var Tk = (l) => {
  throw TypeError(l);
};
var XK = (l, Z, u) => Z.has(l) || Tk("Cannot " + u);
var ll = (l, Z, u) => (XK(l, Z, "read from private field"), u ? u.call(l) : Z.get(l)), ZZ = (l, Z, u) => Z.has(l) ? Tk("Cannot add the same private member more than once") : Z instanceof WeakSet ? Z.add(l) : Z.set(l, u), vl = (l, Z, u, s) => (XK(l, Z, "write to private field"), s ? s.call(l, u) : Z.set(l, u), u), XZ = (l, Z, u) => (XK(l, Z, "access private method"), u);
var gL = (l, Z, u, s) => ({
  set _(G) {
    vl(l, Z, G, u);
  },
  get _() {
    return ll(l, Z, s);
  }
});
function wh(l) {
  return l && l.__esModule && Object.prototype.hasOwnProperty.call(l, "default") ? l.default : l;
}
var fI = { exports: {} }, EI = { exports: {} }, Ya = { exports: {} };
Ya.exports;
var fk;
function YT() {
  return fk || (fk = 1, function(l, Z) {
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var u = "18.3.1", s = Symbol.for("react.element"), G = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), n = Symbol.for("react.provider"), p = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), t = Symbol.for("react.memo"), W = Symbol.for("react.lazy"), V = Symbol.for("react.offscreen"), R = Symbol.iterator, x = "@@iterator";
      function r(I) {
        if (I === null || typeof I != "object")
          return null;
        var Q = R && I[R] || I[x];
        return typeof Q == "function" ? Q : null;
      }
      var k = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, U = {
        transition: null
      }, w = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, z = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, D = {}, C = null;
      function j(I) {
        C = I;
      }
      D.setExtraStackFrame = function(I) {
        C = I;
      }, D.getCurrentStack = null, D.getStackAddendum = function() {
        var I = "";
        C && (I += C);
        var Q = D.getCurrentStack;
        return Q && (I += Q() || ""), I;
      };
      var E = !1, g = !1, A = !1, J = !1, F = !1, v = {
        ReactCurrentDispatcher: k,
        ReactCurrentBatchConfig: U,
        ReactCurrentOwner: z
      };
      v.ReactDebugCurrentFrame = D, v.ReactCurrentActQueue = w;
      function T(I) {
        {
          for (var Q = arguments.length, dl = new Array(Q > 1 ? Q - 1 : 0), al = 1; al < Q; al++)
            dl[al - 1] = arguments[al];
          O("warn", I, dl);
        }
      }
      function f(I) {
        {
          for (var Q = arguments.length, dl = new Array(Q > 1 ? Q - 1 : 0), al = 1; al < Q; al++)
            dl[al - 1] = arguments[al];
          O("error", I, dl);
        }
      }
      function O(I, Q, dl) {
        {
          var al = v.ReactDebugCurrentFrame, Yl = al.getStackAddendum();
          Yl !== "" && (Q += "%s", dl = dl.concat([Yl]));
          var Ol = dl.map(function(gl) {
            return String(gl);
          });
          Ol.unshift("Warning: " + Q), Function.prototype.apply.call(console[I], console, Ol);
        }
      }
      var _ = {};
      function il(I, Q) {
        {
          var dl = I.constructor, al = dl && (dl.displayName || dl.name) || "ReactClass", Yl = al + "." + Q;
          if (_[Yl])
            return;
          f("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Q, al), _[Yl] = !0;
        }
      }
      var Zl = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(I) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(I, Q, dl) {
          il(I, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(I, Q, dl, al) {
          il(I, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(I, Q, dl, al) {
          il(I, "setState");
        }
      }, ol = Object.assign, Wl = {};
      Object.freeze(Wl);
      function ml(I, Q, dl) {
        this.props = I, this.context = Q, this.refs = Wl, this.updater = dl || Zl;
      }
      ml.prototype.isReactComponent = {}, ml.prototype.setState = function(I, Q) {
        if (typeof I != "object" && typeof I != "function" && I != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, I, Q, "setState");
      }, ml.prototype.forceUpdate = function(I) {
        this.updater.enqueueForceUpdate(this, I, "forceUpdate");
      };
      {
        var Rl = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, kl = function(I, Q) {
          Object.defineProperty(ml.prototype, I, {
            get: function() {
              T("%s(...) is deprecated in plain JavaScript React classes. %s", Q[0], Q[1]);
            }
          });
        };
        for (var zl in Rl)
          Rl.hasOwnProperty(zl) && kl(zl, Rl[zl]);
      }
      function Vl() {
      }
      Vl.prototype = ml.prototype;
      function el(I, Q, dl) {
        this.props = I, this.context = Q, this.refs = Wl, this.updater = dl || Zl;
      }
      var xl = el.prototype = new Vl();
      xl.constructor = el, ol(xl, ml.prototype), xl.isPureReactComponent = !0;
      function hl() {
        var I = {
          current: null
        };
        return Object.seal(I), I;
      }
      var cl = Array.isArray;
      function wl(I) {
        return cl(I);
      }
      function Jl(I) {
        {
          var Q = typeof Symbol == "function" && Symbol.toStringTag, dl = Q && I[Symbol.toStringTag] || I.constructor.name || "Object";
          return dl;
        }
      }
      function cZ(I) {
        try {
          return uZ(I), !1;
        } catch {
          return !0;
        }
      }
      function uZ(I) {
        return "" + I;
      }
      function UZ(I) {
        if (cZ(I))
          return f("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Jl(I)), uZ(I);
      }
      function hc(I, Q, dl) {
        var al = I.displayName;
        if (al)
          return al;
        var Yl = Q.displayName || Q.name || "";
        return Yl !== "" ? dl + "(" + Yl + ")" : dl;
      }
      function Zb(I) {
        return I.displayName || "Context";
      }
      function yc(I) {
        if (I == null)
          return null;
        if (typeof I.tag == "number" && f("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof I == "function")
          return I.displayName || I.name || null;
        if (typeof I == "string")
          return I;
        switch (I) {
          case i:
            return "Fragment";
          case G:
            return "Portal";
          case a:
            return "Profiler";
          case m:
            return "StrictMode";
          case h:
            return "Suspense";
          case S:
            return "SuspenseList";
        }
        if (typeof I == "object")
          switch (I.$$typeof) {
            case p:
              var Q = I;
              return Zb(Q) + ".Consumer";
            case n:
              var dl = I;
              return Zb(dl._context) + ".Provider";
            case y:
              return hc(I, I.render, "ForwardRef");
            case t:
              var al = I.displayName || null;
              return al !== null ? al : yc(I.type) || "Memo";
            case W: {
              var Yl = I, Ol = Yl._payload, gl = Yl._init;
              try {
                return yc(gl(Ol));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var nb = Object.prototype.hasOwnProperty, Nc = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, oc, cb, sc;
      sc = {};
      function Vc(I) {
        if (nb.call(I, "ref")) {
          var Q = Object.getOwnPropertyDescriptor(I, "ref").get;
          if (Q && Q.isReactWarning)
            return !1;
        }
        return I.ref !== void 0;
      }
      function BZ(I) {
        if (nb.call(I, "key")) {
          var Q = Object.getOwnPropertyDescriptor(I, "key").get;
          if (Q && Q.isReactWarning)
            return !1;
        }
        return I.key !== void 0;
      }
      function Rb(I, Q) {
        var dl = function() {
          oc || (oc = !0, f("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        dl.isReactWarning = !0, Object.defineProperty(I, "key", {
          get: dl,
          configurable: !0
        });
      }
      function Tb(I, Q) {
        var dl = function() {
          cb || (cb = !0, f("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Q));
        };
        dl.isReactWarning = !0, Object.defineProperty(I, "ref", {
          get: dl,
          configurable: !0
        });
      }
      function tu(I) {
        if (typeof I.ref == "string" && z.current && I.__self && z.current.stateNode !== I.__self) {
          var Q = yc(z.current.type);
          sc[Q] || (f('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Q, I.ref), sc[Q] = !0);
        }
      }
      var Il = function(I, Q, dl, al, Yl, Ol, gl) {
        var $l = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: s,
          // Built-in properties that belong on the element
          type: I,
          key: Q,
          ref: dl,
          props: gl,
          // Record the component responsible for creating this element.
          _owner: Ol
        };
        return $l._store = {}, Object.defineProperty($l._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty($l, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: al
        }), Object.defineProperty($l, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Yl
        }), Object.freeze && (Object.freeze($l.props), Object.freeze($l)), $l;
      };
      function El(I, Q, dl) {
        var al, Yl = {}, Ol = null, gl = null, $l = null, nZ = null;
        if (Q != null) {
          Vc(Q) && (gl = Q.ref, tu(Q)), BZ(Q) && (UZ(Q.key), Ol = "" + Q.key), $l = Q.__self === void 0 ? null : Q.__self, nZ = Q.__source === void 0 ? null : Q.__source;
          for (al in Q)
            nb.call(Q, al) && !Nc.hasOwnProperty(al) && (Yl[al] = Q[al]);
        }
        var CZ = arguments.length - 2;
        if (CZ === 1)
          Yl.children = dl;
        else if (CZ > 1) {
          for (var TZ = Array(CZ), fZ = 0; fZ < CZ; fZ++)
            TZ[fZ] = arguments[fZ + 2];
          Object.freeze && Object.freeze(TZ), Yl.children = TZ;
        }
        if (I && I.defaultProps) {
          var AZ = I.defaultProps;
          for (al in AZ)
            Yl[al] === void 0 && (Yl[al] = AZ[al]);
        }
        if (Ol || gl) {
          var dc = typeof I == "function" ? I.displayName || I.name || "Unknown" : I;
          Ol && Rb(Yl, dc), gl && Tb(Yl, dc);
        }
        return Il(I, Ol, gl, $l, nZ, z.current, Yl);
      }
      function sZ(I, Q) {
        var dl = Il(I.type, Q, I.ref, I._self, I._source, I._owner, I.props);
        return dl;
      }
      function YZ(I, Q, dl) {
        if (I == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + I + ".");
        var al, Yl = ol({}, I.props), Ol = I.key, gl = I.ref, $l = I._self, nZ = I._source, CZ = I._owner;
        if (Q != null) {
          Vc(Q) && (gl = Q.ref, CZ = z.current), BZ(Q) && (UZ(Q.key), Ol = "" + Q.key);
          var TZ;
          I.type && I.type.defaultProps && (TZ = I.type.defaultProps);
          for (al in Q)
            nb.call(Q, al) && !Nc.hasOwnProperty(al) && (Q[al] === void 0 && TZ !== void 0 ? Yl[al] = TZ[al] : Yl[al] = Q[al]);
        }
        var fZ = arguments.length - 2;
        if (fZ === 1)
          Yl.children = dl;
        else if (fZ > 1) {
          for (var AZ = Array(fZ), dc = 0; dc < fZ; dc++)
            AZ[dc] = arguments[dc + 2];
          Yl.children = AZ;
        }
        return Il(I.type, Ol, gl, $l, nZ, CZ, Yl);
      }
      function kZ(I) {
        return typeof I == "object" && I !== null && I.$$typeof === s;
      }
      var ec = ".", Zc = ":";
      function bb(I) {
        var Q = /[=:]/g, dl = {
          "=": "=0",
          ":": "=2"
        }, al = I.replace(Q, function(Yl) {
          return dl[Yl];
        });
        return "$" + al;
      }
      var zZ = !1, pb = /\/+/g;
      function gZ(I) {
        return I.replace(pb, "$&/");
      }
      function vZ(I, Q) {
        return typeof I == "object" && I !== null && I.key != null ? (UZ(I.key), bb("" + I.key)) : Q.toString(36);
      }
      function cu(I, Q, dl, al, Yl) {
        var Ol = typeof I;
        (Ol === "undefined" || Ol === "boolean") && (I = null);
        var gl = !1;
        if (I === null)
          gl = !0;
        else
          switch (Ol) {
            case "string":
            case "number":
              gl = !0;
              break;
            case "object":
              switch (I.$$typeof) {
                case s:
                case G:
                  gl = !0;
              }
          }
        if (gl) {
          var $l = I, nZ = Yl($l), CZ = al === "" ? ec + vZ($l, 0) : al;
          if (wl(nZ)) {
            var TZ = "";
            CZ != null && (TZ = gZ(CZ) + "/"), cu(nZ, Q, TZ, "", function(ty) {
              return ty;
            });
          } else nZ != null && (kZ(nZ) && (nZ.key && (!$l || $l.key !== nZ.key) && UZ(nZ.key), nZ = sZ(
            nZ,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            dl + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (nZ.key && (!$l || $l.key !== nZ.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              gZ("" + nZ.key) + "/"
            ) : "") + CZ
          )), Q.push(nZ));
          return 1;
        }
        var fZ, AZ, dc = 0, xZ = al === "" ? ec : al + Zc;
        if (wl(I))
          for (var Md = 0; Md < I.length; Md++)
            fZ = I[Md], AZ = xZ + vZ(fZ, Md), dc += cu(fZ, Q, dl, AZ, Yl);
        else {
          var Tm = r(I);
          if (typeof Tm == "function") {
            var Jo = I;
            Tm === Jo.entries && (zZ || T("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), zZ = !0);
            for (var Sy = Tm.call(Jo), Us, Ho = 0; !(Us = Sy.next()).done; )
              fZ = Us.value, AZ = xZ + vZ(fZ, Ho++), dc += cu(fZ, Q, dl, AZ, Yl);
          } else if (Ol === "object") {
            var go = String(I);
            throw new Error("Objects are not valid as a React child (found: " + (go === "[object Object]" ? "object with keys {" + Object.keys(I).join(", ") + "}" : go) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return dc;
      }
      function Yb(I, Q, dl) {
        if (I == null)
          return I;
        var al = [], Yl = 0;
        return cu(I, al, "", "", function(Ol) {
          return Q.call(dl, Ol, Yl++);
        }), al;
      }
      function Rs(I) {
        var Q = 0;
        return Yb(I, function() {
          Q++;
        }), Q;
      }
      function Xd(I, Q, dl) {
        Yb(I, function() {
          Q.apply(this, arguments);
        }, dl);
      }
      function tG(I) {
        return Yb(I, function(Q) {
          return Q;
        }) || [];
      }
      function Ys(I) {
        if (!kZ(I))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return I;
      }
      function ks(I) {
        var Q = {
          $$typeof: p,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: I,
          _currentValue2: I,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Q.Provider = {
          $$typeof: n,
          _context: Q
        };
        var dl = !1, al = !1, Yl = !1;
        {
          var Ol = {
            $$typeof: p,
            _context: Q
          };
          Object.defineProperties(Ol, {
            Provider: {
              get: function() {
                return al || (al = !0, f("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Q.Provider;
              },
              set: function(gl) {
                Q.Provider = gl;
              }
            },
            _currentValue: {
              get: function() {
                return Q._currentValue;
              },
              set: function(gl) {
                Q._currentValue = gl;
              }
            },
            _currentValue2: {
              get: function() {
                return Q._currentValue2;
              },
              set: function(gl) {
                Q._currentValue2 = gl;
              }
            },
            _threadCount: {
              get: function() {
                return Q._threadCount;
              },
              set: function(gl) {
                Q._threadCount = gl;
              }
            },
            Consumer: {
              get: function() {
                return dl || (dl = !0, f("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Q.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Q.displayName;
              },
              set: function(gl) {
                Yl || (T("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", gl), Yl = !0);
              }
            }
          }), Q.Consumer = Ol;
        }
        return Q._currentRenderer = null, Q._currentRenderer2 = null, Q;
      }
      var Xu = -1, Qu = 0, Ku = 1, fb = 2;
      function Eb(I) {
        if (I._status === Xu) {
          var Q = I._result, dl = Q();
          if (dl.then(function(Ol) {
            if (I._status === Qu || I._status === Xu) {
              var gl = I;
              gl._status = Ku, gl._result = Ol;
            }
          }, function(Ol) {
            if (I._status === Qu || I._status === Xu) {
              var gl = I;
              gl._status = fb, gl._result = Ol;
            }
          }), I._status === Xu) {
            var al = I;
            al._status = Qu, al._result = dl;
          }
        }
        if (I._status === Ku) {
          var Yl = I._result;
          return Yl === void 0 && f(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Yl), "default" in Yl || f(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Yl), Yl.default;
        } else
          throw I._result;
      }
      function bu(I) {
        var Q = {
          // We use these fields to store the result.
          _status: Xu,
          _result: I
        }, dl = {
          $$typeof: W,
          _payload: Q,
          _init: Eb
        };
        {
          var al, Yl;
          Object.defineProperties(dl, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return al;
              },
              set: function(Ol) {
                f("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), al = Ol, Object.defineProperty(dl, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Yl;
              },
              set: function(Ol) {
                f("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Yl = Ol, Object.defineProperty(dl, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return dl;
      }
      function Ms(I) {
        I != null && I.$$typeof === t ? f("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof I != "function" ? f("forwardRef requires a render function but was given %s.", I === null ? "null" : typeof I) : I.length !== 0 && I.length !== 2 && f("forwardRef render functions accept exactly two parameters: props and ref. %s", I.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), I != null && (I.defaultProps != null || I.propTypes != null) && f("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Q = {
          $$typeof: y,
          render: I
        };
        {
          var dl;
          Object.defineProperty(Q, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return dl;
            },
            set: function(al) {
              dl = al, !I.name && !I.displayName && (I.displayName = al);
            }
          });
        }
        return Q;
      }
      var Pu;
      Pu = Symbol.for("react.module.reference");
      function P(I) {
        return !!(typeof I == "string" || typeof I == "function" || I === i || I === a || F || I === m || I === h || I === S || J || I === V || E || g || A || typeof I == "object" && I !== null && (I.$$typeof === W || I.$$typeof === t || I.$$typeof === n || I.$$typeof === p || I.$$typeof === y || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        I.$$typeof === Pu || I.getModuleId !== void 0));
      }
      function yl(I, Q) {
        P(I) || f("memo: The first argument must be a component. Instead received: %s", I === null ? "null" : typeof I);
        var dl = {
          $$typeof: t,
          type: I,
          compare: Q === void 0 ? null : Q
        };
        {
          var al;
          Object.defineProperty(dl, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return al;
            },
            set: function(Yl) {
              al = Yl, !I.name && !I.displayName && (I.displayName = Yl);
            }
          });
        }
        return dl;
      }
      function Kl() {
        var I = k.current;
        return I === null && f(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), I;
      }
      function Bl(I) {
        var Q = Kl();
        if (I._context !== void 0) {
          var dl = I._context;
          dl.Consumer === I ? f("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : dl.Provider === I && f("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Q.useContext(I);
      }
      function oZ(I) {
        var Q = Kl();
        return Q.useState(I);
      }
      function aZ(I, Q, dl) {
        var al = Kl();
        return al.useReducer(I, Q, dl);
      }
      function jl(I) {
        var Q = Kl();
        return Q.useRef(I);
      }
      function dZ(I, Q) {
        var dl = Kl();
        return dl.useEffect(I, Q);
      }
      function ac(I, Q) {
        var dl = Kl();
        return dl.useInsertionEffect(I, Q);
      }
      function JZ(I, Q) {
        var dl = Kl();
        return dl.useLayoutEffect(I, Q);
      }
      function DZ(I, Q) {
        var dl = Kl();
        return dl.useCallback(I, Q);
      }
      function xc(I, Q) {
        var dl = Kl();
        return dl.useMemo(I, Q);
      }
      function uu(I, Q, dl) {
        var al = Kl();
        return al.useImperativeHandle(I, Q, dl);
      }
      function kb(I, Q) {
        {
          var dl = Kl();
          return dl.useDebugValue(I, Q);
        }
      }
      function Sc() {
        var I = Kl();
        return I.useTransition();
      }
      function Lb(I) {
        var Q = Kl();
        return Q.useDeferredValue(I);
      }
      function GZ() {
        var I = Kl();
        return I.useId();
      }
      function Wu(I, Q, dl) {
        var al = Kl();
        return al.useSyncExternalStore(I, Q, dl);
      }
      var Ou = 0, Kd, XG, KG, WG, VG, xG, RG;
      function wm() {
      }
      wm.__reactDisabledLog = !0;
      function Co() {
        {
          if (Ou === 0) {
            Kd = console.log, XG = console.info, KG = console.warn, WG = console.error, VG = console.group, xG = console.groupCollapsed, RG = console.groupEnd;
            var I = {
              configurable: !0,
              enumerable: !0,
              value: wm,
              writable: !0
            };
            Object.defineProperties(console, {
              info: I,
              log: I,
              warn: I,
              error: I,
              group: I,
              groupCollapsed: I,
              groupEnd: I
            });
          }
          Ou++;
        }
      }
      function YG() {
        {
          if (Ou--, Ou === 0) {
            var I = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ol({}, I, {
                value: Kd
              }),
              info: ol({}, I, {
                value: XG
              }),
              warn: ol({}, I, {
                value: KG
              }),
              error: ol({}, I, {
                value: WG
              }),
              group: ol({}, I, {
                value: VG
              }),
              groupCollapsed: ol({}, I, {
                value: xG
              }),
              groupEnd: ol({}, I, {
                value: RG
              })
            });
          }
          Ou < 0 && f("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Vu = v.ReactCurrentDispatcher, Mb;
      function Wd(I, Q, dl) {
        {
          if (Mb === void 0)
            try {
              throw Error();
            } catch (Yl) {
              var al = Yl.stack.trim().match(/\n( *(at )?)/);
              Mb = al && al[1] || "";
            }
          return `
` + Mb + I;
        }
      }
      var Vd = !1, zm;
      {
        var ro = typeof WeakMap == "function" ? WeakMap : Map;
        zm = new ro();
      }
      function kn(I, Q) {
        if (!I || Vd)
          return "";
        {
          var dl = zm.get(I);
          if (dl !== void 0)
            return dl;
        }
        var al;
        Vd = !0;
        var Yl = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Ol;
        Ol = Vu.current, Vu.current = null, Co();
        try {
          if (Q) {
            var gl = function() {
              throw Error();
            };
            if (Object.defineProperty(gl.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(gl, []);
              } catch (xZ) {
                al = xZ;
              }
              Reflect.construct(I, [], gl);
            } else {
              try {
                gl.call();
              } catch (xZ) {
                al = xZ;
              }
              I.call(gl.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (xZ) {
              al = xZ;
            }
            I();
          }
        } catch (xZ) {
          if (xZ && al && typeof xZ.stack == "string") {
            for (var $l = xZ.stack.split(`
`), nZ = al.stack.split(`
`), CZ = $l.length - 1, TZ = nZ.length - 1; CZ >= 1 && TZ >= 0 && $l[CZ] !== nZ[TZ]; )
              TZ--;
            for (; CZ >= 1 && TZ >= 0; CZ--, TZ--)
              if ($l[CZ] !== nZ[TZ]) {
                if (CZ !== 1 || TZ !== 1)
                  do
                    if (CZ--, TZ--, TZ < 0 || $l[CZ] !== nZ[TZ]) {
                      var fZ = `
` + $l[CZ].replace(" at new ", " at ");
                      return I.displayName && fZ.includes("<anonymous>") && (fZ = fZ.replace("<anonymous>", I.displayName)), typeof I == "function" && zm.set(I, fZ), fZ;
                    }
                  while (CZ >= 1 && TZ >= 0);
                break;
              }
          }
        } finally {
          Vd = !1, Vu.current = Ol, YG(), Error.prepareStackTrace = Yl;
        }
        var AZ = I ? I.displayName || I.name : "", dc = AZ ? Wd(AZ) : "";
        return typeof I == "function" && zm.set(I, dc), dc;
      }
      function Fo(I, Q, dl) {
        return kn(I, !1);
      }
      function hy(I) {
        var Q = I.prototype;
        return !!(Q && Q.isReactComponent);
      }
      function xd(I, Q, dl) {
        if (I == null)
          return "";
        if (typeof I == "function")
          return kn(I, hy(I));
        if (typeof I == "string")
          return Wd(I);
        switch (I) {
          case h:
            return Wd("Suspense");
          case S:
            return Wd("SuspenseList");
        }
        if (typeof I == "object")
          switch (I.$$typeof) {
            case y:
              return Fo(I.render);
            case t:
              return xd(I.type, Q, dl);
            case W: {
              var al = I, Yl = al._payload, Ol = al._init;
              try {
                return xd(Ol(Yl), Q, dl);
              } catch {
              }
            }
          }
        return "";
      }
      var Mn = {}, No = v.ReactDebugCurrentFrame;
      function Jm(I) {
        if (I) {
          var Q = I._owner, dl = xd(I.type, I._source, Q ? Q.type : null);
          No.setExtraStackFrame(dl);
        } else
          No.setExtraStackFrame(null);
      }
      function In(I, Q, dl, al, Yl) {
        {
          var Ol = Function.call.bind(nb);
          for (var gl in I)
            if (Ol(I, gl)) {
              var $l = void 0;
              try {
                if (typeof I[gl] != "function") {
                  var nZ = Error((al || "React class") + ": " + dl + " type `" + gl + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof I[gl] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw nZ.name = "Invariant Violation", nZ;
                }
                $l = I[gl](Q, gl, al, dl, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (CZ) {
                $l = CZ;
              }
              $l && !($l instanceof Error) && (Jm(Yl), f("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", al || "React class", dl, gl, typeof $l), Jm(null)), $l instanceof Error && !($l.message in Mn) && (Mn[$l.message] = !0, Jm(Yl), f("Failed %s type: %s", dl, $l.message), Jm(null));
            }
        }
      }
      function tZ(I) {
        if (I) {
          var Q = I._owner, dl = xd(I.type, I._source, Q ? Q.type : null);
          j(dl);
        } else
          j(null);
      }
      var wo;
      wo = !1;
      function zo() {
        if (z.current) {
          var I = yc(z.current.type);
          if (I)
            return `

Check the render method of \`` + I + "`.";
        }
        return "";
      }
      function bZ(I) {
        if (I !== void 0) {
          var Q = I.fileName.replace(/^.*[\\\/]/, ""), dl = I.lineNumber;
          return `

Check your code at ` + Q + ":" + dl + ".";
        }
        return "";
      }
      function Un(I) {
        return I != null ? bZ(I.__source) : "";
      }
      var ub = {};
      function kG(I) {
        var Q = zo();
        if (!Q) {
          var dl = typeof I == "string" ? I : I.displayName || I.name;
          dl && (Q = `

Check the top-level render call using <` + dl + ">.");
        }
        return Q;
      }
      function Rd(I, Q) {
        if (!(!I._store || I._store.validated || I.key != null)) {
          I._store.validated = !0;
          var dl = kG(Q);
          if (!ub[dl]) {
            ub[dl] = !0;
            var al = "";
            I && I._owner && I._owner !== z.current && (al = " It was passed a child from " + yc(I._owner.type) + "."), tZ(I), f('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', dl, al), tZ(null);
          }
        }
      }
      function Cn(I, Q) {
        if (typeof I == "object") {
          if (wl(I))
            for (var dl = 0; dl < I.length; dl++) {
              var al = I[dl];
              kZ(al) && Rd(al, Q);
            }
          else if (kZ(I))
            I._store && (I._store.validated = !0);
          else if (I) {
            var Yl = r(I);
            if (typeof Yl == "function" && Yl !== I.entries)
              for (var Ol = Yl.call(I), gl; !(gl = Ol.next()).done; )
                kZ(gl.value) && Rd(gl.value, Q);
          }
        }
      }
      function wc(I) {
        {
          var Q = I.type;
          if (Q == null || typeof Q == "string")
            return;
          var dl;
          if (typeof Q == "function")
            dl = Q.propTypes;
          else if (typeof Q == "object" && (Q.$$typeof === y || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Q.$$typeof === t))
            dl = Q.propTypes;
          else
            return;
          if (dl) {
            var al = yc(Q);
            In(dl, I.props, "prop", al, I);
          } else if (Q.PropTypes !== void 0 && !wo) {
            wo = !0;
            var Yl = yc(Q);
            f("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Yl || "Unknown");
          }
          typeof Q.getDefaultProps == "function" && !Q.getDefaultProps.isReactClassApproved && f("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function cc(I) {
        {
          for (var Q = Object.keys(I.props), dl = 0; dl < Q.length; dl++) {
            var al = Q[dl];
            if (al !== "children" && al !== "key") {
              tZ(I), f("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", al), tZ(null);
              break;
            }
          }
          I.ref !== null && (tZ(I), f("Invalid attribute `ref` supplied to `React.Fragment`."), tZ(null));
        }
      }
      function rn(I, Q, dl) {
        var al = P(I);
        if (!al) {
          var Yl = "";
          (I === void 0 || typeof I == "object" && I !== null && Object.keys(I).length === 0) && (Yl += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ol = Un(Q);
          Ol ? Yl += Ol : Yl += zo();
          var gl;
          I === null ? gl = "null" : wl(I) ? gl = "array" : I !== void 0 && I.$$typeof === s ? (gl = "<" + (yc(I.type) || "Unknown") + " />", Yl = " Did you accidentally export a JSX literal instead of a component?") : gl = typeof I, f("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", gl, Yl);
        }
        var $l = El.apply(this, arguments);
        if ($l == null)
          return $l;
        if (al)
          for (var nZ = 2; nZ < arguments.length; nZ++)
            Cn(arguments[nZ], I);
        return I === i ? cc($l) : wc($l), $l;
      }
      var Bb = !1;
      function Ib(I) {
        var Q = rn.bind(null, I);
        return Q.type = I, Bb || (Bb = !0, T("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Q, "type", {
          enumerable: !1,
          get: function() {
            return T("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: I
            }), I;
          }
        }), Q;
      }
      function Au(I, Q, dl) {
        for (var al = YZ.apply(this, arguments), Yl = 2; Yl < arguments.length; Yl++)
          Cn(arguments[Yl], al.type);
        return wc(al), al;
      }
      function yy(I, Q) {
        var dl = U.transition;
        U.transition = {};
        var al = U.transition;
        U.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          I();
        } finally {
          if (U.transition = dl, dl === null && al._updatedFibers) {
            var Yl = al._updatedFibers.size;
            Yl > 10 && T("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), al._updatedFibers.clear();
          }
        }
      }
      var Hm = !1, MG = null;
      function Fn(I) {
        if (MG === null)
          try {
            var Q = ("require" + Math.random()).slice(0, 7), dl = l && l[Q];
            MG = dl.call(l, "timers").setImmediate;
          } catch {
            MG = function(Yl) {
              Hm === !1 && (Hm = !0, typeof MessageChannel > "u" && f("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Ol = new MessageChannel();
              Ol.port1.onmessage = Yl, Ol.port2.postMessage(void 0);
            };
          }
        return MG(I);
      }
      var Yd = 0, Nn = !1;
      function wn(I) {
        {
          var Q = Yd;
          Yd++, w.current === null && (w.current = []);
          var dl = w.isBatchingLegacy, al;
          try {
            if (w.isBatchingLegacy = !0, al = I(), !dl && w.didScheduleLegacyUpdate) {
              var Yl = w.current;
              Yl !== null && (w.didScheduleLegacyUpdate = !1, vm(Yl));
            }
          } catch (AZ) {
            throw Is(Q), AZ;
          } finally {
            w.isBatchingLegacy = dl;
          }
          if (al !== null && typeof al == "object" && typeof al.then == "function") {
            var Ol = al, gl = !1, $l = {
              then: function(AZ, dc) {
                gl = !0, Ol.then(function(xZ) {
                  Is(Q), Yd === 0 ? gm(xZ, AZ, dc) : AZ(xZ);
                }, function(xZ) {
                  Is(Q), dc(xZ);
                });
              }
            };
            return !Nn && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              gl || (Nn = !0, f("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), $l;
          } else {
            var nZ = al;
            if (Is(Q), Yd === 0) {
              var CZ = w.current;
              CZ !== null && (vm(CZ), w.current = null);
              var TZ = {
                then: function(AZ, dc) {
                  w.current === null ? (w.current = [], gm(nZ, AZ, dc)) : AZ(nZ);
                }
              };
              return TZ;
            } else {
              var fZ = {
                then: function(AZ, dc) {
                  AZ(nZ);
                }
              };
              return fZ;
            }
          }
        }
      }
      function Is(I) {
        I !== Yd - 1 && f("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Yd = I;
      }
      function gm(I, Q, dl) {
        {
          var al = w.current;
          if (al !== null)
            try {
              vm(al), Fn(function() {
                al.length === 0 ? (w.current = null, Q(I)) : gm(I, Q, dl);
              });
            } catch (Yl) {
              dl(Yl);
            }
          else
            Q(I);
        }
      }
      var kd = !1;
      function vm(I) {
        if (!kd) {
          kd = !0;
          var Q = 0;
          try {
            for (; Q < I.length; Q++) {
              var dl = I[Q];
              do
                dl = dl(!0);
              while (dl !== null);
            }
            I.length = 0;
          } catch (al) {
            throw I = I.slice(Q + 1), al;
          } finally {
            kd = !1;
          }
        }
      }
      var zn = rn, Jn = Au, Hn = Ib, gn = {
        map: Yb,
        forEach: Xd,
        count: Rs,
        toArray: tG,
        only: Ys
      };
      Z.Children = gn, Z.Component = ml, Z.Fragment = i, Z.Profiler = a, Z.PureComponent = el, Z.StrictMode = m, Z.Suspense = h, Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = v, Z.act = wn, Z.cloneElement = Jn, Z.createContext = ks, Z.createElement = zn, Z.createFactory = Hn, Z.createRef = hl, Z.forwardRef = Ms, Z.isValidElement = kZ, Z.lazy = bu, Z.memo = yl, Z.startTransition = yy, Z.unstable_act = wn, Z.useCallback = DZ, Z.useContext = Bl, Z.useDebugValue = kb, Z.useDeferredValue = Lb, Z.useEffect = dZ, Z.useId = GZ, Z.useImperativeHandle = uu, Z.useInsertionEffect = ac, Z.useLayoutEffect = JZ, Z.useMemo = xc, Z.useReducer = aZ, Z.useRef = jl, Z.useState = oZ, Z.useSyncExternalStore = Wu, Z.useTransition = Sc, Z.version = u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    })();
  }(Ya, Ya.exports)), Ya.exports;
}
EI.exports = YT();
var M = EI.exports;
const tl = /* @__PURE__ */ wh(M);
var La = {}, Ek;
function kT() {
  if (Ek) return La;
  Ek = 1;
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return function() {
    var l = M, Z = Symbol.for("react.element"), u = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), G = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), a = Symbol.for("react.context"), n = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), W = Symbol.iterator, V = "@@iterator";
    function R(P) {
      if (P === null || typeof P != "object")
        return null;
      var yl = W && P[W] || P[V];
      return typeof yl == "function" ? yl : null;
    }
    var x = l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function r(P) {
      {
        for (var yl = arguments.length, Kl = new Array(yl > 1 ? yl - 1 : 0), Bl = 1; Bl < yl; Bl++)
          Kl[Bl - 1] = arguments[Bl];
        k("error", P, Kl);
      }
    }
    function k(P, yl, Kl) {
      {
        var Bl = x.ReactDebugCurrentFrame, oZ = Bl.getStackAddendum();
        oZ !== "" && (yl += "%s", Kl = Kl.concat([oZ]));
        var aZ = Kl.map(function(jl) {
          return String(jl);
        });
        aZ.unshift("Warning: " + yl), Function.prototype.apply.call(console[P], console, aZ);
      }
    }
    var U = !1, w = !1, z = !1, D = !1, C = !1, j;
    j = Symbol.for("react.module.reference");
    function E(P) {
      return !!(typeof P == "string" || typeof P == "function" || P === s || P === i || C || P === G || P === p || P === y || D || P === t || U || w || z || typeof P == "object" && P !== null && (P.$$typeof === S || P.$$typeof === h || P.$$typeof === m || P.$$typeof === a || P.$$typeof === n || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      P.$$typeof === j || P.getModuleId !== void 0));
    }
    function g(P, yl, Kl) {
      var Bl = P.displayName;
      if (Bl)
        return Bl;
      var oZ = yl.displayName || yl.name || "";
      return oZ !== "" ? Kl + "(" + oZ + ")" : Kl;
    }
    function A(P) {
      return P.displayName || "Context";
    }
    function J(P) {
      if (P == null)
        return null;
      if (typeof P.tag == "number" && r("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
        return P.displayName || P.name || null;
      if (typeof P == "string")
        return P;
      switch (P) {
        case s:
          return "Fragment";
        case u:
          return "Portal";
        case i:
          return "Profiler";
        case G:
          return "StrictMode";
        case p:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case a:
            var yl = P;
            return A(yl) + ".Consumer";
          case m:
            var Kl = P;
            return A(Kl._context) + ".Provider";
          case n:
            return g(P, P.render, "ForwardRef");
          case h:
            var Bl = P.displayName || null;
            return Bl !== null ? Bl : J(P.type) || "Memo";
          case S: {
            var oZ = P, aZ = oZ._payload, jl = oZ._init;
            try {
              return J(jl(aZ));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, v = 0, T, f, O, _, il, Zl, ol;
    function Wl() {
    }
    Wl.__reactDisabledLog = !0;
    function ml() {
      {
        if (v === 0) {
          T = console.log, f = console.info, O = console.warn, _ = console.error, il = console.group, Zl = console.groupCollapsed, ol = console.groupEnd;
          var P = {
            configurable: !0,
            enumerable: !0,
            value: Wl,
            writable: !0
          };
          Object.defineProperties(console, {
            info: P,
            log: P,
            warn: P,
            error: P,
            group: P,
            groupCollapsed: P,
            groupEnd: P
          });
        }
        v++;
      }
    }
    function Rl() {
      {
        if (v--, v === 0) {
          var P = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: F({}, P, {
              value: T
            }),
            info: F({}, P, {
              value: f
            }),
            warn: F({}, P, {
              value: O
            }),
            error: F({}, P, {
              value: _
            }),
            group: F({}, P, {
              value: il
            }),
            groupCollapsed: F({}, P, {
              value: Zl
            }),
            groupEnd: F({}, P, {
              value: ol
            })
          });
        }
        v < 0 && r("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var kl = x.ReactCurrentDispatcher, zl;
    function Vl(P, yl, Kl) {
      {
        if (zl === void 0)
          try {
            throw Error();
          } catch (oZ) {
            var Bl = oZ.stack.trim().match(/\n( *(at )?)/);
            zl = Bl && Bl[1] || "";
          }
        return `
` + zl + P;
      }
    }
    var el = !1, xl;
    {
      var hl = typeof WeakMap == "function" ? WeakMap : Map;
      xl = new hl();
    }
    function cl(P, yl) {
      if (!P || el)
        return "";
      {
        var Kl = xl.get(P);
        if (Kl !== void 0)
          return Kl;
      }
      var Bl;
      el = !0;
      var oZ = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var aZ;
      aZ = kl.current, kl.current = null, ml();
      try {
        if (yl) {
          var jl = function() {
            throw Error();
          };
          if (Object.defineProperty(jl.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(jl, []);
            } catch (Sc) {
              Bl = Sc;
            }
            Reflect.construct(P, [], jl);
          } else {
            try {
              jl.call();
            } catch (Sc) {
              Bl = Sc;
            }
            P.call(jl.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Sc) {
            Bl = Sc;
          }
          P();
        }
      } catch (Sc) {
        if (Sc && Bl && typeof Sc.stack == "string") {
          for (var dZ = Sc.stack.split(`
`), ac = Bl.stack.split(`
`), JZ = dZ.length - 1, DZ = ac.length - 1; JZ >= 1 && DZ >= 0 && dZ[JZ] !== ac[DZ]; )
            DZ--;
          for (; JZ >= 1 && DZ >= 0; JZ--, DZ--)
            if (dZ[JZ] !== ac[DZ]) {
              if (JZ !== 1 || DZ !== 1)
                do
                  if (JZ--, DZ--, DZ < 0 || dZ[JZ] !== ac[DZ]) {
                    var xc = `
` + dZ[JZ].replace(" at new ", " at ");
                    return P.displayName && xc.includes("<anonymous>") && (xc = xc.replace("<anonymous>", P.displayName)), typeof P == "function" && xl.set(P, xc), xc;
                  }
                while (JZ >= 1 && DZ >= 0);
              break;
            }
        }
      } finally {
        el = !1, kl.current = aZ, Rl(), Error.prepareStackTrace = oZ;
      }
      var uu = P ? P.displayName || P.name : "", kb = uu ? Vl(uu) : "";
      return typeof P == "function" && xl.set(P, kb), kb;
    }
    function wl(P, yl, Kl) {
      return cl(P, !1);
    }
    function Jl(P) {
      var yl = P.prototype;
      return !!(yl && yl.isReactComponent);
    }
    function cZ(P, yl, Kl) {
      if (P == null)
        return "";
      if (typeof P == "function")
        return cl(P, Jl(P));
      if (typeof P == "string")
        return Vl(P);
      switch (P) {
        case p:
          return Vl("Suspense");
        case y:
          return Vl("SuspenseList");
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case n:
            return wl(P.render);
          case h:
            return cZ(P.type, yl, Kl);
          case S: {
            var Bl = P, oZ = Bl._payload, aZ = Bl._init;
            try {
              return cZ(aZ(oZ), yl, Kl);
            } catch {
            }
          }
        }
      return "";
    }
    var uZ = Object.prototype.hasOwnProperty, UZ = {}, hc = x.ReactDebugCurrentFrame;
    function Zb(P) {
      if (P) {
        var yl = P._owner, Kl = cZ(P.type, P._source, yl ? yl.type : null);
        hc.setExtraStackFrame(Kl);
      } else
        hc.setExtraStackFrame(null);
    }
    function yc(P, yl, Kl, Bl, oZ) {
      {
        var aZ = Function.call.bind(uZ);
        for (var jl in P)
          if (aZ(P, jl)) {
            var dZ = void 0;
            try {
              if (typeof P[jl] != "function") {
                var ac = Error((Bl || "React class") + ": " + Kl + " type `" + jl + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[jl] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ac.name = "Invariant Violation", ac;
              }
              dZ = P[jl](yl, jl, Bl, Kl, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (JZ) {
              dZ = JZ;
            }
            dZ && !(dZ instanceof Error) && (Zb(oZ), r("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Bl || "React class", Kl, jl, typeof dZ), Zb(null)), dZ instanceof Error && !(dZ.message in UZ) && (UZ[dZ.message] = !0, Zb(oZ), r("Failed %s type: %s", Kl, dZ.message), Zb(null));
          }
      }
    }
    var nb = Array.isArray;
    function Nc(P) {
      return nb(P);
    }
    function oc(P) {
      {
        var yl = typeof Symbol == "function" && Symbol.toStringTag, Kl = yl && P[Symbol.toStringTag] || P.constructor.name || "Object";
        return Kl;
      }
    }
    function cb(P) {
      try {
        return sc(P), !1;
      } catch {
        return !0;
      }
    }
    function sc(P) {
      return "" + P;
    }
    function Vc(P) {
      if (cb(P))
        return r("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", oc(P)), sc(P);
    }
    var BZ = x.ReactCurrentOwner, Rb = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Tb, tu, Il;
    Il = {};
    function El(P) {
      if (uZ.call(P, "ref")) {
        var yl = Object.getOwnPropertyDescriptor(P, "ref").get;
        if (yl && yl.isReactWarning)
          return !1;
      }
      return P.ref !== void 0;
    }
    function sZ(P) {
      if (uZ.call(P, "key")) {
        var yl = Object.getOwnPropertyDescriptor(P, "key").get;
        if (yl && yl.isReactWarning)
          return !1;
      }
      return P.key !== void 0;
    }
    function YZ(P, yl) {
      if (typeof P.ref == "string" && BZ.current && yl && BZ.current.stateNode !== yl) {
        var Kl = J(BZ.current.type);
        Il[Kl] || (r('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', J(BZ.current.type), P.ref), Il[Kl] = !0);
      }
    }
    function kZ(P, yl) {
      {
        var Kl = function() {
          Tb || (Tb = !0, r("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", yl));
        };
        Kl.isReactWarning = !0, Object.defineProperty(P, "key", {
          get: Kl,
          configurable: !0
        });
      }
    }
    function ec(P, yl) {
      {
        var Kl = function() {
          tu || (tu = !0, r("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", yl));
        };
        Kl.isReactWarning = !0, Object.defineProperty(P, "ref", {
          get: Kl,
          configurable: !0
        });
      }
    }
    var Zc = function(P, yl, Kl, Bl, oZ, aZ, jl) {
      var dZ = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: Z,
        // Built-in properties that belong on the element
        type: P,
        key: yl,
        ref: Kl,
        props: jl,
        // Record the component responsible for creating this element.
        _owner: aZ
      };
      return dZ._store = {}, Object.defineProperty(dZ._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(dZ, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Bl
      }), Object.defineProperty(dZ, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oZ
      }), Object.freeze && (Object.freeze(dZ.props), Object.freeze(dZ)), dZ;
    };
    function bb(P, yl, Kl, Bl, oZ) {
      {
        var aZ, jl = {}, dZ = null, ac = null;
        Kl !== void 0 && (Vc(Kl), dZ = "" + Kl), sZ(yl) && (Vc(yl.key), dZ = "" + yl.key), El(yl) && (ac = yl.ref, YZ(yl, oZ));
        for (aZ in yl)
          uZ.call(yl, aZ) && !Rb.hasOwnProperty(aZ) && (jl[aZ] = yl[aZ]);
        if (P && P.defaultProps) {
          var JZ = P.defaultProps;
          for (aZ in JZ)
            jl[aZ] === void 0 && (jl[aZ] = JZ[aZ]);
        }
        if (dZ || ac) {
          var DZ = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
          dZ && kZ(jl, DZ), ac && ec(jl, DZ);
        }
        return Zc(P, dZ, ac, oZ, Bl, BZ.current, jl);
      }
    }
    var zZ = x.ReactCurrentOwner, pb = x.ReactDebugCurrentFrame;
    function gZ(P) {
      if (P) {
        var yl = P._owner, Kl = cZ(P.type, P._source, yl ? yl.type : null);
        pb.setExtraStackFrame(Kl);
      } else
        pb.setExtraStackFrame(null);
    }
    var vZ;
    vZ = !1;
    function cu(P) {
      return typeof P == "object" && P !== null && P.$$typeof === Z;
    }
    function Yb() {
      {
        if (zZ.current) {
          var P = J(zZ.current.type);
          if (P)
            return `

Check the render method of \`` + P + "`.";
        }
        return "";
      }
    }
    function Rs(P) {
      return "";
    }
    var Xd = {};
    function tG(P) {
      {
        var yl = Yb();
        if (!yl) {
          var Kl = typeof P == "string" ? P : P.displayName || P.name;
          Kl && (yl = `

Check the top-level render call using <` + Kl + ">.");
        }
        return yl;
      }
    }
    function Ys(P, yl) {
      {
        if (!P._store || P._store.validated || P.key != null)
          return;
        P._store.validated = !0;
        var Kl = tG(yl);
        if (Xd[Kl])
          return;
        Xd[Kl] = !0;
        var Bl = "";
        P && P._owner && P._owner !== zZ.current && (Bl = " It was passed a child from " + J(P._owner.type) + "."), gZ(P), r('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Kl, Bl), gZ(null);
      }
    }
    function ks(P, yl) {
      {
        if (typeof P != "object")
          return;
        if (Nc(P))
          for (var Kl = 0; Kl < P.length; Kl++) {
            var Bl = P[Kl];
            cu(Bl) && Ys(Bl, yl);
          }
        else if (cu(P))
          P._store && (P._store.validated = !0);
        else if (P) {
          var oZ = R(P);
          if (typeof oZ == "function" && oZ !== P.entries)
            for (var aZ = oZ.call(P), jl; !(jl = aZ.next()).done; )
              cu(jl.value) && Ys(jl.value, yl);
        }
      }
    }
    function Xu(P) {
      {
        var yl = P.type;
        if (yl == null || typeof yl == "string")
          return;
        var Kl;
        if (typeof yl == "function")
          Kl = yl.propTypes;
        else if (typeof yl == "object" && (yl.$$typeof === n || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        yl.$$typeof === h))
          Kl = yl.propTypes;
        else
          return;
        if (Kl) {
          var Bl = J(yl);
          yc(Kl, P.props, "prop", Bl, P);
        } else if (yl.PropTypes !== void 0 && !vZ) {
          vZ = !0;
          var oZ = J(yl);
          r("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", oZ || "Unknown");
        }
        typeof yl.getDefaultProps == "function" && !yl.getDefaultProps.isReactClassApproved && r("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Qu(P) {
      {
        for (var yl = Object.keys(P.props), Kl = 0; Kl < yl.length; Kl++) {
          var Bl = yl[Kl];
          if (Bl !== "children" && Bl !== "key") {
            gZ(P), r("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Bl), gZ(null);
            break;
          }
        }
        P.ref !== null && (gZ(P), r("Invalid attribute `ref` supplied to `React.Fragment`."), gZ(null));
      }
    }
    var Ku = {};
    function fb(P, yl, Kl, Bl, oZ, aZ) {
      {
        var jl = E(P);
        if (!jl) {
          var dZ = "";
          (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (dZ += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ac = Rs();
          ac ? dZ += ac : dZ += Yb();
          var JZ;
          P === null ? JZ = "null" : Nc(P) ? JZ = "array" : P !== void 0 && P.$$typeof === Z ? (JZ = "<" + (J(P.type) || "Unknown") + " />", dZ = " Did you accidentally export a JSX literal instead of a component?") : JZ = typeof P, r("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", JZ, dZ);
        }
        var DZ = bb(P, yl, Kl, oZ, aZ);
        if (DZ == null)
          return DZ;
        if (jl) {
          var xc = yl.children;
          if (xc !== void 0)
            if (Bl)
              if (Nc(xc)) {
                for (var uu = 0; uu < xc.length; uu++)
                  ks(xc[uu], P);
                Object.freeze && Object.freeze(xc);
              } else
                r("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ks(xc, P);
        }
        if (uZ.call(yl, "key")) {
          var kb = J(P), Sc = Object.keys(yl).filter(function(Wu) {
            return Wu !== "key";
          }), Lb = Sc.length > 0 ? "{key: someKey, " + Sc.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ku[kb + Lb]) {
            var GZ = Sc.length > 0 ? "{" + Sc.join(": ..., ") + ": ...}" : "{}";
            r(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Lb, kb, GZ, kb), Ku[kb + Lb] = !0;
          }
        }
        return P === s ? Qu(DZ) : Xu(DZ), DZ;
      }
    }
    function Eb(P, yl, Kl) {
      return fb(P, yl, Kl, !0);
    }
    function bu(P, yl, Kl) {
      return fb(P, yl, Kl, !1);
    }
    var Ms = bu, Pu = Eb;
    La.Fragment = s, La.jsx = Ms, La.jsxs = Pu;
  }(), La;
}
fI.exports = kT();
var B = fI.exports, BI = { exports: {} }, KK = { exports: {} }, WK = {}, Bk;
function MT() {
  return Bk || (Bk = 1, function(l) {
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var Z = !1, u = !1, s = 5;
      function G(Il, El) {
        var sZ = Il.length;
        Il.push(El), a(Il, El, sZ);
      }
      function i(Il) {
        return Il.length === 0 ? null : Il[0];
      }
      function m(Il) {
        if (Il.length === 0)
          return null;
        var El = Il[0], sZ = Il.pop();
        return sZ !== El && (Il[0] = sZ, n(Il, sZ, 0)), El;
      }
      function a(Il, El, sZ) {
        for (var YZ = sZ; YZ > 0; ) {
          var kZ = YZ - 1 >>> 1, ec = Il[kZ];
          if (p(ec, El) > 0)
            Il[kZ] = El, Il[YZ] = ec, YZ = kZ;
          else
            return;
        }
      }
      function n(Il, El, sZ) {
        for (var YZ = sZ, kZ = Il.length, ec = kZ >>> 1; YZ < ec; ) {
          var Zc = (YZ + 1) * 2 - 1, bb = Il[Zc], zZ = Zc + 1, pb = Il[zZ];
          if (p(bb, El) < 0)
            zZ < kZ && p(pb, bb) < 0 ? (Il[YZ] = pb, Il[zZ] = El, YZ = zZ) : (Il[YZ] = bb, Il[Zc] = El, YZ = Zc);
          else if (zZ < kZ && p(pb, El) < 0)
            Il[YZ] = pb, Il[zZ] = El, YZ = zZ;
          else
            return;
        }
      }
      function p(Il, El) {
        var sZ = Il.sortIndex - El.sortIndex;
        return sZ !== 0 ? sZ : Il.id - El.id;
      }
      var y = 1, h = 2, S = 3, t = 4, W = 5;
      function V(Il, El) {
      }
      var R = typeof performance == "object" && typeof performance.now == "function";
      if (R) {
        var x = performance;
        l.unstable_now = function() {
          return x.now();
        };
      } else {
        var r = Date, k = r.now();
        l.unstable_now = function() {
          return r.now() - k;
        };
      }
      var U = 1073741823, w = -1, z = 250, D = 5e3, C = 1e4, j = U, E = [], g = [], A = 1, J = null, F = S, v = !1, T = !1, f = !1, O = typeof setTimeout == "function" ? setTimeout : null, _ = typeof clearTimeout == "function" ? clearTimeout : null, il = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function Zl(Il) {
        for (var El = i(g); El !== null; ) {
          if (El.callback === null)
            m(g);
          else if (El.startTime <= Il)
            m(g), El.sortIndex = El.expirationTime, G(E, El);
          else
            return;
          El = i(g);
        }
      }
      function ol(Il) {
        if (f = !1, Zl(Il), !T)
          if (i(E) !== null)
            T = !0, Vc(Wl);
          else {
            var El = i(g);
            El !== null && BZ(ol, El.startTime - Il);
          }
      }
      function Wl(Il, El) {
        T = !1, f && (f = !1, Rb()), v = !0;
        var sZ = F;
        try {
          var YZ;
          if (!u) return ml(Il, El);
        } finally {
          J = null, F = sZ, v = !1;
        }
      }
      function ml(Il, El) {
        var sZ = El;
        for (Zl(sZ), J = i(E); J !== null && !Z && !(J.expirationTime > sZ && (!Il || Zb())); ) {
          var YZ = J.callback;
          if (typeof YZ == "function") {
            J.callback = null, F = J.priorityLevel;
            var kZ = J.expirationTime <= sZ, ec = YZ(kZ);
            sZ = l.unstable_now(), typeof ec == "function" ? J.callback = ec : J === i(E) && m(E), Zl(sZ);
          } else
            m(E);
          J = i(E);
        }
        if (J !== null)
          return !0;
        var Zc = i(g);
        return Zc !== null && BZ(ol, Zc.startTime - sZ), !1;
      }
      function Rl(Il, El) {
        switch (Il) {
          case y:
          case h:
          case S:
          case t:
          case W:
            break;
          default:
            Il = S;
        }
        var sZ = F;
        F = Il;
        try {
          return El();
        } finally {
          F = sZ;
        }
      }
      function kl(Il) {
        var El;
        switch (F) {
          case y:
          case h:
          case S:
            El = S;
            break;
          default:
            El = F;
            break;
        }
        var sZ = F;
        F = El;
        try {
          return Il();
        } finally {
          F = sZ;
        }
      }
      function zl(Il) {
        var El = F;
        return function() {
          var sZ = F;
          F = El;
          try {
            return Il.apply(this, arguments);
          } finally {
            F = sZ;
          }
        };
      }
      function Vl(Il, El, sZ) {
        var YZ = l.unstable_now(), kZ;
        if (typeof sZ == "object" && sZ !== null) {
          var ec = sZ.delay;
          typeof ec == "number" && ec > 0 ? kZ = YZ + ec : kZ = YZ;
        } else
          kZ = YZ;
        var Zc;
        switch (Il) {
          case y:
            Zc = w;
            break;
          case h:
            Zc = z;
            break;
          case W:
            Zc = j;
            break;
          case t:
            Zc = C;
            break;
          case S:
          default:
            Zc = D;
            break;
        }
        var bb = kZ + Zc, zZ = {
          id: A++,
          callback: El,
          priorityLevel: Il,
          startTime: kZ,
          expirationTime: bb,
          sortIndex: -1
        };
        return kZ > YZ ? (zZ.sortIndex = kZ, G(g, zZ), i(E) === null && zZ === i(g) && (f ? Rb() : f = !0, BZ(ol, kZ - YZ))) : (zZ.sortIndex = bb, G(E, zZ), !T && !v && (T = !0, Vc(Wl))), zZ;
      }
      function el() {
      }
      function xl() {
        !T && !v && (T = !0, Vc(Wl));
      }
      function hl() {
        return i(E);
      }
      function cl(Il) {
        Il.callback = null;
      }
      function wl() {
        return F;
      }
      var Jl = !1, cZ = null, uZ = -1, UZ = s, hc = -1;
      function Zb() {
        var Il = l.unstable_now() - hc;
        return !(Il < UZ);
      }
      function yc() {
      }
      function nb(Il) {
        if (Il < 0 || Il > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Il > 0 ? UZ = Math.floor(1e3 / Il) : UZ = s;
      }
      var Nc = function() {
        if (cZ !== null) {
          var Il = l.unstable_now();
          hc = Il;
          var El = !0, sZ = !0;
          try {
            sZ = cZ(El, Il);
          } finally {
            sZ ? oc() : (Jl = !1, cZ = null);
          }
        } else
          Jl = !1;
      }, oc;
      if (typeof il == "function")
        oc = function() {
          il(Nc);
        };
      else if (typeof MessageChannel < "u") {
        var cb = new MessageChannel(), sc = cb.port2;
        cb.port1.onmessage = Nc, oc = function() {
          sc.postMessage(null);
        };
      } else
        oc = function() {
          O(Nc, 0);
        };
      function Vc(Il) {
        cZ = Il, Jl || (Jl = !0, oc());
      }
      function BZ(Il, El) {
        uZ = O(function() {
          Il(l.unstable_now());
        }, El);
      }
      function Rb() {
        _(uZ), uZ = -1;
      }
      var Tb = yc, tu = null;
      l.unstable_IdlePriority = W, l.unstable_ImmediatePriority = y, l.unstable_LowPriority = t, l.unstable_NormalPriority = S, l.unstable_Profiling = tu, l.unstable_UserBlockingPriority = h, l.unstable_cancelCallback = cl, l.unstable_continueExecution = xl, l.unstable_forceFrameRate = nb, l.unstable_getCurrentPriorityLevel = wl, l.unstable_getFirstCallbackNode = hl, l.unstable_next = kl, l.unstable_pauseExecution = el, l.unstable_requestPaint = Tb, l.unstable_runWithPriority = Rl, l.unstable_scheduleCallback = Vl, l.unstable_shouldYield = Zb, l.unstable_wrapCallback = zl, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    })();
  }(WK)), WK;
}
var Dk;
function IT() {
  return Dk || (Dk = 1, KK.exports = MT()), KK.exports;
}
var zb = {}, jk;
function UT() {
  if (jk) return zb;
  jk = 1;
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var l = M, Z = IT(), u = l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, s = !1;
    function G(c) {
      s = c;
    }
    function i(c) {
      if (!s) {
        for (var b = arguments.length, d = new Array(b > 1 ? b - 1 : 0), o = 1; o < b; o++)
          d[o - 1] = arguments[o];
        a("warn", c, d);
      }
    }
    function m(c) {
      if (!s) {
        for (var b = arguments.length, d = new Array(b > 1 ? b - 1 : 0), o = 1; o < b; o++)
          d[o - 1] = arguments[o];
        a("error", c, d);
      }
    }
    function a(c, b, d) {
      {
        var o = u.ReactDebugCurrentFrame, e = o.getStackAddendum();
        e !== "" && (b += "%s", d = d.concat([e]));
        var L = d.map(function(X) {
          return String(X);
        });
        L.unshift("Warning: " + b), Function.prototype.apply.call(console[c], console, L);
      }
    }
    var n = 0, p = 1, y = 2, h = 3, S = 4, t = 5, W = 6, V = 7, R = 8, x = 9, r = 10, k = 11, U = 12, w = 13, z = 14, D = 15, C = 16, j = 17, E = 18, g = 19, A = 21, J = 22, F = 23, v = 24, T = 25, f = !0, O = !1, _ = !1, il = !1, Zl = !1, ol = !0, Wl = !1, ml = !0, Rl = !0, kl = !0, zl = !0, Vl = /* @__PURE__ */ new Set(), el = {}, xl = {};
    function hl(c, b) {
      cl(c, b), cl(c + "Capture", b);
    }
    function cl(c, b) {
      el[c] && m("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", c), el[c] = b;
      {
        var d = c.toLowerCase();
        xl[d] = c, c === "onDoubleClick" && (xl.ondblclick = c);
      }
      for (var o = 0; o < b.length; o++)
        Vl.add(b[o]);
    }
    var wl = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Jl = Object.prototype.hasOwnProperty;
    function cZ(c) {
      {
        var b = typeof Symbol == "function" && Symbol.toStringTag, d = b && c[Symbol.toStringTag] || c.constructor.name || "Object";
        return d;
      }
    }
    function uZ(c) {
      try {
        return UZ(c), !1;
      } catch {
        return !0;
      }
    }
    function UZ(c) {
      return "" + c;
    }
    function hc(c, b) {
      if (uZ(c))
        return m("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", b, cZ(c)), UZ(c);
    }
    function Zb(c) {
      if (uZ(c))
        return m("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", cZ(c)), UZ(c);
    }
    function yc(c, b) {
      if (uZ(c))
        return m("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", b, cZ(c)), UZ(c);
    }
    function nb(c, b) {
      if (uZ(c))
        return m("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", b, cZ(c)), UZ(c);
    }
    function Nc(c) {
      if (uZ(c))
        return m("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", cZ(c)), UZ(c);
    }
    function oc(c) {
      if (uZ(c))
        return m("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", cZ(c)), UZ(c);
    }
    var cb = 0, sc = 1, Vc = 2, BZ = 3, Rb = 4, Tb = 5, tu = 6, Il = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", El = Il + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", sZ = new RegExp("^[" + Il + "][" + El + "]*$"), YZ = {}, kZ = {};
    function ec(c) {
      return Jl.call(kZ, c) ? !0 : Jl.call(YZ, c) ? !1 : sZ.test(c) ? (kZ[c] = !0, !0) : (YZ[c] = !0, m("Invalid attribute name: `%s`", c), !1);
    }
    function Zc(c, b, d) {
      return b !== null ? b.type === cb : d ? !1 : c.length > 2 && (c[0] === "o" || c[0] === "O") && (c[1] === "n" || c[1] === "N");
    }
    function bb(c, b, d, o) {
      if (d !== null && d.type === cb)
        return !1;
      switch (typeof b) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (o)
            return !1;
          if (d !== null)
            return !d.acceptsBooleans;
          var e = c.toLowerCase().slice(0, 5);
          return e !== "data-" && e !== "aria-";
        }
        default:
          return !1;
      }
    }
    function zZ(c, b, d, o) {
      if (b === null || typeof b > "u" || bb(c, b, d, o))
        return !0;
      if (o)
        return !1;
      if (d !== null)
        switch (d.type) {
          case BZ:
            return !b;
          case Rb:
            return b === !1;
          case Tb:
            return isNaN(b);
          case tu:
            return isNaN(b) || b < 1;
        }
      return !1;
    }
    function pb(c) {
      return vZ.hasOwnProperty(c) ? vZ[c] : null;
    }
    function gZ(c, b, d, o, e, L, X) {
      this.acceptsBooleans = b === Vc || b === BZ || b === Rb, this.attributeName = o, this.attributeNamespace = e, this.mustUseProperty = d, this.propertyName = c, this.type = b, this.sanitizeURL = L, this.removeEmptyString = X;
    }
    var vZ = {}, cu = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    cu.forEach(function(c) {
      vZ[c] = new gZ(
        c,
        cb,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
      var b = c[0], d = c[1];
      vZ[b] = new gZ(
        b,
        sc,
        !1,
        // mustUseProperty
        d,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        Vc,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        Vc,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        BZ,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        BZ,
        !0,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        Rb,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        tu,
        !1,
        // mustUseProperty
        c,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        Tb,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Yb = /[\-\:]([a-z])/g, Rs = function(c) {
      return c[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var b = c.replace(Yb, Rs);
      vZ[b] = new gZ(
        b,
        sc,
        !1,
        // mustUseProperty
        c,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var b = c.replace(Yb, Rs);
      vZ[b] = new gZ(
        b,
        sc,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(c) {
      var b = c.replace(Yb, Rs);
      vZ[b] = new gZ(
        b,
        sc,
        !1,
        // mustUseProperty
        c,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        sc,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xd = "xlinkHref";
    vZ[Xd] = new gZ(
      "xlinkHref",
      sc,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(c) {
      vZ[c] = new gZ(
        c,
        sc,
        !1,
        // mustUseProperty
        c.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var tG = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ys = !1;
    function ks(c) {
      !Ys && tG.test(c) && (Ys = !0, m("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(c)));
    }
    function Xu(c, b, d, o) {
      if (o.mustUseProperty) {
        var e = o.propertyName;
        return c[e];
      } else {
        hc(d, b), o.sanitizeURL && ks("" + d);
        var L = o.attributeName, X = null;
        if (o.type === Rb) {
          if (c.hasAttribute(L)) {
            var K = c.getAttribute(L);
            return K === "" ? !0 : zZ(b, d, o, !1) ? K : K === "" + d ? d : K;
          }
        } else if (c.hasAttribute(L)) {
          if (zZ(b, d, o, !1))
            return c.getAttribute(L);
          if (o.type === BZ)
            return d;
          X = c.getAttribute(L);
        }
        return zZ(b, d, o, !1) ? X === null ? d : X : X === "" + d ? d : X;
      }
    }
    function Qu(c, b, d, o) {
      {
        if (!ec(b))
          return;
        if (!c.hasAttribute(b))
          return d === void 0 ? void 0 : null;
        var e = c.getAttribute(b);
        return hc(d, b), e === "" + d ? d : e;
      }
    }
    function Ku(c, b, d, o) {
      var e = pb(b);
      if (!Zc(b, e, o)) {
        if (zZ(b, d, e, o) && (d = null), o || e === null) {
          if (ec(b)) {
            var L = b;
            d === null ? c.removeAttribute(L) : (hc(d, b), c.setAttribute(L, "" + d));
          }
          return;
        }
        var X = e.mustUseProperty;
        if (X) {
          var K = e.propertyName;
          if (d === null) {
            var Y = e.type;
            c[K] = Y === BZ ? !1 : "";
          } else
            c[K] = d;
          return;
        }
        var N = e.attributeName, H = e.attributeNamespace;
        if (d === null)
          c.removeAttribute(N);
        else {
          var q = e.type, $;
          q === BZ || q === Rb && d === !0 ? $ = "" : (hc(d, N), $ = "" + d, e.sanitizeURL && ks($.toString())), H ? c.setAttributeNS(H, N, $) : c.setAttribute(N, $);
        }
      }
    }
    var fb = Symbol.for("react.element"), Eb = Symbol.for("react.portal"), bu = Symbol.for("react.fragment"), Ms = Symbol.for("react.strict_mode"), Pu = Symbol.for("react.profiler"), P = Symbol.for("react.provider"), yl = Symbol.for("react.context"), Kl = Symbol.for("react.forward_ref"), Bl = Symbol.for("react.suspense"), oZ = Symbol.for("react.suspense_list"), aZ = Symbol.for("react.memo"), jl = Symbol.for("react.lazy"), dZ = Symbol.for("react.scope"), ac = Symbol.for("react.debug_trace_mode"), JZ = Symbol.for("react.offscreen"), DZ = Symbol.for("react.legacy_hidden"), xc = Symbol.for("react.cache"), uu = Symbol.for("react.tracing_marker"), kb = Symbol.iterator, Sc = "@@iterator";
    function Lb(c) {
      if (c === null || typeof c != "object")
        return null;
      var b = kb && c[kb] || c[Sc];
      return typeof b == "function" ? b : null;
    }
    var GZ = Object.assign, Wu = 0, Ou, Kd, XG, KG, WG, VG, xG;
    function RG() {
    }
    RG.__reactDisabledLog = !0;
    function wm() {
      {
        if (Wu === 0) {
          Ou = console.log, Kd = console.info, XG = console.warn, KG = console.error, WG = console.group, VG = console.groupCollapsed, xG = console.groupEnd;
          var c = {
            configurable: !0,
            enumerable: !0,
            value: RG,
            writable: !0
          };
          Object.defineProperties(console, {
            info: c,
            log: c,
            warn: c,
            error: c,
            group: c,
            groupCollapsed: c,
            groupEnd: c
          });
        }
        Wu++;
      }
    }
    function Co() {
      {
        if (Wu--, Wu === 0) {
          var c = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: GZ({}, c, {
              value: Ou
            }),
            info: GZ({}, c, {
              value: Kd
            }),
            warn: GZ({}, c, {
              value: XG
            }),
            error: GZ({}, c, {
              value: KG
            }),
            group: GZ({}, c, {
              value: WG
            }),
            groupCollapsed: GZ({}, c, {
              value: VG
            }),
            groupEnd: GZ({}, c, {
              value: xG
            })
          });
        }
        Wu < 0 && m("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var YG = u.ReactCurrentDispatcher, Vu;
    function Mb(c, b, d) {
      {
        if (Vu === void 0)
          try {
            throw Error();
          } catch (e) {
            var o = e.stack.trim().match(/\n( *(at )?)/);
            Vu = o && o[1] || "";
          }
        return `
` + Vu + c;
      }
    }
    var Wd = !1, Vd;
    {
      var zm = typeof WeakMap == "function" ? WeakMap : Map;
      Vd = new zm();
    }
    function ro(c, b) {
      if (!c || Wd)
        return "";
      {
        var d = Vd.get(c);
        if (d !== void 0)
          return d;
      }
      var o;
      Wd = !0;
      var e = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var L;
      L = YG.current, YG.current = null, wm();
      try {
        if (b) {
          var X = function() {
            throw Error();
          };
          if (Object.defineProperty(X.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(X, []);
            } catch (Gl) {
              o = Gl;
            }
            Reflect.construct(c, [], X);
          } else {
            try {
              X.call();
            } catch (Gl) {
              o = Gl;
            }
            c.call(X.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Gl) {
            o = Gl;
          }
          c();
        }
      } catch (Gl) {
        if (Gl && o && typeof Gl.stack == "string") {
          for (var K = Gl.stack.split(`
`), Y = o.stack.split(`
`), N = K.length - 1, H = Y.length - 1; N >= 1 && H >= 0 && K[N] !== Y[H]; )
            H--;
          for (; N >= 1 && H >= 0; N--, H--)
            if (K[N] !== Y[H]) {
              if (N !== 1 || H !== 1)
                do
                  if (N--, H--, H < 0 || K[N] !== Y[H]) {
                    var q = `
` + K[N].replace(" at new ", " at ");
                    return c.displayName && q.includes("<anonymous>") && (q = q.replace("<anonymous>", c.displayName)), typeof c == "function" && Vd.set(c, q), q;
                  }
                while (N >= 1 && H >= 0);
              break;
            }
        }
      } finally {
        Wd = !1, YG.current = L, Co(), Error.prepareStackTrace = e;
      }
      var $ = c ? c.displayName || c.name : "", sl = $ ? Mb($) : "";
      return typeof c == "function" && Vd.set(c, sl), sl;
    }
    function kn(c, b, d) {
      return ro(c, !0);
    }
    function Fo(c, b, d) {
      return ro(c, !1);
    }
    function hy(c) {
      var b = c.prototype;
      return !!(b && b.isReactComponent);
    }
    function xd(c, b, d) {
      if (c == null)
        return "";
      if (typeof c == "function")
        return ro(c, hy(c));
      if (typeof c == "string")
        return Mb(c);
      switch (c) {
        case Bl:
          return Mb("Suspense");
        case oZ:
          return Mb("SuspenseList");
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case Kl:
            return Fo(c.render);
          case aZ:
            return xd(c.type, b, d);
          case jl: {
            var o = c, e = o._payload, L = o._init;
            try {
              return xd(L(e), b, d);
            } catch {
            }
          }
        }
      return "";
    }
    function Mn(c) {
      switch (c._debugOwner && c._debugOwner.type, c._debugSource, c.tag) {
        case t:
          return Mb(c.type);
        case C:
          return Mb("Lazy");
        case w:
          return Mb("Suspense");
        case g:
          return Mb("SuspenseList");
        case n:
        case y:
        case D:
          return Fo(c.type);
        case k:
          return Fo(c.type.render);
        case p:
          return kn(c.type);
        default:
          return "";
      }
    }
    function No(c) {
      try {
        var b = "", d = c;
        do
          b += Mn(d), d = d.return;
        while (d);
        return b;
      } catch (o) {
        return `
Error generating stack: ` + o.message + `
` + o.stack;
      }
    }
    function Jm(c, b, d) {
      var o = c.displayName;
      if (o)
        return o;
      var e = b.displayName || b.name || "";
      return e !== "" ? d + "(" + e + ")" : d;
    }
    function In(c) {
      return c.displayName || "Context";
    }
    function tZ(c) {
      if (c == null)
        return null;
      if (typeof c.tag == "number" && m("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c == "function")
        return c.displayName || c.name || null;
      if (typeof c == "string")
        return c;
      switch (c) {
        case bu:
          return "Fragment";
        case Eb:
          return "Portal";
        case Pu:
          return "Profiler";
        case Ms:
          return "StrictMode";
        case Bl:
          return "Suspense";
        case oZ:
          return "SuspenseList";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case yl:
            var b = c;
            return In(b) + ".Consumer";
          case P:
            var d = c;
            return In(d._context) + ".Provider";
          case Kl:
            return Jm(c, c.render, "ForwardRef");
          case aZ:
            var o = c.displayName || null;
            return o !== null ? o : tZ(c.type) || "Memo";
          case jl: {
            var e = c, L = e._payload, X = e._init;
            try {
              return tZ(X(L));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function wo(c, b, d) {
      var o = b.displayName || b.name || "";
      return c.displayName || (o !== "" ? d + "(" + o + ")" : d);
    }
    function zo(c) {
      return c.displayName || "Context";
    }
    function bZ(c) {
      var b = c.tag, d = c.type;
      switch (b) {
        case v:
          return "Cache";
        case x:
          var o = d;
          return zo(o) + ".Consumer";
        case r:
          var e = d;
          return zo(e._context) + ".Provider";
        case E:
          return "DehydratedFragment";
        case k:
          return wo(d, d.render, "ForwardRef");
        case V:
          return "Fragment";
        case t:
          return d;
        case S:
          return "Portal";
        case h:
          return "Root";
        case W:
          return "Text";
        case C:
          return tZ(d);
        case R:
          return d === Ms ? "StrictMode" : "Mode";
        case J:
          return "Offscreen";
        case U:
          return "Profiler";
        case A:
          return "Scope";
        case w:
          return "Suspense";
        case g:
          return "SuspenseList";
        case T:
          return "TracingMarker";
        case p:
        case n:
        case j:
        case y:
        case z:
        case D:
          if (typeof d == "function")
            return d.displayName || d.name || null;
          if (typeof d == "string")
            return d;
          break;
      }
      return null;
    }
    var Un = u.ReactDebugCurrentFrame, ub = null, kG = !1;
    function Rd() {
      {
        if (ub === null)
          return null;
        var c = ub._debugOwner;
        if (c !== null && typeof c < "u")
          return bZ(c);
      }
      return null;
    }
    function Cn() {
      return ub === null ? "" : No(ub);
    }
    function wc() {
      Un.getCurrentStack = null, ub = null, kG = !1;
    }
    function cc(c) {
      Un.getCurrentStack = c === null ? null : Cn, ub = c, kG = !1;
    }
    function rn() {
      return ub;
    }
    function Bb(c) {
      kG = c;
    }
    function Ib(c) {
      return "" + c;
    }
    function Au(c) {
      switch (typeof c) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return c;
        case "object":
          return oc(c), c;
        default:
          return "";
      }
    }
    var yy = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Hm(c, b) {
      yy[b.type] || b.onChange || b.onInput || b.readOnly || b.disabled || b.value == null || m("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), b.onChange || b.readOnly || b.disabled || b.checked == null || m("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function MG(c) {
      var b = c.type, d = c.nodeName;
      return d && d.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
    }
    function Fn(c) {
      return c._valueTracker;
    }
    function Yd(c) {
      c._valueTracker = null;
    }
    function Nn(c) {
      var b = "";
      return c && (MG(c) ? b = c.checked ? "true" : "false" : b = c.value), b;
    }
    function wn(c) {
      var b = MG(c) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(c.constructor.prototype, b);
      oc(c[b]);
      var o = "" + c[b];
      if (!(c.hasOwnProperty(b) || typeof d > "u" || typeof d.get != "function" || typeof d.set != "function")) {
        var e = d.get, L = d.set;
        Object.defineProperty(c, b, {
          configurable: !0,
          get: function() {
            return e.call(this);
          },
          set: function(K) {
            oc(K), o = "" + K, L.call(this, K);
          }
        }), Object.defineProperty(c, b, {
          enumerable: d.enumerable
        });
        var X = {
          getValue: function() {
            return o;
          },
          setValue: function(K) {
            oc(K), o = "" + K;
          },
          stopTracking: function() {
            Yd(c), delete c[b];
          }
        };
        return X;
      }
    }
    function Is(c) {
      Fn(c) || (c._valueTracker = wn(c));
    }
    function gm(c) {
      if (!c)
        return !1;
      var b = Fn(c);
      if (!b)
        return !0;
      var d = b.getValue(), o = Nn(c);
      return o !== d ? (b.setValue(o), !0) : !1;
    }
    function kd(c) {
      if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u")
        return null;
      try {
        return c.activeElement || c.body;
      } catch {
        return c.body;
      }
    }
    var vm = !1, zn = !1, Jn = !1, Hn = !1;
    function gn(c) {
      var b = c.type === "checkbox" || c.type === "radio";
      return b ? c.checked != null : c.value != null;
    }
    function I(c, b) {
      var d = c, o = b.checked, e = GZ({}, b, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: o ?? d._wrapperState.initialChecked
      });
      return e;
    }
    function Q(c, b) {
      Hm("input", b), b.checked !== void 0 && b.defaultChecked !== void 0 && !zn && (m("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Rd() || "A component", b.type), zn = !0), b.value !== void 0 && b.defaultValue !== void 0 && !vm && (m("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Rd() || "A component", b.type), vm = !0);
      var d = c, o = b.defaultValue == null ? "" : b.defaultValue;
      d._wrapperState = {
        initialChecked: b.checked != null ? b.checked : b.defaultChecked,
        initialValue: Au(b.value != null ? b.value : o),
        controlled: gn(b)
      };
    }
    function dl(c, b) {
      var d = c, o = b.checked;
      o != null && Ku(d, "checked", o, !1);
    }
    function al(c, b) {
      var d = c;
      {
        var o = gn(b);
        !d._wrapperState.controlled && o && !Hn && (m("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Hn = !0), d._wrapperState.controlled && !o && !Jn && (m("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Jn = !0);
      }
      dl(c, b);
      var e = Au(b.value), L = b.type;
      if (e != null)
        L === "number" ? (e === 0 && d.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        d.value != e) && (d.value = Ib(e)) : d.value !== Ib(e) && (d.value = Ib(e));
      else if (L === "submit" || L === "reset") {
        d.removeAttribute("value");
        return;
      }
      b.hasOwnProperty("value") ? $l(d, b.type, e) : b.hasOwnProperty("defaultValue") && $l(d, b.type, Au(b.defaultValue)), b.checked == null && b.defaultChecked != null && (d.defaultChecked = !!b.defaultChecked);
    }
    function Yl(c, b, d) {
      var o = c;
      if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
        var e = b.type, L = e === "submit" || e === "reset";
        if (L && (b.value === void 0 || b.value === null))
          return;
        var X = Ib(o._wrapperState.initialValue);
        d || X !== o.value && (o.value = X), o.defaultValue = X;
      }
      var K = o.name;
      K !== "" && (o.name = ""), o.defaultChecked = !o.defaultChecked, o.defaultChecked = !!o._wrapperState.initialChecked, K !== "" && (o.name = K);
    }
    function Ol(c, b) {
      var d = c;
      al(d, b), gl(d, b);
    }
    function gl(c, b) {
      var d = b.name;
      if (b.type === "radio" && d != null) {
        for (var o = c; o.parentNode; )
          o = o.parentNode;
        hc(d, "name");
        for (var e = o.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), L = 0; L < e.length; L++) {
          var X = e[L];
          if (!(X === c || X.form !== c.form)) {
            var K = Rp(X);
            if (!K)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            gm(X), al(X, K);
          }
        }
      }
    }
    function $l(c, b, d) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (b !== "number" || kd(c.ownerDocument) !== c) && (d == null ? c.defaultValue = Ib(c._wrapperState.initialValue) : c.defaultValue !== Ib(d) && (c.defaultValue = Ib(d)));
    }
    var nZ = !1, CZ = !1, TZ = !1;
    function fZ(c, b) {
      b.value == null && (typeof b.children == "object" && b.children !== null ? l.Children.forEach(b.children, function(d) {
        d != null && (typeof d == "string" || typeof d == "number" || CZ || (CZ = !0, m("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : b.dangerouslySetInnerHTML != null && (TZ || (TZ = !0, m("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), b.selected != null && !nZ && (m("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), nZ = !0);
    }
    function AZ(c, b) {
      b.value != null && c.setAttribute("value", Ib(Au(b.value)));
    }
    var dc = Array.isArray;
    function xZ(c) {
      return dc(c);
    }
    var Md;
    Md = !1;
    function Tm() {
      var c = Rd();
      return c ? `

Check the render method of \`` + c + "`." : "";
    }
    var Jo = ["value", "defaultValue"];
    function Sy(c) {
      {
        Hm("select", c);
        for (var b = 0; b < Jo.length; b++) {
          var d = Jo[b];
          if (c[d] != null) {
            var o = xZ(c[d]);
            c.multiple && !o ? m("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", d, Tm()) : !c.multiple && o && m("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", d, Tm());
          }
        }
      }
    }
    function Us(c, b, d, o) {
      var e = c.options;
      if (b) {
        for (var L = d, X = {}, K = 0; K < L.length; K++)
          X["$" + L[K]] = !0;
        for (var Y = 0; Y < e.length; Y++) {
          var N = X.hasOwnProperty("$" + e[Y].value);
          e[Y].selected !== N && (e[Y].selected = N), N && o && (e[Y].defaultSelected = !0);
        }
      } else {
        for (var H = Ib(Au(d)), q = null, $ = 0; $ < e.length; $++) {
          if (e[$].value === H) {
            e[$].selected = !0, o && (e[$].defaultSelected = !0);
            return;
          }
          q === null && !e[$].disabled && (q = e[$]);
        }
        q !== null && (q.selected = !0);
      }
    }
    function Ho(c, b) {
      return GZ({}, b, {
        value: void 0
      });
    }
    function go(c, b) {
      var d = c;
      Sy(b), d._wrapperState = {
        wasMultiple: !!b.multiple
      }, b.value !== void 0 && b.defaultValue !== void 0 && !Md && (m("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Md = !0);
    }
    function ty(c, b) {
      var d = c;
      d.multiple = !!b.multiple;
      var o = b.value;
      o != null ? Us(d, !!b.multiple, o, !1) : b.defaultValue != null && Us(d, !!b.multiple, b.defaultValue, !0);
    }
    function oF(c, b) {
      var d = c, o = d._wrapperState.wasMultiple;
      d._wrapperState.wasMultiple = !!b.multiple;
      var e = b.value;
      e != null ? Us(d, !!b.multiple, e, !1) : o !== !!b.multiple && (b.defaultValue != null ? Us(d, !!b.multiple, b.defaultValue, !0) : Us(d, !!b.multiple, b.multiple ? [] : "", !1));
    }
    function eF(c, b) {
      var d = c, o = b.value;
      o != null && Us(d, !!b.multiple, o, !1);
    }
    var Nx = !1;
    function Xy(c, b) {
      var d = c;
      if (b.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var o = GZ({}, b, {
        value: void 0,
        defaultValue: void 0,
        children: Ib(d._wrapperState.initialValue)
      });
      return o;
    }
    function wx(c, b) {
      var d = c;
      Hm("textarea", b), b.value !== void 0 && b.defaultValue !== void 0 && !Nx && (m("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Rd() || "A component"), Nx = !0);
      var o = b.value;
      if (o == null) {
        var e = b.children, L = b.defaultValue;
        if (e != null) {
          m("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (L != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (xZ(e)) {
              if (e.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              e = e[0];
            }
            L = e;
          }
        }
        L == null && (L = ""), o = L;
      }
      d._wrapperState = {
        initialValue: Au(o)
      };
    }
    function zx(c, b) {
      var d = c, o = Au(b.value), e = Au(b.defaultValue);
      if (o != null) {
        var L = Ib(o);
        L !== d.value && (d.value = L), b.defaultValue == null && d.defaultValue !== L && (d.defaultValue = L);
      }
      e != null && (d.defaultValue = Ib(e));
    }
    function Jx(c, b) {
      var d = c, o = d.textContent;
      o === d._wrapperState.initialValue && o !== "" && o !== null && (d.value = o);
    }
    function aF(c, b) {
      zx(c, b);
    }
    var Cs = "http://www.w3.org/1999/xhtml", nF = "http://www.w3.org/1998/Math/MathML", Ky = "http://www.w3.org/2000/svg";
    function Wy(c) {
      switch (c) {
        case "svg":
          return Ky;
        case "math":
          return nF;
        default:
          return Cs;
      }
    }
    function Vy(c, b) {
      return c == null || c === Cs ? Wy(b) : c === Ky && b === "foreignObject" ? Cs : c;
    }
    var pF = function(c) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(b, d, o, e) {
        MSApp.execUnsafeLocalFunction(function() {
          return c(b, d, o, e);
        });
      } : c;
    }, vn, Hx = pF(function(c, b) {
      if (c.namespaceURI === Ky && !("innerHTML" in c)) {
        vn = vn || document.createElement("div"), vn.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
        for (var d = vn.firstChild; c.firstChild; )
          c.removeChild(c.firstChild);
        for (; d.firstChild; )
          c.appendChild(d.firstChild);
        return;
      }
      c.innerHTML = b;
    }), Ub = 1, rs = 3, tc = 8, Fs = 9, xy = 11, Tn = function(c, b) {
      if (b) {
        var d = c.firstChild;
        if (d && d === c.lastChild && d.nodeType === rs) {
          d.nodeValue = b;
          return;
        }
      }
      c.textContent = b;
    }, LF = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, vo = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function hF(c, b) {
      return c + b.charAt(0).toUpperCase() + b.substring(1);
    }
    var yF = ["Webkit", "ms", "Moz", "O"];
    Object.keys(vo).forEach(function(c) {
      yF.forEach(function(b) {
        vo[hF(b, c)] = vo[c];
      });
    });
    function Ry(c, b, d) {
      var o = b == null || typeof b == "boolean" || b === "";
      return o ? "" : !d && typeof b == "number" && b !== 0 && !(vo.hasOwnProperty(c) && vo[c]) ? b + "px" : (nb(b, c), ("" + b).trim());
    }
    var SF = /([A-Z])/g, tF = /^ms-/;
    function XF(c) {
      return c.replace(SF, "-$1").toLowerCase().replace(tF, "-ms-");
    }
    var gx = function() {
    };
    {
      var KF = /^(?:webkit|moz|o)[A-Z]/, WF = /^-ms-/, VF = /-(.)/g, vx = /;\s*$/, fm = {}, Yy = {}, Tx = !1, fx = !1, xF = function(c) {
        return c.replace(VF, function(b, d) {
          return d.toUpperCase();
        });
      }, RF = function(c) {
        fm.hasOwnProperty(c) && fm[c] || (fm[c] = !0, m(
          "Unsupported style property %s. Did you mean %s?",
          c,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          xF(c.replace(WF, "ms-"))
        ));
      }, YF = function(c) {
        fm.hasOwnProperty(c) && fm[c] || (fm[c] = !0, m("Unsupported vendor-prefixed style property %s. Did you mean %s?", c, c.charAt(0).toUpperCase() + c.slice(1)));
      }, kF = function(c, b) {
        Yy.hasOwnProperty(b) && Yy[b] || (Yy[b] = !0, m(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, c, b.replace(vx, "")));
      }, MF = function(c, b) {
        Tx || (Tx = !0, m("`NaN` is an invalid value for the `%s` css style property.", c));
      }, IF = function(c, b) {
        fx || (fx = !0, m("`Infinity` is an invalid value for the `%s` css style property.", c));
      };
      gx = function(c, b) {
        c.indexOf("-") > -1 ? RF(c) : KF.test(c) ? YF(c) : vx.test(b) && kF(c, b), typeof b == "number" && (isNaN(b) ? MF(c, b) : isFinite(b) || IF(c, b));
      };
    }
    var UF = gx;
    function CF(c) {
      {
        var b = "", d = "";
        for (var o in c)
          if (c.hasOwnProperty(o)) {
            var e = c[o];
            if (e != null) {
              var L = o.indexOf("--") === 0;
              b += d + (L ? o : XF(o)) + ":", b += Ry(o, e, L), d = ";";
            }
          }
        return b || null;
      }
    }
    function Ex(c, b) {
      var d = c.style;
      for (var o in b)
        if (b.hasOwnProperty(o)) {
          var e = o.indexOf("--") === 0;
          e || UF(o, b[o]);
          var L = Ry(o, b[o], e);
          o === "float" && (o = "cssFloat"), e ? d.setProperty(o, L) : d[o] = L;
        }
    }
    function rF(c) {
      return c == null || typeof c == "boolean" || c === "";
    }
    function Bx(c) {
      var b = {};
      for (var d in c)
        for (var o = LF[d] || [d], e = 0; e < o.length; e++)
          b[o[e]] = d;
      return b;
    }
    function FF(c, b) {
      {
        if (!b)
          return;
        var d = Bx(c), o = Bx(b), e = {};
        for (var L in d) {
          var X = d[L], K = o[L];
          if (K && X !== K) {
            var Y = X + "," + K;
            if (e[Y])
              continue;
            e[Y] = !0, m("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", rF(c[X]) ? "Removing" : "Updating", X, K);
          }
        }
      }
    }
    var NF = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, wF = GZ({
      menuitem: !0
    }, NF), zF = "__html";
    function ky(c, b) {
      if (b) {
        if (wF[c] && (b.children != null || b.dangerouslySetInnerHTML != null))
          throw new Error(c + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (b.dangerouslySetInnerHTML != null) {
          if (b.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof b.dangerouslySetInnerHTML != "object" || !(zF in b.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!b.suppressContentEditableWarning && b.contentEditable && b.children != null && m("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), b.style != null && typeof b.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function IG(c, b) {
      if (c.indexOf("-") === -1)
        return typeof b.is == "string";
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var fn = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Dx = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, Em = {}, JF = new RegExp("^(aria)-[" + El + "]*$"), HF = new RegExp("^(aria)[A-Z][" + El + "]*$");
    function gF(c, b) {
      {
        if (Jl.call(Em, b) && Em[b])
          return !0;
        if (HF.test(b)) {
          var d = "aria-" + b.slice(4).toLowerCase(), o = Dx.hasOwnProperty(d) ? d : null;
          if (o == null)
            return m("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", b), Em[b] = !0, !0;
          if (b !== o)
            return m("Invalid ARIA attribute `%s`. Did you mean `%s`?", b, o), Em[b] = !0, !0;
        }
        if (JF.test(b)) {
          var e = b.toLowerCase(), L = Dx.hasOwnProperty(e) ? e : null;
          if (L == null)
            return Em[b] = !0, !1;
          if (b !== L)
            return m("Unknown ARIA attribute `%s`. Did you mean `%s`?", b, L), Em[b] = !0, !0;
        }
      }
      return !0;
    }
    function vF(c, b) {
      {
        var d = [];
        for (var o in b) {
          var e = gF(c, o);
          e || d.push(o);
        }
        var L = d.map(function(X) {
          return "`" + X + "`";
        }).join(", ");
        d.length === 1 ? m("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", L, c) : d.length > 1 && m("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", L, c);
      }
    }
    function TF(c, b) {
      IG(c, b) || vF(c, b);
    }
    var jx = !1;
    function fF(c, b) {
      {
        if (c !== "input" && c !== "textarea" && c !== "select")
          return;
        b != null && b.value === null && !jx && (jx = !0, c === "select" && b.multiple ? m("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", c) : m("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", c));
      }
    }
    var Qx = function() {
    };
    {
      var hb = {}, Px = /^on./, EF = /^on[^A-Z]/, BF = new RegExp("^(aria)-[" + El + "]*$"), DF = new RegExp("^(aria)[A-Z][" + El + "]*$");
      Qx = function(c, b, d, o) {
        if (Jl.call(hb, b) && hb[b])
          return !0;
        var e = b.toLowerCase();
        if (e === "onfocusin" || e === "onfocusout")
          return m("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), hb[b] = !0, !0;
        if (o != null) {
          var L = o.registrationNameDependencies, X = o.possibleRegistrationNames;
          if (L.hasOwnProperty(b))
            return !0;
          var K = X.hasOwnProperty(e) ? X[e] : null;
          if (K != null)
            return m("Invalid event handler property `%s`. Did you mean `%s`?", b, K), hb[b] = !0, !0;
          if (Px.test(b))
            return m("Unknown event handler property `%s`. It will be ignored.", b), hb[b] = !0, !0;
        } else if (Px.test(b))
          return EF.test(b) && m("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", b), hb[b] = !0, !0;
        if (BF.test(b) || DF.test(b))
          return !0;
        if (e === "innerhtml")
          return m("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), hb[b] = !0, !0;
        if (e === "aria")
          return m("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), hb[b] = !0, !0;
        if (e === "is" && d !== null && d !== void 0 && typeof d != "string")
          return m("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof d), hb[b] = !0, !0;
        if (typeof d == "number" && isNaN(d))
          return m("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", b), hb[b] = !0, !0;
        var Y = pb(b), N = Y !== null && Y.type === cb;
        if (fn.hasOwnProperty(e)) {
          var H = fn[e];
          if (H !== b)
            return m("Invalid DOM property `%s`. Did you mean `%s`?", b, H), hb[b] = !0, !0;
        } else if (!N && b !== e)
          return m("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", b, e), hb[b] = !0, !0;
        return typeof d == "boolean" && bb(b, d, Y, !1) ? (d ? m('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', d, b, b, d, b) : m('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', d, b, b, d, b, b, b), hb[b] = !0, !0) : N ? !0 : bb(b, d, Y, !1) ? (hb[b] = !0, !1) : ((d === "false" || d === "true") && Y !== null && Y.type === BZ && (m("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", d, b, d === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', b, d), hb[b] = !0), !0);
      };
    }
    var jF = function(c, b, d) {
      {
        var o = [];
        for (var e in b) {
          var L = Qx(c, e, b[e], d);
          L || o.push(e);
        }
        var X = o.map(function(K) {
          return "`" + K + "`";
        }).join(", ");
        o.length === 1 ? m("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", X, c) : o.length > 1 && m("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", X, c);
      }
    };
    function QF(c, b, d) {
      IG(c, b) || jF(c, b, d);
    }
    var Ox = 1, My = 2, To = 4, PF = Ox | My | To, fo = null;
    function OF(c) {
      fo !== null && m("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), fo = c;
    }
    function AF() {
      fo === null && m("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), fo = null;
    }
    function $F(c) {
      return c === fo;
    }
    function Iy(c) {
      var b = c.target || c.srcElement || window;
      return b.correspondingUseElement && (b = b.correspondingUseElement), b.nodeType === rs ? b.parentNode : b;
    }
    var Uy = null, Bm = null, Dm = null;
    function Ax(c) {
      var b = zd(c);
      if (b) {
        if (typeof Uy != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var d = b.stateNode;
        if (d) {
          var o = Rp(d);
          Uy(b.stateNode, b.type, o);
        }
      }
    }
    function qF(c) {
      Uy = c;
    }
    function $x(c) {
      Bm ? Dm ? Dm.push(c) : Dm = [c] : Bm = c;
    }
    function _F() {
      return Bm !== null || Dm !== null;
    }
    function qx() {
      if (Bm) {
        var c = Bm, b = Dm;
        if (Bm = null, Dm = null, Ax(c), b)
          for (var d = 0; d < b.length; d++)
            Ax(b[d]);
      }
    }
    var _x = function(c, b) {
      return c(b);
    }, l5 = function() {
    }, Cy = !1;
    function lN() {
      var c = _F();
      c && (l5(), qx());
    }
    function Z5(c, b, d) {
      if (Cy)
        return c(b, d);
      Cy = !0;
      try {
        return _x(c, b, d);
      } finally {
        Cy = !1, lN();
      }
    }
    function ZN(c, b, d) {
      _x = c, l5 = d;
    }
    function cN(c) {
      return c === "button" || c === "input" || c === "select" || c === "textarea";
    }
    function bN(c, b, d) {
      switch (c) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(d.disabled && cN(b));
        default:
          return !1;
      }
    }
    function Eo(c, b) {
      var d = c.stateNode;
      if (d === null)
        return null;
      var o = Rp(d);
      if (o === null)
        return null;
      var e = o[b];
      if (bN(b, c.type, o))
        return null;
      if (e && typeof e != "function")
        throw new Error("Expected `" + b + "` listener to be a function, instead got a value of `" + typeof e + "` type.");
      return e;
    }
    var ry = !1;
    if (wl)
      try {
        var Bo = {};
        Object.defineProperty(Bo, "passive", {
          get: function() {
            ry = !0;
          }
        }), window.addEventListener("test", Bo, Bo), window.removeEventListener("test", Bo, Bo);
      } catch {
        ry = !1;
      }
    function c5(c, b, d, o, e, L, X, K, Y) {
      var N = Array.prototype.slice.call(arguments, 3);
      try {
        b.apply(d, N);
      } catch (H) {
        this.onError(H);
      }
    }
    var b5 = c5;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Fy = document.createElement("react");
      b5 = function(b, d, o, e, L, X, K, Y, N) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var H = document.createEvent("Event"), q = !1, $ = !0, sl = window.event, Gl = Object.getOwnPropertyDescriptor(window, "event");
        function nl() {
          Fy.removeEventListener(pl, Dl, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = sl);
        }
        var Ul = Array.prototype.slice.call(arguments, 3);
        function Dl() {
          q = !0, nl(), d.apply(o, Ul), $ = !1;
        }
        var fl, hZ = !1, eZ = !1;
        function bl(ul) {
          if (fl = ul.error, hZ = !0, fl === null && ul.colno === 0 && ul.lineno === 0 && (eZ = !0), ul.defaultPrevented && fl != null && typeof fl == "object")
            try {
              fl._suppressLogging = !0;
            } catch {
            }
        }
        var pl = "react-" + (b || "invokeguardedcallback");
        if (window.addEventListener("error", bl), Fy.addEventListener(pl, Dl, !1), H.initEvent(pl, !1, !1), Fy.dispatchEvent(H), Gl && Object.defineProperty(window, "event", Gl), q && $ && (hZ ? eZ && (fl = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : fl = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(fl)), window.removeEventListener("error", bl), !q)
          return nl(), c5.apply(this, arguments);
      };
    }
    var uN = b5, jm = !1, En = null, Bn = !1, Ny = null, sN = {
      onError: function(c) {
        jm = !0, En = c;
      }
    };
    function wy(c, b, d, o, e, L, X, K, Y) {
      jm = !1, En = null, uN.apply(sN, arguments);
    }
    function dN(c, b, d, o, e, L, X, K, Y) {
      if (wy.apply(this, arguments), jm) {
        var N = zy();
        Bn || (Bn = !0, Ny = N);
      }
    }
    function GN() {
      if (Bn) {
        var c = Ny;
        throw Bn = !1, Ny = null, c;
      }
    }
    function mN() {
      return jm;
    }
    function zy() {
      if (jm) {
        var c = En;
        return jm = !1, En = null, c;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Qm(c) {
      return c._reactInternals;
    }
    function iN(c) {
      return c._reactInternals !== void 0;
    }
    function oN(c, b) {
      c._reactInternals = b;
    }
    var Pl = (
      /*                      */
      0
    ), Pm = (
      /*                */
      1
    ), Xc = (
      /*                    */
      2
    ), SZ = (
      /*                       */
      4
    ), UG = (
      /*                */
      16
    ), Do = (
      /*                 */
      32
    ), Jy = (
      /*                     */
      64
    ), RZ = (
      /*                   */
      128
    ), Ns = (
      /*            */
      256
    ), Id = (
      /*                          */
      512
    ), CG = (
      /*                     */
      1024
    ), xu = (
      /*                      */
      2048
    ), ws = (
      /*                    */
      4096
    ), rG = (
      /*                   */
      8192
    ), Dn = (
      /*             */
      16384
    ), eN = xu | SZ | Jy | Id | CG | Dn, aN = (
      /*               */
      32767
    ), jo = (
      /*                   */
      32768
    ), yb = (
      /*                */
      65536
    ), Hy = (
      /* */
      131072
    ), u5 = (
      /*                       */
      1048576
    ), gy = (
      /*                    */
      2097152
    ), FG = (
      /*                 */
      4194304
    ), vy = (
      /*                */
      8388608
    ), zs = (
      /*               */
      16777216
    ), jn = (
      /*              */
      33554432
    ), Ty = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      SZ | CG | 0
    ), fy = Xc | SZ | UG | Do | Id | ws | rG, Qo = SZ | Jy | Id | rG, Om = xu | UG, Js = FG | vy | gy, nN = u.ReactCurrentOwner;
    function NG(c) {
      var b = c, d = c;
      if (c.alternate)
        for (; b.return; )
          b = b.return;
      else {
        var o = b;
        do
          b = o, (b.flags & (Xc | ws)) !== Pl && (d = b.return), o = b.return;
        while (o);
      }
      return b.tag === h ? d : null;
    }
    function s5(c) {
      if (c.tag === w) {
        var b = c.memoizedState;
        if (b === null) {
          var d = c.alternate;
          d !== null && (b = d.memoizedState);
        }
        if (b !== null)
          return b.dehydrated;
      }
      return null;
    }
    function d5(c) {
      return c.tag === h ? c.stateNode.containerInfo : null;
    }
    function pN(c) {
      return NG(c) === c;
    }
    function LN(c) {
      {
        var b = nN.current;
        if (b !== null && b.tag === p) {
          var d = b, o = d.stateNode;
          o._warnedAboutRefsInRender || m("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", bZ(d) || "A component"), o._warnedAboutRefsInRender = !0;
        }
      }
      var e = Qm(c);
      return e ? NG(e) === e : !1;
    }
    function G5(c) {
      if (NG(c) !== c)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function m5(c) {
      var b = c.alternate;
      if (!b) {
        var d = NG(c);
        if (d === null)
          throw new Error("Unable to find node on an unmounted component.");
        return d !== c ? null : c;
      }
      for (var o = c, e = b; ; ) {
        var L = o.return;
        if (L === null)
          break;
        var X = L.alternate;
        if (X === null) {
          var K = L.return;
          if (K !== null) {
            o = e = K;
            continue;
          }
          break;
        }
        if (L.child === X.child) {
          for (var Y = L.child; Y; ) {
            if (Y === o)
              return G5(L), c;
            if (Y === e)
              return G5(L), b;
            Y = Y.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (o.return !== e.return)
          o = L, e = X;
        else {
          for (var N = !1, H = L.child; H; ) {
            if (H === o) {
              N = !0, o = L, e = X;
              break;
            }
            if (H === e) {
              N = !0, e = L, o = X;
              break;
            }
            H = H.sibling;
          }
          if (!N) {
            for (H = X.child; H; ) {
              if (H === o) {
                N = !0, o = X, e = L;
                break;
              }
              if (H === e) {
                N = !0, e = X, o = L;
                break;
              }
              H = H.sibling;
            }
            if (!N)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (o.alternate !== e)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (o.tag !== h)
        throw new Error("Unable to find node on an unmounted component.");
      return o.stateNode.current === o ? c : b;
    }
    function i5(c) {
      var b = m5(c);
      return b !== null ? o5(b) : null;
    }
    function o5(c) {
      if (c.tag === t || c.tag === W)
        return c;
      for (var b = c.child; b !== null; ) {
        var d = o5(b);
        if (d !== null)
          return d;
        b = b.sibling;
      }
      return null;
    }
    function hN(c) {
      var b = m5(c);
      return b !== null ? e5(b) : null;
    }
    function e5(c) {
      if (c.tag === t || c.tag === W)
        return c;
      for (var b = c.child; b !== null; ) {
        if (b.tag !== S) {
          var d = e5(b);
          if (d !== null)
            return d;
        }
        b = b.sibling;
      }
      return null;
    }
    var a5 = Z.unstable_scheduleCallback, yN = Z.unstable_cancelCallback, SN = Z.unstable_shouldYield, tN = Z.unstable_requestPaint, zc = Z.unstable_now, XN = Z.unstable_getCurrentPriorityLevel, Qn = Z.unstable_ImmediatePriority, Ey = Z.unstable_UserBlockingPriority, wG = Z.unstable_NormalPriority, KN = Z.unstable_LowPriority, By = Z.unstable_IdlePriority, WN = Z.unstable_yieldValue, VN = Z.unstable_setDisableYieldValue, Am = null, sb = null, rl = null, $u = !1, Ru = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function xN(c) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (b.isDisabled)
        return !0;
      if (!b.supportsFiber)
        return m("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Rl && (c = GZ({}, c, {
          getLaneLabelMap: UN,
          injectProfilingHooks: IN
        })), Am = b.inject(c), sb = b;
      } catch (d) {
        m("React instrumentation encountered an error: %s.", d);
      }
      return !!b.checkDCE;
    }
    function RN(c, b) {
      if (sb && typeof sb.onScheduleFiberRoot == "function")
        try {
          sb.onScheduleFiberRoot(Am, c, b);
        } catch (d) {
          $u || ($u = !0, m("React instrumentation encountered an error: %s", d));
        }
    }
    function YN(c, b) {
      if (sb && typeof sb.onCommitFiberRoot == "function")
        try {
          var d = (c.current.flags & RZ) === RZ;
          if (kl) {
            var o;
            switch (b) {
              case Qb:
                o = Qn;
                break;
              case gs:
                o = Ey;
                break;
              case vs:
                o = wG;
                break;
              case lp:
                o = By;
                break;
              default:
                o = wG;
                break;
            }
            sb.onCommitFiberRoot(Am, c, o, d);
          }
        } catch (e) {
          $u || ($u = !0, m("React instrumentation encountered an error: %s", e));
        }
    }
    function kN(c) {
      if (sb && typeof sb.onPostCommitFiberRoot == "function")
        try {
          sb.onPostCommitFiberRoot(Am, c);
        } catch (b) {
          $u || ($u = !0, m("React instrumentation encountered an error: %s", b));
        }
    }
    function MN(c) {
      if (sb && typeof sb.onCommitFiberUnmount == "function")
        try {
          sb.onCommitFiberUnmount(Am, c);
        } catch (b) {
          $u || ($u = !0, m("React instrumentation encountered an error: %s", b));
        }
    }
    function Jc(c) {
      if (typeof WN == "function" && (VN(c), G(c)), sb && typeof sb.setStrictMode == "function")
        try {
          sb.setStrictMode(Am, c);
        } catch (b) {
          $u || ($u = !0, m("React instrumentation encountered an error: %s", b));
        }
    }
    function IN(c) {
      rl = c;
    }
    function UN() {
      {
        for (var c = /* @__PURE__ */ new Map(), b = 1, d = 0; d < jy; d++) {
          var o = AN(b);
          c.set(b, o), b *= 2;
        }
        return c;
      }
    }
    function CN(c) {
      rl !== null && typeof rl.markCommitStarted == "function" && rl.markCommitStarted(c);
    }
    function n5() {
      rl !== null && typeof rl.markCommitStopped == "function" && rl.markCommitStopped();
    }
    function Po(c) {
      rl !== null && typeof rl.markComponentRenderStarted == "function" && rl.markComponentRenderStarted(c);
    }
    function $m() {
      rl !== null && typeof rl.markComponentRenderStopped == "function" && rl.markComponentRenderStopped();
    }
    function rN(c) {
      rl !== null && typeof rl.markComponentPassiveEffectMountStarted == "function" && rl.markComponentPassiveEffectMountStarted(c);
    }
    function FN() {
      rl !== null && typeof rl.markComponentPassiveEffectMountStopped == "function" && rl.markComponentPassiveEffectMountStopped();
    }
    function NN(c) {
      rl !== null && typeof rl.markComponentPassiveEffectUnmountStarted == "function" && rl.markComponentPassiveEffectUnmountStarted(c);
    }
    function wN() {
      rl !== null && typeof rl.markComponentPassiveEffectUnmountStopped == "function" && rl.markComponentPassiveEffectUnmountStopped();
    }
    function zN(c) {
      rl !== null && typeof rl.markComponentLayoutEffectMountStarted == "function" && rl.markComponentLayoutEffectMountStarted(c);
    }
    function JN() {
      rl !== null && typeof rl.markComponentLayoutEffectMountStopped == "function" && rl.markComponentLayoutEffectMountStopped();
    }
    function p5(c) {
      rl !== null && typeof rl.markComponentLayoutEffectUnmountStarted == "function" && rl.markComponentLayoutEffectUnmountStarted(c);
    }
    function L5() {
      rl !== null && typeof rl.markComponentLayoutEffectUnmountStopped == "function" && rl.markComponentLayoutEffectUnmountStopped();
    }
    function HN(c, b, d) {
      rl !== null && typeof rl.markComponentErrored == "function" && rl.markComponentErrored(c, b, d);
    }
    function gN(c, b, d) {
      rl !== null && typeof rl.markComponentSuspended == "function" && rl.markComponentSuspended(c, b, d);
    }
    function vN(c) {
      rl !== null && typeof rl.markLayoutEffectsStarted == "function" && rl.markLayoutEffectsStarted(c);
    }
    function TN() {
      rl !== null && typeof rl.markLayoutEffectsStopped == "function" && rl.markLayoutEffectsStopped();
    }
    function fN(c) {
      rl !== null && typeof rl.markPassiveEffectsStarted == "function" && rl.markPassiveEffectsStarted(c);
    }
    function EN() {
      rl !== null && typeof rl.markPassiveEffectsStopped == "function" && rl.markPassiveEffectsStopped();
    }
    function h5(c) {
      rl !== null && typeof rl.markRenderStarted == "function" && rl.markRenderStarted(c);
    }
    function BN() {
      rl !== null && typeof rl.markRenderYielded == "function" && rl.markRenderYielded();
    }
    function y5() {
      rl !== null && typeof rl.markRenderStopped == "function" && rl.markRenderStopped();
    }
    function DN(c) {
      rl !== null && typeof rl.markRenderScheduled == "function" && rl.markRenderScheduled(c);
    }
    function jN(c, b) {
      rl !== null && typeof rl.markForceUpdateScheduled == "function" && rl.markForceUpdateScheduled(c, b);
    }
    function Dy(c, b) {
      rl !== null && typeof rl.markStateUpdateScheduled == "function" && rl.markStateUpdateScheduled(c, b);
    }
    var Ql = (
      /*                         */
      0
    ), pZ = (
      /*                 */
      1
    ), rZ = (
      /*                    */
      2
    ), Gc = (
      /*               */
      8
    ), qu = (
      /*              */
      16
    ), S5 = Math.clz32 ? Math.clz32 : ON, QN = Math.log, PN = Math.LN2;
    function ON(c) {
      var b = c >>> 0;
      return b === 0 ? 32 : 31 - (QN(b) / PN | 0) | 0;
    }
    var jy = 31, Sl = (
      /*                        */
      0
    ), Hc = (
      /*                          */
      0
    ), ql = (
      /*                        */
      1
    ), qm = (
      /*    */
      2
    ), Hs = (
      /*             */
      4
    ), zG = (
      /*            */
      8
    ), _u = (
      /*                     */
      16
    ), Oo = (
      /*                */
      32
    ), _m = (
      /*                       */
      4194240
    ), Ao = (
      /*                        */
      64
    ), Qy = (
      /*                        */
      128
    ), Py = (
      /*                        */
      256
    ), Oy = (
      /*                        */
      512
    ), Ay = (
      /*                        */
      1024
    ), $y = (
      /*                        */
      2048
    ), qy = (
      /*                        */
      4096
    ), _y = (
      /*                        */
      8192
    ), lS = (
      /*                        */
      16384
    ), ZS = (
      /*                       */
      32768
    ), cS = (
      /*                       */
      65536
    ), bS = (
      /*                       */
      131072
    ), uS = (
      /*                       */
      262144
    ), sS = (
      /*                       */
      524288
    ), dS = (
      /*                       */
      1048576
    ), GS = (
      /*                       */
      2097152
    ), Pn = (
      /*                            */
      130023424
    ), li = (
      /*                             */
      4194304
    ), mS = (
      /*                             */
      8388608
    ), iS = (
      /*                             */
      16777216
    ), oS = (
      /*                             */
      33554432
    ), eS = (
      /*                             */
      67108864
    ), t5 = li, $o = (
      /*          */
      134217728
    ), X5 = (
      /*                          */
      268435455
    ), qo = (
      /*               */
      268435456
    ), JG = (
      /*                        */
      536870912
    ), Db = (
      /*                   */
      1073741824
    );
    function AN(c) {
      {
        if (c & ql)
          return "Sync";
        if (c & qm)
          return "InputContinuousHydration";
        if (c & Hs)
          return "InputContinuous";
        if (c & zG)
          return "DefaultHydration";
        if (c & _u)
          return "Default";
        if (c & Oo)
          return "TransitionHydration";
        if (c & _m)
          return "Transition";
        if (c & Pn)
          return "Retry";
        if (c & $o)
          return "SelectiveHydration";
        if (c & qo)
          return "IdleHydration";
        if (c & JG)
          return "Idle";
        if (c & Db)
          return "Offscreen";
      }
    }
    var jZ = -1, On = Ao, An = li;
    function _o(c) {
      switch (HG(c)) {
        case ql:
          return ql;
        case qm:
          return qm;
        case Hs:
          return Hs;
        case zG:
          return zG;
        case _u:
          return _u;
        case Oo:
          return Oo;
        case Ao:
        case Qy:
        case Py:
        case Oy:
        case Ay:
        case $y:
        case qy:
        case _y:
        case lS:
        case ZS:
        case cS:
        case bS:
        case uS:
        case sS:
        case dS:
        case GS:
          return c & _m;
        case li:
        case mS:
        case iS:
        case oS:
        case eS:
          return c & Pn;
        case $o:
          return $o;
        case qo:
          return qo;
        case JG:
          return JG;
        case Db:
          return Db;
        default:
          return m("Should have found matching lanes. This is a bug in React."), c;
      }
    }
    function $n(c, b) {
      var d = c.pendingLanes;
      if (d === Sl)
        return Sl;
      var o = Sl, e = c.suspendedLanes, L = c.pingedLanes, X = d & X5;
      if (X !== Sl) {
        var K = X & ~e;
        if (K !== Sl)
          o = _o(K);
        else {
          var Y = X & L;
          Y !== Sl && (o = _o(Y));
        }
      } else {
        var N = d & ~e;
        N !== Sl ? o = _o(N) : L !== Sl && (o = _o(L));
      }
      if (o === Sl)
        return Sl;
      if (b !== Sl && b !== o && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (b & e) === Sl) {
        var H = HG(o), q = HG(b);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          H >= q || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          H === _u && (q & _m) !== Sl
        )
          return b;
      }
      (o & Hs) !== Sl && (o |= d & _u);
      var $ = c.entangledLanes;
      if ($ !== Sl)
        for (var sl = c.entanglements, Gl = o & $; Gl > 0; ) {
          var nl = gG(Gl), Ul = 1 << nl;
          o |= sl[nl], Gl &= ~Ul;
        }
      return o;
    }
    function $N(c, b) {
      for (var d = c.eventTimes, o = jZ; b > 0; ) {
        var e = gG(b), L = 1 << e, X = d[e];
        X > o && (o = X), b &= ~L;
      }
      return o;
    }
    function qN(c, b) {
      switch (c) {
        case ql:
        case qm:
        case Hs:
          return b + 250;
        case zG:
        case _u:
        case Oo:
        case Ao:
        case Qy:
        case Py:
        case Oy:
        case Ay:
        case $y:
        case qy:
        case _y:
        case lS:
        case ZS:
        case cS:
        case bS:
        case uS:
        case sS:
        case dS:
        case GS:
          return b + 5e3;
        case li:
        case mS:
        case iS:
        case oS:
        case eS:
          return jZ;
        case $o:
        case qo:
        case JG:
        case Db:
          return jZ;
        default:
          return m("Should have found matching lanes. This is a bug in React."), jZ;
      }
    }
    function _N(c, b) {
      for (var d = c.pendingLanes, o = c.suspendedLanes, e = c.pingedLanes, L = c.expirationTimes, X = d; X > 0; ) {
        var K = gG(X), Y = 1 << K, N = L[K];
        N === jZ ? ((Y & o) === Sl || (Y & e) !== Sl) && (L[K] = qN(Y, b)) : N <= b && (c.expiredLanes |= Y), X &= ~Y;
      }
    }
    function lw(c) {
      return _o(c.pendingLanes);
    }
    function aS(c) {
      var b = c.pendingLanes & ~Db;
      return b !== Sl ? b : b & Db ? Db : Sl;
    }
    function Zw(c) {
      return (c & ql) !== Sl;
    }
    function nS(c) {
      return (c & X5) !== Sl;
    }
    function K5(c) {
      return (c & Pn) === c;
    }
    function cw(c) {
      var b = ql | Hs | _u;
      return (c & b) === Sl;
    }
    function bw(c) {
      return (c & _m) === c;
    }
    function qn(c, b) {
      var d = qm | Hs | zG | _u;
      return (b & d) !== Sl;
    }
    function uw(c, b) {
      return (b & c.expiredLanes) !== Sl;
    }
    function W5(c) {
      return (c & _m) !== Sl;
    }
    function V5() {
      var c = On;
      return On <<= 1, (On & _m) === Sl && (On = Ao), c;
    }
    function sw() {
      var c = An;
      return An <<= 1, (An & Pn) === Sl && (An = li), c;
    }
    function HG(c) {
      return c & -c;
    }
    function le(c) {
      return HG(c);
    }
    function gG(c) {
      return 31 - S5(c);
    }
    function pS(c) {
      return gG(c);
    }
    function jb(c, b) {
      return (c & b) !== Sl;
    }
    function Zi(c, b) {
      return (c & b) === b;
    }
    function mZ(c, b) {
      return c | b;
    }
    function _n(c, b) {
      return c & ~b;
    }
    function x5(c, b) {
      return c & b;
    }
    function x_(c) {
      return c;
    }
    function dw(c, b) {
      return c !== Hc && c < b ? c : b;
    }
    function LS(c) {
      for (var b = [], d = 0; d < jy; d++)
        b.push(c);
      return b;
    }
    function Ze(c, b, d) {
      c.pendingLanes |= b, b !== JG && (c.suspendedLanes = Sl, c.pingedLanes = Sl);
      var o = c.eventTimes, e = pS(b);
      o[e] = d;
    }
    function Gw(c, b) {
      c.suspendedLanes |= b, c.pingedLanes &= ~b;
      for (var d = c.expirationTimes, o = b; o > 0; ) {
        var e = gG(o), L = 1 << e;
        d[e] = jZ, o &= ~L;
      }
    }
    function R5(c, b, d) {
      c.pingedLanes |= c.suspendedLanes & b;
    }
    function mw(c, b) {
      var d = c.pendingLanes & ~b;
      c.pendingLanes = b, c.suspendedLanes = Sl, c.pingedLanes = Sl, c.expiredLanes &= b, c.mutableReadLanes &= b, c.entangledLanes &= b;
      for (var o = c.entanglements, e = c.eventTimes, L = c.expirationTimes, X = d; X > 0; ) {
        var K = gG(X), Y = 1 << K;
        o[K] = Sl, e[K] = jZ, L[K] = jZ, X &= ~Y;
      }
    }
    function hS(c, b) {
      for (var d = c.entangledLanes |= b, o = c.entanglements, e = d; e; ) {
        var L = gG(e), X = 1 << L;
        // Is this one of the newly entangled lanes?
        X & b | // Is this lane transitively entangled with the newly entangled lanes?
        o[L] & b && (o[L] |= b), e &= ~X;
      }
    }
    function iw(c, b) {
      var d = HG(b), o;
      switch (d) {
        case Hs:
          o = qm;
          break;
        case _u:
          o = zG;
          break;
        case Ao:
        case Qy:
        case Py:
        case Oy:
        case Ay:
        case $y:
        case qy:
        case _y:
        case lS:
        case ZS:
        case cS:
        case bS:
        case uS:
        case sS:
        case dS:
        case GS:
        case li:
        case mS:
        case iS:
        case oS:
        case eS:
          o = Oo;
          break;
        case JG:
          o = qo;
          break;
        default:
          o = Hc;
          break;
      }
      return (o & (c.suspendedLanes | b)) !== Hc ? Hc : o;
    }
    function Y5(c, b, d) {
      if (Ru)
        for (var o = c.pendingUpdatersLaneMap; d > 0; ) {
          var e = pS(d), L = 1 << e, X = o[e];
          X.add(b), d &= ~L;
        }
    }
    function k5(c, b) {
      if (Ru)
        for (var d = c.pendingUpdatersLaneMap, o = c.memoizedUpdaters; b > 0; ) {
          var e = pS(b), L = 1 << e, X = d[e];
          X.size > 0 && (X.forEach(function(K) {
            var Y = K.alternate;
            (Y === null || !o.has(Y)) && o.add(K);
          }), X.clear()), b &= ~L;
        }
    }
    function M5(c, b) {
      return null;
    }
    var Qb = ql, gs = Hs, vs = _u, lp = JG, ce = Hc;
    function Yu() {
      return ce;
    }
    function gc(c) {
      ce = c;
    }
    function ow(c, b) {
      var d = ce;
      try {
        return ce = c, b();
      } finally {
        ce = d;
      }
    }
    function ew(c, b) {
      return c !== 0 && c < b ? c : b;
    }
    function aw(c, b) {
      return c > b ? c : b;
    }
    function yS(c, b) {
      return c !== 0 && c < b;
    }
    function I5(c) {
      var b = HG(c);
      return yS(Qb, b) ? yS(gs, b) ? nS(b) ? vs : lp : gs : Qb;
    }
    function Zp(c) {
      var b = c.current.memoizedState;
      return b.isDehydrated;
    }
    var U5;
    function nw(c) {
      U5 = c;
    }
    function pw(c) {
      U5(c);
    }
    var SS;
    function Lw(c) {
      SS = c;
    }
    var C5;
    function hw(c) {
      C5 = c;
    }
    var r5;
    function yw(c) {
      r5 = c;
    }
    var F5;
    function Sw(c) {
      F5 = c;
    }
    var tS = !1, cp = [], Ud = null, Cd = null, rd = null, be = /* @__PURE__ */ new Map(), ue = /* @__PURE__ */ new Map(), Fd = [], tw = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function Xw(c) {
      return tw.indexOf(c) > -1;
    }
    function Kw(c, b, d, o, e) {
      return {
        blockedOn: c,
        domEventName: b,
        eventSystemFlags: d,
        nativeEvent: e,
        targetContainers: [o]
      };
    }
    function N5(c, b) {
      switch (c) {
        case "focusin":
        case "focusout":
          Ud = null;
          break;
        case "dragenter":
        case "dragleave":
          Cd = null;
          break;
        case "mouseover":
        case "mouseout":
          rd = null;
          break;
        case "pointerover":
        case "pointerout": {
          var d = b.pointerId;
          be.delete(d);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var o = b.pointerId;
          ue.delete(o);
          break;
        }
      }
    }
    function se(c, b, d, o, e, L) {
      if (c === null || c.nativeEvent !== L) {
        var X = Kw(b, d, o, e, L);
        if (b !== null) {
          var K = zd(b);
          K !== null && SS(K);
        }
        return X;
      }
      c.eventSystemFlags |= o;
      var Y = c.targetContainers;
      return e !== null && Y.indexOf(e) === -1 && Y.push(e), c;
    }
    function Ww(c, b, d, o, e) {
      switch (b) {
        case "focusin": {
          var L = e;
          return Ud = se(Ud, c, b, d, o, L), !0;
        }
        case "dragenter": {
          var X = e;
          return Cd = se(Cd, c, b, d, o, X), !0;
        }
        case "mouseover": {
          var K = e;
          return rd = se(rd, c, b, d, o, K), !0;
        }
        case "pointerover": {
          var Y = e, N = Y.pointerId;
          return be.set(N, se(be.get(N) || null, c, b, d, o, Y)), !0;
        }
        case "gotpointercapture": {
          var H = e, q = H.pointerId;
          return ue.set(q, se(ue.get(q) || null, c, b, d, o, H)), !0;
        }
      }
      return !1;
    }
    function w5(c) {
      var b = fG(c.target);
      if (b !== null) {
        var d = NG(b);
        if (d !== null) {
          var o = d.tag;
          if (o === w) {
            var e = s5(d);
            if (e !== null) {
              c.blockedOn = e, F5(c.priority, function() {
                C5(d);
              });
              return;
            }
          } else if (o === h) {
            var L = d.stateNode;
            if (Zp(L)) {
              c.blockedOn = d5(d);
              return;
            }
          }
        }
      }
      c.blockedOn = null;
    }
    function Vw(c) {
      for (var b = r5(), d = {
        blockedOn: null,
        target: c,
        priority: b
      }, o = 0; o < Fd.length && yS(b, Fd[o].priority); o++)
        ;
      Fd.splice(o, 0, d), o === 0 && w5(d);
    }
    function bp(c) {
      if (c.blockedOn !== null)
        return !1;
      for (var b = c.targetContainers; b.length > 0; ) {
        var d = b[0], o = WS(c.domEventName, c.eventSystemFlags, d, c.nativeEvent);
        if (o === null) {
          var e = c.nativeEvent, L = new e.constructor(e.type, e);
          OF(L), e.target.dispatchEvent(L), AF();
        } else {
          var X = zd(o);
          return X !== null && SS(X), c.blockedOn = o, !1;
        }
        b.shift();
      }
      return !0;
    }
    function z5(c, b, d) {
      bp(c) && d.delete(b);
    }
    function xw() {
      tS = !1, Ud !== null && bp(Ud) && (Ud = null), Cd !== null && bp(Cd) && (Cd = null), rd !== null && bp(rd) && (rd = null), be.forEach(z5), ue.forEach(z5);
    }
    function de(c, b) {
      c.blockedOn === b && (c.blockedOn = null, tS || (tS = !0, Z.unstable_scheduleCallback(Z.unstable_NormalPriority, xw)));
    }
    function Ge(c) {
      if (cp.length > 0) {
        de(cp[0], c);
        for (var b = 1; b < cp.length; b++) {
          var d = cp[b];
          d.blockedOn === c && (d.blockedOn = null);
        }
      }
      Ud !== null && de(Ud, c), Cd !== null && de(Cd, c), rd !== null && de(rd, c);
      var o = function(K) {
        return de(K, c);
      };
      be.forEach(o), ue.forEach(o);
      for (var e = 0; e < Fd.length; e++) {
        var L = Fd[e];
        L.blockedOn === c && (L.blockedOn = null);
      }
      for (; Fd.length > 0; ) {
        var X = Fd[0];
        if (X.blockedOn !== null)
          break;
        w5(X), X.blockedOn === null && Fd.shift();
      }
    }
    var ci = u.ReactCurrentBatchConfig, XS = !0;
    function J5(c) {
      XS = !!c;
    }
    function Rw() {
      return XS;
    }
    function Yw(c, b, d) {
      var o = H5(b), e;
      switch (o) {
        case Qb:
          e = kw;
          break;
        case gs:
          e = Mw;
          break;
        case vs:
        default:
          e = KS;
          break;
      }
      return e.bind(null, b, d, c);
    }
    function kw(c, b, d, o) {
      var e = Yu(), L = ci.transition;
      ci.transition = null;
      try {
        gc(Qb), KS(c, b, d, o);
      } finally {
        gc(e), ci.transition = L;
      }
    }
    function Mw(c, b, d, o) {
      var e = Yu(), L = ci.transition;
      ci.transition = null;
      try {
        gc(gs), KS(c, b, d, o);
      } finally {
        gc(e), ci.transition = L;
      }
    }
    function KS(c, b, d, o) {
      XS && Iw(c, b, d, o);
    }
    function Iw(c, b, d, o) {
      var e = WS(c, b, d, o);
      if (e === null) {
        zS(c, b, o, up, d), N5(c, o);
        return;
      }
      if (Ww(e, c, b, d, o)) {
        o.stopPropagation();
        return;
      }
      if (N5(c, o), b & To && Xw(c)) {
        for (; e !== null; ) {
          var L = zd(e);
          L !== null && pw(L);
          var X = WS(c, b, d, o);
          if (X === null && zS(c, b, o, up, d), X === e)
            break;
          e = X;
        }
        e !== null && o.stopPropagation();
        return;
      }
      zS(c, b, o, null, d);
    }
    var up = null;
    function WS(c, b, d, o) {
      up = null;
      var e = Iy(o), L = fG(e);
      if (L !== null) {
        var X = NG(L);
        if (X === null)
          L = null;
        else {
          var K = X.tag;
          if (K === w) {
            var Y = s5(X);
            if (Y !== null)
              return Y;
            L = null;
          } else if (K === h) {
            var N = X.stateNode;
            if (Zp(N))
              return d5(X);
            L = null;
          } else X !== L && (L = null);
        }
      }
      return up = L, null;
    }
    function H5(c) {
      switch (c) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Qb;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return gs;
        case "message": {
          var b = XN();
          switch (b) {
            case Qn:
              return Qb;
            case Ey:
              return gs;
            case wG:
            case KN:
              return vs;
            case By:
              return lp;
            default:
              return vs;
          }
        }
        default:
          return vs;
      }
    }
    function Uw(c, b, d) {
      return c.addEventListener(b, d, !1), d;
    }
    function Cw(c, b, d) {
      return c.addEventListener(b, d, !0), d;
    }
    function rw(c, b, d, o) {
      return c.addEventListener(b, d, {
        capture: !0,
        passive: o
      }), d;
    }
    function Fw(c, b, d, o) {
      return c.addEventListener(b, d, {
        passive: o
      }), d;
    }
    var me = null, VS = null, ie = null;
    function Nw(c) {
      return me = c, VS = v5(), !0;
    }
    function ww() {
      me = null, VS = null, ie = null;
    }
    function g5() {
      if (ie)
        return ie;
      var c, b = VS, d = b.length, o, e = v5(), L = e.length;
      for (c = 0; c < d && b[c] === e[c]; c++)
        ;
      var X = d - c;
      for (o = 1; o <= X && b[d - o] === e[L - o]; o++)
        ;
      var K = o > 1 ? 1 - o : void 0;
      return ie = e.slice(c, K), ie;
    }
    function v5() {
      return "value" in me ? me.value : me.textContent;
    }
    function sp(c) {
      var b, d = c.keyCode;
      return "charCode" in c ? (b = c.charCode, b === 0 && d === 13 && (b = 13)) : b = d, b === 10 && (b = 13), b >= 32 || b === 13 ? b : 0;
    }
    function dp() {
      return !0;
    }
    function T5() {
      return !1;
    }
    function Pb(c) {
      function b(d, o, e, L, X) {
        this._reactName = d, this._targetInst = e, this.type = o, this.nativeEvent = L, this.target = X, this.currentTarget = null;
        for (var K in c)
          if (c.hasOwnProperty(K)) {
            var Y = c[K];
            Y ? this[K] = Y(L) : this[K] = L[K];
          }
        var N = L.defaultPrevented != null ? L.defaultPrevented : L.returnValue === !1;
        return N ? this.isDefaultPrevented = dp : this.isDefaultPrevented = T5, this.isPropagationStopped = T5, this;
      }
      return GZ(b.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = dp);
        },
        stopPropagation: function() {
          var d = this.nativeEvent;
          d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = dp);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: dp
      }), b;
    }
    var bi = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(c) {
        return c.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, xS = Pb(bi), oe = GZ({}, bi, {
      view: 0,
      detail: 0
    }), zw = Pb(oe), RS, YS, ee;
    function Jw(c) {
      c !== ee && (ee && c.type === "mousemove" ? (RS = c.screenX - ee.screenX, YS = c.screenY - ee.screenY) : (RS = 0, YS = 0), ee = c);
    }
    var Gp = GZ({}, oe, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: MS,
      button: 0,
      buttons: 0,
      relatedTarget: function(c) {
        return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
      },
      movementX: function(c) {
        return "movementX" in c ? c.movementX : (Jw(c), RS);
      },
      movementY: function(c) {
        return "movementY" in c ? c.movementY : YS;
      }
    }), f5 = Pb(Gp), Hw = GZ({}, Gp, {
      dataTransfer: 0
    }), gw = Pb(Hw), vw = GZ({}, oe, {
      relatedTarget: 0
    }), kS = Pb(vw), Tw = GZ({}, bi, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), fw = Pb(Tw), Ew = GZ({}, bi, {
      clipboardData: function(c) {
        return "clipboardData" in c ? c.clipboardData : window.clipboardData;
      }
    }), Bw = Pb(Ew), Dw = GZ({}, bi, {
      data: 0
    }), E5 = Pb(Dw), jw = E5, Qw = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Pw = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Ow(c) {
      if (c.key) {
        var b = Qw[c.key] || c.key;
        if (b !== "Unidentified")
          return b;
      }
      if (c.type === "keypress") {
        var d = sp(c);
        return d === 13 ? "Enter" : String.fromCharCode(d);
      }
      return c.type === "keydown" || c.type === "keyup" ? Pw[c.keyCode] || "Unidentified" : "";
    }
    var Aw = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function $w(c) {
      var b = this, d = b.nativeEvent;
      if (d.getModifierState)
        return d.getModifierState(c);
      var o = Aw[c];
      return o ? !!d[o] : !1;
    }
    function MS(c) {
      return $w;
    }
    var qw = GZ({}, oe, {
      key: Ow,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: MS,
      // Legacy Interface
      charCode: function(c) {
        return c.type === "keypress" ? sp(c) : 0;
      },
      keyCode: function(c) {
        return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      },
      which: function(c) {
        return c.type === "keypress" ? sp(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      }
    }), _w = Pb(qw), lz = GZ({}, Gp, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), B5 = Pb(lz), Zz = GZ({}, oe, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: MS
    }), cz = Pb(Zz), bz = GZ({}, bi, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), uz = Pb(bz), sz = GZ({}, Gp, {
      deltaX: function(c) {
        return "deltaX" in c ? c.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in c ? -c.wheelDeltaX : 0
        );
      },
      deltaY: function(c) {
        return "deltaY" in c ? c.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in c ? -c.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in c ? -c.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), dz = Pb(sz), Gz = [9, 13, 27, 32], D5 = 229, IS = wl && "CompositionEvent" in window, ae = null;
    wl && "documentMode" in document && (ae = document.documentMode);
    var mz = wl && "TextEvent" in window && !ae, j5 = wl && (!IS || ae && ae > 8 && ae <= 11), Q5 = 32, P5 = String.fromCharCode(Q5);
    function iz() {
      hl("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), hl("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hl("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), hl("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var O5 = !1;
    function oz(c) {
      return (c.ctrlKey || c.altKey || c.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(c.ctrlKey && c.altKey);
    }
    function ez(c) {
      switch (c) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function az(c, b) {
      return c === "keydown" && b.keyCode === D5;
    }
    function A5(c, b) {
      switch (c) {
        case "keyup":
          return Gz.indexOf(b.keyCode) !== -1;
        case "keydown":
          return b.keyCode !== D5;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function $5(c) {
      var b = c.detail;
      return typeof b == "object" && "data" in b ? b.data : null;
    }
    function q5(c) {
      return c.locale === "ko";
    }
    var ui = !1;
    function nz(c, b, d, o, e) {
      var L, X;
      if (IS ? L = ez(b) : ui ? A5(b, o) && (L = "onCompositionEnd") : az(b, o) && (L = "onCompositionStart"), !L)
        return null;
      j5 && !q5(o) && (!ui && L === "onCompositionStart" ? ui = Nw(e) : L === "onCompositionEnd" && ui && (X = g5()));
      var K = ap(d, L);
      if (K.length > 0) {
        var Y = new E5(L, b, null, o, e);
        if (c.push({
          event: Y,
          listeners: K
        }), X)
          Y.data = X;
        else {
          var N = $5(o);
          N !== null && (Y.data = N);
        }
      }
    }
    function pz(c, b) {
      switch (c) {
        case "compositionend":
          return $5(b);
        case "keypress":
          var d = b.which;
          return d !== Q5 ? null : (O5 = !0, P5);
        case "textInput":
          var o = b.data;
          return o === P5 && O5 ? null : o;
        default:
          return null;
      }
    }
    function Lz(c, b) {
      if (ui) {
        if (c === "compositionend" || !IS && A5(c, b)) {
          var d = g5();
          return ww(), ui = !1, d;
        }
        return null;
      }
      switch (c) {
        case "paste":
          return null;
        case "keypress":
          if (!oz(b)) {
            if (b.char && b.char.length > 1)
              return b.char;
            if (b.which)
              return String.fromCharCode(b.which);
          }
          return null;
        case "compositionend":
          return j5 && !q5(b) ? null : b.data;
        default:
          return null;
      }
    }
    function hz(c, b, d, o, e) {
      var L;
      if (mz ? L = pz(b, o) : L = Lz(b, o), !L)
        return null;
      var X = ap(d, "onBeforeInput");
      if (X.length > 0) {
        var K = new jw("onBeforeInput", "beforeinput", null, o, e);
        c.push({
          event: K,
          listeners: X
        }), K.data = L;
      }
    }
    function yz(c, b, d, o, e, L, X) {
      nz(c, b, d, o, e), hz(c, b, d, o, e);
    }
    var Sz = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function _5(c) {
      var b = c && c.nodeName && c.nodeName.toLowerCase();
      return b === "input" ? !!Sz[c.type] : b === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function tz(c) {
      if (!wl)
        return !1;
      var b = "on" + c, d = b in document;
      if (!d) {
        var o = document.createElement("div");
        o.setAttribute(b, "return;"), d = typeof o[b] == "function";
      }
      return d;
    }
    function Xz() {
      hl("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function l0(c, b, d, o) {
      $x(o);
      var e = ap(b, "onChange");
      if (e.length > 0) {
        var L = new xS("onChange", "change", null, d, o);
        c.push({
          event: L,
          listeners: e
        });
      }
    }
    var ne = null, pe = null;
    function Kz(c) {
      var b = c.nodeName && c.nodeName.toLowerCase();
      return b === "select" || b === "input" && c.type === "file";
    }
    function Wz(c) {
      var b = [];
      l0(b, pe, c, Iy(c)), Z5(Vz, b);
    }
    function Vz(c) {
      S0(c, 0);
    }
    function mp(c) {
      var b = oi(c);
      if (gm(b))
        return c;
    }
    function xz(c, b) {
      if (c === "change")
        return b;
    }
    var Z0 = !1;
    wl && (Z0 = tz("input") && (!document.documentMode || document.documentMode > 9));
    function Rz(c, b) {
      ne = c, pe = b, ne.attachEvent("onpropertychange", b0);
    }
    function c0() {
      ne && (ne.detachEvent("onpropertychange", b0), ne = null, pe = null);
    }
    function b0(c) {
      c.propertyName === "value" && mp(pe) && Wz(c);
    }
    function Yz(c, b, d) {
      c === "focusin" ? (c0(), Rz(b, d)) : c === "focusout" && c0();
    }
    function kz(c, b) {
      if (c === "selectionchange" || c === "keyup" || c === "keydown")
        return mp(pe);
    }
    function Mz(c) {
      var b = c.nodeName;
      return b && b.toLowerCase() === "input" && (c.type === "checkbox" || c.type === "radio");
    }
    function Iz(c, b) {
      if (c === "click")
        return mp(b);
    }
    function Uz(c, b) {
      if (c === "input" || c === "change")
        return mp(b);
    }
    function Cz(c) {
      var b = c._wrapperState;
      !b || !b.controlled || c.type !== "number" || $l(c, "number", c.value);
    }
    function rz(c, b, d, o, e, L, X) {
      var K = d ? oi(d) : window, Y, N;
      if (Kz(K) ? Y = xz : _5(K) ? Z0 ? Y = Uz : (Y = kz, N = Yz) : Mz(K) && (Y = Iz), Y) {
        var H = Y(b, d);
        if (H) {
          l0(c, H, o, e);
          return;
        }
      }
      N && N(b, K, d), b === "focusout" && Cz(K);
    }
    function Fz() {
      cl("onMouseEnter", ["mouseout", "mouseover"]), cl("onMouseLeave", ["mouseout", "mouseover"]), cl("onPointerEnter", ["pointerout", "pointerover"]), cl("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Nz(c, b, d, o, e, L, X) {
      var K = b === "mouseover" || b === "pointerover", Y = b === "mouseout" || b === "pointerout";
      if (K && !$F(o)) {
        var N = o.relatedTarget || o.fromElement;
        if (N && (fG(N) || Ie(N)))
          return;
      }
      if (!(!Y && !K)) {
        var H;
        if (e.window === e)
          H = e;
        else {
          var q = e.ownerDocument;
          q ? H = q.defaultView || q.parentWindow : H = window;
        }
        var $, sl;
        if (Y) {
          var Gl = o.relatedTarget || o.toElement;
          if ($ = d, sl = Gl ? fG(Gl) : null, sl !== null) {
            var nl = NG(sl);
            (sl !== nl || sl.tag !== t && sl.tag !== W) && (sl = null);
          }
        } else
          $ = null, sl = d;
        if ($ !== sl) {
          var Ul = f5, Dl = "onMouseLeave", fl = "onMouseEnter", hZ = "mouse";
          (b === "pointerout" || b === "pointerover") && (Ul = B5, Dl = "onPointerLeave", fl = "onPointerEnter", hZ = "pointer");
          var eZ = $ == null ? H : oi($), bl = sl == null ? H : oi(sl), pl = new Ul(Dl, hZ + "leave", $, o, e);
          pl.target = eZ, pl.relatedTarget = bl;
          var ul = null, Xl = fG(e);
          if (Xl === d) {
            var Nl = new Ul(fl, hZ + "enter", sl, o, e);
            Nl.target = bl, Nl.relatedTarget = eZ, ul = Nl;
          }
          uJ(c, pl, ul, $, sl);
        }
      }
    }
    function wz(c, b) {
      return c === b && (c !== 0 || 1 / c === 1 / b) || c !== c && b !== b;
    }
    var Ob = typeof Object.is == "function" ? Object.is : wz;
    function Le(c, b) {
      if (Ob(c, b))
        return !0;
      if (typeof c != "object" || c === null || typeof b != "object" || b === null)
        return !1;
      var d = Object.keys(c), o = Object.keys(b);
      if (d.length !== o.length)
        return !1;
      for (var e = 0; e < d.length; e++) {
        var L = d[e];
        if (!Jl.call(b, L) || !Ob(c[L], b[L]))
          return !1;
      }
      return !0;
    }
    function u0(c) {
      for (; c && c.firstChild; )
        c = c.firstChild;
      return c;
    }
    function zz(c) {
      for (; c; ) {
        if (c.nextSibling)
          return c.nextSibling;
        c = c.parentNode;
      }
    }
    function s0(c, b) {
      for (var d = u0(c), o = 0, e = 0; d; ) {
        if (d.nodeType === rs) {
          if (e = o + d.textContent.length, o <= b && e >= b)
            return {
              node: d,
              offset: b - o
            };
          o = e;
        }
        d = u0(zz(d));
      }
    }
    function Jz(c) {
      var b = c.ownerDocument, d = b && b.defaultView || window, o = d.getSelection && d.getSelection();
      if (!o || o.rangeCount === 0)
        return null;
      var e = o.anchorNode, L = o.anchorOffset, X = o.focusNode, K = o.focusOffset;
      try {
        e.nodeType, X.nodeType;
      } catch {
        return null;
      }
      return Hz(c, e, L, X, K);
    }
    function Hz(c, b, d, o, e) {
      var L = 0, X = -1, K = -1, Y = 0, N = 0, H = c, q = null;
      l: for (; ; ) {
        for (var $ = null; H === b && (d === 0 || H.nodeType === rs) && (X = L + d), H === o && (e === 0 || H.nodeType === rs) && (K = L + e), H.nodeType === rs && (L += H.nodeValue.length), ($ = H.firstChild) !== null; )
          q = H, H = $;
        for (; ; ) {
          if (H === c)
            break l;
          if (q === b && ++Y === d && (X = L), q === o && ++N === e && (K = L), ($ = H.nextSibling) !== null)
            break;
          H = q, q = H.parentNode;
        }
        H = $;
      }
      return X === -1 || K === -1 ? null : {
        start: X,
        end: K
      };
    }
    function gz(c, b) {
      var d = c.ownerDocument || document, o = d && d.defaultView || window;
      if (o.getSelection) {
        var e = o.getSelection(), L = c.textContent.length, X = Math.min(b.start, L), K = b.end === void 0 ? X : Math.min(b.end, L);
        if (!e.extend && X > K) {
          var Y = K;
          K = X, X = Y;
        }
        var N = s0(c, X), H = s0(c, K);
        if (N && H) {
          if (e.rangeCount === 1 && e.anchorNode === N.node && e.anchorOffset === N.offset && e.focusNode === H.node && e.focusOffset === H.offset)
            return;
          var q = d.createRange();
          q.setStart(N.node, N.offset), e.removeAllRanges(), X > K ? (e.addRange(q), e.extend(H.node, H.offset)) : (q.setEnd(H.node, H.offset), e.addRange(q));
        }
      }
    }
    function d0(c) {
      return c && c.nodeType === rs;
    }
    function G0(c, b) {
      return !c || !b ? !1 : c === b ? !0 : d0(c) ? !1 : d0(b) ? G0(c, b.parentNode) : "contains" in c ? c.contains(b) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(b) & 16) : !1;
    }
    function vz(c) {
      return c && c.ownerDocument && G0(c.ownerDocument.documentElement, c);
    }
    function Tz(c) {
      try {
        return typeof c.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function m0() {
      for (var c = window, b = kd(); b instanceof c.HTMLIFrameElement; ) {
        if (Tz(b))
          c = b.contentWindow;
        else
          return b;
        b = kd(c.document);
      }
      return b;
    }
    function US(c) {
      var b = c && c.nodeName && c.nodeName.toLowerCase();
      return b && (b === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || b === "textarea" || c.contentEditable === "true");
    }
    function fz() {
      var c = m0();
      return {
        focusedElem: c,
        selectionRange: US(c) ? Bz(c) : null
      };
    }
    function Ez(c) {
      var b = m0(), d = c.focusedElem, o = c.selectionRange;
      if (b !== d && vz(d)) {
        o !== null && US(d) && Dz(d, o);
        for (var e = [], L = d; L = L.parentNode; )
          L.nodeType === Ub && e.push({
            element: L,
            left: L.scrollLeft,
            top: L.scrollTop
          });
        typeof d.focus == "function" && d.focus();
        for (var X = 0; X < e.length; X++) {
          var K = e[X];
          K.element.scrollLeft = K.left, K.element.scrollTop = K.top;
        }
      }
    }
    function Bz(c) {
      var b;
      return "selectionStart" in c ? b = {
        start: c.selectionStart,
        end: c.selectionEnd
      } : b = Jz(c), b || {
        start: 0,
        end: 0
      };
    }
    function Dz(c, b) {
      var d = b.start, o = b.end;
      o === void 0 && (o = d), "selectionStart" in c ? (c.selectionStart = d, c.selectionEnd = Math.min(o, c.value.length)) : gz(c, b);
    }
    var jz = wl && "documentMode" in document && document.documentMode <= 11;
    function Qz() {
      hl("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var si = null, CS = null, he = null, rS = !1;
    function Pz(c) {
      if ("selectionStart" in c && US(c))
        return {
          start: c.selectionStart,
          end: c.selectionEnd
        };
      var b = c.ownerDocument && c.ownerDocument.defaultView || window, d = b.getSelection();
      return {
        anchorNode: d.anchorNode,
        anchorOffset: d.anchorOffset,
        focusNode: d.focusNode,
        focusOffset: d.focusOffset
      };
    }
    function Oz(c) {
      return c.window === c ? c.document : c.nodeType === Fs ? c : c.ownerDocument;
    }
    function i0(c, b, d) {
      var o = Oz(d);
      if (!(rS || si == null || si !== kd(o))) {
        var e = Pz(si);
        if (!he || !Le(he, e)) {
          he = e;
          var L = ap(CS, "onSelect");
          if (L.length > 0) {
            var X = new xS("onSelect", "select", null, b, d);
            c.push({
              event: X,
              listeners: L
            }), X.target = si;
          }
        }
      }
    }
    function Az(c, b, d, o, e, L, X) {
      var K = d ? oi(d) : window;
      switch (b) {
        case "focusin":
          (_5(K) || K.contentEditable === "true") && (si = K, CS = d, he = null);
          break;
        case "focusout":
          si = null, CS = null, he = null;
          break;
        case "mousedown":
          rS = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          rS = !1, i0(c, o, e);
          break;
        case "selectionchange":
          if (jz)
            break;
        case "keydown":
        case "keyup":
          i0(c, o, e);
      }
    }
    function ip(c, b) {
      var d = {};
      return d[c.toLowerCase()] = b.toLowerCase(), d["Webkit" + c] = "webkit" + b, d["Moz" + c] = "moz" + b, d;
    }
    var di = {
      animationend: ip("Animation", "AnimationEnd"),
      animationiteration: ip("Animation", "AnimationIteration"),
      animationstart: ip("Animation", "AnimationStart"),
      transitionend: ip("Transition", "TransitionEnd")
    }, FS = {}, o0 = {};
    wl && (o0 = document.createElement("div").style, "AnimationEvent" in window || (delete di.animationend.animation, delete di.animationiteration.animation, delete di.animationstart.animation), "TransitionEvent" in window || delete di.transitionend.transition);
    function op(c) {
      if (FS[c])
        return FS[c];
      if (!di[c])
        return c;
      var b = di[c];
      for (var d in b)
        if (b.hasOwnProperty(d) && d in o0)
          return FS[c] = b[d];
      return c;
    }
    var e0 = op("animationend"), a0 = op("animationiteration"), n0 = op("animationstart"), p0 = op("transitionend"), L0 = /* @__PURE__ */ new Map(), h0 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Nd(c, b) {
      L0.set(c, b), hl(b, [c]);
    }
    function $z() {
      for (var c = 0; c < h0.length; c++) {
        var b = h0[c], d = b.toLowerCase(), o = b[0].toUpperCase() + b.slice(1);
        Nd(d, "on" + o);
      }
      Nd(e0, "onAnimationEnd"), Nd(a0, "onAnimationIteration"), Nd(n0, "onAnimationStart"), Nd("dblclick", "onDoubleClick"), Nd("focusin", "onFocus"), Nd("focusout", "onBlur"), Nd(p0, "onTransitionEnd");
    }
    function qz(c, b, d, o, e, L, X) {
      var K = L0.get(b);
      if (K !== void 0) {
        var Y = xS, N = b;
        switch (b) {
          case "keypress":
            if (sp(o) === 0)
              return;
          case "keydown":
          case "keyup":
            Y = _w;
            break;
          case "focusin":
            N = "focus", Y = kS;
            break;
          case "focusout":
            N = "blur", Y = kS;
            break;
          case "beforeblur":
          case "afterblur":
            Y = kS;
            break;
          case "click":
            if (o.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            Y = f5;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            Y = gw;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            Y = cz;
            break;
          case e0:
          case a0:
          case n0:
            Y = fw;
            break;
          case p0:
            Y = uz;
            break;
          case "scroll":
            Y = zw;
            break;
          case "wheel":
            Y = dz;
            break;
          case "copy":
          case "cut":
          case "paste":
            Y = Bw;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            Y = B5;
            break;
        }
        var H = (L & To) !== 0;
        {
          var q = !H && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          b === "scroll", $ = cJ(d, K, o.type, H, q);
          if ($.length > 0) {
            var sl = new Y(K, N, null, o, e);
            c.push({
              event: sl,
              listeners: $
            });
          }
        }
      }
    }
    $z(), Fz(), Xz(), Qz(), iz();
    function _z(c, b, d, o, e, L, X) {
      qz(c, b, d, o, e, L);
      var K = (L & PF) === 0;
      K && (Nz(c, b, d, o, e), rz(c, b, d, o, e), Az(c, b, d, o, e), yz(c, b, d, o, e));
    }
    var ye = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], NS = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(ye));
    function y0(c, b, d) {
      var o = c.type || "unknown-event";
      c.currentTarget = d, dN(o, b, void 0, c), c.currentTarget = null;
    }
    function lJ(c, b, d) {
      var o;
      if (d)
        for (var e = b.length - 1; e >= 0; e--) {
          var L = b[e], X = L.instance, K = L.currentTarget, Y = L.listener;
          if (X !== o && c.isPropagationStopped())
            return;
          y0(c, Y, K), o = X;
        }
      else
        for (var N = 0; N < b.length; N++) {
          var H = b[N], q = H.instance, $ = H.currentTarget, sl = H.listener;
          if (q !== o && c.isPropagationStopped())
            return;
          y0(c, sl, $), o = q;
        }
    }
    function S0(c, b) {
      for (var d = (b & To) !== 0, o = 0; o < c.length; o++) {
        var e = c[o], L = e.event, X = e.listeners;
        lJ(L, X, d);
      }
      GN();
    }
    function ZJ(c, b, d, o, e) {
      var L = Iy(d), X = [];
      _z(X, c, o, d, L, b), S0(X, b);
    }
    function $Z(c, b) {
      NS.has(c) || m('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', c);
      var d = !1, o = CH(b), e = sJ(c);
      o.has(e) || (t0(b, c, My, d), o.add(e));
    }
    function wS(c, b, d) {
      NS.has(c) && !b && m('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', c);
      var o = 0;
      b && (o |= To), t0(d, c, o, b);
    }
    var ep = "_reactListening" + Math.random().toString(36).slice(2);
    function Se(c) {
      if (!c[ep]) {
        c[ep] = !0, Vl.forEach(function(d) {
          d !== "selectionchange" && (NS.has(d) || wS(d, !1, c), wS(d, !0, c));
        });
        var b = c.nodeType === Fs ? c : c.ownerDocument;
        b !== null && (b[ep] || (b[ep] = !0, wS("selectionchange", !1, b)));
      }
    }
    function t0(c, b, d, o, e) {
      var L = Yw(c, b, d), X = void 0;
      ry && (b === "touchstart" || b === "touchmove" || b === "wheel") && (X = !0), c = c, o ? X !== void 0 ? rw(c, b, L, X) : Cw(c, b, L) : X !== void 0 ? Fw(c, b, L, X) : Uw(c, b, L);
    }
    function X0(c, b) {
      return c === b || c.nodeType === tc && c.parentNode === b;
    }
    function zS(c, b, d, o, e) {
      var L = o;
      if (!(b & Ox) && !(b & My)) {
        var X = e;
        if (o !== null) {
          var K = o;
          l: for (; ; ) {
            if (K === null)
              return;
            var Y = K.tag;
            if (Y === h || Y === S) {
              var N = K.stateNode.containerInfo;
              if (X0(N, X))
                break;
              if (Y === S)
                for (var H = K.return; H !== null; ) {
                  var q = H.tag;
                  if (q === h || q === S) {
                    var $ = H.stateNode.containerInfo;
                    if (X0($, X))
                      return;
                  }
                  H = H.return;
                }
              for (; N !== null; ) {
                var sl = fG(N);
                if (sl === null)
                  return;
                var Gl = sl.tag;
                if (Gl === t || Gl === W) {
                  K = L = sl;
                  continue l;
                }
                N = N.parentNode;
              }
            }
            K = K.return;
          }
        }
      }
      Z5(function() {
        return ZJ(c, b, d, L);
      });
    }
    function te(c, b, d) {
      return {
        instance: c,
        listener: b,
        currentTarget: d
      };
    }
    function cJ(c, b, d, o, e, L) {
      for (var X = b !== null ? b + "Capture" : null, K = o ? X : b, Y = [], N = c, H = null; N !== null; ) {
        var q = N, $ = q.stateNode, sl = q.tag;
        if (sl === t && $ !== null && (H = $, K !== null)) {
          var Gl = Eo(N, K);
          Gl != null && Y.push(te(N, Gl, H));
        }
        if (e)
          break;
        N = N.return;
      }
      return Y;
    }
    function ap(c, b) {
      for (var d = b + "Capture", o = [], e = c; e !== null; ) {
        var L = e, X = L.stateNode, K = L.tag;
        if (K === t && X !== null) {
          var Y = X, N = Eo(e, d);
          N != null && o.unshift(te(e, N, Y));
          var H = Eo(e, b);
          H != null && o.push(te(e, H, Y));
        }
        e = e.return;
      }
      return o;
    }
    function Gi(c) {
      if (c === null)
        return null;
      do
        c = c.return;
      while (c && c.tag !== t);
      return c || null;
    }
    function bJ(c, b) {
      for (var d = c, o = b, e = 0, L = d; L; L = Gi(L))
        e++;
      for (var X = 0, K = o; K; K = Gi(K))
        X++;
      for (; e - X > 0; )
        d = Gi(d), e--;
      for (; X - e > 0; )
        o = Gi(o), X--;
      for (var Y = e; Y--; ) {
        if (d === o || o !== null && d === o.alternate)
          return d;
        d = Gi(d), o = Gi(o);
      }
      return null;
    }
    function K0(c, b, d, o, e) {
      for (var L = b._reactName, X = [], K = d; K !== null && K !== o; ) {
        var Y = K, N = Y.alternate, H = Y.stateNode, q = Y.tag;
        if (N !== null && N === o)
          break;
        if (q === t && H !== null) {
          var $ = H;
          if (e) {
            var sl = Eo(K, L);
            sl != null && X.unshift(te(K, sl, $));
          } else if (!e) {
            var Gl = Eo(K, L);
            Gl != null && X.push(te(K, Gl, $));
          }
        }
        K = K.return;
      }
      X.length !== 0 && c.push({
        event: b,
        listeners: X
      });
    }
    function uJ(c, b, d, o, e) {
      var L = o && e ? bJ(o, e) : null;
      o !== null && K0(c, b, o, L, !1), e !== null && d !== null && K0(c, d, e, L, !0);
    }
    function sJ(c, b) {
      return c + "__bubble";
    }
    var Cb = !1, Xe = "dangerouslySetInnerHTML", np = "suppressContentEditableWarning", wd = "suppressHydrationWarning", W0 = "autoFocus", vG = "children", TG = "style", pp = "__html", JS, Lp, Ke, V0, hp, x0, R0;
    JS = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Lp = function(c, b) {
      TF(c, b), fF(c, b), QF(c, b, {
        registrationNameDependencies: el,
        possibleRegistrationNames: xl
      });
    }, x0 = wl && !document.documentMode, Ke = function(c, b, d) {
      if (!Cb) {
        var o = yp(d), e = yp(b);
        e !== o && (Cb = !0, m("Prop `%s` did not match. Server: %s Client: %s", c, JSON.stringify(e), JSON.stringify(o)));
      }
    }, V0 = function(c) {
      if (!Cb) {
        Cb = !0;
        var b = [];
        c.forEach(function(d) {
          b.push(d);
        }), m("Extra attributes from the server: %s", b);
      }
    }, hp = function(c, b) {
      b === !1 ? m("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", c, c, c) : m("Expected `%s` listener to be a function, instead got a value of `%s` type.", c, typeof b);
    }, R0 = function(c, b) {
      var d = c.namespaceURI === Cs ? c.ownerDocument.createElement(c.tagName) : c.ownerDocument.createElementNS(c.namespaceURI, c.tagName);
      return d.innerHTML = b, d.innerHTML;
    };
    var dJ = /\r\n?/g, GJ = /\u0000|\uFFFD/g;
    function yp(c) {
      Nc(c);
      var b = typeof c == "string" ? c : "" + c;
      return b.replace(dJ, `
`).replace(GJ, "");
    }
    function Sp(c, b, d, o) {
      var e = yp(b), L = yp(c);
      if (L !== e && (o && (Cb || (Cb = !0, m('Text content did not match. Server: "%s" Client: "%s"', L, e))), d && f))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function Y0(c) {
      return c.nodeType === Fs ? c : c.ownerDocument;
    }
    function mJ() {
    }
    function tp(c) {
      c.onclick = mJ;
    }
    function iJ(c, b, d, o, e) {
      for (var L in o)
        if (o.hasOwnProperty(L)) {
          var X = o[L];
          if (L === TG)
            X && Object.freeze(X), Ex(b, X);
          else if (L === Xe) {
            var K = X ? X[pp] : void 0;
            K != null && Hx(b, K);
          } else if (L === vG)
            if (typeof X == "string") {
              var Y = c !== "textarea" || X !== "";
              Y && Tn(b, X);
            } else typeof X == "number" && Tn(b, "" + X);
          else L === np || L === wd || L === W0 || (el.hasOwnProperty(L) ? X != null && (typeof X != "function" && hp(L, X), L === "onScroll" && $Z("scroll", b)) : X != null && Ku(b, L, X, e));
        }
    }
    function oJ(c, b, d, o) {
      for (var e = 0; e < b.length; e += 2) {
        var L = b[e], X = b[e + 1];
        L === TG ? Ex(c, X) : L === Xe ? Hx(c, X) : L === vG ? Tn(c, X) : Ku(c, L, X, o);
      }
    }
    function eJ(c, b, d, o) {
      var e, L = Y0(d), X, K = o;
      if (K === Cs && (K = Wy(c)), K === Cs) {
        if (e = IG(c, b), !e && c !== c.toLowerCase() && m("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", c), c === "script") {
          var Y = L.createElement("div");
          Y.innerHTML = "<script><\/script>";
          var N = Y.firstChild;
          X = Y.removeChild(N);
        } else if (typeof b.is == "string")
          X = L.createElement(c, {
            is: b.is
          });
        else if (X = L.createElement(c), c === "select") {
          var H = X;
          b.multiple ? H.multiple = !0 : b.size && (H.size = b.size);
        }
      } else
        X = L.createElementNS(K, c);
      return K === Cs && !e && Object.prototype.toString.call(X) === "[object HTMLUnknownElement]" && !Jl.call(JS, c) && (JS[c] = !0, m("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", c)), X;
    }
    function aJ(c, b) {
      return Y0(b).createTextNode(c);
    }
    function nJ(c, b, d, o) {
      var e = IG(b, d);
      Lp(b, d);
      var L;
      switch (b) {
        case "dialog":
          $Z("cancel", c), $Z("close", c), L = d;
          break;
        case "iframe":
        case "object":
        case "embed":
          $Z("load", c), L = d;
          break;
        case "video":
        case "audio":
          for (var X = 0; X < ye.length; X++)
            $Z(ye[X], c);
          L = d;
          break;
        case "source":
          $Z("error", c), L = d;
          break;
        case "img":
        case "image":
        case "link":
          $Z("error", c), $Z("load", c), L = d;
          break;
        case "details":
          $Z("toggle", c), L = d;
          break;
        case "input":
          Q(c, d), L = I(c, d), $Z("invalid", c);
          break;
        case "option":
          fZ(c, d), L = d;
          break;
        case "select":
          go(c, d), L = Ho(c, d), $Z("invalid", c);
          break;
        case "textarea":
          wx(c, d), L = Xy(c, d), $Z("invalid", c);
          break;
        default:
          L = d;
      }
      switch (ky(b, L), iJ(b, c, o, L, e), b) {
        case "input":
          Is(c), Yl(c, d, !1);
          break;
        case "textarea":
          Is(c), Jx(c);
          break;
        case "option":
          AZ(c, d);
          break;
        case "select":
          ty(c, d);
          break;
        default:
          typeof L.onClick == "function" && tp(c);
          break;
      }
    }
    function pJ(c, b, d, o, e) {
      Lp(b, o);
      var L = null, X, K;
      switch (b) {
        case "input":
          X = I(c, d), K = I(c, o), L = [];
          break;
        case "select":
          X = Ho(c, d), K = Ho(c, o), L = [];
          break;
        case "textarea":
          X = Xy(c, d), K = Xy(c, o), L = [];
          break;
        default:
          X = d, K = o, typeof X.onClick != "function" && typeof K.onClick == "function" && tp(c);
          break;
      }
      ky(b, K);
      var Y, N, H = null;
      for (Y in X)
        if (!(K.hasOwnProperty(Y) || !X.hasOwnProperty(Y) || X[Y] == null))
          if (Y === TG) {
            var q = X[Y];
            for (N in q)
              q.hasOwnProperty(N) && (H || (H = {}), H[N] = "");
          } else Y === Xe || Y === vG || Y === np || Y === wd || Y === W0 || (el.hasOwnProperty(Y) ? L || (L = []) : (L = L || []).push(Y, null));
      for (Y in K) {
        var $ = K[Y], sl = X != null ? X[Y] : void 0;
        if (!(!K.hasOwnProperty(Y) || $ === sl || $ == null && sl == null))
          if (Y === TG)
            if ($ && Object.freeze($), sl) {
              for (N in sl)
                sl.hasOwnProperty(N) && (!$ || !$.hasOwnProperty(N)) && (H || (H = {}), H[N] = "");
              for (N in $)
                $.hasOwnProperty(N) && sl[N] !== $[N] && (H || (H = {}), H[N] = $[N]);
            } else
              H || (L || (L = []), L.push(Y, H)), H = $;
          else if (Y === Xe) {
            var Gl = $ ? $[pp] : void 0, nl = sl ? sl[pp] : void 0;
            Gl != null && nl !== Gl && (L = L || []).push(Y, Gl);
          } else Y === vG ? (typeof $ == "string" || typeof $ == "number") && (L = L || []).push(Y, "" + $) : Y === np || Y === wd || (el.hasOwnProperty(Y) ? ($ != null && (typeof $ != "function" && hp(Y, $), Y === "onScroll" && $Z("scroll", c)), !L && sl !== $ && (L = [])) : (L = L || []).push(Y, $));
      }
      return H && (FF(H, K[TG]), (L = L || []).push(TG, H)), L;
    }
    function LJ(c, b, d, o, e) {
      d === "input" && e.type === "radio" && e.name != null && dl(c, e);
      var L = IG(d, o), X = IG(d, e);
      switch (oJ(c, b, L, X), d) {
        case "input":
          al(c, e);
          break;
        case "textarea":
          zx(c, e);
          break;
        case "select":
          oF(c, e);
          break;
      }
    }
    function hJ(c) {
      {
        var b = c.toLowerCase();
        return fn.hasOwnProperty(b) && fn[b] || null;
      }
    }
    function yJ(c, b, d, o, e, L, X) {
      var K, Y;
      switch (K = IG(b, d), Lp(b, d), b) {
        case "dialog":
          $Z("cancel", c), $Z("close", c);
          break;
        case "iframe":
        case "object":
        case "embed":
          $Z("load", c);
          break;
        case "video":
        case "audio":
          for (var N = 0; N < ye.length; N++)
            $Z(ye[N], c);
          break;
        case "source":
          $Z("error", c);
          break;
        case "img":
        case "image":
        case "link":
          $Z("error", c), $Z("load", c);
          break;
        case "details":
          $Z("toggle", c);
          break;
        case "input":
          Q(c, d), $Z("invalid", c);
          break;
        case "option":
          fZ(c, d);
          break;
        case "select":
          go(c, d), $Z("invalid", c);
          break;
        case "textarea":
          wx(c, d), $Z("invalid", c);
          break;
      }
      ky(b, d);
      {
        Y = /* @__PURE__ */ new Set();
        for (var H = c.attributes, q = 0; q < H.length; q++) {
          var $ = H[q].name.toLowerCase();
          switch ($) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              Y.add(H[q].name);
          }
        }
      }
      var sl = null;
      for (var Gl in d)
        if (d.hasOwnProperty(Gl)) {
          var nl = d[Gl];
          if (Gl === vG)
            typeof nl == "string" ? c.textContent !== nl && (d[wd] !== !0 && Sp(c.textContent, nl, L, X), sl = [vG, nl]) : typeof nl == "number" && c.textContent !== "" + nl && (d[wd] !== !0 && Sp(c.textContent, nl, L, X), sl = [vG, "" + nl]);
          else if (el.hasOwnProperty(Gl))
            nl != null && (typeof nl != "function" && hp(Gl, nl), Gl === "onScroll" && $Z("scroll", c));
          else if (X && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof K == "boolean") {
            var Ul = void 0, Dl = K && Wl ? null : pb(Gl);
            if (d[wd] !== !0) {
              if (!(Gl === np || Gl === wd || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Gl === "value" || Gl === "checked" || Gl === "selected")) {
                if (Gl === Xe) {
                  var fl = c.innerHTML, hZ = nl ? nl[pp] : void 0;
                  if (hZ != null) {
                    var eZ = R0(c, hZ);
                    eZ !== fl && Ke(Gl, fl, eZ);
                  }
                } else if (Gl === TG) {
                  if (Y.delete(Gl), x0) {
                    var bl = CF(nl);
                    Ul = c.getAttribute("style"), bl !== Ul && Ke(Gl, Ul, bl);
                  }
                } else if (K && !Wl)
                  Y.delete(Gl.toLowerCase()), Ul = Qu(c, Gl, nl), nl !== Ul && Ke(Gl, Ul, nl);
                else if (!Zc(Gl, Dl, K) && !zZ(Gl, nl, Dl, K)) {
                  var pl = !1;
                  if (Dl !== null)
                    Y.delete(Dl.attributeName), Ul = Xu(c, Gl, nl, Dl);
                  else {
                    var ul = o;
                    if (ul === Cs && (ul = Wy(b)), ul === Cs)
                      Y.delete(Gl.toLowerCase());
                    else {
                      var Xl = hJ(Gl);
                      Xl !== null && Xl !== Gl && (pl = !0, Y.delete(Xl)), Y.delete(Gl);
                    }
                    Ul = Qu(c, Gl, nl);
                  }
                  var Nl = Wl;
                  !Nl && nl !== Ul && !pl && Ke(Gl, Ul, nl);
                }
              }
            }
          }
        }
      switch (X && // $FlowFixMe - Should be inferred as not undefined.
      Y.size > 0 && d[wd] !== !0 && V0(Y), b) {
        case "input":
          Is(c), Yl(c, d, !0);
          break;
        case "textarea":
          Is(c), Jx(c);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof d.onClick == "function" && tp(c);
          break;
      }
      return sl;
    }
    function SJ(c, b, d) {
      var o = c.nodeValue !== b;
      return o;
    }
    function HS(c, b) {
      {
        if (Cb)
          return;
        Cb = !0, m("Did not expect server HTML to contain a <%s> in <%s>.", b.nodeName.toLowerCase(), c.nodeName.toLowerCase());
      }
    }
    function gS(c, b) {
      {
        if (Cb)
          return;
        Cb = !0, m('Did not expect server HTML to contain the text node "%s" in <%s>.', b.nodeValue, c.nodeName.toLowerCase());
      }
    }
    function vS(c, b, d) {
      {
        if (Cb)
          return;
        Cb = !0, m("Expected server HTML to contain a matching <%s> in <%s>.", b, c.nodeName.toLowerCase());
      }
    }
    function TS(c, b) {
      {
        if (b === "" || Cb)
          return;
        Cb = !0, m('Expected server HTML to contain a matching text node for "%s" in <%s>.', b, c.nodeName.toLowerCase());
      }
    }
    function tJ(c, b, d) {
      switch (b) {
        case "input":
          Ol(c, d);
          return;
        case "textarea":
          aF(c, d);
          return;
        case "select":
          eF(c, d);
          return;
      }
    }
    var We = function() {
    }, Ve = function() {
    };
    {
      var XJ = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], k0 = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], KJ = k0.concat(["button"]), WJ = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], M0 = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Ve = function(c, b) {
        var d = GZ({}, c || M0), o = {
          tag: b
        };
        return k0.indexOf(b) !== -1 && (d.aTagInScope = null, d.buttonTagInScope = null, d.nobrTagInScope = null), KJ.indexOf(b) !== -1 && (d.pTagInButtonScope = null), XJ.indexOf(b) !== -1 && b !== "address" && b !== "div" && b !== "p" && (d.listItemTagAutoclosing = null, d.dlItemTagAutoclosing = null), d.current = o, b === "form" && (d.formTag = o), b === "a" && (d.aTagInScope = o), b === "button" && (d.buttonTagInScope = o), b === "nobr" && (d.nobrTagInScope = o), b === "p" && (d.pTagInButtonScope = o), b === "li" && (d.listItemTagAutoclosing = o), (b === "dd" || b === "dt") && (d.dlItemTagAutoclosing = o), d;
      };
      var VJ = function(c, b) {
        switch (b) {
          case "select":
            return c === "option" || c === "optgroup" || c === "#text";
          case "optgroup":
            return c === "option" || c === "#text";
          case "option":
            return c === "#text";
          case "tr":
            return c === "th" || c === "td" || c === "style" || c === "script" || c === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return c === "tr" || c === "style" || c === "script" || c === "template";
          case "colgroup":
            return c === "col" || c === "template";
          case "table":
            return c === "caption" || c === "colgroup" || c === "tbody" || c === "tfoot" || c === "thead" || c === "style" || c === "script" || c === "template";
          case "head":
            return c === "base" || c === "basefont" || c === "bgsound" || c === "link" || c === "meta" || c === "title" || c === "noscript" || c === "noframes" || c === "style" || c === "script" || c === "template";
          case "html":
            return c === "head" || c === "body" || c === "frameset";
          case "frameset":
            return c === "frame";
          case "#document":
            return c === "html";
        }
        switch (c) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return b !== "h1" && b !== "h2" && b !== "h3" && b !== "h4" && b !== "h5" && b !== "h6";
          case "rp":
          case "rt":
            return WJ.indexOf(b) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return b == null;
        }
        return !0;
      }, xJ = function(c, b) {
        switch (c) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return b.pTagInButtonScope;
          case "form":
            return b.formTag || b.pTagInButtonScope;
          case "li":
            return b.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return b.dlItemTagAutoclosing;
          case "button":
            return b.buttonTagInScope;
          case "a":
            return b.aTagInScope;
          case "nobr":
            return b.nobrTagInScope;
        }
        return null;
      }, I0 = {};
      We = function(c, b, d) {
        d = d || M0;
        var o = d.current, e = o && o.tag;
        b != null && (c != null && m("validateDOMNesting: when childText is passed, childTag should be null"), c = "#text");
        var L = VJ(c, e) ? null : o, X = L ? null : xJ(c, d), K = L || X;
        if (K) {
          var Y = K.tag, N = !!L + "|" + c + "|" + Y;
          if (!I0[N]) {
            I0[N] = !0;
            var H = c, q = "";
            if (c === "#text" ? /\S/.test(b) ? H = "Text nodes" : (H = "Whitespace text nodes", q = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : H = "<" + c + ">", L) {
              var $ = "";
              Y === "table" && c === "tr" && ($ += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), m("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", H, Y, q, $);
            } else
              m("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", H, Y);
          }
        }
      };
    }
    var Xp = "suppressHydrationWarning", Kp = "$", Wp = "/$", xe = "$?", Re = "$!", RJ = "style", fS = null, ES = null;
    function YJ(c) {
      var b, d, o = c.nodeType;
      switch (o) {
        case Fs:
        case xy: {
          b = o === Fs ? "#document" : "#fragment";
          var e = c.documentElement;
          d = e ? e.namespaceURI : Vy(null, "");
          break;
        }
        default: {
          var L = o === tc ? c.parentNode : c, X = L.namespaceURI || null;
          b = L.tagName, d = Vy(X, b);
          break;
        }
      }
      {
        var K = b.toLowerCase(), Y = Ve(null, K);
        return {
          namespace: d,
          ancestorInfo: Y
        };
      }
    }
    function kJ(c, b, d) {
      {
        var o = c, e = Vy(o.namespace, b), L = Ve(o.ancestorInfo, b);
        return {
          namespace: e,
          ancestorInfo: L
        };
      }
    }
    function R_(c) {
      return c;
    }
    function MJ(c) {
      fS = Rw(), ES = fz();
      var b = null;
      return J5(!1), b;
    }
    function IJ(c) {
      Ez(ES), J5(fS), fS = null, ES = null;
    }
    function UJ(c, b, d, o, e) {
      var L;
      {
        var X = o;
        if (We(c, null, X.ancestorInfo), typeof b.children == "string" || typeof b.children == "number") {
          var K = "" + b.children, Y = Ve(X.ancestorInfo, c);
          We(null, K, Y);
        }
        L = X.namespace;
      }
      var N = eJ(c, b, d, L);
      return Me(e, N), $S(N, b), N;
    }
    function CJ(c, b) {
      c.appendChild(b);
    }
    function rJ(c, b, d, o, e) {
      switch (nJ(c, b, d, o), b) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!d.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function FJ(c, b, d, o, e, L) {
      {
        var X = L;
        if (typeof o.children != typeof d.children && (typeof o.children == "string" || typeof o.children == "number")) {
          var K = "" + o.children, Y = Ve(X.ancestorInfo, b);
          We(null, K, Y);
        }
      }
      return pJ(c, b, d, o);
    }
    function BS(c, b) {
      return c === "textarea" || c === "noscript" || typeof b.children == "string" || typeof b.children == "number" || typeof b.dangerouslySetInnerHTML == "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
    }
    function NJ(c, b, d, o) {
      {
        var e = d;
        We(null, c, e.ancestorInfo);
      }
      var L = aJ(c, b);
      return Me(o, L), L;
    }
    function wJ() {
      var c = window.event;
      return c === void 0 ? vs : H5(c.type);
    }
    var DS = typeof setTimeout == "function" ? setTimeout : void 0, zJ = typeof clearTimeout == "function" ? clearTimeout : void 0, jS = -1, U0 = typeof Promise == "function" ? Promise : void 0, JJ = typeof queueMicrotask == "function" ? queueMicrotask : typeof U0 < "u" ? function(c) {
      return U0.resolve(null).then(c).catch(HJ);
    } : DS;
    function HJ(c) {
      setTimeout(function() {
        throw c;
      });
    }
    function gJ(c, b, d, o) {
      switch (b) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && c.focus();
          return;
        case "img": {
          d.src && (c.src = d.src);
          return;
        }
      }
    }
    function vJ(c, b, d, o, e, L) {
      LJ(c, b, d, o, e), $S(c, e);
    }
    function C0(c) {
      Tn(c, "");
    }
    function TJ(c, b, d) {
      c.nodeValue = d;
    }
    function fJ(c, b) {
      c.appendChild(b);
    }
    function EJ(c, b) {
      var d;
      c.nodeType === tc ? (d = c.parentNode, d.insertBefore(b, c)) : (d = c, d.appendChild(b));
      var o = c._reactRootContainer;
      o == null && d.onclick === null && tp(d);
    }
    function BJ(c, b, d) {
      c.insertBefore(b, d);
    }
    function DJ(c, b, d) {
      c.nodeType === tc ? c.parentNode.insertBefore(b, d) : c.insertBefore(b, d);
    }
    function jJ(c, b) {
      c.removeChild(b);
    }
    function QJ(c, b) {
      c.nodeType === tc ? c.parentNode.removeChild(b) : c.removeChild(b);
    }
    function QS(c, b) {
      var d = b, o = 0;
      do {
        var e = d.nextSibling;
        if (c.removeChild(d), e && e.nodeType === tc) {
          var L = e.data;
          if (L === Wp)
            if (o === 0) {
              c.removeChild(e), Ge(b);
              return;
            } else
              o--;
          else (L === Kp || L === xe || L === Re) && o++;
        }
        d = e;
      } while (d);
      Ge(b);
    }
    function PJ(c, b) {
      c.nodeType === tc ? QS(c.parentNode, b) : c.nodeType === Ub && QS(c, b), Ge(c);
    }
    function OJ(c) {
      c = c;
      var b = c.style;
      typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none";
    }
    function AJ(c) {
      c.nodeValue = "";
    }
    function $J(c, b) {
      c = c;
      var d = b[RJ], o = d != null && d.hasOwnProperty("display") ? d.display : null;
      c.style.display = Ry("display", o);
    }
    function qJ(c, b) {
      c.nodeValue = b;
    }
    function _J(c) {
      c.nodeType === Ub ? c.textContent = "" : c.nodeType === Fs && c.documentElement && c.removeChild(c.documentElement);
    }
    function lH(c, b, d) {
      return c.nodeType !== Ub || b.toLowerCase() !== c.nodeName.toLowerCase() ? null : c;
    }
    function ZH(c, b) {
      return b === "" || c.nodeType !== rs ? null : c;
    }
    function cH(c) {
      return c.nodeType !== tc ? null : c;
    }
    function r0(c) {
      return c.data === xe;
    }
    function PS(c) {
      return c.data === Re;
    }
    function bH(c) {
      var b = c.nextSibling && c.nextSibling.dataset, d, o, e;
      return b && (d = b.dgst, o = b.msg, e = b.stck), {
        message: o,
        digest: d,
        stack: e
      };
    }
    function uH(c, b) {
      c._reactRetry = b;
    }
    function Vp(c) {
      for (; c != null; c = c.nextSibling) {
        var b = c.nodeType;
        if (b === Ub || b === rs)
          break;
        if (b === tc) {
          var d = c.data;
          if (d === Kp || d === Re || d === xe)
            break;
          if (d === Wp)
            return null;
        }
      }
      return c;
    }
    function Ye(c) {
      return Vp(c.nextSibling);
    }
    function sH(c) {
      return Vp(c.firstChild);
    }
    function dH(c) {
      return Vp(c.firstChild);
    }
    function GH(c) {
      return Vp(c.nextSibling);
    }
    function mH(c, b, d, o, e, L, X) {
      Me(L, c), $S(c, d);
      var K;
      {
        var Y = e;
        K = Y.namespace;
      }
      var N = (L.mode & pZ) !== Ql;
      return yJ(c, b, d, K, o, N, X);
    }
    function iH(c, b, d, o) {
      return Me(d, c), d.mode & pZ, SJ(c, b);
    }
    function oH(c, b) {
      Me(b, c);
    }
    function eH(c) {
      for (var b = c.nextSibling, d = 0; b; ) {
        if (b.nodeType === tc) {
          var o = b.data;
          if (o === Wp) {
            if (d === 0)
              return Ye(b);
            d--;
          } else (o === Kp || o === Re || o === xe) && d++;
        }
        b = b.nextSibling;
      }
      return null;
    }
    function F0(c) {
      for (var b = c.previousSibling, d = 0; b; ) {
        if (b.nodeType === tc) {
          var o = b.data;
          if (o === Kp || o === Re || o === xe) {
            if (d === 0)
              return b;
            d--;
          } else o === Wp && d++;
        }
        b = b.previousSibling;
      }
      return null;
    }
    function aH(c) {
      Ge(c);
    }
    function nH(c) {
      Ge(c);
    }
    function pH(c) {
      return c !== "head" && c !== "body";
    }
    function LH(c, b, d, o) {
      var e = !0;
      Sp(b.nodeValue, d, o, e);
    }
    function hH(c, b, d, o, e, L) {
      if (b[Xp] !== !0) {
        var X = !0;
        Sp(o.nodeValue, e, L, X);
      }
    }
    function yH(c, b) {
      b.nodeType === Ub ? HS(c, b) : b.nodeType === tc || gS(c, b);
    }
    function SH(c, b) {
      {
        var d = c.parentNode;
        d !== null && (b.nodeType === Ub ? HS(d, b) : b.nodeType === tc || gS(d, b));
      }
    }
    function tH(c, b, d, o, e) {
      (e || b[Xp] !== !0) && (o.nodeType === Ub ? HS(d, o) : o.nodeType === tc || gS(d, o));
    }
    function XH(c, b, d) {
      vS(c, b);
    }
    function KH(c, b) {
      TS(c, b);
    }
    function WH(c, b, d) {
      {
        var o = c.parentNode;
        o !== null && vS(o, b);
      }
    }
    function VH(c, b) {
      {
        var d = c.parentNode;
        d !== null && TS(d, b);
      }
    }
    function xH(c, b, d, o, e, L) {
      (L || b[Xp] !== !0) && vS(d, o);
    }
    function RH(c, b, d, o, e) {
      (e || b[Xp] !== !0) && TS(d, o);
    }
    function YH(c) {
      m("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", c.nodeName.toLowerCase());
    }
    function kH(c) {
      Se(c);
    }
    var mi = Math.random().toString(36).slice(2), ii = "__reactFiber$" + mi, OS = "__reactProps$" + mi, ke = "__reactContainer$" + mi, AS = "__reactEvents$" + mi, MH = "__reactListeners$" + mi, IH = "__reactHandles$" + mi;
    function UH(c) {
      delete c[ii], delete c[OS], delete c[AS], delete c[MH], delete c[IH];
    }
    function Me(c, b) {
      b[ii] = c;
    }
    function xp(c, b) {
      b[ke] = c;
    }
    function N0(c) {
      c[ke] = null;
    }
    function Ie(c) {
      return !!c[ke];
    }
    function fG(c) {
      var b = c[ii];
      if (b)
        return b;
      for (var d = c.parentNode; d; ) {
        if (b = d[ke] || d[ii], b) {
          var o = b.alternate;
          if (b.child !== null || o !== null && o.child !== null)
            for (var e = F0(c); e !== null; ) {
              var L = e[ii];
              if (L)
                return L;
              e = F0(e);
            }
          return b;
        }
        c = d, d = c.parentNode;
      }
      return null;
    }
    function zd(c) {
      var b = c[ii] || c[ke];
      return b && (b.tag === t || b.tag === W || b.tag === w || b.tag === h) ? b : null;
    }
    function oi(c) {
      if (c.tag === t || c.tag === W)
        return c.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function Rp(c) {
      return c[OS] || null;
    }
    function $S(c, b) {
      c[OS] = b;
    }
    function CH(c) {
      var b = c[AS];
      return b === void 0 && (b = c[AS] = /* @__PURE__ */ new Set()), b;
    }
    var w0 = {}, z0 = u.ReactDebugCurrentFrame;
    function Yp(c) {
      if (c) {
        var b = c._owner, d = xd(c.type, c._source, b ? b.type : null);
        z0.setExtraStackFrame(d);
      } else
        z0.setExtraStackFrame(null);
    }
    function ku(c, b, d, o, e) {
      {
        var L = Function.call.bind(Jl);
        for (var X in c)
          if (L(c, X)) {
            var K = void 0;
            try {
              if (typeof c[X] != "function") {
                var Y = Error((o || "React class") + ": " + d + " type `" + X + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c[X] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Y.name = "Invariant Violation", Y;
              }
              K = c[X](b, X, o, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (N) {
              K = N;
            }
            K && !(K instanceof Error) && (Yp(e), m("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", o || "React class", d, X, typeof K), Yp(null)), K instanceof Error && !(K.message in w0) && (w0[K.message] = !0, Yp(e), m("Failed %s type: %s", d, K.message), Yp(null));
          }
      }
    }
    var qS = [], kp;
    kp = [];
    var Ts = -1;
    function Jd(c) {
      return {
        current: c
      };
    }
    function db(c, b) {
      if (Ts < 0) {
        m("Unexpected pop.");
        return;
      }
      b !== kp[Ts] && m("Unexpected Fiber popped."), c.current = qS[Ts], qS[Ts] = null, kp[Ts] = null, Ts--;
    }
    function Gb(c, b, d) {
      Ts++, qS[Ts] = c.current, kp[Ts] = d, c.current = b;
    }
    var _S;
    _S = {};
    var Ab = {};
    Object.freeze(Ab);
    var fs = Jd(Ab), ls = Jd(!1), lt = Ab;
    function ei(c, b, d) {
      return d && Zs(b) ? lt : fs.current;
    }
    function J0(c, b, d) {
      {
        var o = c.stateNode;
        o.__reactInternalMemoizedUnmaskedChildContext = b, o.__reactInternalMemoizedMaskedChildContext = d;
      }
    }
    function ai(c, b) {
      {
        var d = c.type, o = d.contextTypes;
        if (!o)
          return Ab;
        var e = c.stateNode;
        if (e && e.__reactInternalMemoizedUnmaskedChildContext === b)
          return e.__reactInternalMemoizedMaskedChildContext;
        var L = {};
        for (var X in o)
          L[X] = b[X];
        {
          var K = bZ(c) || "Unknown";
          ku(o, L, "context", K);
        }
        return e && J0(c, b, L), L;
      }
    }
    function Mp() {
      return ls.current;
    }
    function Zs(c) {
      {
        var b = c.childContextTypes;
        return b != null;
      }
    }
    function Ip(c) {
      db(ls, c), db(fs, c);
    }
    function Zt(c) {
      db(ls, c), db(fs, c);
    }
    function H0(c, b, d) {
      {
        if (fs.current !== Ab)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Gb(fs, b, c), Gb(ls, d, c);
      }
    }
    function g0(c, b, d) {
      {
        var o = c.stateNode, e = b.childContextTypes;
        if (typeof o.getChildContext != "function") {
          {
            var L = bZ(c) || "Unknown";
            _S[L] || (_S[L] = !0, m("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", L, L));
          }
          return d;
        }
        var X = o.getChildContext();
        for (var K in X)
          if (!(K in e))
            throw new Error((bZ(c) || "Unknown") + '.getChildContext(): key "' + K + '" is not defined in childContextTypes.');
        {
          var Y = bZ(c) || "Unknown";
          ku(e, X, "child context", Y);
        }
        return GZ({}, d, X);
      }
    }
    function Up(c) {
      {
        var b = c.stateNode, d = b && b.__reactInternalMemoizedMergedChildContext || Ab;
        return lt = fs.current, Gb(fs, d, c), Gb(ls, ls.current, c), !0;
      }
    }
    function v0(c, b, d) {
      {
        var o = c.stateNode;
        if (!o)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (d) {
          var e = g0(c, b, lt);
          o.__reactInternalMemoizedMergedChildContext = e, db(ls, c), db(fs, c), Gb(fs, e, c), Gb(ls, d, c);
        } else
          db(ls, c), Gb(ls, d, c);
      }
    }
    function rH(c) {
      {
        if (!pN(c) || c.tag !== p)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var b = c;
        do {
          switch (b.tag) {
            case h:
              return b.stateNode.context;
            case p: {
              var d = b.type;
              if (Zs(d))
                return b.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          b = b.return;
        } while (b !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Hd = 0, Cp = 1, Es = null, ct = !1, bt = !1;
    function T0(c) {
      Es === null ? Es = [c] : Es.push(c);
    }
    function FH(c) {
      ct = !0, T0(c);
    }
    function f0() {
      ct && gd();
    }
    function gd() {
      if (!bt && Es !== null) {
        bt = !0;
        var c = 0, b = Yu();
        try {
          var d = !0, o = Es;
          for (gc(Qb); c < o.length; c++) {
            var e = o[c];
            do
              e = e(d);
            while (e !== null);
          }
          Es = null, ct = !1;
        } catch (L) {
          throw Es !== null && (Es = Es.slice(c + 1)), a5(Qn, gd), L;
        } finally {
          gc(b), bt = !1;
        }
      }
      return null;
    }
    var ni = [], pi = 0, rp = null, Fp = 0, su = [], du = 0, EG = null, Bs = 1, Ds = "";
    function NH(c) {
      return DG(), (c.flags & u5) !== Pl;
    }
    function wH(c) {
      return DG(), Fp;
    }
    function zH() {
      var c = Ds, b = Bs, d = b & ~JH(b);
      return d.toString(32) + c;
    }
    function BG(c, b) {
      DG(), ni[pi++] = Fp, ni[pi++] = rp, rp = c, Fp = b;
    }
    function E0(c, b, d) {
      DG(), su[du++] = Bs, su[du++] = Ds, su[du++] = EG, EG = c;
      var o = Bs, e = Ds, L = Np(o) - 1, X = o & ~(1 << L), K = d + 1, Y = Np(b) + L;
      if (Y > 30) {
        var N = L - L % 5, H = (1 << N) - 1, q = (X & H).toString(32), $ = X >> N, sl = L - N, Gl = Np(b) + sl, nl = K << sl, Ul = nl | $, Dl = q + e;
        Bs = 1 << Gl | Ul, Ds = Dl;
      } else {
        var fl = K << L, hZ = fl | X, eZ = e;
        Bs = 1 << Y | hZ, Ds = eZ;
      }
    }
    function ut(c) {
      DG();
      var b = c.return;
      if (b !== null) {
        var d = 1, o = 0;
        BG(c, d), E0(c, d, o);
      }
    }
    function Np(c) {
      return 32 - S5(c);
    }
    function JH(c) {
      return 1 << Np(c) - 1;
    }
    function st(c) {
      for (; c === rp; )
        rp = ni[--pi], ni[pi] = null, Fp = ni[--pi], ni[pi] = null;
      for (; c === EG; )
        EG = su[--du], su[du] = null, Ds = su[--du], su[du] = null, Bs = su[--du], su[du] = null;
    }
    function HH() {
      return DG(), EG !== null ? {
        id: Bs,
        overflow: Ds
      } : null;
    }
    function gH(c, b) {
      DG(), su[du++] = Bs, su[du++] = Ds, su[du++] = EG, Bs = b.id, Ds = b.overflow, EG = c;
    }
    function DG() {
      Dc() || m("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Bc = null, Gu = null, Mu = !1, jG = !1, vd = null;
    function vH() {
      Mu && m("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function B0() {
      jG = !0;
    }
    function TH() {
      return jG;
    }
    function fH(c) {
      var b = c.stateNode.containerInfo;
      return Gu = dH(b), Bc = c, Mu = !0, vd = null, jG = !1, !0;
    }
    function EH(c, b, d) {
      return Gu = GH(b), Bc = c, Mu = !0, vd = null, jG = !1, d !== null && gH(c, d), !0;
    }
    function D0(c, b) {
      switch (c.tag) {
        case h: {
          yH(c.stateNode.containerInfo, b);
          break;
        }
        case t: {
          var d = (c.mode & pZ) !== Ql;
          tH(
            c.type,
            c.memoizedProps,
            c.stateNode,
            b,
            // TODO: Delete this argument when we remove the legacy root API.
            d
          );
          break;
        }
        case w: {
          var o = c.memoizedState;
          o.dehydrated !== null && SH(o.dehydrated, b);
          break;
        }
      }
    }
    function j0(c, b) {
      D0(c, b);
      var d = Qv();
      d.stateNode = b, d.return = c;
      var o = c.deletions;
      o === null ? (c.deletions = [d], c.flags |= UG) : o.push(d);
    }
    function dt(c, b) {
      {
        if (jG)
          return;
        switch (c.tag) {
          case h: {
            var d = c.stateNode.containerInfo;
            switch (b.tag) {
              case t:
                var o = b.type;
                b.pendingProps, XH(d, o);
                break;
              case W:
                var e = b.pendingProps;
                KH(d, e);
                break;
            }
            break;
          }
          case t: {
            var L = c.type, X = c.memoizedProps, K = c.stateNode;
            switch (b.tag) {
              case t: {
                var Y = b.type, N = b.pendingProps, H = (c.mode & pZ) !== Ql;
                xH(
                  L,
                  X,
                  K,
                  Y,
                  N,
                  // TODO: Delete this argument when we remove the legacy root API.
                  H
                );
                break;
              }
              case W: {
                var q = b.pendingProps, $ = (c.mode & pZ) !== Ql;
                RH(
                  L,
                  X,
                  K,
                  q,
                  // TODO: Delete this argument when we remove the legacy root API.
                  $
                );
                break;
              }
            }
            break;
          }
          case w: {
            var sl = c.memoizedState, Gl = sl.dehydrated;
            if (Gl !== null) switch (b.tag) {
              case t:
                var nl = b.type;
                b.pendingProps, WH(Gl, nl);
                break;
              case W:
                var Ul = b.pendingProps;
                VH(Gl, Ul);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function Q0(c, b) {
      b.flags = b.flags & ~ws | Xc, dt(c, b);
    }
    function P0(c, b) {
      switch (c.tag) {
        case t: {
          var d = c.type;
          c.pendingProps;
          var o = lH(b, d);
          return o !== null ? (c.stateNode = o, Bc = c, Gu = sH(o), !0) : !1;
        }
        case W: {
          var e = c.pendingProps, L = ZH(b, e);
          return L !== null ? (c.stateNode = L, Bc = c, Gu = null, !0) : !1;
        }
        case w: {
          var X = cH(b);
          if (X !== null) {
            var K = {
              dehydrated: X,
              treeContext: HH(),
              retryLane: Db
            };
            c.memoizedState = K;
            var Y = Pv(X);
            return Y.return = c, c.child = Y, Bc = c, Gu = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Gt(c) {
      return (c.mode & pZ) !== Ql && (c.flags & RZ) === Pl;
    }
    function mt(c) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function it(c) {
      if (Mu) {
        var b = Gu;
        if (!b) {
          Gt(c) && (dt(Bc, c), mt()), Q0(Bc, c), Mu = !1, Bc = c;
          return;
        }
        var d = b;
        if (!P0(c, b)) {
          Gt(c) && (dt(Bc, c), mt()), b = Ye(d);
          var o = Bc;
          if (!b || !P0(c, b)) {
            Q0(Bc, c), Mu = !1, Bc = c;
            return;
          }
          j0(o, d);
        }
      }
    }
    function BH(c, b, d) {
      var o = c.stateNode, e = !jG, L = mH(o, c.type, c.memoizedProps, b, d, c, e);
      return c.updateQueue = L, L !== null;
    }
    function DH(c) {
      var b = c.stateNode, d = c.memoizedProps, o = iH(b, d, c);
      if (o) {
        var e = Bc;
        if (e !== null)
          switch (e.tag) {
            case h: {
              var L = e.stateNode.containerInfo, X = (e.mode & pZ) !== Ql;
              LH(
                L,
                b,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                X
              );
              break;
            }
            case t: {
              var K = e.type, Y = e.memoizedProps, N = e.stateNode, H = (e.mode & pZ) !== Ql;
              hH(
                K,
                Y,
                N,
                b,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                H
              );
              break;
            }
          }
      }
      return o;
    }
    function jH(c) {
      var b = c.memoizedState, d = b !== null ? b.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      oH(d, c);
    }
    function QH(c) {
      var b = c.memoizedState, d = b !== null ? b.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return eH(d);
    }
    function O0(c) {
      for (var b = c.return; b !== null && b.tag !== t && b.tag !== h && b.tag !== w; )
        b = b.return;
      Bc = b;
    }
    function wp(c) {
      if (c !== Bc)
        return !1;
      if (!Mu)
        return O0(c), Mu = !0, !1;
      if (c.tag !== h && (c.tag !== t || pH(c.type) && !BS(c.type, c.memoizedProps))) {
        var b = Gu;
        if (b)
          if (Gt(c))
            A0(c), mt();
          else
            for (; b; )
              j0(c, b), b = Ye(b);
      }
      return O0(c), c.tag === w ? Gu = QH(c) : Gu = Bc ? Ye(c.stateNode) : null, !0;
    }
    function PH() {
      return Mu && Gu !== null;
    }
    function A0(c) {
      for (var b = Gu; b; )
        D0(c, b), b = Ye(b);
    }
    function Li() {
      Bc = null, Gu = null, Mu = !1, jG = !1;
    }
    function $0() {
      vd !== null && (BY(vd), vd = null);
    }
    function Dc() {
      return Mu;
    }
    function ot(c) {
      vd === null ? vd = [c] : vd.push(c);
    }
    var OH = u.ReactCurrentBatchConfig, AH = null;
    function $H() {
      return OH.transition;
    }
    var Iu = {
      recordUnsafeLifecycleWarnings: function(c, b) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(c, b) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var qH = function(c) {
        for (var b = null, d = c; d !== null; )
          d.mode & Gc && (b = d), d = d.return;
        return b;
      }, QG = function(c) {
        var b = [];
        return c.forEach(function(d) {
          b.push(d);
        }), b.sort().join(", ");
      }, Ue = [], Ce = [], re = [], Fe = [], Ne = [], we = [], PG = /* @__PURE__ */ new Set();
      Iu.recordUnsafeLifecycleWarnings = function(c, b) {
        PG.has(c.type) || (typeof b.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        b.componentWillMount.__suppressDeprecationWarning !== !0 && Ue.push(c), c.mode & Gc && typeof b.UNSAFE_componentWillMount == "function" && Ce.push(c), typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && re.push(c), c.mode & Gc && typeof b.UNSAFE_componentWillReceiveProps == "function" && Fe.push(c), typeof b.componentWillUpdate == "function" && b.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ne.push(c), c.mode & Gc && typeof b.UNSAFE_componentWillUpdate == "function" && we.push(c));
      }, Iu.flushPendingUnsafeLifecycleWarnings = function() {
        var c = /* @__PURE__ */ new Set();
        Ue.length > 0 && (Ue.forEach(function($) {
          c.add(bZ($) || "Component"), PG.add($.type);
        }), Ue = []);
        var b = /* @__PURE__ */ new Set();
        Ce.length > 0 && (Ce.forEach(function($) {
          b.add(bZ($) || "Component"), PG.add($.type);
        }), Ce = []);
        var d = /* @__PURE__ */ new Set();
        re.length > 0 && (re.forEach(function($) {
          d.add(bZ($) || "Component"), PG.add($.type);
        }), re = []);
        var o = /* @__PURE__ */ new Set();
        Fe.length > 0 && (Fe.forEach(function($) {
          o.add(bZ($) || "Component"), PG.add($.type);
        }), Fe = []);
        var e = /* @__PURE__ */ new Set();
        Ne.length > 0 && (Ne.forEach(function($) {
          e.add(bZ($) || "Component"), PG.add($.type);
        }), Ne = []);
        var L = /* @__PURE__ */ new Set();
        if (we.length > 0 && (we.forEach(function($) {
          L.add(bZ($) || "Component"), PG.add($.type);
        }), we = []), b.size > 0) {
          var X = QG(b);
          m(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, X);
        }
        if (o.size > 0) {
          var K = QG(o);
          m(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, K);
        }
        if (L.size > 0) {
          var Y = QG(L);
          m(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, Y);
        }
        if (c.size > 0) {
          var N = QG(c);
          i(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, N);
        }
        if (d.size > 0) {
          var H = QG(d);
          i(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, H);
        }
        if (e.size > 0) {
          var q = QG(e);
          i(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, q);
        }
      };
      var zp = /* @__PURE__ */ new Map(), q0 = /* @__PURE__ */ new Set();
      Iu.recordLegacyContextWarning = function(c, b) {
        var d = qH(c);
        if (d === null) {
          m("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!q0.has(c.type)) {
          var o = zp.get(d);
          (c.type.contextTypes != null || c.type.childContextTypes != null || b !== null && typeof b.getChildContext == "function") && (o === void 0 && (o = [], zp.set(d, o)), o.push(c));
        }
      }, Iu.flushLegacyContextWarning = function() {
        zp.forEach(function(c, b) {
          if (c.length !== 0) {
            var d = c[0], o = /* @__PURE__ */ new Set();
            c.forEach(function(L) {
              o.add(bZ(L) || "Component"), q0.add(L.type);
            });
            var e = QG(o);
            try {
              cc(d), m(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, e);
            } finally {
              wc();
            }
          }
        });
      }, Iu.discardPendingWarnings = function() {
        Ue = [], Ce = [], re = [], Fe = [], Ne = [], we = [], zp = /* @__PURE__ */ new Map();
      };
    }
    var et, at, nt, pt, Lt, _0 = function(c, b) {
    };
    et = !1, at = !1, nt = {}, pt = {}, Lt = {}, _0 = function(c, b) {
      if (!(c === null || typeof c != "object") && !(!c._store || c._store.validated || c.key != null)) {
        if (typeof c._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        c._store.validated = !0;
        var d = bZ(b) || "Component";
        pt[d] || (pt[d] = !0, m('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function _H(c) {
      return c.prototype && c.prototype.isReactComponent;
    }
    function ze(c, b, d) {
      var o = d.ref;
      if (o !== null && typeof o != "function" && typeof o != "object") {
        if ((c.mode & Gc || ml) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(d._owner && d._self && d._owner.stateNode !== d._self) && // Will already throw with "Function components cannot have string refs"
        !(d._owner && d._owner.tag !== p) && // Will already warn with "Function components cannot be given refs"
        !(typeof d.type == "function" && !_H(d.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        d._owner) {
          var e = bZ(c) || "Component";
          nt[e] || (m('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', e, o), nt[e] = !0);
        }
        if (d._owner) {
          var L = d._owner, X;
          if (L) {
            var K = L;
            if (K.tag !== p)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            X = K.stateNode;
          }
          if (!X)
            throw new Error("Missing owner for string ref " + o + ". This error is likely caused by a bug in React. Please file an issue.");
          var Y = X;
          yc(o, "ref");
          var N = "" + o;
          if (b !== null && b.ref !== null && typeof b.ref == "function" && b.ref._stringRef === N)
            return b.ref;
          var H = function(q) {
            var $ = Y.refs;
            q === null ? delete $[N] : $[N] = q;
          };
          return H._stringRef = N, H;
        } else {
          if (typeof o != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!d._owner)
            throw new Error("Element ref was specified as a string (" + o + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return o;
    }
    function Jp(c, b) {
      var d = Object.prototype.toString.call(b);
      throw new Error("Objects are not valid as a React child (found: " + (d === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : d) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Hp(c) {
      {
        var b = bZ(c) || "Component";
        if (Lt[b])
          return;
        Lt[b] = !0, m("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function lR(c) {
      var b = c._payload, d = c._init;
      return d(b);
    }
    function ZR(c) {
      function b(bl, pl) {
        if (c) {
          var ul = bl.deletions;
          ul === null ? (bl.deletions = [pl], bl.flags |= UG) : ul.push(pl);
        }
      }
      function d(bl, pl) {
        if (!c)
          return null;
        for (var ul = pl; ul !== null; )
          b(bl, ul), ul = ul.sibling;
        return null;
      }
      function o(bl, pl) {
        for (var ul = /* @__PURE__ */ new Map(), Xl = pl; Xl !== null; )
          Xl.key !== null ? ul.set(Xl.key, Xl) : ul.set(Xl.index, Xl), Xl = Xl.sibling;
        return ul;
      }
      function e(bl, pl) {
        var ul = bm(bl, pl);
        return ul.index = 0, ul.sibling = null, ul;
      }
      function L(bl, pl, ul) {
        if (bl.index = ul, !c)
          return bl.flags |= u5, pl;
        var Xl = bl.alternate;
        if (Xl !== null) {
          var Nl = Xl.index;
          return Nl < pl ? (bl.flags |= Xc, pl) : Nl;
        } else
          return bl.flags |= Xc, pl;
      }
      function X(bl) {
        return c && bl.alternate === null && (bl.flags |= Xc), bl;
      }
      function K(bl, pl, ul, Xl) {
        if (pl === null || pl.tag !== W) {
          var Nl = oK(ul, bl.mode, Xl);
          return Nl.return = bl, Nl;
        } else {
          var Cl = e(pl, ul);
          return Cl.return = bl, Cl;
        }
      }
      function Y(bl, pl, ul, Xl) {
        var Nl = ul.type;
        if (Nl === bu)
          return H(bl, pl, ul.props.children, Xl, ul.key);
        if (pl !== null && (pl.elementType === Nl || // Keep this check inline so it only runs on the false path:
        dk(pl, ul) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof Nl == "object" && Nl !== null && Nl.$$typeof === jl && lR(Nl) === pl.type)) {
          var Cl = e(pl, ul.props);
          return Cl.ref = ze(bl, pl, ul), Cl.return = bl, Cl._debugSource = ul._source, Cl._debugOwner = ul._owner, Cl;
        }
        var Al = iK(ul, bl.mode, Xl);
        return Al.ref = ze(bl, pl, ul), Al.return = bl, Al;
      }
      function N(bl, pl, ul, Xl) {
        if (pl === null || pl.tag !== S || pl.stateNode.containerInfo !== ul.containerInfo || pl.stateNode.implementation !== ul.implementation) {
          var Nl = eK(ul, bl.mode, Xl);
          return Nl.return = bl, Nl;
        } else {
          var Cl = e(pl, ul.children || []);
          return Cl.return = bl, Cl;
        }
      }
      function H(bl, pl, ul, Xl, Nl) {
        if (pl === null || pl.tag !== V) {
          var Cl = $d(ul, bl.mode, Xl, Nl);
          return Cl.return = bl, Cl;
        } else {
          var Al = e(pl, ul);
          return Al.return = bl, Al;
        }
      }
      function q(bl, pl, ul) {
        if (typeof pl == "string" && pl !== "" || typeof pl == "number") {
          var Xl = oK("" + pl, bl.mode, ul);
          return Xl.return = bl, Xl;
        }
        if (typeof pl == "object" && pl !== null) {
          switch (pl.$$typeof) {
            case fb: {
              var Nl = iK(pl, bl.mode, ul);
              return Nl.ref = ze(bl, null, pl), Nl.return = bl, Nl;
            }
            case Eb: {
              var Cl = eK(pl, bl.mode, ul);
              return Cl.return = bl, Cl;
            }
            case jl: {
              var Al = pl._payload, lZ = pl._init;
              return q(bl, lZ(Al), ul);
            }
          }
          if (xZ(pl) || Lb(pl)) {
            var NZ = $d(pl, bl.mode, ul, null);
            return NZ.return = bl, NZ;
          }
          Jp(bl, pl);
        }
        return typeof pl == "function" && Hp(bl), null;
      }
      function $(bl, pl, ul, Xl) {
        var Nl = pl !== null ? pl.key : null;
        if (typeof ul == "string" && ul !== "" || typeof ul == "number")
          return Nl !== null ? null : K(bl, pl, "" + ul, Xl);
        if (typeof ul == "object" && ul !== null) {
          switch (ul.$$typeof) {
            case fb:
              return ul.key === Nl ? Y(bl, pl, ul, Xl) : null;
            case Eb:
              return ul.key === Nl ? N(bl, pl, ul, Xl) : null;
            case jl: {
              var Cl = ul._payload, Al = ul._init;
              return $(bl, pl, Al(Cl), Xl);
            }
          }
          if (xZ(ul) || Lb(ul))
            return Nl !== null ? null : H(bl, pl, ul, Xl, null);
          Jp(bl, ul);
        }
        return typeof ul == "function" && Hp(bl), null;
      }
      function sl(bl, pl, ul, Xl, Nl) {
        if (typeof Xl == "string" && Xl !== "" || typeof Xl == "number") {
          var Cl = bl.get(ul) || null;
          return K(pl, Cl, "" + Xl, Nl);
        }
        if (typeof Xl == "object" && Xl !== null) {
          switch (Xl.$$typeof) {
            case fb: {
              var Al = bl.get(Xl.key === null ? ul : Xl.key) || null;
              return Y(pl, Al, Xl, Nl);
            }
            case Eb: {
              var lZ = bl.get(Xl.key === null ? ul : Xl.key) || null;
              return N(pl, lZ, Xl, Nl);
            }
            case jl:
              var NZ = Xl._payload, WZ = Xl._init;
              return sl(bl, pl, ul, WZ(NZ), Nl);
          }
          if (xZ(Xl) || Lb(Xl)) {
            var nc = bl.get(ul) || null;
            return H(pl, nc, Xl, Nl, null);
          }
          Jp(pl, Xl);
        }
        return typeof Xl == "function" && Hp(pl), null;
      }
      function Gl(bl, pl, ul) {
        {
          if (typeof bl != "object" || bl === null)
            return pl;
          switch (bl.$$typeof) {
            case fb:
            case Eb:
              _0(bl, ul);
              var Xl = bl.key;
              if (typeof Xl != "string")
                break;
              if (pl === null) {
                pl = /* @__PURE__ */ new Set(), pl.add(Xl);
                break;
              }
              if (!pl.has(Xl)) {
                pl.add(Xl);
                break;
              }
              m("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Xl);
              break;
            case jl:
              var Nl = bl._payload, Cl = bl._init;
              Gl(Cl(Nl), pl, ul);
              break;
          }
        }
        return pl;
      }
      function nl(bl, pl, ul, Xl) {
        for (var Nl = null, Cl = 0; Cl < ul.length; Cl++) {
          var Al = ul[Cl];
          Nl = Gl(Al, Nl, bl);
        }
        for (var lZ = null, NZ = null, WZ = pl, nc = 0, VZ = 0, mc = null; WZ !== null && VZ < ul.length; VZ++) {
          WZ.index > VZ ? (mc = WZ, WZ = null) : mc = WZ.sibling;
          var ib = $(bl, WZ, ul[VZ], Xl);
          if (ib === null) {
            WZ === null && (WZ = mc);
            break;
          }
          c && WZ && ib.alternate === null && b(bl, WZ), nc = L(ib, nc, VZ), NZ === null ? lZ = ib : NZ.sibling = ib, NZ = ib, WZ = mc;
        }
        if (VZ === ul.length) {
          if (d(bl, WZ), Dc()) {
            var qc = VZ;
            BG(bl, qc);
          }
          return lZ;
        }
        if (WZ === null) {
          for (; VZ < ul.length; VZ++) {
            var qb = q(bl, ul[VZ], Xl);
            qb !== null && (nc = L(qb, nc, VZ), NZ === null ? lZ = qb : NZ.sibling = qb, NZ = qb);
          }
          if (Dc()) {
            var Kb = VZ;
            BG(bl, Kb);
          }
          return lZ;
        }
        for (var Wb = o(bl, WZ); VZ < ul.length; VZ++) {
          var ob = sl(Wb, bl, VZ, ul[VZ], Xl);
          ob !== null && (c && ob.alternate !== null && Wb.delete(ob.key === null ? VZ : ob.key), nc = L(ob, nc, VZ), NZ === null ? lZ = ob : NZ.sibling = ob, NZ = ob);
        }
        if (c && Wb.forEach(function(Ni) {
          return b(bl, Ni);
        }), Dc()) {
          var qs = VZ;
          BG(bl, qs);
        }
        return lZ;
      }
      function Ul(bl, pl, ul, Xl) {
        var Nl = Lb(ul);
        if (typeof Nl != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          ul[Symbol.toStringTag] === "Generator" && (at || m("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), at = !0), ul.entries === Nl && (et || m("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), et = !0);
          var Cl = Nl.call(ul);
          if (Cl)
            for (var Al = null, lZ = Cl.next(); !lZ.done; lZ = Cl.next()) {
              var NZ = lZ.value;
              Al = Gl(NZ, Al, bl);
            }
        }
        var WZ = Nl.call(ul);
        if (WZ == null)
          throw new Error("An iterable object provided no iterator.");
        for (var nc = null, VZ = null, mc = pl, ib = 0, qc = 0, qb = null, Kb = WZ.next(); mc !== null && !Kb.done; qc++, Kb = WZ.next()) {
          mc.index > qc ? (qb = mc, mc = null) : qb = mc.sibling;
          var Wb = $(bl, mc, Kb.value, Xl);
          if (Wb === null) {
            mc === null && (mc = qb);
            break;
          }
          c && mc && Wb.alternate === null && b(bl, mc), ib = L(Wb, ib, qc), VZ === null ? nc = Wb : VZ.sibling = Wb, VZ = Wb, mc = qb;
        }
        if (Kb.done) {
          if (d(bl, mc), Dc()) {
            var ob = qc;
            BG(bl, ob);
          }
          return nc;
        }
        if (mc === null) {
          for (; !Kb.done; qc++, Kb = WZ.next()) {
            var qs = q(bl, Kb.value, Xl);
            qs !== null && (ib = L(qs, ib, qc), VZ === null ? nc = qs : VZ.sibling = qs, VZ = qs);
          }
          if (Dc()) {
            var Ni = qc;
            BG(bl, Ni);
          }
          return nc;
        }
        for (var pa = o(bl, mc); !Kb.done; qc++, Kb = WZ.next()) {
          var is = sl(pa, bl, qc, Kb.value, Xl);
          is !== null && (c && is.alternate !== null && pa.delete(is.key === null ? qc : is.key), ib = L(is, ib, qc), VZ === null ? nc = is : VZ.sibling = is, VZ = is);
        }
        if (c && pa.forEach(function(RT) {
          return b(bl, RT);
        }), Dc()) {
          var xT = qc;
          BG(bl, xT);
        }
        return nc;
      }
      function Dl(bl, pl, ul, Xl) {
        if (pl !== null && pl.tag === W) {
          d(bl, pl.sibling);
          var Nl = e(pl, ul);
          return Nl.return = bl, Nl;
        }
        d(bl, pl);
        var Cl = oK(ul, bl.mode, Xl);
        return Cl.return = bl, Cl;
      }
      function fl(bl, pl, ul, Xl) {
        for (var Nl = ul.key, Cl = pl; Cl !== null; ) {
          if (Cl.key === Nl) {
            var Al = ul.type;
            if (Al === bu) {
              if (Cl.tag === V) {
                d(bl, Cl.sibling);
                var lZ = e(Cl, ul.props.children);
                return lZ.return = bl, lZ._debugSource = ul._source, lZ._debugOwner = ul._owner, lZ;
              }
            } else if (Cl.elementType === Al || // Keep this check inline so it only runs on the false path:
            dk(Cl, ul) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Al == "object" && Al !== null && Al.$$typeof === jl && lR(Al) === Cl.type) {
              d(bl, Cl.sibling);
              var NZ = e(Cl, ul.props);
              return NZ.ref = ze(bl, Cl, ul), NZ.return = bl, NZ._debugSource = ul._source, NZ._debugOwner = ul._owner, NZ;
            }
            d(bl, Cl);
            break;
          } else
            b(bl, Cl);
          Cl = Cl.sibling;
        }
        if (ul.type === bu) {
          var WZ = $d(ul.props.children, bl.mode, Xl, ul.key);
          return WZ.return = bl, WZ;
        } else {
          var nc = iK(ul, bl.mode, Xl);
          return nc.ref = ze(bl, pl, ul), nc.return = bl, nc;
        }
      }
      function hZ(bl, pl, ul, Xl) {
        for (var Nl = ul.key, Cl = pl; Cl !== null; ) {
          if (Cl.key === Nl)
            if (Cl.tag === S && Cl.stateNode.containerInfo === ul.containerInfo && Cl.stateNode.implementation === ul.implementation) {
              d(bl, Cl.sibling);
              var Al = e(Cl, ul.children || []);
              return Al.return = bl, Al;
            } else {
              d(bl, Cl);
              break;
            }
          else
            b(bl, Cl);
          Cl = Cl.sibling;
        }
        var lZ = eK(ul, bl.mode, Xl);
        return lZ.return = bl, lZ;
      }
      function eZ(bl, pl, ul, Xl) {
        var Nl = typeof ul == "object" && ul !== null && ul.type === bu && ul.key === null;
        if (Nl && (ul = ul.props.children), typeof ul == "object" && ul !== null) {
          switch (ul.$$typeof) {
            case fb:
              return X(fl(bl, pl, ul, Xl));
            case Eb:
              return X(hZ(bl, pl, ul, Xl));
            case jl:
              var Cl = ul._payload, Al = ul._init;
              return eZ(bl, pl, Al(Cl), Xl);
          }
          if (xZ(ul))
            return nl(bl, pl, ul, Xl);
          if (Lb(ul))
            return Ul(bl, pl, ul, Xl);
          Jp(bl, ul);
        }
        return typeof ul == "string" && ul !== "" || typeof ul == "number" ? X(Dl(bl, pl, "" + ul, Xl)) : (typeof ul == "function" && Hp(bl), d(bl, pl));
      }
      return eZ;
    }
    var hi = ZR(!0), cR = ZR(!1);
    function l3(c, b) {
      if (c !== null && b.child !== c.child)
        throw new Error("Resuming work not yet implemented.");
      if (b.child !== null) {
        var d = b.child, o = bm(d, d.pendingProps);
        for (b.child = o, o.return = b; d.sibling !== null; )
          d = d.sibling, o = o.sibling = bm(d, d.pendingProps), o.return = b;
        o.sibling = null;
      }
    }
    function Z3(c, b) {
      for (var d = c.child; d !== null; )
        fv(d, b), d = d.sibling;
    }
    var ht = Jd(null), yt;
    yt = {};
    var gp = null, yi = null, St = null, vp = !1;
    function Tp() {
      gp = null, yi = null, St = null, vp = !1;
    }
    function bR() {
      vp = !0;
    }
    function uR() {
      vp = !1;
    }
    function sR(c, b, d) {
      Gb(ht, b._currentValue, c), b._currentValue = d, b._currentRenderer !== void 0 && b._currentRenderer !== null && b._currentRenderer !== yt && m("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), b._currentRenderer = yt;
    }
    function tt(c, b) {
      var d = ht.current;
      db(ht, b), c._currentValue = d;
    }
    function Xt(c, b, d) {
      for (var o = c; o !== null; ) {
        var e = o.alternate;
        if (Zi(o.childLanes, b) ? e !== null && !Zi(e.childLanes, b) && (e.childLanes = mZ(e.childLanes, b)) : (o.childLanes = mZ(o.childLanes, b), e !== null && (e.childLanes = mZ(e.childLanes, b))), o === d)
          break;
        o = o.return;
      }
      o !== d && m("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function c3(c, b, d) {
      b3(c, b, d);
    }
    function b3(c, b, d) {
      var o = c.child;
      for (o !== null && (o.return = c); o !== null; ) {
        var e = void 0, L = o.dependencies;
        if (L !== null) {
          e = o.child;
          for (var X = L.firstContext; X !== null; ) {
            if (X.context === b) {
              if (o.tag === p) {
                var K = le(d), Y = js(jZ, K);
                Y.tag = Ep;
                var N = o.updateQueue;
                if (N !== null) {
                  var H = N.shared, q = H.pending;
                  q === null ? Y.next = Y : (Y.next = q.next, q.next = Y), H.pending = Y;
                }
              }
              o.lanes = mZ(o.lanes, d);
              var $ = o.alternate;
              $ !== null && ($.lanes = mZ($.lanes, d)), Xt(o.return, d, c), L.lanes = mZ(L.lanes, d);
              break;
            }
            X = X.next;
          }
        } else if (o.tag === r)
          e = o.type === c.type ? null : o.child;
        else if (o.tag === E) {
          var sl = o.return;
          if (sl === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          sl.lanes = mZ(sl.lanes, d);
          var Gl = sl.alternate;
          Gl !== null && (Gl.lanes = mZ(Gl.lanes, d)), Xt(sl, d, c), e = o.sibling;
        } else
          e = o.child;
        if (e !== null)
          e.return = o;
        else
          for (e = o; e !== null; ) {
            if (e === c) {
              e = null;
              break;
            }
            var nl = e.sibling;
            if (nl !== null) {
              nl.return = e.return, e = nl;
              break;
            }
            e = e.return;
          }
        o = e;
      }
    }
    function Si(c, b) {
      gp = c, yi = null, St = null;
      var d = c.dependencies;
      if (d !== null) {
        var o = d.firstContext;
        o !== null && (jb(d.lanes, b) && $e(), d.firstContext = null);
      }
    }
    function Kc(c) {
      vp && m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var b = c._currentValue;
      if (St !== c) {
        var d = {
          context: c,
          memoizedValue: b,
          next: null
        };
        if (yi === null) {
          if (gp === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          yi = d, gp.dependencies = {
            lanes: Sl,
            firstContext: d
          };
        } else
          yi = yi.next = d;
      }
      return b;
    }
    var OG = null;
    function Kt(c) {
      OG === null ? OG = [c] : OG.push(c);
    }
    function u3() {
      if (OG !== null) {
        for (var c = 0; c < OG.length; c++) {
          var b = OG[c], d = b.interleaved;
          if (d !== null) {
            b.interleaved = null;
            var o = d.next, e = b.pending;
            if (e !== null) {
              var L = e.next;
              e.next = o, d.next = L;
            }
            b.pending = d;
          }
        }
        OG = null;
      }
    }
    function dR(c, b, d, o) {
      var e = b.interleaved;
      return e === null ? (d.next = d, Kt(b)) : (d.next = e.next, e.next = d), b.interleaved = d, fp(c, o);
    }
    function s3(c, b, d, o) {
      var e = b.interleaved;
      e === null ? (d.next = d, Kt(b)) : (d.next = e.next, e.next = d), b.interleaved = d;
    }
    function d3(c, b, d, o) {
      var e = b.interleaved;
      return e === null ? (d.next = d, Kt(b)) : (d.next = e.next, e.next = d), b.interleaved = d, fp(c, o);
    }
    function rb(c, b) {
      return fp(c, b);
    }
    var G3 = fp;
    function fp(c, b) {
      c.lanes = mZ(c.lanes, b);
      var d = c.alternate;
      d !== null && (d.lanes = mZ(d.lanes, b)), d === null && (c.flags & (Xc | ws)) !== Pl && ck(c);
      for (var o = c, e = c.return; e !== null; )
        e.childLanes = mZ(e.childLanes, b), d = e.alternate, d !== null ? d.childLanes = mZ(d.childLanes, b) : (e.flags & (Xc | ws)) !== Pl && ck(c), o = e, e = e.return;
      if (o.tag === h) {
        var L = o.stateNode;
        return L;
      } else
        return null;
    }
    var GR = 0, mR = 1, Ep = 2, Wt = 3, Bp = !1, Vt, Dp;
    Vt = !1, Dp = null;
    function xt(c) {
      var b = {
        baseState: c.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Sl
        },
        effects: null
      };
      c.updateQueue = b;
    }
    function iR(c, b) {
      var d = b.updateQueue, o = c.updateQueue;
      if (d === o) {
        var e = {
          baseState: o.baseState,
          firstBaseUpdate: o.firstBaseUpdate,
          lastBaseUpdate: o.lastBaseUpdate,
          shared: o.shared,
          effects: o.effects
        };
        b.updateQueue = e;
      }
    }
    function js(c, b) {
      var d = {
        eventTime: c,
        lane: b,
        tag: GR,
        payload: null,
        callback: null,
        next: null
      };
      return d;
    }
    function Td(c, b, d) {
      var o = c.updateQueue;
      if (o === null)
        return null;
      var e = o.shared;
      if (Dp === e && !Vt && (m("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Vt = !0), sv()) {
        var L = e.pending;
        return L === null ? b.next = b : (b.next = L.next, L.next = b), e.pending = b, G3(c, d);
      } else
        return d3(c, e, b, d);
    }
    function jp(c, b, d) {
      var o = b.updateQueue;
      if (o !== null) {
        var e = o.shared;
        if (W5(d)) {
          var L = e.lanes;
          L = x5(L, c.pendingLanes);
          var X = mZ(L, d);
          e.lanes = X, hS(c, X);
        }
      }
    }
    function Rt(c, b) {
      var d = c.updateQueue, o = c.alternate;
      if (o !== null) {
        var e = o.updateQueue;
        if (d === e) {
          var L = null, X = null, K = d.firstBaseUpdate;
          if (K !== null) {
            var Y = K;
            do {
              var N = {
                eventTime: Y.eventTime,
                lane: Y.lane,
                tag: Y.tag,
                payload: Y.payload,
                callback: Y.callback,
                next: null
              };
              X === null ? L = X = N : (X.next = N, X = N), Y = Y.next;
            } while (Y !== null);
            X === null ? L = X = b : (X.next = b, X = b);
          } else
            L = X = b;
          d = {
            baseState: e.baseState,
            firstBaseUpdate: L,
            lastBaseUpdate: X,
            shared: e.shared,
            effects: e.effects
          }, c.updateQueue = d;
          return;
        }
      }
      var H = d.lastBaseUpdate;
      H === null ? d.firstBaseUpdate = b : H.next = b, d.lastBaseUpdate = b;
    }
    function m3(c, b, d, o, e, L) {
      switch (d.tag) {
        case mR: {
          var X = d.payload;
          if (typeof X == "function") {
            bR();
            var K = X.call(L, o, e);
            {
              if (c.mode & Gc) {
                Jc(!0);
                try {
                  X.call(L, o, e);
                } finally {
                  Jc(!1);
                }
              }
              uR();
            }
            return K;
          }
          return X;
        }
        case Wt:
          c.flags = c.flags & ~yb | RZ;
        case GR: {
          var Y = d.payload, N;
          if (typeof Y == "function") {
            bR(), N = Y.call(L, o, e);
            {
              if (c.mode & Gc) {
                Jc(!0);
                try {
                  Y.call(L, o, e);
                } finally {
                  Jc(!1);
                }
              }
              uR();
            }
          } else
            N = Y;
          return N == null ? o : GZ({}, o, N);
        }
        case Ep:
          return Bp = !0, o;
      }
      return o;
    }
    function Qp(c, b, d, o) {
      var e = c.updateQueue;
      Bp = !1, Dp = e.shared;
      var L = e.firstBaseUpdate, X = e.lastBaseUpdate, K = e.shared.pending;
      if (K !== null) {
        e.shared.pending = null;
        var Y = K, N = Y.next;
        Y.next = null, X === null ? L = N : X.next = N, X = Y;
        var H = c.alternate;
        if (H !== null) {
          var q = H.updateQueue, $ = q.lastBaseUpdate;
          $ !== X && ($ === null ? q.firstBaseUpdate = N : $.next = N, q.lastBaseUpdate = Y);
        }
      }
      if (L !== null) {
        var sl = e.baseState, Gl = Sl, nl = null, Ul = null, Dl = null, fl = L;
        do {
          var hZ = fl.lane, eZ = fl.eventTime;
          if (Zi(o, hZ)) {
            if (Dl !== null) {
              var pl = {
                eventTime: eZ,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Hc,
                tag: fl.tag,
                payload: fl.payload,
                callback: fl.callback,
                next: null
              };
              Dl = Dl.next = pl;
            }
            sl = m3(c, e, fl, sl, b, d);
            var ul = fl.callback;
            if (ul !== null && // If the update was already committed, we should not queue its
            // callback again.
            fl.lane !== Hc) {
              c.flags |= Jy;
              var Xl = e.effects;
              Xl === null ? e.effects = [fl] : Xl.push(fl);
            }
          } else {
            var bl = {
              eventTime: eZ,
              lane: hZ,
              tag: fl.tag,
              payload: fl.payload,
              callback: fl.callback,
              next: null
            };
            Dl === null ? (Ul = Dl = bl, nl = sl) : Dl = Dl.next = bl, Gl = mZ(Gl, hZ);
          }
          if (fl = fl.next, fl === null) {
            if (K = e.shared.pending, K === null)
              break;
            var Nl = K, Cl = Nl.next;
            Nl.next = null, fl = Cl, e.lastBaseUpdate = Nl, e.shared.pending = null;
          }
        } while (!0);
        Dl === null && (nl = sl), e.baseState = nl, e.firstBaseUpdate = Ul, e.lastBaseUpdate = Dl;
        var Al = e.shared.interleaved;
        if (Al !== null) {
          var lZ = Al;
          do
            Gl = mZ(Gl, lZ.lane), lZ = lZ.next;
          while (lZ !== Al);
        } else L === null && (e.shared.lanes = Sl);
        ia(Gl), c.lanes = Gl, c.memoizedState = sl;
      }
      Dp = null;
    }
    function i3(c, b) {
      if (typeof c != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + c));
      c.call(b);
    }
    function oR() {
      Bp = !1;
    }
    function Pp() {
      return Bp;
    }
    function eR(c, b, d) {
      var o = b.effects;
      if (b.effects = null, o !== null)
        for (var e = 0; e < o.length; e++) {
          var L = o[e], X = L.callback;
          X !== null && (L.callback = null, i3(X, d));
        }
    }
    var Je = {}, fd = Jd(Je), He = Jd(Je), Op = Jd(Je);
    function Ap(c) {
      if (c === Je)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function aR() {
      var c = Ap(Op.current);
      return c;
    }
    function Yt(c, b) {
      Gb(Op, b, c), Gb(He, c, c), Gb(fd, Je, c);
      var d = YJ(b);
      db(fd, c), Gb(fd, d, c);
    }
    function ti(c) {
      db(fd, c), db(He, c), db(Op, c);
    }
    function kt() {
      var c = Ap(fd.current);
      return c;
    }
    function nR(c) {
      Ap(Op.current);
      var b = Ap(fd.current), d = kJ(b, c.type);
      b !== d && (Gb(He, c, c), Gb(fd, d, c));
    }
    function Mt(c) {
      He.current === c && (db(fd, c), db(He, c));
    }
    var o3 = 0, pR = 1, LR = 1, ge = 2, Uu = Jd(o3);
    function It(c, b) {
      return (c & b) !== 0;
    }
    function Xi(c) {
      return c & pR;
    }
    function Ut(c, b) {
      return c & pR | b;
    }
    function e3(c, b) {
      return c | b;
    }
    function Ed(c, b) {
      Gb(Uu, b, c);
    }
    function Ki(c) {
      db(Uu, c);
    }
    function a3(c, b) {
      var d = c.memoizedState;
      return d !== null ? d.dehydrated !== null : (c.memoizedProps, !0);
    }
    function $p(c) {
      for (var b = c; b !== null; ) {
        if (b.tag === w) {
          var d = b.memoizedState;
          if (d !== null) {
            var o = d.dehydrated;
            if (o === null || r0(o) || PS(o))
              return b;
          }
        } else if (b.tag === g && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        b.memoizedProps.revealOrder !== void 0) {
          var e = (b.flags & RZ) !== Pl;
          if (e)
            return b;
        } else if (b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === c)
          return null;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c)
            return null;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
      return null;
    }
    var Fb = (
      /*   */
      0
    ), Rc = (
      /* */
      1
    ), cs = (
      /*  */
      2
    ), Yc = (
      /*    */
      4
    ), jc = (
      /*   */
      8
    ), Ct = [];
    function rt() {
      for (var c = 0; c < Ct.length; c++) {
        var b = Ct[c];
        b._workInProgressVersionPrimary = null;
      }
      Ct.length = 0;
    }
    function n3(c, b) {
      var d = b._getVersion, o = d(b._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, o] : c.mutableSourceEagerHydrationData.push(b, o);
    }
    var Fl = u.ReactCurrentDispatcher, ve = u.ReactCurrentBatchConfig, Ft, Wi;
    Ft = /* @__PURE__ */ new Set();
    var AG = Sl, FZ = null, kc = null, Mc = null, qp = !1, Te = !1, fe = 0, p3 = 0, L3 = 25, Ll = null, mu = null, Bd = -1, Nt = !1;
    function MZ() {
      {
        var c = Ll;
        mu === null ? mu = [c] : mu.push(c);
      }
    }
    function Ml() {
      {
        var c = Ll;
        mu !== null && (Bd++, mu[Bd] !== c && h3(c));
      }
    }
    function Vi(c) {
      c != null && !xZ(c) && m("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Ll, typeof c);
    }
    function h3(c) {
      {
        var b = bZ(FZ);
        if (!Ft.has(b) && (Ft.add(b), mu !== null)) {
          for (var d = "", o = 30, e = 0; e <= Bd; e++) {
            for (var L = mu[e], X = e === Bd ? c : L, K = e + 1 + ". " + L; K.length < o; )
              K += " ";
            K += X + `
`, d += K;
          }
          m(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, b, d);
        }
      }
    }
    function mb() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function wt(c, b) {
      if (Nt)
        return !1;
      if (b === null)
        return m("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Ll), !1;
      c.length !== b.length && m(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Ll, "[" + b.join(", ") + "]", "[" + c.join(", ") + "]");
      for (var d = 0; d < b.length && d < c.length; d++)
        if (!Ob(c[d], b[d]))
          return !1;
      return !0;
    }
    function xi(c, b, d, o, e, L) {
      AG = L, FZ = b, mu = c !== null ? c._debugHookTypes : null, Bd = -1, Nt = c !== null && c.type !== b.type, b.memoizedState = null, b.updateQueue = null, b.lanes = Sl, c !== null && c.memoizedState !== null ? Fl.current = JR : mu !== null ? Fl.current = zR : Fl.current = wR;
      var X = d(o, e);
      if (Te) {
        var K = 0;
        do {
          if (Te = !1, fe = 0, K >= L3)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          K += 1, Nt = !1, kc = null, Mc = null, b.updateQueue = null, Bd = -1, Fl.current = HR, X = d(o, e);
        } while (Te);
      }
      Fl.current = eL, b._debugHookTypes = mu;
      var Y = kc !== null && kc.next !== null;
      if (AG = Sl, FZ = null, kc = null, Mc = null, Ll = null, mu = null, Bd = -1, c !== null && (c.flags & Js) !== (b.flags & Js) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (c.mode & pZ) !== Ql && m("Internal React error: Expected static flag was missing. Please notify the React team."), qp = !1, Y)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return X;
    }
    function Ri() {
      var c = fe !== 0;
      return fe = 0, c;
    }
    function hR(c, b, d) {
      b.updateQueue = c.updateQueue, (b.mode & qu) !== Ql ? b.flags &= ~(jn | zs | xu | SZ) : b.flags &= ~(xu | SZ), c.lanes = _n(c.lanes, d);
    }
    function yR() {
      if (Fl.current = eL, qp) {
        for (var c = FZ.memoizedState; c !== null; ) {
          var b = c.queue;
          b !== null && (b.pending = null), c = c.next;
        }
        qp = !1;
      }
      AG = Sl, FZ = null, kc = null, Mc = null, mu = null, Bd = -1, Ll = null, UR = !1, Te = !1, fe = 0;
    }
    function bs() {
      var c = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Mc === null ? FZ.memoizedState = Mc = c : Mc = Mc.next = c, Mc;
    }
    function iu() {
      var c;
      if (kc === null) {
        var b = FZ.alternate;
        b !== null ? c = b.memoizedState : c = null;
      } else
        c = kc.next;
      var d;
      if (Mc === null ? d = FZ.memoizedState : d = Mc.next, d !== null)
        Mc = d, d = Mc.next, kc = c;
      else {
        if (c === null)
          throw new Error("Rendered more hooks than during the previous render.");
        kc = c;
        var o = {
          memoizedState: kc.memoizedState,
          baseState: kc.baseState,
          baseQueue: kc.baseQueue,
          queue: kc.queue,
          next: null
        };
        Mc === null ? FZ.memoizedState = Mc = o : Mc = Mc.next = o;
      }
      return Mc;
    }
    function SR() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function zt(c, b) {
      return typeof b == "function" ? b(c) : b;
    }
    function Jt(c, b, d) {
      var o = bs(), e;
      d !== void 0 ? e = d(b) : e = b, o.memoizedState = o.baseState = e;
      var L = {
        pending: null,
        interleaved: null,
        lanes: Sl,
        dispatch: null,
        lastRenderedReducer: c,
        lastRenderedState: e
      };
      o.queue = L;
      var X = L.dispatch = X3.bind(null, FZ, L);
      return [o.memoizedState, X];
    }
    function Ht(c, b, d) {
      var o = iu(), e = o.queue;
      if (e === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      e.lastRenderedReducer = c;
      var L = kc, X = L.baseQueue, K = e.pending;
      if (K !== null) {
        if (X !== null) {
          var Y = X.next, N = K.next;
          X.next = N, K.next = Y;
        }
        L.baseQueue !== X && m("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), L.baseQueue = X = K, e.pending = null;
      }
      if (X !== null) {
        var H = X.next, q = L.baseState, $ = null, sl = null, Gl = null, nl = H;
        do {
          var Ul = nl.lane;
          if (Zi(AG, Ul)) {
            if (Gl !== null) {
              var fl = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: Hc,
                action: nl.action,
                hasEagerState: nl.hasEagerState,
                eagerState: nl.eagerState,
                next: null
              };
              Gl = Gl.next = fl;
            }
            if (nl.hasEagerState)
              q = nl.eagerState;
            else {
              var hZ = nl.action;
              q = c(q, hZ);
            }
          } else {
            var Dl = {
              lane: Ul,
              action: nl.action,
              hasEagerState: nl.hasEagerState,
              eagerState: nl.eagerState,
              next: null
            };
            Gl === null ? (sl = Gl = Dl, $ = q) : Gl = Gl.next = Dl, FZ.lanes = mZ(FZ.lanes, Ul), ia(Ul);
          }
          nl = nl.next;
        } while (nl !== null && nl !== H);
        Gl === null ? $ = q : Gl.next = sl, Ob(q, o.memoizedState) || $e(), o.memoizedState = q, o.baseState = $, o.baseQueue = Gl, e.lastRenderedState = q;
      }
      var eZ = e.interleaved;
      if (eZ !== null) {
        var bl = eZ;
        do {
          var pl = bl.lane;
          FZ.lanes = mZ(FZ.lanes, pl), ia(pl), bl = bl.next;
        } while (bl !== eZ);
      } else X === null && (e.lanes = Sl);
      var ul = e.dispatch;
      return [o.memoizedState, ul];
    }
    function gt(c, b, d) {
      var o = iu(), e = o.queue;
      if (e === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      e.lastRenderedReducer = c;
      var L = e.dispatch, X = e.pending, K = o.memoizedState;
      if (X !== null) {
        e.pending = null;
        var Y = X.next, N = Y;
        do {
          var H = N.action;
          K = c(K, H), N = N.next;
        } while (N !== Y);
        Ob(K, o.memoizedState) || $e(), o.memoizedState = K, o.baseQueue === null && (o.baseState = K), e.lastRenderedState = K;
      }
      return [K, L];
    }
    function Y_(c, b, d) {
    }
    function k_(c, b, d) {
    }
    function vt(c, b, d) {
      var o = FZ, e = bs(), L, X = Dc();
      if (X) {
        if (d === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        L = d(), Wi || L !== d() && (m("The result of getServerSnapshot should be cached to avoid an infinite loop"), Wi = !0);
      } else {
        if (L = b(), !Wi) {
          var K = b();
          Ob(L, K) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), Wi = !0);
        }
        var Y = UL();
        if (Y === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qn(Y, AG) || tR(o, b, L);
      }
      e.memoizedState = L;
      var N = {
        value: L,
        getSnapshot: b
      };
      return e.queue = N, bL(KR.bind(null, o, N, c), [c]), o.flags |= xu, Ee(Rc | jc, XR.bind(null, o, N, L, b), void 0, null), L;
    }
    function _p(c, b, d) {
      var o = FZ, e = iu(), L = b();
      if (!Wi) {
        var X = b();
        Ob(L, X) || (m("The result of getSnapshot should be cached to avoid an infinite loop"), Wi = !0);
      }
      var K = e.memoizedState, Y = !Ob(K, L);
      Y && (e.memoizedState = L, $e());
      var N = e.queue;
      if (De(KR.bind(null, o, N, c), [c]), N.getSnapshot !== b || Y || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Mc !== null && Mc.memoizedState.tag & Rc) {
        o.flags |= xu, Ee(Rc | jc, XR.bind(null, o, N, L, b), void 0, null);
        var H = UL();
        if (H === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        qn(H, AG) || tR(o, b, L);
      }
      return L;
    }
    function tR(c, b, d) {
      c.flags |= Dn;
      var o = {
        getSnapshot: b,
        value: d
      }, e = FZ.updateQueue;
      if (e === null)
        e = SR(), FZ.updateQueue = e, e.stores = [o];
      else {
        var L = e.stores;
        L === null ? e.stores = [o] : L.push(o);
      }
    }
    function XR(c, b, d, o) {
      b.value = d, b.getSnapshot = o, WR(b) && VR(c);
    }
    function KR(c, b, d) {
      var o = function() {
        WR(b) && VR(c);
      };
      return d(o);
    }
    function WR(c) {
      var b = c.getSnapshot, d = c.value;
      try {
        var o = b();
        return !Ob(d, o);
      } catch {
        return !0;
      }
    }
    function VR(c) {
      var b = rb(c, ql);
      b !== null && rc(b, c, ql, jZ);
    }
    function lL(c) {
      var b = bs();
      typeof c == "function" && (c = c()), b.memoizedState = b.baseState = c;
      var d = {
        pending: null,
        interleaved: null,
        lanes: Sl,
        dispatch: null,
        lastRenderedReducer: zt,
        lastRenderedState: c
      };
      b.queue = d;
      var o = d.dispatch = K3.bind(null, FZ, d);
      return [b.memoizedState, o];
    }
    function Tt(c) {
      return Ht(zt);
    }
    function ft(c) {
      return gt(zt);
    }
    function Ee(c, b, d, o) {
      var e = {
        tag: c,
        create: b,
        destroy: d,
        deps: o,
        // Circular
        next: null
      }, L = FZ.updateQueue;
      if (L === null)
        L = SR(), FZ.updateQueue = L, L.lastEffect = e.next = e;
      else {
        var X = L.lastEffect;
        if (X === null)
          L.lastEffect = e.next = e;
        else {
          var K = X.next;
          X.next = e, e.next = K, L.lastEffect = e;
        }
      }
      return e;
    }
    function Et(c) {
      var b = bs();
      {
        var d = {
          current: c
        };
        return b.memoizedState = d, d;
      }
    }
    function ZL(c) {
      var b = iu();
      return b.memoizedState;
    }
    function Be(c, b, d, o) {
      var e = bs(), L = o === void 0 ? null : o;
      FZ.flags |= c, e.memoizedState = Ee(Rc | b, d, void 0, L);
    }
    function cL(c, b, d, o) {
      var e = iu(), L = o === void 0 ? null : o, X = void 0;
      if (kc !== null) {
        var K = kc.memoizedState;
        if (X = K.destroy, L !== null) {
          var Y = K.deps;
          if (wt(L, Y)) {
            e.memoizedState = Ee(b, d, X, L);
            return;
          }
        }
      }
      FZ.flags |= c, e.memoizedState = Ee(Rc | b, d, X, L);
    }
    function bL(c, b) {
      return (FZ.mode & qu) !== Ql ? Be(jn | xu | vy, jc, c, b) : Be(xu | vy, jc, c, b);
    }
    function De(c, b) {
      return cL(xu, jc, c, b);
    }
    function Bt(c, b) {
      return Be(SZ, cs, c, b);
    }
    function uL(c, b) {
      return cL(SZ, cs, c, b);
    }
    function Dt(c, b) {
      var d = SZ;
      return d |= FG, (FZ.mode & qu) !== Ql && (d |= zs), Be(d, Yc, c, b);
    }
    function sL(c, b) {
      return cL(SZ, Yc, c, b);
    }
    function xR(c, b) {
      if (typeof b == "function") {
        var d = b, o = c();
        return d(o), function() {
          d(null);
        };
      } else if (b != null) {
        var e = b;
        e.hasOwnProperty("current") || m("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(e).join(", ") + "}");
        var L = c();
        return e.current = L, function() {
          e.current = null;
        };
      }
    }
    function jt(c, b, d) {
      typeof b != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", b !== null ? typeof b : "null");
      var o = d != null ? d.concat([c]) : null, e = SZ;
      return e |= FG, (FZ.mode & qu) !== Ql && (e |= zs), Be(e, Yc, xR.bind(null, b, c), o);
    }
    function dL(c, b, d) {
      typeof b != "function" && m("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", b !== null ? typeof b : "null");
      var o = d != null ? d.concat([c]) : null;
      return cL(SZ, Yc, xR.bind(null, b, c), o);
    }
    function y3(c, b) {
    }
    var GL = y3;
    function Qt(c, b) {
      var d = bs(), o = b === void 0 ? null : b;
      return d.memoizedState = [c, o], c;
    }
    function mL(c, b) {
      var d = iu(), o = b === void 0 ? null : b, e = d.memoizedState;
      if (e !== null && o !== null) {
        var L = e[1];
        if (wt(o, L))
          return e[0];
      }
      return d.memoizedState = [c, o], c;
    }
    function Pt(c, b) {
      var d = bs(), o = b === void 0 ? null : b, e = c();
      return d.memoizedState = [e, o], e;
    }
    function iL(c, b) {
      var d = iu(), o = b === void 0 ? null : b, e = d.memoizedState;
      if (e !== null && o !== null) {
        var L = e[1];
        if (wt(o, L))
          return e[0];
      }
      var X = c();
      return d.memoizedState = [X, o], X;
    }
    function Ot(c) {
      var b = bs();
      return b.memoizedState = c, c;
    }
    function RR(c) {
      var b = iu(), d = kc, o = d.memoizedState;
      return kR(b, o, c);
    }
    function YR(c) {
      var b = iu();
      if (kc === null)
        return b.memoizedState = c, c;
      var d = kc.memoizedState;
      return kR(b, d, c);
    }
    function kR(c, b, d) {
      var o = !cw(AG);
      if (o) {
        if (!Ob(d, b)) {
          var e = V5();
          FZ.lanes = mZ(FZ.lanes, e), ia(e), c.baseState = !0;
        }
        return b;
      } else
        return c.baseState && (c.baseState = !1, $e()), c.memoizedState = d, d;
    }
    function S3(c, b, d) {
      var o = Yu();
      gc(ew(o, gs)), c(!0);
      var e = ve.transition;
      ve.transition = {};
      var L = ve.transition;
      ve.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        c(!1), b();
      } finally {
        if (gc(o), ve.transition = e, e === null && L._updatedFibers) {
          var X = L._updatedFibers.size;
          X > 10 && i("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), L._updatedFibers.clear();
        }
      }
    }
    function At() {
      var c = lL(!1), b = c[0], d = c[1], o = S3.bind(null, d), e = bs();
      return e.memoizedState = o, [b, o];
    }
    function MR() {
      var c = Tt(), b = c[0], d = iu(), o = d.memoizedState;
      return [b, o];
    }
    function IR() {
      var c = ft(), b = c[0], d = iu(), o = d.memoizedState;
      return [b, o];
    }
    var UR = !1;
    function t3() {
      return UR;
    }
    function $t() {
      var c = bs(), b = UL(), d = b.identifierPrefix, o;
      if (Dc()) {
        var e = zH();
        o = ":" + d + "R" + e;
        var L = fe++;
        L > 0 && (o += "H" + L.toString(32)), o += ":";
      } else {
        var X = p3++;
        o = ":" + d + "r" + X.toString(32) + ":";
      }
      return c.memoizedState = o, o;
    }
    function oL() {
      var c = iu(), b = c.memoizedState;
      return b;
    }
    function X3(c, b, d) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var o = Od(c), e = {
        lane: o,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (CR(c))
        rR(b, e);
      else {
        var L = dR(c, b, e, o);
        if (L !== null) {
          var X = Xb();
          rc(L, c, o, X), FR(L, b, o);
        }
      }
      NR(c, o);
    }
    function K3(c, b, d) {
      typeof arguments[3] == "function" && m("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var o = Od(c), e = {
        lane: o,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (CR(c))
        rR(b, e);
      else {
        var L = c.alternate;
        if (c.lanes === Sl && (L === null || L.lanes === Sl)) {
          var X = b.lastRenderedReducer;
          if (X !== null) {
            var K;
            K = Fl.current, Fl.current = Cu;
            try {
              var Y = b.lastRenderedState, N = X(Y, d);
              if (e.hasEagerState = !0, e.eagerState = N, Ob(N, Y)) {
                s3(c, b, e, o);
                return;
              }
            } catch {
            } finally {
              Fl.current = K;
            }
          }
        }
        var H = dR(c, b, e, o);
        if (H !== null) {
          var q = Xb();
          rc(H, c, o, q), FR(H, b, o);
        }
      }
      NR(c, o);
    }
    function CR(c) {
      var b = c.alternate;
      return c === FZ || b !== null && b === FZ;
    }
    function rR(c, b) {
      Te = qp = !0;
      var d = c.pending;
      d === null ? b.next = b : (b.next = d.next, d.next = b), c.pending = b;
    }
    function FR(c, b, d) {
      if (W5(d)) {
        var o = b.lanes;
        o = x5(o, c.pendingLanes);
        var e = mZ(o, d);
        b.lanes = e, hS(c, e);
      }
    }
    function NR(c, b, d) {
      Dy(c, b);
    }
    var eL = {
      readContext: Kc,
      useCallback: mb,
      useContext: mb,
      useEffect: mb,
      useImperativeHandle: mb,
      useInsertionEffect: mb,
      useLayoutEffect: mb,
      useMemo: mb,
      useReducer: mb,
      useRef: mb,
      useState: mb,
      useDebugValue: mb,
      useDeferredValue: mb,
      useTransition: mb,
      useMutableSource: mb,
      useSyncExternalStore: mb,
      useId: mb,
      unstable_isNewReconciler: O
    }, wR = null, zR = null, JR = null, HR = null, us = null, Cu = null, aL = null;
    {
      var qt = function() {
        m("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, _l = function() {
        m("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      wR = {
        readContext: function(c) {
          return Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", MZ(), Vi(b), Qt(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", MZ(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", MZ(), Vi(b), bL(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", MZ(), Vi(d), jt(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", MZ(), Vi(b), Bt(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", MZ(), Vi(b), Dt(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", MZ(), Vi(b);
          var d = Fl.current;
          Fl.current = us;
          try {
            return Pt(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", MZ();
          var o = Fl.current;
          Fl.current = us;
          try {
            return Jt(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", MZ(), Et(c);
        },
        useState: function(c) {
          Ll = "useState", MZ();
          var b = Fl.current;
          Fl.current = us;
          try {
            return lL(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", MZ(), void 0;
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", MZ(), Ot(c);
        },
        useTransition: function() {
          return Ll = "useTransition", MZ(), At();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", MZ(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", MZ(), vt(c, b, d);
        },
        useId: function() {
          return Ll = "useId", MZ(), $t();
        },
        unstable_isNewReconciler: O
      }, zR = {
        readContext: function(c) {
          return Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", Ml(), Qt(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", Ml(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", Ml(), bL(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", Ml(), jt(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", Ml(), Bt(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", Ml(), Dt(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", Ml();
          var d = Fl.current;
          Fl.current = us;
          try {
            return Pt(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", Ml();
          var o = Fl.current;
          Fl.current = us;
          try {
            return Jt(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", Ml(), Et(c);
        },
        useState: function(c) {
          Ll = "useState", Ml();
          var b = Fl.current;
          Fl.current = us;
          try {
            return lL(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", Ml(), void 0;
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", Ml(), Ot(c);
        },
        useTransition: function() {
          return Ll = "useTransition", Ml(), At();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", Ml(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", Ml(), vt(c, b, d);
        },
        useId: function() {
          return Ll = "useId", Ml(), $t();
        },
        unstable_isNewReconciler: O
      }, JR = {
        readContext: function(c) {
          return Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", Ml(), mL(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", Ml(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", Ml(), De(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", Ml(), dL(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", Ml(), uL(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", Ml(), sL(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", Ml();
          var d = Fl.current;
          Fl.current = Cu;
          try {
            return iL(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", Ml();
          var o = Fl.current;
          Fl.current = Cu;
          try {
            return Ht(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", Ml(), ZL();
        },
        useState: function(c) {
          Ll = "useState", Ml();
          var b = Fl.current;
          Fl.current = Cu;
          try {
            return Tt(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", Ml(), GL();
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", Ml(), RR(c);
        },
        useTransition: function() {
          return Ll = "useTransition", Ml(), MR();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", Ml(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", Ml(), _p(c, b);
        },
        useId: function() {
          return Ll = "useId", Ml(), oL();
        },
        unstable_isNewReconciler: O
      }, HR = {
        readContext: function(c) {
          return Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", Ml(), mL(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", Ml(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", Ml(), De(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", Ml(), dL(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", Ml(), uL(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", Ml(), sL(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", Ml();
          var d = Fl.current;
          Fl.current = aL;
          try {
            return iL(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", Ml();
          var o = Fl.current;
          Fl.current = aL;
          try {
            return gt(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", Ml(), ZL();
        },
        useState: function(c) {
          Ll = "useState", Ml();
          var b = Fl.current;
          Fl.current = aL;
          try {
            return ft(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", Ml(), GL();
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", Ml(), YR(c);
        },
        useTransition: function() {
          return Ll = "useTransition", Ml(), IR();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", Ml(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", Ml(), _p(c, b);
        },
        useId: function() {
          return Ll = "useId", Ml(), oL();
        },
        unstable_isNewReconciler: O
      }, us = {
        readContext: function(c) {
          return qt(), Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", _l(), MZ(), Qt(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", _l(), MZ(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", _l(), MZ(), bL(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", _l(), MZ(), jt(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", _l(), MZ(), Bt(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", _l(), MZ(), Dt(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", _l(), MZ();
          var d = Fl.current;
          Fl.current = us;
          try {
            return Pt(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", _l(), MZ();
          var o = Fl.current;
          Fl.current = us;
          try {
            return Jt(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", _l(), MZ(), Et(c);
        },
        useState: function(c) {
          Ll = "useState", _l(), MZ();
          var b = Fl.current;
          Fl.current = us;
          try {
            return lL(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", _l(), MZ(), void 0;
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", _l(), MZ(), Ot(c);
        },
        useTransition: function() {
          return Ll = "useTransition", _l(), MZ(), At();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", _l(), MZ(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", _l(), MZ(), vt(c, b, d);
        },
        useId: function() {
          return Ll = "useId", _l(), MZ(), $t();
        },
        unstable_isNewReconciler: O
      }, Cu = {
        readContext: function(c) {
          return qt(), Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", _l(), Ml(), mL(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", _l(), Ml(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", _l(), Ml(), De(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", _l(), Ml(), dL(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", _l(), Ml(), uL(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", _l(), Ml(), sL(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", _l(), Ml();
          var d = Fl.current;
          Fl.current = Cu;
          try {
            return iL(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", _l(), Ml();
          var o = Fl.current;
          Fl.current = Cu;
          try {
            return Ht(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", _l(), Ml(), ZL();
        },
        useState: function(c) {
          Ll = "useState", _l(), Ml();
          var b = Fl.current;
          Fl.current = Cu;
          try {
            return Tt(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", _l(), Ml(), GL();
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", _l(), Ml(), RR(c);
        },
        useTransition: function() {
          return Ll = "useTransition", _l(), Ml(), MR();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", _l(), Ml(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", _l(), Ml(), _p(c, b);
        },
        useId: function() {
          return Ll = "useId", _l(), Ml(), oL();
        },
        unstable_isNewReconciler: O
      }, aL = {
        readContext: function(c) {
          return qt(), Kc(c);
        },
        useCallback: function(c, b) {
          return Ll = "useCallback", _l(), Ml(), mL(c, b);
        },
        useContext: function(c) {
          return Ll = "useContext", _l(), Ml(), Kc(c);
        },
        useEffect: function(c, b) {
          return Ll = "useEffect", _l(), Ml(), De(c, b);
        },
        useImperativeHandle: function(c, b, d) {
          return Ll = "useImperativeHandle", _l(), Ml(), dL(c, b, d);
        },
        useInsertionEffect: function(c, b) {
          return Ll = "useInsertionEffect", _l(), Ml(), uL(c, b);
        },
        useLayoutEffect: function(c, b) {
          return Ll = "useLayoutEffect", _l(), Ml(), sL(c, b);
        },
        useMemo: function(c, b) {
          Ll = "useMemo", _l(), Ml();
          var d = Fl.current;
          Fl.current = Cu;
          try {
            return iL(c, b);
          } finally {
            Fl.current = d;
          }
        },
        useReducer: function(c, b, d) {
          Ll = "useReducer", _l(), Ml();
          var o = Fl.current;
          Fl.current = Cu;
          try {
            return gt(c, b, d);
          } finally {
            Fl.current = o;
          }
        },
        useRef: function(c) {
          return Ll = "useRef", _l(), Ml(), ZL();
        },
        useState: function(c) {
          Ll = "useState", _l(), Ml();
          var b = Fl.current;
          Fl.current = Cu;
          try {
            return ft(c);
          } finally {
            Fl.current = b;
          }
        },
        useDebugValue: function(c, b) {
          return Ll = "useDebugValue", _l(), Ml(), GL();
        },
        useDeferredValue: function(c) {
          return Ll = "useDeferredValue", _l(), Ml(), YR(c);
        },
        useTransition: function() {
          return Ll = "useTransition", _l(), Ml(), IR();
        },
        useMutableSource: function(c, b, d) {
          return Ll = "useMutableSource", _l(), Ml(), void 0;
        },
        useSyncExternalStore: function(c, b, d) {
          return Ll = "useSyncExternalStore", _l(), Ml(), _p(c, b);
        },
        useId: function() {
          return Ll = "useId", _l(), Ml(), oL();
        },
        unstable_isNewReconciler: O
      };
    }
    var Dd = Z.unstable_now, gR = 0, nL = -1, je = -1, pL = -1, _t = !1, LL = !1;
    function vR() {
      return _t;
    }
    function W3() {
      LL = !0;
    }
    function V3() {
      _t = !1, LL = !1;
    }
    function x3() {
      _t = LL, LL = !1;
    }
    function TR() {
      return gR;
    }
    function fR() {
      gR = Dd();
    }
    function lX(c) {
      je = Dd(), c.actualStartTime < 0 && (c.actualStartTime = Dd());
    }
    function ER(c) {
      je = -1;
    }
    function hL(c, b) {
      if (je >= 0) {
        var d = Dd() - je;
        c.actualDuration += d, b && (c.selfBaseDuration = d), je = -1;
      }
    }
    function ss(c) {
      if (nL >= 0) {
        var b = Dd() - nL;
        nL = -1;
        for (var d = c.return; d !== null; ) {
          switch (d.tag) {
            case h:
              var o = d.stateNode;
              o.effectDuration += b;
              return;
            case U:
              var e = d.stateNode;
              e.effectDuration += b;
              return;
          }
          d = d.return;
        }
      }
    }
    function ZX(c) {
      if (pL >= 0) {
        var b = Dd() - pL;
        pL = -1;
        for (var d = c.return; d !== null; ) {
          switch (d.tag) {
            case h:
              var o = d.stateNode;
              o !== null && (o.passiveEffectDuration += b);
              return;
            case U:
              var e = d.stateNode;
              e !== null && (e.passiveEffectDuration += b);
              return;
          }
          d = d.return;
        }
      }
    }
    function ds() {
      nL = Dd();
    }
    function cX() {
      pL = Dd();
    }
    function bX(c) {
      for (var b = c.child; b; )
        c.actualDuration += b.actualDuration, b = b.sibling;
    }
    function ru(c, b) {
      if (c && c.defaultProps) {
        var d = GZ({}, b), o = c.defaultProps;
        for (var e in o)
          d[e] === void 0 && (d[e] = o[e]);
        return d;
      }
      return b;
    }
    var uX = {}, sX, dX, GX, mX, iX, BR, yL, oX, eX, aX, Qe;
    {
      sX = /* @__PURE__ */ new Set(), dX = /* @__PURE__ */ new Set(), GX = /* @__PURE__ */ new Set(), mX = /* @__PURE__ */ new Set(), oX = /* @__PURE__ */ new Set(), iX = /* @__PURE__ */ new Set(), eX = /* @__PURE__ */ new Set(), aX = /* @__PURE__ */ new Set(), Qe = /* @__PURE__ */ new Set();
      var DR = /* @__PURE__ */ new Set();
      yL = function(c, b) {
        if (!(c === null || typeof c == "function")) {
          var d = b + "_" + c;
          DR.has(d) || (DR.add(d), m("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", b, c));
        }
      }, BR = function(c, b) {
        if (b === void 0) {
          var d = tZ(c) || "Component";
          iX.has(d) || (iX.add(d), m("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      }, Object.defineProperty(uX, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(uX);
    }
    function nX(c, b, d, o) {
      var e = c.memoizedState, L = d(o, e);
      {
        if (c.mode & Gc) {
          Jc(!0);
          try {
            L = d(o, e);
          } finally {
            Jc(!1);
          }
        }
        BR(b, L);
      }
      var X = L == null ? e : GZ({}, e, L);
      if (c.memoizedState = X, c.lanes === Sl) {
        var K = c.updateQueue;
        K.baseState = X;
      }
    }
    var pX = {
      isMounted: LN,
      enqueueSetState: function(c, b, d) {
        var o = Qm(c), e = Xb(), L = Od(o), X = js(e, L);
        X.payload = b, d != null && (yL(d, "setState"), X.callback = d);
        var K = Td(o, X, L);
        K !== null && (rc(K, o, L, e), jp(K, o, L)), Dy(o, L);
      },
      enqueueReplaceState: function(c, b, d) {
        var o = Qm(c), e = Xb(), L = Od(o), X = js(e, L);
        X.tag = mR, X.payload = b, d != null && (yL(d, "replaceState"), X.callback = d);
        var K = Td(o, X, L);
        K !== null && (rc(K, o, L, e), jp(K, o, L)), Dy(o, L);
      },
      enqueueForceUpdate: function(c, b) {
        var d = Qm(c), o = Xb(), e = Od(d), L = js(o, e);
        L.tag = Ep, b != null && (yL(b, "forceUpdate"), L.callback = b);
        var X = Td(d, L, e);
        X !== null && (rc(X, d, e, o), jp(X, d, e)), jN(d, e);
      }
    };
    function jR(c, b, d, o, e, L, X) {
      var K = c.stateNode;
      if (typeof K.shouldComponentUpdate == "function") {
        var Y = K.shouldComponentUpdate(o, L, X);
        {
          if (c.mode & Gc) {
            Jc(!0);
            try {
              Y = K.shouldComponentUpdate(o, L, X);
            } finally {
              Jc(!1);
            }
          }
          Y === void 0 && m("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", tZ(b) || "Component");
        }
        return Y;
      }
      return b.prototype && b.prototype.isPureReactComponent ? !Le(d, o) || !Le(e, L) : !0;
    }
    function R3(c, b, d) {
      var o = c.stateNode;
      {
        var e = tZ(b) || "Component", L = o.render;
        L || (b.prototype && typeof b.prototype.render == "function" ? m("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", e) : m("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", e)), o.getInitialState && !o.getInitialState.isReactClassApproved && !o.state && m("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", e), o.getDefaultProps && !o.getDefaultProps.isReactClassApproved && m("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", e), o.propTypes && m("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", e), o.contextType && m("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", e), b.childContextTypes && !Qe.has(b) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (c.mode & Gc) === Ql && (Qe.add(b), m(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, e)), b.contextTypes && !Qe.has(b) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (c.mode & Gc) === Ql && (Qe.add(b), m(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, e)), o.contextTypes && m("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", e), b.contextType && b.contextTypes && !eX.has(b) && (eX.add(b), m("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", e)), typeof o.componentShouldUpdate == "function" && m("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", e), b.prototype && b.prototype.isPureReactComponent && typeof o.shouldComponentUpdate < "u" && m("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", tZ(b) || "A pure component"), typeof o.componentDidUnmount == "function" && m("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", e), typeof o.componentDidReceiveProps == "function" && m("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", e), typeof o.componentWillRecieveProps == "function" && m("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", e), typeof o.UNSAFE_componentWillRecieveProps == "function" && m("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", e);
        var X = o.props !== d;
        o.props !== void 0 && X && m("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", e, e), o.defaultProps && m("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", e, e), typeof o.getSnapshotBeforeUpdate == "function" && typeof o.componentDidUpdate != "function" && !GX.has(b) && (GX.add(b), m("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", tZ(b))), typeof o.getDerivedStateFromProps == "function" && m("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", e), typeof o.getDerivedStateFromError == "function" && m("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", e), typeof b.getSnapshotBeforeUpdate == "function" && m("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", e);
        var K = o.state;
        K && (typeof K != "object" || xZ(K)) && m("%s.state: must be set to an object or null", e), typeof o.getChildContext == "function" && typeof b.childContextTypes != "object" && m("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", e);
      }
    }
    function QR(c, b) {
      b.updater = pX, c.stateNode = b, oN(b, c), b._reactInternalInstance = uX;
    }
    function PR(c, b, d) {
      var o = !1, e = Ab, L = Ab, X = b.contextType;
      if ("contextType" in b) {
        var K = (
          // Allow null for conditional declaration
          X === null || X !== void 0 && X.$$typeof === yl && X._context === void 0
        );
        if (!K && !aX.has(b)) {
          aX.add(b);
          var Y = "";
          X === void 0 ? Y = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof X != "object" ? Y = " However, it is set to a " + typeof X + "." : X.$$typeof === P ? Y = " Did you accidentally pass the Context.Provider instead?" : X._context !== void 0 ? Y = " Did you accidentally pass the Context.Consumer instead?" : Y = " However, it is set to an object with keys {" + Object.keys(X).join(", ") + "}.", m("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", tZ(b) || "Component", Y);
        }
      }
      if (typeof X == "object" && X !== null)
        L = Kc(X);
      else {
        e = ei(c, b, !0);
        var N = b.contextTypes;
        o = N != null, L = o ? ai(c, e) : Ab;
      }
      var H = new b(d, L);
      if (c.mode & Gc) {
        Jc(!0);
        try {
          H = new b(d, L);
        } finally {
          Jc(!1);
        }
      }
      var q = c.memoizedState = H.state !== null && H.state !== void 0 ? H.state : null;
      QR(c, H);
      {
        if (typeof b.getDerivedStateFromProps == "function" && q === null) {
          var $ = tZ(b) || "Component";
          dX.has($) || (dX.add($), m("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", $, H.state === null ? "null" : "undefined", $));
        }
        if (typeof b.getDerivedStateFromProps == "function" || typeof H.getSnapshotBeforeUpdate == "function") {
          var sl = null, Gl = null, nl = null;
          if (typeof H.componentWillMount == "function" && H.componentWillMount.__suppressDeprecationWarning !== !0 ? sl = "componentWillMount" : typeof H.UNSAFE_componentWillMount == "function" && (sl = "UNSAFE_componentWillMount"), typeof H.componentWillReceiveProps == "function" && H.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Gl = "componentWillReceiveProps" : typeof H.UNSAFE_componentWillReceiveProps == "function" && (Gl = "UNSAFE_componentWillReceiveProps"), typeof H.componentWillUpdate == "function" && H.componentWillUpdate.__suppressDeprecationWarning !== !0 ? nl = "componentWillUpdate" : typeof H.UNSAFE_componentWillUpdate == "function" && (nl = "UNSAFE_componentWillUpdate"), sl !== null || Gl !== null || nl !== null) {
            var Ul = tZ(b) || "Component", Dl = typeof b.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            mX.has(Ul) || (mX.add(Ul), m(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Ul, Dl, sl !== null ? `
  ` + sl : "", Gl !== null ? `
  ` + Gl : "", nl !== null ? `
  ` + nl : ""));
          }
        }
      }
      return o && J0(c, e, L), H;
    }
    function Y3(c, b) {
      var d = b.state;
      typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), d !== b.state && (m("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", bZ(c) || "Component"), pX.enqueueReplaceState(b, b.state, null));
    }
    function OR(c, b, d, o) {
      var e = b.state;
      if (typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps(d, o), typeof b.UNSAFE_componentWillReceiveProps == "function" && b.UNSAFE_componentWillReceiveProps(d, o), b.state !== e) {
        {
          var L = bZ(c) || "Component";
          sX.has(L) || (sX.add(L), m("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", L));
        }
        pX.enqueueReplaceState(b, b.state, null);
      }
    }
    function LX(c, b, d, o) {
      R3(c, b, d);
      var e = c.stateNode;
      e.props = d, e.state = c.memoizedState, e.refs = {}, xt(c);
      var L = b.contextType;
      if (typeof L == "object" && L !== null)
        e.context = Kc(L);
      else {
        var X = ei(c, b, !0);
        e.context = ai(c, X);
      }
      {
        if (e.state === d) {
          var K = tZ(b) || "Component";
          oX.has(K) || (oX.add(K), m("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", K));
        }
        c.mode & Gc && Iu.recordLegacyContextWarning(c, e), Iu.recordUnsafeLifecycleWarnings(c, e);
      }
      e.state = c.memoizedState;
      var Y = b.getDerivedStateFromProps;
      if (typeof Y == "function" && (nX(c, b, Y, d), e.state = c.memoizedState), typeof b.getDerivedStateFromProps != "function" && typeof e.getSnapshotBeforeUpdate != "function" && (typeof e.UNSAFE_componentWillMount == "function" || typeof e.componentWillMount == "function") && (Y3(c, e), Qp(c, d, e, o), e.state = c.memoizedState), typeof e.componentDidMount == "function") {
        var N = SZ;
        N |= FG, (c.mode & qu) !== Ql && (N |= zs), c.flags |= N;
      }
    }
    function k3(c, b, d, o) {
      var e = c.stateNode, L = c.memoizedProps;
      e.props = L;
      var X = e.context, K = b.contextType, Y = Ab;
      if (typeof K == "object" && K !== null)
        Y = Kc(K);
      else {
        var N = ei(c, b, !0);
        Y = ai(c, N);
      }
      var H = b.getDerivedStateFromProps, q = typeof H == "function" || typeof e.getSnapshotBeforeUpdate == "function";
      !q && (typeof e.UNSAFE_componentWillReceiveProps == "function" || typeof e.componentWillReceiveProps == "function") && (L !== d || X !== Y) && OR(c, e, d, Y), oR();
      var $ = c.memoizedState, sl = e.state = $;
      if (Qp(c, d, e, o), sl = c.memoizedState, L === d && $ === sl && !Mp() && !Pp()) {
        if (typeof e.componentDidMount == "function") {
          var Gl = SZ;
          Gl |= FG, (c.mode & qu) !== Ql && (Gl |= zs), c.flags |= Gl;
        }
        return !1;
      }
      typeof H == "function" && (nX(c, b, H, d), sl = c.memoizedState);
      var nl = Pp() || jR(c, b, L, d, $, sl, Y);
      if (nl) {
        if (!q && (typeof e.UNSAFE_componentWillMount == "function" || typeof e.componentWillMount == "function") && (typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount()), typeof e.componentDidMount == "function") {
          var Ul = SZ;
          Ul |= FG, (c.mode & qu) !== Ql && (Ul |= zs), c.flags |= Ul;
        }
      } else {
        if (typeof e.componentDidMount == "function") {
          var Dl = SZ;
          Dl |= FG, (c.mode & qu) !== Ql && (Dl |= zs), c.flags |= Dl;
        }
        c.memoizedProps = d, c.memoizedState = sl;
      }
      return e.props = d, e.state = sl, e.context = Y, nl;
    }
    function M3(c, b, d, o, e) {
      var L = b.stateNode;
      iR(c, b);
      var X = b.memoizedProps, K = b.type === b.elementType ? X : ru(b.type, X);
      L.props = K;
      var Y = b.pendingProps, N = L.context, H = d.contextType, q = Ab;
      if (typeof H == "object" && H !== null)
        q = Kc(H);
      else {
        var $ = ei(b, d, !0);
        q = ai(b, $);
      }
      var sl = d.getDerivedStateFromProps, Gl = typeof sl == "function" || typeof L.getSnapshotBeforeUpdate == "function";
      !Gl && (typeof L.UNSAFE_componentWillReceiveProps == "function" || typeof L.componentWillReceiveProps == "function") && (X !== Y || N !== q) && OR(b, L, o, q), oR();
      var nl = b.memoizedState, Ul = L.state = nl;
      if (Qp(b, o, L, e), Ul = b.memoizedState, X === Y && nl === Ul && !Mp() && !Pp() && !_)
        return typeof L.componentDidUpdate == "function" && (X !== c.memoizedProps || nl !== c.memoizedState) && (b.flags |= SZ), typeof L.getSnapshotBeforeUpdate == "function" && (X !== c.memoizedProps || nl !== c.memoizedState) && (b.flags |= CG), !1;
      typeof sl == "function" && (nX(b, d, sl, o), Ul = b.memoizedState);
      var Dl = Pp() || jR(b, d, K, o, nl, Ul, q) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      _;
      return Dl ? (!Gl && (typeof L.UNSAFE_componentWillUpdate == "function" || typeof L.componentWillUpdate == "function") && (typeof L.componentWillUpdate == "function" && L.componentWillUpdate(o, Ul, q), typeof L.UNSAFE_componentWillUpdate == "function" && L.UNSAFE_componentWillUpdate(o, Ul, q)), typeof L.componentDidUpdate == "function" && (b.flags |= SZ), typeof L.getSnapshotBeforeUpdate == "function" && (b.flags |= CG)) : (typeof L.componentDidUpdate == "function" && (X !== c.memoizedProps || nl !== c.memoizedState) && (b.flags |= SZ), typeof L.getSnapshotBeforeUpdate == "function" && (X !== c.memoizedProps || nl !== c.memoizedState) && (b.flags |= CG), b.memoizedProps = o, b.memoizedState = Ul), L.props = o, L.state = Ul, L.context = q, Dl;
    }
    function $G(c, b) {
      return {
        value: c,
        source: b,
        stack: No(b),
        digest: null
      };
    }
    function hX(c, b, d) {
      return {
        value: c,
        source: null,
        stack: d ?? null,
        digest: b ?? null
      };
    }
    function I3(c, b) {
      return !0;
    }
    function yX(c, b) {
      try {
        var d = I3(c, b);
        if (d === !1)
          return;
        var o = b.value, e = b.source, L = b.stack, X = L !== null ? L : "";
        if (o != null && o._suppressLogging) {
          if (c.tag === p)
            return;
          console.error(o);
        }
        var K = e ? bZ(e) : null, Y = K ? "The above error occurred in the <" + K + "> component:" : "The above error occurred in one of your React components:", N;
        if (c.tag === h)
          N = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var H = bZ(c) || "Anonymous";
          N = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + H + ".");
        }
        var q = Y + `
` + X + `

` + ("" + N);
        console.error(q);
      } catch ($) {
        setTimeout(function() {
          throw $;
        });
      }
    }
    var U3 = typeof WeakMap == "function" ? WeakMap : Map;
    function AR(c, b, d) {
      var o = js(jZ, d);
      o.tag = Wt, o.payload = {
        element: null
      };
      var e = b.value;
      return o.callback = function() {
        Wv(e), yX(c, b);
      }, o;
    }
    function SX(c, b, d) {
      var o = js(jZ, d);
      o.tag = Wt;
      var e = c.type.getDerivedStateFromError;
      if (typeof e == "function") {
        var L = b.value;
        o.payload = function() {
          return e(L);
        }, o.callback = function() {
          Gk(c), yX(c, b);
        };
      }
      var X = c.stateNode;
      return X !== null && typeof X.componentDidCatch == "function" && (o.callback = function() {
        Gk(c), yX(c, b), typeof e != "function" && Xv(this);
        var Y = b.value, N = b.stack;
        this.componentDidCatch(Y, {
          componentStack: N !== null ? N : ""
        }), typeof e != "function" && (jb(c.lanes, ql) || m("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", bZ(c) || "Unknown"));
      }), o;
    }
    function $R(c, b, d) {
      var o = c.pingCache, e;
      if (o === null ? (o = c.pingCache = new U3(), e = /* @__PURE__ */ new Set(), o.set(b, e)) : (e = o.get(b), e === void 0 && (e = /* @__PURE__ */ new Set(), o.set(b, e))), !e.has(d)) {
        e.add(d);
        var L = Vv.bind(null, c, b, d);
        Ru && oa(c, d), b.then(L, L);
      }
    }
    function C3(c, b, d, o) {
      var e = c.updateQueue;
      if (e === null) {
        var L = /* @__PURE__ */ new Set();
        L.add(d), c.updateQueue = L;
      } else
        e.add(d);
    }
    function r3(c, b) {
      var d = c.tag;
      if ((c.mode & pZ) === Ql && (d === n || d === k || d === D)) {
        var o = c.alternate;
        o ? (c.updateQueue = o.updateQueue, c.memoizedState = o.memoizedState, c.lanes = o.lanes) : (c.updateQueue = null, c.memoizedState = null);
      }
    }
    function qR(c) {
      var b = c;
      do {
        if (b.tag === w && a3(b))
          return b;
        b = b.return;
      } while (b !== null);
      return null;
    }
    function _R(c, b, d, o, e) {
      if ((c.mode & pZ) === Ql) {
        if (c === b)
          c.flags |= yb;
        else {
          if (c.flags |= RZ, d.flags |= Hy, d.flags &= ~(eN | jo), d.tag === p) {
            var L = d.alternate;
            if (L === null)
              d.tag = j;
            else {
              var X = js(jZ, ql);
              X.tag = Ep, Td(d, X, ql);
            }
          }
          d.lanes = mZ(d.lanes, ql);
        }
        return c;
      }
      return c.flags |= yb, c.lanes = e, c;
    }
    function F3(c, b, d, o, e) {
      if (d.flags |= jo, Ru && oa(c, e), o !== null && typeof o == "object" && typeof o.then == "function") {
        var L = o;
        r3(d), Dc() && d.mode & pZ && B0();
        var X = qR(b);
        if (X !== null) {
          X.flags &= ~Ns, _R(X, b, d, c, e), X.mode & pZ && $R(c, L, e), C3(X, c, L);
          return;
        } else {
          if (!Zw(e)) {
            $R(c, L, e), $X();
            return;
          }
          var K = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          o = K;
        }
      } else if (Dc() && d.mode & pZ) {
        B0();
        var Y = qR(b);
        if (Y !== null) {
          (Y.flags & yb) === Pl && (Y.flags |= Ns), _R(Y, b, d, c, e), ot($G(o, d));
          return;
        }
      }
      o = $G(o, d), av(o);
      var N = b;
      do {
        switch (N.tag) {
          case h: {
            var H = o;
            N.flags |= yb;
            var q = le(e);
            N.lanes = mZ(N.lanes, q);
            var $ = AR(N, H, q);
            Rt(N, $);
            return;
          }
          case p:
            var sl = o, Gl = N.type, nl = N.stateNode;
            if ((N.flags & RZ) === Pl && (typeof Gl.getDerivedStateFromError == "function" || nl !== null && typeof nl.componentDidCatch == "function" && !qY(nl))) {
              N.flags |= yb;
              var Ul = le(e);
              N.lanes = mZ(N.lanes, Ul);
              var Dl = SX(N, sl, Ul);
              Rt(N, Dl);
              return;
            }
            break;
        }
        N = N.return;
      } while (N !== null);
    }
    function N3() {
      return null;
    }
    var Pe = u.ReactCurrentOwner, Fu = !1, tX, Oe, XX, KX, WX, qG, VX, SL, Ae;
    tX = {}, Oe = {}, XX = {}, KX = {}, WX = {}, qG = !1, VX = {}, SL = {}, Ae = {};
    function Sb(c, b, d, o) {
      c === null ? b.child = cR(b, null, d, o) : b.child = hi(b, c.child, d, o);
    }
    function w3(c, b, d, o) {
      b.child = hi(b, c.child, null, o), b.child = hi(b, null, d, o);
    }
    function lY(c, b, d, o, e) {
      if (b.type !== b.elementType) {
        var L = d.propTypes;
        L && ku(
          L,
          o,
          // Resolved props
          "prop",
          tZ(d)
        );
      }
      var X = d.render, K = b.ref, Y, N;
      Si(b, e), Po(b);
      {
        if (Pe.current = b, Bb(!0), Y = xi(c, b, X, o, K, e), N = Ri(), b.mode & Gc) {
          Jc(!0);
          try {
            Y = xi(c, b, X, o, K, e), N = Ri();
          } finally {
            Jc(!1);
          }
        }
        Bb(!1);
      }
      return $m(), c !== null && !Fu ? (hR(c, b, e), Qs(c, b, e)) : (Dc() && N && ut(b), b.flags |= Pm, Sb(c, b, Y, e), b.child);
    }
    function ZY(c, b, d, o, e) {
      if (c === null) {
        var L = d.type;
        if (vv(L) && d.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        d.defaultProps === void 0) {
          var X = L;
          return X = Fi(L), b.tag = D, b.type = X, YX(b, L), cY(c, b, X, o, e);
        }
        {
          var K = L.propTypes;
          if (K && ku(
            K,
            o,
            // Resolved props
            "prop",
            tZ(L)
          ), d.defaultProps !== void 0) {
            var Y = tZ(L) || "Unknown";
            Ae[Y] || (m("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", Y), Ae[Y] = !0);
          }
        }
        var N = mK(d.type, null, o, b, b.mode, e);
        return N.ref = b.ref, N.return = b, b.child = N, N;
      }
      {
        var H = d.type, q = H.propTypes;
        q && ku(
          q,
          o,
          // Resolved props
          "prop",
          tZ(H)
        );
      }
      var $ = c.child, sl = rX(c, e);
      if (!sl) {
        var Gl = $.memoizedProps, nl = d.compare;
        if (nl = nl !== null ? nl : Le, nl(Gl, o) && c.ref === b.ref)
          return Qs(c, b, e);
      }
      b.flags |= Pm;
      var Ul = bm($, o);
      return Ul.ref = b.ref, Ul.return = b, b.child = Ul, Ul;
    }
    function cY(c, b, d, o, e) {
      if (b.type !== b.elementType) {
        var L = b.elementType;
        if (L.$$typeof === jl) {
          var X = L, K = X._payload, Y = X._init;
          try {
            L = Y(K);
          } catch {
            L = null;
          }
          var N = L && L.propTypes;
          N && ku(
            N,
            o,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            tZ(L)
          );
        }
      }
      if (c !== null) {
        var H = c.memoizedProps;
        if (Le(H, o) && c.ref === b.ref && // Prevent bailout if the implementation changed due to hot reload.
        b.type === c.type)
          if (Fu = !1, b.pendingProps = o = H, rX(c, e))
            (c.flags & Hy) !== Pl && (Fu = !0);
          else return b.lanes = c.lanes, Qs(c, b, e);
      }
      return xX(c, b, d, o, e);
    }
    function bY(c, b, d) {
      var o = b.pendingProps, e = o.children, L = c !== null ? c.memoizedState : null;
      if (o.mode === "hidden" || il)
        if ((b.mode & pZ) === Ql) {
          var X = {
            baseLanes: Sl,
            cachePool: null,
            transitions: null
          };
          b.memoizedState = X, CL(b, d);
        } else if (jb(d, Db)) {
          var q = {
            baseLanes: Sl,
            cachePool: null,
            transitions: null
          };
          b.memoizedState = q;
          var $ = L !== null ? L.baseLanes : d;
          CL(b, $);
        } else {
          var K = null, Y;
          if (L !== null) {
            var N = L.baseLanes;
            Y = mZ(N, d);
          } else
            Y = d;
          b.lanes = b.childLanes = Db;
          var H = {
            baseLanes: Y,
            cachePool: K,
            transitions: null
          };
          return b.memoizedState = H, b.updateQueue = null, CL(b, Y), null;
        }
      else {
        var sl;
        L !== null ? (sl = mZ(L.baseLanes, d), b.memoizedState = null) : sl = d, CL(b, sl);
      }
      return Sb(c, b, e, d), b.child;
    }
    function z3(c, b, d) {
      var o = b.pendingProps;
      return Sb(c, b, o, d), b.child;
    }
    function J3(c, b, d) {
      var o = b.pendingProps.children;
      return Sb(c, b, o, d), b.child;
    }
    function H3(c, b, d) {
      {
        b.flags |= SZ;
        {
          var o = b.stateNode;
          o.effectDuration = 0, o.passiveEffectDuration = 0;
        }
      }
      var e = b.pendingProps, L = e.children;
      return Sb(c, b, L, d), b.child;
    }
    function uY(c, b) {
      var d = b.ref;
      (c === null && d !== null || c !== null && c.ref !== d) && (b.flags |= Id, b.flags |= gy);
    }
    function xX(c, b, d, o, e) {
      if (b.type !== b.elementType) {
        var L = d.propTypes;
        L && ku(
          L,
          o,
          // Resolved props
          "prop",
          tZ(d)
        );
      }
      var X;
      {
        var K = ei(b, d, !0);
        X = ai(b, K);
      }
      var Y, N;
      Si(b, e), Po(b);
      {
        if (Pe.current = b, Bb(!0), Y = xi(c, b, d, o, X, e), N = Ri(), b.mode & Gc) {
          Jc(!0);
          try {
            Y = xi(c, b, d, o, X, e), N = Ri();
          } finally {
            Jc(!1);
          }
        }
        Bb(!1);
      }
      return $m(), c !== null && !Fu ? (hR(c, b, e), Qs(c, b, e)) : (Dc() && N && ut(b), b.flags |= Pm, Sb(c, b, Y, e), b.child);
    }
    function sY(c, b, d, o, e) {
      {
        switch (ZT(b)) {
          case !1: {
            var L = b.stateNode, X = b.type, K = new X(b.memoizedProps, L.context), Y = K.state;
            L.updater.enqueueSetState(L, Y, null);
            break;
          }
          case !0: {
            b.flags |= RZ, b.flags |= yb;
            var N = new Error("Simulated error coming from DevTools"), H = le(e);
            b.lanes = mZ(b.lanes, H);
            var q = SX(b, $G(N, b), H);
            Rt(b, q);
            break;
          }
        }
        if (b.type !== b.elementType) {
          var $ = d.propTypes;
          $ && ku(
            $,
            o,
            // Resolved props
            "prop",
            tZ(d)
          );
        }
      }
      var sl;
      Zs(d) ? (sl = !0, Up(b)) : sl = !1, Si(b, e);
      var Gl = b.stateNode, nl;
      Gl === null ? (XL(c, b), PR(b, d, o), LX(b, d, o, e), nl = !0) : c === null ? nl = k3(b, d, o, e) : nl = M3(c, b, d, o, e);
      var Ul = RX(c, b, d, nl, sl, e);
      {
        var Dl = b.stateNode;
        nl && Dl.props !== o && (qG || m("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", bZ(b) || "a component"), qG = !0);
      }
      return Ul;
    }
    function RX(c, b, d, o, e, L) {
      uY(c, b);
      var X = (b.flags & RZ) !== Pl;
      if (!o && !X)
        return e && v0(b, d, !1), Qs(c, b, L);
      var K = b.stateNode;
      Pe.current = b;
      var Y;
      if (X && typeof d.getDerivedStateFromError != "function")
        Y = null, ER();
      else {
        Po(b);
        {
          if (Bb(!0), Y = K.render(), b.mode & Gc) {
            Jc(!0);
            try {
              K.render();
            } finally {
              Jc(!1);
            }
          }
          Bb(!1);
        }
        $m();
      }
      return b.flags |= Pm, c !== null && X ? w3(c, b, Y, L) : Sb(c, b, Y, L), b.memoizedState = K.state, e && v0(b, d, !0), b.child;
    }
    function dY(c) {
      var b = c.stateNode;
      b.pendingContext ? H0(c, b.pendingContext, b.pendingContext !== b.context) : b.context && H0(c, b.context, !1), Yt(c, b.containerInfo);
    }
    function g3(c, b, d) {
      if (dY(b), c === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var o = b.pendingProps, e = b.memoizedState, L = e.element;
      iR(c, b), Qp(b, o, null, d);
      var X = b.memoizedState;
      b.stateNode;
      var K = X.element;
      if (e.isDehydrated) {
        var Y = {
          element: K,
          isDehydrated: !1,
          cache: X.cache,
          pendingSuspenseBoundaries: X.pendingSuspenseBoundaries,
          transitions: X.transitions
        }, N = b.updateQueue;
        if (N.baseState = Y, b.memoizedState = Y, b.flags & Ns) {
          var H = $G(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), b);
          return GY(c, b, K, d, H);
        } else if (K !== L) {
          var q = $G(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), b);
          return GY(c, b, K, d, q);
        } else {
          fH(b);
          var $ = cR(b, null, K, d);
          b.child = $;
          for (var sl = $; sl; )
            sl.flags = sl.flags & ~Xc | ws, sl = sl.sibling;
        }
      } else {
        if (Li(), K === L)
          return Qs(c, b, d);
        Sb(c, b, K, d);
      }
      return b.child;
    }
    function GY(c, b, d, o, e) {
      return Li(), ot(e), b.flags |= Ns, Sb(c, b, d, o), b.child;
    }
    function v3(c, b, d) {
      nR(b), c === null && it(b);
      var o = b.type, e = b.pendingProps, L = c !== null ? c.memoizedProps : null, X = e.children, K = BS(o, e);
      return K ? X = null : L !== null && BS(o, L) && (b.flags |= Do), uY(c, b), Sb(c, b, X, d), b.child;
    }
    function T3(c, b) {
      return c === null && it(b), null;
    }
    function f3(c, b, d, o) {
      XL(c, b);
      var e = b.pendingProps, L = d, X = L._payload, K = L._init, Y = K(X);
      b.type = Y;
      var N = b.tag = Tv(Y), H = ru(Y, e), q;
      switch (N) {
        case n:
          return YX(b, Y), b.type = Y = Fi(Y), q = xX(null, b, Y, H, o), q;
        case p:
          return b.type = Y = cK(Y), q = sY(null, b, Y, H, o), q;
        case k:
          return b.type = Y = bK(Y), q = lY(null, b, Y, H, o), q;
        case z: {
          if (b.type !== b.elementType) {
            var $ = Y.propTypes;
            $ && ku(
              $,
              H,
              // Resolved for outer only
              "prop",
              tZ(Y)
            );
          }
          return q = ZY(
            null,
            b,
            Y,
            ru(Y.type, H),
            // The inner type can have defaults too
            o
          ), q;
        }
      }
      var sl = "";
      throw Y !== null && typeof Y == "object" && Y.$$typeof === jl && (sl = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + Y + ". " + ("Lazy element type must resolve to a class or function." + sl));
    }
    function E3(c, b, d, o, e) {
      XL(c, b), b.tag = p;
      var L;
      return Zs(d) ? (L = !0, Up(b)) : L = !1, Si(b, e), PR(b, d, o), LX(b, d, o, e), RX(null, b, d, !0, L, e);
    }
    function B3(c, b, d, o) {
      XL(c, b);
      var e = b.pendingProps, L;
      {
        var X = ei(b, d, !1);
        L = ai(b, X);
      }
      Si(b, o);
      var K, Y;
      Po(b);
      {
        if (d.prototype && typeof d.prototype.render == "function") {
          var N = tZ(d) || "Unknown";
          tX[N] || (m("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", N, N), tX[N] = !0);
        }
        b.mode & Gc && Iu.recordLegacyContextWarning(b, null), Bb(!0), Pe.current = b, K = xi(null, b, d, e, L, o), Y = Ri(), Bb(!1);
      }
      if ($m(), b.flags |= Pm, typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0) {
        var H = tZ(d) || "Unknown";
        Oe[H] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", H, H, H), Oe[H] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof K == "object" && K !== null && typeof K.render == "function" && K.$$typeof === void 0
      ) {
        {
          var q = tZ(d) || "Unknown";
          Oe[q] || (m("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", q, q, q), Oe[q] = !0);
        }
        b.tag = p, b.memoizedState = null, b.updateQueue = null;
        var $ = !1;
        return Zs(d) ? ($ = !0, Up(b)) : $ = !1, b.memoizedState = K.state !== null && K.state !== void 0 ? K.state : null, xt(b), QR(b, K), LX(b, d, e, o), RX(null, b, d, !0, $, o);
      } else {
        if (b.tag = n, b.mode & Gc) {
          Jc(!0);
          try {
            K = xi(null, b, d, e, L, o), Y = Ri();
          } finally {
            Jc(!1);
          }
        }
        return Dc() && Y && ut(b), Sb(null, b, K, o), YX(b, d), b.child;
      }
    }
    function YX(c, b) {
      {
        if (b && b.childContextTypes && m("%s(...): childContextTypes cannot be defined on a function component.", b.displayName || b.name || "Component"), c.ref !== null) {
          var d = "", o = Rd();
          o && (d += `

Check the render method of \`` + o + "`.");
          var e = o || "", L = c._debugSource;
          L && (e = L.fileName + ":" + L.lineNumber), WX[e] || (WX[e] = !0, m("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", d));
        }
        if (b.defaultProps !== void 0) {
          var X = tZ(b) || "Unknown";
          Ae[X] || (m("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", X), Ae[X] = !0);
        }
        if (typeof b.getDerivedStateFromProps == "function") {
          var K = tZ(b) || "Unknown";
          KX[K] || (m("%s: Function components do not support getDerivedStateFromProps.", K), KX[K] = !0);
        }
        if (typeof b.contextType == "object" && b.contextType !== null) {
          var Y = tZ(b) || "Unknown";
          XX[Y] || (m("%s: Function components do not support contextType.", Y), XX[Y] = !0);
        }
      }
    }
    var kX = {
      dehydrated: null,
      treeContext: null,
      retryLane: Hc
    };
    function MX(c) {
      return {
        baseLanes: c,
        cachePool: N3(),
        transitions: null
      };
    }
    function D3(c, b) {
      var d = null;
      return {
        baseLanes: mZ(c.baseLanes, b),
        cachePool: d,
        transitions: c.transitions
      };
    }
    function j3(c, b, d, o) {
      if (b !== null) {
        var e = b.memoizedState;
        if (e === null)
          return !1;
      }
      return It(c, ge);
    }
    function Q3(c, b) {
      return _n(c.childLanes, b);
    }
    function mY(c, b, d) {
      var o = b.pendingProps;
      cT(b) && (b.flags |= RZ);
      var e = Uu.current, L = !1, X = (b.flags & RZ) !== Pl;
      if (X || j3(e, c) ? (L = !0, b.flags &= ~RZ) : (c === null || c.memoizedState !== null) && (e = e3(e, LR)), e = Xi(e), Ed(b, e), c === null) {
        it(b);
        var K = b.memoizedState;
        if (K !== null) {
          var Y = K.dehydrated;
          if (Y !== null)
            return q3(b, Y);
        }
        var N = o.children, H = o.fallback;
        if (L) {
          var q = P3(b, N, H, d), $ = b.child;
          return $.memoizedState = MX(d), b.memoizedState = kX, q;
        } else
          return IX(b, N);
      } else {
        var sl = c.memoizedState;
        if (sl !== null) {
          var Gl = sl.dehydrated;
          if (Gl !== null)
            return _3(c, b, X, o, Gl, sl, d);
        }
        if (L) {
          var nl = o.fallback, Ul = o.children, Dl = A3(c, b, Ul, nl, d), fl = b.child, hZ = c.child.memoizedState;
          return fl.memoizedState = hZ === null ? MX(d) : D3(hZ, d), fl.childLanes = Q3(c, d), b.memoizedState = kX, Dl;
        } else {
          var eZ = o.children, bl = O3(c, b, eZ, d);
          return b.memoizedState = null, bl;
        }
      }
    }
    function IX(c, b, d) {
      var o = c.mode, e = {
        mode: "visible",
        children: b
      }, L = UX(e, o);
      return L.return = c, c.child = L, L;
    }
    function P3(c, b, d, o) {
      var e = c.mode, L = c.child, X = {
        mode: "hidden",
        children: b
      }, K, Y;
      return (e & pZ) === Ql && L !== null ? (K = L, K.childLanes = Sl, K.pendingProps = X, c.mode & rZ && (K.actualDuration = 0, K.actualStartTime = -1, K.selfBaseDuration = 0, K.treeBaseDuration = 0), Y = $d(d, e, o, null)) : (K = UX(X, e), Y = $d(d, e, o, null)), K.return = c, Y.return = c, K.sibling = Y, c.child = K, Y;
    }
    function UX(c, b, d) {
      return ik(c, b, Sl, null);
    }
    function iY(c, b) {
      return bm(c, b);
    }
    function O3(c, b, d, o) {
      var e = c.child, L = e.sibling, X = iY(e, {
        mode: "visible",
        children: d
      });
      if ((b.mode & pZ) === Ql && (X.lanes = o), X.return = b, X.sibling = null, L !== null) {
        var K = b.deletions;
        K === null ? (b.deletions = [L], b.flags |= UG) : K.push(L);
      }
      return b.child = X, X;
    }
    function A3(c, b, d, o, e) {
      var L = b.mode, X = c.child, K = X.sibling, Y = {
        mode: "hidden",
        children: d
      }, N;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (L & pZ) === Ql && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        b.child !== X
      ) {
        var H = b.child;
        N = H, N.childLanes = Sl, N.pendingProps = Y, b.mode & rZ && (N.actualDuration = 0, N.actualStartTime = -1, N.selfBaseDuration = X.selfBaseDuration, N.treeBaseDuration = X.treeBaseDuration), b.deletions = null;
      } else
        N = iY(X, Y), N.subtreeFlags = X.subtreeFlags & Js;
      var q;
      return K !== null ? q = bm(K, o) : (q = $d(o, L, e, null), q.flags |= Xc), q.return = b, N.return = b, N.sibling = q, b.child = N, q;
    }
    function tL(c, b, d, o) {
      o !== null && ot(o), hi(b, c.child, null, d);
      var e = b.pendingProps, L = e.children, X = IX(b, L);
      return X.flags |= Xc, b.memoizedState = null, X;
    }
    function $3(c, b, d, o, e) {
      var L = b.mode, X = {
        mode: "visible",
        children: d
      }, K = UX(X, L), Y = $d(o, L, e, null);
      return Y.flags |= Xc, K.return = b, Y.return = b, K.sibling = Y, b.child = K, (b.mode & pZ) !== Ql && hi(b, c.child, null, e), Y;
    }
    function q3(c, b, d) {
      return (c.mode & pZ) === Ql ? (m("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), c.lanes = ql) : PS(b) ? c.lanes = zG : c.lanes = Db, null;
    }
    function _3(c, b, d, o, e, L, X) {
      if (d)
        if (b.flags & Ns) {
          b.flags &= ~Ns;
          var bl = hX(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return tL(c, b, X, bl);
        } else {
          if (b.memoizedState !== null)
            return b.child = c.child, b.flags |= RZ, null;
          var pl = o.children, ul = o.fallback, Xl = $3(c, b, pl, ul, X), Nl = b.child;
          return Nl.memoizedState = MX(X), b.memoizedState = kX, Xl;
        }
      else {
        if (vH(), (b.mode & pZ) === Ql)
          return tL(
            c,
            b,
            X,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (PS(e)) {
          var K, Y, N;
          {
            var H = bH(e);
            K = H.digest, Y = H.message, N = H.stack;
          }
          var q;
          Y ? q = new Error(Y) : q = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var $ = hX(q, K, N);
          return tL(c, b, X, $);
        }
        var sl = jb(X, c.childLanes);
        if (Fu || sl) {
          var Gl = UL();
          if (Gl !== null) {
            var nl = iw(Gl, X);
            if (nl !== Hc && nl !== L.retryLane) {
              L.retryLane = nl;
              var Ul = jZ;
              rb(c, nl), rc(Gl, c, nl, Ul);
            }
          }
          $X();
          var Dl = hX(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return tL(c, b, X, Dl);
        } else if (r0(e)) {
          b.flags |= RZ, b.child = c.child;
          var fl = xv.bind(null, c);
          return uH(e, fl), null;
        } else {
          EH(b, e, L.treeContext);
          var hZ = o.children, eZ = IX(b, hZ);
          return eZ.flags |= ws, eZ;
        }
      }
    }
    function oY(c, b, d) {
      c.lanes = mZ(c.lanes, b);
      var o = c.alternate;
      o !== null && (o.lanes = mZ(o.lanes, b)), Xt(c.return, b, d);
    }
    function lg(c, b, d) {
      for (var o = b; o !== null; ) {
        if (o.tag === w) {
          var e = o.memoizedState;
          e !== null && oY(o, d, c);
        } else if (o.tag === g)
          oY(o, d, c);
        else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === c)
          return;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === c)
            return;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
    }
    function Zg(c) {
      for (var b = c, d = null; b !== null; ) {
        var o = b.alternate;
        o !== null && $p(o) === null && (d = b), b = b.sibling;
      }
      return d;
    }
    function cg(c) {
      if (c !== void 0 && c !== "forwards" && c !== "backwards" && c !== "together" && !VX[c])
        if (VX[c] = !0, typeof c == "string")
          switch (c.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', c, c.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              m('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', c, c.toLowerCase());
              break;
            }
            default:
              m('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
              break;
          }
        else
          m('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', c);
    }
    function bg(c, b) {
      c !== void 0 && !SL[c] && (c !== "collapsed" && c !== "hidden" ? (SL[c] = !0, m('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', c)) : b !== "forwards" && b !== "backwards" && (SL[c] = !0, m('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', c)));
    }
    function eY(c, b) {
      {
        var d = xZ(c), o = !d && typeof Lb(c) == "function";
        if (d || o) {
          var e = d ? "array" : "iterable";
          return m("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", e, b, e), !1;
        }
      }
      return !0;
    }
    function ug(c, b) {
      if ((b === "forwards" || b === "backwards") && c !== void 0 && c !== null && c !== !1)
        if (xZ(c)) {
          for (var d = 0; d < c.length; d++)
            if (!eY(c[d], d))
              return;
        } else {
          var o = Lb(c);
          if (typeof o == "function") {
            var e = o.call(c);
            if (e)
              for (var L = e.next(), X = 0; !L.done; L = e.next()) {
                if (!eY(L.value, X))
                  return;
                X++;
              }
          } else
            m('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', b);
        }
    }
    function CX(c, b, d, o, e) {
      var L = c.memoizedState;
      L === null ? c.memoizedState = {
        isBackwards: b,
        rendering: null,
        renderingStartTime: 0,
        last: o,
        tail: d,
        tailMode: e
      } : (L.isBackwards = b, L.rendering = null, L.renderingStartTime = 0, L.last = o, L.tail = d, L.tailMode = e);
    }
    function aY(c, b, d) {
      var o = b.pendingProps, e = o.revealOrder, L = o.tail, X = o.children;
      cg(e), bg(L, e), ug(X, e), Sb(c, b, X, d);
      var K = Uu.current, Y = It(K, ge);
      if (Y)
        K = Ut(K, ge), b.flags |= RZ;
      else {
        var N = c !== null && (c.flags & RZ) !== Pl;
        N && lg(b, b.child, d), K = Xi(K);
      }
      if (Ed(b, K), (b.mode & pZ) === Ql)
        b.memoizedState = null;
      else
        switch (e) {
          case "forwards": {
            var H = Zg(b.child), q;
            H === null ? (q = b.child, b.child = null) : (q = H.sibling, H.sibling = null), CX(
              b,
              !1,
              // isBackwards
              q,
              H,
              L
            );
            break;
          }
          case "backwards": {
            var $ = null, sl = b.child;
            for (b.child = null; sl !== null; ) {
              var Gl = sl.alternate;
              if (Gl !== null && $p(Gl) === null) {
                b.child = sl;
                break;
              }
              var nl = sl.sibling;
              sl.sibling = $, $ = sl, sl = nl;
            }
            CX(
              b,
              !0,
              // isBackwards
              $,
              null,
              // last
              L
            );
            break;
          }
          case "together": {
            CX(
              b,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            b.memoizedState = null;
        }
      return b.child;
    }
    function sg(c, b, d) {
      Yt(b, b.stateNode.containerInfo);
      var o = b.pendingProps;
      return c === null ? b.child = hi(b, null, o, d) : Sb(c, b, o, d), b.child;
    }
    var nY = !1;
    function dg(c, b, d) {
      var o = b.type, e = o._context, L = b.pendingProps, X = b.memoizedProps, K = L.value;
      {
        "value" in L || nY || (nY = !0, m("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var Y = b.type.propTypes;
        Y && ku(Y, L, "prop", "Context.Provider");
      }
      if (sR(b, e, K), X !== null) {
        var N = X.value;
        if (Ob(N, K)) {
          if (X.children === L.children && !Mp())
            return Qs(c, b, d);
        } else
          c3(b, e, d);
      }
      var H = L.children;
      return Sb(c, b, H, d), b.child;
    }
    var pY = !1;
    function Gg(c, b, d) {
      var o = b.type;
      o._context === void 0 ? o !== o.Consumer && (pY || (pY = !0, m("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : o = o._context;
      var e = b.pendingProps, L = e.children;
      typeof L != "function" && m("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), Si(b, d);
      var X = Kc(o);
      Po(b);
      var K;
      return Pe.current = b, Bb(!0), K = L(X), Bb(!1), $m(), b.flags |= Pm, Sb(c, b, K, d), b.child;
    }
    function $e() {
      Fu = !0;
    }
    function XL(c, b) {
      (b.mode & pZ) === Ql && c !== null && (c.alternate = null, b.alternate = null, b.flags |= Xc);
    }
    function Qs(c, b, d) {
      return c !== null && (b.dependencies = c.dependencies), ER(), ia(b.lanes), jb(d, b.childLanes) ? (l3(c, b), b.child) : null;
    }
    function mg(c, b, d) {
      {
        var o = b.return;
        if (o === null)
          throw new Error("Cannot swap the root fiber.");
        if (c.alternate = null, b.alternate = null, d.index = b.index, d.sibling = b.sibling, d.return = b.return, d.ref = b.ref, b === o.child)
          o.child = d;
        else {
          var e = o.child;
          if (e === null)
            throw new Error("Expected parent to have a child.");
          for (; e.sibling !== b; )
            if (e = e.sibling, e === null)
              throw new Error("Expected to find the previous sibling.");
          e.sibling = d;
        }
        var L = o.deletions;
        return L === null ? (o.deletions = [c], o.flags |= UG) : L.push(c), d.flags |= Xc, d;
      }
    }
    function rX(c, b) {
      var d = c.lanes;
      return !!jb(d, b);
    }
    function ig(c, b, d) {
      switch (b.tag) {
        case h:
          dY(b), b.stateNode, Li();
          break;
        case t:
          nR(b);
          break;
        case p: {
          var o = b.type;
          Zs(o) && Up(b);
          break;
        }
        case S:
          Yt(b, b.stateNode.containerInfo);
          break;
        case r: {
          var e = b.memoizedProps.value, L = b.type._context;
          sR(b, L, e);
          break;
        }
        case U:
          {
            var X = jb(d, b.childLanes);
            X && (b.flags |= SZ);
            {
              var K = b.stateNode;
              K.effectDuration = 0, K.passiveEffectDuration = 0;
            }
          }
          break;
        case w: {
          var Y = b.memoizedState;
          if (Y !== null) {
            if (Y.dehydrated !== null)
              return Ed(b, Xi(Uu.current)), b.flags |= RZ, null;
            var N = b.child, H = N.childLanes;
            if (jb(d, H))
              return mY(c, b, d);
            Ed(b, Xi(Uu.current));
            var q = Qs(c, b, d);
            return q !== null ? q.sibling : null;
          } else
            Ed(b, Xi(Uu.current));
          break;
        }
        case g: {
          var $ = (c.flags & RZ) !== Pl, sl = jb(d, b.childLanes);
          if ($) {
            if (sl)
              return aY(c, b, d);
            b.flags |= RZ;
          }
          var Gl = b.memoizedState;
          if (Gl !== null && (Gl.rendering = null, Gl.tail = null, Gl.lastEffect = null), Ed(b, Uu.current), sl)
            break;
          return null;
        }
        case J:
        case F:
          return b.lanes = Sl, bY(c, b, d);
      }
      return Qs(c, b, d);
    }
    function LY(c, b, d) {
      if (b._debugNeedsRemount && c !== null)
        return mg(c, b, mK(b.type, b.key, b.pendingProps, b._debugOwner || null, b.mode, b.lanes));
      if (c !== null) {
        var o = c.memoizedProps, e = b.pendingProps;
        if (o !== e || Mp() || // Force a re-render if the implementation changed due to hot reload:
        b.type !== c.type)
          Fu = !0;
        else {
          var L = rX(c, d);
          if (!L && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (b.flags & RZ) === Pl)
            return Fu = !1, ig(c, b, d);
          (c.flags & Hy) !== Pl ? Fu = !0 : Fu = !1;
        }
      } else if (Fu = !1, Dc() && NH(b)) {
        var X = b.index, K = wH();
        E0(b, K, X);
      }
      switch (b.lanes = Sl, b.tag) {
        case y:
          return B3(c, b, b.type, d);
        case C: {
          var Y = b.elementType;
          return f3(c, b, Y, d);
        }
        case n: {
          var N = b.type, H = b.pendingProps, q = b.elementType === N ? H : ru(N, H);
          return xX(c, b, N, q, d);
        }
        case p: {
          var $ = b.type, sl = b.pendingProps, Gl = b.elementType === $ ? sl : ru($, sl);
          return sY(c, b, $, Gl, d);
        }
        case h:
          return g3(c, b, d);
        case t:
          return v3(c, b, d);
        case W:
          return T3(c, b);
        case w:
          return mY(c, b, d);
        case S:
          return sg(c, b, d);
        case k: {
          var nl = b.type, Ul = b.pendingProps, Dl = b.elementType === nl ? Ul : ru(nl, Ul);
          return lY(c, b, nl, Dl, d);
        }
        case V:
          return z3(c, b, d);
        case R:
          return J3(c, b, d);
        case U:
          return H3(c, b, d);
        case r:
          return dg(c, b, d);
        case x:
          return Gg(c, b, d);
        case z: {
          var fl = b.type, hZ = b.pendingProps, eZ = ru(fl, hZ);
          if (b.type !== b.elementType) {
            var bl = fl.propTypes;
            bl && ku(
              bl,
              eZ,
              // Resolved for outer only
              "prop",
              tZ(fl)
            );
          }
          return eZ = ru(fl.type, eZ), ZY(c, b, fl, eZ, d);
        }
        case D:
          return cY(c, b, b.type, b.pendingProps, d);
        case j: {
          var pl = b.type, ul = b.pendingProps, Xl = b.elementType === pl ? ul : ru(pl, ul);
          return E3(c, b, pl, Xl, d);
        }
        case g:
          return aY(c, b, d);
        case A:
          break;
        case J:
          return bY(c, b, d);
      }
      throw new Error("Unknown unit of work tag (" + b.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Yi(c) {
      c.flags |= SZ;
    }
    function hY(c) {
      c.flags |= Id, c.flags |= gy;
    }
    var yY, FX, SY, tY;
    yY = function(c, b, d, o) {
      for (var e = b.child; e !== null; ) {
        if (e.tag === t || e.tag === W)
          CJ(c, e.stateNode);
        else if (e.tag !== S) {
          if (e.child !== null) {
            e.child.return = e, e = e.child;
            continue;
          }
        }
        if (e === b)
          return;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === b)
            return;
          e = e.return;
        }
        e.sibling.return = e.return, e = e.sibling;
      }
    }, FX = function(c, b) {
    }, SY = function(c, b, d, o, e) {
      var L = c.memoizedProps;
      if (L !== o) {
        var X = b.stateNode, K = kt(), Y = FJ(X, d, L, o, e, K);
        b.updateQueue = Y, Y && Yi(b);
      }
    }, tY = function(c, b, d, o) {
      d !== o && Yi(b);
    };
    function qe(c, b) {
      if (!Dc())
        switch (c.tailMode) {
          case "hidden": {
            for (var d = c.tail, o = null; d !== null; )
              d.alternate !== null && (o = d), d = d.sibling;
            o === null ? c.tail = null : o.sibling = null;
            break;
          }
          case "collapsed": {
            for (var e = c.tail, L = null; e !== null; )
              e.alternate !== null && (L = e), e = e.sibling;
            L === null ? !b && c.tail !== null ? c.tail.sibling = null : c.tail = null : L.sibling = null;
            break;
          }
        }
    }
    function Qc(c) {
      var b = c.alternate !== null && c.alternate.child === c.child, d = Sl, o = Pl;
      if (b) {
        if ((c.mode & rZ) !== Ql) {
          for (var Y = c.selfBaseDuration, N = c.child; N !== null; )
            d = mZ(d, mZ(N.lanes, N.childLanes)), o |= N.subtreeFlags & Js, o |= N.flags & Js, Y += N.treeBaseDuration, N = N.sibling;
          c.treeBaseDuration = Y;
        } else
          for (var H = c.child; H !== null; )
            d = mZ(d, mZ(H.lanes, H.childLanes)), o |= H.subtreeFlags & Js, o |= H.flags & Js, H.return = c, H = H.sibling;
        c.subtreeFlags |= o;
      } else {
        if ((c.mode & rZ) !== Ql) {
          for (var e = c.actualDuration, L = c.selfBaseDuration, X = c.child; X !== null; )
            d = mZ(d, mZ(X.lanes, X.childLanes)), o |= X.subtreeFlags, o |= X.flags, e += X.actualDuration, L += X.treeBaseDuration, X = X.sibling;
          c.actualDuration = e, c.treeBaseDuration = L;
        } else
          for (var K = c.child; K !== null; )
            d = mZ(d, mZ(K.lanes, K.childLanes)), o |= K.subtreeFlags, o |= K.flags, K.return = c, K = K.sibling;
        c.subtreeFlags |= o;
      }
      return c.childLanes = d, b;
    }
    function og(c, b, d) {
      if (PH() && (b.mode & pZ) !== Ql && (b.flags & RZ) === Pl)
        return A0(b), Li(), b.flags |= Ns | jo | yb, !1;
      var o = wp(b);
      if (d !== null && d.dehydrated !== null)
        if (c === null) {
          if (!o)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (jH(b), Qc(b), (b.mode & rZ) !== Ql) {
            var e = d !== null;
            if (e) {
              var L = b.child;
              L !== null && (b.treeBaseDuration -= L.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Li(), (b.flags & RZ) === Pl && (b.memoizedState = null), b.flags |= SZ, Qc(b), (b.mode & rZ) !== Ql) {
            var X = d !== null;
            if (X) {
              var K = b.child;
              K !== null && (b.treeBaseDuration -= K.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return $0(), !0;
    }
    function XY(c, b, d) {
      var o = b.pendingProps;
      switch (st(b), b.tag) {
        case y:
        case C:
        case D:
        case n:
        case k:
        case V:
        case R:
        case U:
        case x:
        case z:
          return Qc(b), null;
        case p: {
          var e = b.type;
          return Zs(e) && Ip(b), Qc(b), null;
        }
        case h: {
          var L = b.stateNode;
          if (ti(b), Zt(b), rt(), L.pendingContext && (L.context = L.pendingContext, L.pendingContext = null), c === null || c.child === null) {
            var X = wp(b);
            if (X)
              Yi(b);
            else if (c !== null) {
              var K = c.memoizedState;
              // Check if this is a client root
              (!K.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (b.flags & Ns) !== Pl) && (b.flags |= CG, $0());
            }
          }
          return FX(c, b), Qc(b), null;
        }
        case t: {
          Mt(b);
          var Y = aR(), N = b.type;
          if (c !== null && b.stateNode != null)
            SY(c, b, N, o, Y), c.ref !== b.ref && hY(b);
          else {
            if (!o) {
              if (b.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Qc(b), null;
            }
            var H = kt(), q = wp(b);
            if (q)
              BH(b, Y, H) && Yi(b);
            else {
              var $ = UJ(N, o, Y, H, b);
              yY($, b, !1, !1), b.stateNode = $, rJ($, N, o, Y) && Yi(b);
            }
            b.ref !== null && hY(b);
          }
          return Qc(b), null;
        }
        case W: {
          var sl = o;
          if (c && b.stateNode != null) {
            var Gl = c.memoizedProps;
            tY(c, b, Gl, sl);
          } else {
            if (typeof sl != "string" && b.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var nl = aR(), Ul = kt(), Dl = wp(b);
            Dl ? DH(b) && Yi(b) : b.stateNode = NJ(sl, nl, Ul, b);
          }
          return Qc(b), null;
        }
        case w: {
          Ki(b);
          var fl = b.memoizedState;
          if (c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
            var hZ = og(c, b, fl);
            if (!hZ)
              return b.flags & yb ? b : null;
          }
          if ((b.flags & RZ) !== Pl)
            return b.lanes = d, (b.mode & rZ) !== Ql && bX(b), b;
          var eZ = fl !== null, bl = c !== null && c.memoizedState !== null;
          if (eZ !== bl && eZ) {
            var pl = b.child;
            if (pl.flags |= rG, (b.mode & pZ) !== Ql) {
              var ul = c === null && (b.memoizedProps.unstable_avoidThisFallback !== !0 || !Zl);
              ul || It(Uu.current, LR) ? ev() : $X();
            }
          }
          var Xl = b.updateQueue;
          if (Xl !== null && (b.flags |= SZ), Qc(b), (b.mode & rZ) !== Ql && eZ) {
            var Nl = b.child;
            Nl !== null && (b.treeBaseDuration -= Nl.treeBaseDuration);
          }
          return null;
        }
        case S:
          return ti(b), FX(c, b), c === null && kH(b.stateNode.containerInfo), Qc(b), null;
        case r:
          var Cl = b.type._context;
          return tt(Cl, b), Qc(b), null;
        case j: {
          var Al = b.type;
          return Zs(Al) && Ip(b), Qc(b), null;
        }
        case g: {
          Ki(b);
          var lZ = b.memoizedState;
          if (lZ === null)
            return Qc(b), null;
          var NZ = (b.flags & RZ) !== Pl, WZ = lZ.rendering;
          if (WZ === null)
            if (NZ)
              qe(lZ, !1);
            else {
              var nc = nv() && (c === null || (c.flags & RZ) === Pl);
              if (!nc)
                for (var VZ = b.child; VZ !== null; ) {
                  var mc = $p(VZ);
                  if (mc !== null) {
                    NZ = !0, b.flags |= RZ, qe(lZ, !1);
                    var ib = mc.updateQueue;
                    return ib !== null && (b.updateQueue = ib, b.flags |= SZ), b.subtreeFlags = Pl, Z3(b, d), Ed(b, Ut(Uu.current, ge)), b.child;
                  }
                  VZ = VZ.sibling;
                }
              lZ.tail !== null && zc() > TY() && (b.flags |= RZ, NZ = !0, qe(lZ, !1), b.lanes = t5);
            }
          else {
            if (!NZ) {
              var qc = $p(WZ);
              if (qc !== null) {
                b.flags |= RZ, NZ = !0;
                var qb = qc.updateQueue;
                if (qb !== null && (b.updateQueue = qb, b.flags |= SZ), qe(lZ, !0), lZ.tail === null && lZ.tailMode === "hidden" && !WZ.alternate && !Dc())
                  return Qc(b), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              zc() * 2 - lZ.renderingStartTime > TY() && d !== Db && (b.flags |= RZ, NZ = !0, qe(lZ, !1), b.lanes = t5);
            }
            if (lZ.isBackwards)
              WZ.sibling = b.child, b.child = WZ;
            else {
              var Kb = lZ.last;
              Kb !== null ? Kb.sibling = WZ : b.child = WZ, lZ.last = WZ;
            }
          }
          if (lZ.tail !== null) {
            var Wb = lZ.tail;
            lZ.rendering = Wb, lZ.tail = Wb.sibling, lZ.renderingStartTime = zc(), Wb.sibling = null;
            var ob = Uu.current;
            return NZ ? ob = Ut(ob, ge) : ob = Xi(ob), Ed(b, ob), Wb;
          }
          return Qc(b), null;
        }
        case A:
          break;
        case J:
        case F: {
          AX(b);
          var qs = b.memoizedState, Ni = qs !== null;
          if (c !== null) {
            var pa = c.memoizedState, is = pa !== null;
            is !== Ni && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !il && (b.flags |= rG);
          }
          return !Ni || (b.mode & pZ) === Ql ? Qc(b) : jb(ms, Db) && (Qc(b), b.subtreeFlags & (Xc | SZ) && (b.flags |= rG)), null;
        }
        case v:
          return null;
        case T:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + b.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function eg(c, b, d) {
      switch (st(b), b.tag) {
        case p: {
          var o = b.type;
          Zs(o) && Ip(b);
          var e = b.flags;
          return e & yb ? (b.flags = e & ~yb | RZ, (b.mode & rZ) !== Ql && bX(b), b) : null;
        }
        case h: {
          b.stateNode, ti(b), Zt(b), rt();
          var L = b.flags;
          return (L & yb) !== Pl && (L & RZ) === Pl ? (b.flags = L & ~yb | RZ, b) : null;
        }
        case t:
          return Mt(b), null;
        case w: {
          Ki(b);
          var X = b.memoizedState;
          if (X !== null && X.dehydrated !== null) {
            if (b.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Li();
          }
          var K = b.flags;
          return K & yb ? (b.flags = K & ~yb | RZ, (b.mode & rZ) !== Ql && bX(b), b) : null;
        }
        case g:
          return Ki(b), null;
        case S:
          return ti(b), null;
        case r:
          var Y = b.type._context;
          return tt(Y, b), null;
        case J:
        case F:
          return AX(b), null;
        case v:
          return null;
        default:
          return null;
      }
    }
    function KY(c, b, d) {
      switch (st(b), b.tag) {
        case p: {
          var o = b.type.childContextTypes;
          o != null && Ip(b);
          break;
        }
        case h: {
          b.stateNode, ti(b), Zt(b), rt();
          break;
        }
        case t: {
          Mt(b);
          break;
        }
        case S:
          ti(b);
          break;
        case w:
          Ki(b);
          break;
        case g:
          Ki(b);
          break;
        case r:
          var e = b.type._context;
          tt(e, b);
          break;
        case J:
        case F:
          AX(b);
          break;
      }
    }
    var WY = null;
    WY = /* @__PURE__ */ new Set();
    var KL = !1, Pc = !1, ag = typeof WeakSet == "function" ? WeakSet : Set, Hl = null, ki = null, Mi = null;
    function ng(c) {
      wy(null, function() {
        throw c;
      }), zy();
    }
    var pg = function(c, b) {
      if (b.props = c.memoizedProps, b.state = c.memoizedState, c.mode & rZ)
        try {
          ds(), b.componentWillUnmount();
        } finally {
          ss(c);
        }
      else
        b.componentWillUnmount();
    };
    function VY(c, b) {
      try {
        jd(Yc, c);
      } catch (d) {
        EZ(c, b, d);
      }
    }
    function NX(c, b, d) {
      try {
        pg(c, d);
      } catch (o) {
        EZ(c, b, o);
      }
    }
    function Lg(c, b, d) {
      try {
        d.componentDidMount();
      } catch (o) {
        EZ(c, b, o);
      }
    }
    function xY(c, b) {
      try {
        YY(c);
      } catch (d) {
        EZ(c, b, d);
      }
    }
    function Ii(c, b) {
      var d = c.ref;
      if (d !== null)
        if (typeof d == "function") {
          var o;
          try {
            if (kl && zl && c.mode & rZ)
              try {
                ds(), o = d(null);
              } finally {
                ss(c);
              }
            else
              o = d(null);
          } catch (e) {
            EZ(c, b, e);
          }
          typeof o == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", bZ(c));
        } else
          d.current = null;
    }
    function WL(c, b, d) {
      try {
        d();
      } catch (o) {
        EZ(c, b, o);
      }
    }
    var RY = !1;
    function hg(c, b) {
      MJ(c.containerInfo), Hl = b, yg();
      var d = RY;
      return RY = !1, d;
    }
    function yg() {
      for (; Hl !== null; ) {
        var c = Hl, b = c.child;
        (c.subtreeFlags & Ty) !== Pl && b !== null ? (b.return = c, Hl = b) : Sg();
      }
    }
    function Sg() {
      for (; Hl !== null; ) {
        var c = Hl;
        cc(c);
        try {
          tg(c);
        } catch (d) {
          EZ(c, c.return, d);
        }
        wc();
        var b = c.sibling;
        if (b !== null) {
          b.return = c.return, Hl = b;
          return;
        }
        Hl = c.return;
      }
    }
    function tg(c) {
      var b = c.alternate, d = c.flags;
      if ((d & CG) !== Pl) {
        switch (cc(c), c.tag) {
          case n:
          case k:
          case D:
            break;
          case p: {
            if (b !== null) {
              var o = b.memoizedProps, e = b.memoizedState, L = c.stateNode;
              c.type === c.elementType && !qG && (L.props !== c.memoizedProps && m("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bZ(c) || "instance"), L.state !== c.memoizedState && m("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bZ(c) || "instance"));
              var X = L.getSnapshotBeforeUpdate(c.elementType === c.type ? o : ru(c.type, o), e);
              {
                var K = WY;
                X === void 0 && !K.has(c.type) && (K.add(c.type), m("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", bZ(c)));
              }
              L.__reactInternalSnapshotBeforeUpdate = X;
            }
            break;
          }
          case h: {
            {
              var Y = c.stateNode;
              _J(Y.containerInfo);
            }
            break;
          }
          case t:
          case W:
          case S:
          case j:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        wc();
      }
    }
    function Nu(c, b, d) {
      var o = b.updateQueue, e = o !== null ? o.lastEffect : null;
      if (e !== null) {
        var L = e.next, X = L;
        do {
          if ((X.tag & c) === c) {
            var K = X.destroy;
            X.destroy = void 0, K !== void 0 && ((c & jc) !== Fb ? NN(b) : (c & Yc) !== Fb && p5(b), (c & cs) !== Fb && ea(!0), WL(b, d, K), (c & cs) !== Fb && ea(!1), (c & jc) !== Fb ? wN() : (c & Yc) !== Fb && L5());
          }
          X = X.next;
        } while (X !== L);
      }
    }
    function jd(c, b) {
      var d = b.updateQueue, o = d !== null ? d.lastEffect : null;
      if (o !== null) {
        var e = o.next, L = e;
        do {
          if ((L.tag & c) === c) {
            (c & jc) !== Fb ? rN(b) : (c & Yc) !== Fb && zN(b);
            var X = L.create;
            (c & cs) !== Fb && ea(!0), L.destroy = X(), (c & cs) !== Fb && ea(!1), (c & jc) !== Fb ? FN() : (c & Yc) !== Fb && JN();
            {
              var K = L.destroy;
              if (K !== void 0 && typeof K != "function") {
                var Y = void 0;
                (L.tag & Yc) !== Pl ? Y = "useLayoutEffect" : (L.tag & cs) !== Pl ? Y = "useInsertionEffect" : Y = "useEffect";
                var N = void 0;
                K === null ? N = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof K.then == "function" ? N = `

It looks like you wrote ` + Y + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + Y + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : N = " You returned: " + K, m("%s must not return anything besides a function, which is used for clean-up.%s", Y, N);
              }
            }
          }
          L = L.next;
        } while (L !== e);
      }
    }
    function Xg(c, b) {
      if ((b.flags & SZ) !== Pl)
        switch (b.tag) {
          case U: {
            var d = b.stateNode.passiveEffectDuration, o = b.memoizedProps, e = o.id, L = o.onPostCommit, X = TR(), K = b.alternate === null ? "mount" : "update";
            vR() && (K = "nested-update"), typeof L == "function" && L(e, K, d, X);
            var Y = b.return;
            l: for (; Y !== null; ) {
              switch (Y.tag) {
                case h:
                  var N = Y.stateNode;
                  N.passiveEffectDuration += d;
                  break l;
                case U:
                  var H = Y.stateNode;
                  H.passiveEffectDuration += d;
                  break l;
              }
              Y = Y.return;
            }
            break;
          }
        }
    }
    function Kg(c, b, d, o) {
      if ((d.flags & Qo) !== Pl)
        switch (d.tag) {
          case n:
          case k:
          case D: {
            if (!Pc)
              if (d.mode & rZ)
                try {
                  ds(), jd(Yc | Rc, d);
                } finally {
                  ss(d);
                }
              else
                jd(Yc | Rc, d);
            break;
          }
          case p: {
            var e = d.stateNode;
            if (d.flags & SZ && !Pc)
              if (b === null)
                if (d.type === d.elementType && !qG && (e.props !== d.memoizedProps && m("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bZ(d) || "instance"), e.state !== d.memoizedState && m("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bZ(d) || "instance")), d.mode & rZ)
                  try {
                    ds(), e.componentDidMount();
                  } finally {
                    ss(d);
                  }
                else
                  e.componentDidMount();
              else {
                var L = d.elementType === d.type ? b.memoizedProps : ru(d.type, b.memoizedProps), X = b.memoizedState;
                if (d.type === d.elementType && !qG && (e.props !== d.memoizedProps && m("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bZ(d) || "instance"), e.state !== d.memoizedState && m("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bZ(d) || "instance")), d.mode & rZ)
                  try {
                    ds(), e.componentDidUpdate(L, X, e.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    ss(d);
                  }
                else
                  e.componentDidUpdate(L, X, e.__reactInternalSnapshotBeforeUpdate);
              }
            var K = d.updateQueue;
            K !== null && (d.type === d.elementType && !qG && (e.props !== d.memoizedProps && m("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", bZ(d) || "instance"), e.state !== d.memoizedState && m("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", bZ(d) || "instance")), eR(d, K, e));
            break;
          }
          case h: {
            var Y = d.updateQueue;
            if (Y !== null) {
              var N = null;
              if (d.child !== null)
                switch (d.child.tag) {
                  case t:
                    N = d.child.stateNode;
                    break;
                  case p:
                    N = d.child.stateNode;
                    break;
                }
              eR(d, Y, N);
            }
            break;
          }
          case t: {
            var H = d.stateNode;
            if (b === null && d.flags & SZ) {
              var q = d.type, $ = d.memoizedProps;
              gJ(H, q, $);
            }
            break;
          }
          case W:
            break;
          case S:
            break;
          case U: {
            {
              var sl = d.memoizedProps, Gl = sl.onCommit, nl = sl.onRender, Ul = d.stateNode.effectDuration, Dl = TR(), fl = b === null ? "mount" : "update";
              vR() && (fl = "nested-update"), typeof nl == "function" && nl(d.memoizedProps.id, fl, d.actualDuration, d.treeBaseDuration, d.actualStartTime, Dl);
              {
                typeof Gl == "function" && Gl(d.memoizedProps.id, fl, Ul, Dl), Sv(d);
                var hZ = d.return;
                l: for (; hZ !== null; ) {
                  switch (hZ.tag) {
                    case h:
                      var eZ = hZ.stateNode;
                      eZ.effectDuration += Ul;
                      break l;
                    case U:
                      var bl = hZ.stateNode;
                      bl.effectDuration += Ul;
                      break l;
                  }
                  hZ = hZ.return;
                }
              }
            }
            break;
          }
          case w: {
            Ig(c, d);
            break;
          }
          case g:
          case j:
          case A:
          case J:
          case F:
          case T:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Pc || d.flags & Id && YY(d);
    }
    function Wg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          if (c.mode & rZ)
            try {
              ds(), VY(c, c.return);
            } finally {
              ss(c);
            }
          else
            VY(c, c.return);
          break;
        }
        case p: {
          var b = c.stateNode;
          typeof b.componentDidMount == "function" && Lg(c, c.return, b), xY(c, c.return);
          break;
        }
        case t: {
          xY(c, c.return);
          break;
        }
      }
    }
    function Vg(c, b) {
      for (var d = null, o = c; ; ) {
        if (o.tag === t) {
          if (d === null) {
            d = o;
            try {
              var e = o.stateNode;
              b ? OJ(e) : $J(o.stateNode, o.memoizedProps);
            } catch (X) {
              EZ(c, c.return, X);
            }
          }
        } else if (o.tag === W) {
          if (d === null)
            try {
              var L = o.stateNode;
              b ? AJ(L) : qJ(L, o.memoizedProps);
            } catch (X) {
              EZ(c, c.return, X);
            }
        } else if (!((o.tag === J || o.tag === F) && o.memoizedState !== null && o !== c)) {
          if (o.child !== null) {
            o.child.return = o, o = o.child;
            continue;
          }
        }
        if (o === c)
          return;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === c)
            return;
          d === o && (d = null), o = o.return;
        }
        d === o && (d = null), o.sibling.return = o.return, o = o.sibling;
      }
    }
    function YY(c) {
      var b = c.ref;
      if (b !== null) {
        var d = c.stateNode, o;
        switch (c.tag) {
          case t:
            o = d;
            break;
          default:
            o = d;
        }
        if (typeof b == "function") {
          var e;
          if (c.mode & rZ)
            try {
              ds(), e = b(o);
            } finally {
              ss(c);
            }
          else
            e = b(o);
          typeof e == "function" && m("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", bZ(c));
        } else
          b.hasOwnProperty("current") || m("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", bZ(c)), b.current = o;
      }
    }
    function xg(c) {
      var b = c.alternate;
      b !== null && (b.return = null), c.return = null;
    }
    function kY(c) {
      var b = c.alternate;
      b !== null && (c.alternate = null, kY(b));
      {
        if (c.child = null, c.deletions = null, c.sibling = null, c.tag === t) {
          var d = c.stateNode;
          d !== null && UH(d);
        }
        c.stateNode = null, c._debugOwner = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
      }
    }
    function Rg(c) {
      for (var b = c.return; b !== null; ) {
        if (MY(b))
          return b;
        b = b.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function MY(c) {
      return c.tag === t || c.tag === h || c.tag === S;
    }
    function IY(c) {
      var b = c;
      l: for (; ; ) {
        for (; b.sibling === null; ) {
          if (b.return === null || MY(b.return))
            return null;
          b = b.return;
        }
        for (b.sibling.return = b.return, b = b.sibling; b.tag !== t && b.tag !== W && b.tag !== E; ) {
          if (b.flags & Xc || b.child === null || b.tag === S)
            continue l;
          b.child.return = b, b = b.child;
        }
        if (!(b.flags & Xc))
          return b.stateNode;
      }
    }
    function Yg(c) {
      var b = Rg(c);
      switch (b.tag) {
        case t: {
          var d = b.stateNode;
          b.flags & Do && (C0(d), b.flags &= ~Do);
          var o = IY(c);
          zX(c, o, d);
          break;
        }
        case h:
        case S: {
          var e = b.stateNode.containerInfo, L = IY(c);
          wX(c, L, e);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function wX(c, b, d) {
      var o = c.tag, e = o === t || o === W;
      if (e) {
        var L = c.stateNode;
        b ? DJ(d, L, b) : EJ(d, L);
      } else if (o !== S) {
        var X = c.child;
        if (X !== null) {
          wX(X, b, d);
          for (var K = X.sibling; K !== null; )
            wX(K, b, d), K = K.sibling;
        }
      }
    }
    function zX(c, b, d) {
      var o = c.tag, e = o === t || o === W;
      if (e) {
        var L = c.stateNode;
        b ? BJ(d, L, b) : fJ(d, L);
      } else if (o !== S) {
        var X = c.child;
        if (X !== null) {
          zX(X, b, d);
          for (var K = X.sibling; K !== null; )
            zX(K, b, d), K = K.sibling;
        }
      }
    }
    var Oc = null, wu = !1;
    function kg(c, b, d) {
      {
        var o = b;
        l: for (; o !== null; ) {
          switch (o.tag) {
            case t: {
              Oc = o.stateNode, wu = !1;
              break l;
            }
            case h: {
              Oc = o.stateNode.containerInfo, wu = !0;
              break l;
            }
            case S: {
              Oc = o.stateNode.containerInfo, wu = !0;
              break l;
            }
          }
          o = o.return;
        }
        if (Oc === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        UY(c, b, d), Oc = null, wu = !1;
      }
      xg(d);
    }
    function Qd(c, b, d) {
      for (var o = d.child; o !== null; )
        UY(c, b, o), o = o.sibling;
    }
    function UY(c, b, d) {
      switch (MN(d), d.tag) {
        case t:
          Pc || Ii(d, b);
        case W: {
          {
            var o = Oc, e = wu;
            Oc = null, Qd(c, b, d), Oc = o, wu = e, Oc !== null && (wu ? QJ(Oc, d.stateNode) : jJ(Oc, d.stateNode));
          }
          return;
        }
        case E: {
          Oc !== null && (wu ? PJ(Oc, d.stateNode) : QS(Oc, d.stateNode));
          return;
        }
        case S: {
          {
            var L = Oc, X = wu;
            Oc = d.stateNode.containerInfo, wu = !0, Qd(c, b, d), Oc = L, wu = X;
          }
          return;
        }
        case n:
        case k:
        case z:
        case D: {
          if (!Pc) {
            var K = d.updateQueue;
            if (K !== null) {
              var Y = K.lastEffect;
              if (Y !== null) {
                var N = Y.next, H = N;
                do {
                  var q = H, $ = q.destroy, sl = q.tag;
                  $ !== void 0 && ((sl & cs) !== Fb ? WL(d, b, $) : (sl & Yc) !== Fb && (p5(d), d.mode & rZ ? (ds(), WL(d, b, $), ss(d)) : WL(d, b, $), L5())), H = H.next;
                } while (H !== N);
              }
            }
          }
          Qd(c, b, d);
          return;
        }
        case p: {
          if (!Pc) {
            Ii(d, b);
            var Gl = d.stateNode;
            typeof Gl.componentWillUnmount == "function" && NX(d, b, Gl);
          }
          Qd(c, b, d);
          return;
        }
        case A: {
          Qd(c, b, d);
          return;
        }
        case J: {
          if (
            // TODO: Remove this dead flag
            d.mode & pZ
          ) {
            var nl = Pc;
            Pc = nl || d.memoizedState !== null, Qd(c, b, d), Pc = nl;
          } else
            Qd(c, b, d);
          break;
        }
        default: {
          Qd(c, b, d);
          return;
        }
      }
    }
    function Mg(c) {
      c.memoizedState;
    }
    function Ig(c, b) {
      var d = b.memoizedState;
      if (d === null) {
        var o = b.alternate;
        if (o !== null) {
          var e = o.memoizedState;
          if (e !== null) {
            var L = e.dehydrated;
            L !== null && nH(L);
          }
        }
      }
    }
    function CY(c) {
      var b = c.updateQueue;
      if (b !== null) {
        c.updateQueue = null;
        var d = c.stateNode;
        d === null && (d = c.stateNode = new ag()), b.forEach(function(o) {
          var e = Rv.bind(null, c, o);
          if (!d.has(o)) {
            if (d.add(o), Ru)
              if (ki !== null && Mi !== null)
                oa(Mi, ki);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            o.then(e, e);
          }
        });
      }
    }
    function Ug(c, b, d) {
      ki = d, Mi = c, cc(b), rY(b, c), cc(b), ki = null, Mi = null;
    }
    function zu(c, b, d) {
      var o = b.deletions;
      if (o !== null)
        for (var e = 0; e < o.length; e++) {
          var L = o[e];
          try {
            kg(c, b, L);
          } catch (Y) {
            EZ(L, b, Y);
          }
        }
      var X = rn();
      if (b.subtreeFlags & fy)
        for (var K = b.child; K !== null; )
          cc(K), rY(K, c), K = K.sibling;
      cc(X);
    }
    function rY(c, b, d) {
      var o = c.alternate, e = c.flags;
      switch (c.tag) {
        case n:
        case k:
        case z:
        case D: {
          if (zu(b, c), Gs(c), e & SZ) {
            try {
              Nu(cs | Rc, c, c.return), jd(cs | Rc, c);
            } catch (Al) {
              EZ(c, c.return, Al);
            }
            if (c.mode & rZ) {
              try {
                ds(), Nu(Yc | Rc, c, c.return);
              } catch (Al) {
                EZ(c, c.return, Al);
              }
              ss(c);
            } else
              try {
                Nu(Yc | Rc, c, c.return);
              } catch (Al) {
                EZ(c, c.return, Al);
              }
          }
          return;
        }
        case p: {
          zu(b, c), Gs(c), e & Id && o !== null && Ii(o, o.return);
          return;
        }
        case t: {
          zu(b, c), Gs(c), e & Id && o !== null && Ii(o, o.return);
          {
            if (c.flags & Do) {
              var L = c.stateNode;
              try {
                C0(L);
              } catch (Al) {
                EZ(c, c.return, Al);
              }
            }
            if (e & SZ) {
              var X = c.stateNode;
              if (X != null) {
                var K = c.memoizedProps, Y = o !== null ? o.memoizedProps : K, N = c.type, H = c.updateQueue;
                if (c.updateQueue = null, H !== null)
                  try {
                    vJ(X, H, N, Y, K, c);
                  } catch (Al) {
                    EZ(c, c.return, Al);
                  }
              }
            }
          }
          return;
        }
        case W: {
          if (zu(b, c), Gs(c), e & SZ) {
            if (c.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var q = c.stateNode, $ = c.memoizedProps, sl = o !== null ? o.memoizedProps : $;
            try {
              TJ(q, sl, $);
            } catch (Al) {
              EZ(c, c.return, Al);
            }
          }
          return;
        }
        case h: {
          if (zu(b, c), Gs(c), e & SZ && o !== null) {
            var Gl = o.memoizedState;
            if (Gl.isDehydrated)
              try {
                aH(b.containerInfo);
              } catch (Al) {
                EZ(c, c.return, Al);
              }
          }
          return;
        }
        case S: {
          zu(b, c), Gs(c);
          return;
        }
        case w: {
          zu(b, c), Gs(c);
          var nl = c.child;
          if (nl.flags & rG) {
            var Ul = nl.stateNode, Dl = nl.memoizedState, fl = Dl !== null;
            if (Ul.isHidden = fl, fl) {
              var hZ = nl.alternate !== null && nl.alternate.memoizedState !== null;
              hZ || ov();
            }
          }
          if (e & SZ) {
            try {
              Mg(c);
            } catch (Al) {
              EZ(c, c.return, Al);
            }
            CY(c);
          }
          return;
        }
        case J: {
          var eZ = o !== null && o.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            c.mode & pZ
          ) {
            var bl = Pc;
            Pc = bl || eZ, zu(b, c), Pc = bl;
          } else
            zu(b, c);
          if (Gs(c), e & rG) {
            var pl = c.stateNode, ul = c.memoizedState, Xl = ul !== null, Nl = c;
            if (pl.isHidden = Xl, Xl && !eZ && (Nl.mode & pZ) !== Ql) {
              Hl = Nl;
              for (var Cl = Nl.child; Cl !== null; )
                Hl = Cl, rg(Cl), Cl = Cl.sibling;
            }
            Vg(Nl, Xl);
          }
          return;
        }
        case g: {
          zu(b, c), Gs(c), e & SZ && CY(c);
          return;
        }
        case A:
          return;
        default: {
          zu(b, c), Gs(c);
          return;
        }
      }
    }
    function Gs(c) {
      var b = c.flags;
      if (b & Xc) {
        try {
          Yg(c);
        } catch (d) {
          EZ(c, c.return, d);
        }
        c.flags &= ~Xc;
      }
      b & ws && (c.flags &= ~ws);
    }
    function Cg(c, b, d) {
      ki = d, Mi = b, Hl = c, FY(c, b, d), ki = null, Mi = null;
    }
    function FY(c, b, d) {
      for (var o = (c.mode & pZ) !== Ql; Hl !== null; ) {
        var e = Hl, L = e.child;
        if (e.tag === J && o) {
          var X = e.memoizedState !== null, K = X || KL;
          if (K) {
            JX(c, b, d);
            continue;
          } else {
            var Y = e.alternate, N = Y !== null && Y.memoizedState !== null, H = N || Pc, q = KL, $ = Pc;
            KL = K, Pc = H, Pc && !$ && (Hl = e, Fg(e));
            for (var sl = L; sl !== null; )
              Hl = sl, FY(
                sl,
                // New root; bubble back up to here and stop.
                b,
                d
              ), sl = sl.sibling;
            Hl = e, KL = q, Pc = $, JX(c, b, d);
            continue;
          }
        }
        (e.subtreeFlags & Qo) !== Pl && L !== null ? (L.return = e, Hl = L) : JX(c, b, d);
      }
    }
    function JX(c, b, d) {
      for (; Hl !== null; ) {
        var o = Hl;
        if ((o.flags & Qo) !== Pl) {
          var e = o.alternate;
          cc(o);
          try {
            Kg(b, e, o, d);
          } catch (X) {
            EZ(o, o.return, X);
          }
          wc();
        }
        if (o === c) {
          Hl = null;
          return;
        }
        var L = o.sibling;
        if (L !== null) {
          L.return = o.return, Hl = L;
          return;
        }
        Hl = o.return;
      }
    }
    function rg(c) {
      for (; Hl !== null; ) {
        var b = Hl, d = b.child;
        switch (b.tag) {
          case n:
          case k:
          case z:
          case D: {
            if (b.mode & rZ)
              try {
                ds(), Nu(Yc, b, b.return);
              } finally {
                ss(b);
              }
            else
              Nu(Yc, b, b.return);
            break;
          }
          case p: {
            Ii(b, b.return);
            var o = b.stateNode;
            typeof o.componentWillUnmount == "function" && NX(b, b.return, o);
            break;
          }
          case t: {
            Ii(b, b.return);
            break;
          }
          case J: {
            var e = b.memoizedState !== null;
            if (e) {
              NY(c);
              continue;
            }
            break;
          }
        }
        d !== null ? (d.return = b, Hl = d) : NY(c);
      }
    }
    function NY(c) {
      for (; Hl !== null; ) {
        var b = Hl;
        if (b === c) {
          Hl = null;
          return;
        }
        var d = b.sibling;
        if (d !== null) {
          d.return = b.return, Hl = d;
          return;
        }
        Hl = b.return;
      }
    }
    function Fg(c) {
      for (; Hl !== null; ) {
        var b = Hl, d = b.child;
        if (b.tag === J) {
          var o = b.memoizedState !== null;
          if (o) {
            wY(c);
            continue;
          }
        }
        d !== null ? (d.return = b, Hl = d) : wY(c);
      }
    }
    function wY(c) {
      for (; Hl !== null; ) {
        var b = Hl;
        cc(b);
        try {
          Wg(b);
        } catch (o) {
          EZ(b, b.return, o);
        }
        if (wc(), b === c) {
          Hl = null;
          return;
        }
        var d = b.sibling;
        if (d !== null) {
          d.return = b.return, Hl = d;
          return;
        }
        Hl = b.return;
      }
    }
    function Ng(c, b, d, o) {
      Hl = b, wg(b, c, d, o);
    }
    function wg(c, b, d, o) {
      for (; Hl !== null; ) {
        var e = Hl, L = e.child;
        (e.subtreeFlags & Om) !== Pl && L !== null ? (L.return = e, Hl = L) : zg(c, b, d, o);
      }
    }
    function zg(c, b, d, o) {
      for (; Hl !== null; ) {
        var e = Hl;
        if ((e.flags & xu) !== Pl) {
          cc(e);
          try {
            Jg(b, e, d, o);
          } catch (X) {
            EZ(e, e.return, X);
          }
          wc();
        }
        if (e === c) {
          Hl = null;
          return;
        }
        var L = e.sibling;
        if (L !== null) {
          L.return = e.return, Hl = L;
          return;
        }
        Hl = e.return;
      }
    }
    function Jg(c, b, d, o) {
      switch (b.tag) {
        case n:
        case k:
        case D: {
          if (b.mode & rZ) {
            cX();
            try {
              jd(jc | Rc, b);
            } finally {
              ZX(b);
            }
          } else
            jd(jc | Rc, b);
          break;
        }
      }
    }
    function Hg(c) {
      Hl = c, gg();
    }
    function gg() {
      for (; Hl !== null; ) {
        var c = Hl, b = c.child;
        if ((Hl.flags & UG) !== Pl) {
          var d = c.deletions;
          if (d !== null) {
            for (var o = 0; o < d.length; o++) {
              var e = d[o];
              Hl = e, fg(e, c);
            }
            {
              var L = c.alternate;
              if (L !== null) {
                var X = L.child;
                if (X !== null) {
                  L.child = null;
                  do {
                    var K = X.sibling;
                    X.sibling = null, X = K;
                  } while (X !== null);
                }
              }
            }
            Hl = c;
          }
        }
        (c.subtreeFlags & Om) !== Pl && b !== null ? (b.return = c, Hl = b) : vg();
      }
    }
    function vg() {
      for (; Hl !== null; ) {
        var c = Hl;
        (c.flags & xu) !== Pl && (cc(c), Tg(c), wc());
        var b = c.sibling;
        if (b !== null) {
          b.return = c.return, Hl = b;
          return;
        }
        Hl = c.return;
      }
    }
    function Tg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          c.mode & rZ ? (cX(), Nu(jc | Rc, c, c.return), ZX(c)) : Nu(jc | Rc, c, c.return);
          break;
        }
      }
    }
    function fg(c, b) {
      for (; Hl !== null; ) {
        var d = Hl;
        cc(d), Bg(d, b), wc();
        var o = d.child;
        o !== null ? (o.return = d, Hl = o) : Eg(c);
      }
    }
    function Eg(c) {
      for (; Hl !== null; ) {
        var b = Hl, d = b.sibling, o = b.return;
        if (kY(b), b === c) {
          Hl = null;
          return;
        }
        if (d !== null) {
          d.return = o, Hl = d;
          return;
        }
        Hl = o;
      }
    }
    function Bg(c, b) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          c.mode & rZ ? (cX(), Nu(jc, c, b), ZX(c)) : Nu(jc, c, b);
          break;
        }
      }
    }
    function Dg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          try {
            jd(Yc | Rc, c);
          } catch (d) {
            EZ(c, c.return, d);
          }
          break;
        }
        case p: {
          var b = c.stateNode;
          try {
            b.componentDidMount();
          } catch (d) {
            EZ(c, c.return, d);
          }
          break;
        }
      }
    }
    function jg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          try {
            jd(jc | Rc, c);
          } catch (b) {
            EZ(c, c.return, b);
          }
          break;
        }
      }
    }
    function Qg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D: {
          try {
            Nu(Yc | Rc, c, c.return);
          } catch (d) {
            EZ(c, c.return, d);
          }
          break;
        }
        case p: {
          var b = c.stateNode;
          typeof b.componentWillUnmount == "function" && NX(c, c.return, b);
          break;
        }
      }
    }
    function Pg(c) {
      switch (c.tag) {
        case n:
        case k:
        case D:
          try {
            Nu(jc | Rc, c, c.return);
          } catch (b) {
            EZ(c, c.return, b);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var _e = Symbol.for;
      _e("selector.component"), _e("selector.has_pseudo_class"), _e("selector.role"), _e("selector.test_id"), _e("selector.text");
    }
    var Og = [];
    function Ag() {
      Og.forEach(function(c) {
        return c();
      });
    }
    var $g = u.ReactCurrentActQueue;
    function qg(c) {
      {
        var b = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), d = typeof jest < "u";
        return d && b !== !1;
      }
    }
    function zY() {
      {
        var c = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !c && $g.current !== null && m("The current testing environment is not configured to support act(...)"), c;
      }
    }
    var _g = Math.ceil, HX = u.ReactCurrentDispatcher, gX = u.ReactCurrentOwner, Ac = u.ReactCurrentBatchConfig, Ju = u.ReactCurrentActQueue, Ic = (
      /*             */
      0
    ), JY = (
      /*               */
      1
    ), $c = (
      /*                */
      2
    ), ou = (
      /*                */
      4
    ), Ps = 0, la = 1, _G = 2, VL = 3, Za = 4, HY = 5, vX = 6, LZ = Ic, tb = null, bc = null, Uc = Sl, ms = Sl, TX = Jd(Sl), Cc = Ps, ca = null, xL = Sl, ba = Sl, RL = Sl, ua = null, Nb = null, fX = 0, gY = 500, vY = 1 / 0, lv = 500, Os = null;
    function sa() {
      vY = zc() + lv;
    }
    function TY() {
      return vY;
    }
    var YL = !1, EX = null, Ui = null, lm = !1, Pd = null, da = Sl, BX = [], DX = null, Zv = 50, Ga = 0, jX = null, QX = !1, kL = !1, cv = 50, Ci = 0, ML = null, ma = jZ, IL = Sl, fY = !1;
    function UL() {
      return tb;
    }
    function Xb() {
      return (LZ & ($c | ou)) !== Ic ? zc() : (ma !== jZ || (ma = zc()), ma);
    }
    function Od(c) {
      var b = c.mode;
      if ((b & pZ) === Ql)
        return ql;
      if ((LZ & $c) !== Ic && Uc !== Sl)
        return le(Uc);
      var d = $H() !== AH;
      if (d) {
        if (Ac.transition !== null) {
          var o = Ac.transition;
          o._updatedFibers || (o._updatedFibers = /* @__PURE__ */ new Set()), o._updatedFibers.add(c);
        }
        return IL === Hc && (IL = V5()), IL;
      }
      var e = Yu();
      if (e !== Hc)
        return e;
      var L = wJ();
      return L;
    }
    function bv(c) {
      var b = c.mode;
      return (b & pZ) === Ql ? ql : sw();
    }
    function rc(c, b, d, o) {
      kv(), fY && m("useInsertionEffect must not schedule updates."), QX && (kL = !0), Ze(c, d, o), (LZ & $c) !== Sl && c === tb ? Uv(b) : (Ru && Y5(c, b, d), Cv(b), c === tb && ((LZ & $c) === Ic && (ba = mZ(ba, d)), Cc === Za && Ad(c, Uc)), wb(c, o), d === ql && LZ === Ic && (b.mode & pZ) === Ql && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Ju.isBatchingLegacy && (sa(), f0()));
    }
    function uv(c, b, d) {
      var o = c.current;
      o.lanes = b, Ze(c, b, d), wb(c, d);
    }
    function sv(c) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (LZ & $c) !== Ic
      );
    }
    function wb(c, b) {
      var d = c.callbackNode;
      _N(c, b);
      var o = $n(c, c === tb ? Uc : Sl);
      if (o === Sl) {
        d !== null && uk(d), c.callbackNode = null, c.callbackPriority = Hc;
        return;
      }
      var e = HG(o), L = c.callbackPriority;
      if (L === e && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Ju.current !== null && d !== lK)) {
        d == null && L !== ql && m("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      d != null && uk(d);
      var X;
      if (e === ql)
        c.tag === Hd ? (Ju.isBatchingLegacy !== null && (Ju.didScheduleLegacyUpdate = !0), FH(DY.bind(null, c))) : T0(DY.bind(null, c)), Ju.current !== null ? Ju.current.push(gd) : JJ(function() {
          (LZ & ($c | ou)) === Ic && gd();
        }), X = null;
      else {
        var K;
        switch (I5(o)) {
          case Qb:
            K = Qn;
            break;
          case gs:
            K = Ey;
            break;
          case vs:
            K = wG;
            break;
          case lp:
            K = By;
            break;
          default:
            K = wG;
            break;
        }
        X = ZK(K, EY.bind(null, c));
      }
      c.callbackPriority = e, c.callbackNode = X;
    }
    function EY(c, b) {
      if (V3(), ma = jZ, IL = Sl, (LZ & ($c | ou)) !== Ic)
        throw new Error("Should not already be working.");
      var d = c.callbackNode, o = $s();
      if (o && c.callbackNode !== d)
        return null;
      var e = $n(c, c === tb ? Uc : Sl);
      if (e === Sl)
        return null;
      var L = !qn(c, e) && !uw(c, e) && !b, X = L ? Lv(c, e) : rL(c, e);
      if (X !== Ps) {
        if (X === _G) {
          var K = aS(c);
          K !== Sl && (e = K, X = PX(c, K));
        }
        if (X === la) {
          var Y = ca;
          throw Zm(c, Sl), Ad(c, e), wb(c, zc()), Y;
        }
        if (X === vX)
          Ad(c, e);
        else {
          var N = !qn(c, e), H = c.current.alternate;
          if (N && !Gv(H)) {
            if (X = rL(c, e), X === _G) {
              var q = aS(c);
              q !== Sl && (e = q, X = PX(c, q));
            }
            if (X === la) {
              var $ = ca;
              throw Zm(c, Sl), Ad(c, e), wb(c, zc()), $;
            }
          }
          c.finishedWork = H, c.finishedLanes = e, dv(c, X, e);
        }
      }
      return wb(c, zc()), c.callbackNode === d ? EY.bind(null, c) : null;
    }
    function PX(c, b) {
      var d = ua;
      if (Zp(c)) {
        var o = Zm(c, b);
        o.flags |= Ns, YH(c.containerInfo);
      }
      var e = rL(c, b);
      if (e !== _G) {
        var L = Nb;
        Nb = d, L !== null && BY(L);
      }
      return e;
    }
    function BY(c) {
      Nb === null ? Nb = c : Nb.push.apply(Nb, c);
    }
    function dv(c, b, d) {
      switch (b) {
        case Ps:
        case la:
          throw new Error("Root did not complete. This is a bug in React.");
        case _G: {
          cm(c, Nb, Os);
          break;
        }
        case VL: {
          if (Ad(c, d), K5(d) && // do not delay if we're inside an act() scope
          !sk()) {
            var o = fX + gY - zc();
            if (o > 10) {
              var e = $n(c, Sl);
              if (e !== Sl)
                break;
              var L = c.suspendedLanes;
              if (!Zi(L, d)) {
                Xb(), R5(c, L);
                break;
              }
              c.timeoutHandle = DS(cm.bind(null, c, Nb, Os), o);
              break;
            }
          }
          cm(c, Nb, Os);
          break;
        }
        case Za: {
          if (Ad(c, d), bw(d))
            break;
          if (!sk()) {
            var X = $N(c, d), K = X, Y = zc() - K, N = Yv(Y) - Y;
            if (N > 10) {
              c.timeoutHandle = DS(cm.bind(null, c, Nb, Os), N);
              break;
            }
          }
          cm(c, Nb, Os);
          break;
        }
        case HY: {
          cm(c, Nb, Os);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function Gv(c) {
      for (var b = c; ; ) {
        if (b.flags & Dn) {
          var d = b.updateQueue;
          if (d !== null) {
            var o = d.stores;
            if (o !== null)
              for (var e = 0; e < o.length; e++) {
                var L = o[e], X = L.getSnapshot, K = L.value;
                try {
                  if (!Ob(X(), K))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var Y = b.child;
        if (b.subtreeFlags & Dn && Y !== null) {
          Y.return = b, b = Y;
          continue;
        }
        if (b === c)
          return !0;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c)
            return !0;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
      return !0;
    }
    function Ad(c, b) {
      b = _n(b, RL), b = _n(b, ba), Gw(c, b);
    }
    function DY(c) {
      if (x3(), (LZ & ($c | ou)) !== Ic)
        throw new Error("Should not already be working.");
      $s();
      var b = $n(c, Sl);
      if (!jb(b, ql))
        return wb(c, zc()), null;
      var d = rL(c, b);
      if (c.tag !== Hd && d === _G) {
        var o = aS(c);
        o !== Sl && (b = o, d = PX(c, o));
      }
      if (d === la) {
        var e = ca;
        throw Zm(c, Sl), Ad(c, b), wb(c, zc()), e;
      }
      if (d === vX)
        throw new Error("Root did not complete. This is a bug in React.");
      var L = c.current.alternate;
      return c.finishedWork = L, c.finishedLanes = b, cm(c, Nb, Os), wb(c, zc()), null;
    }
    function mv(c, b) {
      b !== Sl && (hS(c, mZ(b, ql)), wb(c, zc()), (LZ & ($c | ou)) === Ic && (sa(), gd()));
    }
    function OX(c, b) {
      var d = LZ;
      LZ |= JY;
      try {
        return c(b);
      } finally {
        LZ = d, LZ === Ic && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Ju.isBatchingLegacy && (sa(), f0());
      }
    }
    function iv(c, b, d, o, e) {
      var L = Yu(), X = Ac.transition;
      try {
        return Ac.transition = null, gc(Qb), c(b, d, o, e);
      } finally {
        gc(L), Ac.transition = X, LZ === Ic && sa();
      }
    }
    function As(c) {
      Pd !== null && Pd.tag === Hd && (LZ & ($c | ou)) === Ic && $s();
      var b = LZ;
      LZ |= JY;
      var d = Ac.transition, o = Yu();
      try {
        return Ac.transition = null, gc(Qb), c ? c() : void 0;
      } finally {
        gc(o), Ac.transition = d, LZ = b, (LZ & ($c | ou)) === Ic && gd();
      }
    }
    function jY() {
      return (LZ & ($c | ou)) !== Ic;
    }
    function CL(c, b) {
      Gb(TX, ms, c), ms = mZ(ms, b);
    }
    function AX(c) {
      ms = TX.current, db(TX, c);
    }
    function Zm(c, b) {
      c.finishedWork = null, c.finishedLanes = Sl;
      var d = c.timeoutHandle;
      if (d !== jS && (c.timeoutHandle = jS, zJ(d)), bc !== null)
        for (var o = bc.return; o !== null; ) {
          var e = o.alternate;
          KY(e, o), o = o.return;
        }
      tb = c;
      var L = bm(c.current, null);
      return bc = L, Uc = ms = b, Cc = Ps, ca = null, xL = Sl, ba = Sl, RL = Sl, ua = null, Nb = null, u3(), Iu.discardPendingWarnings(), L;
    }
    function QY(c, b) {
      do {
        var d = bc;
        try {
          if (Tp(), yR(), wc(), gX.current = null, d === null || d.return === null) {
            Cc = la, ca = b, bc = null;
            return;
          }
          if (kl && d.mode & rZ && hL(d, !0), Rl)
            if ($m(), b !== null && typeof b == "object" && typeof b.then == "function") {
              var o = b;
              gN(d, o, Uc);
            } else
              HN(d, b, Uc);
          F3(c, d.return, d, b, Uc), $Y(d);
        } catch (e) {
          b = e, bc === d && d !== null ? (d = d.return, bc = d) : d = bc;
          continue;
        }
        return;
      } while (!0);
    }
    function PY() {
      var c = HX.current;
      return HX.current = eL, c === null ? eL : c;
    }
    function OY(c) {
      HX.current = c;
    }
    function ov() {
      fX = zc();
    }
    function ia(c) {
      xL = mZ(c, xL);
    }
    function ev() {
      Cc === Ps && (Cc = VL);
    }
    function $X() {
      (Cc === Ps || Cc === VL || Cc === _G) && (Cc = Za), tb !== null && (nS(xL) || nS(ba)) && Ad(tb, Uc);
    }
    function av(c) {
      Cc !== Za && (Cc = _G), ua === null ? ua = [c] : ua.push(c);
    }
    function nv() {
      return Cc === Ps;
    }
    function rL(c, b) {
      var d = LZ;
      LZ |= $c;
      var o = PY();
      if (tb !== c || Uc !== b) {
        if (Ru) {
          var e = c.memoizedUpdaters;
          e.size > 0 && (oa(c, Uc), e.clear()), k5(c, b);
        }
        Os = M5(), Zm(c, b);
      }
      h5(b);
      do
        try {
          pv();
          break;
        } catch (L) {
          QY(c, L);
        }
      while (!0);
      if (Tp(), LZ = d, OY(o), bc !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return y5(), tb = null, Uc = Sl, Cc;
    }
    function pv() {
      for (; bc !== null; )
        AY(bc);
    }
    function Lv(c, b) {
      var d = LZ;
      LZ |= $c;
      var o = PY();
      if (tb !== c || Uc !== b) {
        if (Ru) {
          var e = c.memoizedUpdaters;
          e.size > 0 && (oa(c, Uc), e.clear()), k5(c, b);
        }
        Os = M5(), sa(), Zm(c, b);
      }
      h5(b);
      do
        try {
          hv();
          break;
        } catch (L) {
          QY(c, L);
        }
      while (!0);
      return Tp(), OY(o), LZ = d, bc !== null ? (BN(), Ps) : (y5(), tb = null, Uc = Sl, Cc);
    }
    function hv() {
      for (; bc !== null && !SN(); )
        AY(bc);
    }
    function AY(c) {
      var b = c.alternate;
      cc(c);
      var d;
      (c.mode & rZ) !== Ql ? (lX(c), d = qX(b, c, ms), hL(c, !0)) : d = qX(b, c, ms), wc(), c.memoizedProps = c.pendingProps, d === null ? $Y(c) : bc = d, gX.current = null;
    }
    function $Y(c) {
      var b = c;
      do {
        var d = b.alternate, o = b.return;
        if ((b.flags & jo) === Pl) {
          cc(b);
          var e = void 0;
          if ((b.mode & rZ) === Ql ? e = XY(d, b, ms) : (lX(b), e = XY(d, b, ms), hL(b, !1)), wc(), e !== null) {
            bc = e;
            return;
          }
        } else {
          var L = eg(d, b);
          if (L !== null) {
            L.flags &= aN, bc = L;
            return;
          }
          if ((b.mode & rZ) !== Ql) {
            hL(b, !1);
            for (var X = b.actualDuration, K = b.child; K !== null; )
              X += K.actualDuration, K = K.sibling;
            b.actualDuration = X;
          }
          if (o !== null)
            o.flags |= jo, o.subtreeFlags = Pl, o.deletions = null;
          else {
            Cc = vX, bc = null;
            return;
          }
        }
        var Y = b.sibling;
        if (Y !== null) {
          bc = Y;
          return;
        }
        b = o, bc = b;
      } while (b !== null);
      Cc === Ps && (Cc = HY);
    }
    function cm(c, b, d) {
      var o = Yu(), e = Ac.transition;
      try {
        Ac.transition = null, gc(Qb), yv(c, b, d, o);
      } finally {
        Ac.transition = e, gc(o);
      }
      return null;
    }
    function yv(c, b, d, o) {
      do
        $s();
      while (Pd !== null);
      if (Mv(), (LZ & ($c | ou)) !== Ic)
        throw new Error("Should not already be working.");
      var e = c.finishedWork, L = c.finishedLanes;
      if (CN(L), e === null)
        return n5(), null;
      if (L === Sl && m("root.finishedLanes should not be empty during a commit. This is a bug in React."), c.finishedWork = null, c.finishedLanes = Sl, e === c.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      c.callbackNode = null, c.callbackPriority = Hc;
      var X = mZ(e.lanes, e.childLanes);
      mw(c, X), c === tb && (tb = null, bc = null, Uc = Sl), ((e.subtreeFlags & Om) !== Pl || (e.flags & Om) !== Pl) && (lm || (lm = !0, DX = d, ZK(wG, function() {
        return $s(), null;
      })));
      var K = (e.subtreeFlags & (Ty | fy | Qo | Om)) !== Pl, Y = (e.flags & (Ty | fy | Qo | Om)) !== Pl;
      if (K || Y) {
        var N = Ac.transition;
        Ac.transition = null;
        var H = Yu();
        gc(Qb);
        var q = LZ;
        LZ |= ou, gX.current = null, hg(c, e), fR(), Ug(c, e, L), IJ(c.containerInfo), c.current = e, vN(L), Cg(e, c, L), TN(), tN(), LZ = q, gc(H), Ac.transition = N;
      } else
        c.current = e, fR();
      var $ = lm;
      if (lm ? (lm = !1, Pd = c, da = L) : (Ci = 0, ML = null), X = c.pendingLanes, X === Sl && (Ui = null), $ || Zk(c.current, !1), YN(e.stateNode, o), Ru && c.memoizedUpdaters.clear(), Ag(), wb(c, zc()), b !== null)
        for (var sl = c.onRecoverableError, Gl = 0; Gl < b.length; Gl++) {
          var nl = b[Gl], Ul = nl.stack, Dl = nl.digest;
          sl(nl.value, {
            componentStack: Ul,
            digest: Dl
          });
        }
      if (YL) {
        YL = !1;
        var fl = EX;
        throw EX = null, fl;
      }
      return jb(da, ql) && c.tag !== Hd && $s(), X = c.pendingLanes, jb(X, ql) ? (W3(), c === jX ? Ga++ : (Ga = 0, jX = c)) : Ga = 0, gd(), n5(), null;
    }
    function $s() {
      if (Pd !== null) {
        var c = I5(da), b = aw(vs, c), d = Ac.transition, o = Yu();
        try {
          return Ac.transition = null, gc(b), tv();
        } finally {
          gc(o), Ac.transition = d;
        }
      }
      return !1;
    }
    function Sv(c) {
      BX.push(c), lm || (lm = !0, ZK(wG, function() {
        return $s(), null;
      }));
    }
    function tv() {
      if (Pd === null)
        return !1;
      var c = DX;
      DX = null;
      var b = Pd, d = da;
      if (Pd = null, da = Sl, (LZ & ($c | ou)) !== Ic)
        throw new Error("Cannot flush passive effects while already rendering.");
      QX = !0, kL = !1, fN(d);
      var o = LZ;
      LZ |= ou, Hg(b.current), Ng(b, b.current, d, c);
      {
        var e = BX;
        BX = [];
        for (var L = 0; L < e.length; L++) {
          var X = e[L];
          Xg(b, X);
        }
      }
      EN(), Zk(b.current, !0), LZ = o, gd(), kL ? b === ML ? Ci++ : (Ci = 0, ML = b) : Ci = 0, QX = !1, kL = !1, kN(b);
      {
        var K = b.current.stateNode;
        K.effectDuration = 0, K.passiveEffectDuration = 0;
      }
      return !0;
    }
    function qY(c) {
      return Ui !== null && Ui.has(c);
    }
    function Xv(c) {
      Ui === null ? Ui = /* @__PURE__ */ new Set([c]) : Ui.add(c);
    }
    function Kv(c) {
      YL || (YL = !0, EX = c);
    }
    var Wv = Kv;
    function _Y(c, b, d) {
      var o = $G(d, b), e = AR(c, o, ql), L = Td(c, e, ql), X = Xb();
      L !== null && (Ze(L, ql, X), wb(L, X));
    }
    function EZ(c, b, d) {
      if (ng(d), ea(!1), c.tag === h) {
        _Y(c, c, d);
        return;
      }
      var o = null;
      for (o = b; o !== null; ) {
        if (o.tag === h) {
          _Y(o, c, d);
          return;
        } else if (o.tag === p) {
          var e = o.type, L = o.stateNode;
          if (typeof e.getDerivedStateFromError == "function" || typeof L.componentDidCatch == "function" && !qY(L)) {
            var X = $G(d, c), K = SX(o, X, ql), Y = Td(o, K, ql), N = Xb();
            Y !== null && (Ze(Y, ql, N), wb(Y, N));
            return;
          }
        }
        o = o.return;
      }
      m(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, d);
    }
    function Vv(c, b, d) {
      var o = c.pingCache;
      o !== null && o.delete(b);
      var e = Xb();
      R5(c, d), rv(c), tb === c && Zi(Uc, d) && (Cc === Za || Cc === VL && K5(Uc) && zc() - fX < gY ? Zm(c, Sl) : RL = mZ(RL, d)), wb(c, e);
    }
    function lk(c, b) {
      b === Hc && (b = bv(c));
      var d = Xb(), o = rb(c, b);
      o !== null && (Ze(o, b, d), wb(o, d));
    }
    function xv(c) {
      var b = c.memoizedState, d = Hc;
      b !== null && (d = b.retryLane), lk(c, d);
    }
    function Rv(c, b) {
      var d = Hc, o;
      switch (c.tag) {
        case w:
          o = c.stateNode;
          var e = c.memoizedState;
          e !== null && (d = e.retryLane);
          break;
        case g:
          o = c.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      o !== null && o.delete(b), lk(c, d);
    }
    function Yv(c) {
      return c < 120 ? 120 : c < 480 ? 480 : c < 1080 ? 1080 : c < 1920 ? 1920 : c < 3e3 ? 3e3 : c < 4320 ? 4320 : _g(c / 1960) * 1960;
    }
    function kv() {
      if (Ga > Zv)
        throw Ga = 0, jX = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Ci > cv && (Ci = 0, ML = null, m("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function Mv() {
      Iu.flushLegacyContextWarning(), Iu.flushPendingUnsafeLifecycleWarnings();
    }
    function Zk(c, b) {
      cc(c), FL(c, zs, Qg), b && FL(c, jn, Pg), FL(c, zs, Dg), b && FL(c, jn, jg), wc();
    }
    function FL(c, b, d) {
      for (var o = c, e = null; o !== null; ) {
        var L = o.subtreeFlags & b;
        o !== e && o.child !== null && L !== Pl ? o = o.child : ((o.flags & b) !== Pl && d(o), o.sibling !== null ? o = o.sibling : o = e = o.return);
      }
    }
    var NL = null;
    function ck(c) {
      {
        if ((LZ & $c) !== Ic || !(c.mode & pZ))
          return;
        var b = c.tag;
        if (b !== y && b !== h && b !== p && b !== n && b !== k && b !== z && b !== D)
          return;
        var d = bZ(c) || "ReactComponent";
        if (NL !== null) {
          if (NL.has(d))
            return;
          NL.add(d);
        } else
          NL = /* @__PURE__ */ new Set([d]);
        var o = ub;
        try {
          cc(c), m("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          o ? cc(c) : wc();
        }
      }
    }
    var qX;
    {
      var Iv = null;
      qX = function(c, b, d) {
        var o = ok(Iv, b);
        try {
          return LY(c, b, d);
        } catch (L) {
          if (TH() || L !== null && typeof L == "object" && typeof L.then == "function")
            throw L;
          if (Tp(), yR(), KY(c, b), ok(b, o), b.mode & rZ && lX(b), wy(null, LY, null, c, b, d), mN()) {
            var e = zy();
            typeof e == "object" && e !== null && e._suppressLogging && typeof L == "object" && L !== null && !L._suppressLogging && (L._suppressLogging = !0);
          }
          throw L;
        }
      };
    }
    var bk = !1, _X;
    _X = /* @__PURE__ */ new Set();
    function Uv(c) {
      if (kG && !t3())
        switch (c.tag) {
          case n:
          case k:
          case D: {
            var b = bc && bZ(bc) || "Unknown", d = b;
            if (!_X.has(d)) {
              _X.add(d);
              var o = bZ(c) || "Unknown";
              m("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", o, b, b);
            }
            break;
          }
          case p: {
            bk || (m("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), bk = !0);
            break;
          }
        }
    }
    function oa(c, b) {
      if (Ru) {
        var d = c.memoizedUpdaters;
        d.forEach(function(o) {
          Y5(c, o, b);
        });
      }
    }
    var lK = {};
    function ZK(c, b) {
      {
        var d = Ju.current;
        return d !== null ? (d.push(b), lK) : a5(c, b);
      }
    }
    function uk(c) {
      if (c !== lK)
        return yN(c);
    }
    function sk() {
      return Ju.current !== null;
    }
    function Cv(c) {
      {
        if (c.mode & pZ) {
          if (!zY())
            return;
        } else if (!qg() || LZ !== Ic || c.tag !== n && c.tag !== k && c.tag !== D)
          return;
        if (Ju.current === null) {
          var b = ub;
          try {
            cc(c), m(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, bZ(c));
          } finally {
            b ? cc(c) : wc();
          }
        }
      }
    }
    function rv(c) {
      c.tag !== Hd && zY() && Ju.current === null && m(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function ea(c) {
      fY = c;
    }
    var eu = null, ri = null, Fv = function(c) {
      eu = c;
    };
    function Fi(c) {
      {
        if (eu === null)
          return c;
        var b = eu(c);
        return b === void 0 ? c : b.current;
      }
    }
    function cK(c) {
      return Fi(c);
    }
    function bK(c) {
      {
        if (eu === null)
          return c;
        var b = eu(c);
        if (b === void 0) {
          if (c != null && typeof c.render == "function") {
            var d = Fi(c.render);
            if (c.render !== d) {
              var o = {
                $$typeof: Kl,
                render: d
              };
              return c.displayName !== void 0 && (o.displayName = c.displayName), o;
            }
          }
          return c;
        }
        return b.current;
      }
    }
    function dk(c, b) {
      {
        if (eu === null)
          return !1;
        var d = c.elementType, o = b.type, e = !1, L = typeof o == "object" && o !== null ? o.$$typeof : null;
        switch (c.tag) {
          case p: {
            typeof o == "function" && (e = !0);
            break;
          }
          case n: {
            (typeof o == "function" || L === jl) && (e = !0);
            break;
          }
          case k: {
            (L === Kl || L === jl) && (e = !0);
            break;
          }
          case z:
          case D: {
            (L === aZ || L === jl) && (e = !0);
            break;
          }
          default:
            return !1;
        }
        if (e) {
          var X = eu(d);
          if (X !== void 0 && X === eu(o))
            return !0;
        }
        return !1;
      }
    }
    function Gk(c) {
      {
        if (eu === null || typeof WeakSet != "function")
          return;
        ri === null && (ri = /* @__PURE__ */ new WeakSet()), ri.add(c);
      }
    }
    var Nv = function(c, b) {
      {
        if (eu === null)
          return;
        var d = b.staleFamilies, o = b.updatedFamilies;
        $s(), As(function() {
          uK(c.current, o, d);
        });
      }
    }, wv = function(c, b) {
      {
        if (c.context !== Ab)
          return;
        $s(), As(function() {
          aa(b, c, null, null);
        });
      }
    };
    function uK(c, b, d) {
      {
        var o = c.alternate, e = c.child, L = c.sibling, X = c.tag, K = c.type, Y = null;
        switch (X) {
          case n:
          case D:
          case p:
            Y = K;
            break;
          case k:
            Y = K.render;
            break;
        }
        if (eu === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var N = !1, H = !1;
        if (Y !== null) {
          var q = eu(Y);
          q !== void 0 && (d.has(q) ? H = !0 : b.has(q) && (X === p ? H = !0 : N = !0));
        }
        if (ri !== null && (ri.has(c) || o !== null && ri.has(o)) && (H = !0), H && (c._debugNeedsRemount = !0), H || N) {
          var $ = rb(c, ql);
          $ !== null && rc($, c, ql, jZ);
        }
        e !== null && !H && uK(e, b, d), L !== null && uK(L, b, d);
      }
    }
    var zv = function(c, b) {
      {
        var d = /* @__PURE__ */ new Set(), o = new Set(b.map(function(e) {
          return e.current;
        }));
        return sK(c.current, o, d), d;
      }
    };
    function sK(c, b, d) {
      {
        var o = c.child, e = c.sibling, L = c.tag, X = c.type, K = null;
        switch (L) {
          case n:
          case D:
          case p:
            K = X;
            break;
          case k:
            K = X.render;
            break;
        }
        var Y = !1;
        K !== null && b.has(K) && (Y = !0), Y ? Jv(c, d) : o !== null && sK(o, b, d), e !== null && sK(e, b, d);
      }
    }
    function Jv(c, b) {
      {
        var d = Hv(c, b);
        if (d)
          return;
        for (var o = c; ; ) {
          switch (o.tag) {
            case t:
              b.add(o.stateNode);
              return;
            case S:
              b.add(o.stateNode.containerInfo);
              return;
            case h:
              b.add(o.stateNode.containerInfo);
              return;
          }
          if (o.return === null)
            throw new Error("Expected to reach root first.");
          o = o.return;
        }
      }
    }
    function Hv(c, b) {
      for (var d = c, o = !1; ; ) {
        if (d.tag === t)
          o = !0, b.add(d.stateNode);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === c)
          return o;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === c)
            return o;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !1;
    }
    var dK;
    {
      dK = !1;
      try {
        var mk = Object.preventExtensions({});
      } catch {
        dK = !0;
      }
    }
    function gv(c, b, d, o) {
      this.tag = c, this.key = d, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = b, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = o, this.flags = Pl, this.subtreeFlags = Pl, this.deletions = null, this.lanes = Sl, this.childLanes = Sl, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !dK && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var $b = function(c, b, d, o) {
      return new gv(c, b, d, o);
    };
    function GK(c) {
      var b = c.prototype;
      return !!(b && b.isReactComponent);
    }
    function vv(c) {
      return typeof c == "function" && !GK(c) && c.defaultProps === void 0;
    }
    function Tv(c) {
      if (typeof c == "function")
        return GK(c) ? p : n;
      if (c != null) {
        var b = c.$$typeof;
        if (b === Kl)
          return k;
        if (b === aZ)
          return z;
      }
      return y;
    }
    function bm(c, b) {
      var d = c.alternate;
      d === null ? (d = $b(c.tag, b, c.key, c.mode), d.elementType = c.elementType, d.type = c.type, d.stateNode = c.stateNode, d._debugSource = c._debugSource, d._debugOwner = c._debugOwner, d._debugHookTypes = c._debugHookTypes, d.alternate = c, c.alternate = d) : (d.pendingProps = b, d.type = c.type, d.flags = Pl, d.subtreeFlags = Pl, d.deletions = null, d.actualDuration = 0, d.actualStartTime = -1), d.flags = c.flags & Js, d.childLanes = c.childLanes, d.lanes = c.lanes, d.child = c.child, d.memoizedProps = c.memoizedProps, d.memoizedState = c.memoizedState, d.updateQueue = c.updateQueue;
      var o = c.dependencies;
      switch (d.dependencies = o === null ? null : {
        lanes: o.lanes,
        firstContext: o.firstContext
      }, d.sibling = c.sibling, d.index = c.index, d.ref = c.ref, d.selfBaseDuration = c.selfBaseDuration, d.treeBaseDuration = c.treeBaseDuration, d._debugNeedsRemount = c._debugNeedsRemount, d.tag) {
        case y:
        case n:
        case D:
          d.type = Fi(c.type);
          break;
        case p:
          d.type = cK(c.type);
          break;
        case k:
          d.type = bK(c.type);
          break;
      }
      return d;
    }
    function fv(c, b) {
      c.flags &= Js | Xc;
      var d = c.alternate;
      if (d === null)
        c.childLanes = Sl, c.lanes = b, c.child = null, c.subtreeFlags = Pl, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null, c.selfBaseDuration = 0, c.treeBaseDuration = 0;
      else {
        c.childLanes = d.childLanes, c.lanes = d.lanes, c.child = d.child, c.subtreeFlags = Pl, c.deletions = null, c.memoizedProps = d.memoizedProps, c.memoizedState = d.memoizedState, c.updateQueue = d.updateQueue, c.type = d.type;
        var o = d.dependencies;
        c.dependencies = o === null ? null : {
          lanes: o.lanes,
          firstContext: o.firstContext
        }, c.selfBaseDuration = d.selfBaseDuration, c.treeBaseDuration = d.treeBaseDuration;
      }
      return c;
    }
    function Ev(c, b, d) {
      var o;
      return c === Cp ? (o = pZ, b === !0 && (o |= Gc, o |= qu)) : o = Ql, Ru && (o |= rZ), $b(h, null, null, o);
    }
    function mK(c, b, d, o, e, L) {
      var X = y, K = c;
      if (typeof c == "function")
        GK(c) ? (X = p, K = cK(K)) : K = Fi(K);
      else if (typeof c == "string")
        X = t;
      else
        l: switch (c) {
          case bu:
            return $d(d.children, e, L, b);
          case Ms:
            X = R, e |= Gc, (e & pZ) !== Ql && (e |= qu);
            break;
          case Pu:
            return Bv(d, e, L, b);
          case Bl:
            return Dv(d, e, L, b);
          case oZ:
            return jv(d, e, L, b);
          case JZ:
            return ik(d, e, L, b);
          case DZ:
          case dZ:
          case xc:
          case uu:
          case ac:
          default: {
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case P:
                  X = r;
                  break l;
                case yl:
                  X = x;
                  break l;
                case Kl:
                  X = k, K = bK(K);
                  break l;
                case aZ:
                  X = z;
                  break l;
                case jl:
                  X = C, K = null;
                  break l;
              }
            var Y = "";
            {
              (c === void 0 || typeof c == "object" && c !== null && Object.keys(c).length === 0) && (Y += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var N = o ? bZ(o) : null;
              N && (Y += `

Check the render method of \`` + N + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (c == null ? c : typeof c) + "." + Y));
          }
        }
      var H = $b(X, d, b, e);
      return H.elementType = c, H.type = K, H.lanes = L, H._debugOwner = o, H;
    }
    function iK(c, b, d) {
      var o = null;
      o = c._owner;
      var e = c.type, L = c.key, X = c.props, K = mK(e, L, X, o, b, d);
      return K._debugSource = c._source, K._debugOwner = c._owner, K;
    }
    function $d(c, b, d, o) {
      var e = $b(V, c, o, b);
      return e.lanes = d, e;
    }
    function Bv(c, b, d, o) {
      typeof c.id != "string" && m('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof c.id);
      var e = $b(U, c, o, b | rZ);
      return e.elementType = Pu, e.lanes = d, e.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, e;
    }
    function Dv(c, b, d, o) {
      var e = $b(w, c, o, b);
      return e.elementType = Bl, e.lanes = d, e;
    }
    function jv(c, b, d, o) {
      var e = $b(g, c, o, b);
      return e.elementType = oZ, e.lanes = d, e;
    }
    function ik(c, b, d, o) {
      var e = $b(J, c, o, b);
      e.elementType = JZ, e.lanes = d;
      var L = {
        isHidden: !1
      };
      return e.stateNode = L, e;
    }
    function oK(c, b, d) {
      var o = $b(W, c, null, b);
      return o.lanes = d, o;
    }
    function Qv() {
      var c = $b(t, null, null, Ql);
      return c.elementType = "DELETED", c;
    }
    function Pv(c) {
      var b = $b(E, null, null, Ql);
      return b.stateNode = c, b;
    }
    function eK(c, b, d) {
      var o = c.children !== null ? c.children : [], e = $b(S, o, c.key, b);
      return e.lanes = d, e.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: c.implementation
      }, e;
    }
    function ok(c, b) {
      return c === null && (c = $b(y, null, null, Ql)), c.tag = b.tag, c.key = b.key, c.elementType = b.elementType, c.type = b.type, c.stateNode = b.stateNode, c.return = b.return, c.child = b.child, c.sibling = b.sibling, c.index = b.index, c.ref = b.ref, c.pendingProps = b.pendingProps, c.memoizedProps = b.memoizedProps, c.updateQueue = b.updateQueue, c.memoizedState = b.memoizedState, c.dependencies = b.dependencies, c.mode = b.mode, c.flags = b.flags, c.subtreeFlags = b.subtreeFlags, c.deletions = b.deletions, c.lanes = b.lanes, c.childLanes = b.childLanes, c.alternate = b.alternate, c.actualDuration = b.actualDuration, c.actualStartTime = b.actualStartTime, c.selfBaseDuration = b.selfBaseDuration, c.treeBaseDuration = b.treeBaseDuration, c._debugSource = b._debugSource, c._debugOwner = b._debugOwner, c._debugNeedsRemount = b._debugNeedsRemount, c._debugHookTypes = b._debugHookTypes, c;
    }
    function Ov(c, b, d, o, e) {
      this.tag = b, this.containerInfo = c, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = jS, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = Hc, this.eventTimes = LS(Sl), this.expirationTimes = LS(jZ), this.pendingLanes = Sl, this.suspendedLanes = Sl, this.pingedLanes = Sl, this.expiredLanes = Sl, this.mutableReadLanes = Sl, this.finishedLanes = Sl, this.entangledLanes = Sl, this.entanglements = LS(Sl), this.identifierPrefix = o, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var L = this.pendingUpdatersLaneMap = [], X = 0; X < jy; X++)
          L.push(/* @__PURE__ */ new Set());
      }
      switch (b) {
        case Cp:
          this._debugRootType = d ? "hydrateRoot()" : "createRoot()";
          break;
        case Hd:
          this._debugRootType = d ? "hydrate()" : "render()";
          break;
      }
    }
    function ek(c, b, d, o, e, L, X, K, Y, N) {
      var H = new Ov(c, b, d, K, Y), q = Ev(b, L);
      H.current = q, q.stateNode = H;
      {
        var $ = {
          element: o,
          isDehydrated: d,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        q.memoizedState = $;
      }
      return xt(q), H;
    }
    var aK = "18.3.1";
    function Av(c, b, d) {
      var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Zb(o), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: Eb,
        key: o == null ? null : "" + o,
        children: c,
        containerInfo: b,
        implementation: d
      };
    }
    var nK, pK;
    nK = !1, pK = {};
    function ak(c) {
      if (!c)
        return Ab;
      var b = Qm(c), d = rH(b);
      if (b.tag === p) {
        var o = b.type;
        if (Zs(o))
          return g0(b, o, d);
      }
      return d;
    }
    function $v(c, b) {
      {
        var d = Qm(c);
        if (d === void 0) {
          if (typeof c.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var o = Object.keys(c).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + o);
        }
        var e = i5(d);
        if (e === null)
          return null;
        if (e.mode & Gc) {
          var L = bZ(d) || "Component";
          if (!pK[L]) {
            pK[L] = !0;
            var X = ub;
            try {
              cc(e), d.mode & Gc ? m("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", b, b, L) : m("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", b, b, L);
            } finally {
              X ? cc(X) : wc();
            }
          }
        }
        return e.stateNode;
      }
    }
    function nk(c, b, d, o, e, L, X, K) {
      var Y = !1, N = null;
      return ek(c, b, Y, N, d, o, e, L, X);
    }
    function pk(c, b, d, o, e, L, X, K, Y, N) {
      var H = !0, q = ek(d, o, H, c, e, L, X, K, Y);
      q.context = ak(null);
      var $ = q.current, sl = Xb(), Gl = Od($), nl = js(sl, Gl);
      return nl.callback = b ?? null, Td($, nl, Gl), uv(q, Gl, sl), q;
    }
    function aa(c, b, d, o) {
      RN(b, c);
      var e = b.current, L = Xb(), X = Od(e);
      DN(X);
      var K = ak(d);
      b.context === null ? b.context = K : b.pendingContext = K, kG && ub !== null && !nK && (nK = !0, m(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, bZ(ub) || "Unknown"));
      var Y = js(L, X);
      Y.payload = {
        element: c
      }, o = o === void 0 ? null : o, o !== null && (typeof o != "function" && m("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o), Y.callback = o);
      var N = Td(e, Y, X);
      return N !== null && (rc(N, e, X, L), jp(N, e, X)), X;
    }
    function wL(c) {
      var b = c.current;
      if (!b.child)
        return null;
      switch (b.child.tag) {
        case t:
          return b.child.stateNode;
        default:
          return b.child.stateNode;
      }
    }
    function qv(c) {
      switch (c.tag) {
        case h: {
          var b = c.stateNode;
          if (Zp(b)) {
            var d = lw(b);
            mv(b, d);
          }
          break;
        }
        case w: {
          As(function() {
            var e = rb(c, ql);
            if (e !== null) {
              var L = Xb();
              rc(e, c, ql, L);
            }
          });
          var o = ql;
          LK(c, o);
          break;
        }
      }
    }
    function Lk(c, b) {
      var d = c.memoizedState;
      d !== null && d.dehydrated !== null && (d.retryLane = dw(d.retryLane, b));
    }
    function LK(c, b) {
      Lk(c, b);
      var d = c.alternate;
      d && Lk(d, b);
    }
    function _v(c) {
      if (c.tag === w) {
        var b = $o, d = rb(c, b);
        if (d !== null) {
          var o = Xb();
          rc(d, c, b, o);
        }
        LK(c, b);
      }
    }
    function lT(c) {
      if (c.tag === w) {
        var b = Od(c), d = rb(c, b);
        if (d !== null) {
          var o = Xb();
          rc(d, c, b, o);
        }
        LK(c, b);
      }
    }
    function hk(c) {
      var b = hN(c);
      return b === null ? null : b.stateNode;
    }
    var yk = function(c) {
      return null;
    };
    function ZT(c) {
      return yk(c);
    }
    var Sk = function(c) {
      return !1;
    };
    function cT(c) {
      return Sk(c);
    }
    var tk = null, Xk = null, Kk = null, Wk = null, Vk = null, xk = null, Rk = null, Yk = null, kk = null;
    {
      var Mk = function(c, b, d) {
        var o = b[d], e = xZ(c) ? c.slice() : GZ({}, c);
        return d + 1 === b.length ? (xZ(e) ? e.splice(o, 1) : delete e[o], e) : (e[o] = Mk(c[o], b, d + 1), e);
      }, Ik = function(c, b) {
        return Mk(c, b, 0);
      }, Uk = function(c, b, d, o) {
        var e = b[o], L = xZ(c) ? c.slice() : GZ({}, c);
        if (o + 1 === b.length) {
          var X = d[o];
          L[X] = L[e], xZ(L) ? L.splice(e, 1) : delete L[e];
        } else
          L[e] = Uk(
            // $FlowFixMe number or string is fine here
            c[e],
            b,
            d,
            o + 1
          );
        return L;
      }, Ck = function(c, b, d) {
        if (b.length !== d.length) {
          i("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var o = 0; o < d.length - 1; o++)
            if (b[o] !== d[o]) {
              i("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return Uk(c, b, d, 0);
      }, rk = function(c, b, d, o) {
        if (d >= b.length)
          return o;
        var e = b[d], L = xZ(c) ? c.slice() : GZ({}, c);
        return L[e] = rk(c[e], b, d + 1, o), L;
      }, Fk = function(c, b, d) {
        return rk(c, b, 0, d);
      }, hK = function(c, b) {
        for (var d = c.memoizedState; d !== null && b > 0; )
          d = d.next, b--;
        return d;
      };
      tk = function(c, b, d, o) {
        var e = hK(c, b);
        if (e !== null) {
          var L = Fk(e.memoizedState, d, o);
          e.memoizedState = L, e.baseState = L, c.memoizedProps = GZ({}, c.memoizedProps);
          var X = rb(c, ql);
          X !== null && rc(X, c, ql, jZ);
        }
      }, Xk = function(c, b, d) {
        var o = hK(c, b);
        if (o !== null) {
          var e = Ik(o.memoizedState, d);
          o.memoizedState = e, o.baseState = e, c.memoizedProps = GZ({}, c.memoizedProps);
          var L = rb(c, ql);
          L !== null && rc(L, c, ql, jZ);
        }
      }, Kk = function(c, b, d, o) {
        var e = hK(c, b);
        if (e !== null) {
          var L = Ck(e.memoizedState, d, o);
          e.memoizedState = L, e.baseState = L, c.memoizedProps = GZ({}, c.memoizedProps);
          var X = rb(c, ql);
          X !== null && rc(X, c, ql, jZ);
        }
      }, Wk = function(c, b, d) {
        c.pendingProps = Fk(c.memoizedProps, b, d), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var o = rb(c, ql);
        o !== null && rc(o, c, ql, jZ);
      }, Vk = function(c, b) {
        c.pendingProps = Ik(c.memoizedProps, b), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var d = rb(c, ql);
        d !== null && rc(d, c, ql, jZ);
      }, xk = function(c, b, d) {
        c.pendingProps = Ck(c.memoizedProps, b, d), c.alternate && (c.alternate.pendingProps = c.pendingProps);
        var o = rb(c, ql);
        o !== null && rc(o, c, ql, jZ);
      }, Rk = function(c) {
        var b = rb(c, ql);
        b !== null && rc(b, c, ql, jZ);
      }, Yk = function(c) {
        yk = c;
      }, kk = function(c) {
        Sk = c;
      };
    }
    function bT(c) {
      var b = i5(c);
      return b === null ? null : b.stateNode;
    }
    function uT(c) {
      return null;
    }
    function sT() {
      return ub;
    }
    function dT(c) {
      var b = c.findFiberByHostInstance, d = u.ReactCurrentDispatcher;
      return xN({
        bundleType: c.bundleType,
        version: c.version,
        rendererPackageName: c.rendererPackageName,
        rendererConfig: c.rendererConfig,
        overrideHookState: tk,
        overrideHookStateDeletePath: Xk,
        overrideHookStateRenamePath: Kk,
        overrideProps: Wk,
        overridePropsDeletePath: Vk,
        overridePropsRenamePath: xk,
        setErrorHandler: Yk,
        setSuspenseHandler: kk,
        scheduleUpdate: Rk,
        currentDispatcherRef: d,
        findHostInstanceByFiber: bT,
        findFiberByHostInstance: b || uT,
        // React Refresh
        findHostInstancesForRefresh: zv,
        scheduleRefresh: Nv,
        scheduleRoot: wv,
        setRefreshHandler: Fv,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: sT,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: aK
      });
    }
    var Nk = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(c) {
      console.error(c);
    };
    function yK(c) {
      this._internalRoot = c;
    }
    zL.prototype.render = yK.prototype.render = function(c) {
      var b = this._internalRoot;
      if (b === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? m("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : JL(arguments[1]) ? m("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && m("You passed a second argument to root.render(...) but it only accepts one argument.");
        var d = b.containerInfo;
        if (d.nodeType !== tc) {
          var o = hk(b.current);
          o && o.parentNode !== d && m("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      aa(c, b, null, null);
    }, zL.prototype.unmount = yK.prototype.unmount = function() {
      typeof arguments[0] == "function" && m("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var c = this._internalRoot;
      if (c !== null) {
        this._internalRoot = null;
        var b = c.containerInfo;
        jY() && m("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), As(function() {
          aa(null, c, null, null);
        }), N0(b);
      }
    };
    function GT(c, b) {
      if (!JL(c))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      wk(c);
      var d = !1, o = !1, e = "", L = Nk;
      b != null && (b.hydrate ? i("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof b == "object" && b !== null && b.$$typeof === fb && m(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), b.unstable_strictMode === !0 && (d = !0), b.identifierPrefix !== void 0 && (e = b.identifierPrefix), b.onRecoverableError !== void 0 && (L = b.onRecoverableError), b.transitionCallbacks !== void 0 && b.transitionCallbacks);
      var X = nk(c, Cp, null, d, o, e, L);
      xp(X.current, c);
      var K = c.nodeType === tc ? c.parentNode : c;
      return Se(K), new yK(X);
    }
    function zL(c) {
      this._internalRoot = c;
    }
    function mT(c) {
      c && Vw(c);
    }
    zL.prototype.unstable_scheduleHydration = mT;
    function iT(c, b, d) {
      if (!JL(c))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      wk(c), b === void 0 && m("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var o = d ?? null, e = d != null && d.hydratedSources || null, L = !1, X = !1, K = "", Y = Nk;
      d != null && (d.unstable_strictMode === !0 && (L = !0), d.identifierPrefix !== void 0 && (K = d.identifierPrefix), d.onRecoverableError !== void 0 && (Y = d.onRecoverableError));
      var N = pk(b, null, c, Cp, o, L, X, K, Y);
      if (xp(N.current, c), Se(c), e)
        for (var H = 0; H < e.length; H++) {
          var q = e[H];
          n3(N, q);
        }
      return new zL(N);
    }
    function JL(c) {
      return !!(c && (c.nodeType === Ub || c.nodeType === Fs || c.nodeType === xy || !ol));
    }
    function na(c) {
      return !!(c && (c.nodeType === Ub || c.nodeType === Fs || c.nodeType === xy || c.nodeType === tc && c.nodeValue === " react-mount-point-unstable "));
    }
    function wk(c) {
      c.nodeType === Ub && c.tagName && c.tagName.toUpperCase() === "BODY" && m("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Ie(c) && (c._reactRootContainer ? m("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : m("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var oT = u.ReactCurrentOwner, zk;
    zk = function(c) {
      if (c._reactRootContainer && c.nodeType !== tc) {
        var b = hk(c._reactRootContainer.current);
        b && b.parentNode !== c && m("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var d = !!c._reactRootContainer, o = SK(c), e = !!(o && zd(o));
      e && !d && m("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), c.nodeType === Ub && c.tagName && c.tagName.toUpperCase() === "BODY" && m("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function SK(c) {
      return c ? c.nodeType === Fs ? c.documentElement : c.firstChild : null;
    }
    function Jk() {
    }
    function eT(c, b, d, o, e) {
      if (e) {
        if (typeof o == "function") {
          var L = o;
          o = function() {
            var $ = wL(X);
            L.call($);
          };
        }
        var X = pk(
          b,
          o,
          c,
          Hd,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Jk
        );
        c._reactRootContainer = X, xp(X.current, c);
        var K = c.nodeType === tc ? c.parentNode : c;
        return Se(K), As(), X;
      } else {
        for (var Y; Y = c.lastChild; )
          c.removeChild(Y);
        if (typeof o == "function") {
          var N = o;
          o = function() {
            var $ = wL(H);
            N.call($);
          };
        }
        var H = nk(
          c,
          Hd,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          Jk
        );
        c._reactRootContainer = H, xp(H.current, c);
        var q = c.nodeType === tc ? c.parentNode : c;
        return Se(q), As(function() {
          aa(b, H, d, o);
        }), H;
      }
    }
    function aT(c, b) {
      c !== null && typeof c != "function" && m("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", b, c);
    }
    function HL(c, b, d, o, e) {
      zk(d), aT(e === void 0 ? null : e, "render");
      var L = d._reactRootContainer, X;
      if (!L)
        X = eT(d, b, c, e, o);
      else {
        if (X = L, typeof e == "function") {
          var K = e;
          e = function() {
            var Y = wL(X);
            K.call(Y);
          };
        }
        aa(b, X, c, e);
      }
      return wL(X);
    }
    var Hk = !1;
    function nT(c) {
      {
        Hk || (Hk = !0, m("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var b = oT.current;
        if (b !== null && b.stateNode !== null) {
          var d = b.stateNode._warnedAboutRefsInRender;
          d || m("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", tZ(b.type) || "A component"), b.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return c == null ? null : c.nodeType === Ub ? c : $v(c, "findDOMNode");
    }
    function pT(c, b, d) {
      if (m("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !na(b))
        throw new Error("Target container is not a DOM element.");
      {
        var o = Ie(b) && b._reactRootContainer === void 0;
        o && m("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return HL(null, c, b, !0, d);
    }
    function LT(c, b, d) {
      if (m("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !na(b))
        throw new Error("Target container is not a DOM element.");
      {
        var o = Ie(b) && b._reactRootContainer === void 0;
        o && m("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return HL(null, c, b, !1, d);
    }
    function hT(c, b, d, o) {
      if (m("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !na(d))
        throw new Error("Target container is not a DOM element.");
      if (c == null || !iN(c))
        throw new Error("parentComponent must be a valid React Component");
      return HL(c, b, d, !1, o);
    }
    var gk = !1;
    function yT(c) {
      if (gk || (gk = !0, m("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !na(c))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var b = Ie(c) && c._reactRootContainer === void 0;
        b && m("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (c._reactRootContainer) {
        {
          var d = SK(c), o = d && !zd(d);
          o && m("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return As(function() {
          HL(null, null, c, !1, function() {
            c._reactRootContainer = null, N0(c);
          });
        }), !0;
      } else {
        {
          var e = SK(c), L = !!(e && zd(e)), X = c.nodeType === Ub && na(c.parentNode) && !!c.parentNode._reactRootContainer;
          L && m("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", X ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    nw(qv), Lw(_v), hw(lT), yw(Yu), Sw(ow), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && m("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), qF(tJ), ZN(OX, iv, As);
    function ST(c, b) {
      var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!JL(b))
        throw new Error("Target container is not a DOM element.");
      return Av(c, b, null, d);
    }
    function tT(c, b, d, o) {
      return hT(c, b, d, o);
    }
    var tK = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [zd, oi, Rp, $x, qx, OX]
    };
    function XT(c, b) {
      return tK.usingClientEntryPoint || m('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), GT(c, b);
    }
    function KT(c, b, d) {
      return tK.usingClientEntryPoint || m('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), iT(c, b, d);
    }
    function WT(c) {
      return jY() && m("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), As(c);
    }
    var VT = dT({
      findFiberByHostInstance: fG,
      bundleType: 1,
      version: aK,
      rendererPackageName: "react-dom"
    });
    if (!VT && wl && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var vk = window.location.protocol;
      /^(https?|file):$/.test(vk) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (vk === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    zb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tK, zb.createPortal = ST, zb.createRoot = XT, zb.findDOMNode = nT, zb.flushSync = WT, zb.hydrate = pT, zb.hydrateRoot = KT, zb.render = LT, zb.unmountComponentAtNode = yT, zb.unstable_batchedUpdates = OX, zb.unstable_renderSubtreeIntoContainer = tT, zb.version = aK, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), zb;
}
BI.exports = UT();
var xo = BI.exports;
const DI = /* @__PURE__ */ wh(xo);
var hV, Qk = xo;
{
  var Pk = Qk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  hV = function(l, Z) {
    Pk.usingClientEntryPoint = !0;
    try {
      return Qk.createRoot(l, Z);
    } finally {
      Pk.usingClientEntryPoint = !1;
    }
  };
}
class yV {
  get childNodes() {
    throw new Error("childNodes is not supported");
  }
  clone() {
    let Z = new yV(this.type, this.key);
    return Z.value = this.value, Z.level = this.level, Z.hasChildNodes = this.hasChildNodes, Z.rendered = this.rendered, Z.textValue = this.textValue, Z["aria-label"] = this["aria-label"], Z.index = this.index, Z.parentKey = this.parentKey, Z.prevKey = this.prevKey, Z.nextKey = this.nextKey, Z.firstChildKey = this.firstChildKey, Z.lastChildKey = this.lastChildKey, Z.props = this.props, Z.render = this.render, Z;
  }
  constructor(Z, u) {
    this.value = null, this.level = 0, this.hasChildNodes = !1, this.rendered = null, this.textValue = "", this["aria-label"] = void 0, this.index = 0, this.parentKey = null, this.prevKey = null, this.nextKey = null, this.firstChildKey = null, this.lastChildKey = null, this.props = {}, this.type = Z, this.key = u;
  }
}
class CT {
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  *[Symbol.iterator]() {
    let Z = this.firstKey != null ? this.keyMap.get(this.firstKey) : void 0;
    for (; Z; )
      yield Z, Z = Z.nextKey != null ? this.keyMap.get(Z.nextKey) : void 0;
  }
  getChildren(Z) {
    let u = this.keyMap;
    return {
      *[Symbol.iterator]() {
        let s = u.get(Z), G = (s == null ? void 0 : s.firstChildKey) != null ? u.get(s.firstChildKey) : null;
        for (; G; )
          yield G, G = G.nextKey != null ? u.get(G.nextKey) : void 0;
      }
    };
  }
  getKeyBefore(Z) {
    let u = this.keyMap.get(Z);
    if (!u) return null;
    if (u.prevKey != null) {
      for (u = this.keyMap.get(u.prevKey); u && u.type !== "item" && u.lastChildKey != null; ) u = this.keyMap.get(u.lastChildKey);
      var s;
      return (s = u == null ? void 0 : u.key) !== null && s !== void 0 ? s : null;
    }
    return u.parentKey;
  }
  getKeyAfter(Z) {
    let u = this.keyMap.get(Z);
    if (!u) return null;
    if (u.type !== "item" && u.firstChildKey != null) return u.firstChildKey;
    for (; u; ) {
      if (u.nextKey != null) return u.nextKey;
      if (u.parentKey != null) u = this.keyMap.get(u.parentKey);
      else return null;
    }
    return null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    let Z = this.lastKey != null ? this.keyMap.get(this.lastKey) : null;
    for (; (Z == null ? void 0 : Z.lastChildKey) != null; ) Z = this.keyMap.get(Z.lastChildKey);
    var u;
    return (u = Z == null ? void 0 : Z.key) !== null && u !== void 0 ? u : null;
  }
  getItem(Z) {
    var u;
    return (u = this.keyMap.get(Z)) !== null && u !== void 0 ? u : null;
  }
  at() {
    throw new Error("Not implemented");
  }
  clone() {
    let Z = this.constructor, u = new Z();
    return u.keyMap = new Map(this.keyMap), u.firstKey = this.firstKey, u.lastKey = this.lastKey, u;
  }
  addNode(Z) {
    if (this.frozen) throw new Error("Cannot add a node to a frozen collection");
    this.keyMap.set(Z.key, Z);
  }
  removeNode(Z) {
    if (this.frozen) throw new Error("Cannot remove a node to a frozen collection");
    this.keyMap.delete(Z);
  }
  commit(Z, u, s = !1) {
    if (this.frozen) throw new Error("Cannot commit a frozen collection");
    this.firstKey = Z, this.lastKey = u, this.frozen = !s;
  }
  constructor() {
    this.keyMap = /* @__PURE__ */ new Map(), this.firstKey = null, this.lastKey = null, this.frozen = !1;
  }
}
class jI {
  *[Symbol.iterator]() {
    let Z = this.firstChild;
    for (; Z; )
      yield Z, Z = Z.nextSibling;
  }
  get firstChild() {
    return this._firstChild;
  }
  set firstChild(Z) {
    this._firstChild = Z, this.ownerDocument.markDirty(this);
  }
  get lastChild() {
    return this._lastChild;
  }
  set lastChild(Z) {
    this._lastChild = Z, this.ownerDocument.markDirty(this);
  }
  get previousSibling() {
    return this._previousSibling;
  }
  set previousSibling(Z) {
    this._previousSibling = Z, this.ownerDocument.markDirty(this);
  }
  get nextSibling() {
    return this._nextSibling;
  }
  set nextSibling(Z) {
    this._nextSibling = Z, this.ownerDocument.markDirty(this);
  }
  get parentNode() {
    return this._parentNode;
  }
  set parentNode(Z) {
    this._parentNode = Z, this.ownerDocument.markDirty(this);
  }
  get isConnected() {
    var Z;
    return ((Z = this.parentNode) === null || Z === void 0 ? void 0 : Z.isConnected) || !1;
  }
  appendChild(Z) {
    this.ownerDocument.startTransaction(), Z.parentNode && Z.parentNode.removeChild(Z), this.firstChild == null && (this.firstChild = Z), this.lastChild ? (this.lastChild.nextSibling = Z, Z.index = this.lastChild.index + 1, Z.previousSibling = this.lastChild) : (Z.previousSibling = null, Z.index = 0), Z.parentNode = this, Z.nextSibling = null, this.lastChild = Z, this.ownerDocument.markDirty(this), Z.hasSetProps && this.ownerDocument.addNode(Z), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  insertBefore(Z, u) {
    if (u == null) return this.appendChild(Z);
    this.ownerDocument.startTransaction(), Z.parentNode && Z.parentNode.removeChild(Z), Z.nextSibling = u, Z.previousSibling = u.previousSibling, Z.index = u.index, this.firstChild === u ? this.firstChild = Z : u.previousSibling && (u.previousSibling.nextSibling = Z), u.previousSibling = Z, Z.parentNode = u.parentNode;
    let s = u;
    for (; s; )
      s.index++, s = s.nextSibling;
    Z.hasSetProps && this.ownerDocument.addNode(Z), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  removeChild(Z) {
    if (Z.parentNode !== this || !this.ownerDocument.isMounted) return;
    this.ownerDocument.startTransaction();
    let u = Z.nextSibling;
    for (; u; )
      u.index--, u = u.nextSibling;
    Z.nextSibling && (Z.nextSibling.previousSibling = Z.previousSibling), Z.previousSibling && (Z.previousSibling.nextSibling = Z.nextSibling), this.firstChild === Z && (this.firstChild = Z.nextSibling), this.lastChild === Z && (this.lastChild = Z.previousSibling), Z.parentNode = null, Z.nextSibling = null, Z.previousSibling = null, Z.index = 0, this.ownerDocument.removeNode(Z), this.ownerDocument.endTransaction(), this.ownerDocument.queueUpdate();
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  constructor(Z) {
    this._firstChild = null, this._lastChild = null, this._previousSibling = null, this._nextSibling = null, this._parentNode = null, this.ownerDocument = Z;
  }
}
class Ja extends jI {
  get index() {
    return this._index;
  }
  set index(Z) {
    this._index = Z, this.ownerDocument.markDirty(this);
  }
  get level() {
    return this.parentNode instanceof Ja ? this.parentNode.level + (this.node.type === "item" ? 1 : 0) : 0;
  }
  updateNode() {
    var Z, u, s, G;
    let i = this.ownerDocument.getMutableNode(this);
    i.index = this.index, i.level = this.level, i.parentKey = this.parentNode instanceof Ja ? this.parentNode.node.key : null;
    var m;
    i.prevKey = (m = (Z = this.previousSibling) === null || Z === void 0 ? void 0 : Z.node.key) !== null && m !== void 0 ? m : null;
    var a;
    i.nextKey = (a = (u = this.nextSibling) === null || u === void 0 ? void 0 : u.node.key) !== null && a !== void 0 ? a : null, i.hasChildNodes = !!this.firstChild;
    var n;
    i.firstChildKey = (n = (s = this.firstChild) === null || s === void 0 ? void 0 : s.node.key) !== null && n !== void 0 ? n : null;
    var p;
    i.lastChildKey = (p = (G = this.lastChild) === null || G === void 0 ? void 0 : G.node.key) !== null && p !== void 0 ? p : null;
  }
  setProps(Z, u, s, G) {
    let i = this.ownerDocument.getMutableNode(this), { value: m, textValue: a, id: n, ...p } = Z;
    if (p.ref = u, i.props = p, i.rendered = s, i.render = G, i.value = m, i.textValue = a || (typeof p.children == "string" ? p.children : "") || Z["aria-label"] || "", n != null && n !== i.key) {
      if (this.hasSetProps) throw new Error("Cannot change the id of an item");
      i.key = n;
    }
    this.hasSetProps || (this.ownerDocument.addNode(this), this.ownerDocument.endTransaction(), this.hasSetProps = !0), this.ownerDocument.queueUpdate();
  }
  get style() {
    return {};
  }
  hasAttribute() {
  }
  setAttribute() {
  }
  setAttributeNS() {
  }
  removeAttribute() {
  }
  constructor(Z, u) {
    super(u), this.nodeType = 8, this._index = 0, this.hasSetProps = !1, this.node = new yV(Z, `react-aria-${++u.nodeId}`), this.ownerDocument.startTransaction();
  }
}
class rT extends jI {
  get isConnected() {
    return this.isMounted;
  }
  createElement(Z) {
    return new Ja(Z, this);
  }
  /**
  * Lazily gets a mutable instance of a Node. If the node has already
  * been cloned during this update cycle, it just returns the existing one.
  */
  getMutableNode(Z) {
    let u = Z.node;
    return this.mutatedNodes.has(Z) || (u = Z.node.clone(), this.mutatedNodes.add(Z), Z.node = u), this.markDirty(Z), u;
  }
  getMutableCollection() {
    return !this.isSSR && !this.collectionMutated && (this.collection = this.collection.clone(), this.collectionMutated = !0), this.collection;
  }
  markDirty(Z) {
    this.dirtyNodes.add(Z);
  }
  startTransaction() {
    this.transactionCount++;
  }
  endTransaction() {
    this.transactionCount--;
  }
  addNode(Z) {
    let u = this.getMutableCollection();
    if (!u.getItem(Z.node.key)) {
      u.addNode(Z.node);
      for (let s of Z) this.addNode(s);
    }
    this.markDirty(Z);
  }
  removeNode(Z) {
    for (let s of Z) this.removeNode(s);
    this.getMutableCollection().removeNode(Z.node.key), this.markDirty(Z);
  }
  /** Finalizes the collection update, updating all nodes and freezing the collection. */
  getCollection() {
    return this.transactionCount > 0 ? this.collection : (this.updateCollection(), this.collection);
  }
  updateCollection() {
    for (let i of this.dirtyNodes) i instanceof Ja && i.isConnected && i.updateNode();
    if (this.dirtyNodes.clear(), this.mutatedNodes.size || this.collectionMutated) {
      var Z, u;
      let i = this.getMutableCollection();
      for (let m of this.mutatedNodes) m.isConnected && i.addNode(m.node);
      var s, G;
      i.commit((s = (Z = this.firstChild) === null || Z === void 0 ? void 0 : Z.node.key) !== null && s !== void 0 ? s : null, (G = (u = this.lastChild) === null || u === void 0 ? void 0 : u.node.key) !== null && G !== void 0 ? G : null, this.isSSR), this.mutatedNodes.clear();
    }
    this.collectionMutated = !1;
  }
  queueUpdate() {
    if (!(this.dirtyNodes.size === 0 || this.transactionCount > 0))
      for (let Z of this.subscriptions) Z();
  }
  subscribe(Z) {
    return this.subscriptions.add(Z), () => this.subscriptions.delete(Z);
  }
  resetAfterSSR() {
    this.isSSR && (this.isSSR = !1, this.firstChild = null, this.lastChild = null, this.nodeId = 0);
  }
  constructor(Z) {
    super(null), this.nodeType = 11, this.ownerDocument = this, this.dirtyNodes = /* @__PURE__ */ new Set(), this.isSSR = !1, this.nodeId = 0, this.nodesByProps = /* @__PURE__ */ new WeakMap(), this.isMounted = !0, this.mutatedNodes = /* @__PURE__ */ new Set(), this.subscriptions = /* @__PURE__ */ new Set(), this.transactionCount = 0, this.collection = Z, this.collectionMutated = !0;
  }
}
function QI(l) {
  let { children: Z, items: u, idScope: s, addIdAndValue: G, dependencies: i = [] } = l, m = M.useMemo(() => /* @__PURE__ */ new WeakMap(), i);
  return M.useMemo(() => {
    if (u && typeof Z == "function") {
      let p = [];
      for (let y of u) {
        let h = m.get(y);
        if (!h) {
          h = Z(y);
          var a, n;
          let S = (n = (a = h.props.id) !== null && a !== void 0 ? a : y.key) !== null && n !== void 0 ? n : y.id;
          if (S == null) throw new Error("Could not determine key for item");
          s && (S = s + ":" + S), h = M.cloneElement(h, G ? {
            key: S,
            id: S,
            value: y
          } : {
            key: S
          }), m.set(y, h);
        }
        p.push(h);
      }
      return p;
    } else if (typeof Z != "function") return Z;
  }, [
    Z,
    u,
    m,
    s,
    G
  ]);
}
var PI = { NODE_ENV: '"production"' };
const oh = {
  prefix: String(Math.round(Math.random() * 1e10)),
  current: 0
}, OI = /* @__PURE__ */ tl.createContext(oh), FT = /* @__PURE__ */ tl.createContext(!1);
let NT = !!(typeof window < "u" && window.document && window.document.createElement), VK = /* @__PURE__ */ new WeakMap();
function wT(l = !1) {
  let Z = M.useContext(OI), u = M.useRef(null);
  if (u.current === null && !l) {
    var s, G;
    let i = (G = tl.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === null || G === void 0 || (s = G.ReactCurrentOwner) === null || s === void 0 ? void 0 : s.current;
    if (i) {
      let m = VK.get(i);
      m == null ? VK.set(i, {
        id: Z.current,
        state: i.memoizedState
      }) : i.memoizedState !== m.state && (Z.current = m.id, VK.delete(i));
    }
    u.current = ++Z.current;
  }
  return u.current;
}
function zT(l) {
  let Z = M.useContext(OI);
  Z === oh && !NT && console.warn("When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.");
  let u = wT(!!l), s = Z === oh && PI.NODE_ENV === "test" ? "react-aria" : `react-aria${Z.prefix}`;
  return l || `${s}-${u}`;
}
function JT(l) {
  let Z = tl.useId(), [u] = M.useState(Mm()), s = u || PI.NODE_ENV === "test" ? "react-aria" : `react-aria${oh.prefix}`;
  return l || `${s}-${Z}`;
}
const HT = typeof tl.useId == "function" ? JT : zT;
function gT() {
  return !1;
}
function vT() {
  return !0;
}
function TT(l) {
  return () => {
  };
}
function Mm() {
  return typeof tl.useSyncExternalStore == "function" ? tl.useSyncExternalStore(TT, gT, vT) : M.useContext(FT);
}
if (typeof HTMLTemplateElement < "u") {
  const l = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild").get;
  Object.defineProperty(HTMLTemplateElement.prototype, "firstChild", {
    configurable: !0,
    enumerable: !0,
    get: function() {
      return this.dataset.reactAriaHidden ? this.content.firstChild : l.call(this);
    }
  });
}
const eh = /* @__PURE__ */ M.createContext(!1), fT = typeof DocumentFragment < "u" ? new DocumentFragment() : null;
function ET(l) {
  let Z = M.useContext(eh), u = Mm();
  if (Z)
    return /* @__PURE__ */ tl.createElement(tl.Fragment, null, l.children);
  let s = /* @__PURE__ */ tl.createElement(eh.Provider, {
    value: !0
  }, l.children);
  return u ? /* @__PURE__ */ tl.createElement("template", {
    "data-react-aria-hidden": !0
  }, s) : /* @__PURE__ */ xo.createPortal(s, fT);
}
function BT(l) {
  let Z = (u, s) => M.useContext(eh) ? null : l(u, s);
  return Z.displayName = l.displayName || l.name, M.forwardRef(Z);
}
function DT() {
  return M.useContext(eh);
}
const PZ = typeof document < "u" ? tl.useLayoutEffect : () => {
};
function gb(l) {
  const Z = M.useRef(null);
  return PZ(() => {
    Z.current = l;
  }, [
    l
  ]), M.useCallback((...u) => {
    const s = Z.current;
    return s == null ? void 0 : s(...u);
  }, []);
}
function jT(l) {
  let [Z, u] = M.useState(l), s = M.useRef(null), G = gb(() => {
    if (!s.current) return;
    let m = s.current.next();
    if (m.done) {
      s.current = null;
      return;
    }
    Z === m.value ? G() : u(m.value);
  });
  PZ(() => {
    s.current && G();
  });
  let i = gb((m) => {
    s.current = m(Z), G();
  });
  return [
    Z,
    i
  ];
}
let QT = !!(typeof window < "u" && window.document && window.document.createElement), uG = /* @__PURE__ */ new Map();
function ad(l) {
  let [Z, u] = M.useState(l), s = M.useRef(null), G = HT(Z), i = M.useCallback((m) => {
    s.current = m;
  }, []);
  return QT && (uG.has(G) && !uG.get(G).includes(i) ? uG.set(G, [
    ...uG.get(G),
    i
  ]) : uG.set(G, [
    i
  ])), PZ(() => {
    let m = G;
    return () => {
      uG.delete(m);
    };
  }, [
    G
  ]), M.useEffect(() => {
    let m = s.current;
    m && (s.current = null, u(m));
  }), G;
}
function PT(l, Z) {
  if (l === Z) return l;
  let u = uG.get(l);
  if (u)
    return u.forEach((G) => G(Z)), Z;
  let s = uG.get(Z);
  return s ? (s.forEach((G) => G(l)), l) : Z;
}
function xK(l = []) {
  let Z = ad(), [u, s] = jT(Z), G = M.useCallback(() => {
    s(function* () {
      yield Z, yield document.getElementById(Z) ? Z : void 0;
    });
  }, [
    Z,
    s
  ]);
  return PZ(G, [
    Z,
    G,
    ...l
  ]), u;
}
function Ha(...l) {
  return (...Z) => {
    for (let u of l) typeof u == "function" && u(...Z);
  };
}
const _Z = (l) => {
  var Z;
  return (Z = l == null ? void 0 : l.ownerDocument) !== null && Z !== void 0 ? Z : document;
}, Eu = (l) => l && "window" in l && l.window === l ? l : _Z(l).defaultView || window;
function AI(l) {
  var Z, u, s = "";
  if (typeof l == "string" || typeof l == "number") s += l;
  else if (typeof l == "object") if (Array.isArray(l)) {
    var G = l.length;
    for (Z = 0; Z < G; Z++) l[Z] && (u = AI(l[Z])) && (s && (s += " "), s += u);
  } else for (u in l) l[u] && (s && (s += " "), s += u);
  return s;
}
function OT() {
  for (var l, Z, u = 0, s = "", G = arguments.length; u < G; u++) (l = arguments[u]) && (Z = AI(l)) && (s && (s += " "), s += Z);
  return s;
}
function HZ(...l) {
  let Z = {
    ...l[0]
  };
  for (let u = 1; u < l.length; u++) {
    let s = l[u];
    for (let G in s) {
      let i = Z[G], m = s[G];
      typeof i == "function" && typeof m == "function" && // This is a lot faster than a regex.
      G[0] === "o" && G[1] === "n" && G.charCodeAt(2) >= /* 'A' */
      65 && G.charCodeAt(2) <= /* 'Z' */
      90 ? Z[G] = Ha(i, m) : (G === "className" || G === "UNSAFE_className") && typeof i == "string" && typeof m == "string" ? Z[G] = OT(i, m) : G === "id" && i && m ? Z.id = PT(i, m) : Z[G] = m !== void 0 ? m : i;
    }
  }
  return Z;
}
function AT(...l) {
  return l.length === 1 && l[0] ? l[0] : (Z) => {
    for (let u of l)
      typeof u == "function" ? u(Z) : u != null && (u.current = Z);
  };
}
const $T = /* @__PURE__ */ new Set([
  "id"
]), qT = /* @__PURE__ */ new Set([
  "aria-label",
  "aria-labelledby",
  "aria-describedby",
  "aria-details"
]), _T = /* @__PURE__ */ new Set([
  "href",
  "hrefLang",
  "target",
  "rel",
  "download",
  "ping",
  "referrerPolicy"
]), lf = /^(data-.*)$/;
function Su(l, Z = {}) {
  let { labelable: u, isLink: s, propNames: G } = Z, i = {};
  for (const m in l) Object.prototype.hasOwnProperty.call(l, m) && ($T.has(m) || u && qT.has(m) || s && _T.has(m) || G != null && G.has(m) || lf.test(m)) && (i[m] = l[m]);
  return i;
}
function Ls(l) {
  if (Zf()) l.focus({
    preventScroll: !0
  });
  else {
    let Z = cf(l);
    l.focus(), bf(Z);
  }
}
let vL = null;
function Zf() {
  if (vL == null) {
    vL = !1;
    try {
      document.createElement("div").focus({
        get preventScroll() {
          return vL = !0, !0;
        }
      });
    } catch {
    }
  }
  return vL;
}
function cf(l) {
  let Z = l.parentNode, u = [], s = document.scrollingElement || document.documentElement;
  for (; Z instanceof HTMLElement && Z !== s; )
    (Z.offsetHeight < Z.scrollHeight || Z.offsetWidth < Z.scrollWidth) && u.push({
      element: Z,
      scrollTop: Z.scrollTop,
      scrollLeft: Z.scrollLeft
    }), Z = Z.parentNode;
  return s instanceof HTMLElement && u.push({
    element: s,
    scrollTop: s.scrollTop,
    scrollLeft: s.scrollLeft
  }), u;
}
function bf(l) {
  for (let { element: Z, scrollTop: u, scrollLeft: s } of l)
    Z.scrollTop = u, Z.scrollLeft = s;
}
function zh(l) {
  var Z;
  return typeof window > "u" || window.navigator == null ? !1 : ((Z = window.navigator.userAgentData) === null || Z === void 0 ? void 0 : Z.brands.some((u) => l.test(u.brand))) || l.test(window.navigator.userAgent);
}
function SV(l) {
  var Z;
  return typeof window < "u" && window.navigator != null ? l.test(((Z = window.navigator.userAgentData) === null || Z === void 0 ? void 0 : Z.platform) || window.navigator.platform) : !1;
}
function hd(l) {
  let Z = null;
  return () => (Z == null && (Z = l()), Z);
}
const Sm = hd(function() {
  return SV(/^Mac/i);
}), uf = hd(function() {
  return SV(/^iPhone/i);
}), $I = hd(function() {
  return SV(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  Sm() && navigator.maxTouchPoints > 1;
}), Jh = hd(function() {
  return uf() || $I();
}), sf = hd(function() {
  return Sm() || Jh();
}), qI = hd(function() {
  return zh(/AppleWebKit/i) && !df();
}), df = hd(function() {
  return zh(/Chrome/i);
}), _I = hd(function() {
  return zh(/Android/i);
}), Gf = hd(function() {
  return zh(/Firefox/i);
}), mf = /* @__PURE__ */ M.createContext({
  isNative: !0,
  open: af,
  useHref: (l) => l
});
function nn() {
  return M.useContext(mf);
}
function of(l, Z) {
  let u = l.getAttribute("target");
  return (!u || u === "_self") && l.origin === location.origin && !l.hasAttribute("download") && !Z.metaKey && // open in new tab (mac)
  !Z.ctrlKey && // open in new tab (windows)
  !Z.altKey && // download
  !Z.shiftKey;
}
function tm(l, Z, u = !0) {
  var s, G;
  let { metaKey: i, ctrlKey: m, altKey: a, shiftKey: n } = Z;
  Gf() && (!((G = window.event) === null || G === void 0 || (s = G.type) === null || s === void 0) && s.startsWith("key")) && l.target === "_blank" && (Sm() ? i = !0 : m = !0);
  let p = qI() && Sm() && !$I() ? new KeyboardEvent("keydown", {
    keyIdentifier: "Enter",
    metaKey: i,
    ctrlKey: m,
    altKey: a,
    shiftKey: n
  }) : new MouseEvent("click", {
    metaKey: i,
    ctrlKey: m,
    altKey: a,
    shiftKey: n,
    bubbles: !0,
    cancelable: !0
  });
  tm.isOpening = u, Ls(l), l.dispatchEvent(p), tm.isOpening = !1;
}
tm.isOpening = !1;
function ef(l, Z) {
  if (l instanceof HTMLAnchorElement) Z(l);
  else if (l.hasAttribute("data-href")) {
    let u = document.createElement("a");
    u.href = l.getAttribute("data-href"), l.hasAttribute("data-target") && (u.target = l.getAttribute("data-target")), l.hasAttribute("data-rel") && (u.rel = l.getAttribute("data-rel")), l.hasAttribute("data-download") && (u.download = l.getAttribute("data-download")), l.hasAttribute("data-ping") && (u.ping = l.getAttribute("data-ping")), l.hasAttribute("data-referrer-policy") && (u.referrerPolicy = l.getAttribute("data-referrer-policy")), l.appendChild(u), Z(u), l.removeChild(u);
  }
}
function af(l, Z) {
  ef(l, (u) => tm(u, Z));
}
function l1(l) {
  let Z = nn();
  var u;
  const s = Z.useHref((u = l == null ? void 0 : l.href) !== null && u !== void 0 ? u : "");
  return {
    href: l != null && l.href ? s : void 0,
    target: l == null ? void 0 : l.target,
    rel: l == null ? void 0 : l.rel,
    download: l == null ? void 0 : l.download,
    ping: l == null ? void 0 : l.ping,
    referrerPolicy: l == null ? void 0 : l.referrerPolicy
  };
}
let gi = /* @__PURE__ */ new Map(), iW = /* @__PURE__ */ new Set();
function Ok() {
  if (typeof window > "u") return;
  function l(s) {
    return "propertyName" in s;
  }
  let Z = (s) => {
    if (!l(s) || !s.target) return;
    let G = gi.get(s.target);
    G || (G = /* @__PURE__ */ new Set(), gi.set(s.target, G), s.target.addEventListener("transitioncancel", u, {
      once: !0
    })), G.add(s.propertyName);
  }, u = (s) => {
    if (!l(s) || !s.target) return;
    let G = gi.get(s.target);
    if (G && (G.delete(s.propertyName), G.size === 0 && (s.target.removeEventListener("transitioncancel", u), gi.delete(s.target)), gi.size === 0)) {
      for (let i of iW) i();
      iW.clear();
    }
  };
  document.body.addEventListener("transitionrun", Z), document.body.addEventListener("transitionend", u);
}
typeof document < "u" && (document.readyState !== "loading" ? Ok() : document.addEventListener("DOMContentLoaded", Ok));
function Z1(l) {
  requestAnimationFrame(() => {
    gi.size === 0 ? l() : iW.add(l);
  });
}
function pn() {
  let l = M.useRef(/* @__PURE__ */ new Map()), Z = M.useCallback((G, i, m, a) => {
    let n = a != null && a.once ? (...p) => {
      l.current.delete(m), m(...p);
    } : m;
    l.current.set(m, {
      type: i,
      eventTarget: G,
      fn: n,
      options: a
    }), G.addEventListener(i, m, a);
  }, []), u = M.useCallback((G, i, m, a) => {
    var n;
    let p = ((n = l.current.get(m)) === null || n === void 0 ? void 0 : n.fn) || m;
    G.removeEventListener(i, p, a), l.current.delete(m);
  }, []), s = M.useCallback(() => {
    l.current.forEach((G, i) => {
      u(G.eventTarget, G.type, i, G.options);
    });
  }, [
    u
  ]);
  return M.useEffect(() => s, [
    s
  ]), {
    addGlobalListener: Z,
    removeGlobalListener: u,
    removeAllGlobalListeners: s
  };
}
function c1(l, Z) {
  let { id: u, "aria-label": s, "aria-labelledby": G } = l;
  return u = ad(u), G && s ? G = [
    .../* @__PURE__ */ new Set([
      u,
      ...G.trim().split(/\s+/)
    ])
  ].join(" ") : G && (G = G.trim().split(/\s+/).join(" ")), !s && !G && Z && (s = Z), {
    id: u,
    "aria-label": s,
    "aria-labelledby": G
  };
}
function tV(l) {
  const Z = M.useRef(null);
  return M.useMemo(() => ({
    get current() {
      return Z.current;
    },
    set current(u) {
      Z.current = u, typeof l == "function" ? l(u) : l && (l.current = u);
    }
  }), [
    l
  ]);
}
function nf() {
  return typeof window.ResizeObserver < "u";
}
function oW(l) {
  const { ref: Z, box: u, onResize: s } = l;
  M.useEffect(() => {
    let G = Z == null ? void 0 : Z.current;
    if (G)
      if (nf()) {
        const i = new window.ResizeObserver((m) => {
          m.length && s();
        });
        return i.observe(G, {
          box: u
        }), () => {
          G && i.unobserve(G);
        };
      } else
        return window.addEventListener("resize", s, !1), () => {
          window.removeEventListener("resize", s, !1);
        };
  }, [
    s,
    Z,
    u
  ]);
}
function XV(l, Z) {
  PZ(() => {
    if (l && l.ref && Z)
      return l.ref.current = Z.current, () => {
        l.ref && (l.ref.current = null);
      };
  });
}
function ga(l, Z) {
  let u = window.getComputedStyle(l), s = /(auto|scroll)/.test(u.overflow + u.overflowX + u.overflowY);
  return s && Z && (s = l.scrollHeight !== l.clientHeight || l.scrollWidth !== l.clientWidth), s;
}
function b1(l, Z) {
  let u = l;
  for (ga(u, Z) && (u = u.parentElement); u && !ga(u, Z); ) u = u.parentElement;
  return u || document.scrollingElement || document.documentElement;
}
function pf(l, Z) {
  const u = [];
  for (; l && l !== document.documentElement; )
    ga(l, Z) && u.push(l), l = l.parentElement;
  return u;
}
let Lf = 0;
const RK = /* @__PURE__ */ new Map();
function hf(l) {
  let [Z, u] = M.useState();
  return PZ(() => {
    if (!l) return;
    let s = RK.get(l);
    if (s)
      u(s.element.id);
    else {
      let G = `react-aria-description-${Lf++}`;
      u(G);
      let i = document.createElement("div");
      i.id = G, i.style.display = "none", i.textContent = l, document.body.appendChild(i), s = {
        refCount: 0,
        element: i
      }, RK.set(l, s);
    }
    return s.refCount++, () => {
      s && --s.refCount === 0 && (s.element.remove(), RK.delete(l));
    };
  }, [
    l
  ]), {
    "aria-describedby": l ? Z : void 0
  };
}
function Ak(l, Z, u, s) {
  let G = gb(u), i = u == null;
  M.useEffect(() => {
    if (i || !l.current) return;
    let m = l.current;
    return m.addEventListener(Z, G, s), () => {
      m.removeEventListener(Z, G, s);
    };
  }, [
    l,
    Z,
    s,
    i,
    G
  ]);
}
function u1(l, Z) {
  let u = $k(l, Z, "left"), s = $k(l, Z, "top"), G = Z.offsetWidth, i = Z.offsetHeight, m = l.scrollLeft, a = l.scrollTop, { borderTopWidth: n, borderLeftWidth: p } = getComputedStyle(l), y = l.scrollLeft + parseInt(p, 10), h = l.scrollTop + parseInt(n, 10), S = y + l.clientWidth, t = h + l.clientHeight;
  u <= m ? m = u - parseInt(p, 10) : u + G > S && (m += u + G - S), s <= h ? a = s - parseInt(n, 10) : s + i > t && (a += s + i - t), l.scrollLeft = m, l.scrollTop = a;
}
function $k(l, Z, u) {
  const s = u === "left" ? "offsetLeft" : "offsetTop";
  let G = 0;
  for (; Z.offsetParent && (G += Z[s], Z.offsetParent !== l); ) {
    if (Z.offsetParent.contains(l)) {
      G -= l[s];
      break;
    }
    Z = Z.offsetParent;
  }
  return G;
}
function qk(l, Z) {
  if (document.contains(l)) {
    let m = document.scrollingElement || document.documentElement;
    if (window.getComputedStyle(m).overflow === "hidden") {
      let n = pf(l);
      for (let p of n) u1(p, l);
    } else {
      var u;
      let { left: n, top: p } = l.getBoundingClientRect();
      l == null || (u = l.scrollIntoView) === null || u === void 0 || u.call(l, {
        block: "nearest"
      });
      let { left: y, top: h } = l.getBoundingClientRect();
      if (Math.abs(n - y) > 1 || Math.abs(p - h) > 1) {
        var s, G, i;
        Z == null || (G = Z.containingElement) === null || G === void 0 || (s = G.scrollIntoView) === null || s === void 0 || s.call(G, {
          block: "center",
          inline: "center"
        }), (i = l.scrollIntoView) === null || i === void 0 || i.call(l, {
          block: "nearest"
        });
      }
    }
  }
}
function eW(l) {
  return l.mozInputSource === 0 && l.isTrusted ? !0 : _I() && l.pointerType ? l.type === "click" && l.buttons === 1 : l.detail === 0 && !l.pointerType;
}
function yf(l) {
  return !_I() && l.width === 0 && l.height === 0 || l.width === 1 && l.height === 1 && l.pressure === 0 && l.detail === 0 && l.pointerType === "mouse";
}
function Sf(l, Z, u) {
  let s = M.useRef(Z), G = gb(() => {
    u && u(s.current);
  });
  M.useEffect(() => {
    var i;
    let m = l == null || (i = l.current) === null || i === void 0 ? void 0 : i.form;
    return m == null || m.addEventListener("reset", G), () => {
      m == null || m.removeEventListener("reset", G);
    };
  }, [
    l,
    G
  ]);
}
function Hh(l, Z, u) {
  let [s, G] = M.useState(l || Z), i = M.useRef(l !== void 0), m = l !== void 0;
  M.useEffect(() => {
    let p = i.current;
    p !== m && console.warn(`WARN: A component changed from ${p ? "controlled" : "uncontrolled"} to ${m ? "controlled" : "uncontrolled"}.`), i.current = m;
  }, [
    m
  ]);
  let a = m ? l : s, n = M.useCallback((p, ...y) => {
    let h = (S, ...t) => {
      u && (Object.is(a, S) || u(S, ...t)), m || (a = S);
    };
    typeof p == "function" ? (console.warn("We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"), G((t, ...W) => {
      let V = p(m ? a : t, ...W);
      return h(V, ...y), m ? t : V;
    })) : (m || G(p), h(p, ...y));
  }, [
    m,
    a,
    u
  ]);
  return [
    a,
    n
  ];
}
function eo(l, Z = -1 / 0, u = 1 / 0) {
  return Math.min(Math.max(l, Z), u);
}
function TL(l, Z) {
  let u = l, s = Z.toString(), G = s.indexOf("."), i = G >= 0 ? s.length - G : 0;
  if (i > 0) {
    let m = Math.pow(10, i);
    u = Math.round(u * m) / m;
  }
  return u;
}
function ha(l, Z, u, s) {
  Z = Number(Z), u = Number(u);
  let G = (l - (isNaN(Z) ? 0 : Z)) % s, i = TL(Math.abs(G) * 2 >= s ? l + Math.sign(G) * (s - Math.abs(G)) : l - G, s);
  return isNaN(Z) ? !isNaN(u) && i > u && (i = Math.floor(TL(u / s, s)) * s) : i < Z ? i = Z : !isNaN(u) && i > u && (i = Z + Math.floor(TL((u - Z) / s, s)) * s), i = TL(i, s), i;
}
var YK = { exports: {} }, kK = {}, _k;
function tf() {
  if (_k) return kK;
  _k = 1;
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var l = M, Z = l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function u(k) {
      {
        for (var U = arguments.length, w = new Array(U > 1 ? U - 1 : 0), z = 1; z < U; z++)
          w[z - 1] = arguments[z];
        s("error", k, w);
      }
    }
    function s(k, U, w) {
      {
        var z = Z.ReactDebugCurrentFrame, D = z.getStackAddendum();
        D !== "" && (U += "%s", w = w.concat([D]));
        var C = w.map(function(j) {
          return String(j);
        });
        C.unshift("Warning: " + U), Function.prototype.apply.call(console[k], console, C);
      }
    }
    function G(k, U) {
      return k === U && (k !== 0 || 1 / k === 1 / U) || k !== k && U !== U;
    }
    var i = typeof Object.is == "function" ? Object.is : G, m = l.useState, a = l.useEffect, n = l.useLayoutEffect, p = l.useDebugValue, y = !1, h = !1;
    function S(k, U, w) {
      y || l.startTransition !== void 0 && (y = !0, u("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var z = U();
      if (!h) {
        var D = U();
        i(z, D) || (u("The result of getSnapshot should be cached to avoid an infinite loop"), h = !0);
      }
      var C = m({
        inst: {
          value: z,
          getSnapshot: U
        }
      }), j = C[0].inst, E = C[1];
      return n(function() {
        j.value = z, j.getSnapshot = U, t(j) && E({
          inst: j
        });
      }, [k, z, U]), a(function() {
        t(j) && E({
          inst: j
        });
        var g = function() {
          t(j) && E({
            inst: j
          });
        };
        return k(g);
      }, [k]), p(z), z;
    }
    function t(k) {
      var U = k.getSnapshot, w = k.value;
      try {
        var z = U();
        return !i(w, z);
      } catch {
        return !0;
      }
    }
    function W(k, U, w) {
      return U();
    }
    var V = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", R = !V, x = R ? W : S, r = l.useSyncExternalStore !== void 0 ? l.useSyncExternalStore : x;
    kK.useSyncExternalStore = r, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), kK;
}
var l2;
function s1() {
  return l2 || (l2 = 1, YK.exports = tf()), YK.exports;
}
var Xf = s1();
const d1 = /* @__PURE__ */ M.createContext(!1), va = /* @__PURE__ */ M.createContext(null);
function Kf(l) {
  if (M.useContext(va))
    return l.content;
  let { collection: u, document: s } = Rf(l.createCollection);
  return /* @__PURE__ */ tl.createElement(tl.Fragment, null, /* @__PURE__ */ tl.createElement(ET, null, /* @__PURE__ */ tl.createElement(va.Provider, {
    value: s
  }, l.content)), /* @__PURE__ */ tl.createElement(Wf, {
    render: l.children,
    collection: u
  }));
}
function Wf({ collection: l, render: Z }) {
  return Z(l);
}
function Vf(l, Z, u) {
  let s = Mm(), G = M.useRef(s);
  G.current = s;
  let i = M.useCallback(() => G.current ? u() : Z(), [
    Z,
    u
  ]);
  return Xf.useSyncExternalStore(l, i);
}
const xf = typeof tl.useSyncExternalStore == "function" ? tl.useSyncExternalStore : Vf;
function Rf(l) {
  let [Z] = M.useState(() => new rT((l == null ? void 0 : l()) || new CT())), u = M.useCallback((m) => Z.subscribe(m), [
    Z
  ]), s = M.useCallback(() => {
    let m = Z.getCollection();
    return Z.isSSR && Z.resetAfterSSR(), m;
  }, [
    Z
  ]), G = M.useCallback(() => (Z.isSSR = !0, Z.getCollection()), [
    Z
  ]), i = xf(u, s, G);
  return PZ(() => (Z.isMounted = !0, () => {
    Z.isMounted = !1;
  }), [
    Z
  ]), {
    collection: i,
    document: Z
  };
}
const aW = /* @__PURE__ */ M.createContext(null);
function Yf(l, Z, u, s, G, i) {
  let m = M.useCallback((n) => {
    n == null || n.setProps(Z, u, s, i);
  }, [
    Z,
    u,
    s,
    i
  ]), a = M.useContext(aW);
  if (a) {
    let n = a.ownerDocument.nodesByProps.get(Z);
    return n || (n = a.ownerDocument.createElement(l), n.setProps(Z, u, s, i), a.appendChild(n), a.ownerDocument.updateCollection(), a.ownerDocument.nodesByProps.set(Z, n)), G ? /* @__PURE__ */ tl.createElement(aW.Provider, {
      value: n
    }, G) : null;
  }
  return /* @__PURE__ */ tl.createElement(l, {
    ref: m
  }, G);
}
function G1(l, Z) {
  let u = ({ node: G }) => Z(G.props, G.props.ref, G), s = M.forwardRef((G, i) => {
    if (!M.useContext(d1)) {
      if (Z.length >= 3) throw new Error(Z.name + " cannot be rendered outside a collection.");
      return Z(G, i);
    }
    return Yf(l, G, i, "children" in G ? G.children : null, null, (a) => /* @__PURE__ */ tl.createElement(u, {
      node: a
    }));
  });
  return s.displayName = Z.name, s;
}
function kf(l) {
  return QI({
    ...l,
    addIdAndValue: !0
  });
}
const Z2 = /* @__PURE__ */ M.createContext(null);
function Mf(l) {
  let Z = M.useContext(Z2), u = ((Z == null ? void 0 : Z.dependencies) || []).concat(l.dependencies), s = l.idScope || (Z == null ? void 0 : Z.idScope), G = kf({
    ...l,
    idScope: s,
    dependencies: u
  });
  return M.useContext(va) && (G = /* @__PURE__ */ tl.createElement(If, null, G)), Z = M.useMemo(() => ({
    dependencies: u,
    idScope: s
  }), [
    s,
    ...u
  ]), /* @__PURE__ */ tl.createElement(Z2.Provider, {
    value: Z
  }, G);
}
function If({ children: l }) {
  let Z = M.useContext(va), u = M.useMemo(() => /* @__PURE__ */ tl.createElement(va.Provider, {
    value: null
  }, /* @__PURE__ */ tl.createElement(d1.Provider, {
    value: !0
  }, l)), [
    l
  ]);
  return Mm() ? /* @__PURE__ */ tl.createElement(aW.Provider, {
    value: Z
  }, u) : /* @__PURE__ */ xo.createPortal(u, Z);
}
const Uf = /* @__PURE__ */ M.createContext(null), Cf = {
  CollectionRoot({ collection: l, renderDropIndicator: Z }) {
    return c2(l, null, Z);
  },
  CollectionBranch({ collection: l, parent: Z, renderDropIndicator: u }) {
    return c2(l, Z, u);
  }
};
function c2(l, Z, u) {
  return QI({
    items: Z ? l.getChildren(Z.key) : l,
    dependencies: [
      u
    ],
    children(s) {
      var G;
      let i = s.render(s);
      if (!u || s.type !== "item") return i;
      let m = s.key, a = l.getKeyAfter(m);
      return /* @__PURE__ */ tl.createElement(tl.Fragment, null, u({
        type: "item",
        key: m,
        dropPosition: "before"
      }), i, (a == null || ((G = l.getItem(a)) === null || G === void 0 ? void 0 : G.type) !== "item") && u({
        type: "item",
        key: m,
        dropPosition: "after"
      }));
    }
  });
}
const m1 = /* @__PURE__ */ M.createContext(Cf);
function rf(l) {
  return M.useMemo(() => l != null ? /* @__PURE__ */ new Set([
    l
  ]) : null, [
    l
  ]);
}
const b2 = Symbol("default");
function Ln({ values: l, children: Z }) {
  for (let [u, s] of l)
    Z = /* @__PURE__ */ tl.createElement(u.Provider, {
      value: s
    }, Z);
  return Z;
}
function Ks(l) {
  let { className: Z, style: u, children: s, defaultClassName: G, defaultChildren: i, defaultStyle: m, values: a } = l;
  return M.useMemo(() => {
    let n, p, y;
    return typeof Z == "function" ? n = Z({
      ...a,
      defaultClassName: G
    }) : n = Z, typeof u == "function" ? p = u({
      ...a,
      defaultStyle: m || {}
    }) : p = u, typeof s == "function" ? y = s({
      ...a,
      defaultChildren: i
    }) : s == null ? y = i : y = s, {
      className: n ?? G,
      style: p || m ? {
        ...m,
        ...p
      } : void 0,
      children: y ?? i,
      "data-rac": ""
    };
  }, [
    Z,
    u,
    s,
    G,
    i,
    m,
    a
  ]);
}
function nW(l, Z) {
  return (u) => Z(typeof l == "function" ? l(u) : l, u);
}
function gh(l, Z) {
  let u = M.useContext(l);
  if (Z === null)
    return null;
  if (u && typeof u == "object" && "slots" in u && u.slots) {
    let s = new Intl.ListFormat().format(Object.keys(u.slots).map((i) => `"${i}"`));
    if (!Z && !u.slots[b2]) throw new Error(`A slot prop is required. Valid slot names are ${s}.`);
    let G = Z || b2;
    if (!u.slots[G])
      throw new Error(`Invalid slot "${Z}". Valid slot names are ${s}.`);
    return u.slots[G];
  }
  return u;
}
function yd(l, Z, u) {
  let s = gh(u, l.slot) || {}, { ref: G, ...i } = s, m = tV(M.useMemo(() => AT(Z, G), [
    Z,
    G
  ])), a = HZ(i, l);
  return "style" in i && i.style && "style" in l && l.style && (typeof i.style == "function" || typeof l.style == "function" ? a.style = (n) => {
    let p = typeof i.style == "function" ? i.style(n) : i.style, y = {
      ...n.defaultStyle,
      ...p
    }, h = typeof l.style == "function" ? l.style({
      ...n,
      defaultStyle: y
    }) : l.style;
    return {
      ...y,
      ...h
    };
  } : a.style = {
    ...i.style,
    ...l.style
  }), [
    a,
    m
  ];
}
function KV() {
  let [l, Z] = M.useState(!0), u = M.useRef(!1), s = M.useCallback((G) => {
    u.current = !0, Z(!!G);
  }, []);
  return PZ(() => {
    u.current || Z(!1);
  }, []), [
    s,
    l
  ];
}
function Ff(l, Z = !0) {
  let [u, s] = M.useState(!0);
  return i1(l, u && Z, M.useCallback(() => s(!1), [])), u && Z;
}
function Nf(l, Z) {
  let [u, s] = M.useState(!1), [G, i] = M.useState("idle");
  return !Z && l.current && G === "idle" && (u = !0, s(!0), i("exiting")), !l.current && G === "exited" && i("idle"), i1(l, u, M.useCallback(() => {
    i("exited"), s(!1);
  }, [])), u;
}
function i1(l, Z, u) {
  let s = M.useRef(null);
  Z && l.current && (s.current = window.getComputedStyle(l.current).animation), PZ(() => {
    if (Z && l.current) {
      let G = window.getComputedStyle(l.current);
      if (G.animationName && G.animationName !== "none" && G.animation !== s.current) {
        let i = (a) => {
          a.target === l.current && (m.removeEventListener("animationend", i), DI.flushSync(() => {
            u();
          }));
        }, m = l.current;
        return m.addEventListener("animationend", i), () => {
          m.removeEventListener("animationend", i);
        };
      } else u();
    }
  }, [
    l,
    Z,
    u
  ]);
}
function I_(l) {
  const Z = /^(data-.*)$/;
  let u = {};
  for (const s in l) Z.test(s) || (u[s] = l[s]);
  return u;
}
let Ti = "default", pW = "", sh = /* @__PURE__ */ new WeakMap();
function LW(l) {
  if (Jh()) {
    if (Ti === "default") {
      const Z = _Z(l);
      pW = Z.documentElement.style.webkitUserSelect, Z.documentElement.style.webkitUserSelect = "none";
    }
    Ti = "disabled";
  } else (l instanceof HTMLElement || l instanceof SVGElement) && (sh.set(l, l.style.userSelect), l.style.userSelect = "none");
}
function ka(l) {
  if (Jh()) {
    if (Ti !== "disabled") return;
    Ti = "restoring", setTimeout(() => {
      Z1(() => {
        if (Ti === "restoring") {
          const Z = _Z(l);
          Z.documentElement.style.webkitUserSelect === "none" && (Z.documentElement.style.webkitUserSelect = pW || ""), pW = "", Ti = "default";
        }
      });
    }, 300);
  } else if ((l instanceof HTMLElement || l instanceof SVGElement) && l && sh.has(l)) {
    let Z = sh.get(l);
    l.style.userSelect === "none" && (l.style.userSelect = Z), l.getAttribute("style") === "" && l.removeAttribute("style"), sh.delete(l);
  }
}
const Ta = tl.createContext({
  register: () => {
  }
});
Ta.displayName = "PressResponderContext";
function wf(l, Z) {
  return Z.get ? Z.get.call(l) : Z.value;
}
function o1(l, Z, u) {
  if (!Z.has(l)) throw new TypeError("attempted to " + u + " private field on non-instance");
  return Z.get(l);
}
function zf(l, Z) {
  var u = o1(l, Z, "get");
  return wf(l, u);
}
function Jf(l, Z) {
  if (Z.has(l))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Hf(l, Z, u) {
  Jf(l, Z), Z.set(l, u);
}
function gf(l, Z, u) {
  if (Z.set) Z.set.call(l, u);
  else {
    if (!Z.writable)
      throw new TypeError("attempted to set read only private field");
    Z.value = u;
  }
}
function u2(l, Z, u) {
  var s = o1(l, Z, "set");
  return gf(l, s, u), u;
}
function vf(l) {
  let Z = M.useContext(Ta);
  if (Z) {
    let { register: u, ...s } = Z;
    l = HZ(s, l), u();
  }
  return XV(Z, l.ref), l;
}
var fL = /* @__PURE__ */ new WeakMap();
class EL {
  continuePropagation() {
    u2(this, fL, !1);
  }
  get shouldStopPropagation() {
    return zf(this, fL);
  }
  constructor(Z, u, s, G) {
    Hf(this, fL, {
      writable: !0,
      value: void 0
    }), u2(this, fL, !0);
    var i;
    let m = (i = G == null ? void 0 : G.target) !== null && i !== void 0 ? i : s.currentTarget;
    const a = m == null ? void 0 : m.getBoundingClientRect();
    let n, p = 0, y, h = null;
    s.clientX != null && s.clientY != null && (y = s.clientX, h = s.clientY), a && (y != null && h != null ? (n = y - a.left, p = h - a.top) : (n = a.width / 2, p = a.height / 2)), this.type = Z, this.pointerType = u, this.target = s.currentTarget, this.shiftKey = s.shiftKey, this.metaKey = s.metaKey, this.ctrlKey = s.ctrlKey, this.altKey = s.altKey, this.x = n, this.y = p;
  }
}
const s2 = Symbol("linkClicked");
function hn(l) {
  let {
    onPress: Z,
    onPressChange: u,
    onPressStart: s,
    onPressEnd: G,
    onPressUp: i,
    isDisabled: m,
    isPressed: a,
    preventFocusOnPress: n,
    shouldCancelOnPointerExit: p,
    allowTextSelectionOnPress: y,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ref: h,
    ...S
  } = vf(l), [t, W] = M.useState(!1), V = M.useRef({
    isPressed: !1,
    ignoreEmulatedMouseEvents: !1,
    ignoreClickAfterPress: !1,
    didFirePressStart: !1,
    isTriggeringEvent: !1,
    activePointerId: null,
    target: null,
    isOverTarget: !1,
    pointerType: null
  }), { addGlobalListener: R, removeAllGlobalListeners: x } = pn(), r = gb((C, j) => {
    let E = V.current;
    if (m || E.didFirePressStart) return !1;
    let g = !0;
    if (E.isTriggeringEvent = !0, s) {
      let A = new EL("pressstart", j, C);
      s(A), g = A.shouldStopPropagation;
    }
    return u && u(!0), E.isTriggeringEvent = !1, E.didFirePressStart = !0, W(!0), g;
  }), k = gb((C, j, E = !0) => {
    let g = V.current;
    if (!g.didFirePressStart) return !1;
    g.ignoreClickAfterPress = !0, g.didFirePressStart = !1, g.isTriggeringEvent = !0;
    let A = !0;
    if (G) {
      let J = new EL("pressend", j, C);
      G(J), A = J.shouldStopPropagation;
    }
    if (u && u(!1), W(!1), Z && E && !m) {
      let J = new EL("press", j, C);
      Z(J), A && (A = J.shouldStopPropagation);
    }
    return g.isTriggeringEvent = !1, A;
  }), U = gb((C, j) => {
    let E = V.current;
    if (m) return !1;
    if (i) {
      E.isTriggeringEvent = !0;
      let g = new EL("pressup", j, C);
      return i(g), E.isTriggeringEvent = !1, g.shouldStopPropagation;
    }
    return !0;
  }), w = gb((C) => {
    let j = V.current;
    j.isPressed && j.target && (j.isOverTarget && j.pointerType != null && k(_s(j.target, C), j.pointerType, !1), j.isPressed = !1, j.isOverTarget = !1, j.activePointerId = null, j.pointerType = null, x(), y || ka(j.target));
  }), z = gb((C) => {
    p && w(C);
  }), D = M.useMemo(() => {
    let C = V.current, j = {
      onKeyDown(g) {
        if (MK(g.nativeEvent, g.currentTarget) && g.currentTarget.contains(g.target)) {
          var A;
          G2(g.target, g.key) && g.preventDefault();
          let J = !0;
          if (!C.isPressed && !g.repeat) {
            C.target = g.currentTarget, C.isPressed = !0, J = r(g, "keyboard");
            let F = g.currentTarget, v = (T) => {
              MK(T, F) && !T.repeat && F.contains(T.target) && C.target && U(_s(C.target, T), "keyboard");
            };
            R(_Z(g.currentTarget), "keyup", Ha(v, E), !0);
          }
          J && g.stopPropagation(), g.metaKey && Sm() && ((A = C.metaKeyEvents) === null || A === void 0 || A.set(g.key, g.nativeEvent));
        } else g.key === "Meta" && (C.metaKeyEvents = /* @__PURE__ */ new Map());
      },
      onClick(g) {
        if (!(g && !g.currentTarget.contains(g.target)) && g && g.button === 0 && !C.isTriggeringEvent && !tm.isOpening) {
          let A = !0;
          if (m && g.preventDefault(), !C.ignoreClickAfterPress && !C.ignoreEmulatedMouseEvents && !C.isPressed && (C.pointerType === "virtual" || eW(g.nativeEvent))) {
            !m && !n && Ls(g.currentTarget);
            let J = r(g, "virtual"), F = U(g, "virtual"), v = k(g, "virtual");
            A = J && F && v;
          }
          C.ignoreEmulatedMouseEvents = !1, C.ignoreClickAfterPress = !1, A && g.stopPropagation();
        }
      }
    }, E = (g) => {
      var A;
      if (C.isPressed && C.target && MK(g, C.target)) {
        var J;
        G2(g.target, g.key) && g.preventDefault();
        let v = g.target;
        k(_s(C.target, g), "keyboard", C.target.contains(v)), x(), g.key !== "Enter" && WV(C.target) && C.target.contains(v) && !g[s2] && (g[s2] = !0, tm(C.target, g, !1)), C.isPressed = !1, (J = C.metaKeyEvents) === null || J === void 0 || J.delete(g.key);
      } else if (g.key === "Meta" && (!((A = C.metaKeyEvents) === null || A === void 0) && A.size)) {
        var F;
        let v = C.metaKeyEvents;
        C.metaKeyEvents = void 0;
        for (let T of v.values()) (F = C.target) === null || F === void 0 || F.dispatchEvent(new KeyboardEvent("keyup", T));
      }
    };
    if (typeof PointerEvent < "u") {
      j.onPointerDown = (v) => {
        if (v.button !== 0 || !v.currentTarget.contains(v.target)) return;
        if (yf(v.nativeEvent)) {
          C.pointerType = "virtual";
          return;
        }
        IK(v.currentTarget) && v.preventDefault(), C.pointerType = v.pointerType;
        let T = !0;
        C.isPressed || (C.isPressed = !0, C.isOverTarget = !0, C.activePointerId = v.pointerId, C.target = v.currentTarget, !m && !n && Ls(v.currentTarget), y || LW(C.target), T = r(v, C.pointerType), R(_Z(v.currentTarget), "pointermove", g, !1), R(_Z(v.currentTarget), "pointerup", A, !1), R(_Z(v.currentTarget), "pointercancel", F, !1)), T && v.stopPropagation();
      }, j.onMouseDown = (v) => {
        v.currentTarget.contains(v.target) && v.button === 0 && (IK(v.currentTarget) && v.preventDefault(), v.stopPropagation());
      }, j.onPointerUp = (v) => {
        !v.currentTarget.contains(v.target) || C.pointerType === "virtual" || v.button === 0 && wi(v, v.currentTarget) && U(v, C.pointerType || v.pointerType);
      };
      let g = (v) => {
        v.pointerId === C.activePointerId && (C.target && wi(v, C.target) ? !C.isOverTarget && C.pointerType != null && (C.isOverTarget = !0, r(_s(C.target, v), C.pointerType)) : C.target && C.isOverTarget && C.pointerType != null && (C.isOverTarget = !1, k(_s(C.target, v), C.pointerType, !1), z(v)));
      }, A = (v) => {
        v.pointerId === C.activePointerId && C.isPressed && v.button === 0 && C.target && (wi(v, C.target) && C.pointerType != null ? k(_s(C.target, v), C.pointerType) : C.isOverTarget && C.pointerType != null && k(_s(C.target, v), C.pointerType, !1), C.isPressed = !1, C.isOverTarget = !1, C.activePointerId = null, C.pointerType = null, x(), y || ka(C.target), "ontouchend" in C.target && v.pointerType !== "mouse" && R(C.target, "touchend", J, {
          once: !0
        }));
      }, J = (v) => {
        e1(v.target) && v.preventDefault();
      }, F = (v) => {
        w(v);
      };
      j.onDragStart = (v) => {
        v.currentTarget.contains(v.target) && w(v);
      };
    } else {
      j.onMouseDown = (J) => {
        if (J.button !== 0 || !J.currentTarget.contains(J.target)) return;
        if (IK(J.currentTarget) && J.preventDefault(), C.ignoreEmulatedMouseEvents) {
          J.stopPropagation();
          return;
        }
        C.isPressed = !0, C.isOverTarget = !0, C.target = J.currentTarget, C.pointerType = eW(J.nativeEvent) ? "virtual" : "mouse", !m && !n && Ls(J.currentTarget), r(J, C.pointerType) && J.stopPropagation(), R(_Z(J.currentTarget), "mouseup", g, !1);
      }, j.onMouseEnter = (J) => {
        if (!J.currentTarget.contains(J.target)) return;
        let F = !0;
        C.isPressed && !C.ignoreEmulatedMouseEvents && C.pointerType != null && (C.isOverTarget = !0, F = r(J, C.pointerType)), F && J.stopPropagation();
      }, j.onMouseLeave = (J) => {
        if (!J.currentTarget.contains(J.target)) return;
        let F = !0;
        C.isPressed && !C.ignoreEmulatedMouseEvents && C.pointerType != null && (C.isOverTarget = !1, F = k(J, C.pointerType, !1), z(J)), F && J.stopPropagation();
      }, j.onMouseUp = (J) => {
        J.currentTarget.contains(J.target) && !C.ignoreEmulatedMouseEvents && J.button === 0 && U(J, C.pointerType || "mouse");
      };
      let g = (J) => {
        if (J.button === 0) {
          if (C.isPressed = !1, x(), C.ignoreEmulatedMouseEvents) {
            C.ignoreEmulatedMouseEvents = !1;
            return;
          }
          C.target && wi(J, C.target) && C.pointerType != null ? k(_s(C.target, J), C.pointerType) : C.target && C.isOverTarget && C.pointerType != null && k(_s(C.target, J), C.pointerType, !1), C.isOverTarget = !1;
        }
      };
      j.onTouchStart = (J) => {
        if (!J.currentTarget.contains(J.target)) return;
        let F = Tf(J.nativeEvent);
        if (!F) return;
        C.activePointerId = F.identifier, C.ignoreEmulatedMouseEvents = !0, C.isOverTarget = !0, C.isPressed = !0, C.target = J.currentTarget, C.pointerType = "touch", !m && !n && Ls(J.currentTarget), y || LW(C.target), r(qd(C.target, J), C.pointerType) && J.stopPropagation(), R(Eu(J.currentTarget), "scroll", A, !0);
      }, j.onTouchMove = (J) => {
        if (!J.currentTarget.contains(J.target)) return;
        if (!C.isPressed) {
          J.stopPropagation();
          return;
        }
        let F = d2(J.nativeEvent, C.activePointerId), v = !0;
        F && wi(F, J.currentTarget) ? !C.isOverTarget && C.pointerType != null && (C.isOverTarget = !0, v = r(qd(C.target, J), C.pointerType)) : C.isOverTarget && C.pointerType != null && (C.isOverTarget = !1, v = k(qd(C.target, J), C.pointerType, !1), z(qd(C.target, J))), v && J.stopPropagation();
      }, j.onTouchEnd = (J) => {
        if (!J.currentTarget.contains(J.target)) return;
        if (!C.isPressed) {
          J.stopPropagation();
          return;
        }
        let F = d2(J.nativeEvent, C.activePointerId), v = !0;
        F && wi(F, J.currentTarget) && C.pointerType != null ? (U(qd(C.target, J), C.pointerType), v = k(qd(C.target, J), C.pointerType)) : C.isOverTarget && C.pointerType != null && (v = k(qd(C.target, J), C.pointerType, !1)), v && J.stopPropagation(), C.isPressed = !1, C.activePointerId = null, C.isOverTarget = !1, C.ignoreEmulatedMouseEvents = !0, C.target && !y && ka(C.target), x();
      }, j.onTouchCancel = (J) => {
        J.currentTarget.contains(J.target) && (J.stopPropagation(), C.isPressed && w(qd(C.target, J)));
      };
      let A = (J) => {
        C.isPressed && J.target.contains(C.target) && w({
          currentTarget: C.target,
          shiftKey: !1,
          ctrlKey: !1,
          metaKey: !1,
          altKey: !1
        });
      };
      j.onDragStart = (J) => {
        J.currentTarget.contains(J.target) && w(J);
      };
    }
    return j;
  }, [
    R,
    m,
    n,
    x,
    y,
    w,
    z,
    k,
    r,
    U
  ]);
  return M.useEffect(() => () => {
    var C;
    y || ka((C = V.current.target) !== null && C !== void 0 ? C : void 0);
  }, [
    y
  ]), {
    isPressed: a || t,
    pressProps: HZ(S, D)
  };
}
function WV(l) {
  return l.tagName === "A" && l.hasAttribute("href");
}
function MK(l, Z) {
  const { key: u, code: s } = l, G = Z, i = G.getAttribute("role");
  return (u === "Enter" || u === " " || u === "Spacebar" || s === "Space") && !(G instanceof Eu(G).HTMLInputElement && !a1(G, u) || G instanceof Eu(G).HTMLTextAreaElement || G.isContentEditable) && // Links should only trigger with Enter key
  !((i === "link" || !i && WV(G)) && u !== "Enter");
}
function Tf(l) {
  const { targetTouches: Z } = l;
  return Z.length > 0 ? Z[0] : null;
}
function d2(l, Z) {
  const u = l.changedTouches;
  for (let s = 0; s < u.length; s++) {
    const G = u[s];
    if (G.identifier === Z) return G;
  }
  return null;
}
function qd(l, Z) {
  let u = 0, s = 0;
  return Z.targetTouches && Z.targetTouches.length === 1 && (u = Z.targetTouches[0].clientX, s = Z.targetTouches[0].clientY), {
    currentTarget: l,
    shiftKey: Z.shiftKey,
    ctrlKey: Z.ctrlKey,
    metaKey: Z.metaKey,
    altKey: Z.altKey,
    clientX: u,
    clientY: s
  };
}
function _s(l, Z) {
  let u = Z.clientX, s = Z.clientY;
  return {
    currentTarget: l,
    shiftKey: Z.shiftKey,
    ctrlKey: Z.ctrlKey,
    metaKey: Z.metaKey,
    altKey: Z.altKey,
    clientX: u,
    clientY: s
  };
}
function ff(l) {
  let Z = 0, u = 0;
  return l.width !== void 0 ? Z = l.width / 2 : l.radiusX !== void 0 && (Z = l.radiusX), l.height !== void 0 ? u = l.height / 2 : l.radiusY !== void 0 && (u = l.radiusY), {
    top: l.clientY - u,
    right: l.clientX + Z,
    bottom: l.clientY + u,
    left: l.clientX - Z
  };
}
function Ef(l, Z) {
  return !(l.left > Z.right || Z.left > l.right || l.top > Z.bottom || Z.top > l.bottom);
}
function wi(l, Z) {
  let u = Z.getBoundingClientRect(), s = ff(l);
  return Ef(u, s);
}
function IK(l) {
  return !(l instanceof HTMLElement) || !l.hasAttribute("draggable");
}
function e1(l) {
  return l instanceof HTMLInputElement ? !1 : l instanceof HTMLButtonElement ? l.type !== "submit" && l.type !== "reset" : !WV(l);
}
function G2(l, Z) {
  return l instanceof HTMLInputElement ? !a1(l, Z) : e1(l);
}
const Bf = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function a1(l, Z) {
  return l.type === "checkbox" || l.type === "radio" ? Z === " " : Bf.has(l.type);
}
const Df = /* @__PURE__ */ tl.forwardRef(({ children: l, ...Z }, u) => {
  let s = M.useRef(!1), G = M.useContext(Ta);
  u = tV(u || (G == null ? void 0 : G.ref));
  let i = HZ(G || {}, {
    ...Z,
    ref: u,
    register() {
      s.current = !0, G && G.register();
    }
  });
  return XV(G, u), M.useEffect(() => {
    s.current || (console.warn("A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component."), s.current = !0);
  }, []), /* @__PURE__ */ tl.createElement(Ta.Provider, {
    value: i
  }, l);
});
function jf({ children: l }) {
  let Z = M.useMemo(() => ({
    register: () => {
    }
  }), []);
  return /* @__PURE__ */ tl.createElement(Ta.Provider, {
    value: Z
  }, l);
}
class Qf {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(Z, u) {
    this.nativeEvent = u, this.target = u.target, this.currentTarget = u.currentTarget, this.relatedTarget = u.relatedTarget, this.bubbles = u.bubbles, this.cancelable = u.cancelable, this.defaultPrevented = u.defaultPrevented, this.eventPhase = u.eventPhase, this.isTrusted = u.isTrusted, this.timeStamp = u.timeStamp, this.type = Z;
  }
}
function n1(l) {
  let Z = M.useRef({
    isFocused: !1,
    observer: null
  });
  PZ(() => {
    const s = Z.current;
    return () => {
      s.observer && (s.observer.disconnect(), s.observer = null);
    };
  }, []);
  let u = gb((s) => {
    l == null || l(s);
  });
  return M.useCallback((s) => {
    if (s.target instanceof HTMLButtonElement || s.target instanceof HTMLInputElement || s.target instanceof HTMLTextAreaElement || s.target instanceof HTMLSelectElement) {
      Z.current.isFocused = !0;
      let G = s.target, i = (m) => {
        Z.current.isFocused = !1, G.disabled && u(new Qf("blur", m)), Z.current.observer && (Z.current.observer.disconnect(), Z.current.observer = null);
      };
      G.addEventListener("focusout", i, {
        once: !0
      }), Z.current.observer = new MutationObserver(() => {
        if (Z.current.isFocused && G.disabled) {
          var m;
          (m = Z.current.observer) === null || m === void 0 || m.disconnect();
          let a = G === document.activeElement ? null : document.activeElement;
          G.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: a
          })), G.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: a
          }));
        }
      }), Z.current.observer.observe(G, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    u
  ]);
}
function VV(l) {
  let { isDisabled: Z, onFocus: u, onBlur: s, onFocusChange: G } = l;
  const i = M.useCallback((n) => {
    if (n.target === n.currentTarget)
      return s && s(n), G && G(!1), !0;
  }, [
    s,
    G
  ]), m = n1(i), a = M.useCallback((n) => {
    const p = _Z(n.target);
    n.target === n.currentTarget && p.activeElement === n.target && (u && u(n), G && G(!0), m(n));
  }, [
    G,
    u,
    m
  ]);
  return {
    focusProps: {
      onFocus: !Z && (u || G || s) ? a : void 0,
      onBlur: !Z && (s || G) ? i : void 0
    }
  };
}
let nd = null, fa = /* @__PURE__ */ new Set(), Fa = /* @__PURE__ */ new Map(), Xm = !1, hW = !1;
const Pf = {
  Tab: !0,
  Escape: !0
};
function vh(l, Z) {
  for (let u of fa) u(l, Z);
}
function Of(l) {
  return !(l.metaKey || !Sm() && l.altKey || l.ctrlKey || l.key === "Control" || l.key === "Shift" || l.key === "Meta");
}
function ah(l) {
  Xm = !0, Of(l) && (nd = "keyboard", vh("keyboard", l));
}
function Lu(l) {
  nd = "pointer", (l.type === "mousedown" || l.type === "pointerdown") && (Xm = !0, vh("pointer", l));
}
function p1(l) {
  eW(l) && (Xm = !0, nd = "virtual");
}
function L1(l) {
  l.target === window || l.target === document || (!Xm && !hW && (nd = "virtual", vh("virtual", l)), Xm = !1, hW = !1);
}
function h1() {
  Xm = !1, hW = !0;
}
function nh(l) {
  if (typeof window > "u" || Fa.get(Eu(l))) return;
  const Z = Eu(l), u = _Z(l);
  let s = Z.HTMLElement.prototype.focus;
  Z.HTMLElement.prototype.focus = function() {
    Xm = !0, s.apply(this, arguments);
  }, u.addEventListener("keydown", ah, !0), u.addEventListener("keyup", ah, !0), u.addEventListener("click", p1, !0), Z.addEventListener("focus", L1, !0), Z.addEventListener("blur", h1, !1), typeof PointerEvent < "u" ? (u.addEventListener("pointerdown", Lu, !0), u.addEventListener("pointermove", Lu, !0), u.addEventListener("pointerup", Lu, !0)) : (u.addEventListener("mousedown", Lu, !0), u.addEventListener("mousemove", Lu, !0), u.addEventListener("mouseup", Lu, !0)), Z.addEventListener("beforeunload", () => {
    y1(l);
  }, {
    once: !0
  }), Fa.set(Z, {
    focus: s
  });
}
const y1 = (l, Z) => {
  const u = Eu(l), s = _Z(l);
  Z && s.removeEventListener("DOMContentLoaded", Z), Fa.has(u) && (u.HTMLElement.prototype.focus = Fa.get(u).focus, s.removeEventListener("keydown", ah, !0), s.removeEventListener("keyup", ah, !0), s.removeEventListener("click", p1, !0), u.removeEventListener("focus", L1, !0), u.removeEventListener("blur", h1, !1), typeof PointerEvent < "u" ? (s.removeEventListener("pointerdown", Lu, !0), s.removeEventListener("pointermove", Lu, !0), s.removeEventListener("pointerup", Lu, !0)) : (s.removeEventListener("mousedown", Lu, !0), s.removeEventListener("mousemove", Lu, !0), s.removeEventListener("mouseup", Lu, !0)), Fa.delete(u));
};
function Af(l) {
  const Z = _Z(l);
  let u;
  return Z.readyState !== "loading" ? nh(l) : (u = () => {
    nh(l);
  }, Z.addEventListener("DOMContentLoaded", u)), () => y1(l, u);
}
typeof document < "u" && Af();
function xV() {
  return nd !== "pointer";
}
function yW() {
  return nd;
}
function $f(l) {
  nd = l, vh(l, null);
}
function U_() {
  nh();
  let [l, Z] = M.useState(nd);
  return M.useEffect(() => {
    let u = () => {
      Z(nd);
    };
    return fa.add(u), () => {
      fa.delete(u);
    };
  }, []), Mm() ? null : l;
}
const qf = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function _f(l, Z, u) {
  var s;
  const G = typeof window < "u" ? Eu(u == null ? void 0 : u.target).HTMLInputElement : HTMLInputElement, i = typeof window < "u" ? Eu(u == null ? void 0 : u.target).HTMLTextAreaElement : HTMLTextAreaElement, m = typeof window < "u" ? Eu(u == null ? void 0 : u.target).HTMLElement : HTMLElement, a = typeof window < "u" ? Eu(u == null ? void 0 : u.target).KeyboardEvent : KeyboardEvent;
  return l = l || (u == null ? void 0 : u.target) instanceof G && !qf.has(u == null || (s = u.target) === null || s === void 0 ? void 0 : s.type) || (u == null ? void 0 : u.target) instanceof i || (u == null ? void 0 : u.target) instanceof m && (u == null ? void 0 : u.target.isContentEditable), !(l && Z === "keyboard" && u instanceof a && !Pf[u.key]);
}
function lE(l, Z, u) {
  nh(), M.useEffect(() => {
    let s = (G, i) => {
      _f(!!(u != null && u.isTextInput), G, i) && l(xV());
    };
    return fa.add(s), () => {
      fa.delete(s);
    };
  }, Z);
}
function RV(l) {
  let { isDisabled: Z, onBlurWithin: u, onFocusWithin: s, onFocusWithinChange: G } = l, i = M.useRef({
    isFocusWithin: !1
  }), m = M.useCallback((p) => {
    i.current.isFocusWithin && !p.currentTarget.contains(p.relatedTarget) && (i.current.isFocusWithin = !1, u && u(p), G && G(!1));
  }, [
    u,
    G,
    i
  ]), a = n1(m), n = M.useCallback((p) => {
    !i.current.isFocusWithin && document.activeElement === p.target && (s && s(p), G && G(!0), i.current.isFocusWithin = !0, a(p));
  }, [
    s,
    G,
    a
  ]);
  return Z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: n,
      onBlur: m
    }
  };
}
let ph = !1, UK = 0;
function SW() {
  ph = !0, setTimeout(() => {
    ph = !1;
  }, 50);
}
function m2(l) {
  l.pointerType === "touch" && SW();
}
function ZE() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", m2) : document.addEventListener("touchend", SW), UK++, () => {
      UK--, !(UK > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", m2) : document.removeEventListener("touchend", SW));
    };
}
function Ro(l) {
  let { onHoverStart: Z, onHoverChange: u, onHoverEnd: s, isDisabled: G } = l, [i, m] = M.useState(!1), a = M.useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  M.useEffect(ZE, []);
  let { hoverProps: n, triggerHoverEnd: p } = M.useMemo(() => {
    let y = (t, W) => {
      if (a.pointerType = W, G || W === "touch" || a.isHovered || !t.currentTarget.contains(t.target)) return;
      a.isHovered = !0;
      let V = t.currentTarget;
      a.target = V, Z && Z({
        type: "hoverstart",
        target: V,
        pointerType: W
      }), u && u(!0), m(!0);
    }, h = (t, W) => {
      if (a.pointerType = "", a.target = null, W === "touch" || !a.isHovered) return;
      a.isHovered = !1;
      let V = t.currentTarget;
      s && s({
        type: "hoverend",
        target: V,
        pointerType: W
      }), u && u(!1), m(!1);
    }, S = {};
    return typeof PointerEvent < "u" ? (S.onPointerEnter = (t) => {
      ph && t.pointerType === "mouse" || y(t, t.pointerType);
    }, S.onPointerLeave = (t) => {
      !G && t.currentTarget.contains(t.target) && h(t, t.pointerType);
    }) : (S.onTouchStart = () => {
      a.ignoreEmulatedMouseEvents = !0;
    }, S.onMouseEnter = (t) => {
      !a.ignoreEmulatedMouseEvents && !ph && y(t, "mouse"), a.ignoreEmulatedMouseEvents = !1;
    }, S.onMouseLeave = (t) => {
      !G && t.currentTarget.contains(t.target) && h(t, "mouse");
    }), {
      hoverProps: S,
      triggerHoverEnd: h
    };
  }, [
    Z,
    u,
    s,
    G,
    a
  ]);
  return M.useEffect(() => {
    G && p({
      currentTarget: a.target
    }, a.pointerType);
  }, [
    G
  ]), {
    hoverProps: n,
    isHovered: i
  };
}
function S1(l) {
  let { ref: Z, onInteractOutside: u, isDisabled: s, onInteractOutsideStart: G } = l, i = M.useRef({
    isPointerDown: !1,
    ignoreEmulatedMouseEvents: !1
  }), m = gb((n) => {
    u && BL(n, Z) && (G && G(n), i.current.isPointerDown = !0);
  }), a = gb((n) => {
    u && u(n);
  });
  M.useEffect(() => {
    let n = i.current;
    if (s) return;
    const p = Z.current, y = _Z(p);
    if (typeof PointerEvent < "u") {
      let h = (S) => {
        n.isPointerDown && BL(S, Z) && a(S), n.isPointerDown = !1;
      };
      return y.addEventListener("pointerdown", m, !0), y.addEventListener("pointerup", h, !0), () => {
        y.removeEventListener("pointerdown", m, !0), y.removeEventListener("pointerup", h, !0);
      };
    } else {
      let h = (t) => {
        n.ignoreEmulatedMouseEvents ? n.ignoreEmulatedMouseEvents = !1 : n.isPointerDown && BL(t, Z) && a(t), n.isPointerDown = !1;
      }, S = (t) => {
        n.ignoreEmulatedMouseEvents = !0, n.isPointerDown && BL(t, Z) && a(t), n.isPointerDown = !1;
      };
      return y.addEventListener("mousedown", m, !0), y.addEventListener("mouseup", h, !0), y.addEventListener("touchstart", m, !0), y.addEventListener("touchend", S, !0), () => {
        y.removeEventListener("mousedown", m, !0), y.removeEventListener("mouseup", h, !0), y.removeEventListener("touchstart", m, !0), y.removeEventListener("touchend", S, !0);
      };
    }
  }, [
    Z,
    s,
    m,
    a
  ]);
}
function BL(l, Z) {
  if (l.button > 0) return !1;
  if (l.target) {
    const u = l.target.ownerDocument;
    if (!u || !u.documentElement.contains(l.target) || l.target.closest("[data-react-aria-top-layer]")) return !1;
  }
  return Z.current && !Z.current.contains(l.target);
}
function i2(l) {
  if (!l) return;
  let Z = !0;
  return (u) => {
    let s = {
      ...u,
      preventDefault() {
        u.preventDefault();
      },
      isDefaultPrevented() {
        return u.isDefaultPrevented();
      },
      stopPropagation() {
        console.error("stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.");
      },
      continuePropagation() {
        Z = !1;
      }
    };
    l(s), Z && u.stopPropagation();
  };
}
function YV(l) {
  return {
    keyboardProps: l.isDisabled ? {} : {
      onKeyDown: i2(l.onKeyDown),
      onKeyUp: i2(l.onKeyUp)
    }
  };
}
function t1(l) {
  let { onMoveStart: Z, onMove: u, onMoveEnd: s } = l, G = M.useRef({
    didMove: !1,
    lastPosition: null,
    id: null
  }), { addGlobalListener: i, removeGlobalListener: m } = pn(), a = gb((y, h, S, t) => {
    S === 0 && t === 0 || (G.current.didMove || (G.current.didMove = !0, Z == null || Z({
      type: "movestart",
      pointerType: h,
      shiftKey: y.shiftKey,
      metaKey: y.metaKey,
      ctrlKey: y.ctrlKey,
      altKey: y.altKey
    })), u == null || u({
      type: "move",
      pointerType: h,
      deltaX: S,
      deltaY: t,
      shiftKey: y.shiftKey,
      metaKey: y.metaKey,
      ctrlKey: y.ctrlKey,
      altKey: y.altKey
    }));
  }), n = gb((y, h) => {
    ka(), G.current.didMove && (s == null || s({
      type: "moveend",
      pointerType: h,
      shiftKey: y.shiftKey,
      metaKey: y.metaKey,
      ctrlKey: y.ctrlKey,
      altKey: y.altKey
    }));
  });
  return {
    moveProps: M.useMemo(() => {
      let y = {}, h = () => {
        LW(), G.current.didMove = !1;
      };
      if (typeof PointerEvent > "u") {
        let t = (x) => {
          if (x.button === 0) {
            var r, k, U, w;
            a(x, "mouse", x.pageX - ((U = (r = G.current.lastPosition) === null || r === void 0 ? void 0 : r.pageX) !== null && U !== void 0 ? U : 0), x.pageY - ((w = (k = G.current.lastPosition) === null || k === void 0 ? void 0 : k.pageY) !== null && w !== void 0 ? w : 0)), G.current.lastPosition = {
              pageX: x.pageX,
              pageY: x.pageY
            };
          }
        }, W = (x) => {
          x.button === 0 && (n(x, "mouse"), m(window, "mousemove", t, !1), m(window, "mouseup", W, !1));
        };
        y.onMouseDown = (x) => {
          x.button === 0 && (h(), x.stopPropagation(), x.preventDefault(), G.current.lastPosition = {
            pageX: x.pageX,
            pageY: x.pageY
          }, i(window, "mousemove", t, !1), i(window, "mouseup", W, !1));
        };
        let V = (x) => {
          let r = [
            ...x.changedTouches
          ].findIndex(({ identifier: D }) => D === G.current.id);
          if (r >= 0) {
            var k, U;
            let { pageX: D, pageY: C } = x.changedTouches[r];
            var w, z;
            a(x, "touch", D - ((w = (k = G.current.lastPosition) === null || k === void 0 ? void 0 : k.pageX) !== null && w !== void 0 ? w : 0), C - ((z = (U = G.current.lastPosition) === null || U === void 0 ? void 0 : U.pageY) !== null && z !== void 0 ? z : 0)), G.current.lastPosition = {
              pageX: D,
              pageY: C
            };
          }
        }, R = (x) => {
          [
            ...x.changedTouches
          ].findIndex(({ identifier: k }) => k === G.current.id) >= 0 && (n(x, "touch"), G.current.id = null, m(window, "touchmove", V), m(window, "touchend", R), m(window, "touchcancel", R));
        };
        y.onTouchStart = (x) => {
          if (x.changedTouches.length === 0 || G.current.id != null) return;
          let { pageX: r, pageY: k, identifier: U } = x.changedTouches[0];
          h(), x.stopPropagation(), x.preventDefault(), G.current.lastPosition = {
            pageX: r,
            pageY: k
          }, G.current.id = U, i(window, "touchmove", V, !1), i(window, "touchend", R, !1), i(window, "touchcancel", R, !1);
        };
      } else {
        let t = (V) => {
          if (V.pointerId === G.current.id) {
            var R, x;
            let U = V.pointerType || "mouse";
            var r, k;
            a(V, U, V.pageX - ((r = (R = G.current.lastPosition) === null || R === void 0 ? void 0 : R.pageX) !== null && r !== void 0 ? r : 0), V.pageY - ((k = (x = G.current.lastPosition) === null || x === void 0 ? void 0 : x.pageY) !== null && k !== void 0 ? k : 0)), G.current.lastPosition = {
              pageX: V.pageX,
              pageY: V.pageY
            };
          }
        }, W = (V) => {
          if (V.pointerId === G.current.id) {
            let R = V.pointerType || "mouse";
            n(V, R), G.current.id = null, m(window, "pointermove", t, !1), m(window, "pointerup", W, !1), m(window, "pointercancel", W, !1);
          }
        };
        y.onPointerDown = (V) => {
          V.button === 0 && G.current.id == null && (h(), V.stopPropagation(), V.preventDefault(), G.current.lastPosition = {
            pageX: V.pageX,
            pageY: V.pageY
          }, G.current.id = V.pointerId, i(window, "pointermove", t, !1), i(window, "pointerup", W, !1), i(window, "pointercancel", W, !1));
        };
      }
      let S = (t, W, V) => {
        h(), a(t, "keyboard", W, V), n(t, "keyboard");
      };
      return y.onKeyDown = (t) => {
        switch (t.key) {
          case "Left":
          case "ArrowLeft":
            t.preventDefault(), t.stopPropagation(), S(t, -1, 0);
            break;
          case "Right":
          case "ArrowRight":
            t.preventDefault(), t.stopPropagation(), S(t, 1, 0);
            break;
          case "Up":
          case "ArrowUp":
            t.preventDefault(), t.stopPropagation(), S(t, 0, -1);
            break;
          case "Down":
          case "ArrowDown":
            t.preventDefault(), t.stopPropagation(), S(t, 0, 1);
            break;
        }
      }, y;
    }, [
      G,
      i,
      m,
      a,
      n
    ])
  };
}
const cE = 500;
function X1(l) {
  let { isDisabled: Z, onLongPressStart: u, onLongPressEnd: s, onLongPress: G, threshold: i = cE, accessibilityDescription: m } = l;
  const a = M.useRef(void 0);
  let { addGlobalListener: n, removeGlobalListener: p } = pn(), { pressProps: y } = hn({
    isDisabled: Z,
    onPressStart(S) {
      if (S.continuePropagation(), (S.pointerType === "mouse" || S.pointerType === "touch") && (u && u({
        ...S,
        type: "longpressstart"
      }), a.current = setTimeout(() => {
        S.target.dispatchEvent(new PointerEvent("pointercancel", {
          bubbles: !0
        })), G && G({
          ...S,
          type: "longpress"
        }), a.current = void 0;
      }, i), S.pointerType === "touch")) {
        let t = (W) => {
          W.preventDefault();
        };
        n(S.target, "contextmenu", t, {
          once: !0
        }), n(window, "pointerup", () => {
          setTimeout(() => {
            p(S.target, "contextmenu", t);
          }, 30);
        }, {
          once: !0
        });
      }
    },
    onPressEnd(S) {
      a.current && clearTimeout(a.current), s && (S.pointerType === "mouse" || S.pointerType === "touch") && s({
        ...S,
        type: "longpressend"
      });
    }
  }), h = hf(G && !Z ? m : void 0);
  return {
    longPressProps: HZ(y, h)
  };
}
function Ea(l) {
  const Z = _Z(l);
  if (yW() === "virtual") {
    let u = Z.activeElement;
    Z1(() => {
      Z.activeElement === u && l.isConnected && Ls(l);
    });
  } else Ls(l);
}
function bE(l) {
  const Z = Eu(l);
  if (!(l instanceof Z.HTMLElement) && !(l instanceof Z.SVGElement)) return !1;
  let { display: u, visibility: s } = l.style, G = u !== "none" && s !== "hidden" && s !== "collapse";
  if (G) {
    const { getComputedStyle: i } = l.ownerDocument.defaultView;
    let { display: m, visibility: a } = i(l);
    G = m !== "none" && a !== "hidden" && a !== "collapse";
  }
  return G;
}
function uE(l, Z) {
  return !l.hasAttribute("hidden") && // Ignore HiddenSelect when tree walking.
  !l.hasAttribute("data-react-aria-prevent-focus") && (l.nodeName === "DETAILS" && Z && Z.nodeName !== "SUMMARY" ? l.hasAttribute("open") : !0);
}
function K1(l, Z) {
  return l.nodeName !== "#comment" && bE(l) && uE(l, Z) && (!l.parentElement || K1(l.parentElement, l));
}
const o2 = /* @__PURE__ */ tl.createContext(null), tW = "react-aria-focus-scope-restore";
let QZ = null;
function W1(l) {
  let { children: Z, contain: u, restoreFocus: s, autoFocus: G } = l, i = M.useRef(null), m = M.useRef(null), a = M.useRef([]), { parentNode: n } = M.useContext(o2) || {}, p = M.useMemo(() => new KW({
    scopeRef: a
  }), [
    a
  ]);
  PZ(() => {
    let S = n || Wc.root;
    if (Wc.getTreeNode(S.scopeRef) && QZ && !hh(QZ, S.scopeRef)) {
      let t = Wc.getTreeNode(QZ);
      t && (S = t);
    }
    S.addChild(p), Wc.addNode(p);
  }, [
    p,
    n
  ]), PZ(() => {
    let S = Wc.getTreeNode(a);
    S && (S.contain = !!u);
  }, [
    u
  ]), PZ(() => {
    var S;
    let t = (S = i.current) === null || S === void 0 ? void 0 : S.nextSibling, W = [], V = (R) => R.stopPropagation();
    for (; t && t !== m.current; )
      W.push(t), t.addEventListener(tW, V), t = t.nextSibling;
    return a.current = W, () => {
      for (let R of W) R.removeEventListener(tW, V);
    };
  }, [
    Z
  ]), eE(a, s, u), mE(a, u), nE(a, s, u), oE(a, G), M.useEffect(() => {
    const S = _Z(a.current ? a.current[0] : void 0).activeElement;
    let t = null;
    if (ab(S, a.current)) {
      for (let W of Wc.traverse()) W.scopeRef && ab(S, W.scopeRef.current) && (t = W);
      t === Wc.getTreeNode(a) && (QZ = t.scopeRef);
    }
  }, [
    a
  ]), PZ(() => () => {
    var S, t, W;
    let V = (W = (t = Wc.getTreeNode(a)) === null || t === void 0 || (S = t.parent) === null || S === void 0 ? void 0 : S.scopeRef) !== null && W !== void 0 ? W : null;
    (a === QZ || hh(a, QZ)) && (!V || Wc.getTreeNode(V)) && (QZ = V), Wc.removeTreeNode(a);
  }, [
    a
  ]);
  let y = M.useMemo(() => sE(a), []), h = M.useMemo(() => ({
    focusManager: y,
    parentNode: p
  }), [
    p,
    y
  ]);
  return /* @__PURE__ */ tl.createElement(o2.Provider, {
    value: h
  }, /* @__PURE__ */ tl.createElement("span", {
    "data-focus-scope-start": !0,
    hidden: !0,
    ref: i
  }), Z, /* @__PURE__ */ tl.createElement("span", {
    "data-focus-scope-end": !0,
    hidden: !0,
    ref: m
  }));
}
function sE(l) {
  return {
    focusNext(Z = {}) {
      let u = l.current, { from: s, tabbable: G, wrap: i, accept: m } = Z, a = s || _Z(u[0]).activeElement, n = u[0].previousElementSibling, p = sm(u), y = sd(p, {
        tabbable: G,
        accept: m
      }, u);
      y.currentNode = ab(a, u) ? a : n;
      let h = y.nextNode();
      return !h && i && (y.currentNode = n, h = y.nextNode()), h && ud(h, !0), h;
    },
    focusPrevious(Z = {}) {
      let u = l.current, { from: s, tabbable: G, wrap: i, accept: m } = Z, a = s || _Z(u[0]).activeElement, n = u[u.length - 1].nextElementSibling, p = sm(u), y = sd(p, {
        tabbable: G,
        accept: m
      }, u);
      y.currentNode = ab(a, u) ? a : n;
      let h = y.previousNode();
      return !h && i && (y.currentNode = n, h = y.previousNode()), h && ud(h, !0), h;
    },
    focusFirst(Z = {}) {
      let u = l.current, { tabbable: s, accept: G } = Z, i = sm(u), m = sd(i, {
        tabbable: s,
        accept: G
      }, u);
      m.currentNode = u[0].previousElementSibling;
      let a = m.nextNode();
      return a && ud(a, !0), a;
    },
    focusLast(Z = {}) {
      let u = l.current, { tabbable: s, accept: G } = Z, i = sm(u), m = sd(i, {
        tabbable: s,
        accept: G
      }, u);
      m.currentNode = u[u.length - 1].nextElementSibling;
      let a = m.previousNode();
      return a && ud(a, !0), a;
    }
  };
}
const kV = [
  "input:not([disabled]):not([type=hidden])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[contenteditable]"
], dE = kV.join(":not([hidden]),") + ",[tabindex]:not([disabled]):not([hidden])";
kV.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const GE = kV.join(':not([hidden]):not([tabindex="-1"]),');
function sm(l) {
  return l[0].parentElement;
}
function Ma(l) {
  let Z = Wc.getTreeNode(QZ);
  for (; Z && Z.scopeRef !== l; ) {
    if (Z.contain) return !1;
    Z = Z.parent;
  }
  return !0;
}
function mE(l, Z) {
  let u = M.useRef(void 0), s = M.useRef(void 0);
  PZ(() => {
    let G = l.current;
    if (!Z) {
      s.current && (cancelAnimationFrame(s.current), s.current = void 0);
      return;
    }
    const i = _Z(G ? G[0] : void 0);
    let m = (p) => {
      if (p.key !== "Tab" || p.altKey || p.ctrlKey || p.metaKey || !Ma(l) || p.isComposing) return;
      let y = i.activeElement, h = l.current;
      if (!h || !ab(y, h)) return;
      let S = sm(h), t = sd(S, {
        tabbable: !0
      }, h);
      if (!y) return;
      t.currentNode = y;
      let W = p.shiftKey ? t.previousNode() : t.nextNode();
      W || (t.currentNode = p.shiftKey ? h[h.length - 1].nextElementSibling : h[0].previousElementSibling, W = p.shiftKey ? t.previousNode() : t.nextNode()), p.preventDefault(), W && ud(W, !0);
    }, a = (p) => {
      (!QZ || hh(QZ, l)) && ab(p.target, l.current) ? (QZ = l, u.current = p.target) : Ma(l) && !Lh(p.target, l) ? u.current ? u.current.focus() : QZ && QZ.current && XW(QZ.current) : Ma(l) && (u.current = p.target);
    }, n = (p) => {
      s.current && cancelAnimationFrame(s.current), s.current = requestAnimationFrame(() => {
        if (i.activeElement && Ma(l) && !Lh(i.activeElement, l))
          if (QZ = l, i.body.contains(p.target)) {
            var y;
            u.current = p.target, (y = u.current) === null || y === void 0 || y.focus();
          } else QZ.current && XW(QZ.current);
      });
    };
    return i.addEventListener("keydown", m, !1), i.addEventListener("focusin", a, !1), G == null || G.forEach((p) => p.addEventListener("focusin", a, !1)), G == null || G.forEach((p) => p.addEventListener("focusout", n, !1)), () => {
      i.removeEventListener("keydown", m, !1), i.removeEventListener("focusin", a, !1), G == null || G.forEach((p) => p.removeEventListener("focusin", a, !1)), G == null || G.forEach((p) => p.removeEventListener("focusout", n, !1));
    };
  }, [
    l,
    Z
  ]), PZ(() => () => {
    s.current && cancelAnimationFrame(s.current);
  }, [
    s
  ]);
}
function V1(l) {
  return Lh(l);
}
function ab(l, Z) {
  return !l || !Z ? !1 : Z.some((u) => u.contains(l));
}
function Lh(l, Z = null) {
  if (l instanceof Element && l.closest("[data-react-aria-top-layer]")) return !0;
  for (let { scopeRef: u } of Wc.traverse(Wc.getTreeNode(Z)))
    if (u && ab(l, u.current)) return !0;
  return !1;
}
function iE(l) {
  return Lh(l, QZ);
}
function hh(l, Z) {
  var u;
  let s = (u = Wc.getTreeNode(Z)) === null || u === void 0 ? void 0 : u.parent;
  for (; s; ) {
    if (s.scopeRef === l) return !0;
    s = s.parent;
  }
  return !1;
}
function ud(l, Z = !1) {
  if (l != null && !Z) try {
    Ea(l);
  } catch {
  }
  else if (l != null) try {
    l.focus();
  } catch {
  }
}
function x1(l, Z = !0) {
  let u = l[0].previousElementSibling, s = sm(l), G = sd(s, {
    tabbable: Z
  }, l);
  G.currentNode = u;
  let i = G.nextNode();
  return Z && !i && (s = sm(l), G = sd(s, {
    tabbable: !1
  }, l), G.currentNode = u, i = G.nextNode()), i;
}
function XW(l, Z = !0) {
  ud(x1(l, Z));
}
function oE(l, Z) {
  const u = tl.useRef(Z);
  M.useEffect(() => {
    if (u.current) {
      QZ = l;
      const s = _Z(l.current ? l.current[0] : void 0);
      !ab(s.activeElement, QZ.current) && l.current && XW(l.current);
    }
    u.current = !1;
  }, [
    l
  ]);
}
function eE(l, Z, u) {
  PZ(() => {
    if (Z || u) return;
    let s = l.current;
    const G = _Z(s ? s[0] : void 0);
    let i = (m) => {
      let a = m.target;
      ab(a, l.current) ? QZ = l : V1(a) || (QZ = null);
    };
    return G.addEventListener("focusin", i, !1), s == null || s.forEach((m) => m.addEventListener("focusin", i, !1)), () => {
      G.removeEventListener("focusin", i, !1), s == null || s.forEach((m) => m.removeEventListener("focusin", i, !1));
    };
  }, [
    l,
    Z,
    u
  ]);
}
function aE(l) {
  let Z = Wc.getTreeNode(QZ);
  for (; Z && Z.scopeRef !== l; ) {
    if (Z.nodeToRestore) return !1;
    Z = Z.parent;
  }
  return (Z == null ? void 0 : Z.scopeRef) === l;
}
function nE(l, Z, u) {
  const s = M.useRef(typeof document < "u" ? _Z(l.current ? l.current[0] : void 0).activeElement : null);
  PZ(() => {
    let G = l.current;
    const i = _Z(G ? G[0] : void 0);
    if (!Z || u) return;
    let m = () => {
      (!QZ || hh(QZ, l)) && ab(i.activeElement, l.current) && (QZ = l);
    };
    return i.addEventListener("focusin", m, !1), G == null || G.forEach((a) => a.addEventListener("focusin", m, !1)), () => {
      i.removeEventListener("focusin", m, !1), G == null || G.forEach((a) => a.removeEventListener("focusin", m, !1));
    };
  }, [
    l,
    u
  ]), PZ(() => {
    const G = _Z(l.current ? l.current[0] : void 0);
    if (!Z) return;
    let i = (m) => {
      if (m.key !== "Tab" || m.altKey || m.ctrlKey || m.metaKey || !Ma(l) || m.isComposing) return;
      let a = G.activeElement;
      if (!ab(a, l.current)) return;
      let n = Wc.getTreeNode(l);
      if (!n) return;
      let p = n.nodeToRestore, y = sd(G.body, {
        tabbable: !0
      });
      y.currentNode = a;
      let h = m.shiftKey ? y.previousNode() : y.nextNode();
      if ((!p || !G.body.contains(p) || p === G.body) && (p = void 0, n.nodeToRestore = void 0), (!h || !ab(h, l.current)) && p) {
        y.currentNode = p;
        do
          h = m.shiftKey ? y.previousNode() : y.nextNode();
        while (ab(h, l.current));
        m.preventDefault(), m.stopPropagation(), h ? ud(h, !0) : V1(p) ? ud(p, !0) : a.blur();
      }
    };
    return u || G.addEventListener("keydown", i, !0), () => {
      u || G.removeEventListener("keydown", i, !0);
    };
  }, [
    l,
    Z,
    u
  ]), PZ(() => {
    const G = _Z(l.current ? l.current[0] : void 0);
    if (!Z) return;
    let i = Wc.getTreeNode(l);
    if (i) {
      var m;
      return i.nodeToRestore = (m = s.current) !== null && m !== void 0 ? m : void 0, () => {
        let a = Wc.getTreeNode(l);
        if (!a) return;
        let n = a.nodeToRestore;
        if (Z && n && // eslint-disable-next-line react-hooks/exhaustive-deps
        (ab(G.activeElement, l.current) || G.activeElement === G.body && aE(l))) {
          let p = Wc.clone();
          requestAnimationFrame(() => {
            if (G.activeElement === G.body) {
              let y = p.getTreeNode(l);
              for (; y; ) {
                if (y.nodeToRestore && y.nodeToRestore.isConnected) {
                  e2(y.nodeToRestore);
                  return;
                }
                y = y.parent;
              }
              for (y = p.getTreeNode(l); y; ) {
                if (y.scopeRef && y.scopeRef.current && Wc.getTreeNode(y.scopeRef)) {
                  let h = x1(y.scopeRef.current, !0);
                  e2(h);
                  return;
                }
                y = y.parent;
              }
            }
          });
        }
      };
    }
  }, [
    l,
    Z
  ]);
}
function e2(l) {
  l.dispatchEvent(new CustomEvent(tW, {
    bubbles: !0,
    cancelable: !0
  })) && ud(l);
}
function sd(l, Z, u) {
  let s = Z != null && Z.tabbable ? GE : dE, G = _Z(l).createTreeWalker(l, NodeFilter.SHOW_ELEMENT, {
    acceptNode(i) {
      var m;
      return !(Z == null || (m = Z.from) === null || m === void 0) && m.contains(i) ? NodeFilter.FILTER_REJECT : i.matches(s) && K1(i) && (!u || ab(i, u)) && (!(Z != null && Z.accept) || Z.accept(i)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  return Z != null && Z.from && (G.currentNode = Z.from), G;
}
class MV {
  get size() {
    return this.fastMap.size;
  }
  getTreeNode(Z) {
    return this.fastMap.get(Z);
  }
  addTreeNode(Z, u, s) {
    let G = this.fastMap.get(u ?? null);
    if (!G) return;
    let i = new KW({
      scopeRef: Z
    });
    G.addChild(i), i.parent = G, this.fastMap.set(Z, i), s && (i.nodeToRestore = s);
  }
  addNode(Z) {
    this.fastMap.set(Z.scopeRef, Z);
  }
  removeTreeNode(Z) {
    if (Z === null) return;
    let u = this.fastMap.get(Z);
    if (!u) return;
    let s = u.parent;
    for (let i of this.traverse()) i !== u && u.nodeToRestore && i.nodeToRestore && u.scopeRef && u.scopeRef.current && ab(i.nodeToRestore, u.scopeRef.current) && (i.nodeToRestore = u.nodeToRestore);
    let G = u.children;
    s && (s.removeChild(u), G.size > 0 && G.forEach((i) => s && s.addChild(i))), this.fastMap.delete(u.scopeRef);
  }
  // Pre Order Depth First
  *traverse(Z = this.root) {
    if (Z.scopeRef != null && (yield Z), Z.children.size > 0) for (let u of Z.children) yield* this.traverse(u);
  }
  clone() {
    var Z;
    let u = new MV();
    var s;
    for (let G of this.traverse()) u.addTreeNode(G.scopeRef, (s = (Z = G.parent) === null || Z === void 0 ? void 0 : Z.scopeRef) !== null && s !== void 0 ? s : null, G.nodeToRestore);
    return u;
  }
  constructor() {
    this.fastMap = /* @__PURE__ */ new Map(), this.root = new KW({
      scopeRef: null
    }), this.fastMap.set(null, this.root);
  }
}
class KW {
  addChild(Z) {
    this.children.add(Z), Z.parent = this;
  }
  removeChild(Z) {
    this.children.delete(Z), Z.parent = void 0;
  }
  constructor(Z) {
    this.children = /* @__PURE__ */ new Set(), this.contain = !1, this.scopeRef = Z.scopeRef;
  }
}
let Wc = new MV();
function Th(l = {}) {
  let { autoFocus: Z = !1, isTextInput: u, within: s } = l, G = M.useRef({
    isFocused: !1,
    isFocusVisible: Z || xV()
  }), [i, m] = M.useState(!1), [a, n] = M.useState(() => G.current.isFocused && G.current.isFocusVisible), p = M.useCallback(() => n(G.current.isFocused && G.current.isFocusVisible), []), y = M.useCallback((t) => {
    G.current.isFocused = t, m(t), p();
  }, [
    p
  ]);
  lE((t) => {
    G.current.isFocusVisible = t, p();
  }, [], {
    isTextInput: u
  });
  let { focusProps: h } = VV({
    isDisabled: s,
    onFocusChange: y
  }), { focusWithinProps: S } = RV({
    isDisabled: !s,
    onFocusWithinChange: y
  });
  return {
    isFocused: i,
    isFocusVisible: a,
    focusProps: s ? S : h
  };
}
let pE = /* @__PURE__ */ tl.createContext(null);
function LE(l) {
  let Z = M.useContext(pE) || {};
  XV(Z, l);
  let { ref: u, ...s } = Z;
  return s;
}
function IV(l, Z) {
  let { focusProps: u } = VV(l), { keyboardProps: s } = YV(l), G = HZ(u, s), i = LE(Z), m = l.isDisabled ? {} : i, a = M.useRef(l.autoFocus);
  return M.useEffect(() => {
    a.current && Z.current && Ea(Z.current), a.current = !1;
  }, [
    Z
  ]), {
    focusableProps: HZ({
      ...G,
      tabIndex: l.excludeFromTabOrder && !l.isDisabled ? -1 : void 0
    }, m)
  };
}
function hE(l, Z) {
  let {
    elementType: u = "a",
    onPress: s,
    onPressStart: G,
    onPressEnd: i,
    // @ts-ignore
    onClick: m,
    isDisabled: a,
    ...n
  } = l, p = {};
  u !== "a" && (p = {
    role: "link",
    tabIndex: a ? void 0 : 0
  });
  let { focusableProps: y } = IV(l, Z), { pressProps: h, isPressed: S } = hn({
    onPress: s,
    onPressStart: G,
    onPressEnd: i,
    isDisabled: a,
    ref: Z
  }), t = Su(n, {
    labelable: !0
  }), W = HZ(y, h), V = nn(), R = l1(l);
  return {
    isPressed: S,
    linkProps: HZ(t, R, {
      ...W,
      ...p,
      "aria-disabled": a || void 0,
      "aria-current": l["aria-current"],
      onClick: (x) => {
        var r;
        (r = h.onClick) === null || r === void 0 || r.call(h, x), m && (m(x), console.warn("onClick is deprecated, please use onPress")), !V.isNative && x.currentTarget instanceof HTMLAnchorElement && x.currentTarget.href && // If props are applied to a router Link component, it may have already prevented default.
        !x.isDefaultPrevented() && of(x.currentTarget, x) && l.href && (x.preventDefault(), V.open(x.currentTarget, x, l.href, l.routerOptions));
      }
    })
  };
}
const yE = /* @__PURE__ */ new Set([
  "Arab",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]), SE = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function tE(l) {
  if (Intl.Locale) {
    let u = new Intl.Locale(l).maximize(), s = typeof u.getTextInfo == "function" ? u.getTextInfo() : u.textInfo;
    if (s) return s.direction === "rtl";
    if (u.script) return yE.has(u.script);
  }
  let Z = l.split("-")[0];
  return SE.has(Z);
}
const XE = Symbol.for("react-aria.i18n.locale");
function R1() {
  let l = typeof window < "u" && window[XE] || typeof navigator < "u" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([
      l
    ]);
  } catch {
    l = "en-US";
  }
  return {
    locale: l,
    direction: tE(l) ? "rtl" : "ltr"
  };
}
let WW = R1(), Ia = /* @__PURE__ */ new Set();
function a2() {
  WW = R1();
  for (let l of Ia) l(WW);
}
function KE() {
  let l = Mm(), [Z, u] = M.useState(WW);
  return M.useEffect(() => (Ia.size === 0 && window.addEventListener("languagechange", a2), Ia.add(u), () => {
    Ia.delete(u), Ia.size === 0 && window.removeEventListener("languagechange", a2);
  }), []), l ? {
    locale: "en-US",
    direction: "ltr"
  } : Z;
}
const WE = /* @__PURE__ */ tl.createContext(null);
function Im() {
  let l = KE();
  return M.useContext(WE) || l;
}
const VE = Symbol.for("react-aria.i18n.locale"), xE = Symbol.for("react-aria.i18n.strings");
let zi;
class fh {
  /** Returns a localized string for the given key and locale. */
  getStringForLocale(Z, u) {
    let G = this.getStringsForLocale(u)[Z];
    if (!G) throw new Error(`Could not find intl message ${Z} in ${u} locale`);
    return G;
  }
  /** Returns all localized strings for the given locale. */
  getStringsForLocale(Z) {
    let u = this.strings[Z];
    return u || (u = RE(Z, this.strings, this.defaultLocale), this.strings[Z] = u), u;
  }
  static getGlobalDictionaryForPackage(Z) {
    if (typeof window > "u") return null;
    let u = window[VE];
    if (zi === void 0) {
      let G = window[xE];
      if (!G) return null;
      zi = {};
      for (let i in G) zi[i] = new fh({
        [u]: G[i]
      }, u);
    }
    let s = zi == null ? void 0 : zi[Z];
    if (!s) throw new Error(`Strings for package "${Z}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`);
    return s;
  }
  constructor(Z, u = "en-US") {
    this.strings = Object.fromEntries(Object.entries(Z).filter(([, s]) => s)), this.defaultLocale = u;
  }
}
function RE(l, Z, u = "en-US") {
  if (Z[l]) return Z[l];
  let s = YE(l);
  if (Z[s]) return Z[s];
  for (let G in Z)
    if (G.startsWith(s + "-")) return Z[G];
  return Z[u];
}
function YE(l) {
  return Intl.Locale ? new Intl.Locale(l).language : l.split("-")[0];
}
const n2 = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map();
class kE {
  /** Formats a localized string for the given key with the provided variables. */
  format(Z, u) {
    let s = this.strings.getStringForLocale(Z, this.locale);
    return typeof s == "function" ? s(u, this) : s;
  }
  plural(Z, u, s = "cardinal") {
    let G = u["=" + Z];
    if (G) return typeof G == "function" ? G() : G;
    let i = this.locale + ":" + s, m = n2.get(i);
    m || (m = new Intl.PluralRules(this.locale, {
      type: s
    }), n2.set(i, m));
    let a = m.select(Z);
    return G = u[a] || u.other, typeof G == "function" ? G() : G;
  }
  number(Z) {
    let u = p2.get(this.locale);
    return u || (u = new Intl.NumberFormat(this.locale), p2.set(this.locale, u)), u.format(Z);
  }
  select(Z, u) {
    let s = Z[u] || Z.other;
    return typeof s == "function" ? s() : s;
  }
  constructor(Z, u) {
    this.locale = Z, this.strings = u;
  }
}
const L2 = /* @__PURE__ */ new WeakMap();
function ME(l) {
  let Z = L2.get(l);
  return Z || (Z = new fh(l), L2.set(l, Z)), Z;
}
function IE(l, Z) {
  return Z && fh.getGlobalDictionaryForPackage(Z) || ME(l);
}
function Y1(l, Z) {
  let { locale: u } = Im(), s = IE(l, Z);
  return M.useMemo(() => new kE(u, s), [
    u,
    s
  ]);
}
let CK = /* @__PURE__ */ new Map(), VW = !1;
try {
  VW = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
let yh = !1;
try {
  yh = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
const k1 = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
class UE {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(Z) {
    let u = "";
    if (!VW && this.options.signDisplay != null ? u = rE(this.numberFormatter, this.options.signDisplay, Z) : u = this.numberFormatter.format(Z), this.options.style === "unit" && !yh) {
      var s;
      let { unit: G, unitDisplay: i = "short", locale: m } = this.resolvedOptions();
      if (!G) return u;
      let a = (s = k1[G]) === null || s === void 0 ? void 0 : s[i];
      u += a[m] || a.default;
    }
    return u;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(Z) {
    return this.numberFormatter.formatToParts(Z);
  }
  /** Formats a number range as a string. */
  formatRange(Z, u) {
    if (typeof this.numberFormatter.formatRange == "function")
      return this.numberFormatter.formatRange(Z, u);
    if (u < Z) throw new RangeError("End date must be >= start date");
    return `${this.format(Z)} – ${this.format(u)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(Z, u) {
    if (typeof this.numberFormatter.formatRangeToParts == "function")
      return this.numberFormatter.formatRangeToParts(Z, u);
    if (u < Z) throw new RangeError("End date must be >= start date");
    let s = this.numberFormatter.formatToParts(Z), G = this.numberFormatter.formatToParts(u);
    return [
      ...s.map((i) => ({
        ...i,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...G.map((i) => ({
        ...i,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let Z = this.numberFormatter.resolvedOptions();
    return !VW && this.options.signDisplay != null && (Z = {
      ...Z,
      signDisplay: this.options.signDisplay
    }), !yh && this.options.style === "unit" && (Z = {
      ...Z,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    }), Z;
  }
  constructor(Z, u = {}) {
    this.numberFormatter = CE(Z, u), this.options = u;
  }
}
function CE(l, Z = {}) {
  let { numberingSystem: u } = Z;
  if (u && l.includes("-nu-") && (l.includes("-u-") || (l += "-u-"), l += `-nu-${u}`), Z.style === "unit" && !yh) {
    var s;
    let { unit: m, unitDisplay: a = "short" } = Z;
    if (!m) throw new Error('unit option must be provided with style: "unit"');
    if (!(!((s = k1[m]) === null || s === void 0) && s[a])) throw new Error(`Unsupported unit ${m} with unitDisplay = ${a}`);
    Z = {
      ...Z,
      style: "decimal"
    };
  }
  let G = l + (Z ? Object.entries(Z).sort((m, a) => m[0] < a[0] ? -1 : 1).join() : "");
  if (CK.has(G)) return CK.get(G);
  let i = new Intl.NumberFormat(l, Z);
  return CK.set(G, i), i;
}
function rE(l, Z, u) {
  if (Z === "auto") return l.format(u);
  if (Z === "never") return l.format(Math.abs(u));
  {
    let s = !1;
    if (Z === "always" ? s = u > 0 || Object.is(u, 0) : Z === "exceptZero" && (Object.is(u, -0) || Object.is(u, 0) ? u = Math.abs(u) : s = u > 0), s) {
      let G = l.format(-u), i = l.format(u), m = G.replace(i, "").replace(/\u200e|\u061C/, "");
      return [
        ...m
      ].length !== 1 && console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case"), G.replace(i, "!!!").replace(m, "+").replace("!!!", i);
    } else return l.format(u);
  }
}
function FE(l = {}) {
  let { locale: Z } = Im();
  return M.useMemo(() => new UE(Z, l), [
    Z,
    l
  ]);
}
let rK = /* @__PURE__ */ new Map();
function NE(l) {
  let { locale: Z } = Im(), u = Z + (l ? Object.entries(l).sort((G, i) => G[0] < i[0] ? -1 : 1).join() : "");
  if (rK.has(u)) return rK.get(u);
  let s = new Intl.Collator(Z, l);
  return rK.set(u, s), s;
}
function wE(l, Z) {
  let {
    elementType: u = "button",
    isDisabled: s,
    onPress: G,
    onPressStart: i,
    onPressEnd: m,
    onPressUp: a,
    onPressChange: n,
    preventFocusOnPress: p,
    allowFocusWhenDisabled: y,
    // @ts-ignore
    onClick: h,
    href: S,
    target: t,
    rel: W,
    type: V = "button"
  } = l, R;
  u === "button" ? R = {
    type: V,
    disabled: s
  } : R = {
    role: "button",
    tabIndex: s ? void 0 : 0,
    href: u === "a" && s ? void 0 : S,
    target: u === "a" ? t : void 0,
    type: u === "input" ? V : void 0,
    disabled: u === "input" ? s : void 0,
    "aria-disabled": !s || u === "input" ? void 0 : s,
    rel: u === "a" ? W : void 0
  };
  let { pressProps: x, isPressed: r } = hn({
    onPressStart: i,
    onPressEnd: m,
    onPressChange: n,
    onPress: G,
    onPressUp: a,
    isDisabled: s,
    preventFocusOnPress: p,
    ref: Z
  }), { focusableProps: k } = IV(l, Z);
  y && (k.tabIndex = s ? -1 : k.tabIndex);
  let U = HZ(k, x, Su(l, {
    labelable: !0
  }));
  return {
    isPressed: r,
    buttonProps: HZ(R, U, {
      "aria-haspopup": l["aria-haspopup"],
      "aria-expanded": l["aria-expanded"],
      "aria-controls": l["aria-controls"],
      "aria-pressed": l["aria-pressed"],
      onClick: (w) => {
        h && (h(w), console.warn("onClick is deprecated, please use onPress"));
      }
    })
  };
}
const M1 = 7e3;
let os = null;
function h2(l, Z = "assertive", u = M1) {
  os ? os.announce(l, Z, u) : (os = new zE(), (typeof IS_REACT_ACT_ENVIRONMENT == "boolean" ? IS_REACT_ACT_ENVIRONMENT : typeof jest < "u") ? os.announce(l, Z, u) : setTimeout(() => {
    os != null && os.isAttached() && (os == null || os.announce(l, Z, u));
  }, 100));
}
class zE {
  isAttached() {
    var Z;
    return (Z = this.node) === null || Z === void 0 ? void 0 : Z.isConnected;
  }
  createLog(Z) {
    let u = document.createElement("div");
    return u.setAttribute("role", "log"), u.setAttribute("aria-live", Z), u.setAttribute("aria-relevant", "additions"), u;
  }
  destroy() {
    this.node && (document.body.removeChild(this.node), this.node = null);
  }
  announce(Z, u = "assertive", s = M1) {
    var G, i;
    if (!this.node) return;
    let m = document.createElement("div");
    typeof Z == "object" ? (m.setAttribute("role", "img"), m.setAttribute("aria-labelledby", Z["aria-labelledby"])) : m.textContent = Z, u === "assertive" ? (G = this.assertiveLog) === null || G === void 0 || G.appendChild(m) : (i = this.politeLog) === null || i === void 0 || i.appendChild(m), Z !== "" && setTimeout(() => {
      m.remove();
    }, s);
  }
  clear(Z) {
    this.node && ((!Z || Z === "assertive") && this.assertiveLog && (this.assertiveLog.innerHTML = ""), (!Z || Z === "polite") && this.politeLog && (this.politeLog.innerHTML = ""));
  }
  constructor() {
    this.node = null, this.assertiveLog = null, this.politeLog = null, typeof document < "u" && (this.node = document.createElement("div"), this.node.dataset.liveAnnouncer = "true", Object.assign(this.node.style, {
      border: 0,
      clip: "rect(0 0 0 0)",
      clipPath: "inset(50%)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap"
    }), this.assertiveLog = this.createLog("assertive"), this.node.appendChild(this.assertiveLog), this.politeLog = this.createLog("polite"), this.node.appendChild(this.politeLog), document.body.prepend(this.node));
  }
}
function I1(l) {
  let { id: Z, label: u, "aria-labelledby": s, "aria-label": G, labelElementType: i = "label" } = l;
  Z = ad(Z);
  let m = ad(), a = {};
  u ? (s = s ? `${m} ${s}` : m, a = {
    id: m,
    htmlFor: i === "label" ? Z : void 0
  }) : !s && !G && console.warn("If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility");
  let n = c1({
    id: Z,
    "aria-label": G,
    "aria-labelledby": s
  });
  return {
    labelProps: a,
    fieldProps: n
  };
}
const JE = 0, HE = 100, gE = 1;
function vE(l) {
  const { isDisabled: Z = !1, minValue: u = JE, maxValue: s = HE, numberFormatter: G, step: i = gE, orientation: m = "horizontal" } = l;
  let a = M.useMemo(() => {
    let Zl = (s - u) / 10;
    return Zl = ha(Zl, 0, Zl + i, i), Math.max(Zl, i);
  }, [
    i,
    s,
    u
  ]), n = M.useCallback((Zl) => Zl == null ? void 0 : Zl.map((ol, Wl) => {
    let ml = Wl === 0 ? u : ol[Wl - 1], Rl = Wl === Zl.length - 1 ? s : ol[Wl + 1];
    return ha(ol, ml, Rl, i);
  }), [
    u,
    s,
    i
  ]), p = M.useMemo(() => n(S2(l.value)), [
    l.value
  ]), y = M.useMemo(() => {
    var Zl;
    return n((Zl = S2(l.defaultValue)) !== null && Zl !== void 0 ? Zl : [
      u
    ]);
  }, [
    l.defaultValue,
    u
  ]), h = t2(l.value, l.defaultValue, l.onChange), S = t2(l.value, l.defaultValue, l.onChangeEnd);
  const [t, W] = Hh(p, y, h), [V, R] = M.useState(new Array(t.length).fill(!1)), x = M.useRef(new Array(t.length).fill(!0)), [r, k] = M.useState(void 0), U = M.useRef(t), w = M.useRef(V);
  let z = (Zl) => {
    U.current = Zl, W(Zl);
  }, D = (Zl) => {
    w.current = Zl, R(Zl);
  };
  function C(Zl) {
    return (Zl - u) / (s - u);
  }
  function j(Zl) {
    return Zl === 0 ? u : t[Zl - 1];
  }
  function E(Zl) {
    return Zl === t.length - 1 ? s : t[Zl + 1];
  }
  function g(Zl) {
    return x.current[Zl];
  }
  function A(Zl, ol) {
    x.current[Zl] = ol;
  }
  function J(Zl, ol) {
    if (Z || !g(Zl)) return;
    const Wl = j(Zl), ml = E(Zl);
    ol = ha(ol, Wl, ml, i);
    let Rl = y2(U.current, Zl, ol);
    z(Rl);
  }
  function F(Zl, ol) {
    if (Z || !g(Zl)) return;
    ol && (U.current = t);
    const Wl = w.current[Zl];
    w.current = y2(w.current, Zl, ol), D(w.current), S && Wl && !w.current.some(Boolean) && S(U.current);
  }
  function v(Zl) {
    return G.format(Zl);
  }
  function T(Zl, ol) {
    J(Zl, O(ol));
  }
  function f(Zl) {
    return Math.round((Zl - u) / i) * i + u;
  }
  function O(Zl) {
    const ol = Zl * (s - u) + u;
    return eo(f(ol), u, s);
  }
  function _(Zl, ol = 1) {
    let Wl = Math.max(ol, i);
    J(Zl, ha(t[Zl] + Wl, u, s, i));
  }
  function il(Zl, ol = 1) {
    let Wl = Math.max(ol, i);
    J(Zl, ha(t[Zl] - Wl, u, s, i));
  }
  return {
    values: t,
    getThumbValue: (Zl) => t[Zl],
    setThumbValue: J,
    setThumbPercent: T,
    isThumbDragging: (Zl) => V[Zl],
    setThumbDragging: F,
    focusedThumb: r,
    setFocusedThumb: k,
    getThumbPercent: (Zl) => C(t[Zl]),
    getValuePercent: C,
    getThumbValueLabel: (Zl) => v(t[Zl]),
    getFormattedValue: v,
    getThumbMinValue: j,
    getThumbMaxValue: E,
    getPercentValue: O,
    isThumbEditable: g,
    setThumbEditable: A,
    incrementThumb: _,
    decrementThumb: il,
    step: i,
    pageSize: a,
    orientation: m,
    isDisabled: Z
  };
}
function y2(l, Z, u) {
  return l[Z] === u ? l : [
    ...l.slice(0, Z),
    u,
    ...l.slice(Z + 1)
  ];
}
function S2(l) {
  if (l != null)
    return Array.isArray(l) ? l : [
      l
    ];
}
function t2(l, Z, u) {
  return (s) => {
    typeof l == "number" || typeof Z == "number" ? u == null || u(s[0]) : u == null || u(s);
  };
}
const X2 = {
  border: 0,
  clip: "rect(0 0 0 0)",
  clipPath: "inset(50%)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap"
};
function TE(l = {}) {
  let { style: Z, isFocusable: u } = l, [s, G] = M.useState(!1), { focusWithinProps: i } = RV({
    isDisabled: !u,
    onFocusWithinChange: (a) => G(a)
  }), m = M.useMemo(() => s ? Z : Z ? {
    ...X2,
    ...Z
  } : X2, [
    s
  ]);
  return {
    visuallyHiddenProps: {
      ...i,
      style: m
    }
  };
}
function U1(l) {
  let { children: Z, elementType: u = "div", isFocusable: s, style: G, ...i } = l, { visuallyHiddenProps: m } = TE(l);
  return /* @__PURE__ */ tl.createElement(u, HZ(i, m), Z);
}
const UV = /* @__PURE__ */ new WeakMap();
function xW(l, Z) {
  let u = UV.get(l);
  if (!u) throw new Error("Unknown slider state");
  return `${u.id}-${Z}`;
}
function fE(l, Z, u) {
  let { labelProps: s, fieldProps: G } = I1(l), i = l.orientation === "vertical";
  var m;
  UV.set(Z, {
    id: (m = s.id) !== null && m !== void 0 ? m : G.id,
    "aria-describedby": l["aria-describedby"],
    "aria-details": l["aria-details"]
  });
  let { direction: a } = Im(), { addGlobalListener: n, removeGlobalListener: p } = pn();
  const y = M.useRef(null), h = a === "rtl", S = M.useRef(null), { moveProps: t } = t1({
    onMoveStart() {
      S.current = null;
    },
    onMove({ deltaX: x, deltaY: r }) {
      let { height: k, width: U } = u.current.getBoundingClientRect(), w = i ? k : U;
      S.current == null && (S.current = Z.getThumbPercent(y.current) * w);
      let z = i ? r : x;
      if ((i || h) && (z = -z), S.current += z, y.current != null && u.current) {
        const D = eo(S.current / w, 0, 1);
        Z.setThumbPercent(y.current, D);
      }
    },
    onMoveEnd() {
      y.current != null && (Z.setThumbDragging(y.current, !1), y.current = null);
    }
  });
  let W = M.useRef(void 0), V = (x, r, k, U) => {
    if (u.current && !l.isDisabled && Z.values.every((w, z) => !Z.isThumbDragging(z))) {
      let { height: w, width: z, top: D, left: C } = u.current.getBoundingClientRect(), j = i ? w : z, J = ((i ? U : k) - (i ? D : C)) / j;
      (a === "rtl" || i) && (J = 1 - J);
      let F = Z.getPercentValue(J), v, T = Z.values.findIndex((f) => F - f < 0);
      if (T === 0) v = T;
      else if (T === -1) v = Z.values.length - 1;
      else {
        let f = Z.values[T - 1], O = Z.values[T];
        Math.abs(f - F) < Math.abs(O - F) ? v = T - 1 : v = T;
      }
      v >= 0 && Z.isThumbEditable(v) ? (x.preventDefault(), y.current = v, Z.setFocusedThumb(v), W.current = r, Z.setThumbDragging(y.current, !0), Z.setThumbValue(v, F), n(window, "mouseup", R, !1), n(window, "touchend", R, !1), n(window, "pointerup", R, !1)) : y.current = null;
    }
  }, R = (x) => {
    var r, k;
    ((k = x.pointerId) !== null && k !== void 0 ? k : (r = x.changedTouches) === null || r === void 0 ? void 0 : r[0].identifier) === W.current && (y.current != null && (Z.setThumbDragging(y.current, !1), y.current = null), p(window, "mouseup", R, !1), p(window, "touchend", R, !1), p(window, "pointerup", R, !1));
  };
  return "htmlFor" in s && s.htmlFor && (delete s.htmlFor, s.onClick = () => {
    var x;
    (x = document.getElementById(xW(Z, 0))) === null || x === void 0 || x.focus(), $f("keyboard");
  }), {
    labelProps: s,
    // The root element of the Slider will have role="group" to group together
    // all the thumb inputs in the Slider.  The label of the Slider will
    // be used to label the group.
    groupProps: {
      role: "group",
      ...G
    },
    trackProps: HZ({
      onMouseDown(x) {
        x.button !== 0 || x.altKey || x.ctrlKey || x.metaKey || V(x, void 0, x.clientX, x.clientY);
      },
      onPointerDown(x) {
        x.pointerType === "mouse" && (x.button !== 0 || x.altKey || x.ctrlKey || x.metaKey) || V(x, x.pointerId, x.clientX, x.clientY);
      },
      onTouchStart(x) {
        V(x, x.changedTouches[0].identifier, x.changedTouches[0].clientX, x.changedTouches[0].clientY);
      },
      style: {
        position: "relative",
        touchAction: "none"
      }
    }, t),
    outputProps: {
      htmlFor: Z.values.map((x, r) => xW(Z, r)).join(" "),
      "aria-live": "off"
    }
  };
}
function EE(l, Z) {
  let { index: u = 0, isRequired: s, validationState: G, isInvalid: i, trackRef: m, inputRef: a, orientation: n = Z.orientation, name: p } = l, y = l.isDisabled || Z.isDisabled, h = n === "vertical", { direction: S } = Im(), { addGlobalListener: t, removeGlobalListener: W } = pn(), V = UV.get(Z);
  var R;
  const { labelProps: x, fieldProps: r } = I1({
    ...l,
    id: xW(Z, u),
    "aria-labelledby": `${V.id} ${(R = l["aria-labelledby"]) !== null && R !== void 0 ? R : ""}`.trim()
  }), k = Z.values[u], U = M.useCallback(() => {
    a.current && Ls(a.current);
  }, [
    a
  ]), w = Z.focusedThumb === u;
  M.useEffect(() => {
    w && U();
  }, [
    w,
    U
  ]);
  let z = S === "rtl", D = M.useRef(null), { keyboardProps: C } = YV({
    onKeyDown(T) {
      let { getThumbMaxValue: f, getThumbMinValue: O, decrementThumb: _, incrementThumb: il, setThumbValue: Zl, setThumbDragging: ol, pageSize: Wl } = Z;
      if (!/^(PageUp|PageDown|Home|End)$/.test(T.key)) {
        T.continuePropagation();
        return;
      }
      switch (T.preventDefault(), ol(u, !0), T.key) {
        case "PageUp":
          il(u, Wl);
          break;
        case "PageDown":
          _(u, Wl);
          break;
        case "Home":
          Zl(u, O(u));
          break;
        case "End":
          Zl(u, f(u));
          break;
      }
      ol(u, !1);
    }
  }), { moveProps: j } = t1({
    onMoveStart() {
      D.current = null, Z.setThumbDragging(u, !0);
    },
    onMove({ deltaX: T, deltaY: f, pointerType: O, shiftKey: _ }) {
      const { getThumbPercent: il, setThumbPercent: Zl, decrementThumb: ol, incrementThumb: Wl, step: ml, pageSize: Rl } = Z;
      let { width: kl, height: zl } = m.current.getBoundingClientRect(), Vl = h ? zl : kl;
      if (D.current == null && (D.current = il(u) * Vl), O === "keyboard")
        T > 0 && z || T < 0 && !z || f > 0 ? ol(u, _ ? Rl : ml) : Wl(u, _ ? Rl : ml);
      else {
        let el = h ? f : T;
        (h || z) && (el = -el), D.current += el, Zl(u, eo(D.current / Vl, 0, 1));
      }
    },
    onMoveEnd() {
      Z.setThumbDragging(u, !1);
    }
  });
  Z.setThumbEditable(u, !y);
  const { focusableProps: E } = IV(HZ(l, {
    onFocus: () => Z.setFocusedThumb(u),
    onBlur: () => Z.setFocusedThumb(void 0)
  }), a);
  let g = M.useRef(void 0), A = (T) => {
    U(), g.current = T, Z.setThumbDragging(u, !0), t(window, "mouseup", J, !1), t(window, "touchend", J, !1), t(window, "pointerup", J, !1);
  }, J = (T) => {
    var f, O;
    ((O = T.pointerId) !== null && O !== void 0 ? O : (f = T.changedTouches) === null || f === void 0 ? void 0 : f[0].identifier) === g.current && (U(), Z.setThumbDragging(u, !1), W(window, "mouseup", J, !1), W(window, "touchend", J, !1), W(window, "pointerup", J, !1));
  }, F = Z.getThumbPercent(u);
  (h || S === "rtl") && (F = 1 - F);
  let v = y ? {} : HZ(C, j, {
    onMouseDown: (T) => {
      T.button !== 0 || T.altKey || T.ctrlKey || T.metaKey || A();
    },
    onPointerDown: (T) => {
      T.button !== 0 || T.altKey || T.ctrlKey || T.metaKey || A(T.pointerId);
    },
    onTouchStart: (T) => {
      A(T.changedTouches[0].identifier);
    }
  });
  return Sf(a, k, (T) => {
    Z.setThumbValue(u, T);
  }), {
    inputProps: HZ(E, r, {
      type: "range",
      tabIndex: y ? void 0 : 0,
      min: Z.getThumbMinValue(u),
      max: Z.getThumbMaxValue(u),
      step: Z.step,
      value: k,
      name: p,
      disabled: y,
      "aria-orientation": n,
      "aria-valuetext": Z.getThumbValueLabel(u),
      "aria-required": s || void 0,
      "aria-invalid": i || G === "invalid" || void 0,
      "aria-errormessage": l["aria-errormessage"],
      "aria-describedby": [
        V["aria-describedby"],
        l["aria-describedby"]
      ].filter(Boolean).join(" "),
      "aria-details": [
        V["aria-details"],
        l["aria-details"]
      ].filter(Boolean).join(" "),
      onChange: (T) => {
        Z.setThumbValue(u, parseFloat(T.target.value));
      }
    }),
    thumbProps: {
      ...v,
      style: {
        position: "absolute",
        [h ? "top" : "left"]: `${F * 100}%`,
        transform: "translate(-50%, -50%)",
        touchAction: "none"
      }
    },
    labelProps: x,
    isDragging: Z.isThumbDragging(u),
    isDisabled: y,
    isFocused: w
  };
}
const hs = {
  top: "top",
  bottom: "top",
  left: "left",
  right: "left"
}, Sh = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, BE = {
  top: "left",
  left: "top"
}, RW = {
  top: "height",
  left: "width"
}, C1 = {
  width: "totalWidth",
  height: "totalHeight"
}, DL = {};
let Jb = typeof document < "u" && window.visualViewport;
function K2(l) {
  let Z = 0, u = 0, s = 0, G = 0, i = 0, m = 0, a = {}, n = (Jb == null ? void 0 : Jb.scale) > 1;
  if (l.tagName === "BODY") {
    let h = document.documentElement;
    s = h.clientWidth, G = h.clientHeight;
    var p;
    Z = (p = Jb == null ? void 0 : Jb.width) !== null && p !== void 0 ? p : s;
    var y;
    u = (y = Jb == null ? void 0 : Jb.height) !== null && y !== void 0 ? y : G, a.top = h.scrollTop || l.scrollTop, a.left = h.scrollLeft || l.scrollLeft, Jb && (i = Jb.offsetTop, m = Jb.offsetLeft);
  } else
    ({ width: Z, height: u, top: i, left: m } = Di(l)), a.top = l.scrollTop, a.left = l.scrollLeft, s = Z, G = u;
  return qI() && (l.tagName === "BODY" || l.tagName === "HTML") && n && (a.top = 0, a.left = 0, i = Jb.pageTop, m = Jb.pageLeft), {
    width: Z,
    height: u,
    totalWidth: s,
    totalHeight: G,
    scroll: a,
    top: i,
    left: m
  };
}
function DE(l) {
  return {
    top: l.scrollTop,
    left: l.scrollLeft,
    width: l.scrollWidth,
    height: l.scrollHeight
  };
}
function W2(l, Z, u, s, G, i, m) {
  let a = G.scroll[l], n = s[RW[l]], p = s.scroll[hs[l]] + i, y = n + s.scroll[hs[l]] - i, h = Z - a + m[l] - s[hs[l]], S = Z - a + u + m[l] - s[hs[l]];
  return h < p ? p - h : S > y ? Math.max(y - S, p - h) : 0;
}
function jE(l) {
  let Z = window.getComputedStyle(l);
  return {
    top: parseInt(Z.marginTop, 10) || 0,
    bottom: parseInt(Z.marginBottom, 10) || 0,
    left: parseInt(Z.marginLeft, 10) || 0,
    right: parseInt(Z.marginRight, 10) || 0
  };
}
function V2(l) {
  if (DL[l]) return DL[l];
  let [Z, u] = l.split(" "), s = hs[Z] || "right", G = BE[s];
  hs[u] || (u = "center");
  let i = RW[s], m = RW[G];
  return DL[l] = {
    placement: Z,
    crossPlacement: u,
    axis: s,
    crossAxis: G,
    size: i,
    crossSize: m
  }, DL[l];
}
function FK(l, Z, u, s, G, i, m, a, n, p) {
  let { placement: y, crossPlacement: h, axis: S, crossAxis: t, size: W, crossSize: V } = s, R = {};
  R[t] = l[t], h === "center" ? R[t] += (l[V] - u[V]) / 2 : h !== t && (R[t] += l[V] - u[V]), R[t] += i;
  const x = l[t] - u[V] + n + p, r = l[t] + l[V] - n - p;
  if (R[t] = eo(R[t], x, r), y === S) {
    const k = a ? m[W] : Z[C1[W]];
    R[Sh[S]] = Math.floor(k - l[S] + G);
  } else R[S] = Math.floor(l[S] + l[W] + G);
  return R;
}
function QE(l, Z, u, s, G, i, m, a) {
  const n = s ? u.height : Z[C1.height];
  let p = l.top != null ? u.top + l.top : u.top + (n - l.bottom - m), y = a !== "top" ? (
    // We want the distance between the top of the overlay to the bottom of the boundary
    Math.max(0, Z.height + Z.top + Z.scroll.top - p - (G.top + G.bottom + i))
  ) : Math.max(0, p + m - (Z.top + Z.scroll.top) - (G.top + G.bottom + i));
  return Math.min(Z.height - i * 2, y);
}
function x2(l, Z, u, s, G, i) {
  let { placement: m, axis: a, size: n } = i;
  return m === a ? Math.max(0, u[a] - l[a] - l.scroll[a] + Z[a] - s[a] - s[Sh[a]] - G) : Math.max(0, l[n] + l[a] + l.scroll[a] - Z[a] - u[a] - u[n] - s[a] - s[Sh[a]] - G);
}
function PE(l, Z, u, s, G, i, m, a, n, p, y, h, S, t, W, V) {
  let R = V2(l), { size: x, crossAxis: r, crossSize: k, placement: U, crossPlacement: w } = R, z = FK(Z, a, u, R, y, h, p, S, W, V), D = y, C = x2(a, p, Z, G, i + y, R);
  if (m && s[x] > C) {
    let il = V2(`${Sh[U]} ${w}`), Zl = FK(Z, a, u, il, y, h, p, S, W, V);
    x2(a, p, Z, G, i + y, il) > C && (R = il, z = Zl, D = y);
  }
  let j = "bottom";
  R.axis === "top" ? R.placement === "top" ? j = "top" : R.placement === "bottom" && (j = "bottom") : R.crossAxis === "top" && (R.crossPlacement === "top" ? j = "bottom" : R.crossPlacement === "bottom" && (j = "top"));
  let E = W2(r, z[r], u[k], a, n, i, p);
  z[r] += E;
  let g = QE(z, a, p, S, G, i, u.height, j);
  t && t < g && (g = t), u.height = Math.min(u.height, g), z = FK(Z, a, u, R, D, h, p, S, W, V), E = W2(r, z[r], u[k], a, n, i, p), z[r] += E;
  let A = {}, J = Z[r] + 0.5 * Z[k] - z[r] - G[hs[r]];
  const F = W / 2 + V, v = hs[r] === "left" ? G.left + G.right : G.top + G.bottom, T = u[k] - v - W / 2 - V, f = Z[r] + W / 2 - (z[r] + G[hs[r]]), O = Z[r] + Z[k] - W / 2 - (z[r] + G[hs[r]]), _ = eo(J, f, O);
  return A[r] = eo(_, F, T), {
    position: z,
    maxHeight: g,
    arrowOffsetLeft: A.left,
    arrowOffsetTop: A.top,
    placement: R.placement
  };
}
function OE(l) {
  let { placement: Z, targetNode: u, overlayNode: s, scrollNode: G, padding: i, shouldFlip: m, boundaryElement: a, offset: n, crossOffset: p, maxHeight: y, arrowSize: h = 0, arrowBoundaryOffset: S = 0 } = l, t = s instanceof HTMLElement ? AE(s) : document.documentElement, W = t === document.documentElement;
  const V = window.getComputedStyle(t).position;
  let R = !!V && V !== "static", x = W ? Di(u) : R2(u, t);
  if (!W) {
    let { marginTop: C, marginLeft: j } = window.getComputedStyle(u);
    x.top += parseInt(C, 10) || 0, x.left += parseInt(j, 10) || 0;
  }
  let r = Di(s), k = jE(s);
  r.width += k.left + k.right, r.height += k.top + k.bottom;
  let U = DE(G), w = K2(a), z = K2(t), D = a.tagName === "BODY" ? Di(t) : R2(t, a);
  return t.tagName === "HTML" && a.tagName === "BODY" && (z.scroll.top = 0, z.scroll.left = 0), PE(Z, x, r, U, k, i, m, w, z, D, n, p, R, y, h, S);
}
function Di(l) {
  let { top: Z, left: u, width: s, height: G } = l.getBoundingClientRect(), { scrollTop: i, scrollLeft: m, clientTop: a, clientLeft: n } = document.documentElement;
  return {
    top: Z + i - a,
    left: u + m - n,
    width: s,
    height: G
  };
}
function R2(l, Z) {
  let u = window.getComputedStyle(l), s;
  if (u.position === "fixed") {
    let { top: G, left: i, width: m, height: a } = l.getBoundingClientRect();
    s = {
      top: G,
      left: i,
      width: m,
      height: a
    };
  } else {
    s = Di(l);
    let G = Di(Z), i = window.getComputedStyle(Z);
    G.top += (parseInt(i.borderTopWidth, 10) || 0) - Z.scrollTop, G.left += (parseInt(i.borderLeftWidth, 10) || 0) - Z.scrollLeft, s.top -= G.top, s.left -= G.left;
  }
  return s.top -= parseInt(u.marginTop, 10) || 0, s.left -= parseInt(u.marginLeft, 10) || 0, s;
}
function AE(l) {
  let Z = l.offsetParent;
  if (Z && Z === document.body && window.getComputedStyle(Z).position === "static" && !Y2(Z) && (Z = document.documentElement), Z == null)
    for (Z = l.parentElement; Z && !Y2(Z); ) Z = Z.parentElement;
  return Z || document.documentElement;
}
function Y2(l) {
  let Z = window.getComputedStyle(l);
  return Z.transform !== "none" || /transform|perspective/.test(Z.willChange) || Z.filter !== "none" || Z.contain === "paint" || // @ts-ignore
  "backdropFilter" in Z && Z.backdropFilter !== "none" || // @ts-ignore
  "WebkitBackdropFilter" in Z && Z.WebkitBackdropFilter !== "none";
}
const r1 = /* @__PURE__ */ new WeakMap();
function $E(l) {
  let { triggerRef: Z, isOpen: u, onClose: s } = l;
  M.useEffect(() => {
    if (!u || s === null) return;
    let G = (i) => {
      let m = i.target;
      if (!Z.current || m instanceof Node && !m.contains(Z.current) || i.target instanceof HTMLInputElement || i.target instanceof HTMLTextAreaElement) return;
      let a = s || r1.get(Z.current);
      a && a();
    };
    return window.addEventListener("scroll", G, !0), () => {
      window.removeEventListener("scroll", G, !0);
    };
  }, [
    u,
    s,
    Z
  ]);
}
let pc = typeof document < "u" && window.visualViewport;
function qE(l) {
  let { direction: Z } = Im(), { arrowSize: u = 0, targetRef: s, overlayRef: G, scrollRef: i = G, placement: m = "bottom", containerPadding: a = 12, shouldFlip: n = !0, boundaryElement: p = typeof document < "u" ? document.body : null, offset: y = 0, crossOffset: h = 0, shouldUpdatePosition: S = !0, isOpen: t = !0, onClose: W, maxHeight: V, arrowBoundaryOffset: R = 0 } = l, [x, r] = M.useState({
    position: {},
    arrowOffsetLeft: void 0,
    arrowOffsetTop: void 0,
    maxHeight: void 0,
    placement: void 0
  }), k = [
    S,
    m,
    G.current,
    s.current,
    i.current,
    a,
    n,
    p,
    y,
    h,
    t,
    Z,
    V,
    R,
    u
  ], U = M.useRef(pc == null ? void 0 : pc.scale);
  M.useEffect(() => {
    t && (U.current = pc == null ? void 0 : pc.scale);
  }, [
    t
  ]);
  let w = M.useCallback(() => {
    if (S === !1 || !t || !G.current || !s.current || !p || (pc == null ? void 0 : pc.scale) !== U.current) return;
    let j = null;
    if (i.current && i.current.contains(document.activeElement)) {
      let F = document.activeElement.getBoundingClientRect(), v = i.current.getBoundingClientRect();
      j = {
        type: "top",
        offset: F.top - v.top
      }, j.offset > v.height / 2 && (j.type = "bottom", j.offset = F.bottom - v.bottom);
    }
    let E = G.current;
    if (!V && G.current) {
      var g;
      E.style.top = "0px", E.style.bottom = "";
      var A;
      E.style.maxHeight = ((A = (g = window.visualViewport) === null || g === void 0 ? void 0 : g.height) !== null && A !== void 0 ? A : window.innerHeight) + "px";
    }
    let J = OE({
      placement: l4(m, Z),
      overlayNode: G.current,
      targetNode: s.current,
      scrollNode: i.current || G.current,
      padding: a,
      shouldFlip: n,
      boundaryElement: p,
      offset: y,
      crossOffset: h,
      maxHeight: V,
      arrowSize: u,
      arrowBoundaryOffset: R
    });
    if (E.style.top = "", E.style.bottom = "", E.style.left = "", E.style.right = "", Object.keys(J.position).forEach((F) => E.style[F] = J.position[F] + "px"), E.style.maxHeight = J.maxHeight != null ? J.maxHeight + "px" : void 0, j) {
      let F = document.activeElement.getBoundingClientRect(), v = i.current.getBoundingClientRect(), T = F[j.type] - v[j.type];
      i.current.scrollTop += T - j.offset;
    }
    r(J);
  }, k);
  PZ(w, k), _E(w), oW({
    ref: G,
    onResize: w
  }), oW({
    ref: s,
    onResize: w
  });
  let z = M.useRef(!1);
  PZ(() => {
    let j, E = () => {
      z.current = !0, clearTimeout(j), j = setTimeout(() => {
        z.current = !1;
      }, 500), w();
    }, g = () => {
      z.current && E();
    };
    return pc == null || pc.addEventListener("resize", E), pc == null || pc.addEventListener("scroll", g), () => {
      pc == null || pc.removeEventListener("resize", E), pc == null || pc.removeEventListener("scroll", g);
    };
  }, [
    w
  ]);
  let D = M.useCallback(() => {
    z.current || W();
  }, [
    W,
    z
  ]);
  $E({
    triggerRef: s,
    isOpen: t,
    onClose: W && D
  });
  var C;
  return {
    overlayProps: {
      style: {
        position: "absolute",
        zIndex: 1e5,
        ...x.position,
        maxHeight: (C = x.maxHeight) !== null && C !== void 0 ? C : "100vh"
      }
    },
    placement: x.placement,
    arrowProps: {
      "aria-hidden": "true",
      role: "presentation",
      style: {
        left: x.arrowOffsetLeft,
        top: x.arrowOffsetTop
      }
    },
    updatePosition: w
  };
}
function _E(l) {
  PZ(() => (window.addEventListener("resize", l, !1), () => {
    window.removeEventListener("resize", l, !1);
  }), [
    l
  ]);
}
function l4(l, Z) {
  return Z === "rtl" ? l.replace("start", "right").replace("end", "left") : l.replace("start", "left").replace("end", "right");
}
const ld = [];
function Z4(l, Z) {
  let { onClose: u, shouldCloseOnBlur: s, isOpen: G, isDismissable: i = !1, isKeyboardDismissDisabled: m = !1, shouldCloseOnInteractOutside: a } = l;
  M.useEffect(() => (G && ld.push(Z), () => {
    let W = ld.indexOf(Z);
    W >= 0 && ld.splice(W, 1);
  }), [
    G,
    Z
  ]);
  let n = () => {
    ld[ld.length - 1] === Z && u && u();
  }, p = (W) => {
    (!a || a(W.target)) && ld[ld.length - 1] === Z && (W.stopPropagation(), W.preventDefault());
  }, y = (W) => {
    (!a || a(W.target)) && (ld[ld.length - 1] === Z && (W.stopPropagation(), W.preventDefault()), n());
  }, h = (W) => {
    W.key === "Escape" && !m && !W.nativeEvent.isComposing && (W.stopPropagation(), W.preventDefault(), n());
  };
  S1({
    ref: Z,
    onInteractOutside: i && G ? y : null,
    onInteractOutsideStart: p
  });
  let { focusWithinProps: S } = RV({
    isDisabled: !s,
    onBlurWithin: (W) => {
      !W.relatedTarget || iE(W.relatedTarget) || (!a || a(W.relatedTarget)) && u();
    }
  }), t = (W) => {
    W.target === W.currentTarget && W.preventDefault();
  };
  return {
    overlayProps: {
      onKeyDown: h,
      ...S
    },
    underlayProps: {
      onPointerDown: t
    }
  };
}
function c4(l, Z, u) {
  let { type: s } = l, { isOpen: G } = Z;
  M.useEffect(() => {
    u && u.current && r1.set(u.current, Z.close);
  });
  let i;
  s === "menu" ? i = !0 : s === "listbox" && (i = "listbox");
  let m = ad();
  return {
    triggerProps: {
      "aria-haspopup": i,
      "aria-expanded": G,
      "aria-controls": G ? m : null,
      onPress: Z.toggle
    },
    overlayProps: {
      id: m
    }
  };
}
const NK = typeof document < "u" && window.visualViewport, b4 = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
let jL = 0, wK;
function u4(l = {}) {
  let { isDisabled: Z } = l;
  PZ(() => {
    if (!Z)
      return jL++, jL === 1 && (Jh() ? wK = d4() : wK = s4()), () => {
        jL--, jL === 0 && wK();
      };
  }, [
    Z
  ]);
}
function s4() {
  return Ha(fi(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), fi(document.documentElement, "overflow", "hidden"));
}
function d4() {
  let l, Z, u = (p) => {
    l = b1(p.target, !0), !(l === document.documentElement && l === document.body) && l instanceof HTMLElement && window.getComputedStyle(l).overscrollBehavior === "auto" && (Z = fi(l, "overscrollBehavior", "contain"));
  }, s = (p) => {
    if (!l || l === document.documentElement || l === document.body) {
      p.preventDefault();
      return;
    }
    l.scrollHeight === l.clientHeight && l.scrollWidth === l.clientWidth && p.preventDefault();
  }, G = (p) => {
    let y = p.target;
    M2(y) && y !== document.activeElement && (p.preventDefault(), a(), y.style.transform = "translateY(-2000px)", y.focus(), requestAnimationFrame(() => {
      y.style.transform = "";
    })), Z && Z();
  }, i = (p) => {
    let y = p.target;
    M2(y) && (a(), y.style.transform = "translateY(-2000px)", requestAnimationFrame(() => {
      y.style.transform = "", NK && (NK.height < window.innerHeight ? requestAnimationFrame(() => {
        k2(y);
      }) : NK.addEventListener("resize", () => k2(y), {
        once: !0
      }));
    }));
  }, m = null, a = () => {
    if (m) return;
    let p = () => {
      window.scrollTo(0, 0);
    }, y = window.pageXOffset, h = window.pageYOffset;
    m = Ha(ya(window, "scroll", p), fi(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), fi(document.documentElement, "overflow", "hidden"), fi(document.body, "marginTop", `-${h}px`), () => {
      window.scrollTo(y, h);
    }), window.scrollTo(0, 0);
  }, n = Ha(ya(document, "touchstart", u, {
    passive: !1,
    capture: !0
  }), ya(document, "touchmove", s, {
    passive: !1,
    capture: !0
  }), ya(document, "touchend", G, {
    passive: !1,
    capture: !0
  }), ya(document, "focus", i, !0));
  return () => {
    Z == null || Z(), m == null || m(), n();
  };
}
function fi(l, Z, u) {
  let s = l.style[Z];
  return l.style[Z] = u, () => {
    l.style[Z] = s;
  };
}
function ya(l, Z, u, s) {
  return l.addEventListener(Z, u, s), () => {
    l.removeEventListener(Z, u, s);
  };
}
function k2(l) {
  let Z = document.scrollingElement || document.documentElement;
  for (; l && l !== Z; ) {
    let u = b1(l);
    if (u !== document.documentElement && u !== document.body && u !== l) {
      let s = u.getBoundingClientRect().top, G = l.getBoundingClientRect().top;
      G > s + l.clientHeight && (u.scrollTop += G - s);
    }
    l = u.parentElement;
  }
}
function M2(l) {
  return l instanceof HTMLInputElement && !b4.has(l.type) || l instanceof HTMLTextAreaElement || l instanceof HTMLElement && l.isContentEditable;
}
var F1 = {};
F1 = {
  dismiss: "تجاهل"
};
var N1 = {};
N1 = {
  dismiss: "Отхвърляне"
};
var w1 = {};
w1 = {
  dismiss: "Odstranit"
};
var z1 = {};
z1 = {
  dismiss: "Luk"
};
var J1 = {};
J1 = {
  dismiss: "Schließen"
};
var H1 = {};
H1 = {
  dismiss: "Απόρριψη"
};
var g1 = {};
g1 = {
  dismiss: "Dismiss"
};
var v1 = {};
v1 = {
  dismiss: "Descartar"
};
var T1 = {};
T1 = {
  dismiss: "Lõpeta"
};
var f1 = {};
f1 = {
  dismiss: "Hylkää"
};
var E1 = {};
E1 = {
  dismiss: "Rejeter"
};
var B1 = {};
B1 = {
  dismiss: "התעלם"
};
var D1 = {};
D1 = {
  dismiss: "Odbaci"
};
var j1 = {};
j1 = {
  dismiss: "Elutasítás"
};
var Q1 = {};
Q1 = {
  dismiss: "Ignora"
};
var P1 = {};
P1 = {
  dismiss: "閉じる"
};
var O1 = {};
O1 = {
  dismiss: "무시"
};
var A1 = {};
A1 = {
  dismiss: "Atmesti"
};
var $1 = {};
$1 = {
  dismiss: "Nerādīt"
};
var q1 = {};
q1 = {
  dismiss: "Lukk"
};
var _1 = {};
_1 = {
  dismiss: "Negeren"
};
var l9 = {};
l9 = {
  dismiss: "Zignoruj"
};
var Z9 = {};
Z9 = {
  dismiss: "Descartar"
};
var c9 = {};
c9 = {
  dismiss: "Dispensar"
};
var b9 = {};
b9 = {
  dismiss: "Revocare"
};
var u9 = {};
u9 = {
  dismiss: "Пропустить"
};
var s9 = {};
s9 = {
  dismiss: "Zrušiť"
};
var d9 = {};
d9 = {
  dismiss: "Opusti"
};
var G9 = {};
G9 = {
  dismiss: "Odbaci"
};
var m9 = {};
m9 = {
  dismiss: "Avvisa"
};
var i9 = {};
i9 = {
  dismiss: "Kapat"
};
var o9 = {};
o9 = {
  dismiss: "Скасувати"
};
var e9 = {};
e9 = {
  dismiss: "取消"
};
var a9 = {};
a9 = {
  dismiss: "關閉"
};
var n9 = {};
n9 = {
  "ar-AE": F1,
  "bg-BG": N1,
  "cs-CZ": w1,
  "da-DK": z1,
  "de-DE": J1,
  "el-GR": H1,
  "en-US": g1,
  "es-ES": v1,
  "et-EE": T1,
  "fi-FI": f1,
  "fr-FR": E1,
  "he-IL": B1,
  "hr-HR": D1,
  "hu-HU": j1,
  "it-IT": Q1,
  "ja-JP": P1,
  "ko-KR": O1,
  "lt-LT": A1,
  "lv-LV": $1,
  "nb-NO": q1,
  "nl-NL": _1,
  "pl-PL": l9,
  "pt-BR": Z9,
  "pt-PT": c9,
  "ro-RO": b9,
  "ru-RU": u9,
  "sk-SK": s9,
  "sl-SI": d9,
  "sr-SP": G9,
  "sv-SE": m9,
  "tr-TR": i9,
  "uk-UA": o9,
  "zh-CN": e9,
  "zh-TW": a9
};
function G4(l) {
  return l && l.__esModule ? l.default : l;
}
function I2(l) {
  let { onDismiss: Z, ...u } = l, s = Y1(G4(n9), "@react-aria/overlays"), G = c1(u, s.format("dismiss")), i = () => {
    Z && Z();
  };
  return /* @__PURE__ */ tl.createElement(U1, null, /* @__PURE__ */ tl.createElement("button", {
    ...G,
    tabIndex: -1,
    onClick: i,
    style: {
      width: 1,
      height: 1
    }
  }));
}
let Sa = /* @__PURE__ */ new WeakMap(), au = [];
function m4(l, Z = document.body) {
  let u = new Set(l), s = /* @__PURE__ */ new Set(), G = (n) => {
    for (let S of n.querySelectorAll("[data-live-announcer], [data-react-aria-top-layer]")) u.add(S);
    let p = (S) => {
      if (u.has(S) || s.has(S.parentElement) && S.parentElement.getAttribute("role") !== "row") return NodeFilter.FILTER_REJECT;
      for (let t of u)
        if (S.contains(t)) return NodeFilter.FILTER_SKIP;
      return NodeFilter.FILTER_ACCEPT;
    }, y = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: p
    }), h = p(n);
    if (h === NodeFilter.FILTER_ACCEPT && i(n), h !== NodeFilter.FILTER_REJECT) {
      let S = y.nextNode();
      for (; S != null; )
        i(S), S = y.nextNode();
    }
  }, i = (n) => {
    var p;
    let y = (p = Sa.get(n)) !== null && p !== void 0 ? p : 0;
    n.getAttribute("aria-hidden") === "true" && y === 0 || (y === 0 && n.setAttribute("aria-hidden", "true"), s.add(n), Sa.set(n, y + 1));
  };
  au.length && au[au.length - 1].disconnect(), G(Z);
  let m = new MutationObserver((n) => {
    for (let p of n)
      if (!(p.type !== "childList" || p.addedNodes.length === 0) && ![
        ...u,
        ...s
      ].some((y) => y.contains(p.target))) {
        for (let y of p.removedNodes) y instanceof Element && (u.delete(y), s.delete(y));
        for (let y of p.addedNodes)
          (y instanceof HTMLElement || y instanceof SVGElement) && (y.dataset.liveAnnouncer === "true" || y.dataset.reactAriaTopLayer === "true") ? u.add(y) : y instanceof Element && G(y);
      }
  });
  m.observe(Z, {
    childList: !0,
    subtree: !0
  });
  let a = {
    observe() {
      m.observe(Z, {
        childList: !0,
        subtree: !0
      });
    },
    disconnect() {
      m.disconnect();
    }
  };
  return au.push(a), () => {
    m.disconnect();
    for (let n of s) {
      let p = Sa.get(n);
      p === 1 ? (n.removeAttribute("aria-hidden"), Sa.delete(n)) : Sa.set(n, p - 1);
    }
    a === au[au.length - 1] ? (au.pop(), au.length && au[au.length - 1].observe()) : au.splice(au.indexOf(a), 1);
  };
}
function i4(l, Z) {
  let { triggerRef: u, popoverRef: s, isNonModal: G, isKeyboardDismissDisabled: i, shouldCloseOnInteractOutside: m, ...a } = l, { overlayProps: n, underlayProps: p } = Z4({
    isOpen: Z.isOpen,
    onClose: Z.close,
    shouldCloseOnBlur: !0,
    isDismissable: !G,
    isKeyboardDismissDisabled: i,
    shouldCloseOnInteractOutside: m
  }, s), { overlayProps: y, arrowProps: h, placement: S } = qE({
    ...a,
    targetRef: u,
    overlayRef: s,
    isOpen: Z.isOpen,
    onClose: G ? Z.close : null
  });
  return u4({
    isDisabled: G || !Z.isOpen
  }), PZ(() => {
    if (Z.isOpen && !G && s.current) return m4([
      s.current
    ]);
  }, [
    G,
    Z.isOpen,
    s
  ]), {
    popoverProps: HZ(n, y),
    arrowProps: h,
    underlayProps: p,
    placement: S
  };
}
const o4 = /* @__PURE__ */ M.createContext({});
function e4() {
  var l;
  return (l = M.useContext(o4)) !== null && l !== void 0 ? l : {};
}
const a4 = /* @__PURE__ */ tl.createContext(null);
function n4(l) {
  let Z = Mm(), { portalContainer: u = Z ? null : document.body, isExiting: s } = l, [G, i] = M.useState(!1), m = M.useMemo(() => ({
    contain: G,
    setContain: i
  }), [
    G,
    i
  ]), { getContainer: a } = e4();
  if (!l.portalContainer && a && (u = a()), !u) return null;
  let n = l.children;
  return l.disableFocusManagement || (n = /* @__PURE__ */ tl.createElement(W1, {
    restoreFocus: !0,
    contain: G && !s
  }, n)), n = /* @__PURE__ */ tl.createElement(a4.Provider, {
    value: m
  }, /* @__PURE__ */ tl.createElement(jf, null, n)), /* @__PURE__ */ DI.createPortal(n, u);
}
function YW(l) {
  return sf() ? l.altKey : l.ctrlKey;
}
function vi(l) {
  return Sm() ? l.metaKey : l.ctrlKey;
}
const p4 = 1e3;
function L4(l) {
  let { keyboardDelegate: Z, selectionManager: u, onTypeSelect: s } = l, G = M.useRef({
    search: "",
    timeout: null
  }).current, i = (m) => {
    let a = h4(m.key);
    if (!a || m.ctrlKey || m.metaKey || !m.currentTarget.contains(m.target)) return;
    a === " " && G.search.trim().length > 0 && (m.preventDefault(), "continuePropagation" in m || m.stopPropagation()), G.search += a;
    let n = Z.getKeyForSearch(G.search, u.focusedKey);
    n == null && (n = Z.getKeyForSearch(G.search)), n != null && (u.setFocusedKey(n), s && s(n)), clearTimeout(G.timeout), G.timeout = setTimeout(() => {
      G.search = "";
    }, p4);
  };
  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: Z.getKeyForSearch ? i : null
    }
  };
}
function h4(l) {
  return l.length === 1 || !/^[A-Z]/i.test(l) ? l : "";
}
function y4(l) {
  let { selectionManager: Z, keyboardDelegate: u, ref: s, autoFocus: G = !1, shouldFocusWrap: i = !1, disallowEmptySelection: m = !1, disallowSelectAll: a = !1, selectOnFocus: n = Z.selectionBehavior === "replace", disallowTypeAhead: p = !1, shouldUseVirtualFocus: y, allowsTabNavigation: h = !1, isVirtualized: S, scrollRef: t = s, linkBehavior: W = "action" } = l, { direction: V } = Im(), R = nn(), x = (E) => {
    if (E.altKey && E.key === "Tab" && E.preventDefault(), !s.current.contains(E.target)) return;
    const g = (ml, Rl) => {
      if (ml != null) {
        if (Z.isLink(ml) && W === "selection" && n && !YW(E)) {
          xo.flushSync(() => {
            Z.setFocusedKey(ml, Rl);
          });
          let kl = t.current.querySelector(`[data-key="${CSS.escape(ml.toString())}"]`), zl = Z.getItemProps(ml);
          R.open(kl, E, zl.href, zl.routerOptions);
          return;
        }
        if (Z.setFocusedKey(ml, Rl), Z.isLink(ml) && W === "override") return;
        E.shiftKey && Z.selectionMode === "multiple" ? Z.extendSelection(ml) : n && !YW(E) && Z.replaceSelection(ml);
      }
    };
    switch (E.key) {
      case "ArrowDown":
        if (u.getKeyBelow) {
          var A, J, F;
          let ml = Z.focusedKey != null ? (A = u.getKeyBelow) === null || A === void 0 ? void 0 : A.call(u, Z.focusedKey) : (J = u.getFirstKey) === null || J === void 0 ? void 0 : J.call(u);
          ml == null && i && (ml = (F = u.getFirstKey) === null || F === void 0 ? void 0 : F.call(u, Z.focusedKey)), ml != null && (E.preventDefault(), g(ml));
        }
        break;
      case "ArrowUp":
        if (u.getKeyAbove) {
          var v, T, f;
          let ml = Z.focusedKey != null ? (v = u.getKeyAbove) === null || v === void 0 ? void 0 : v.call(u, Z.focusedKey) : (T = u.getLastKey) === null || T === void 0 ? void 0 : T.call(u);
          ml == null && i && (ml = (f = u.getLastKey) === null || f === void 0 ? void 0 : f.call(u, Z.focusedKey)), ml != null && (E.preventDefault(), g(ml));
        }
        break;
      case "ArrowLeft":
        if (u.getKeyLeftOf) {
          var O, _, il;
          let ml = (O = u.getKeyLeftOf) === null || O === void 0 ? void 0 : O.call(u, Z.focusedKey);
          ml == null && i && (ml = V === "rtl" ? (_ = u.getFirstKey) === null || _ === void 0 ? void 0 : _.call(u, Z.focusedKey) : (il = u.getLastKey) === null || il === void 0 ? void 0 : il.call(u, Z.focusedKey)), ml != null && (E.preventDefault(), g(ml, V === "rtl" ? "first" : "last"));
        }
        break;
      case "ArrowRight":
        if (u.getKeyRightOf) {
          var Zl, ol, Wl;
          let ml = (Zl = u.getKeyRightOf) === null || Zl === void 0 ? void 0 : Zl.call(u, Z.focusedKey);
          ml == null && i && (ml = V === "rtl" ? (ol = u.getLastKey) === null || ol === void 0 ? void 0 : ol.call(u, Z.focusedKey) : (Wl = u.getFirstKey) === null || Wl === void 0 ? void 0 : Wl.call(u, Z.focusedKey)), ml != null && (E.preventDefault(), g(ml, V === "rtl" ? "last" : "first"));
        }
        break;
      case "Home":
        if (u.getFirstKey) {
          E.preventDefault();
          let ml = u.getFirstKey(Z.focusedKey, vi(E));
          Z.setFocusedKey(ml), vi(E) && E.shiftKey && Z.selectionMode === "multiple" ? Z.extendSelection(ml) : n && Z.replaceSelection(ml);
        }
        break;
      case "End":
        if (u.getLastKey) {
          E.preventDefault();
          let ml = u.getLastKey(Z.focusedKey, vi(E));
          Z.setFocusedKey(ml), vi(E) && E.shiftKey && Z.selectionMode === "multiple" ? Z.extendSelection(ml) : n && Z.replaceSelection(ml);
        }
        break;
      case "PageDown":
        if (u.getKeyPageBelow) {
          let ml = u.getKeyPageBelow(Z.focusedKey);
          ml != null && (E.preventDefault(), g(ml));
        }
        break;
      case "PageUp":
        if (u.getKeyPageAbove) {
          let ml = u.getKeyPageAbove(Z.focusedKey);
          ml != null && (E.preventDefault(), g(ml));
        }
        break;
      case "a":
        vi(E) && Z.selectionMode === "multiple" && a !== !0 && (E.preventDefault(), Z.selectAll());
        break;
      case "Escape":
        !m && Z.selectedKeys.size !== 0 && (E.stopPropagation(), E.preventDefault(), Z.clearSelection());
        break;
      case "Tab":
        if (!h) {
          if (E.shiftKey) s.current.focus();
          else {
            let ml = sd(s.current, {
              tabbable: !0
            }), Rl, kl;
            do
              kl = ml.lastChild(), kl && (Rl = kl);
            while (kl);
            Rl && !Rl.contains(document.activeElement) && Ls(Rl);
          }
          break;
        }
    }
  }, r = M.useRef({
    top: 0,
    left: 0
  });
  Ak(t, "scroll", S ? null : () => {
    r.current = {
      top: t.current.scrollTop,
      left: t.current.scrollLeft
    };
  });
  let k = (E) => {
    if (Z.isFocused) {
      E.currentTarget.contains(E.target) || Z.setFocused(!1);
      return;
    }
    if (E.currentTarget.contains(E.target)) {
      if (Z.setFocused(!0), Z.focusedKey == null) {
        let J = (v) => {
          v != null && (Z.setFocusedKey(v), n && Z.replaceSelection(v));
        }, F = E.relatedTarget;
        var g, A;
        F && E.currentTarget.compareDocumentPosition(F) & Node.DOCUMENT_POSITION_FOLLOWING ? J((g = Z.lastSelectedKey) !== null && g !== void 0 ? g : u.getLastKey()) : J((A = Z.firstSelectedKey) !== null && A !== void 0 ? A : u.getFirstKey());
      } else S || (t.current.scrollTop = r.current.top, t.current.scrollLeft = r.current.left);
      if (Z.focusedKey != null) {
        let J = t.current.querySelector(`[data-key="${CSS.escape(Z.focusedKey.toString())}"]`);
        J && (J.contains(document.activeElement) || Ls(J), yW() === "keyboard" && qk(J, {
          containingElement: s.current
        }));
      }
    }
  }, U = (E) => {
    E.currentTarget.contains(E.relatedTarget) || Z.setFocused(!1);
  };
  const w = M.useRef(G);
  M.useEffect(() => {
    if (w.current) {
      let E = null;
      G === "first" && (E = u.getFirstKey()), G === "last" && (E = u.getLastKey());
      let g = Z.selectedKeys;
      if (g.size) {
        for (let A of g) if (Z.canSelectItem(A)) {
          E = A;
          break;
        }
      }
      Z.setFocused(!0), Z.setFocusedKey(E), E == null && !y && Ea(s.current);
    }
  }, []);
  let z = M.useRef(Z.focusedKey);
  M.useEffect(() => {
    if (Z.isFocused && Z.focusedKey != null && (Z.focusedKey !== z.current || w.current) && (t != null && t.current)) {
      let E = yW(), g = s.current.querySelector(`[data-key="${CSS.escape(Z.focusedKey.toString())}"]`);
      if (!g)
        return;
      (E === "keyboard" || w.current) && (u1(t.current, g), E !== "virtual" && qk(g, {
        containingElement: s.current
      }));
    }
    !y && Z.isFocused && Z.focusedKey == null && z.current != null && Ea(s.current), z.current = Z.focusedKey, w.current = !1;
  }), Ak(s, "react-aria-focus-scope-restore", (E) => {
    E.preventDefault(), Z.setFocused(!0);
  });
  let D = {
    onKeyDown: x,
    onFocus: k,
    onBlur: U,
    onMouseDown(E) {
      t.current === E.target && E.preventDefault();
    }
  }, { typeSelectProps: C } = L4({
    keyboardDelegate: u,
    selectionManager: Z
  });
  p || (D = HZ(C, D));
  let j;
  return y || (j = Z.focusedKey == null ? 0 : -1), {
    collectionProps: {
      ...D,
      tabIndex: j
    }
  };
}
function S4(l) {
  let { selectionManager: Z, key: u, ref: s, shouldSelectOnPressUp: G, shouldUseVirtualFocus: i, focus: m, isDisabled: a, onAction: n, allowsDifferentPressOrigin: p, linkBehavior: y = "action" } = l, h = nn(), S = (f) => {
    if (f.pointerType === "keyboard" && YW(f)) Z.toggleSelection(u);
    else {
      if (Z.selectionMode === "none") return;
      if (Z.isLink(u)) {
        if (y === "selection") {
          let O = Z.getItemProps(u);
          h.open(s.current, f, O.href, O.routerOptions), Z.setSelectedKeys(Z.selectedKeys);
          return;
        } else if (y === "override" || y === "none") return;
      }
      Z.selectionMode === "single" ? Z.isSelected(u) && !Z.disallowEmptySelection ? Z.toggleSelection(u) : Z.replaceSelection(u) : f && f.shiftKey ? Z.extendSelection(u) : Z.selectionBehavior === "toggle" || f && (vi(f) || f.pointerType === "touch" || f.pointerType === "virtual") ? Z.toggleSelection(u) : Z.replaceSelection(u);
    }
  };
  M.useEffect(() => {
    u === Z.focusedKey && Z.isFocused && !i && (m ? m() : document.activeElement !== s.current && Ea(s.current));
  }, [
    s,
    u,
    Z.focusedKey,
    Z.childFocusStrategy,
    Z.isFocused,
    i
  ]), a = a || Z.isDisabled(u);
  let t = {};
  !i && !a ? t = {
    tabIndex: u === Z.focusedKey ? 0 : -1,
    onFocus(f) {
      f.target === s.current && Z.setFocusedKey(u);
    }
  } : a && (t.onMouseDown = (f) => {
    f.preventDefault();
  });
  let W = Z.isLink(u) && y === "override", V = Z.isLink(u) && y !== "selection" && y !== "none", R = !a && Z.canSelectItem(u) && !W, x = (n || V) && !a, r = x && (Z.selectionBehavior === "replace" ? !R : !R || Z.isEmpty), k = x && R && Z.selectionBehavior === "replace", U = r || k, w = M.useRef(null), z = U && R, D = M.useRef(!1), C = M.useRef(!1), j = (f) => {
    if (n && n(), V) {
      let O = Z.getItemProps(u);
      h.open(s.current, f, O.href, O.routerOptions);
    }
  }, E = {};
  G ? (E.onPressStart = (f) => {
    w.current = f.pointerType, D.current = z, f.pointerType === "keyboard" && (!U || C2()) && S(f);
  }, p ? (E.onPressUp = r ? null : (f) => {
    f.pointerType !== "keyboard" && R && S(f);
  }, E.onPress = r ? j : null) : E.onPress = (f) => {
    if (r || k && f.pointerType !== "mouse") {
      if (f.pointerType === "keyboard" && !U2()) return;
      j(f);
    } else f.pointerType !== "keyboard" && R && S(f);
  }) : (E.onPressStart = (f) => {
    w.current = f.pointerType, D.current = z, C.current = r, R && (f.pointerType === "mouse" && !r || f.pointerType === "keyboard" && (!x || C2())) && S(f);
  }, E.onPress = (f) => {
    (f.pointerType === "touch" || f.pointerType === "pen" || f.pointerType === "virtual" || f.pointerType === "keyboard" && U && U2() || f.pointerType === "mouse" && C.current) && (U ? j(f) : R && S(f));
  }), t["data-key"] = u, E.preventFocusOnPress = i;
  let { pressProps: g, isPressed: A } = hn(E), J = k ? (f) => {
    w.current === "mouse" && (f.stopPropagation(), f.preventDefault(), j(f));
  } : void 0, { longPressProps: F } = X1({
    isDisabled: !z,
    onLongPress(f) {
      f.pointerType === "touch" && (S(f), Z.setSelectionBehavior("toggle"));
    }
  }), v = (f) => {
    w.current === "touch" && D.current && f.preventDefault();
  }, T = Z.isLink(u) ? (f) => {
    tm.isOpening || f.preventDefault();
  } : void 0;
  return {
    itemProps: HZ(t, R || r ? g : {}, z ? F : {}, {
      onDoubleClick: J,
      onDragStartCapture: v,
      onClick: T
    }),
    isPressed: A,
    isSelected: Z.isSelected(u),
    isFocused: Z.isFocused && Z.focusedKey === u,
    isDisabled: a,
    allowsSelection: R,
    hasAction: U
  };
}
function U2() {
  let l = window.event;
  return (l == null ? void 0 : l.key) === "Enter";
}
function C2() {
  let l = window.event;
  return (l == null ? void 0 : l.key) === " " || (l == null ? void 0 : l.code) === "Space";
}
class r2 {
  getItemRect(Z) {
    let u = this.ref.current, s = Z != null ? u.querySelector(`[data-key="${CSS.escape(Z.toString())}"]`) : null;
    if (!s) return null;
    let G = u.getBoundingClientRect(), i = s.getBoundingClientRect();
    return {
      x: i.left - G.left + u.scrollLeft,
      y: i.top - G.top + u.scrollTop,
      width: i.width,
      height: i.height
    };
  }
  getContentSize() {
    let Z = this.ref.current;
    return {
      width: Z.scrollWidth,
      height: Z.scrollHeight
    };
  }
  getVisibleRect() {
    let Z = this.ref.current;
    return {
      x: Z.scrollLeft,
      y: Z.scrollTop,
      width: Z.offsetWidth,
      height: Z.offsetHeight
    };
  }
  constructor(Z) {
    this.ref = Z;
  }
}
class t4 {
  isDisabled(Z) {
    var u;
    return this.disabledBehavior === "all" && (((u = Z.props) === null || u === void 0 ? void 0 : u.isDisabled) || this.disabledKeys.has(Z.key));
  }
  findNextNonDisabled(Z, u) {
    for (; Z != null; ) {
      let s = this.collection.getItem(Z);
      if ((s == null ? void 0 : s.type) === "item" && !this.isDisabled(s)) return Z;
      Z = u(Z);
    }
    return null;
  }
  getNextKey(Z) {
    return Z = this.collection.getKeyAfter(Z), this.findNextNonDisabled(Z, (u) => this.collection.getKeyAfter(u));
  }
  getPreviousKey(Z) {
    return Z = this.collection.getKeyBefore(Z), this.findNextNonDisabled(Z, (u) => this.collection.getKeyBefore(u));
  }
  findKey(Z, u, s) {
    let G = this.layoutDelegate.getItemRect(Z);
    if (!G) return null;
    let i = G;
    do
      Z = u(Z), G = this.layoutDelegate.getItemRect(Z);
    while (G && s(i, G));
    return Z;
  }
  isSameRow(Z, u) {
    return Z.y === u.y || Z.x !== u.x;
  }
  isSameColumn(Z, u) {
    return Z.x === u.x || Z.y !== u.y;
  }
  getKeyBelow(Z) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(Z, (u) => this.getNextKey(u), this.isSameRow) : this.getNextKey(Z);
  }
  getKeyAbove(Z) {
    return this.layout === "grid" && this.orientation === "vertical" ? this.findKey(Z, (u) => this.getPreviousKey(u), this.isSameRow) : this.getPreviousKey(Z);
  }
  getNextColumn(Z, u) {
    return u ? this.getPreviousKey(Z) : this.getNextKey(Z);
  }
  getKeyRightOf(Z) {
    let u = this.direction === "ltr" ? "getKeyRightOf" : "getKeyLeftOf";
    return this.layoutDelegate[u] ? (Z = this.layoutDelegate[u](Z), this.findNextNonDisabled(Z, (s) => this.layoutDelegate[u](s))) : this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(Z, this.direction === "rtl") : this.findKey(Z, (s) => this.getNextColumn(s, this.direction === "rtl"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(Z, this.direction === "rtl") : null;
  }
  getKeyLeftOf(Z) {
    let u = this.direction === "ltr" ? "getKeyLeftOf" : "getKeyRightOf";
    return this.layoutDelegate[u] ? (Z = this.layoutDelegate[u](Z), this.findNextNonDisabled(Z, (s) => this.layoutDelegate[u](s))) : this.layout === "grid" ? this.orientation === "vertical" ? this.getNextColumn(Z, this.direction === "ltr") : this.findKey(Z, (s) => this.getNextColumn(s, this.direction === "ltr"), this.isSameColumn) : this.orientation === "horizontal" ? this.getNextColumn(Z, this.direction === "ltr") : null;
  }
  getFirstKey() {
    let Z = this.collection.getFirstKey();
    return this.findNextNonDisabled(Z, (u) => this.collection.getKeyAfter(u));
  }
  getLastKey() {
    let Z = this.collection.getLastKey();
    return this.findNextNonDisabled(Z, (u) => this.collection.getKeyBefore(u));
  }
  getKeyPageAbove(Z) {
    let u = this.ref.current, s = this.layoutDelegate.getItemRect(Z);
    if (!s) return null;
    if (!ga(u)) return this.getFirstKey();
    if (this.orientation === "horizontal") {
      let G = Math.max(0, s.x + s.width - this.layoutDelegate.getVisibleRect().width);
      for (; s && s.x > G; )
        Z = this.getKeyAbove(Z), s = Z == null ? null : this.layoutDelegate.getItemRect(Z);
    } else {
      let G = Math.max(0, s.y + s.height - this.layoutDelegate.getVisibleRect().height);
      for (; s && s.y > G; )
        Z = this.getKeyAbove(Z), s = Z == null ? null : this.layoutDelegate.getItemRect(Z);
    }
    return Z ?? this.getFirstKey();
  }
  getKeyPageBelow(Z) {
    let u = this.ref.current, s = this.layoutDelegate.getItemRect(Z);
    if (!s) return null;
    if (!ga(u)) return this.getLastKey();
    if (this.orientation === "horizontal") {
      let G = Math.min(this.layoutDelegate.getContentSize().width, s.y - s.width + this.layoutDelegate.getVisibleRect().width);
      for (; s && s.x < G; )
        Z = this.getKeyBelow(Z), s = Z == null ? null : this.layoutDelegate.getItemRect(Z);
    } else {
      let G = Math.min(this.layoutDelegate.getContentSize().height, s.y - s.height + this.layoutDelegate.getVisibleRect().height);
      for (; s && s.y < G; )
        Z = this.getKeyBelow(Z), s = Z == null ? null : this.layoutDelegate.getItemRect(Z);
    }
    return Z ?? this.getLastKey();
  }
  getKeyForSearch(Z, u) {
    if (!this.collator) return null;
    let s = this.collection, G = u || this.getFirstKey();
    for (; G != null; ) {
      let i = s.getItem(G), m = i.textValue.slice(0, Z.length);
      if (i.textValue && this.collator.compare(m, Z) === 0) return G;
      G = this.getNextKey(G);
    }
    return null;
  }
  constructor(...Z) {
    if (Z.length === 1) {
      let u = Z[0];
      this.collection = u.collection, this.ref = u.ref, this.collator = u.collator, this.disabledKeys = u.disabledKeys || /* @__PURE__ */ new Set(), this.disabledBehavior = u.disabledBehavior || "all", this.orientation = u.orientation || "vertical", this.direction = u.direction, this.layout = u.layout || "stack", this.layoutDelegate = u.layoutDelegate || new r2(u.ref);
    } else
      this.collection = Z[0], this.disabledKeys = Z[1], this.ref = Z[2], this.collator = Z[3], this.layout = "stack", this.orientation = "vertical", this.disabledBehavior = "all", this.layoutDelegate = new r2(this.ref);
    this.layout === "stack" && this.orientation === "vertical" && (this.getKeyLeftOf = void 0, this.getKeyRightOf = void 0);
  }
}
function X4(l) {
  let { selectionManager: Z, collection: u, disabledKeys: s, ref: G, keyboardDelegate: i, layoutDelegate: m } = l, a = NE({
    usage: "search",
    sensitivity: "base"
  }), n = Z.disabledBehavior, p = M.useMemo(() => i || new t4({
    collection: u,
    disabledKeys: s,
    disabledBehavior: n,
    ref: G,
    collator: a,
    layoutDelegate: m
  }), [
    i,
    m,
    u,
    s,
    G,
    a,
    n
  ]), { collectionProps: y } = y4({
    ...l,
    ref: G,
    selectionManager: Z,
    keyboardDelegate: p
  });
  return {
    listProps: y
  };
}
class K4 {
  build(Z, u) {
    return this.context = u, F2(() => this.iterateCollection(Z));
  }
  *iterateCollection(Z) {
    let { children: u, items: s } = Z;
    if (tl.isValidElement(u) && u.type === tl.Fragment) yield* this.iterateCollection({
      children: u.props.children,
      items: s
    });
    else if (typeof u == "function") {
      if (!s) throw new Error("props.children was a function but props.items is missing");
      for (let G of Z.items) yield* this.getFullNode({
        value: G
      }, {
        renderer: u
      });
    } else {
      let G = [];
      tl.Children.forEach(u, (m) => {
        G.push(m);
      });
      let i = 0;
      for (let m of G) {
        let a = this.getFullNode({
          element: m,
          index: i
        }, {});
        for (let n of a)
          i++, yield n;
      }
    }
  }
  getKey(Z, u, s, G) {
    if (Z.key != null) return Z.key;
    if (u.type === "cell" && u.key != null) return `${G}${u.key}`;
    let i = u.value;
    if (i != null) {
      var m;
      let a = (m = i.key) !== null && m !== void 0 ? m : i.id;
      if (a == null) throw new Error("No key found for item");
      return a;
    }
    return G ? `${G}.${u.index}` : `$.${u.index}`;
  }
  getChildState(Z, u) {
    return {
      renderer: u.renderer || Z.renderer
    };
  }
  *getFullNode(Z, u, s, G) {
    if (tl.isValidElement(Z.element) && Z.element.type === tl.Fragment) {
      let n = [];
      tl.Children.forEach(Z.element.props.children, (y) => {
        n.push(y);
      });
      let p = Z.index;
      for (const y of n) yield* this.getFullNode({
        element: y,
        index: p++
      }, u, s, G);
      return;
    }
    let i = Z.element;
    if (!i && Z.value && u && u.renderer) {
      let n = this.cache.get(Z.value);
      if (n && (!n.shouldInvalidate || !n.shouldInvalidate(this.context))) {
        n.index = Z.index, n.parentKey = G ? G.key : null, yield n;
        return;
      }
      i = u.renderer(Z.value);
    }
    if (tl.isValidElement(i)) {
      let n = i.type;
      if (typeof n != "function" && typeof n.getCollectionNode != "function") {
        let S = typeof i.type == "function" ? i.type.name : i.type;
        throw new Error(`Unknown element <${S}> in collection.`);
      }
      let p = n.getCollectionNode(i.props, this.context), y = Z.index, h = p.next();
      for (; !h.done && h.value; ) {
        let S = h.value;
        Z.index = y;
        let t = S.key;
        t || (t = S.element ? null : this.getKey(i, Z, u, s));
        let V = [
          ...this.getFullNode({
            ...S,
            key: t,
            index: y,
            wrapper: W4(Z.wrapper, S.wrapper)
          }, this.getChildState(u, S), s ? `${s}${i.key}` : i.key, G)
        ];
        for (let R of V) {
          if (R.value = S.value || Z.value, R.value && this.cache.set(R.value, R), Z.type && R.type !== Z.type) throw new Error(`Unsupported type <${zK(R.type)}> in <${zK(G.type)}>. Only <${zK(Z.type)}> is supported.`);
          y++, yield R;
        }
        h = p.next(V);
      }
      return;
    }
    if (Z.key == null) return;
    let m = this, a = {
      type: Z.type,
      props: Z.props,
      key: Z.key,
      parentKey: G ? G.key : null,
      value: Z.value,
      level: G ? G.level + 1 : 0,
      index: Z.index,
      rendered: Z.rendered,
      textValue: Z.textValue,
      "aria-label": Z["aria-label"],
      wrapper: Z.wrapper,
      shouldInvalidate: Z.shouldInvalidate,
      hasChildNodes: Z.hasChildNodes,
      childNodes: F2(function* () {
        if (!Z.hasChildNodes) return;
        let n = 0;
        for (let p of Z.childNodes()) {
          p.key != null && (p.key = `${a.key}${p.key}`), p.index = n;
          let y = m.getFullNode(p, m.getChildState(u, p), a.key, a);
          for (let h of y)
            n++, yield h;
        }
      })
    };
    yield a;
  }
  constructor() {
    this.cache = /* @__PURE__ */ new WeakMap();
  }
}
function F2(l) {
  let Z = [], u = null;
  return {
    *[Symbol.iterator]() {
      for (let s of Z) yield s;
      u || (u = l());
      for (let s of u)
        Z.push(s), yield s;
    }
  };
}
function W4(l, Z) {
  if (l && Z) return (u) => l(Z(u));
  if (l) return l;
  if (Z) return Z;
}
function zK(l) {
  return l[0].toUpperCase() + l.slice(1);
}
function V4(l, Z, u) {
  let s = M.useMemo(() => new K4(), []), { children: G, items: i, collection: m } = l;
  return M.useMemo(() => {
    if (m) return m;
    let n = s.build({
      children: G,
      items: i
    }, u);
    return Z(n);
  }, [
    s,
    G,
    i,
    m,
    u,
    Z
  ]);
}
function p9(l, Z) {
  return typeof Z.getChildren == "function" ? Z.getChildren(l.key) : l.childNodes;
}
function x4(l) {
  return R4(l);
}
function R4(l, Z) {
  for (let u of l)
    return u;
}
function JK(l, Z, u) {
  if (Z.parentKey === u.parentKey) return Z.index - u.index;
  let s = [
    ...N2(l, Z),
    Z
  ], G = [
    ...N2(l, u),
    u
  ], i = s.slice(0, G.length).findIndex((m, a) => m !== G[a]);
  return i !== -1 ? (Z = s[i], u = G[i], Z.index - u.index) : s.findIndex((m) => m === u) >= 0 ? 1 : (G.findIndex((m) => m === Z) >= 0, -1);
}
function N2(l, Z) {
  let u = [];
  for (; (Z == null ? void 0 : Z.parentKey) != null; )
    Z = l.getItem(Z.parentKey), u.unshift(Z);
  return u;
}
const w2 = /* @__PURE__ */ new WeakMap();
function Y4(l) {
  let Z = w2.get(l);
  if (Z != null) return Z;
  Z = 0;
  let u = (s) => {
    for (let G of s) G.type === "section" ? u(p9(G, l)) : Z++;
  };
  return u(l), w2.set(l, Z), Z;
}
var L9 = {};
L9 = {
  longPressMessage: "اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة"
};
var h9 = {};
h9 = {
  longPressMessage: "Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто"
};
var y9 = {};
y9 = {
  longPressMessage: "Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku"
};
var S9 = {};
S9 = {
  longPressMessage: "Langt tryk eller tryk på Alt + pil ned for at åbne menuen"
};
var t9 = {};
t9 = {
  longPressMessage: "Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen"
};
var X9 = {};
X9 = {
  longPressMessage: "Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού"
};
var K9 = {};
K9 = {
  longPressMessage: "Long press or press Alt + ArrowDown to open menu"
};
var W9 = {};
W9 = {
  longPressMessage: "Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú"
};
var V9 = {};
V9 = {
  longPressMessage: "Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool"
};
var x9 = {};
x9 = {
  longPressMessage: "Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli"
};
var R9 = {};
R9 = {
  longPressMessage: "Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu."
};
var Y9 = {};
Y9 = {
  longPressMessage: "לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט"
};
var k9 = {};
k9 = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika"
};
var M9 = {};
M9 = {
  longPressMessage: "Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához"
};
var I9 = {};
I9 = {
  longPressMessage: "Premere a lungo o premere Alt + Freccia giù per aprire il menu"
};
var U9 = {};
U9 = {
  longPressMessage: "長押しまたは Alt+下矢印キーでメニューを開く"
};
var C9 = {};
C9 = {
  longPressMessage: "길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기"
};
var r9 = {};
r9 = {
  longPressMessage: "Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“."
};
var F9 = {};
F9 = {
  longPressMessage: "Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa"
};
var N9 = {};
N9 = {
  longPressMessage: "Langt trykk eller trykk Alt + PilNed for å åpne menyen"
};
var w9 = {};
w9 = {
  longPressMessage: "Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen"
};
var z9 = {};
z9 = {
  longPressMessage: "Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu"
};
var J9 = {};
J9 = {
  longPressMessage: "Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu"
};
var H9 = {};
H9 = {
  longPressMessage: "Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu"
};
var g9 = {};
g9 = {
  longPressMessage: "Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul"
};
var v9 = {};
v9 = {
  longPressMessage: "Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню"
};
var T9 = {};
T9 = {
  longPressMessage: "Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol"
};
var f9 = {};
f9 = {
  longPressMessage: "Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol"
};
var E9 = {};
E9 = {
  longPressMessage: "Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni"
};
var B9 = {};
B9 = {
  longPressMessage: "Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn"
};
var D9 = {};
D9 = {
  longPressMessage: "Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın"
};
var j9 = {};
j9 = {
  longPressMessage: "Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню"
};
var Q9 = {};
Q9 = {
  longPressMessage: "长按或按 Alt + 向下方向键以打开菜单"
};
var P9 = {};
P9 = {
  longPressMessage: "長按或按 Alt+向下鍵以開啟功能表"
};
var O9 = {};
O9 = {
  "ar-AE": L9,
  "bg-BG": h9,
  "cs-CZ": y9,
  "da-DK": S9,
  "de-DE": t9,
  "el-GR": X9,
  "en-US": K9,
  "es-ES": W9,
  "et-EE": V9,
  "fi-FI": x9,
  "fr-FR": R9,
  "he-IL": Y9,
  "hr-HR": k9,
  "hu-HU": M9,
  "it-IT": I9,
  "ja-JP": U9,
  "ko-KR": C9,
  "lt-LT": r9,
  "lv-LV": F9,
  "nb-NO": N9,
  "nl-NL": w9,
  "pl-PL": z9,
  "pt-BR": J9,
  "pt-PT": H9,
  "ro-RO": g9,
  "ru-RU": v9,
  "sk-SK": T9,
  "sl-SI": f9,
  "sr-SP": E9,
  "sv-SE": B9,
  "tr-TR": D9,
  "uk-UA": j9,
  "zh-CN": Q9,
  "zh-TW": P9
};
function k4(l) {
  return l && l.__esModule ? l.default : l;
}
function M4(l, Z, u) {
  let { type: s = "menu", isDisabled: G, trigger: i = "press" } = l, m = ad(), { triggerProps: a, overlayProps: n } = c4({
    type: s
  }, Z, u), p = (t) => {
    if (!G && !(i === "longPress" && !t.altKey) && u && u.current)
      switch (t.key) {
        case "Enter":
        case " ":
          if (i === "longPress") return;
        case "ArrowDown":
          "continuePropagation" in t || t.stopPropagation(), t.preventDefault(), Z.toggle("first");
          break;
        case "ArrowUp":
          "continuePropagation" in t || t.stopPropagation(), t.preventDefault(), Z.toggle("last");
          break;
        default:
          "continuePropagation" in t && t.continuePropagation();
      }
  }, y = Y1(k4(O9), "@react-aria/menu"), { longPressProps: h } = X1({
    isDisabled: G || i !== "longPress",
    accessibilityDescription: y.format("longPressMessage"),
    onLongPressStart() {
      Z.close();
    },
    onLongPress() {
      Z.open("first");
    }
  }), S = {
    onPressStart(t) {
      t.pointerType !== "touch" && t.pointerType !== "keyboard" && !G && Z.open(t.pointerType === "virtual" ? "first" : null);
    },
    onPress(t) {
      t.pointerType === "touch" && !G && Z.toggle();
    }
  };
  return delete a.onPress, {
    menuTriggerProps: {
      ...a,
      ...i === "press" ? S : h,
      id: m,
      onKeyDown: p
    },
    menuProps: {
      ...n,
      "aria-labelledby": m,
      autoFocus: Z.focusStrategy || !0,
      onClose: Z.close
    }
  };
}
const A9 = /* @__PURE__ */ new WeakMap();
function I4(l, Z, u) {
  let { shouldFocusWrap: s = !0, onKeyDown: G, onKeyUp: i, ...m } = l;
  !l["aria-label"] && !l["aria-labelledby"] && console.warn("An aria-label or aria-labelledby prop is required for accessibility.");
  let a = Su(l, {
    labelable: !0
  }), { listProps: n } = X4({
    ...m,
    ref: u,
    selectionManager: Z.selectionManager,
    collection: Z.collection,
    disabledKeys: Z.disabledKeys,
    shouldFocusWrap: s,
    linkBehavior: "override"
  });
  return A9.set(Z, {
    onClose: l.onClose,
    onAction: l.onAction
  }), {
    menuProps: HZ(a, {
      onKeyDown: G,
      onKeyUp: i
    }, {
      role: "menu",
      ...n,
      onKeyDown: (p) => {
        p.key !== "Escape" && n.onKeyDown(p);
      }
    })
  };
}
function U4(l, Z, u) {
  let { id: s, key: G, closeOnSelect: i, isVirtualized: m, "aria-haspopup": a, onPressStart: n, onPressUp: p, onPress: y, onPressChange: h, onPressEnd: S, onHoverStart: t, onHoverChange: W, onHoverEnd: V, onKeyDown: R, onKeyUp: x, onFocus: r, onFocusChange: k, onBlur: U } = l, w = !!a;
  var z;
  let D = (z = l.isDisabled) !== null && z !== void 0 ? z : Z.selectionManager.isDisabled(G);
  var C;
  let j = (C = l.isSelected) !== null && C !== void 0 ? C : Z.selectionManager.isSelected(G), E = A9.get(Z), g = Z.collection.getItem(G), A = l.onClose || E.onClose, J = nn(), F = (hl) => {
    var cl;
    if (!w) {
      if (!(g == null || (cl = g.props) === null || cl === void 0) && cl.onAction ? g.props.onAction() : l.onAction && l.onAction(G), E.onAction) {
        let wl = E.onAction;
        wl(G);
      }
      hl.target instanceof HTMLAnchorElement && J.open(hl.target, hl, g.props.href, g.props.routerOptions);
    }
  }, v = "menuitem";
  w || (Z.selectionManager.selectionMode === "single" ? v = "menuitemradio" : Z.selectionManager.selectionMode === "multiple" && (v = "menuitemcheckbox"));
  let T = xK(), f = xK(), O = xK(), _ = {
    id: s,
    "aria-disabled": D || void 0,
    role: v,
    "aria-label": l["aria-label"],
    "aria-labelledby": T,
    "aria-describedby": [
      f,
      O
    ].filter(Boolean).join(" ") || void 0,
    "aria-controls": l["aria-controls"],
    "aria-haspopup": a,
    "aria-expanded": l["aria-expanded"]
  };
  Z.selectionManager.selectionMode !== "none" && !w && (_["aria-checked"] = j), m && (_["aria-posinset"] = g == null ? void 0 : g.index, _["aria-setsize"] = Y4(Z.collection));
  let il = (hl) => {
    hl.pointerType === "keyboard" && F(hl), n == null || n(hl);
  }, Zl = (hl) => {
    hl.pointerType !== "keyboard" && (F(hl), !w && A && (i ?? (Z.selectionManager.selectionMode !== "multiple" || Z.selectionManager.isLink(G))) && A()), p == null || p(hl);
  }, { itemProps: ol, isFocused: Wl } = S4({
    selectionManager: Z.selectionManager,
    key: G,
    ref: u,
    shouldSelectOnPressUp: !0,
    allowsDifferentPressOrigin: !0,
    // Disable all handling of links in useSelectable item
    // because we handle it ourselves. The behavior of menus
    // is slightly different from other collections because
    // actions are performed on key down rather than key up.
    linkBehavior: "none"
  }), { pressProps: ml, isPressed: Rl } = hn({
    onPressStart: il,
    onPress: y,
    onPressUp: Zl,
    onPressChange: h,
    onPressEnd: S,
    isDisabled: D
  }), { hoverProps: kl } = Ro({
    isDisabled: D,
    onHoverStart(hl) {
      xV() || (Z.selectionManager.setFocused(!0), Z.selectionManager.setFocusedKey(G)), t == null || t(hl);
    },
    onHoverChange: W,
    onHoverEnd: V
  }), { keyboardProps: zl } = YV({
    onKeyDown: (hl) => {
      if (hl.repeat) {
        hl.continuePropagation();
        return;
      }
      switch (hl.key) {
        case " ":
          !D && Z.selectionManager.selectionMode === "none" && !w && i !== !1 && A && A();
          break;
        case "Enter":
          !D && i !== !1 && !w && A && A();
          break;
        default:
          w || hl.continuePropagation(), R == null || R(hl);
          break;
      }
    },
    onKeyUp: x
  }), { focusProps: Vl } = VV({
    onBlur: U,
    onFocus: r,
    onFocusChange: k
  }), el = Su(g.props);
  delete el.id;
  let xl = l1(g.props);
  return {
    menuItemProps: {
      ..._,
      ...HZ(el, xl, w ? {
        onFocus: ol.onFocus,
        "data-key": ol["data-key"]
      } : ol, ml, kl, zl, Vl),
      tabIndex: ol.tabIndex != null ? -1 : void 0
    },
    labelProps: {
      id: T
    },
    descriptionProps: {
      id: f
    },
    keyboardShortcutProps: {
      id: O
    },
    isFocused: Wl,
    isSelected: j,
    isPressed: Rl,
    isDisabled: D
  };
}
function C4(l) {
  let { heading: Z, "aria-label": u } = l, s = ad();
  return {
    itemProps: {
      role: "presentation"
    },
    headingProps: Z ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, using role="presentation",
      // and only use it as a label for the nested group.
      id: s,
      role: "presentation"
    } : {},
    groupProps: {
      role: "group",
      "aria-label": u,
      "aria-labelledby": Z ? s : void 0
    }
  };
}
function r4(l) {
  let Z = Su(l, {
    labelable: !0
  }), u;
  return l.orientation === "vertical" && (u = "vertical"), l.elementType !== "hr" ? {
    separatorProps: {
      ...Z,
      role: "separator",
      "aria-orientation": u
    }
  } : {
    separatorProps: Z
  };
}
const F4 = /* @__PURE__ */ M.createContext(null);
function N4(l, Z) {
  [l, Z] = yd(l, Z, F4);
  let u = l.href && !l.isDisabled ? "a" : "span", { linkProps: s, isPressed: G } = hE({
    ...l,
    elementType: u
  }, Z), { hoverProps: i, isHovered: m } = Ro(l), { focusProps: a, isFocused: n, isFocusVisible: p } = Th(), y = Ks({
    ...l,
    defaultClassName: "react-aria-Link",
    values: {
      isCurrent: !!l["aria-current"],
      isDisabled: l.isDisabled || !1,
      isPressed: G,
      isHovered: m,
      isFocused: n,
      isFocusVisible: p
    }
  });
  return /* @__PURE__ */ tl.createElement(u, {
    ref: Z,
    slot: l.slot || void 0,
    ...HZ(y, s, i, a),
    "data-focused": n || void 0,
    "data-hovered": m || void 0,
    "data-pressed": G || void 0,
    "data-focus-visible": p || void 0,
    "data-current": !!l["aria-current"] || void 0,
    "data-disabled": l.isDisabled || void 0
  }, y.children);
}
const w4 = /* @__PURE__ */ M.forwardRef(N4), $9 = /* @__PURE__ */ M.createContext({}), z4 = /* @__PURE__ */ M.createContext(null), J4 = /* @__PURE__ */ new Set([
  "form",
  "formAction",
  "formEncType",
  "formMethod",
  "formNoValidate",
  "formTarget",
  "name",
  "value"
]), H4 = /* @__PURE__ */ M.createContext({});
function g4(l, Z) {
  [l, Z] = yd(l, Z, H4), l = v4(l);
  let u = l, { isPending: s } = u, { buttonProps: G, isPressed: i } = wE(l, Z), { focusProps: m, isFocused: a, isFocusVisible: n } = Th(l), { hoverProps: p, isHovered: y } = Ro({
    ...l,
    isDisabled: l.isDisabled || s
  }), h = {
    isHovered: y,
    isPressed: (u.isPressed || i) && !s,
    isFocused: a,
    isFocusVisible: n,
    isDisabled: l.isDisabled || !1,
    isPending: s ?? !1
  }, S = Ks({
    ...l,
    values: h,
    defaultClassName: "react-aria-Button"
  }), t = ad(G.id), W = ad(), V = G["aria-labelledby"];
  s && (V ? V = `${V} ${W}` : G["aria-label"] && (V = `${t} ${W}`));
  let R = M.useRef(s);
  return M.useEffect(() => {
    let x = {
      "aria-labelledby": V || t
    };
    (!R.current && a && s || R.current && a && !s) && h2(x, "assertive"), R.current = s;
  }, [
    s,
    a,
    V,
    t
  ]), /* @__PURE__ */ tl.createElement("button", {
    ...Su(l, {
      propNames: J4
    }),
    ...HZ(G, m, p),
    ...S,
    id: t,
    ref: Z,
    "aria-labelledby": V,
    slot: l.slot || void 0,
    "aria-disabled": s ? "true" : G["aria-disabled"],
    "data-disabled": l.isDisabled || void 0,
    "data-pressed": h.isPressed || void 0,
    "data-hovered": y || void 0,
    "data-focused": a || void 0,
    "data-pending": s || void 0,
    "data-focus-visible": n || void 0
  }, /* @__PURE__ */ tl.createElement(z4.Provider, {
    value: {
      id: W
    }
  }, S.children));
}
function v4(l) {
  return l.isPending && (l.onPress = void 0, l.onPressStart = void 0, l.onPressEnd = void 0, l.onPressChange = void 0, l.onPressUp = void 0, l.onKeyDown = void 0, l.onKeyUp = void 0, l.onClick = void 0, l.href = void 0), l;
}
const T4 = /* @__PURE__ */ BT(g4), f4 = /* @__PURE__ */ M.createContext({});
class gu extends Set {
  constructor(Z, u, s) {
    super(Z), Z instanceof gu ? (this.anchorKey = u ?? Z.anchorKey, this.currentKey = s ?? Z.currentKey) : (this.anchorKey = u, this.currentKey = s);
  }
}
function E4(l, Z) {
  if (l.size !== Z.size) return !1;
  for (let u of l)
    if (!Z.has(u)) return !1;
  return !0;
}
function B4(l) {
  let { selectionMode: Z = "none", disallowEmptySelection: u, allowDuplicateSelectionEvents: s, selectionBehavior: G = "toggle", disabledBehavior: i = "all" } = l, m = M.useRef(!1), [, a] = M.useState(!1), n = M.useRef(null), p = M.useRef(null), [, y] = M.useState(null), h = M.useMemo(() => z2(l.selectedKeys), [
    l.selectedKeys
  ]), S = M.useMemo(() => z2(l.defaultSelectedKeys, new gu()), [
    l.defaultSelectedKeys
  ]), [t, W] = Hh(h, S, l.onSelectionChange), V = M.useMemo(() => l.disabledKeys ? new Set(l.disabledKeys) : /* @__PURE__ */ new Set(), [
    l.disabledKeys
  ]), [R, x] = M.useState(G);
  G === "replace" && R === "toggle" && typeof t == "object" && t.size === 0 && x("replace");
  let r = M.useRef(G);
  return M.useEffect(() => {
    G !== r.current && (x(G), r.current = G);
  }, [
    G
  ]), {
    selectionMode: Z,
    disallowEmptySelection: u,
    selectionBehavior: R,
    setSelectionBehavior: x,
    get isFocused() {
      return m.current;
    },
    setFocused(k) {
      m.current = k, a(k);
    },
    get focusedKey() {
      return n.current;
    },
    get childFocusStrategy() {
      return p.current;
    },
    setFocusedKey(k, U = "first") {
      n.current = k, p.current = U, y(k);
    },
    selectedKeys: t,
    setSelectedKeys(k) {
      (s || !E4(k, t)) && W(k);
    },
    disabledKeys: V,
    disabledBehavior: i
  };
}
function z2(l, Z) {
  return l ? l === "all" ? "all" : new gu(l) : Z;
}
class D4 {
  /**
  * The type of selection that is allowed in the collection.
  */
  get selectionMode() {
    return this.state.selectionMode;
  }
  /**
  * Whether the collection allows empty selection.
  */
  get disallowEmptySelection() {
    return this.state.disallowEmptySelection;
  }
  /**
  * The selection behavior for the collection.
  */
  get selectionBehavior() {
    return this.state.selectionBehavior;
  }
  /**
  * Sets the selection behavior for the collection.
  */
  setSelectionBehavior(Z) {
    this.state.setSelectionBehavior(Z);
  }
  /**
  * Whether the collection is currently focused.
  */
  get isFocused() {
    return this.state.isFocused;
  }
  /**
  * Sets whether the collection is focused.
  */
  setFocused(Z) {
    this.state.setFocused(Z);
  }
  /**
  * The current focused key in the collection.
  */
  get focusedKey() {
    return this.state.focusedKey;
  }
  /** Whether the first or last child of the focused key should receive focus. */
  get childFocusStrategy() {
    return this.state.childFocusStrategy;
  }
  /**
  * Sets the focused key.
  */
  setFocusedKey(Z, u) {
    (Z == null || this.collection.getItem(Z)) && this.state.setFocusedKey(Z, u);
  }
  /**
  * The currently selected keys in the collection.
  */
  get selectedKeys() {
    return this.state.selectedKeys === "all" ? new Set(this.getSelectAllKeys()) : this.state.selectedKeys;
  }
  /**
  * The raw selection value for the collection.
  * Either 'all' for select all, or a set of keys.
  */
  get rawSelection() {
    return this.state.selectedKeys;
  }
  /**
  * Returns whether a key is selected.
  */
  isSelected(Z) {
    return this.state.selectionMode === "none" ? !1 : (Z = this.getKey(Z), this.state.selectedKeys === "all" ? this.canSelectItem(Z) : this.state.selectedKeys.has(Z));
  }
  /**
  * Whether the selection is empty.
  */
  get isEmpty() {
    return this.state.selectedKeys !== "all" && this.state.selectedKeys.size === 0;
  }
  /**
  * Whether all items in the collection are selected.
  */
  get isSelectAll() {
    if (this.isEmpty) return !1;
    if (this.state.selectedKeys === "all") return !0;
    if (this._isSelectAll != null) return this._isSelectAll;
    let Z = this.getSelectAllKeys(), u = this.state.selectedKeys;
    return this._isSelectAll = Z.every((s) => u.has(s)), this._isSelectAll;
  }
  get firstSelectedKey() {
    let Z = null;
    for (let u of this.state.selectedKeys) {
      let s = this.collection.getItem(u);
      (!Z || s && JK(this.collection, s, Z) < 0) && (Z = s);
    }
    return Z == null ? void 0 : Z.key;
  }
  get lastSelectedKey() {
    let Z = null;
    for (let u of this.state.selectedKeys) {
      let s = this.collection.getItem(u);
      (!Z || s && JK(this.collection, s, Z) > 0) && (Z = s);
    }
    return Z == null ? void 0 : Z.key;
  }
  get disabledKeys() {
    return this.state.disabledKeys;
  }
  get disabledBehavior() {
    return this.state.disabledBehavior;
  }
  /**
  * Extends the selection to the given key.
  */
  extendSelection(Z) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single") {
      this.replaceSelection(Z);
      return;
    }
    Z = this.getKey(Z);
    let u;
    if (this.state.selectedKeys === "all") u = new gu([
      Z
    ], Z, Z);
    else {
      let i = this.state.selectedKeys;
      var s;
      let m = (s = i.anchorKey) !== null && s !== void 0 ? s : Z;
      u = new gu(i, m, Z);
      var G;
      for (let a of this.getKeyRange(m, (G = i.currentKey) !== null && G !== void 0 ? G : Z)) u.delete(a);
      for (let a of this.getKeyRange(Z, m)) this.canSelectItem(a) && u.add(a);
    }
    this.state.setSelectedKeys(u);
  }
  getKeyRange(Z, u) {
    let s = this.collection.getItem(Z), G = this.collection.getItem(u);
    return s && G ? JK(this.collection, s, G) <= 0 ? this.getKeyRangeInternal(Z, u) : this.getKeyRangeInternal(u, Z) : [];
  }
  getKeyRangeInternal(Z, u) {
    var s;
    if (!((s = this.layoutDelegate) === null || s === void 0) && s.getKeyRange) return this.layoutDelegate.getKeyRange(Z, u);
    let G = [], i = Z;
    for (; i != null; ) {
      let m = this.collection.getItem(i);
      if ((m && m.type === "item" || m.type === "cell" && this.allowsCellSelection) && G.push(i), i === u) return G;
      i = this.collection.getKeyAfter(i);
    }
    return [];
  }
  getKey(Z) {
    let u = this.collection.getItem(Z);
    if (!u || u.type === "cell" && this.allowsCellSelection) return Z;
    for (; u.type !== "item" && u.parentKey != null; ) u = this.collection.getItem(u.parentKey);
    return !u || u.type !== "item" ? null : u.key;
  }
  /**
  * Toggles whether the given key is selected.
  */
  toggleSelection(Z) {
    if (this.selectionMode === "none") return;
    if (this.selectionMode === "single" && !this.isSelected(Z)) {
      this.replaceSelection(Z);
      return;
    }
    if (Z = this.getKey(Z), Z == null) return;
    let u = new gu(this.state.selectedKeys === "all" ? this.getSelectAllKeys() : this.state.selectedKeys);
    u.has(Z) ? u.delete(Z) : this.canSelectItem(Z) && (u.add(Z), u.anchorKey = Z, u.currentKey = Z), !(this.disallowEmptySelection && u.size === 0) && this.state.setSelectedKeys(u);
  }
  /**
  * Replaces the selection with only the given key.
  */
  replaceSelection(Z) {
    if (this.selectionMode === "none" || (Z = this.getKey(Z), Z == null)) return;
    let u = this.canSelectItem(Z) ? new gu([
      Z
    ], Z, Z) : new gu();
    this.state.setSelectedKeys(u);
  }
  /**
  * Replaces the selection with the given keys.
  */
  setSelectedKeys(Z) {
    if (this.selectionMode === "none") return;
    let u = new gu();
    for (let s of Z)
      if (s = this.getKey(s), s != null && (u.add(s), this.selectionMode === "single"))
        break;
    this.state.setSelectedKeys(u);
  }
  getSelectAllKeys() {
    let Z = [], u = (s) => {
      for (; s != null; ) {
        if (this.canSelectItem(s)) {
          let G = this.collection.getItem(s);
          G.type === "item" && Z.push(s), G.hasChildNodes && (this.allowsCellSelection || G.type !== "item") && u(x4(p9(G, this.collection)).key);
        }
        s = this.collection.getKeyAfter(s);
      }
    };
    return u(this.collection.getFirstKey()), Z;
  }
  /**
  * Selects all items in the collection.
  */
  selectAll() {
    !this.isSelectAll && this.selectionMode === "multiple" && this.state.setSelectedKeys("all");
  }
  /**
  * Removes all keys from the selection.
  */
  clearSelection() {
    !this.disallowEmptySelection && (this.state.selectedKeys === "all" || this.state.selectedKeys.size > 0) && this.state.setSelectedKeys(new gu());
  }
  /**
  * Toggles between select all and an empty selection.
  */
  toggleSelectAll() {
    this.isSelectAll ? this.clearSelection() : this.selectAll();
  }
  select(Z, u) {
    this.selectionMode !== "none" && (this.selectionMode === "single" ? this.isSelected(Z) && !this.disallowEmptySelection ? this.toggleSelection(Z) : this.replaceSelection(Z) : this.selectionBehavior === "toggle" || u && (u.pointerType === "touch" || u.pointerType === "virtual") ? this.toggleSelection(Z) : this.replaceSelection(Z));
  }
  /**
  * Returns whether the current selection is equal to the given selection.
  */
  isSelectionEqual(Z) {
    if (Z === this.state.selectedKeys) return !0;
    let u = this.selectedKeys;
    if (Z.size !== u.size) return !1;
    for (let s of Z)
      if (!u.has(s)) return !1;
    for (let s of u)
      if (!Z.has(s)) return !1;
    return !0;
  }
  canSelectItem(Z) {
    var u;
    if (this.state.selectionMode === "none" || this.state.disabledKeys.has(Z)) return !1;
    let s = this.collection.getItem(Z);
    return !(!s || !(s == null || (u = s.props) === null || u === void 0) && u.isDisabled || s.type === "cell" && !this.allowsCellSelection);
  }
  isDisabled(Z) {
    var u, s;
    return this.state.disabledBehavior === "all" && (this.state.disabledKeys.has(Z) || !!(!((s = this.collection.getItem(Z)) === null || s === void 0 || (u = s.props) === null || u === void 0) && u.isDisabled));
  }
  isLink(Z) {
    var u, s;
    return !!(!((s = this.collection.getItem(Z)) === null || s === void 0 || (u = s.props) === null || u === void 0) && u.href);
  }
  getItemProps(Z) {
    var u;
    return (u = this.collection.getItem(Z)) === null || u === void 0 ? void 0 : u.props;
  }
  constructor(Z, u, s) {
    this.collection = Z, this.state = u;
    var G;
    this.allowsCellSelection = (G = s == null ? void 0 : s.allowsCellSelection) !== null && G !== void 0 ? G : !1, this._isSelectAll = null, this.layoutDelegate = (s == null ? void 0 : s.layoutDelegate) || null;
  }
}
function q9(l) {
  let [Z, u] = Hh(l.isOpen, l.defaultOpen || !1, l.onOpenChange);
  const s = M.useCallback(() => {
    u(!0);
  }, [
    u
  ]), G = M.useCallback(() => {
    u(!1);
  }, [
    u
  ]), i = M.useCallback(() => {
    u(!Z);
  }, [
    u,
    Z
  ]);
  return {
    isOpen: Z,
    setOpen: u,
    open: s,
    close: G,
    toggle: i
  };
}
function j4(l) {
  let Z = q9(l), [u, s] = M.useState(null), [G, i] = M.useState([]), m = () => {
    i([]), Z.close();
  };
  return {
    focusStrategy: u,
    ...Z,
    open(p = null) {
      s(p), Z.open();
    },
    toggle(p = null) {
      s(p), Z.toggle();
    },
    close() {
      m();
    },
    expandedKeysStack: G,
    openSubmenu: (p, y) => {
      i((h) => y > h.length ? h : [
        ...h.slice(0, y),
        p
      ]);
    },
    closeSubmenu: (p, y) => {
      i((h) => h[y] === p ? h.slice(0, y) : h);
    }
  };
}
class Q4 {
  *[Symbol.iterator]() {
    yield* this.iterable;
  }
  get size() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(Z) {
    let u = this.keyMap.get(Z);
    return u ? u.prevKey : null;
  }
  getKeyAfter(Z) {
    let u = this.keyMap.get(Z);
    return u ? u.nextKey : null;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(Z) {
    return this.keyMap.get(Z);
  }
  at(Z) {
    const u = [
      ...this.getKeys()
    ];
    return this.getItem(u[Z]);
  }
  constructor(Z, { expandedKeys: u } = {}) {
    this.keyMap = /* @__PURE__ */ new Map(), this.iterable = Z, u = u || /* @__PURE__ */ new Set();
    let s = (m) => {
      if (this.keyMap.set(m.key, m), m.childNodes && (m.type === "section" || u.has(m.key))) for (let a of m.childNodes) s(a);
    };
    for (let m of Z) s(m);
    let G, i = 0;
    for (let [m, a] of this.keyMap)
      G ? (G.nextKey = m, a.prevKey = G.key) : (this.firstKey = m, a.prevKey = void 0), a.type === "item" && (a.index = i++), G = a, G.nextKey = void 0;
    this.lastKey = G == null ? void 0 : G.key;
  }
}
function P4(l) {
  let { onExpandedChange: Z } = l, [u, s] = Hh(l.expandedKeys ? new Set(l.expandedKeys) : void 0, l.defaultExpandedKeys ? new Set(l.defaultExpandedKeys) : /* @__PURE__ */ new Set(), Z), G = B4(l), i = M.useMemo(() => l.disabledKeys ? new Set(l.disabledKeys) : /* @__PURE__ */ new Set(), [
    l.disabledKeys
  ]), m = V4(l, M.useCallback((n) => new Q4(n, {
    expandedKeys: u
  }), [
    u
  ]), null);
  return M.useEffect(() => {
    G.focusedKey != null && !m.getItem(G.focusedKey) && G.setFocusedKey(null);
  }, [
    m,
    G.focusedKey
  ]), {
    collection: m,
    expandedKeys: u,
    disabledKeys: i,
    toggleKey: (n) => {
      s(O4(u, n));
    },
    setExpandedKeys: s,
    selectionManager: new D4(m, G)
  };
}
function O4(l, Z) {
  let u = new Set(l);
  return u.has(Z) ? u.delete(Z) : u.add(Z), u;
}
const A4 = /* @__PURE__ */ M.createContext({}), _9 = /* @__PURE__ */ M.createContext({}), $4 = /* @__PURE__ */ G1("separator", function(Z, u) {
  [Z, u] = yd(Z, u, _9);
  let { elementType: s, orientation: G, style: i, className: m } = Z, a = s || "hr";
  a === "hr" && G === "vertical" && (a = "div");
  let { separatorProps: n } = r4({
    elementType: s,
    orientation: G
  });
  return /* @__PURE__ */ tl.createElement(a, {
    ...Su(Z),
    ...n,
    style: i,
    className: m ?? "react-aria-Separator",
    ref: u,
    slot: Z.slot || void 0
  });
}), q4 = /* @__PURE__ */ M.createContext(null), Eh = /* @__PURE__ */ M.createContext(null), CV = /* @__PURE__ */ M.createContext(null), lU = /* @__PURE__ */ M.createContext(null);
function _4(l, Z) {
  [l, Z] = yd(l, Z, q4);
  let u = M.useRef(null), s = FE(l.formatOptions), G = vE({
    ...l,
    numberFormatter: s
  }), [i, m] = KV(), { groupProps: a, trackProps: n, labelProps: p, outputProps: y } = fE({
    ...l,
    label: m
  }, G, u), h = Ks({
    ...l,
    values: {
      orientation: G.orientation,
      isDisabled: G.isDisabled,
      state: G
    },
    defaultClassName: "react-aria-Slider"
  }), S = Su(l);
  return delete S.id, /* @__PURE__ */ tl.createElement(Ln, {
    values: [
      [
        Eh,
        G
      ],
      [
        CV,
        {
          ...n,
          ref: u
        }
      ],
      [
        lU,
        y
      ],
      [
        $9,
        {
          ...p,
          ref: i
        }
      ]
    ]
  }, /* @__PURE__ */ tl.createElement("div", {
    ...S,
    ...a,
    ...h,
    ref: Z,
    slot: l.slot || void 0,
    "data-orientation": G.orientation,
    "data-disabled": G.isDisabled || void 0
  }));
}
const lB = /* @__PURE__ */ M.forwardRef(_4);
function ZB(l, Z) {
  [l, Z] = yd(l, Z, lU);
  let { children: u, style: s, className: G, ...i } = l, m = M.useContext(Eh), a = Ks({
    className: G,
    style: s,
    children: u,
    defaultChildren: m.getThumbValueLabel(0),
    defaultClassName: "react-aria-SliderOutput",
    values: {
      orientation: m.orientation,
      isDisabled: m.isDisabled,
      state: m
    }
  });
  return /* @__PURE__ */ tl.createElement("output", {
    ...i,
    ...a,
    ref: Z,
    "data-orientation": m.orientation || void 0,
    "data-disabled": m.isDisabled || void 0
  });
}
const cB = /* @__PURE__ */ M.forwardRef(ZB);
function bB(l, Z) {
  [l, Z] = yd(l, Z, CV);
  let u = M.useContext(Eh), { onHoverStart: s, onHoverEnd: G, onHoverChange: i, ...m } = l, { hoverProps: a, isHovered: n } = Ro({
    onHoverStart: s,
    onHoverEnd: G,
    onHoverChange: i
  }), p = Ks({
    ...l,
    defaultClassName: "react-aria-SliderTrack",
    values: {
      orientation: u.orientation,
      isDisabled: u.isDisabled,
      isHovered: n,
      state: u
    }
  });
  return /* @__PURE__ */ tl.createElement("div", {
    ...HZ(m, a),
    ...p,
    ref: Z,
    "data-hovered": n || void 0,
    "data-orientation": u.orientation || void 0,
    "data-disabled": u.isDisabled || void 0
  });
}
const uB = /* @__PURE__ */ M.forwardRef(bB);
function sB(l, Z) {
  let { inputRef: u = null } = l, s = M.useContext(Eh), { ref: G } = gh(CV), { index: i = 0 } = l, m = M.useRef(null), a = u || m, [n, p] = KV(), { thumbProps: y, inputProps: h, labelProps: S, isDragging: t, isFocused: W, isDisabled: V } = EE({
    ...l,
    index: i,
    trackRef: G,
    inputRef: a,
    label: p
  }, s), { focusProps: R, isFocusVisible: x } = Th(), { hoverProps: r, isHovered: k } = Ro(l), U = Ks({
    ...l,
    defaultClassName: "react-aria-SliderThumb",
    values: {
      state: s,
      isHovered: k,
      isDragging: t,
      isFocused: W,
      isFocusVisible: x,
      isDisabled: V
    }
  }), w = Su(l);
  return delete w.id, /* @__PURE__ */ tl.createElement("div", {
    ...HZ(w, y, r),
    ...U,
    ref: Z,
    style: {
      ...y.style,
      ...U.style
    },
    "data-hovered": k || void 0,
    "data-dragging": t || void 0,
    "data-focused": W || void 0,
    "data-focus-visible": x || void 0,
    "data-disabled": V || void 0
  }, /* @__PURE__ */ tl.createElement(U1, null, /* @__PURE__ */ tl.createElement("input", {
    ref: a,
    ...HZ(h, R)
  })), /* @__PURE__ */ tl.createElement(Ln, {
    values: [
      [
        $9,
        {
          ...S,
          ref: n
        }
      ]
    ]
  }, U.children));
}
const dB = /* @__PURE__ */ M.forwardRef(sB), GB = /* @__PURE__ */ M.createContext({
  placement: "bottom"
}), Ba = /* @__PURE__ */ M.createContext(null);
function mB(l, Z) {
  [l, Z] = yd(l, Z, Ba);
  let u = M.useContext(ZU), s = q9(l), G = l.isOpen != null || l.defaultOpen != null || !u ? s : u, i = Nf(Z, G.isOpen) || l.isExiting || !1;
  if (DT()) {
    let a = l.children;
    return typeof a == "function" && (a = a({
      trigger: l.trigger || null,
      placement: "bottom",
      isEntering: !1,
      isExiting: !1,
      defaultChildren: null
    })), /* @__PURE__ */ tl.createElement(tl.Fragment, null, a);
  }
  return G && !G.isOpen && !i ? null : /* @__PURE__ */ tl.createElement(oB, {
    ...l,
    triggerRef: l.triggerRef,
    state: G,
    popoverRef: Z,
    isExiting: i
  });
}
const iB = /* @__PURE__ */ M.forwardRef(mB);
function oB({ state: l, isExiting: Z, UNSTABLE_portalContainer: u, ...s }) {
  let G = M.useRef(null), [i, m] = M.useState(0);
  PZ(() => {
    G.current && l.isOpen && m(G.current.getBoundingClientRect().width);
  }, [
    l.isOpen,
    G
  ]);
  var a;
  let { popoverProps: n, underlayProps: p, arrowProps: y, placement: h } = i4({
    ...s,
    offset: (a = s.offset) !== null && a !== void 0 ? a : 8,
    arrowSize: i
  }, l), S = s.popoverRef, t = Ff(S, !!h) || s.isEntering || !1, W = Ks({
    ...s,
    defaultClassName: "react-aria-Popover",
    values: {
      trigger: s.trigger || null,
      placement: h,
      isEntering: t,
      isExiting: Z
    }
  }), V = {
    ...n.style,
    ...W.style
  };
  return /* @__PURE__ */ tl.createElement(n4, {
    isExiting: Z,
    portalContainer: u
  }, !s.isNonModal && l.isOpen && /* @__PURE__ */ tl.createElement("div", {
    "data-testid": "underlay",
    ...p,
    style: {
      position: "fixed",
      inset: 0
    }
  }), /* @__PURE__ */ tl.createElement("div", {
    ...HZ(Su(s), n),
    ...W,
    ref: S,
    slot: s.slot || void 0,
    style: V,
    "data-trigger": s.trigger,
    "data-placement": h,
    "data-entering": t || void 0,
    "data-exiting": Z || void 0
  }, !s.isNonModal && /* @__PURE__ */ tl.createElement(I2, {
    onDismiss: l.close
  }), /* @__PURE__ */ tl.createElement(GB.Provider, {
    value: {
      ...y,
      placement: h,
      ref: G
    }
  }, W.children), /* @__PURE__ */ tl.createElement(I2, {
    onDismiss: l.close
  })));
}
const ZU = /* @__PURE__ */ M.createContext(null), eB = /* @__PURE__ */ M.createContext({}), cU = /* @__PURE__ */ M.createContext(null), rV = /* @__PURE__ */ M.createContext(null), bU = /* @__PURE__ */ M.createContext(null);
function aB(l) {
  let Z = j4(l), u = M.useRef(null), { menuTriggerProps: s, menuProps: G } = M4({
    ...l,
    type: "menu"
  }, Z, u), [i, m] = M.useState(null), a = M.useCallback(() => {
    u.current && m(u.current.offsetWidth + "px");
  }, [
    u
  ]);
  oW({
    ref: u,
    onResize: a
  });
  let n = M.useRef(null);
  return /* @__PURE__ */ tl.createElement(Ln, {
    values: [
      [
        cU,
        {
          ...G,
          ref: n
        }
      ],
      [
        ZU,
        Z
      ],
      [
        bU,
        Z
      ],
      [
        Ba,
        {
          trigger: "MenuTrigger",
          triggerRef: u,
          scrollRef: n,
          placement: "bottom start",
          style: {
            "--trigger-width": i
          }
        }
      ]
    ]
  }, /* @__PURE__ */ tl.createElement(Df, {
    ...s,
    ref: u,
    isPressed: Z.isOpen
  }, l.children));
}
const nB = /* @__PURE__ */ M.createContext(null);
function pB(l, Z) {
  return [l, Z] = yd(l, Z, cU), /* @__PURE__ */ tl.createElement(Kf, {
    content: /* @__PURE__ */ tl.createElement(Mf, l)
  }, (u) => u.size > 0 && /* @__PURE__ */ tl.createElement(LB, {
    props: l,
    collection: u,
    menuRef: Z
  }));
}
function LB({ props: l, collection: Z, menuRef: u }) {
  let s = P4({
    ...l,
    collection: Z,
    children: void 0
  }), [G, i] = M.useState(null), { isVirtualized: m, CollectionRoot: a } = M.useContext(m1), { menuProps: n } = I4({
    ...l,
    isVirtualized: m
  }, s, u), p = M.useContext(bU), y = M.useContext(Ba), h = (y == null ? void 0 : y.trigger) === "SubmenuTrigger";
  S1({
    ref: u,
    onInteractOutside: (R) => {
      p && !(G != null && G.contains(R.target)) && p.close();
    },
    isDisabled: h || (p == null ? void 0 : p.expandedKeysStack.length) === 0
  });
  let S = M.useRef(null), [t, W] = M.useState({
    left: 0
  });
  M.useEffect(() => {
    if (G && S.current !== G && t.left === 0) {
      S.current = G;
      let { left: R } = G.getBoundingClientRect();
      W({
        left: -1 * R
      });
    }
  }, [
    t,
    G
  ]);
  let V = Ks({
    defaultClassName: "react-aria-Menu",
    className: l.className,
    style: l.style,
    values: {}
  });
  return /* @__PURE__ */ tl.createElement(W1, null, /* @__PURE__ */ tl.createElement("div", {
    ...Su(l),
    ...n,
    ...V,
    ref: u,
    slot: l.slot || void 0,
    onScroll: l.onScroll
  }, /* @__PURE__ */ tl.createElement(Ln, {
    values: [
      [
        rV,
        s
      ],
      [
        _9,
        {
          elementType: "div"
        }
      ],
      [
        Ba,
        {
          UNSTABLE_portalContainer: G || void 0
        }
      ],
      [
        Uf,
        {
          render: yB
        }
      ],
      [
        nB,
        {
          parentMenuRef: u
        }
      ],
      [
        kW,
        null
      ]
    ]
  }, /* @__PURE__ */ tl.createElement(a, {
    collection: Z,
    persistedKeys: rf(s.selectionManager.focusedKey),
    scrollRef: u
  }))), /* @__PURE__ */ tl.createElement("div", {
    ref: i,
    style: {
      width: "100vw",
      position: "absolute",
      top: 0,
      ...t
    }
  }));
}
const hB = /* @__PURE__ */ M.forwardRef(pB);
function yB(l, Z, u) {
  var s, G;
  let i = M.useContext(rV), { CollectionBranch: m } = M.useContext(m1), [a, n] = KV();
  var p;
  let { headingProps: y, groupProps: h } = C4({
    heading: n,
    "aria-label": (p = u.props["aria-label"]) !== null && p !== void 0 ? p : void 0
  }), S = Ks({
    defaultClassName: "react-aria-Section",
    className: (s = u.props) === null || s === void 0 ? void 0 : s.className,
    style: (G = u.props) === null || G === void 0 ? void 0 : G.style,
    values: {}
  });
  return /* @__PURE__ */ tl.createElement("section", {
    ...Su(l),
    ...h,
    ...S,
    ref: Z
  }, /* @__PURE__ */ tl.createElement(A4.Provider, {
    value: {
      ...y,
      ref: a
    }
  }, /* @__PURE__ */ tl.createElement(m, {
    collection: i.collection,
    parent: u
  })));
}
const kW = /* @__PURE__ */ M.createContext(null), SB = /* @__PURE__ */ G1("item", function(Z, u, s) {
  var G;
  [Z, u] = yd(Z, u, kW);
  let i = (G = gh(kW)) === null || G === void 0 ? void 0 : G.id, m = M.useContext(rV), a = tV(u), { menuItemProps: n, labelProps: p, descriptionProps: y, keyboardShortcutProps: h, ...S } = U4({
    ...Z,
    id: i,
    key: s.key
  }, m, a), { isFocusVisible: t, focusProps: W } = Th(), { hoverProps: V, isHovered: R } = Ro({
    isDisabled: S.isDisabled
  }), x = Ks({
    ...Z,
    id: void 0,
    children: s.rendered,
    defaultClassName: "react-aria-MenuItem",
    values: {
      ...S,
      isHovered: R,
      isFocusVisible: t,
      selectionMode: m.selectionManager.selectionMode,
      selectionBehavior: m.selectionManager.selectionBehavior,
      hasSubmenu: !!Z["aria-haspopup"],
      isOpen: Z["aria-expanded"] === "true"
    }
  }), r = Z.href ? "a" : "div";
  return /* @__PURE__ */ tl.createElement(r, {
    ...HZ(n, W, V),
    ...x,
    ref: a,
    "data-disabled": S.isDisabled || void 0,
    "data-hovered": R || void 0,
    "data-focused": S.isFocused || void 0,
    "data-focus-visible": t || void 0,
    "data-pressed": S.isPressed || void 0,
    "data-selected": S.isSelected || void 0,
    "data-selection-mode": m.selectionManager.selectionMode === "none" ? void 0 : m.selectionManager.selectionMode,
    "data-has-submenu": !!Z["aria-haspopup"] || void 0,
    "data-open": Z["aria-expanded"] === "true" || void 0
  }, /* @__PURE__ */ tl.createElement(Ln, {
    values: [
      [
        f4,
        {
          slots: {
            label: p,
            description: y
          }
        }
      ],
      [
        eB,
        h
      ]
    ]
  }, x.children));
}), FV = "-", tB = (l) => {
  const Z = KB(l), {
    conflictingClassGroups: u,
    conflictingClassGroupModifiers: s
  } = l;
  return {
    getClassGroupId: (m) => {
      const a = m.split(FV);
      return a[0] === "" && a.length !== 1 && a.shift(), uU(a, Z) || XB(m);
    },
    getConflictingClassGroupIds: (m, a) => {
      const n = u[m] || [];
      return a && s[m] ? [...n, ...s[m]] : n;
    }
  };
}, uU = (l, Z) => {
  var m;
  if (l.length === 0)
    return Z.classGroupId;
  const u = l[0], s = Z.nextPart.get(u), G = s ? uU(l.slice(1), s) : void 0;
  if (G)
    return G;
  if (Z.validators.length === 0)
    return;
  const i = l.join(FV);
  return (m = Z.validators.find(({
    validator: a
  }) => a(i))) == null ? void 0 : m.classGroupId;
}, J2 = /^\[(.+)\]$/, XB = (l) => {
  if (J2.test(l)) {
    const Z = J2.exec(l)[1], u = Z == null ? void 0 : Z.substring(0, Z.indexOf(":"));
    if (u)
      return "arbitrary.." + u;
  }
}, KB = (l) => {
  const {
    theme: Z,
    prefix: u
  } = l, s = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return VB(Object.entries(l.classGroups), u).forEach(([i, m]) => {
    MW(m, s, i, Z);
  }), s;
}, MW = (l, Z, u, s) => {
  l.forEach((G) => {
    if (typeof G == "string") {
      const i = G === "" ? Z : H2(Z, G);
      i.classGroupId = u;
      return;
    }
    if (typeof G == "function") {
      if (WB(G)) {
        MW(G(s), Z, u, s);
        return;
      }
      Z.validators.push({
        validator: G,
        classGroupId: u
      });
      return;
    }
    Object.entries(G).forEach(([i, m]) => {
      MW(m, H2(Z, i), u, s);
    });
  });
}, H2 = (l, Z) => {
  let u = l;
  return Z.split(FV).forEach((s) => {
    u.nextPart.has(s) || u.nextPart.set(s, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), u = u.nextPart.get(s);
  }), u;
}, WB = (l) => l.isThemeGetter, VB = (l, Z) => Z ? l.map(([u, s]) => {
  const G = s.map((i) => typeof i == "string" ? Z + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([m, a]) => [Z + m, a])) : i);
  return [u, G];
}) : l, xB = (l) => {
  if (l < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let Z = 0, u = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  const G = (i, m) => {
    u.set(i, m), Z++, Z > l && (Z = 0, s = u, u = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let m = u.get(i);
      if (m !== void 0)
        return m;
      if ((m = s.get(i)) !== void 0)
        return G(i, m), m;
    },
    set(i, m) {
      u.has(i) ? u.set(i, m) : G(i, m);
    }
  };
}, sU = "!", RB = (l) => {
  const {
    separator: Z,
    experimentalParseClassName: u
  } = l, s = Z.length === 1, G = Z[0], i = Z.length, m = (a) => {
    const n = [];
    let p = 0, y = 0, h;
    for (let R = 0; R < a.length; R++) {
      let x = a[R];
      if (p === 0) {
        if (x === G && (s || a.slice(R, R + i) === Z)) {
          n.push(a.slice(y, R)), y = R + i;
          continue;
        }
        if (x === "/") {
          h = R;
          continue;
        }
      }
      x === "[" ? p++ : x === "]" && p--;
    }
    const S = n.length === 0 ? a : a.substring(y), t = S.startsWith(sU), W = t ? S.substring(1) : S, V = h && h > y ? h - y : void 0;
    return {
      modifiers: n,
      hasImportantModifier: t,
      baseClassName: W,
      maybePostfixModifierPosition: V
    };
  };
  return u ? (a) => u({
    className: a,
    parseClassName: m
  }) : m;
}, YB = (l) => {
  if (l.length <= 1)
    return l;
  const Z = [];
  let u = [];
  return l.forEach((s) => {
    s[0] === "[" ? (Z.push(...u.sort(), s), u = []) : u.push(s);
  }), Z.push(...u.sort()), Z;
}, kB = (l) => ({
  cache: xB(l.cacheSize),
  parseClassName: RB(l),
  ...tB(l)
}), MB = /\s+/, IB = (l, Z) => {
  const {
    parseClassName: u,
    getClassGroupId: s,
    getConflictingClassGroupIds: G
  } = Z, i = [], m = l.trim().split(MB);
  let a = "";
  for (let n = m.length - 1; n >= 0; n -= 1) {
    const p = m[n], {
      modifiers: y,
      hasImportantModifier: h,
      baseClassName: S,
      maybePostfixModifierPosition: t
    } = u(p);
    let W = !!t, V = s(W ? S.substring(0, t) : S);
    if (!V) {
      if (!W) {
        a = p + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (V = s(S), !V) {
        a = p + (a.length > 0 ? " " + a : a);
        continue;
      }
      W = !1;
    }
    const R = YB(y).join(":"), x = h ? R + sU : R, r = x + V;
    if (i.includes(r))
      continue;
    i.push(r);
    const k = G(V, W);
    for (let U = 0; U < k.length; ++U) {
      const w = k[U];
      i.push(x + w);
    }
    a = p + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function UB() {
  let l = 0, Z, u, s = "";
  for (; l < arguments.length; )
    (Z = arguments[l++]) && (u = dU(Z)) && (s && (s += " "), s += u);
  return s;
}
const dU = (l) => {
  if (typeof l == "string")
    return l;
  let Z, u = "";
  for (let s = 0; s < l.length; s++)
    l[s] && (Z = dU(l[s])) && (u && (u += " "), u += Z);
  return u;
};
function CB(l, ...Z) {
  let u, s, G, i = m;
  function m(n) {
    const p = Z.reduce((y, h) => h(y), l());
    return u = kB(p), s = u.cache.get, G = u.cache.set, i = a, a(n);
  }
  function a(n) {
    const p = s(n);
    if (p)
      return p;
    const y = IB(n, u);
    return G(n, y), y;
  }
  return function() {
    return i(UB.apply(null, arguments));
  };
}
const qZ = (l) => {
  const Z = (u) => u[l] || [];
  return Z.isThemeGetter = !0, Z;
}, GU = /^\[(?:([a-z-]+):)?(.+)\]$/i, rB = /^\d+\/\d+$/, FB = /* @__PURE__ */ new Set(["px", "full", "screen"]), NB = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, wB = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, zB = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, JB = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, HB = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Zd = (l) => ji(l) || FB.has(l) || rB.test(l), _d = (l) => Yo(l, "length", jB), ji = (l) => !!l && !Number.isNaN(Number(l)), HK = (l) => Yo(l, "number", ji), ta = (l) => !!l && Number.isInteger(Number(l)), gB = (l) => l.endsWith("%") && ji(l.slice(0, -1)), iZ = (l) => GU.test(l), lG = (l) => NB.test(l), vB = /* @__PURE__ */ new Set(["length", "size", "percentage"]), TB = (l) => Yo(l, vB, mU), fB = (l) => Yo(l, "position", mU), EB = /* @__PURE__ */ new Set(["image", "url"]), BB = (l) => Yo(l, EB, PB), DB = (l) => Yo(l, "", QB), Xa = () => !0, Yo = (l, Z, u) => {
  const s = GU.exec(l);
  return s ? s[1] ? typeof Z == "string" ? s[1] === Z : Z.has(s[1]) : u(s[2]) : !1;
}, jB = (l) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  wB.test(l) && !zB.test(l)
), mU = () => !1, QB = (l) => JB.test(l), PB = (l) => HB.test(l), OB = () => {
  const l = qZ("colors"), Z = qZ("spacing"), u = qZ("blur"), s = qZ("brightness"), G = qZ("borderColor"), i = qZ("borderRadius"), m = qZ("borderSpacing"), a = qZ("borderWidth"), n = qZ("contrast"), p = qZ("grayscale"), y = qZ("hueRotate"), h = qZ("invert"), S = qZ("gap"), t = qZ("gradientColorStops"), W = qZ("gradientColorStopPositions"), V = qZ("inset"), R = qZ("margin"), x = qZ("opacity"), r = qZ("padding"), k = qZ("saturate"), U = qZ("scale"), w = qZ("sepia"), z = qZ("skew"), D = qZ("space"), C = qZ("translate"), j = () => ["auto", "contain", "none"], E = () => ["auto", "hidden", "clip", "visible", "scroll"], g = () => ["auto", iZ, Z], A = () => [iZ, Z], J = () => ["", Zd, _d], F = () => ["auto", ji, iZ], v = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], T = () => ["solid", "dashed", "dotted", "double", "none"], f = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], O = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], _ = () => ["", "0", iZ], il = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Zl = () => [ji, iZ];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Xa],
      spacing: [Zd, _d],
      blur: ["none", "", lG, iZ],
      brightness: Zl(),
      borderColor: [l],
      borderRadius: ["none", "", "full", lG, iZ],
      borderSpacing: A(),
      borderWidth: J(),
      contrast: Zl(),
      grayscale: _(),
      hueRotate: Zl(),
      invert: _(),
      gap: A(),
      gradientColorStops: [l],
      gradientColorStopPositions: [gB, _d],
      inset: g(),
      margin: g(),
      opacity: Zl(),
      padding: A(),
      saturate: Zl(),
      scale: Zl(),
      sepia: _(),
      skew: Zl(),
      space: A(),
      translate: A()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", iZ]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [lG]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": il()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": il()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...v(), iZ]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: E()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": E()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": E()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: j()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": j()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": j()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [V]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [V]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [V]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [V]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [V]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [V]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [V]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [V]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [V]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ta, iZ]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: g()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", iZ]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: _()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: _()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ta, iZ]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Xa]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ta, iZ]
        }, iZ]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": F()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": F()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Xa]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ta, iZ]
        }, iZ]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": F()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": F()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", iZ]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", iZ]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [S]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [S]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [S]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...O()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...O(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...O(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [r]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [r]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [r]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [r]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [r]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [r]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [r]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [r]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [r]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [R]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [R]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [R]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [R]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [R]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [R]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [R]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [R]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [R]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [D]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [D]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", iZ, Z]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [iZ, Z, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [iZ, Z, "none", "full", "min", "max", "fit", "prose", {
          screen: [lG]
        }, lG]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [iZ, Z, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [iZ, Z, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [iZ, Z, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [iZ, Z, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", lG, _d]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", HK]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Xa]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", iZ]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ji, HK]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Zd, iZ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", iZ]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", iZ]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [l]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [x]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [l]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [x]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...T(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Zd, _d]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Zd, iZ]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [l]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: A()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", iZ]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", iZ]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [x]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...v(), fB]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", TB]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, BB]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [l]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [W]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [W]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [W]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [t]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [t]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [t]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [x]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...T(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [x]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: T()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [G]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [G]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [G]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [G]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [G]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [G]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [G]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [G]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [G]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [G]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...T()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Zd, iZ]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Zd, _d]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [l]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: J()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [l]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [x]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Zd, _d]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [l]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", lG, DB]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Xa]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [x]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...f(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": f()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [u]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [s]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [n]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", lG, iZ]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [p]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [y]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [h]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [k]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [w]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [u]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [s]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [n]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [p]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [y]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [h]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [x]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [k]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [w]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [m]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [m]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [m]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", iZ]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Zl()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", iZ]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Zl()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", iZ]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [U]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [U]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [U]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ta, iZ]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [C]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [C]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [z]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [z]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", iZ]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", l]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", iZ]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [l]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": A()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": A()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": A()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": A()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": A()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": A()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": A()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": A()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": A()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": A()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": A()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": A()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": A()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": A()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": A()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": A()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": A()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": A()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", iZ]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [l, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Zd, _d, HK]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [l, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, lb = /* @__PURE__ */ CB(OB);
function Um(l, Z) {
  return nW(l, (u) => lb(Z, u));
}
const NV = [
  "focus-visible:outline",
  "focus-visible:outline-2",
  "focus-visible:outline-blue-500",
  "focus-visible:outline-offset-2",
  "focus-visible:group-data-[readonly]:outline-blue-300"
].join(" "), C_ = [
  "focus-visible:ring-1",
  "focus-visible:ring-inset",
  "focus-visible:ring-blue-500",
  "focus-visible:border-blue-500",
  "focus-visible:invalid:border-blue-500",
  "focus-visible:group-invalid:border-blue-500",
  "focus-visible:[&[readonly]]:ring-blue-300",
  "focus-visible:[&[readonly]]:border-blue-300",
  "focus-visible:[&:has(:is([readonly],[aria-readonly]))]:ring-blue-300",
  "focus-visible:[&:has(:is([readonly],[aria-readonly]))]:border-blue-300"
].join(" "), r_ = [
  "group",
  // Label style
  "[&_[data-ui=label]:not([class*=mb-])]:mb-1",
  "[&_[data-ui=label]:not([class*=mb-]):has(+:is(input,textarea,[data-ui=control]))]:mb-2",
  // Description style
  "[&>:is(input,[data-ui=control])+[data-ui=description]:not([class*=mt-])]:mt-2",
  "[&>textarea+[data-ui=description]:not([class*=mt-])]:mt-0.5",
  "[&_[data-ui=description]:not([class*=mb-]):has(+:is(input,textarea,[data-ui=control]))]:mb-3",
  // Error
  "[&>:is(input,textarea,[data-ui=control])+[data-ui=errorMessage]:not([class*=mt-])]:mt-2",
  "[&:has([data-ui=description]+[data-ui=errorMessage])_[data-ui=errorMessage]]:mt-1"
].join(" "), F_ = [
  "after:pointer-events-none",
  "after:absolute",
  "after:border-muted",
  "hover:after:border-foreground",
  "after:content-['']",
  "after:size-[9px] after:sm:size-[7.5px]",
  "after:border-b-[1.5px] after:border-r-[1.5px]",
  "after:bottom-[55%] after:end-2.5 after:-translate-x-1/2 after:translate-y-1/2 after:rotate-45 rtl:after:translate-x-1.5"
].join(" ");
function nG({
  children: l,
  "aria-label": Z,
  ...u
}) {
  const s = tl.Children.only(l);
  return /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    tl.cloneElement(s, {
      "aria-hidden": "true",
      "aria-label": void 0,
      "data-ui": "icon",
      focusable: "false",
      ...u
    }),
    Z ? /* @__PURE__ */ B.jsx("span", { className: "sr-only", children: Z }) : null
  ] });
}
function AB({
  "aria-label": l,
  ...Z
}) {
  return /* @__PURE__ */ B.jsx(nG, { "aria-label": l, children: /* @__PURE__ */ B.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      strokeWidth: "2",
      ...Z,
      children: /* @__PURE__ */ B.jsx(
        "path",
        {
          fillRule: "evenodd",
          d: "M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z",
          clipRule: "evenodd"
        }
      )
    }
  ) });
}
function $B({
  "aria-label": l,
  ...Z
}) {
  return /* @__PURE__ */ B.jsx(nG, { "aria-label": l, children: /* @__PURE__ */ B.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...Z,
      children: /* @__PURE__ */ B.jsx("path", { d: "m6 9 6 6 6-6" })
    }
  ) });
}
function qB({
  "aria-label": l,
  ...Z
}) {
  return /* @__PURE__ */ B.jsx(nG, { "aria-label": l, children: /* @__PURE__ */ B.jsx(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      ...Z,
      children: /* @__PURE__ */ B.jsx("path", { d: "m9 18 6-6-6-6" })
    }
  ) });
}
function _B({
  className: l,
  "aria-label": Z,
  ...u
}) {
  return /* @__PURE__ */ B.jsx(nG, { "aria-label": Z, children: /* @__PURE__ */ B.jsxs(
    "svg",
    {
      className: lb("animate-spin", l),
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      ...u,
      children: [
        /* @__PURE__ */ B.jsx(
          "circle",
          {
            className: "opacity-25",
            cx: "12",
            cy: "12",
            r: "10",
            stroke: "currentColor",
            strokeWidth: "4"
          }
        ),
        /* @__PURE__ */ B.jsx(
          "path",
          {
            className: "opacity-75",
            fill: "currentColor",
            d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          }
        )
      ]
    }
  ) });
}
function lD(l) {
  const Z = gh(Ba), u = (Z == null ? void 0 : Z.trigger) === "SubmenuTrigger";
  let s = 8;
  return s = l.offset !== void 0 ? l.offset : u ? s - 14 : s, /* @__PURE__ */ B.jsx(
    iB,
    {
      ...l,
      offset: s,
      className: Um(l.className, [
        "bg-white",
        "dark:bg-zinc-900",
        "shadow-md",
        "rounded-lg",
        "ring-1",
        "ring-zinc-950/10",
        "dark:ring-zinc-800",
        "entering:animate-in",
        "entering:ease-out",
        "entering:fade-in",
        "entering:placement-left:slide-in-from-right-1",
        "entering:placement-right:slide-in-from-left-1",
        "entering:placement-top:slide-in-from-bottom-1",
        "entering:placement-bottom:slide-in-from-top-1",
        "entering:duration-50",
        "exiting:animate-out",
        "exiting:ease-in",
        "exiting:fade-out",
        "exiting:placement-left:slide-out-to-right-1",
        "exiting:placement-right:slide-out-to-left-1",
        "exiting:placement-top:slide-out-to-bottom-1",
        "exiting:placement-bottom:slide-out-to-top-1",
        "exiting:duration-50"
      ])
    }
  );
}
function iU({
  children: l,
  ...Z
}) {
  return "asChild" in Z && delete Z.asChild, tl.isValidElement(l) ? tl.cloneElement(l, {
    ...Z,
    ...l.props,
    style: {
      ...Z.style,
      ...l.props.style
    },
    className: lb(
      Z.className,
      l.props.className
    )
  }) : (tl.Children.count(l) > 1 && tl.Children.only(null), null);
}
const g2 = [
  "relative inline-flex cursor-pointer items-center gap-1 rounded-lg outline-none hover:underline",
  "text-base/6 sm:text-sm/6",
  "disabled:no-underline disabled:opacity-50 disabled:cursor-default",
  "[&.border]:hover:no-underline"
].join(" ");
tl.forwardRef(
  function(Z, u) {
    if (Z.asChild)
      return /* @__PURE__ */ B.jsx(iU, { className: lb(g2), children: Z.children });
    const { asChild: s, ...G } = Z;
    return /* @__PURE__ */ B.jsx(
      w4,
      {
        ...G,
        ref: u,
        className: Um(Z.className, [
          g2,
          NV
        ])
      }
    );
  }
);
function ZD({
  className: l,
  elementType: Z,
  children: u,
  ...s
}) {
  return tl.createElement(
    Z ?? "p",
    {
      ...s,
      className: lb(
        "text-pretty text-base/6 text-muted sm:text-sm/6",
        l
      )
    },
    u
  );
}
function cD({ className: l, ...Z }) {
  return /* @__PURE__ */ B.jsx(
    ZD,
    {
      ...Z,
      elementType: "small",
      className: lb("text-sm sm:text-xs", l)
    }
  );
}
const v2 = {
  base: [
    "group relative inline-flex gap-x-2 justify-center items-center",
    "font-semibold text-base/6 sm:text-sm/6 whitespace-nowrap outline-none rounded-lg"
  ],
  solid: [
    "border border-[var(--btn-bg)] dark:border-none dark:[--border-with:0px]",
    "bg-[var(--btn-bg)] hover:bg-[var(--btn-bg-hover)] pressed:bg-[var(--btn-bg-hover)]",
    "shadow-[inset_0_1px_0_0_rgba(255,255,255,0.1)]",
    "text-white"
  ],
  outline: [
    "border border-zinc-950/10 dark:border-white/15 border-b-zinc-950/15 dark:border-b-white/20",
    "hover:bg-zinc-50 pressed:bg-zinc-50 dark:hover:bg-zinc-800 dark:pressed:bg-zinc-800",
    "shadow-sm",
    "text-[var(--btn-color)]"
  ],
  plain: [
    "[--border-with:0px]",
    "hover:bg-zinc-100 dark:hover:bg-zinc-800",
    "text-[var(--btn-color)]"
  ]
}, bD = {
  sm: {
    button: [
      "h-8 sm:h-7 px-2 text-sm/6 sm:text-xs/6 rounded-md",
      "[&_svg:not([class*=size-])]:size-3"
    ],
    iconOnly: [
      "size-8 sm:size-7 rounded-md",
      "[&_svg:not([class*=size-])]:size-5",
      "sm:[&_svg:not([class*=size-])]:size-4"
    ]
  },
  md: {
    // H: 44px, sm:36px
    button: [
      "px-3 py-[calc(theme(spacing[2.5])-var(--border-with,1px))]",
      "sm:py-[calc(theme(spacing[1.5])-var(--border-with,1px))]",
      "[&_svg:not([class*=size-])]:size-5",
      "sm:[&_svg:not([class*=size-])]:size-4"
    ],
    iconOnly: [
      "p-[calc(theme(spacing[2.5])-var(--border-with,1px))]",
      "sm:p-[calc(theme(spacing[1.5])-var(--border-with,1px))]",
      // 20+2x2=24px
      "[&_svg:not([class*=size-])]:size-5",
      "[&_svg]:m-0.5",
      // 16+4x2=24px
      "sm:[&_svg:not([class*=size-])]:size-4",
      "sm:[&_svg]:m-1"
    ]
  },
  lg: {
    button: [
      "px-4 py-[calc(theme(spacing[2.5])-var(--border-with,1px))]",
      "[&_svg:not([class*=size-])]:size-5"
    ],
    iconOnly: [
      "p-[calc(theme(spacing[2.5])-var(--border-with,1px))]",
      "[&_svg:not([class*=size-])]:size-5",
      "[&_svg]:m-0.5"
    ]
  }
};
function T2({
  size: l,
  color: Z,
  isIconOnly: u,
  variant: s = "solid"
}) {
  if (s === "unstyle")
    return "relative outline-none rounded-lg";
  const G = l ?? "md", i = u ? "iconOnly" : "button", m = {
    accent: [
      "[--btn-bg:theme(colors.accent)]",
      "[--btn-bg-hover:theme(colors.accent/90%)]"
    ],
    destructive: [
      "[--btn-bg:theme(colors.destructive)]",
      "[--btn-bg-hover:theme(colors.destructive/90%)]"
    ],
    success: [
      "[--btn-bg:theme(colors.success)]",
      "[--btn-bg-hover:theme(colors.success/90%)]"
    ]
  }, a = {
    foreground: "[--btn-color:theme(colors.foreground)]",
    accent: "[--btn-color:theme(colors.accent)]",
    destructive: "[--btn-color:theme(colors.destructive)]",
    success: "[--btn-color:theme(colors.success)]"
  };
  return [
    v2.base,
    v2[s],
    s == "solid" ? [m[Z ?? "accent"]] : [a[Z ?? "foreground"]],
    bD[G][i]
  ];
}
const uD = tl.forwardRef(
  function(Z, u) {
    if (Z.asChild)
      return /* @__PURE__ */ B.jsx(iU, { className: lb(T2(Z)), children: Z.children });
    const {
      asChild: s,
      children: G,
      isCustomPending: i,
      pendingLabel: m,
      size: a,
      color: n,
      variant: p = "solid",
      isIconOnly: y,
      ...h
    } = Z;
    return /* @__PURE__ */ B.jsx(B.Fragment, { children: /* @__PURE__ */ B.jsx(
      T4,
      {
        ...h,
        ref: u,
        "data-variant": p,
        className: Um(Z.className, [
          T2({ size: a, color: n, isIconOnly: y, variant: p }),
          NV,
          "disabled:opacity-50",
          "data-[pending]:opacity-75",
          !i && "data-[pending]:text-transparent"
        ]),
        children: (S) => /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
          S.isPending && /* @__PURE__ */ B.jsx(
            _B,
            {
              "aria-label": m,
              className: lb(
                "absolute",
                "text-foreground",
                "group-data-[variant=solid]:text-zinc-300",
                i ? "group-data-[pending]:sr-only" : "group-data-[pending]:flex"
              )
            }
          ),
          /* @__PURE__ */ B.jsx(
            "span",
            {
              className: "contents",
              ...S.isPending && { "aria-hidden": !0 },
              children: typeof G == "function" ? G(S) : G
            }
          ),
          /* @__PURE__ */ B.jsx(
            "span",
            {
              className: "absolute left-1/2 top-1/2 size-[max(100%,2.75rem)] -translate-x-1/2 -translate-y-1/2 [@media(pointer:fine)]:hidden",
              "aria-hidden": "true"
            }
          )
        ] })
      }
    ) });
  }
);
function f2() {
  return /* @__PURE__ */ B.jsx("div", { className: "absolute bg-white bg-opacity-60 z-10 h-full w-full flex items-center justify-center", children: /* @__PURE__ */ B.jsxs("div", { className: "flex items-center", children: [
    /* @__PURE__ */ B.jsx("span", { className: "text-3xl mr-4", children: "Loading" }),
    /* @__PURE__ */ B.jsxs("svg", { className: "animate-spin h-8 w-8 text-gray-800", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [
      /* @__PURE__ */ B.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
      /* @__PURE__ */ B.jsx(
        "path",
        {
          className: "opacity-75",
          fill: "currentColor",
          d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        }
      )
    ] })
  ] }) });
}
function sD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"
  }));
}
const dD = /* @__PURE__ */ M.forwardRef(sD);
function GD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m15 15 6-6m0 0-6-6m6 6H9a6 6 0 0 0 0 12h3"
  }));
}
const mD = /* @__PURE__ */ M.forwardRef(GD);
function iD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3.75 9h16.5m-16.5 6.75h16.5"
  }));
}
const oD = /* @__PURE__ */ M.forwardRef(iD);
function eD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m8.25 4.5 7.5 7.5-7.5 7.5"
  }));
}
const aD = /* @__PURE__ */ M.forwardRef(eD);
function nD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 12h3.75M9 15h3.75M9 18h3.75m3 .75H18a2.25 2.25 0 0 0 2.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 0 0-1.123-.08m-5.801 0c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75 2.25 2.25 0 0 0-.1-.664m-5.8 0A2.251 2.251 0 0 1 13.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m0 0H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V9.375c0-.621-.504-1.125-1.125-1.125H8.25ZM6.75 12h.008v.008H6.75V12Zm0 3h.008v.008H6.75V15Zm0 3h.008v.008H6.75V18Z"
  }));
}
const pD = /* @__PURE__ */ M.forwardRef(nD);
function LD({
  title: l,
  titleId: Z,
  ...u
}, s) {
  return /* @__PURE__ */ M.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: s,
    "aria-labelledby": Z
  }, u), l ? /* @__PURE__ */ M.createElement("title", {
    id: Z
  }, l) : null, /* @__PURE__ */ M.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M4.5 12a7.5 7.5 0 0 0 15 0m-15 0a7.5 7.5 0 1 1 15 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077 1.41-.513m14.095-5.13 1.41-.513M5.106 17.785l1.15-.964m11.49-9.642 1.149-.964M7.501 19.795l.75-1.3m7.5-12.99.75-1.3m-6.063 16.658.26-1.477m2.605-14.772.26-1.477m0 17.726-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205 12 12m6.894 5.785-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495"
  }));
}
const hD = /* @__PURE__ */ M.forwardRef(LD);
function Lc(l) {
  if (typeof l == "string" || typeof l == "number") return "" + l;
  let Z = "";
  if (Array.isArray(l))
    for (let u = 0, s; u < l.length; u++)
      (s = Lc(l[u])) !== "" && (Z += (Z && " ") + s);
  else
    for (let u in l)
      l[u] && (Z += (Z && " ") + u);
  return Z;
}
var yD = { value: () => {
} };
function Bh() {
  for (var l = 0, Z = arguments.length, u = {}, s; l < Z; ++l) {
    if (!(s = arguments[l] + "") || s in u || /[\s.]/.test(s)) throw new Error("illegal type: " + s);
    u[s] = [];
  }
  return new dh(u);
}
function dh(l) {
  this._ = l;
}
function SD(l, Z) {
  return l.trim().split(/^|\s+/).map(function(u) {
    var s = "", G = u.indexOf(".");
    if (G >= 0 && (s = u.slice(G + 1), u = u.slice(0, G)), u && !Z.hasOwnProperty(u)) throw new Error("unknown type: " + u);
    return { type: u, name: s };
  });
}
dh.prototype = Bh.prototype = {
  constructor: dh,
  on: function(l, Z) {
    var u = this._, s = SD(l + "", u), G, i = -1, m = s.length;
    if (arguments.length < 2) {
      for (; ++i < m; ) if ((G = (l = s[i]).type) && (G = tD(u[G], l.name))) return G;
      return;
    }
    if (Z != null && typeof Z != "function") throw new Error("invalid callback: " + Z);
    for (; ++i < m; )
      if (G = (l = s[i]).type) u[G] = E2(u[G], l.name, Z);
      else if (Z == null) for (G in u) u[G] = E2(u[G], l.name, null);
    return this;
  },
  copy: function() {
    var l = {}, Z = this._;
    for (var u in Z) l[u] = Z[u].slice();
    return new dh(l);
  },
  call: function(l, Z) {
    if ((G = arguments.length - 2) > 0) for (var u = new Array(G), s = 0, G, i; s < G; ++s) u[s] = arguments[s + 2];
    if (!this._.hasOwnProperty(l)) throw new Error("unknown type: " + l);
    for (i = this._[l], s = 0, G = i.length; s < G; ++s) i[s].value.apply(Z, u);
  },
  apply: function(l, Z, u) {
    if (!this._.hasOwnProperty(l)) throw new Error("unknown type: " + l);
    for (var s = this._[l], G = 0, i = s.length; G < i; ++G) s[G].value.apply(Z, u);
  }
};
function tD(l, Z) {
  for (var u = 0, s = l.length, G; u < s; ++u)
    if ((G = l[u]).name === Z)
      return G.value;
}
function E2(l, Z, u) {
  for (var s = 0, G = l.length; s < G; ++s)
    if (l[s].name === Z) {
      l[s] = yD, l = l.slice(0, s).concat(l.slice(s + 1));
      break;
    }
  return u != null && l.push({ name: Z, value: u }), l;
}
var IW = "http://www.w3.org/1999/xhtml";
const B2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: IW,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Dh(l) {
  var Z = l += "", u = Z.indexOf(":");
  return u >= 0 && (Z = l.slice(0, u)) !== "xmlns" && (l = l.slice(u + 1)), B2.hasOwnProperty(Z) ? { space: B2[Z], local: l } : l;
}
function XD(l) {
  return function() {
    var Z = this.ownerDocument, u = this.namespaceURI;
    return u === IW && Z.documentElement.namespaceURI === IW ? Z.createElement(l) : Z.createElementNS(u, l);
  };
}
function KD(l) {
  return function() {
    return this.ownerDocument.createElementNS(l.space, l.local);
  };
}
function oU(l) {
  var Z = Dh(l);
  return (Z.local ? KD : XD)(Z);
}
function WD() {
}
function wV(l) {
  return l == null ? WD : function() {
    return this.querySelector(l);
  };
}
function VD(l) {
  typeof l != "function" && (l = wV(l));
  for (var Z = this._groups, u = Z.length, s = new Array(u), G = 0; G < u; ++G)
    for (var i = Z[G], m = i.length, a = s[G] = new Array(m), n, p, y = 0; y < m; ++y)
      (n = i[y]) && (p = l.call(n, n.__data__, y, i)) && ("__data__" in n && (p.__data__ = n.__data__), a[y] = p);
  return new Zu(s, this._parents);
}
function xD(l) {
  return l == null ? [] : Array.isArray(l) ? l : Array.from(l);
}
function RD() {
  return [];
}
function eU(l) {
  return l == null ? RD : function() {
    return this.querySelectorAll(l);
  };
}
function YD(l) {
  return function() {
    return xD(l.apply(this, arguments));
  };
}
function kD(l) {
  typeof l == "function" ? l = YD(l) : l = eU(l);
  for (var Z = this._groups, u = Z.length, s = [], G = [], i = 0; i < u; ++i)
    for (var m = Z[i], a = m.length, n, p = 0; p < a; ++p)
      (n = m[p]) && (s.push(l.call(n, n.__data__, p, m)), G.push(n));
  return new Zu(s, G);
}
function aU(l) {
  return function() {
    return this.matches(l);
  };
}
function nU(l) {
  return function(Z) {
    return Z.matches(l);
  };
}
var MD = Array.prototype.find;
function ID(l) {
  return function() {
    return MD.call(this.children, l);
  };
}
function UD() {
  return this.firstElementChild;
}
function CD(l) {
  return this.select(l == null ? UD : ID(typeof l == "function" ? l : nU(l)));
}
var rD = Array.prototype.filter;
function FD() {
  return Array.from(this.children);
}
function ND(l) {
  return function() {
    return rD.call(this.children, l);
  };
}
function wD(l) {
  return this.selectAll(l == null ? FD : ND(typeof l == "function" ? l : nU(l)));
}
function zD(l) {
  typeof l != "function" && (l = aU(l));
  for (var Z = this._groups, u = Z.length, s = new Array(u), G = 0; G < u; ++G)
    for (var i = Z[G], m = i.length, a = s[G] = [], n, p = 0; p < m; ++p)
      (n = i[p]) && l.call(n, n.__data__, p, i) && a.push(n);
  return new Zu(s, this._parents);
}
function pU(l) {
  return new Array(l.length);
}
function JD() {
  return new Zu(this._enter || this._groups.map(pU), this._parents);
}
function th(l, Z) {
  this.ownerDocument = l.ownerDocument, this.namespaceURI = l.namespaceURI, this._next = null, this._parent = l, this.__data__ = Z;
}
th.prototype = {
  constructor: th,
  appendChild: function(l) {
    return this._parent.insertBefore(l, this._next);
  },
  insertBefore: function(l, Z) {
    return this._parent.insertBefore(l, Z);
  },
  querySelector: function(l) {
    return this._parent.querySelector(l);
  },
  querySelectorAll: function(l) {
    return this._parent.querySelectorAll(l);
  }
};
function HD(l) {
  return function() {
    return l;
  };
}
function gD(l, Z, u, s, G, i) {
  for (var m = 0, a, n = Z.length, p = i.length; m < p; ++m)
    (a = Z[m]) ? (a.__data__ = i[m], s[m] = a) : u[m] = new th(l, i[m]);
  for (; m < n; ++m)
    (a = Z[m]) && (G[m] = a);
}
function vD(l, Z, u, s, G, i, m) {
  var a, n, p = /* @__PURE__ */ new Map(), y = Z.length, h = i.length, S = new Array(y), t;
  for (a = 0; a < y; ++a)
    (n = Z[a]) && (S[a] = t = m.call(n, n.__data__, a, Z) + "", p.has(t) ? G[a] = n : p.set(t, n));
  for (a = 0; a < h; ++a)
    t = m.call(l, i[a], a, i) + "", (n = p.get(t)) ? (s[a] = n, n.__data__ = i[a], p.delete(t)) : u[a] = new th(l, i[a]);
  for (a = 0; a < y; ++a)
    (n = Z[a]) && p.get(S[a]) === n && (G[a] = n);
}
function TD(l) {
  return l.__data__;
}
function fD(l, Z) {
  if (!arguments.length) return Array.from(this, TD);
  var u = Z ? vD : gD, s = this._parents, G = this._groups;
  typeof l != "function" && (l = HD(l));
  for (var i = G.length, m = new Array(i), a = new Array(i), n = new Array(i), p = 0; p < i; ++p) {
    var y = s[p], h = G[p], S = h.length, t = ED(l.call(y, y && y.__data__, p, s)), W = t.length, V = a[p] = new Array(W), R = m[p] = new Array(W), x = n[p] = new Array(S);
    u(y, h, V, R, x, t, Z);
    for (var r = 0, k = 0, U, w; r < W; ++r)
      if (U = V[r]) {
        for (r >= k && (k = r + 1); !(w = R[k]) && ++k < W; ) ;
        U._next = w || null;
      }
  }
  return m = new Zu(m, s), m._enter = a, m._exit = n, m;
}
function ED(l) {
  return typeof l == "object" && "length" in l ? l : Array.from(l);
}
function BD() {
  return new Zu(this._exit || this._groups.map(pU), this._parents);
}
function DD(l, Z, u) {
  var s = this.enter(), G = this, i = this.exit();
  return typeof l == "function" ? (s = l(s), s && (s = s.selection())) : s = s.append(l + ""), Z != null && (G = Z(G), G && (G = G.selection())), u == null ? i.remove() : u(i), s && G ? s.merge(G).order() : G;
}
function jD(l) {
  for (var Z = l.selection ? l.selection() : l, u = this._groups, s = Z._groups, G = u.length, i = s.length, m = Math.min(G, i), a = new Array(G), n = 0; n < m; ++n)
    for (var p = u[n], y = s[n], h = p.length, S = a[n] = new Array(h), t, W = 0; W < h; ++W)
      (t = p[W] || y[W]) && (S[W] = t);
  for (; n < G; ++n)
    a[n] = u[n];
  return new Zu(a, this._parents);
}
function QD() {
  for (var l = this._groups, Z = -1, u = l.length; ++Z < u; )
    for (var s = l[Z], G = s.length - 1, i = s[G], m; --G >= 0; )
      (m = s[G]) && (i && m.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(m, i), i = m);
  return this;
}
function PD(l) {
  l || (l = OD);
  function Z(h, S) {
    return h && S ? l(h.__data__, S.__data__) : !h - !S;
  }
  for (var u = this._groups, s = u.length, G = new Array(s), i = 0; i < s; ++i) {
    for (var m = u[i], a = m.length, n = G[i] = new Array(a), p, y = 0; y < a; ++y)
      (p = m[y]) && (n[y] = p);
    n.sort(Z);
  }
  return new Zu(G, this._parents).order();
}
function OD(l, Z) {
  return l < Z ? -1 : l > Z ? 1 : l >= Z ? 0 : NaN;
}
function AD() {
  var l = arguments[0];
  return arguments[0] = this, l.apply(null, arguments), this;
}
function $D() {
  return Array.from(this);
}
function qD() {
  for (var l = this._groups, Z = 0, u = l.length; Z < u; ++Z)
    for (var s = l[Z], G = 0, i = s.length; G < i; ++G) {
      var m = s[G];
      if (m) return m;
    }
  return null;
}
function _D() {
  let l = 0;
  for (const Z of this) ++l;
  return l;
}
function lj() {
  return !this.node();
}
function Zj(l) {
  for (var Z = this._groups, u = 0, s = Z.length; u < s; ++u)
    for (var G = Z[u], i = 0, m = G.length, a; i < m; ++i)
      (a = G[i]) && l.call(a, a.__data__, i, G);
  return this;
}
function cj(l) {
  return function() {
    this.removeAttribute(l);
  };
}
function bj(l) {
  return function() {
    this.removeAttributeNS(l.space, l.local);
  };
}
function uj(l, Z) {
  return function() {
    this.setAttribute(l, Z);
  };
}
function sj(l, Z) {
  return function() {
    this.setAttributeNS(l.space, l.local, Z);
  };
}
function dj(l, Z) {
  return function() {
    var u = Z.apply(this, arguments);
    u == null ? this.removeAttribute(l) : this.setAttribute(l, u);
  };
}
function Gj(l, Z) {
  return function() {
    var u = Z.apply(this, arguments);
    u == null ? this.removeAttributeNS(l.space, l.local) : this.setAttributeNS(l.space, l.local, u);
  };
}
function mj(l, Z) {
  var u = Dh(l);
  if (arguments.length < 2) {
    var s = this.node();
    return u.local ? s.getAttributeNS(u.space, u.local) : s.getAttribute(u);
  }
  return this.each((Z == null ? u.local ? bj : cj : typeof Z == "function" ? u.local ? Gj : dj : u.local ? sj : uj)(u, Z));
}
function LU(l) {
  return l.ownerDocument && l.ownerDocument.defaultView || l.document && l || l.defaultView;
}
function ij(l) {
  return function() {
    this.style.removeProperty(l);
  };
}
function oj(l, Z, u) {
  return function() {
    this.style.setProperty(l, Z, u);
  };
}
function ej(l, Z, u) {
  return function() {
    var s = Z.apply(this, arguments);
    s == null ? this.style.removeProperty(l) : this.style.setProperty(l, s, u);
  };
}
function aj(l, Z, u) {
  return arguments.length > 1 ? this.each((Z == null ? ij : typeof Z == "function" ? ej : oj)(l, Z, u ?? "")) : ao(this.node(), l);
}
function ao(l, Z) {
  return l.style.getPropertyValue(Z) || LU(l).getComputedStyle(l, null).getPropertyValue(Z);
}
function nj(l) {
  return function() {
    delete this[l];
  };
}
function pj(l, Z) {
  return function() {
    this[l] = Z;
  };
}
function Lj(l, Z) {
  return function() {
    var u = Z.apply(this, arguments);
    u == null ? delete this[l] : this[l] = u;
  };
}
function hj(l, Z) {
  return arguments.length > 1 ? this.each((Z == null ? nj : typeof Z == "function" ? Lj : pj)(l, Z)) : this.node()[l];
}
function hU(l) {
  return l.trim().split(/^|\s+/);
}
function zV(l) {
  return l.classList || new yU(l);
}
function yU(l) {
  this._node = l, this._names = hU(l.getAttribute("class") || "");
}
yU.prototype = {
  add: function(l) {
    var Z = this._names.indexOf(l);
    Z < 0 && (this._names.push(l), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(l) {
    var Z = this._names.indexOf(l);
    Z >= 0 && (this._names.splice(Z, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(l) {
    return this._names.indexOf(l) >= 0;
  }
};
function SU(l, Z) {
  for (var u = zV(l), s = -1, G = Z.length; ++s < G; ) u.add(Z[s]);
}
function tU(l, Z) {
  for (var u = zV(l), s = -1, G = Z.length; ++s < G; ) u.remove(Z[s]);
}
function yj(l) {
  return function() {
    SU(this, l);
  };
}
function Sj(l) {
  return function() {
    tU(this, l);
  };
}
function tj(l, Z) {
  return function() {
    (Z.apply(this, arguments) ? SU : tU)(this, l);
  };
}
function Xj(l, Z) {
  var u = hU(l + "");
  if (arguments.length < 2) {
    for (var s = zV(this.node()), G = -1, i = u.length; ++G < i; ) if (!s.contains(u[G])) return !1;
    return !0;
  }
  return this.each((typeof Z == "function" ? tj : Z ? yj : Sj)(u, Z));
}
function Kj() {
  this.textContent = "";
}
function Wj(l) {
  return function() {
    this.textContent = l;
  };
}
function Vj(l) {
  return function() {
    var Z = l.apply(this, arguments);
    this.textContent = Z ?? "";
  };
}
function xj(l) {
  return arguments.length ? this.each(l == null ? Kj : (typeof l == "function" ? Vj : Wj)(l)) : this.node().textContent;
}
function Rj() {
  this.innerHTML = "";
}
function Yj(l) {
  return function() {
    this.innerHTML = l;
  };
}
function kj(l) {
  return function() {
    var Z = l.apply(this, arguments);
    this.innerHTML = Z ?? "";
  };
}
function Mj(l) {
  return arguments.length ? this.each(l == null ? Rj : (typeof l == "function" ? kj : Yj)(l)) : this.node().innerHTML;
}
function Ij() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Uj() {
  return this.each(Ij);
}
function Cj() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function rj() {
  return this.each(Cj);
}
function Fj(l) {
  var Z = typeof l == "function" ? l : oU(l);
  return this.select(function() {
    return this.appendChild(Z.apply(this, arguments));
  });
}
function Nj() {
  return null;
}
function wj(l, Z) {
  var u = typeof l == "function" ? l : oU(l), s = Z == null ? Nj : typeof Z == "function" ? Z : wV(Z);
  return this.select(function() {
    return this.insertBefore(u.apply(this, arguments), s.apply(this, arguments) || null);
  });
}
function zj() {
  var l = this.parentNode;
  l && l.removeChild(this);
}
function Jj() {
  return this.each(zj);
}
function Hj() {
  var l = this.cloneNode(!1), Z = this.parentNode;
  return Z ? Z.insertBefore(l, this.nextSibling) : l;
}
function gj() {
  var l = this.cloneNode(!0), Z = this.parentNode;
  return Z ? Z.insertBefore(l, this.nextSibling) : l;
}
function vj(l) {
  return this.select(l ? gj : Hj);
}
function Tj(l) {
  return arguments.length ? this.property("__data__", l) : this.node().__data__;
}
function fj(l) {
  return function(Z) {
    l.call(this, Z, this.__data__);
  };
}
function Ej(l) {
  return l.trim().split(/^|\s+/).map(function(Z) {
    var u = "", s = Z.indexOf(".");
    return s >= 0 && (u = Z.slice(s + 1), Z = Z.slice(0, s)), { type: Z, name: u };
  });
}
function Bj(l) {
  return function() {
    var Z = this.__on;
    if (Z) {
      for (var u = 0, s = -1, G = Z.length, i; u < G; ++u)
        i = Z[u], (!l.type || i.type === l.type) && i.name === l.name ? this.removeEventListener(i.type, i.listener, i.options) : Z[++s] = i;
      ++s ? Z.length = s : delete this.__on;
    }
  };
}
function Dj(l, Z, u) {
  return function() {
    var s = this.__on, G, i = fj(Z);
    if (s) {
      for (var m = 0, a = s.length; m < a; ++m)
        if ((G = s[m]).type === l.type && G.name === l.name) {
          this.removeEventListener(G.type, G.listener, G.options), this.addEventListener(G.type, G.listener = i, G.options = u), G.value = Z;
          return;
        }
    }
    this.addEventListener(l.type, i, u), G = { type: l.type, name: l.name, value: Z, listener: i, options: u }, s ? s.push(G) : this.__on = [G];
  };
}
function jj(l, Z, u) {
  var s = Ej(l + ""), G, i = s.length, m;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var n = 0, p = a.length, y; n < p; ++n)
        for (G = 0, y = a[n]; G < i; ++G)
          if ((m = s[G]).type === y.type && m.name === y.name)
            return y.value;
    }
    return;
  }
  for (a = Z ? Dj : Bj, G = 0; G < i; ++G) this.each(a(s[G], Z, u));
  return this;
}
function XU(l, Z, u) {
  var s = LU(l), G = s.CustomEvent;
  typeof G == "function" ? G = new G(Z, u) : (G = s.document.createEvent("Event"), u ? (G.initEvent(Z, u.bubbles, u.cancelable), G.detail = u.detail) : G.initEvent(Z, !1, !1)), l.dispatchEvent(G);
}
function Qj(l, Z) {
  return function() {
    return XU(this, l, Z);
  };
}
function Pj(l, Z) {
  return function() {
    return XU(this, l, Z.apply(this, arguments));
  };
}
function Oj(l, Z) {
  return this.each((typeof Z == "function" ? Pj : Qj)(l, Z));
}
function* Aj() {
  for (var l = this._groups, Z = 0, u = l.length; Z < u; ++Z)
    for (var s = l[Z], G = 0, i = s.length, m; G < i; ++G)
      (m = s[G]) && (yield m);
}
var KU = [null];
function Zu(l, Z) {
  this._groups = l, this._parents = Z;
}
function yn() {
  return new Zu([[document.documentElement]], KU);
}
function $j() {
  return this;
}
Zu.prototype = yn.prototype = {
  constructor: Zu,
  select: VD,
  selectAll: kD,
  selectChild: CD,
  selectChildren: wD,
  filter: zD,
  data: fD,
  enter: JD,
  exit: BD,
  join: DD,
  merge: jD,
  selection: $j,
  order: QD,
  sort: PD,
  call: AD,
  nodes: $D,
  node: qD,
  size: _D,
  empty: lj,
  each: Zj,
  attr: mj,
  style: aj,
  property: hj,
  classed: Xj,
  text: xj,
  html: Mj,
  raise: Uj,
  lower: rj,
  append: Fj,
  insert: wj,
  remove: Jj,
  clone: vj,
  datum: Tj,
  on: jj,
  dispatch: Oj,
  [Symbol.iterator]: Aj
};
function lu(l) {
  return typeof l == "string" ? new Zu([[document.querySelector(l)]], [document.documentElement]) : new Zu([[l]], KU);
}
function qj(l) {
  let Z;
  for (; Z = l.sourceEvent; ) l = Z;
  return l;
}
function vu(l, Z) {
  if (l = qj(l), Z === void 0 && (Z = l.currentTarget), Z) {
    var u = Z.ownerSVGElement || Z;
    if (u.createSVGPoint) {
      var s = u.createSVGPoint();
      return s.x = l.clientX, s.y = l.clientY, s = s.matrixTransform(Z.getScreenCTM().inverse()), [s.x, s.y];
    }
    if (Z.getBoundingClientRect) {
      var G = Z.getBoundingClientRect();
      return [l.clientX - G.left - Z.clientLeft, l.clientY - G.top - Z.clientTop];
    }
  }
  return [l.pageX, l.pageY];
}
const _j = { passive: !1 }, Da = { capture: !0, passive: !1 };
function gK(l) {
  l.stopImmediatePropagation();
}
function Qi(l) {
  l.preventDefault(), l.stopImmediatePropagation();
}
function WU(l) {
  var Z = l.document.documentElement, u = lu(l).on("dragstart.drag", Qi, Da);
  "onselectstart" in Z ? u.on("selectstart.drag", Qi, Da) : (Z.__noselect = Z.style.MozUserSelect, Z.style.MozUserSelect = "none");
}
function VU(l, Z) {
  var u = l.document.documentElement, s = lu(l).on("dragstart.drag", null);
  Z && (s.on("click.drag", Qi, Da), setTimeout(function() {
    s.on("click.drag", null);
  }, 0)), "onselectstart" in u ? s.on("selectstart.drag", null) : (u.style.MozUserSelect = u.__noselect, delete u.__noselect);
}
const QL = (l) => () => l;
function UW(l, {
  sourceEvent: Z,
  subject: u,
  target: s,
  identifier: G,
  active: i,
  x: m,
  y: a,
  dx: n,
  dy: p,
  dispatch: y
}) {
  Object.defineProperties(this, {
    type: { value: l, enumerable: !0, configurable: !0 },
    sourceEvent: { value: Z, enumerable: !0, configurable: !0 },
    subject: { value: u, enumerable: !0, configurable: !0 },
    target: { value: s, enumerable: !0, configurable: !0 },
    identifier: { value: G, enumerable: !0, configurable: !0 },
    active: { value: i, enumerable: !0, configurable: !0 },
    x: { value: m, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: n, enumerable: !0, configurable: !0 },
    dy: { value: p, enumerable: !0, configurable: !0 },
    _: { value: y }
  });
}
UW.prototype.on = function() {
  var l = this._.on.apply(this._, arguments);
  return l === this._ ? this : l;
};
function lQ(l) {
  return !l.ctrlKey && !l.button;
}
function ZQ() {
  return this.parentNode;
}
function cQ(l, Z) {
  return Z ?? { x: l.x, y: l.y };
}
function bQ() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function xU() {
  var l = lQ, Z = ZQ, u = cQ, s = bQ, G = {}, i = Bh("start", "drag", "end"), m = 0, a, n, p, y, h = 0;
  function S(U) {
    U.on("mousedown.drag", t).filter(s).on("touchstart.drag", R).on("touchmove.drag", x, _j).on("touchend.drag touchcancel.drag", r).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function t(U, w) {
    if (!(y || !l.call(this, U, w))) {
      var z = k(this, Z.call(this, U, w), U, w, "mouse");
      z && (lu(U.view).on("mousemove.drag", W, Da).on("mouseup.drag", V, Da), WU(U.view), gK(U), p = !1, a = U.clientX, n = U.clientY, z("start", U));
    }
  }
  function W(U) {
    if (Qi(U), !p) {
      var w = U.clientX - a, z = U.clientY - n;
      p = w * w + z * z > h;
    }
    G.mouse("drag", U);
  }
  function V(U) {
    lu(U.view).on("mousemove.drag mouseup.drag", null), VU(U.view, p), Qi(U), G.mouse("end", U);
  }
  function R(U, w) {
    if (l.call(this, U, w)) {
      var z = U.changedTouches, D = Z.call(this, U, w), C = z.length, j, E;
      for (j = 0; j < C; ++j)
        (E = k(this, D, U, w, z[j].identifier, z[j])) && (gK(U), E("start", U, z[j]));
    }
  }
  function x(U) {
    var w = U.changedTouches, z = w.length, D, C;
    for (D = 0; D < z; ++D)
      (C = G[w[D].identifier]) && (Qi(U), C("drag", U, w[D]));
  }
  function r(U) {
    var w = U.changedTouches, z = w.length, D, C;
    for (y && clearTimeout(y), y = setTimeout(function() {
      y = null;
    }, 500), D = 0; D < z; ++D)
      (C = G[w[D].identifier]) && (gK(U), C("end", U, w[D]));
  }
  function k(U, w, z, D, C, j) {
    var E = i.copy(), g = vu(j || z, w), A, J, F;
    if ((F = u.call(U, new UW("beforestart", {
      sourceEvent: z,
      target: S,
      identifier: C,
      active: m,
      x: g[0],
      y: g[1],
      dx: 0,
      dy: 0,
      dispatch: E
    }), D)) != null)
      return A = F.x - g[0] || 0, J = F.y - g[1] || 0, function v(T, f, O) {
        var _ = g, il;
        switch (T) {
          case "start":
            G[C] = v, il = m++;
            break;
          case "end":
            delete G[C], --m;
          case "drag":
            g = vu(O || f, w), il = m;
            break;
        }
        E.call(
          T,
          U,
          new UW(T, {
            sourceEvent: f,
            subject: F,
            target: S,
            identifier: C,
            active: il,
            x: g[0] + A,
            y: g[1] + J,
            dx: g[0] - _[0],
            dy: g[1] - _[1],
            dispatch: E
          }),
          D
        );
      };
  }
  return S.filter = function(U) {
    return arguments.length ? (l = typeof U == "function" ? U : QL(!!U), S) : l;
  }, S.container = function(U) {
    return arguments.length ? (Z = typeof U == "function" ? U : QL(U), S) : Z;
  }, S.subject = function(U) {
    return arguments.length ? (u = typeof U == "function" ? U : QL(U), S) : u;
  }, S.touchable = function(U) {
    return arguments.length ? (s = typeof U == "function" ? U : QL(!!U), S) : s;
  }, S.on = function() {
    var U = i.on.apply(i, arguments);
    return U === i ? S : U;
  }, S.clickDistance = function(U) {
    return arguments.length ? (h = (U = +U) * U, S) : Math.sqrt(h);
  }, S;
}
function ko(l, Z, u) {
  l.prototype = Z.prototype = u, u.constructor = l;
}
function Sn(l, Z) {
  var u = Object.create(l.prototype);
  for (var s in Z) u[s] = Z[s];
  return u;
}
function hG() {
}
var Km = 0.7, no = 1 / Km, Pi = "\\s*([+-]?\\d+)\\s*", ja = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ys = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", uQ = /^#([0-9a-f]{3,8})$/, sQ = new RegExp(`^rgb\\(${Pi},${Pi},${Pi}\\)$`), dQ = new RegExp(`^rgb\\(${ys},${ys},${ys}\\)$`), GQ = new RegExp(`^rgba\\(${Pi},${Pi},${Pi},${ja}\\)$`), mQ = new RegExp(`^rgba\\(${ys},${ys},${ys},${ja}\\)$`), iQ = new RegExp(`^hsl\\(${ja},${ys},${ys}\\)$`), oQ = new RegExp(`^hsla\\(${ja},${ys},${ys},${ja}\\)$`), D2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
ko(hG, Wm, {
  copy(l) {
    return Object.assign(new this.constructor(), this, l);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: j2,
  // Deprecated! Use color.formatHex.
  formatHex: j2,
  formatHex8: eQ,
  formatHsl: aQ,
  formatRgb: Q2,
  toString: Q2
});
function j2() {
  return this.rgb().formatHex();
}
function eQ() {
  return this.rgb().formatHex8();
}
function aQ() {
  return RU(this).formatHsl();
}
function Q2() {
  return this.rgb().formatRgb();
}
function Wm(l) {
  var Z, u;
  return l = (l + "").trim().toLowerCase(), (Z = uQ.exec(l)) ? (u = Z[1].length, Z = parseInt(Z[1], 16), u === 6 ? P2(Z) : u === 3 ? new vc(Z >> 8 & 15 | Z >> 4 & 240, Z >> 4 & 15 | Z & 240, (Z & 15) << 4 | Z & 15, 1) : u === 8 ? PL(Z >> 24 & 255, Z >> 16 & 255, Z >> 8 & 255, (Z & 255) / 255) : u === 4 ? PL(Z >> 12 & 15 | Z >> 8 & 240, Z >> 8 & 15 | Z >> 4 & 240, Z >> 4 & 15 | Z & 240, ((Z & 15) << 4 | Z & 15) / 255) : null) : (Z = sQ.exec(l)) ? new vc(Z[1], Z[2], Z[3], 1) : (Z = dQ.exec(l)) ? new vc(Z[1] * 255 / 100, Z[2] * 255 / 100, Z[3] * 255 / 100, 1) : (Z = GQ.exec(l)) ? PL(Z[1], Z[2], Z[3], Z[4]) : (Z = mQ.exec(l)) ? PL(Z[1] * 255 / 100, Z[2] * 255 / 100, Z[3] * 255 / 100, Z[4]) : (Z = iQ.exec(l)) ? $2(Z[1], Z[2] / 100, Z[3] / 100, 1) : (Z = oQ.exec(l)) ? $2(Z[1], Z[2] / 100, Z[3] / 100, Z[4]) : D2.hasOwnProperty(l) ? P2(D2[l]) : l === "transparent" ? new vc(NaN, NaN, NaN, 0) : null;
}
function P2(l) {
  return new vc(l >> 16 & 255, l >> 8 & 255, l & 255, 1);
}
function PL(l, Z, u, s) {
  return s <= 0 && (l = Z = u = NaN), new vc(l, Z, u, s);
}
function JV(l) {
  return l instanceof hG || (l = Wm(l)), l ? (l = l.rgb(), new vc(l.r, l.g, l.b, l.opacity)) : new vc();
}
function Xh(l, Z, u, s) {
  return arguments.length === 1 ? JV(l) : new vc(l, Z, u, s ?? 1);
}
function vc(l, Z, u, s) {
  this.r = +l, this.g = +Z, this.b = +u, this.opacity = +s;
}
ko(vc, Xh, Sn(hG, {
  brighter(l) {
    return l = l == null ? no : Math.pow(no, l), new vc(this.r * l, this.g * l, this.b * l, this.opacity);
  },
  darker(l) {
    return l = l == null ? Km : Math.pow(Km, l), new vc(this.r * l, this.g * l, this.b * l, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new vc(pm(this.r), pm(this.g), pm(this.b), Kh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: O2,
  // Deprecated! Use color.formatHex.
  formatHex: O2,
  formatHex8: nQ,
  formatRgb: A2,
  toString: A2
}));
function O2() {
  return `#${dm(this.r)}${dm(this.g)}${dm(this.b)}`;
}
function nQ() {
  return `#${dm(this.r)}${dm(this.g)}${dm(this.b)}${dm((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function A2() {
  const l = Kh(this.opacity);
  return `${l === 1 ? "rgb(" : "rgba("}${pm(this.r)}, ${pm(this.g)}, ${pm(this.b)}${l === 1 ? ")" : `, ${l})`}`;
}
function Kh(l) {
  return isNaN(l) ? 1 : Math.max(0, Math.min(1, l));
}
function pm(l) {
  return Math.max(0, Math.min(255, Math.round(l) || 0));
}
function dm(l) {
  return l = pm(l), (l < 16 ? "0" : "") + l.toString(16);
}
function $2(l, Z, u, s) {
  return s <= 0 ? l = Z = u = NaN : u <= 0 || u >= 1 ? l = Z = NaN : Z <= 0 && (l = NaN), new fu(l, Z, u, s);
}
function RU(l) {
  if (l instanceof fu) return new fu(l.h, l.s, l.l, l.opacity);
  if (l instanceof hG || (l = Wm(l)), !l) return new fu();
  if (l instanceof fu) return l;
  l = l.rgb();
  var Z = l.r / 255, u = l.g / 255, s = l.b / 255, G = Math.min(Z, u, s), i = Math.max(Z, u, s), m = NaN, a = i - G, n = (i + G) / 2;
  return a ? (Z === i ? m = (u - s) / a + (u < s) * 6 : u === i ? m = (s - Z) / a + 2 : m = (Z - u) / a + 4, a /= n < 0.5 ? i + G : 2 - i - G, m *= 60) : a = n > 0 && n < 1 ? 0 : m, new fu(m, a, n, l.opacity);
}
function CW(l, Z, u, s) {
  return arguments.length === 1 ? RU(l) : new fu(l, Z, u, s ?? 1);
}
function fu(l, Z, u, s) {
  this.h = +l, this.s = +Z, this.l = +u, this.opacity = +s;
}
ko(fu, CW, Sn(hG, {
  brighter(l) {
    return l = l == null ? no : Math.pow(no, l), new fu(this.h, this.s, this.l * l, this.opacity);
  },
  darker(l) {
    return l = l == null ? Km : Math.pow(Km, l), new fu(this.h, this.s, this.l * l, this.opacity);
  },
  rgb() {
    var l = this.h % 360 + (this.h < 0) * 360, Z = isNaN(l) || isNaN(this.s) ? 0 : this.s, u = this.l, s = u + (u < 0.5 ? u : 1 - u) * Z, G = 2 * u - s;
    return new vc(
      vK(l >= 240 ? l - 240 : l + 120, G, s),
      vK(l, G, s),
      vK(l < 120 ? l + 240 : l - 120, G, s),
      this.opacity
    );
  },
  clamp() {
    return new fu(q2(this.h), OL(this.s), OL(this.l), Kh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const l = Kh(this.opacity);
    return `${l === 1 ? "hsl(" : "hsla("}${q2(this.h)}, ${OL(this.s) * 100}%, ${OL(this.l) * 100}%${l === 1 ? ")" : `, ${l})`}`;
  }
}));
function q2(l) {
  return l = (l || 0) % 360, l < 0 ? l + 360 : l;
}
function OL(l) {
  return Math.max(0, Math.min(1, l || 0));
}
function vK(l, Z, u) {
  return (l < 60 ? Z + (u - Z) * l / 60 : l < 180 ? u : l < 240 ? Z + (u - Z) * (240 - l) / 60 : Z) * 255;
}
const YU = Math.PI / 180, kU = 180 / Math.PI, Wh = 18, MU = 0.96422, IU = 1, UU = 0.82521, CU = 4 / 29, Oi = 6 / 29, rU = 3 * Oi * Oi, pQ = Oi * Oi * Oi;
function FU(l) {
  if (l instanceof Ss) return new Ss(l.l, l.a, l.b, l.opacity);
  if (l instanceof dd) return NU(l);
  l instanceof vc || (l = JV(l));
  var Z = BK(l.r), u = BK(l.g), s = BK(l.b), G = TK((0.2225045 * Z + 0.7168786 * u + 0.0606169 * s) / IU), i, m;
  return Z === u && u === s ? i = m = G : (i = TK((0.4360747 * Z + 0.3850649 * u + 0.1430804 * s) / MU), m = TK((0.0139322 * Z + 0.0971045 * u + 0.7141733 * s) / UU)), new Ss(116 * G - 16, 500 * (i - G), 200 * (G - m), l.opacity);
}
function rW(l, Z, u, s) {
  return arguments.length === 1 ? FU(l) : new Ss(l, Z, u, s ?? 1);
}
function Ss(l, Z, u, s) {
  this.l = +l, this.a = +Z, this.b = +u, this.opacity = +s;
}
ko(Ss, rW, Sn(hG, {
  brighter(l) {
    return new Ss(this.l + Wh * (l ?? 1), this.a, this.b, this.opacity);
  },
  darker(l) {
    return new Ss(this.l - Wh * (l ?? 1), this.a, this.b, this.opacity);
  },
  rgb() {
    var l = (this.l + 16) / 116, Z = isNaN(this.a) ? l : l + this.a / 500, u = isNaN(this.b) ? l : l - this.b / 200;
    return Z = MU * fK(Z), l = IU * fK(l), u = UU * fK(u), new vc(
      EK(3.1338561 * Z - 1.6168667 * l - 0.4906146 * u),
      EK(-0.9787684 * Z + 1.9161415 * l + 0.033454 * u),
      EK(0.0719453 * Z - 0.2289914 * l + 1.4052427 * u),
      this.opacity
    );
  }
}));
function TK(l) {
  return l > pQ ? Math.pow(l, 1 / 3) : l / rU + CU;
}
function fK(l) {
  return l > Oi ? l * l * l : rU * (l - CU);
}
function EK(l) {
  return 255 * (l <= 31308e-7 ? 12.92 * l : 1.055 * Math.pow(l, 1 / 2.4) - 0.055);
}
function BK(l) {
  return (l /= 255) <= 0.04045 ? l / 12.92 : Math.pow((l + 0.055) / 1.055, 2.4);
}
function LQ(l) {
  if (l instanceof dd) return new dd(l.h, l.c, l.l, l.opacity);
  if (l instanceof Ss || (l = FU(l)), l.a === 0 && l.b === 0) return new dd(NaN, 0 < l.l && l.l < 100 ? 0 : NaN, l.l, l.opacity);
  var Z = Math.atan2(l.b, l.a) * kU;
  return new dd(Z < 0 ? Z + 360 : Z, Math.sqrt(l.a * l.a + l.b * l.b), l.l, l.opacity);
}
function FW(l, Z, u, s) {
  return arguments.length === 1 ? LQ(l) : new dd(l, Z, u, s ?? 1);
}
function dd(l, Z, u, s) {
  this.h = +l, this.c = +Z, this.l = +u, this.opacity = +s;
}
function NU(l) {
  if (isNaN(l.h)) return new Ss(l.l, 0, 0, l.opacity);
  var Z = l.h * YU;
  return new Ss(l.l, Math.cos(Z) * l.c, Math.sin(Z) * l.c, l.opacity);
}
ko(dd, FW, Sn(hG, {
  brighter(l) {
    return new dd(this.h, this.c, this.l + Wh * (l ?? 1), this.opacity);
  },
  darker(l) {
    return new dd(this.h, this.c, this.l - Wh * (l ?? 1), this.opacity);
  },
  rgb() {
    return NU(this).rgb();
  }
}));
var wU = -0.14861, HV = 1.78277, gV = -0.29227, jh = -0.90649, Qa = 1.97294, _2 = Qa * jh, lM = Qa * HV, ZM = HV * gV - jh * wU;
function hQ(l) {
  if (l instanceof Lm) return new Lm(l.h, l.s, l.l, l.opacity);
  l instanceof vc || (l = JV(l));
  var Z = l.r / 255, u = l.g / 255, s = l.b / 255, G = (ZM * s + _2 * Z - lM * u) / (ZM + _2 - lM), i = s - G, m = (Qa * (u - G) - gV * i) / jh, a = Math.sqrt(m * m + i * i) / (Qa * G * (1 - G)), n = a ? Math.atan2(m, i) * kU - 120 : NaN;
  return new Lm(n < 0 ? n + 360 : n, a, G, l.opacity);
}
function NW(l, Z, u, s) {
  return arguments.length === 1 ? hQ(l) : new Lm(l, Z, u, s ?? 1);
}
function Lm(l, Z, u, s) {
  this.h = +l, this.s = +Z, this.l = +u, this.opacity = +s;
}
ko(Lm, NW, Sn(hG, {
  brighter(l) {
    return l = l == null ? no : Math.pow(no, l), new Lm(this.h, this.s, this.l * l, this.opacity);
  },
  darker(l) {
    return l = l == null ? Km : Math.pow(Km, l), new Lm(this.h, this.s, this.l * l, this.opacity);
  },
  rgb() {
    var l = isNaN(this.h) ? 0 : (this.h + 120) * YU, Z = +this.l, u = isNaN(this.s) ? 0 : this.s * Z * (1 - Z), s = Math.cos(l), G = Math.sin(l);
    return new vc(
      255 * (Z + u * (wU * s + HV * G)),
      255 * (Z + u * (gV * s + jh * G)),
      255 * (Z + u * (Qa * s)),
      this.opacity
    );
  }
}));
function zU(l, Z, u, s, G) {
  var i = l * l, m = i * l;
  return ((1 - 3 * l + 3 * i - m) * Z + (4 - 6 * i + 3 * m) * u + (1 + 3 * l + 3 * i - 3 * m) * s + m * G) / 6;
}
function JU(l) {
  var Z = l.length - 1;
  return function(u) {
    var s = u <= 0 ? u = 0 : u >= 1 ? (u = 1, Z - 1) : Math.floor(u * Z), G = l[s], i = l[s + 1], m = s > 0 ? l[s - 1] : 2 * G - i, a = s < Z - 1 ? l[s + 2] : 2 * i - G;
    return zU((u - s / Z) * Z, m, G, i, a);
  };
}
function HU(l) {
  var Z = l.length;
  return function(u) {
    var s = Math.floor(((u %= 1) < 0 ? ++u : u) * Z), G = l[(s + Z - 1) % Z], i = l[s % Z], m = l[(s + 1) % Z], a = l[(s + 2) % Z];
    return zU((u - s / Z) * Z, G, i, m, a);
  };
}
const Qh = (l) => () => l;
function gU(l, Z) {
  return function(u) {
    return l + u * Z;
  };
}
function yQ(l, Z, u) {
  return l = Math.pow(l, u), Z = Math.pow(Z, u) - l, u = 1 / u, function(s) {
    return Math.pow(l + s * Z, u);
  };
}
function Ph(l, Z) {
  var u = Z - l;
  return u ? gU(l, u > 180 || u < -180 ? u - 360 * Math.round(u / 360) : u) : Qh(isNaN(l) ? Z : l);
}
function SQ(l) {
  return (l = +l) == 1 ? Tc : function(Z, u) {
    return u - Z ? yQ(Z, u, l) : Qh(isNaN(Z) ? u : Z);
  };
}
function Tc(l, Z) {
  var u = Z - l;
  return u ? gU(l, u) : Qh(isNaN(l) ? Z : l);
}
const Pa = function l(Z) {
  var u = SQ(Z);
  function s(G, i) {
    var m = u((G = Xh(G)).r, (i = Xh(i)).r), a = u(G.g, i.g), n = u(G.b, i.b), p = Tc(G.opacity, i.opacity);
    return function(y) {
      return G.r = m(y), G.g = a(y), G.b = n(y), G.opacity = p(y), G + "";
    };
  }
  return s.gamma = l, s;
}(1);
function vU(l) {
  return function(Z) {
    var u = Z.length, s = new Array(u), G = new Array(u), i = new Array(u), m, a;
    for (m = 0; m < u; ++m)
      a = Xh(Z[m]), s[m] = a.r || 0, G[m] = a.g || 0, i[m] = a.b || 0;
    return s = l(s), G = l(G), i = l(i), a.opacity = 1, function(n) {
      return a.r = s(n), a.g = G(n), a.b = i(n), a + "";
    };
  };
}
var tQ = vU(JU), XQ = vU(HU);
function vV(l, Z) {
  Z || (Z = []);
  var u = l ? Math.min(Z.length, l.length) : 0, s = Z.slice(), G;
  return function(i) {
    for (G = 0; G < u; ++G) s[G] = l[G] * (1 - i) + Z[G] * i;
    return s;
  };
}
function TU(l) {
  return ArrayBuffer.isView(l) && !(l instanceof DataView);
}
function KQ(l, Z) {
  return (TU(Z) ? vV : fU)(l, Z);
}
function fU(l, Z) {
  var u = Z ? Z.length : 0, s = l ? Math.min(u, l.length) : 0, G = new Array(s), i = new Array(u), m;
  for (m = 0; m < s; ++m) G[m] = Cm(l[m], Z[m]);
  for (; m < u; ++m) i[m] = Z[m];
  return function(a) {
    for (m = 0; m < s; ++m) i[m] = G[m](a);
    return i;
  };
}
function EU(l, Z) {
  var u = /* @__PURE__ */ new Date();
  return l = +l, Z = +Z, function(s) {
    return u.setTime(l * (1 - s) + Z * s), u;
  };
}
function hu(l, Z) {
  return l = +l, Z = +Z, function(u) {
    return l * (1 - u) + Z * u;
  };
}
function BU(l, Z) {
  var u = {}, s = {}, G;
  (l === null || typeof l != "object") && (l = {}), (Z === null || typeof Z != "object") && (Z = {});
  for (G in Z)
    G in l ? u[G] = Cm(l[G], Z[G]) : s[G] = Z[G];
  return function(i) {
    for (G in u) s[G] = u[G](i);
    return s;
  };
}
var wW = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, DK = new RegExp(wW.source, "g");
function WQ(l) {
  return function() {
    return l;
  };
}
function VQ(l) {
  return function(Z) {
    return l(Z) + "";
  };
}
function TV(l, Z) {
  var u = wW.lastIndex = DK.lastIndex = 0, s, G, i, m = -1, a = [], n = [];
  for (l = l + "", Z = Z + ""; (s = wW.exec(l)) && (G = DK.exec(Z)); )
    (i = G.index) > u && (i = Z.slice(u, i), a[m] ? a[m] += i : a[++m] = i), (s = s[0]) === (G = G[0]) ? a[m] ? a[m] += G : a[++m] = G : (a[++m] = null, n.push({ i: m, x: hu(s, G) })), u = DK.lastIndex;
  return u < Z.length && (i = Z.slice(u), a[m] ? a[m] += i : a[++m] = i), a.length < 2 ? n[0] ? VQ(n[0].x) : WQ(Z) : (Z = n.length, function(p) {
    for (var y = 0, h; y < Z; ++y) a[(h = n[y]).i] = h.x(p);
    return a.join("");
  });
}
function Cm(l, Z) {
  var u = typeof Z, s;
  return Z == null || u === "boolean" ? Qh(Z) : (u === "number" ? hu : u === "string" ? (s = Wm(Z)) ? (Z = s, Pa) : TV : Z instanceof Wm ? Pa : Z instanceof Date ? EU : TU(Z) ? vV : Array.isArray(Z) ? fU : typeof Z.valueOf != "function" && typeof Z.toString != "function" || isNaN(Z) ? BU : hu)(l, Z);
}
function xQ(l) {
  var Z = l.length;
  return function(u) {
    return l[Math.max(0, Math.min(Z - 1, Math.floor(u * Z)))];
  };
}
function RQ(l, Z) {
  var u = Ph(+l, +Z);
  return function(s) {
    var G = u(s);
    return G - 360 * Math.floor(G / 360);
  };
}
function Oh(l, Z) {
  return l = +l, Z = +Z, function(u) {
    return Math.round(l * (1 - u) + Z * u);
  };
}
var cM = 180 / Math.PI, zW = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function DU(l, Z, u, s, G, i) {
  var m, a, n;
  return (m = Math.sqrt(l * l + Z * Z)) && (l /= m, Z /= m), (n = l * u + Z * s) && (u -= l * n, s -= Z * n), (a = Math.sqrt(u * u + s * s)) && (u /= a, s /= a, n /= a), l * s < Z * u && (l = -l, Z = -Z, n = -n, m = -m), {
    translateX: G,
    translateY: i,
    rotate: Math.atan2(Z, l) * cM,
    skewX: Math.atan(n) * cM,
    scaleX: m,
    scaleY: a
  };
}
var AL;
function YQ(l) {
  const Z = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(l + "");
  return Z.isIdentity ? zW : DU(Z.a, Z.b, Z.c, Z.d, Z.e, Z.f);
}
function kQ(l) {
  return l == null || (AL || (AL = document.createElementNS("http://www.w3.org/2000/svg", "g")), AL.setAttribute("transform", l), !(l = AL.transform.baseVal.consolidate())) ? zW : (l = l.matrix, DU(l.a, l.b, l.c, l.d, l.e, l.f));
}
function jU(l, Z, u, s) {
  function G(p) {
    return p.length ? p.pop() + " " : "";
  }
  function i(p, y, h, S, t, W) {
    if (p !== h || y !== S) {
      var V = t.push("translate(", null, Z, null, u);
      W.push({ i: V - 4, x: hu(p, h) }, { i: V - 2, x: hu(y, S) });
    } else (h || S) && t.push("translate(" + h + Z + S + u);
  }
  function m(p, y, h, S) {
    p !== y ? (p - y > 180 ? y += 360 : y - p > 180 && (p += 360), S.push({ i: h.push(G(h) + "rotate(", null, s) - 2, x: hu(p, y) })) : y && h.push(G(h) + "rotate(" + y + s);
  }
  function a(p, y, h, S) {
    p !== y ? S.push({ i: h.push(G(h) + "skewX(", null, s) - 2, x: hu(p, y) }) : y && h.push(G(h) + "skewX(" + y + s);
  }
  function n(p, y, h, S, t, W) {
    if (p !== h || y !== S) {
      var V = t.push(G(t) + "scale(", null, ",", null, ")");
      W.push({ i: V - 4, x: hu(p, h) }, { i: V - 2, x: hu(y, S) });
    } else (h !== 1 || S !== 1) && t.push(G(t) + "scale(" + h + "," + S + ")");
  }
  return function(p, y) {
    var h = [], S = [];
    return p = l(p), y = l(y), i(p.translateX, p.translateY, y.translateX, y.translateY, h, S), m(p.rotate, y.rotate, h, S), a(p.skewX, y.skewX, h, S), n(p.scaleX, p.scaleY, y.scaleX, y.scaleY, h, S), p = y = null, function(t) {
      for (var W = -1, V = S.length, R; ++W < V; ) h[(R = S[W]).i] = R.x(t);
      return h.join("");
    };
  };
}
var QU = jU(YQ, "px, ", "px)", "deg)"), PU = jU(kQ, ", ", ")", ")"), MQ = 1e-12;
function bM(l) {
  return ((l = Math.exp(l)) + 1 / l) / 2;
}
function IQ(l) {
  return ((l = Math.exp(l)) - 1 / l) / 2;
}
function UQ(l) {
  return ((l = Math.exp(2 * l)) - 1) / (l + 1);
}
const OU = function l(Z, u, s) {
  function G(i, m) {
    var a = i[0], n = i[1], p = i[2], y = m[0], h = m[1], S = m[2], t = y - a, W = h - n, V = t * t + W * W, R, x;
    if (V < MQ)
      x = Math.log(S / p) / Z, R = function(D) {
        return [
          a + D * t,
          n + D * W,
          p * Math.exp(Z * D * x)
        ];
      };
    else {
      var r = Math.sqrt(V), k = (S * S - p * p + s * V) / (2 * p * u * r), U = (S * S - p * p - s * V) / (2 * S * u * r), w = Math.log(Math.sqrt(k * k + 1) - k), z = Math.log(Math.sqrt(U * U + 1) - U);
      x = (z - w) / Z, R = function(D) {
        var C = D * x, j = bM(w), E = p / (u * r) * (j * UQ(Z * C + w) - IQ(w));
        return [
          a + E * t,
          n + E * W,
          p * j / bM(Z * C + w)
        ];
      };
    }
    return R.duration = x * 1e3 * Z / Math.SQRT2, R;
  }
  return G.rho = function(i) {
    var m = Math.max(1e-3, +i), a = m * m, n = a * a;
    return l(m, a, n);
  }, G;
}(Math.SQRT2, 2, 4);
function AU(l) {
  return function(Z, u) {
    var s = l((Z = CW(Z)).h, (u = CW(u)).h), G = Tc(Z.s, u.s), i = Tc(Z.l, u.l), m = Tc(Z.opacity, u.opacity);
    return function(a) {
      return Z.h = s(a), Z.s = G(a), Z.l = i(a), Z.opacity = m(a), Z + "";
    };
  };
}
const CQ = AU(Ph);
var rQ = AU(Tc);
function FQ(l, Z) {
  var u = Tc((l = rW(l)).l, (Z = rW(Z)).l), s = Tc(l.a, Z.a), G = Tc(l.b, Z.b), i = Tc(l.opacity, Z.opacity);
  return function(m) {
    return l.l = u(m), l.a = s(m), l.b = G(m), l.opacity = i(m), l + "";
  };
}
function $U(l) {
  return function(Z, u) {
    var s = l((Z = FW(Z)).h, (u = FW(u)).h), G = Tc(Z.c, u.c), i = Tc(Z.l, u.l), m = Tc(Z.opacity, u.opacity);
    return function(a) {
      return Z.h = s(a), Z.c = G(a), Z.l = i(a), Z.opacity = m(a), Z + "";
    };
  };
}
const NQ = $U(Ph);
var wQ = $U(Tc);
function qU(l) {
  return function Z(u) {
    u = +u;
    function s(G, i) {
      var m = l((G = NW(G)).h, (i = NW(i)).h), a = Tc(G.s, i.s), n = Tc(G.l, i.l), p = Tc(G.opacity, i.opacity);
      return function(y) {
        return G.h = m(y), G.s = a(y), G.l = n(Math.pow(y, u)), G.opacity = p(y), G + "";
      };
    }
    return s.gamma = Z, s;
  }(1);
}
const zQ = qU(Ph);
var JQ = qU(Tc);
function fV(l, Z) {
  Z === void 0 && (Z = l, l = Cm);
  for (var u = 0, s = Z.length - 1, G = Z[0], i = new Array(s < 0 ? 0 : s); u < s; ) i[u] = l(G, G = Z[++u]);
  return function(m) {
    var a = Math.max(0, Math.min(s - 1, Math.floor(m *= s)));
    return i[a](m - a);
  };
}
function HQ(l, Z) {
  for (var u = new Array(Z), s = 0; s < Z; ++s) u[s] = l(s / (Z - 1));
  return u;
}
const gQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: Cm,
  interpolateArray: KQ,
  interpolateBasis: JU,
  interpolateBasisClosed: HU,
  interpolateCubehelix: zQ,
  interpolateCubehelixLong: JQ,
  interpolateDate: EU,
  interpolateDiscrete: xQ,
  interpolateHcl: NQ,
  interpolateHclLong: wQ,
  interpolateHsl: CQ,
  interpolateHslLong: rQ,
  interpolateHue: RQ,
  interpolateLab: FQ,
  interpolateNumber: hu,
  interpolateNumberArray: vV,
  interpolateObject: BU,
  interpolateRgb: Pa,
  interpolateRgbBasis: tQ,
  interpolateRgbBasisClosed: XQ,
  interpolateRound: Oh,
  interpolateString: TV,
  interpolateTransformCss: QU,
  interpolateTransformSvg: PU,
  interpolateZoom: OU,
  piecewise: fV,
  quantize: HQ
}, Symbol.toStringTag, { value: "Module" }));
var po = 0, Ua = 0, Ka = 0, _U = 1e3, Vh, Ca, xh = 0, Vm = 0, Ah = 0, Oa = typeof performance == "object" && performance.now ? performance : Date, lC = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(l) {
  setTimeout(l, 17);
};
function EV() {
  return Vm || (lC(vQ), Vm = Oa.now() + Ah);
}
function vQ() {
  Vm = 0;
}
function Rh() {
  this._call = this._time = this._next = null;
}
Rh.prototype = ZC.prototype = {
  constructor: Rh,
  restart: function(l, Z, u) {
    if (typeof l != "function") throw new TypeError("callback is not a function");
    u = (u == null ? EV() : +u) + (Z == null ? 0 : +Z), !this._next && Ca !== this && (Ca ? Ca._next = this : Vh = this, Ca = this), this._call = l, this._time = u, JW();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, JW());
  }
};
function ZC(l, Z, u) {
  var s = new Rh();
  return s.restart(l, Z, u), s;
}
function TQ() {
  EV(), ++po;
  for (var l = Vh, Z; l; )
    (Z = Vm - l._time) >= 0 && l._call.call(void 0, Z), l = l._next;
  --po;
}
function uM() {
  Vm = (xh = Oa.now()) + Ah, po = Ua = 0;
  try {
    TQ();
  } finally {
    po = 0, EQ(), Vm = 0;
  }
}
function fQ() {
  var l = Oa.now(), Z = l - xh;
  Z > _U && (Ah -= Z, xh = l);
}
function EQ() {
  for (var l, Z = Vh, u, s = 1 / 0; Z; )
    Z._call ? (s > Z._time && (s = Z._time), l = Z, Z = Z._next) : (u = Z._next, Z._next = null, Z = l ? l._next = u : Vh = u);
  Ca = l, JW(s);
}
function JW(l) {
  if (!po) {
    Ua && (Ua = clearTimeout(Ua));
    var Z = l - Vm;
    Z > 24 ? (l < 1 / 0 && (Ua = setTimeout(uM, l - Oa.now() - Ah)), Ka && (Ka = clearInterval(Ka))) : (Ka || (xh = Oa.now(), Ka = setInterval(fQ, _U)), po = 1, lC(uM));
  }
}
function sM(l, Z, u) {
  var s = new Rh();
  return Z = Z == null ? 0 : +Z, s.restart((G) => {
    s.stop(), l(G + Z);
  }, Z, u), s;
}
var BQ = Bh("start", "end", "cancel", "interrupt"), DQ = [], cC = 0, dM = 1, HW = 2, Gh = 3, GM = 4, gW = 5, mh = 6;
function $h(l, Z, u, s, G, i) {
  var m = l.__transition;
  if (!m) l.__transition = {};
  else if (u in m) return;
  jQ(l, u, {
    name: Z,
    index: s,
    // For context during callback.
    group: G,
    // For context during callback.
    on: BQ,
    tween: DQ,
    time: i.time,
    delay: i.delay,
    duration: i.duration,
    ease: i.ease,
    timer: null,
    state: cC
  });
}
function BV(l, Z) {
  var u = Du(l, Z);
  if (u.state > cC) throw new Error("too late; already scheduled");
  return u;
}
function Ws(l, Z) {
  var u = Du(l, Z);
  if (u.state > Gh) throw new Error("too late; already running");
  return u;
}
function Du(l, Z) {
  var u = l.__transition;
  if (!u || !(u = u[Z])) throw new Error("transition not found");
  return u;
}
function jQ(l, Z, u) {
  var s = l.__transition, G;
  s[Z] = u, u.timer = ZC(i, 0, u.time);
  function i(p) {
    u.state = dM, u.timer.restart(m, u.delay, u.time), u.delay <= p && m(p - u.delay);
  }
  function m(p) {
    var y, h, S, t;
    if (u.state !== dM) return n();
    for (y in s)
      if (t = s[y], t.name === u.name) {
        if (t.state === Gh) return sM(m);
        t.state === GM ? (t.state = mh, t.timer.stop(), t.on.call("interrupt", l, l.__data__, t.index, t.group), delete s[y]) : +y < Z && (t.state = mh, t.timer.stop(), t.on.call("cancel", l, l.__data__, t.index, t.group), delete s[y]);
      }
    if (sM(function() {
      u.state === Gh && (u.state = GM, u.timer.restart(a, u.delay, u.time), a(p));
    }), u.state = HW, u.on.call("start", l, l.__data__, u.index, u.group), u.state === HW) {
      for (u.state = Gh, G = new Array(S = u.tween.length), y = 0, h = -1; y < S; ++y)
        (t = u.tween[y].value.call(l, l.__data__, u.index, u.group)) && (G[++h] = t);
      G.length = h + 1;
    }
  }
  function a(p) {
    for (var y = p < u.duration ? u.ease.call(null, p / u.duration) : (u.timer.restart(n), u.state = gW, 1), h = -1, S = G.length; ++h < S; )
      G[h].call(l, y);
    u.state === gW && (u.on.call("end", l, l.__data__, u.index, u.group), n());
  }
  function n() {
    u.state = mh, u.timer.stop(), delete s[Z];
    for (var p in s) return;
    delete l.__transition;
  }
}
function ih(l, Z) {
  var u = l.__transition, s, G, i = !0, m;
  if (u) {
    Z = Z == null ? null : Z + "";
    for (m in u) {
      if ((s = u[m]).name !== Z) {
        i = !1;
        continue;
      }
      G = s.state > HW && s.state < gW, s.state = mh, s.timer.stop(), s.on.call(G ? "interrupt" : "cancel", l, l.__data__, s.index, s.group), delete u[m];
    }
    i && delete l.__transition;
  }
}
function QQ(l) {
  return this.each(function() {
    ih(this, l);
  });
}
function PQ(l, Z) {
  var u, s;
  return function() {
    var G = Ws(this, l), i = G.tween;
    if (i !== u) {
      s = u = i;
      for (var m = 0, a = s.length; m < a; ++m)
        if (s[m].name === Z) {
          s = s.slice(), s.splice(m, 1);
          break;
        }
    }
    G.tween = s;
  };
}
function OQ(l, Z, u) {
  var s, G;
  if (typeof u != "function") throw new Error();
  return function() {
    var i = Ws(this, l), m = i.tween;
    if (m !== s) {
      G = (s = m).slice();
      for (var a = { name: Z, value: u }, n = 0, p = G.length; n < p; ++n)
        if (G[n].name === Z) {
          G[n] = a;
          break;
        }
      n === p && G.push(a);
    }
    i.tween = G;
  };
}
function AQ(l, Z) {
  var u = this._id;
  if (l += "", arguments.length < 2) {
    for (var s = Du(this.node(), u).tween, G = 0, i = s.length, m; G < i; ++G)
      if ((m = s[G]).name === l)
        return m.value;
    return null;
  }
  return this.each((Z == null ? PQ : OQ)(u, l, Z));
}
function DV(l, Z, u) {
  var s = l._id;
  return l.each(function() {
    var G = Ws(this, s);
    (G.value || (G.value = {}))[Z] = u.apply(this, arguments);
  }), function(G) {
    return Du(G, s).value[Z];
  };
}
function bC(l, Z) {
  var u;
  return (typeof Z == "number" ? hu : Z instanceof Wm ? Pa : (u = Wm(Z)) ? (Z = u, Pa) : TV)(l, Z);
}
function $Q(l) {
  return function() {
    this.removeAttribute(l);
  };
}
function qQ(l) {
  return function() {
    this.removeAttributeNS(l.space, l.local);
  };
}
function _Q(l, Z, u) {
  var s, G = u + "", i;
  return function() {
    var m = this.getAttribute(l);
    return m === G ? null : m === s ? i : i = Z(s = m, u);
  };
}
function lP(l, Z, u) {
  var s, G = u + "", i;
  return function() {
    var m = this.getAttributeNS(l.space, l.local);
    return m === G ? null : m === s ? i : i = Z(s = m, u);
  };
}
function ZP(l, Z, u) {
  var s, G, i;
  return function() {
    var m, a = u(this), n;
    return a == null ? void this.removeAttribute(l) : (m = this.getAttribute(l), n = a + "", m === n ? null : m === s && n === G ? i : (G = n, i = Z(s = m, a)));
  };
}
function cP(l, Z, u) {
  var s, G, i;
  return function() {
    var m, a = u(this), n;
    return a == null ? void this.removeAttributeNS(l.space, l.local) : (m = this.getAttributeNS(l.space, l.local), n = a + "", m === n ? null : m === s && n === G ? i : (G = n, i = Z(s = m, a)));
  };
}
function bP(l, Z) {
  var u = Dh(l), s = u === "transform" ? PU : bC;
  return this.attrTween(l, typeof Z == "function" ? (u.local ? cP : ZP)(u, s, DV(this, "attr." + l, Z)) : Z == null ? (u.local ? qQ : $Q)(u) : (u.local ? lP : _Q)(u, s, Z));
}
function uP(l, Z) {
  return function(u) {
    this.setAttribute(l, Z.call(this, u));
  };
}
function sP(l, Z) {
  return function(u) {
    this.setAttributeNS(l.space, l.local, Z.call(this, u));
  };
}
function dP(l, Z) {
  var u, s;
  function G() {
    var i = Z.apply(this, arguments);
    return i !== s && (u = (s = i) && sP(l, i)), u;
  }
  return G._value = Z, G;
}
function GP(l, Z) {
  var u, s;
  function G() {
    var i = Z.apply(this, arguments);
    return i !== s && (u = (s = i) && uP(l, i)), u;
  }
  return G._value = Z, G;
}
function mP(l, Z) {
  var u = "attr." + l;
  if (arguments.length < 2) return (u = this.tween(u)) && u._value;
  if (Z == null) return this.tween(u, null);
  if (typeof Z != "function") throw new Error();
  var s = Dh(l);
  return this.tween(u, (s.local ? dP : GP)(s, Z));
}
function iP(l, Z) {
  return function() {
    BV(this, l).delay = +Z.apply(this, arguments);
  };
}
function oP(l, Z) {
  return Z = +Z, function() {
    BV(this, l).delay = Z;
  };
}
function eP(l) {
  var Z = this._id;
  return arguments.length ? this.each((typeof l == "function" ? iP : oP)(Z, l)) : Du(this.node(), Z).delay;
}
function aP(l, Z) {
  return function() {
    Ws(this, l).duration = +Z.apply(this, arguments);
  };
}
function nP(l, Z) {
  return Z = +Z, function() {
    Ws(this, l).duration = Z;
  };
}
function pP(l) {
  var Z = this._id;
  return arguments.length ? this.each((typeof l == "function" ? aP : nP)(Z, l)) : Du(this.node(), Z).duration;
}
function LP(l, Z) {
  if (typeof Z != "function") throw new Error();
  return function() {
    Ws(this, l).ease = Z;
  };
}
function hP(l) {
  var Z = this._id;
  return arguments.length ? this.each(LP(Z, l)) : Du(this.node(), Z).ease;
}
function yP(l, Z) {
  return function() {
    var u = Z.apply(this, arguments);
    if (typeof u != "function") throw new Error();
    Ws(this, l).ease = u;
  };
}
function SP(l) {
  if (typeof l != "function") throw new Error();
  return this.each(yP(this._id, l));
}
function tP(l) {
  typeof l != "function" && (l = aU(l));
  for (var Z = this._groups, u = Z.length, s = new Array(u), G = 0; G < u; ++G)
    for (var i = Z[G], m = i.length, a = s[G] = [], n, p = 0; p < m; ++p)
      (n = i[p]) && l.call(n, n.__data__, p, i) && a.push(n);
  return new pd(s, this._parents, this._name, this._id);
}
function XP(l) {
  if (l._id !== this._id) throw new Error();
  for (var Z = this._groups, u = l._groups, s = Z.length, G = u.length, i = Math.min(s, G), m = new Array(s), a = 0; a < i; ++a)
    for (var n = Z[a], p = u[a], y = n.length, h = m[a] = new Array(y), S, t = 0; t < y; ++t)
      (S = n[t] || p[t]) && (h[t] = S);
  for (; a < s; ++a)
    m[a] = Z[a];
  return new pd(m, this._parents, this._name, this._id);
}
function KP(l) {
  return (l + "").trim().split(/^|\s+/).every(function(Z) {
    var u = Z.indexOf(".");
    return u >= 0 && (Z = Z.slice(0, u)), !Z || Z === "start";
  });
}
function WP(l, Z, u) {
  var s, G, i = KP(Z) ? BV : Ws;
  return function() {
    var m = i(this, l), a = m.on;
    a !== s && (G = (s = a).copy()).on(Z, u), m.on = G;
  };
}
function VP(l, Z) {
  var u = this._id;
  return arguments.length < 2 ? Du(this.node(), u).on.on(l) : this.each(WP(u, l, Z));
}
function xP(l) {
  return function() {
    var Z = this.parentNode;
    for (var u in this.__transition) if (+u !== l) return;
    Z && Z.removeChild(this);
  };
}
function RP() {
  return this.on("end.remove", xP(this._id));
}
function YP(l) {
  var Z = this._name, u = this._id;
  typeof l != "function" && (l = wV(l));
  for (var s = this._groups, G = s.length, i = new Array(G), m = 0; m < G; ++m)
    for (var a = s[m], n = a.length, p = i[m] = new Array(n), y, h, S = 0; S < n; ++S)
      (y = a[S]) && (h = l.call(y, y.__data__, S, a)) && ("__data__" in y && (h.__data__ = y.__data__), p[S] = h, $h(p[S], Z, u, S, p, Du(y, u)));
  return new pd(i, this._parents, Z, u);
}
function kP(l) {
  var Z = this._name, u = this._id;
  typeof l != "function" && (l = eU(l));
  for (var s = this._groups, G = s.length, i = [], m = [], a = 0; a < G; ++a)
    for (var n = s[a], p = n.length, y, h = 0; h < p; ++h)
      if (y = n[h]) {
        for (var S = l.call(y, y.__data__, h, n), t, W = Du(y, u), V = 0, R = S.length; V < R; ++V)
          (t = S[V]) && $h(t, Z, u, V, S, W);
        i.push(S), m.push(y);
      }
  return new pd(i, m, Z, u);
}
var MP = yn.prototype.constructor;
function IP() {
  return new MP(this._groups, this._parents);
}
function UP(l, Z) {
  var u, s, G;
  return function() {
    var i = ao(this, l), m = (this.style.removeProperty(l), ao(this, l));
    return i === m ? null : i === u && m === s ? G : G = Z(u = i, s = m);
  };
}
function uC(l) {
  return function() {
    this.style.removeProperty(l);
  };
}
function CP(l, Z, u) {
  var s, G = u + "", i;
  return function() {
    var m = ao(this, l);
    return m === G ? null : m === s ? i : i = Z(s = m, u);
  };
}
function rP(l, Z, u) {
  var s, G, i;
  return function() {
    var m = ao(this, l), a = u(this), n = a + "";
    return a == null && (n = a = (this.style.removeProperty(l), ao(this, l))), m === n ? null : m === s && n === G ? i : (G = n, i = Z(s = m, a));
  };
}
function FP(l, Z) {
  var u, s, G, i = "style." + Z, m = "end." + i, a;
  return function() {
    var n = Ws(this, l), p = n.on, y = n.value[i] == null ? a || (a = uC(Z)) : void 0;
    (p !== u || G !== y) && (s = (u = p).copy()).on(m, G = y), n.on = s;
  };
}
function NP(l, Z, u) {
  var s = (l += "") == "transform" ? QU : bC;
  return Z == null ? this.styleTween(l, UP(l, s)).on("end.style." + l, uC(l)) : typeof Z == "function" ? this.styleTween(l, rP(l, s, DV(this, "style." + l, Z))).each(FP(this._id, l)) : this.styleTween(l, CP(l, s, Z), u).on("end.style." + l, null);
}
function wP(l, Z, u) {
  return function(s) {
    this.style.setProperty(l, Z.call(this, s), u);
  };
}
function zP(l, Z, u) {
  var s, G;
  function i() {
    var m = Z.apply(this, arguments);
    return m !== G && (s = (G = m) && wP(l, m, u)), s;
  }
  return i._value = Z, i;
}
function JP(l, Z, u) {
  var s = "style." + (l += "");
  if (arguments.length < 2) return (s = this.tween(s)) && s._value;
  if (Z == null) return this.tween(s, null);
  if (typeof Z != "function") throw new Error();
  return this.tween(s, zP(l, Z, u ?? ""));
}
function HP(l) {
  return function() {
    this.textContent = l;
  };
}
function gP(l) {
  return function() {
    var Z = l(this);
    this.textContent = Z ?? "";
  };
}
function vP(l) {
  return this.tween("text", typeof l == "function" ? gP(DV(this, "text", l)) : HP(l == null ? "" : l + ""));
}
function TP(l) {
  return function(Z) {
    this.textContent = l.call(this, Z);
  };
}
function fP(l) {
  var Z, u;
  function s() {
    var G = l.apply(this, arguments);
    return G !== u && (Z = (u = G) && TP(G)), Z;
  }
  return s._value = l, s;
}
function EP(l) {
  var Z = "text";
  if (arguments.length < 1) return (Z = this.tween(Z)) && Z._value;
  if (l == null) return this.tween(Z, null);
  if (typeof l != "function") throw new Error();
  return this.tween(Z, fP(l));
}
function BP() {
  for (var l = this._name, Z = this._id, u = sC(), s = this._groups, G = s.length, i = 0; i < G; ++i)
    for (var m = s[i], a = m.length, n, p = 0; p < a; ++p)
      if (n = m[p]) {
        var y = Du(n, Z);
        $h(n, l, u, p, m, {
          time: y.time + y.delay + y.duration,
          delay: 0,
          duration: y.duration,
          ease: y.ease
        });
      }
  return new pd(s, this._parents, l, u);
}
function DP() {
  var l, Z, u = this, s = u._id, G = u.size();
  return new Promise(function(i, m) {
    var a = { value: m }, n = { value: function() {
      --G === 0 && i();
    } };
    u.each(function() {
      var p = Ws(this, s), y = p.on;
      y !== l && (Z = (l = y).copy(), Z._.cancel.push(a), Z._.interrupt.push(a), Z._.end.push(n)), p.on = Z;
    }), G === 0 && i();
  });
}
var jP = 0;
function pd(l, Z, u, s) {
  this._groups = l, this._parents = Z, this._name = u, this._id = s;
}
function sC() {
  return ++jP;
}
var cd = yn.prototype;
pd.prototype = {
  constructor: pd,
  select: YP,
  selectAll: kP,
  selectChild: cd.selectChild,
  selectChildren: cd.selectChildren,
  filter: tP,
  merge: XP,
  selection: IP,
  transition: BP,
  call: cd.call,
  nodes: cd.nodes,
  node: cd.node,
  size: cd.size,
  empty: cd.empty,
  each: cd.each,
  on: VP,
  attr: bP,
  attrTween: mP,
  style: NP,
  styleTween: JP,
  text: vP,
  textTween: EP,
  remove: RP,
  tween: AQ,
  delay: eP,
  duration: pP,
  ease: hP,
  easeVarying: SP,
  end: DP,
  [Symbol.iterator]: cd[Symbol.iterator]
};
function QP(l) {
  return ((l *= 2) <= 1 ? l * l * l : (l -= 2) * l * l + 2) / 2;
}
var PP = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: QP
};
function OP(l, Z) {
  for (var u; !(u = l.__transition) || !(u = u[Z]); )
    if (!(l = l.parentNode))
      throw new Error(`transition ${Z} not found`);
  return u;
}
function AP(l) {
  var Z, u;
  l instanceof pd ? (Z = l._id, l = l._name) : (Z = sC(), (u = PP).time = EV(), l = l == null ? null : l + "");
  for (var s = this._groups, G = s.length, i = 0; i < G; ++i)
    for (var m = s[i], a = m.length, n, p = 0; p < a; ++p)
      (n = m[p]) && $h(n, l, Z, p, m, u || OP(n, Z));
  return new pd(s, this._parents, l, Z);
}
yn.prototype.interrupt = QQ;
yn.prototype.transition = AP;
const $L = (l) => () => l;
function $P(l, {
  sourceEvent: Z,
  target: u,
  transform: s,
  dispatch: G
}) {
  Object.defineProperties(this, {
    type: { value: l, enumerable: !0, configurable: !0 },
    sourceEvent: { value: Z, enumerable: !0, configurable: !0 },
    target: { value: u, enumerable: !0, configurable: !0 },
    transform: { value: s, enumerable: !0, configurable: !0 },
    _: { value: G }
  });
}
function Gd(l, Z, u) {
  this.k = l, this.x = Z, this.y = u;
}
Gd.prototype = {
  constructor: Gd,
  scale: function(l) {
    return l === 1 ? this : new Gd(this.k * l, this.x, this.y);
  },
  translate: function(l, Z) {
    return l === 0 & Z === 0 ? this : new Gd(this.k, this.x + this.k * l, this.y + this.k * Z);
  },
  apply: function(l) {
    return [l[0] * this.k + this.x, l[1] * this.k + this.y];
  },
  applyX: function(l) {
    return l * this.k + this.x;
  },
  applyY: function(l) {
    return l * this.k + this.y;
  },
  invert: function(l) {
    return [(l[0] - this.x) / this.k, (l[1] - this.y) / this.k];
  },
  invertX: function(l) {
    return (l - this.x) / this.k;
  },
  invertY: function(l) {
    return (l - this.y) / this.k;
  },
  rescaleX: function(l) {
    return l.copy().domain(l.range().map(this.invertX, this).map(l.invert, l));
  },
  rescaleY: function(l) {
    return l.copy().domain(l.range().map(this.invertY, this).map(l.invert, l));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var qh = new Gd(1, 0, 0);
dC.prototype = Gd.prototype;
function dC(l) {
  for (; !l.__zoom; ) if (!(l = l.parentNode)) return qh;
  return l.__zoom;
}
function jK(l) {
  l.stopImmediatePropagation();
}
function Wa(l) {
  l.preventDefault(), l.stopImmediatePropagation();
}
function qP(l) {
  return (!l.ctrlKey || l.type === "wheel") && !l.button;
}
function _P() {
  var l = this;
  return l instanceof SVGElement ? (l = l.ownerSVGElement || l, l.hasAttribute("viewBox") ? (l = l.viewBox.baseVal, [[l.x, l.y], [l.x + l.width, l.y + l.height]]) : [[0, 0], [l.width.baseVal.value, l.height.baseVal.value]]) : [[0, 0], [l.clientWidth, l.clientHeight]];
}
function mM() {
  return this.__zoom || qh;
}
function l8(l) {
  return -l.deltaY * (l.deltaMode === 1 ? 0.05 : l.deltaMode ? 1 : 2e-3) * (l.ctrlKey ? 10 : 1);
}
function Z8() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function c8(l, Z, u) {
  var s = l.invertX(Z[0][0]) - u[0][0], G = l.invertX(Z[1][0]) - u[1][0], i = l.invertY(Z[0][1]) - u[0][1], m = l.invertY(Z[1][1]) - u[1][1];
  return l.translate(
    G > s ? (s + G) / 2 : Math.min(0, s) || Math.max(0, G),
    m > i ? (i + m) / 2 : Math.min(0, i) || Math.max(0, m)
  );
}
function GC() {
  var l = qP, Z = _P, u = c8, s = l8, G = Z8, i = [0, 1 / 0], m = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, n = OU, p = Bh("start", "zoom", "end"), y, h, S, t = 500, W = 150, V = 0, R = 10;
  function x(F) {
    F.property("__zoom", mM).on("wheel.zoom", C, { passive: !1 }).on("mousedown.zoom", j).on("dblclick.zoom", E).filter(G).on("touchstart.zoom", g).on("touchmove.zoom", A).on("touchend.zoom touchcancel.zoom", J).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  x.transform = function(F, v, T, f) {
    var O = F.selection ? F.selection() : F;
    O.property("__zoom", mM), F !== O ? w(F, v, T, f) : O.interrupt().each(function() {
      z(this, arguments).event(f).start().zoom(null, typeof v == "function" ? v.apply(this, arguments) : v).end();
    });
  }, x.scaleBy = function(F, v, T, f) {
    x.scaleTo(F, function() {
      var O = this.__zoom.k, _ = typeof v == "function" ? v.apply(this, arguments) : v;
      return O * _;
    }, T, f);
  }, x.scaleTo = function(F, v, T, f) {
    x.transform(F, function() {
      var O = Z.apply(this, arguments), _ = this.__zoom, il = T == null ? U(O) : typeof T == "function" ? T.apply(this, arguments) : T, Zl = _.invert(il), ol = typeof v == "function" ? v.apply(this, arguments) : v;
      return u(k(r(_, ol), il, Zl), O, m);
    }, T, f);
  }, x.translateBy = function(F, v, T, f) {
    x.transform(F, function() {
      return u(this.__zoom.translate(
        typeof v == "function" ? v.apply(this, arguments) : v,
        typeof T == "function" ? T.apply(this, arguments) : T
      ), Z.apply(this, arguments), m);
    }, null, f);
  }, x.translateTo = function(F, v, T, f, O) {
    x.transform(F, function() {
      var _ = Z.apply(this, arguments), il = this.__zoom, Zl = f == null ? U(_) : typeof f == "function" ? f.apply(this, arguments) : f;
      return u(qh.translate(Zl[0], Zl[1]).scale(il.k).translate(
        typeof v == "function" ? -v.apply(this, arguments) : -v,
        typeof T == "function" ? -T.apply(this, arguments) : -T
      ), _, m);
    }, f, O);
  };
  function r(F, v) {
    return v = Math.max(i[0], Math.min(i[1], v)), v === F.k ? F : new Gd(v, F.x, F.y);
  }
  function k(F, v, T) {
    var f = v[0] - T[0] * F.k, O = v[1] - T[1] * F.k;
    return f === F.x && O === F.y ? F : new Gd(F.k, f, O);
  }
  function U(F) {
    return [(+F[0][0] + +F[1][0]) / 2, (+F[0][1] + +F[1][1]) / 2];
  }
  function w(F, v, T, f) {
    F.on("start.zoom", function() {
      z(this, arguments).event(f).start();
    }).on("interrupt.zoom end.zoom", function() {
      z(this, arguments).event(f).end();
    }).tween("zoom", function() {
      var O = this, _ = arguments, il = z(O, _).event(f), Zl = Z.apply(O, _), ol = T == null ? U(Zl) : typeof T == "function" ? T.apply(O, _) : T, Wl = Math.max(Zl[1][0] - Zl[0][0], Zl[1][1] - Zl[0][1]), ml = O.__zoom, Rl = typeof v == "function" ? v.apply(O, _) : v, kl = n(ml.invert(ol).concat(Wl / ml.k), Rl.invert(ol).concat(Wl / Rl.k));
      return function(zl) {
        if (zl === 1) zl = Rl;
        else {
          var Vl = kl(zl), el = Wl / Vl[2];
          zl = new Gd(el, ol[0] - Vl[0] * el, ol[1] - Vl[1] * el);
        }
        il.zoom(null, zl);
      };
    });
  }
  function z(F, v, T) {
    return !T && F.__zooming || new D(F, v);
  }
  function D(F, v) {
    this.that = F, this.args = v, this.active = 0, this.sourceEvent = null, this.extent = Z.apply(F, v), this.taps = 0;
  }
  D.prototype = {
    event: function(F) {
      return F && (this.sourceEvent = F), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(F, v) {
      return this.mouse && F !== "mouse" && (this.mouse[1] = v.invert(this.mouse[0])), this.touch0 && F !== "touch" && (this.touch0[1] = v.invert(this.touch0[0])), this.touch1 && F !== "touch" && (this.touch1[1] = v.invert(this.touch1[0])), this.that.__zoom = v, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(F) {
      var v = lu(this.that).datum();
      p.call(
        F,
        this.that,
        new $P(F, {
          sourceEvent: this.sourceEvent,
          target: x,
          type: F,
          transform: this.that.__zoom,
          dispatch: p
        }),
        v
      );
    }
  };
  function C(F, ...v) {
    if (!l.apply(this, arguments)) return;
    var T = z(this, v).event(F), f = this.__zoom, O = Math.max(i[0], Math.min(i[1], f.k * Math.pow(2, s.apply(this, arguments)))), _ = vu(F);
    if (T.wheel)
      (T.mouse[0][0] !== _[0] || T.mouse[0][1] !== _[1]) && (T.mouse[1] = f.invert(T.mouse[0] = _)), clearTimeout(T.wheel);
    else {
      if (f.k === O) return;
      T.mouse = [_, f.invert(_)], ih(this), T.start();
    }
    Wa(F), T.wheel = setTimeout(il, W), T.zoom("mouse", u(k(r(f, O), T.mouse[0], T.mouse[1]), T.extent, m));
    function il() {
      T.wheel = null, T.end();
    }
  }
  function j(F, ...v) {
    if (S || !l.apply(this, arguments)) return;
    var T = F.currentTarget, f = z(this, v, !0).event(F), O = lu(F.view).on("mousemove.zoom", ol, !0).on("mouseup.zoom", Wl, !0), _ = vu(F, T), il = F.clientX, Zl = F.clientY;
    WU(F.view), jK(F), f.mouse = [_, this.__zoom.invert(_)], ih(this), f.start();
    function ol(ml) {
      if (Wa(ml), !f.moved) {
        var Rl = ml.clientX - il, kl = ml.clientY - Zl;
        f.moved = Rl * Rl + kl * kl > V;
      }
      f.event(ml).zoom("mouse", u(k(f.that.__zoom, f.mouse[0] = vu(ml, T), f.mouse[1]), f.extent, m));
    }
    function Wl(ml) {
      O.on("mousemove.zoom mouseup.zoom", null), VU(ml.view, f.moved), Wa(ml), f.event(ml).end();
    }
  }
  function E(F, ...v) {
    if (l.apply(this, arguments)) {
      var T = this.__zoom, f = vu(F.changedTouches ? F.changedTouches[0] : F, this), O = T.invert(f), _ = T.k * (F.shiftKey ? 0.5 : 2), il = u(k(r(T, _), f, O), Z.apply(this, v), m);
      Wa(F), a > 0 ? lu(this).transition().duration(a).call(w, il, f, F) : lu(this).call(x.transform, il, f, F);
    }
  }
  function g(F, ...v) {
    if (l.apply(this, arguments)) {
      var T = F.touches, f = T.length, O = z(this, v, F.changedTouches.length === f).event(F), _, il, Zl, ol;
      for (jK(F), il = 0; il < f; ++il)
        Zl = T[il], ol = vu(Zl, this), ol = [ol, this.__zoom.invert(ol), Zl.identifier], O.touch0 ? !O.touch1 && O.touch0[2] !== ol[2] && (O.touch1 = ol, O.taps = 0) : (O.touch0 = ol, _ = !0, O.taps = 1 + !!y);
      y && (y = clearTimeout(y)), _ && (O.taps < 2 && (h = ol[0], y = setTimeout(function() {
        y = null;
      }, t)), ih(this), O.start());
    }
  }
  function A(F, ...v) {
    if (this.__zooming) {
      var T = z(this, v).event(F), f = F.changedTouches, O = f.length, _, il, Zl, ol;
      for (Wa(F), _ = 0; _ < O; ++_)
        il = f[_], Zl = vu(il, this), T.touch0 && T.touch0[2] === il.identifier ? T.touch0[0] = Zl : T.touch1 && T.touch1[2] === il.identifier && (T.touch1[0] = Zl);
      if (il = T.that.__zoom, T.touch1) {
        var Wl = T.touch0[0], ml = T.touch0[1], Rl = T.touch1[0], kl = T.touch1[1], zl = (zl = Rl[0] - Wl[0]) * zl + (zl = Rl[1] - Wl[1]) * zl, Vl = (Vl = kl[0] - ml[0]) * Vl + (Vl = kl[1] - ml[1]) * Vl;
        il = r(il, Math.sqrt(zl / Vl)), Zl = [(Wl[0] + Rl[0]) / 2, (Wl[1] + Rl[1]) / 2], ol = [(ml[0] + kl[0]) / 2, (ml[1] + kl[1]) / 2];
      } else if (T.touch0) Zl = T.touch0[0], ol = T.touch0[1];
      else return;
      T.zoom("touch", u(k(il, Zl, ol), T.extent, m));
    }
  }
  function J(F, ...v) {
    if (this.__zooming) {
      var T = z(this, v).event(F), f = F.changedTouches, O = f.length, _, il;
      for (jK(F), S && clearTimeout(S), S = setTimeout(function() {
        S = null;
      }, t), _ = 0; _ < O; ++_)
        il = f[_], T.touch0 && T.touch0[2] === il.identifier ? delete T.touch0 : T.touch1 && T.touch1[2] === il.identifier && delete T.touch1;
      if (T.touch1 && !T.touch0 && (T.touch0 = T.touch1, delete T.touch1), T.touch0) T.touch0[1] = this.__zoom.invert(T.touch0[0]);
      else if (T.end(), T.taps === 2 && (il = vu(il, this), Math.hypot(h[0] - il[0], h[1] - il[1]) < R)) {
        var Zl = lu(this).on("dblclick.zoom");
        Zl && Zl.apply(this, arguments);
      }
    }
  }
  return x.wheelDelta = function(F) {
    return arguments.length ? (s = typeof F == "function" ? F : $L(+F), x) : s;
  }, x.filter = function(F) {
    return arguments.length ? (l = typeof F == "function" ? F : $L(!!F), x) : l;
  }, x.touchable = function(F) {
    return arguments.length ? (G = typeof F == "function" ? F : $L(!!F), x) : G;
  }, x.extent = function(F) {
    return arguments.length ? (Z = typeof F == "function" ? F : $L([[+F[0][0], +F[0][1]], [+F[1][0], +F[1][1]]]), x) : Z;
  }, x.scaleExtent = function(F) {
    return arguments.length ? (i[0] = +F[0], i[1] = +F[1], x) : [i[0], i[1]];
  }, x.translateExtent = function(F) {
    return arguments.length ? (m[0][0] = +F[0][0], m[1][0] = +F[1][0], m[0][1] = +F[0][1], m[1][1] = +F[1][1], x) : [[m[0][0], m[0][1]], [m[1][0], m[1][1]]];
  }, x.constrain = function(F) {
    return arguments.length ? (u = F, x) : u;
  }, x.duration = function(F) {
    return arguments.length ? (a = +F, x) : a;
  }, x.interpolate = function(F) {
    return arguments.length ? (n = F, x) : n;
  }, x.on = function() {
    var F = p.on.apply(p, arguments);
    return F === p ? x : F;
  }, x.clickDistance = function(F) {
    return arguments.length ? (V = (F = +F) * F, x) : Math.sqrt(V);
  }, x.tapDistance = function(F) {
    return arguments.length ? (R = +F, x) : R;
  }, x;
}
const Sd = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (l) => `Node type "${l}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (l) => `The old edge with id=${l} does not exist.`,
  error009: (l) => `Marker type "${l}" doesn't exist.`,
  error008: (l, { id: Z, sourceHandle: u, targetHandle: s }) => `Couldn't create edge for ${l} handle id: "${l === "source" ? u : s}", edge id: ${Z}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (l) => `Edge type "${l}" not found. Using fallback type "default".`,
  error012: (l) => `Node with id "${l}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (l = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${l}/dist/style.css' or base.css to make sure everything is working properly.`
}, Aa = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], mC = ["Enter", " ", "Escape"];
var Lo;
(function(l) {
  l.Strict = "strict", l.Loose = "loose";
})(Lo || (Lo = {}));
var hm;
(function(l) {
  l.Free = "free", l.Vertical = "vertical", l.Horizontal = "horizontal";
})(hm || (hm = {}));
var $a;
(function(l) {
  l.Partial = "partial", l.Full = "full";
})($a || ($a = {}));
const iC = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var sG;
(function(l) {
  l.Bezier = "default", l.Straight = "straight", l.Step = "step", l.SmoothStep = "smoothstep", l.SimpleBezier = "simplebezier";
})(sG || (sG = {}));
var qa;
(function(l) {
  l.Arrow = "arrow", l.ArrowClosed = "arrowclosed";
})(qa || (qa = {}));
var Tl;
(function(l) {
  l.Left = "left", l.Top = "top", l.Right = "right", l.Bottom = "bottom";
})(Tl || (Tl = {}));
const iM = {
  [Tl.Left]: Tl.Right,
  [Tl.Right]: Tl.Left,
  [Tl.Top]: Tl.Bottom,
  [Tl.Bottom]: Tl.Top
};
function oC(l) {
  return l === null ? null : l ? "valid" : "invalid";
}
const eC = (l) => "id" in l && "source" in l && "target" in l, b8 = (l) => "id" in l && "position" in l && !("source" in l) && !("target" in l), jV = (l) => "id" in l && "internals" in l && !("source" in l) && !("target" in l), tn = (l, Z = [0, 0]) => {
  const { width: u, height: s } = td(l), G = l.origin ?? Z, i = u * G[0], m = s * G[1];
  return {
    x: l.position.x - i,
    y: l.position.y - m
  };
}, u8 = (l, Z = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
  if (l.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const u = l.reduce((s, G) => {
    const i = typeof G == "string";
    let m = !Z.nodeLookup && !i ? G : void 0;
    Z.nodeLookup && (m = i ? Z.nodeLookup.get(G) : jV(G) ? G : Z.nodeLookup.get(G.id));
    const a = m ? Yh(m, Z.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return _h(s, a);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return ly(u);
}, Mo = (l, Z = {}) => {
  if (l.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let u = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return l.forEach((s) => {
    if (Z.filter === void 0 || Z.filter(s)) {
      const G = Yh(s);
      u = _h(u, G);
    }
  }), ly(u);
}, aC = (l, Z, [u, s, G] = [0, 0, 1], i = !1, m = !1) => {
  const a = {
    ...Xn(Z, [u, s, G]),
    width: Z.width / G,
    height: Z.height / G
  }, n = [];
  for (const p of l.values()) {
    const { measured: y, selectable: h = !0, hidden: S = !1 } = p;
    if (m && !h || S)
      continue;
    const t = y.width ?? p.width ?? p.initialWidth ?? null, W = y.height ?? p.height ?? p.initialHeight ?? null, V = _a(a, yo(p)), R = (t ?? 0) * (W ?? 0), x = i && V > 0;
    (!p.internals.handleBounds || x || V >= R || p.dragging) && n.push(p);
  }
  return n;
}, s8 = (l, Z) => {
  const u = /* @__PURE__ */ new Set();
  return l.forEach((s) => {
    u.add(s.id);
  }), Z.filter((s) => u.has(s.source) || u.has(s.target));
};
function vW(l, Z) {
  const u = /* @__PURE__ */ new Map(), s = Z != null && Z.nodes ? new Set(Z.nodes.map((G) => G.id)) : null;
  return l.forEach((G) => {
    G.measured.width && G.measured.height && ((Z == null ? void 0 : Z.includeHiddenNodes) || !G.hidden) && (!s || s.has(G.id)) && u.set(G.id, G);
  }), u;
}
async function TW({ nodes: l, width: Z, height: u, panZoom: s, minZoom: G, maxZoom: i }, m) {
  if (l.size === 0)
    return Promise.resolve(!1);
  const a = Mo(l), n = QV(a, Z, u, (m == null ? void 0 : m.minZoom) ?? G, (m == null ? void 0 : m.maxZoom) ?? i, (m == null ? void 0 : m.padding) ?? 0.1);
  return await s.setViewport(n, { duration: m == null ? void 0 : m.duration }), Promise.resolve(!0);
}
function nC({ nodeId: l, nextPosition: Z, nodeLookup: u, nodeOrigin: s = [0, 0], nodeExtent: G, onError: i }) {
  const m = u.get(l), a = m.parentId ? u.get(m.parentId) : void 0, { x: n, y: p } = a ? a.internals.positionAbsolute : { x: 0, y: 0 }, y = m.origin ?? s;
  let h = G;
  if (m.extent === "parent" && !m.expandParent)
    if (!a)
      i == null || i("005", Sd.error005());
    else {
      const t = a.measured.width, W = a.measured.height;
      t && W && (h = [
        [n, p],
        [n + t, p + W]
      ]);
    }
  else a && So(m.extent) && (h = [
    [m.extent[0][0] + n, m.extent[0][1] + p],
    [m.extent[1][0] + n, m.extent[1][1] + p]
  ]);
  const S = So(h) ? xm(Z, h, m.measured) : Z;
  return {
    position: {
      x: S.x - n + m.measured.width * y[0],
      y: S.y - p + m.measured.height * y[1]
    },
    positionAbsolute: S
  };
}
async function d8({ nodesToRemove: l = [], edgesToRemove: Z = [], nodes: u, edges: s, onBeforeDelete: G }) {
  const i = new Set(l.map((S) => S.id)), m = [];
  for (const S of u) {
    if (S.deletable === !1)
      continue;
    const t = i.has(S.id), W = !t && S.parentId && m.find((V) => V.id === S.parentId);
    (t || W) && m.push(S);
  }
  const a = new Set(Z.map((S) => S.id)), n = s.filter((S) => S.deletable !== !1), y = s8(m, n);
  for (const S of n)
    a.has(S.id) && !y.find((W) => W.id === S.id) && y.push(S);
  if (!G)
    return {
      edges: y,
      nodes: m
    };
  const h = await G({
    nodes: m,
    edges: y
  });
  return typeof h == "boolean" ? h ? { edges: y, nodes: m } : { edges: [], nodes: [] } : h;
}
const ho = (l, Z = 0, u = 1) => Math.min(Math.max(l, Z), u), xm = (l = { x: 0, y: 0 }, Z, u) => ({
  x: ho(l.x, Z[0][0], Z[1][0] - ((u == null ? void 0 : u.width) ?? 0)),
  y: ho(l.y, Z[0][1], Z[1][1] - ((u == null ? void 0 : u.height) ?? 0))
});
function pC(l, Z, u) {
  const { width: s, height: G } = td(u), { x: i, y: m } = u.internals.positionAbsolute;
  return xm(l, [
    [i, m],
    [i + s, m + G]
  ], Z);
}
const oM = (l, Z, u) => l < Z ? ho(Math.abs(l - Z), 1, Z) / Z : l > u ? -ho(Math.abs(l - u), 1, Z) / Z : 0, LC = (l, Z, u = 15, s = 40) => {
  const G = oM(l.x, s, Z.width - s) * u, i = oM(l.y, s, Z.height - s) * u;
  return [G, i];
}, _h = (l, Z) => ({
  x: Math.min(l.x, Z.x),
  y: Math.min(l.y, Z.y),
  x2: Math.max(l.x2, Z.x2),
  y2: Math.max(l.y2, Z.y2)
}), fW = ({ x: l, y: Z, width: u, height: s }) => ({
  x: l,
  y: Z,
  x2: l + u,
  y2: Z + s
}), ly = ({ x: l, y: Z, x2: u, y2: s }) => ({
  x: l,
  y: Z,
  width: u - l,
  height: s - Z
}), yo = (l, Z = [0, 0]) => {
  var G, i;
  const { x: u, y: s } = jV(l) ? l.internals.positionAbsolute : tn(l, Z);
  return {
    x: u,
    y: s,
    width: ((G = l.measured) == null ? void 0 : G.width) ?? l.width ?? l.initialWidth ?? 0,
    height: ((i = l.measured) == null ? void 0 : i.height) ?? l.height ?? l.initialHeight ?? 0
  };
}, Yh = (l, Z = [0, 0]) => {
  var G, i;
  const { x: u, y: s } = jV(l) ? l.internals.positionAbsolute : tn(l, Z);
  return {
    x: u,
    y: s,
    x2: u + (((G = l.measured) == null ? void 0 : G.width) ?? l.width ?? l.initialWidth ?? 0),
    y2: s + (((i = l.measured) == null ? void 0 : i.height) ?? l.height ?? l.initialHeight ?? 0)
  };
}, hC = (l, Z) => ly(_h(fW(l), fW(Z))), _a = (l, Z) => {
  const u = Math.max(0, Math.min(l.x + l.width, Z.x + Z.width) - Math.max(l.x, Z.x)), s = Math.max(0, Math.min(l.y + l.height, Z.y + Z.height) - Math.max(l.y, Z.y));
  return Math.ceil(u * s);
}, eM = (l) => Bu(l.width) && Bu(l.height) && Bu(l.x) && Bu(l.y), Bu = (l) => !isNaN(l) && isFinite(l), G8 = (l, Z) => {
}, Zy = (l, Z = [1, 1]) => ({
  x: Z[0] * Math.round(l.x / Z[0]),
  y: Z[1] * Math.round(l.y / Z[1])
}), Xn = ({ x: l, y: Z }, [u, s, G], i = !1, m = [1, 1]) => {
  const a = {
    x: (l - u) / G,
    y: (Z - s) / G
  };
  return i ? Zy(a, m) : a;
}, yC = ({ x: l, y: Z }, [u, s, G]) => ({
  x: l * G + u,
  y: Z * G + s
}), QV = (l, Z, u, s, G, i) => {
  const m = Z / (l.width * (1 + i)), a = u / (l.height * (1 + i)), n = Math.min(m, a), p = ho(n, s, G), y = l.x + l.width / 2, h = l.y + l.height / 2, S = Z / 2 - y * p, t = u / 2 - h * p;
  return { x: S, y: t, zoom: p };
}, kh = () => {
  var l;
  return typeof navigator < "u" && ((l = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : l.indexOf("Mac")) >= 0;
};
function So(l) {
  return l !== void 0 && l !== "parent";
}
function td(l) {
  var Z, u;
  return {
    width: ((Z = l.measured) == null ? void 0 : Z.width) ?? l.width ?? l.initialWidth ?? 0,
    height: ((u = l.measured) == null ? void 0 : u.height) ?? l.height ?? l.initialHeight ?? 0
  };
}
function PV(l) {
  var Z, u;
  return (((Z = l.measured) == null ? void 0 : Z.width) ?? l.width ?? l.initialWidth) !== void 0 && (((u = l.measured) == null ? void 0 : u.height) ?? l.height ?? l.initialHeight) !== void 0;
}
function SC(l, Z = { width: 0, height: 0 }, u, s, G) {
  let i = u;
  const m = { ...l };
  for (; i; ) {
    const a = s.get(i);
    if (i = a == null ? void 0 : a.parentId, a) {
      const n = a.origin || G;
      m.x += a.internals.positionAbsolute.x - (Z.width ?? 0) * n[0], m.y += a.internals.positionAbsolute.y - (Z.height ?? 0) * n[1];
    }
  }
  return m;
}
function Na(l, { snapGrid: Z = [0, 0], snapToGrid: u = !1, transform: s }) {
  const { x: G, y: i } = ed(l), m = Xn({ x: G, y: i }, s), { x: a, y: n } = u ? Zy(m, Z) : m;
  return {
    xSnapped: a,
    ySnapped: n,
    ...m
  };
}
const cy = (l) => ({
  width: l.offsetWidth,
  height: l.offsetHeight
}), tC = (l) => {
  var Z;
  return ((Z = l.getRootNode) == null ? void 0 : Z.call(l)) || (window == null ? void 0 : window.document);
}, m8 = ["INPUT", "SELECT", "TEXTAREA"];
function EW(l) {
  var s, G;
  const Z = ((G = (s = l.composedPath) == null ? void 0 : s.call(l)) == null ? void 0 : G[0]) || l.target;
  return m8.includes(Z == null ? void 0 : Z.nodeName) || (Z == null ? void 0 : Z.hasAttribute("contenteditable")) || !!(Z != null && Z.closest(".nokey"));
}
const XC = (l) => "clientX" in l, ed = (l, Z) => {
  var i, m;
  const u = XC(l), s = u ? l.clientX : (i = l.touches) == null ? void 0 : i[0].clientX, G = u ? l.clientY : (m = l.touches) == null ? void 0 : m[0].clientY;
  return {
    x: s - ((Z == null ? void 0 : Z.left) ?? 0),
    y: G - ((Z == null ? void 0 : Z.top) ?? 0)
  };
}, aM = (l, Z, u, s, G) => {
  const i = Z.querySelectorAll(`.${l}`);
  return !i || !i.length ? null : Array.from(i).map((m) => {
    const a = m.getBoundingClientRect();
    return {
      id: m.getAttribute("data-handleid"),
      type: l,
      nodeId: G,
      position: m.getAttribute("data-handlepos"),
      x: (a.left - u.left) / s,
      y: (a.top - u.top) / s,
      ...cy(m)
    };
  });
};
function KC({ sourceX: l, sourceY: Z, targetX: u, targetY: s, sourceControlX: G, sourceControlY: i, targetControlX: m, targetControlY: a }) {
  const n = l * 0.125 + G * 0.375 + m * 0.375 + u * 0.125, p = Z * 0.125 + i * 0.375 + a * 0.375 + s * 0.125, y = Math.abs(n - l), h = Math.abs(p - Z);
  return [n, p, y, h];
}
function qL(l, Z) {
  return l >= 0 ? 0.5 * l : Z * 25 * Math.sqrt(-l);
}
function nM({ pos: l, x1: Z, y1: u, x2: s, y2: G, c: i }) {
  switch (l) {
    case Tl.Left:
      return [Z - qL(Z - s, i), u];
    case Tl.Right:
      return [Z + qL(s - Z, i), u];
    case Tl.Top:
      return [Z, u - qL(u - G, i)];
    case Tl.Bottom:
      return [Z, u + qL(G - u, i)];
  }
}
function WC({ sourceX: l, sourceY: Z, sourcePosition: u = Tl.Bottom, targetX: s, targetY: G, targetPosition: i = Tl.Top, curvature: m = 0.25 }) {
  const [a, n] = nM({
    pos: u,
    x1: l,
    y1: Z,
    x2: s,
    y2: G,
    c: m
  }), [p, y] = nM({
    pos: i,
    x1: s,
    y1: G,
    x2: l,
    y2: Z,
    c: m
  }), [h, S, t, W] = KC({
    sourceX: l,
    sourceY: Z,
    targetX: s,
    targetY: G,
    sourceControlX: a,
    sourceControlY: n,
    targetControlX: p,
    targetControlY: y
  });
  return [
    `M${l},${Z} C${a},${n} ${p},${y} ${s},${G}`,
    h,
    S,
    t,
    W
  ];
}
function VC({ sourceX: l, sourceY: Z, targetX: u, targetY: s }) {
  const G = Math.abs(u - l) / 2, i = u < l ? u + G : u - G, m = Math.abs(s - Z) / 2, a = s < Z ? s + m : s - m;
  return [i, a, G, m];
}
function i8({ sourceNode: l, targetNode: Z, selected: u = !1, zIndex: s = 0, elevateOnSelect: G = !1 }) {
  if (!G)
    return s;
  const i = u || Z.selected || l.selected, m = Math.max(l.internals.z || 0, Z.internals.z || 0, 1e3);
  return s + (i ? m : 0);
}
function o8({ sourceNode: l, targetNode: Z, width: u, height: s, transform: G }) {
  const i = _h(Yh(l), Yh(Z));
  i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1);
  const m = {
    x: -G[0] / G[2],
    y: -G[1] / G[2],
    width: u / G[2],
    height: s / G[2]
  };
  return _a(m, ly(i)) > 0;
}
const e8 = ({ source: l, sourceHandle: Z, target: u, targetHandle: s }) => `xy-edge__${l}${Z || ""}-${u}${s || ""}`, a8 = (l, Z) => Z.some((u) => u.source === l.source && u.target === l.target && (u.sourceHandle === l.sourceHandle || !u.sourceHandle && !l.sourceHandle) && (u.targetHandle === l.targetHandle || !u.targetHandle && !l.targetHandle)), n8 = (l, Z) => {
  if (!l.source || !l.target)
    return Z;
  let u;
  return eC(l) ? u = { ...l } : u = {
    ...l,
    id: e8(l)
  }, a8(u, Z) ? Z : (u.sourceHandle === null && delete u.sourceHandle, u.targetHandle === null && delete u.targetHandle, Z.concat(u));
};
function xC({ sourceX: l, sourceY: Z, targetX: u, targetY: s }) {
  const [G, i, m, a] = VC({
    sourceX: l,
    sourceY: Z,
    targetX: u,
    targetY: s
  });
  return [`M ${l},${Z}L ${u},${s}`, G, i, m, a];
}
const pM = {
  [Tl.Left]: { x: -1, y: 0 },
  [Tl.Right]: { x: 1, y: 0 },
  [Tl.Top]: { x: 0, y: -1 },
  [Tl.Bottom]: { x: 0, y: 1 }
}, p8 = ({ source: l, sourcePosition: Z = Tl.Bottom, target: u }) => Z === Tl.Left || Z === Tl.Right ? l.x < u.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : l.y < u.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, LM = (l, Z) => Math.sqrt(Math.pow(Z.x - l.x, 2) + Math.pow(Z.y - l.y, 2));
function L8({ source: l, sourcePosition: Z = Tl.Bottom, target: u, targetPosition: s = Tl.Top, center: G, offset: i }) {
  const m = pM[Z], a = pM[s], n = { x: l.x + m.x * i, y: l.y + m.y * i }, p = { x: u.x + a.x * i, y: u.y + a.y * i }, y = p8({
    source: n,
    sourcePosition: Z,
    target: p
  }), h = y.x !== 0 ? "x" : "y", S = y[h];
  let t = [], W, V;
  const R = { x: 0, y: 0 }, x = { x: 0, y: 0 }, [r, k, U, w] = VC({
    sourceX: l.x,
    sourceY: l.y,
    targetX: u.x,
    targetY: u.y
  });
  if (m[h] * a[h] === -1) {
    W = G.x ?? r, V = G.y ?? k;
    const D = [
      { x: W, y: n.y },
      { x: W, y: p.y }
    ], C = [
      { x: n.x, y: V },
      { x: p.x, y: V }
    ];
    m[h] === S ? t = h === "x" ? D : C : t = h === "x" ? C : D;
  } else {
    const D = [{ x: n.x, y: p.y }], C = [{ x: p.x, y: n.y }];
    if (h === "x" ? t = m.x === S ? C : D : t = m.y === S ? D : C, Z === s) {
      const J = Math.abs(l[h] - u[h]);
      if (J <= i) {
        const F = Math.min(i - 1, i - J);
        m[h] === S ? R[h] = (n[h] > l[h] ? -1 : 1) * F : x[h] = (p[h] > u[h] ? -1 : 1) * F;
      }
    }
    if (Z !== s) {
      const J = h === "x" ? "y" : "x", F = m[h] === a[J], v = n[J] > p[J], T = n[J] < p[J];
      (m[h] === 1 && (!F && v || F && T) || m[h] !== 1 && (!F && T || F && v)) && (t = h === "x" ? D : C);
    }
    const j = { x: n.x + R.x, y: n.y + R.y }, E = { x: p.x + x.x, y: p.y + x.y }, g = Math.max(Math.abs(j.x - t[0].x), Math.abs(E.x - t[0].x)), A = Math.max(Math.abs(j.y - t[0].y), Math.abs(E.y - t[0].y));
    g >= A ? (W = (j.x + E.x) / 2, V = t[0].y) : (W = t[0].x, V = (j.y + E.y) / 2);
  }
  return [[
    l,
    { x: n.x + R.x, y: n.y + R.y },
    ...t,
    { x: p.x + x.x, y: p.y + x.y },
    u
  ], W, V, U, w];
}
function h8(l, Z, u, s) {
  const G = Math.min(LM(l, Z) / 2, LM(Z, u) / 2, s), { x: i, y: m } = Z;
  if (l.x === i && i === u.x || l.y === m && m === u.y)
    return `L${i} ${m}`;
  if (l.y === m) {
    const p = l.x < u.x ? -1 : 1, y = l.y < u.y ? 1 : -1;
    return `L ${i + G * p},${m}Q ${i},${m} ${i},${m + G * y}`;
  }
  const a = l.x < u.x ? 1 : -1, n = l.y < u.y ? -1 : 1;
  return `L ${i},${m + G * n}Q ${i},${m} ${i + G * a},${m}`;
}
function BW({ sourceX: l, sourceY: Z, sourcePosition: u = Tl.Bottom, targetX: s, targetY: G, targetPosition: i = Tl.Top, borderRadius: m = 5, centerX: a, centerY: n, offset: p = 20 }) {
  const [y, h, S, t, W] = L8({
    source: { x: l, y: Z },
    sourcePosition: u,
    target: { x: s, y: G },
    targetPosition: i,
    center: { x: a, y: n },
    offset: p
  });
  return [y.reduce((R, x, r) => {
    let k = "";
    return r > 0 && r < y.length - 1 ? k = h8(y[r - 1], x, y[r + 1], m) : k = `${r === 0 ? "M" : "L"}${x.x} ${x.y}`, R += k, R;
  }, ""), h, S, t, W];
}
function hM(l) {
  var Z;
  return l && !!(l.internals.handleBounds || (Z = l.handles) != null && Z.length) && !!(l.measured.width || l.width || l.initialWidth);
}
function y8(l) {
  var h;
  const { sourceNode: Z, targetNode: u } = l;
  if (!hM(Z) || !hM(u))
    return null;
  const s = Z.internals.handleBounds || yM(Z.handles), G = u.internals.handleBounds || yM(u.handles), i = SM((s == null ? void 0 : s.source) ?? [], l.sourceHandle), m = SM(
    // when connection type is loose we can define all handles as sources and connect source -> source
    l.connectionMode === Lo.Strict ? (G == null ? void 0 : G.target) ?? [] : ((G == null ? void 0 : G.target) ?? []).concat((G == null ? void 0 : G.source) ?? []),
    l.targetHandle
  );
  if (!i || !m)
    return (h = l.onError) == null || h.call(l, "008", Sd.error008(i ? "target" : "source", {
      id: l.id,
      sourceHandle: l.sourceHandle,
      targetHandle: l.targetHandle
    })), null;
  const a = (i == null ? void 0 : i.position) || Tl.Bottom, n = (m == null ? void 0 : m.position) || Tl.Top, p = ln(Z, i, a), y = ln(u, m, n);
  return {
    sourceX: p.x,
    sourceY: p.y,
    targetX: y.x,
    targetY: y.y,
    sourcePosition: a,
    targetPosition: n
  };
}
function yM(l) {
  if (!l)
    return null;
  const Z = [], u = [];
  for (const s of l)
    s.width = s.width ?? 1, s.height = s.height ?? 1, s.type === "source" ? Z.push(s) : s.type === "target" && u.push(s);
  return {
    source: Z,
    target: u
  };
}
function ln(l, Z, u = Tl.Left, s = !1) {
  const G = ((Z == null ? void 0 : Z.x) ?? 0) + l.internals.positionAbsolute.x, i = ((Z == null ? void 0 : Z.y) ?? 0) + l.internals.positionAbsolute.y, { width: m, height: a } = Z ?? td(l);
  if (s)
    return { x: G + m / 2, y: i + a / 2 };
  switch ((Z == null ? void 0 : Z.position) ?? u) {
    case Tl.Top:
      return { x: G + m / 2, y: i };
    case Tl.Right:
      return { x: G + m, y: i + a / 2 };
    case Tl.Bottom:
      return { x: G + m / 2, y: i + a };
    case Tl.Left:
      return { x: G, y: i + a / 2 };
  }
}
function SM(l, Z) {
  return l && (Z ? l.find((u) => u.id === Z) : l[0]) || null;
}
function DW(l, Z) {
  return l ? typeof l == "string" ? l : `${Z ? `${Z}__` : ""}${Object.keys(l).sort().map((s) => `${s}=${l[s]}`).join("&")}` : "";
}
function S8(l, { id: Z, defaultColor: u, defaultMarkerStart: s, defaultMarkerEnd: G }) {
  const i = /* @__PURE__ */ new Set();
  return l.reduce((m, a) => ([a.markerStart || s, a.markerEnd || G].forEach((n) => {
    if (n && typeof n == "object") {
      const p = DW(n, Z);
      i.has(p) || (m.push({ id: p, color: n.color || u, ...n }), i.add(p));
    }
  }), m), []).sort((m, a) => m.id.localeCompare(a.id));
}
function t8(l, Z, u, s, G) {
  let i = 0.5;
  G === "start" ? i = 0 : G === "end" && (i = 1);
  let m = [
    (l.x + l.width * i) * Z.zoom + Z.x,
    l.y * Z.zoom + Z.y - s
  ], a = [-100 * i, -100];
  switch (u) {
    case Tl.Right:
      m = [
        (l.x + l.width) * Z.zoom + Z.x + s,
        (l.y + l.height * i) * Z.zoom + Z.y
      ], a = [0, -100 * i];
      break;
    case Tl.Bottom:
      m[1] = (l.y + l.height) * Z.zoom + Z.y + s, a[1] = 0;
      break;
    case Tl.Left:
      m = [
        l.x * Z.zoom + Z.x - s,
        (l.y + l.height * i) * Z.zoom + Z.y
      ], a = [-100, -100 * i];
      break;
  }
  return `translate(${m[0]}px, ${m[1]}px) translate(${a[0]}%, ${a[1]}%)`;
}
const OV = {
  nodeOrigin: [0, 0],
  nodeExtent: Aa,
  elevateNodesOnSelect: !0,
  defaults: {}
}, X8 = {
  ...OV,
  checkEquality: !0
};
function AV(l, Z) {
  const u = { ...l };
  for (const s in Z)
    Z[s] !== void 0 && (u[s] = Z[s]);
  return u;
}
function K8(l, Z, u) {
  const s = AV(OV, u);
  for (const G of l.values())
    if (G.parentId)
      $V(G, l, Z, s);
    else {
      const i = tn(G, s.nodeOrigin), m = So(G.extent) ? G.extent : s.nodeExtent, a = xm(i, m, td(G));
      G.internals.positionAbsolute = a;
    }
}
function jW(l, Z, u, s) {
  var a, n;
  const G = AV(X8, s), i = new Map(Z), m = G != null && G.elevateNodesOnSelect ? 1e3 : 0;
  Z.clear(), u.clear();
  for (const p of l) {
    let y = i.get(p.id);
    if (G.checkEquality && p === (y == null ? void 0 : y.internals.userNode))
      Z.set(p.id, y);
    else {
      const h = tn(p, G.nodeOrigin), S = So(p.extent) ? p.extent : G.nodeExtent, t = xm(h, S, td(p));
      y = {
        ...G.defaults,
        ...p,
        measured: {
          width: (a = p.measured) == null ? void 0 : a.width,
          height: (n = p.measured) == null ? void 0 : n.height
        },
        internals: {
          positionAbsolute: t,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: p.measured ? y == null ? void 0 : y.internals.handleBounds : void 0,
          z: RC(p, m),
          userNode: p
        }
      }, Z.set(p.id, y);
    }
    p.parentId && $V(y, Z, u, s);
  }
}
function W8(l, Z) {
  if (!l.parentId)
    return;
  const u = Z.get(l.parentId);
  u ? u.set(l.id, l) : Z.set(l.parentId, /* @__PURE__ */ new Map([[l.id, l]]));
}
function $V(l, Z, u, s) {
  const { elevateNodesOnSelect: G, nodeOrigin: i, nodeExtent: m } = AV(OV, s), a = l.parentId, n = Z.get(a);
  if (!n) {
    console.warn(`Parent node ${a} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  W8(l, u);
  const p = G ? 1e3 : 0, { x: y, y: h, z: S } = V8(l, n, i, m, p), { positionAbsolute: t } = l.internals, W = y !== t.x || h !== t.y;
  (W || S !== l.internals.z) && (l.internals = {
    ...l.internals,
    positionAbsolute: W ? { x: y, y: h } : t,
    z: S
  });
}
function RC(l, Z) {
  return (Bu(l.zIndex) ? l.zIndex : 0) + (l.selected ? Z : 0);
}
function V8(l, Z, u, s, G) {
  const { x: i, y: m } = Z.internals.positionAbsolute, a = td(l), n = tn(l, u), p = So(l.extent) ? xm(n, l.extent, a) : n;
  let y = xm({ x: i + p.x, y: m + p.y }, s, a);
  l.extent === "parent" && (y = pC(y, a, Z));
  const h = RC(l, G), S = Z.internals.z ?? 0;
  return {
    x: y.x,
    y: y.y,
    z: S > h ? S : h
  };
}
function qV(l, Z, u, s = [0, 0]) {
  var m;
  const G = [], i = /* @__PURE__ */ new Map();
  for (const a of l) {
    const n = Z.get(a.parentId);
    if (!n)
      continue;
    const p = ((m = i.get(a.parentId)) == null ? void 0 : m.expandedRect) ?? yo(n), y = hC(p, a.rect);
    i.set(a.parentId, { expandedRect: y, parent: n });
  }
  return i.size > 0 && i.forEach(({ expandedRect: a, parent: n }, p) => {
    var k;
    const y = n.internals.positionAbsolute, h = td(n), S = n.origin ?? s, t = a.x < y.x ? Math.round(Math.abs(y.x - a.x)) : 0, W = a.y < y.y ? Math.round(Math.abs(y.y - a.y)) : 0, V = Math.max(h.width, Math.round(a.width)), R = Math.max(h.height, Math.round(a.height)), x = (V - h.width) * S[0], r = (R - h.height) * S[1];
    (t > 0 || W > 0 || x || r) && (G.push({
      id: p,
      type: "position",
      position: {
        x: n.position.x - t + x,
        y: n.position.y - W + r
      }
    }), (k = u.get(p)) == null || k.forEach((U) => {
      l.some((w) => w.id === U.id) || G.push({
        id: U.id,
        type: "position",
        position: {
          x: U.position.x + t,
          y: U.position.y + W
        }
      });
    })), (h.width < a.width || h.height < a.height || t || W) && G.push({
      id: p,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: V + (t ? S[0] * t - x : 0),
        height: R + (W ? S[1] * W - r : 0)
      }
    });
  }), G;
}
function x8(l, Z, u, s, G, i) {
  const m = s == null ? void 0 : s.querySelector(".xyflow__viewport");
  let a = !1;
  if (!m)
    return { changes: [], updatedInternals: a };
  const n = [], p = window.getComputedStyle(m), { m22: y } = new window.DOMMatrixReadOnly(p.transform), h = [];
  for (const S of l.values()) {
    const t = Z.get(S.id);
    if (t)
      if (t.hidden)
        t.internals = {
          ...t.internals,
          handleBounds: void 0
        }, a = !0;
      else {
        const W = cy(S.nodeElement), V = t.measured.width !== W.width || t.measured.height !== W.height;
        if (!!(W.width && W.height && (V || !t.internals.handleBounds || S.force))) {
          const x = S.nodeElement.getBoundingClientRect(), r = So(t.extent) ? t.extent : i;
          let { positionAbsolute: k } = t.internals;
          t.parentId && t.extent === "parent" ? k = pC(k, W, Z.get(t.parentId)) : r && (k = xm(k, r, W)), t.measured = W, t.internals = {
            ...t.internals,
            positionAbsolute: k,
            handleBounds: {
              source: aM("source", S.nodeElement, x, y, t.id),
              target: aM("target", S.nodeElement, x, y, t.id)
            }
          }, t.parentId && $V(t, Z, u, { nodeOrigin: G }), a = !0, V && (n.push({
            id: t.id,
            type: "dimensions",
            dimensions: W
          }), t.expandParent && t.parentId && h.push({
            id: t.id,
            parentId: t.parentId,
            rect: yo(t, G)
          }));
        }
      }
  }
  if (h.length > 0) {
    const S = qV(h, Z, u, G);
    n.push(...S);
  }
  return { changes: n, updatedInternals: a };
}
async function R8({ delta: l, panZoom: Z, transform: u, translateExtent: s, width: G, height: i }) {
  if (!Z || !l.x && !l.y)
    return Promise.resolve(!1);
  const m = await Z.setViewportConstrained({
    x: u[0] + l.x,
    y: u[1] + l.y,
    zoom: u[2]
  }, [
    [0, 0],
    [G, i]
  ], s), a = !!m && (m.x !== u[0] || m.y !== u[1] || m.k !== u[2]);
  return Promise.resolve(a);
}
function YC(l, Z, u) {
  l.clear(), Z.clear();
  for (const s of u) {
    const { source: G, target: i, sourceHandle: m = null, targetHandle: a = null } = s, n = `${G}-source-${m}`, p = `${i}-target-${a}`, y = l.get(n) || /* @__PURE__ */ new Map(), h = l.get(p) || /* @__PURE__ */ new Map(), S = { edgeId: s.id, source: G, target: i, sourceHandle: m, targetHandle: a };
    Z.set(s.id, s), l.set(n, y.set(`${i}-${a}`, S)), l.set(p, h.set(`${G}-${m}`, S));
  }
}
function kC(l, Z) {
  if (!l.parentId)
    return !1;
  const u = Z.get(l.parentId);
  return u ? u.selected ? !0 : kC(u, Z) : !1;
}
function tM(l, Z, u) {
  let s = l;
  do {
    if (s != null && s.matches(Z))
      return !0;
    if (s === u)
      return !1;
    s = s.parentElement;
  } while (s);
  return !1;
}
function Y8(l, Z, u, s) {
  const G = /* @__PURE__ */ new Map();
  for (const [i, m] of l)
    if ((m.selected || m.id === s) && (!m.parentId || !kC(m, l)) && (m.draggable || Z && typeof m.draggable > "u")) {
      const a = l.get(i);
      a && G.set(i, {
        id: i,
        position: a.position || { x: 0, y: 0 },
        distance: {
          x: u.x - a.internals.positionAbsolute.x,
          y: u.y - a.internals.positionAbsolute.y
        },
        extent: a.extent,
        parentId: a.parentId,
        origin: a.origin,
        expandParent: a.expandParent,
        internals: {
          positionAbsolute: a.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: a.measured.width ?? 0,
          height: a.measured.height ?? 0
        }
      });
    }
  return G;
}
function QK({ nodeId: l, dragItems: Z, nodeLookup: u, dragging: s = !0 }) {
  var m, a;
  const G = [];
  for (const [n, p] of Z) {
    const y = (m = u.get(n)) == null ? void 0 : m.internals.userNode;
    y && G.push({
      ...y,
      position: p.position,
      dragging: s
    });
  }
  if (!l)
    return [G[0], G];
  const i = u.get(l).internals.userNode;
  return [
    {
      ...i,
      position: ((a = Z.get(l)) == null ? void 0 : a.position) || i.position,
      dragging: s
    },
    G
  ];
}
function k8({ onNodeMouseDown: l, getStoreItems: Z, onDragStart: u, onDrag: s, onDragStop: G }) {
  let i = { x: null, y: null }, m = 0, a = /* @__PURE__ */ new Map(), n = !1, p = { x: 0, y: 0 }, y = null, h = !1, S = null, t = !1;
  function W({ noDragClassName: R, handleSelector: x, domNode: r, isSelectable: k, nodeId: U, nodeClickDistance: w = 0 }) {
    S = lu(r);
    function z({ x: E, y: g }, A) {
      const { nodeLookup: J, nodeExtent: F, snapGrid: v, snapToGrid: T, nodeOrigin: f, onNodeDrag: O, onSelectionDrag: _, onError: il, updateNodePositions: Zl } = Z();
      i = { x: E, y: g };
      let ol = !1, Wl = { x: 0, y: 0, x2: 0, y2: 0 };
      if (a.size > 1 && F) {
        const ml = Mo(a);
        Wl = fW(ml);
      }
      for (const [ml, Rl] of a) {
        if (!J.has(ml))
          continue;
        let kl = { x: E - Rl.distance.x, y: g - Rl.distance.y };
        T && (kl = Zy(kl, v));
        let zl = [
          [F[0][0], F[0][1]],
          [F[1][0], F[1][1]]
        ];
        if (a.size > 1 && F && !Rl.extent) {
          const { positionAbsolute: xl } = Rl.internals, hl = xl.x - Wl.x + F[0][0], cl = xl.x + Rl.measured.width - Wl.x2 + F[1][0], wl = xl.y - Wl.y + F[0][1], Jl = xl.y + Rl.measured.height - Wl.y2 + F[1][1];
          zl = [
            [hl, wl],
            [cl, Jl]
          ];
        }
        const { position: Vl, positionAbsolute: el } = nC({
          nodeId: ml,
          nextPosition: kl,
          nodeLookup: J,
          nodeExtent: zl,
          nodeOrigin: f,
          onError: il
        });
        ol = ol || Rl.position.x !== Vl.x || Rl.position.y !== Vl.y, Rl.position = Vl, Rl.internals.positionAbsolute = el;
      }
      if (ol && (Zl(a, !0), A && (s || O || !U && _))) {
        const [ml, Rl] = QK({
          nodeId: U,
          dragItems: a,
          nodeLookup: J
        });
        s == null || s(A, a, ml, Rl), O == null || O(A, ml, Rl), U || _ == null || _(A, Rl);
      }
    }
    async function D() {
      if (!y)
        return;
      const { transform: E, panBy: g, autoPanSpeed: A } = Z(), [J, F] = LC(p, y, A);
      (J !== 0 || F !== 0) && (i.x = (i.x ?? 0) - J / E[2], i.y = (i.y ?? 0) - F / E[2], await g({ x: J, y: F }) && z(i, null)), m = requestAnimationFrame(D);
    }
    function C(E) {
      var ol;
      const { nodeLookup: g, multiSelectionActive: A, nodesDraggable: J, transform: F, snapGrid: v, snapToGrid: T, selectNodesOnDrag: f, onNodeDragStart: O, onSelectionDragStart: _, unselectNodesAndEdges: il } = Z();
      h = !0, (!f || !k) && !A && U && ((ol = g.get(U)) != null && ol.selected || il()), k && f && U && (l == null || l(U));
      const Zl = Na(E.sourceEvent, { transform: F, snapGrid: v, snapToGrid: T });
      if (i = Zl, a = Y8(g, J, Zl, U), a.size > 0 && (u || O || !U && _)) {
        const [Wl, ml] = QK({
          nodeId: U,
          dragItems: a,
          nodeLookup: g
        });
        u == null || u(E.sourceEvent, a, Wl, ml), O == null || O(E.sourceEvent, Wl, ml), U || _ == null || _(E.sourceEvent, ml);
      }
    }
    const j = xU().clickDistance(w).on("start", (E) => {
      const { domNode: g, nodeDragThreshold: A, transform: J, snapGrid: F, snapToGrid: v } = Z();
      t = !1, A === 0 && C(E), i = Na(E.sourceEvent, { transform: J, snapGrid: F, snapToGrid: v }), y = (g == null ? void 0 : g.getBoundingClientRect()) || null, p = ed(E.sourceEvent, y);
    }).on("drag", (E) => {
      const { autoPanOnNodeDrag: g, transform: A, snapGrid: J, snapToGrid: F, nodeDragThreshold: v, nodeLookup: T } = Z(), f = Na(E.sourceEvent, { transform: A, snapGrid: J, snapToGrid: F });
      if ((E.sourceEvent.type === "touchmove" && E.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      U && !T.has(U)) && (t = !0), !t) {
        if (!n && g && h && (n = !0, D()), !h) {
          const O = f.xSnapped - (i.x ?? 0), _ = f.ySnapped - (i.y ?? 0);
          Math.sqrt(O * O + _ * _) > v && C(E);
        }
        (i.x !== f.xSnapped || i.y !== f.ySnapped) && a && h && (p = ed(E.sourceEvent, y), z(f, E.sourceEvent));
      }
    }).on("end", (E) => {
      if (!(!h || t) && (n = !1, h = !1, cancelAnimationFrame(m), a.size > 0)) {
        const { nodeLookup: g, updateNodePositions: A, onNodeDragStop: J, onSelectionDragStop: F } = Z();
        if (A(a, !1), G || J || !U && F) {
          const [v, T] = QK({
            nodeId: U,
            dragItems: a,
            nodeLookup: g,
            dragging: !1
          });
          G == null || G(E.sourceEvent, a, v, T), J == null || J(E.sourceEvent, v, T), U || F == null || F(E.sourceEvent, T);
        }
      }
    }).filter((E) => {
      const g = E.target;
      return !E.button && (!R || !tM(g, `.${R}`, r)) && (!x || tM(g, x, r));
    });
    S.call(j);
  }
  function V() {
    S == null || S.on(".drag", null);
  }
  return {
    update: W,
    destroy: V
  };
}
function M8(l, Z, u) {
  const s = [], G = {
    x: l.x - u,
    y: l.y - u,
    width: u * 2,
    height: u * 2
  };
  for (const i of Z.values())
    _a(G, yo(i)) > 0 && s.push(i);
  return s;
}
const I8 = 250;
function U8(l, Z, u, s) {
  var a, n;
  let G = [], i = 1 / 0;
  const m = M8(l, u, Z + I8);
  for (const p of m) {
    const y = [...((a = p.internals.handleBounds) == null ? void 0 : a.source) ?? [], ...((n = p.internals.handleBounds) == null ? void 0 : n.target) ?? []];
    for (const h of y) {
      if (s.nodeId === h.nodeId && s.type === h.type && s.id === h.id)
        continue;
      const { x: S, y: t } = ln(p, h, h.position, !0), W = Math.sqrt(Math.pow(S - l.x, 2) + Math.pow(t - l.y, 2));
      W > Z || (W < i ? (G = [{ ...h, x: S, y: t }], i = W) : W === i && G.push({ ...h, x: S, y: t }));
    }
  }
  if (!G.length)
    return null;
  if (G.length > 1) {
    const p = s.type === "source" ? "target" : "source";
    return G.find((y) => y.type === p) ?? G[0];
  }
  return G[0];
}
function MC(l, Z, u, s, G, i = !1) {
  var p, y, h;
  const m = s.get(l);
  if (!m)
    return null;
  const a = G === "strict" ? (p = m.internals.handleBounds) == null ? void 0 : p[Z] : [...((y = m.internals.handleBounds) == null ? void 0 : y.source) ?? [], ...((h = m.internals.handleBounds) == null ? void 0 : h.target) ?? []], n = (u ? a == null ? void 0 : a.find((S) => S.id === u) : a == null ? void 0 : a[0]) ?? null;
  return n && i ? { ...n, ...ln(m, n, n.position, !0) } : n;
}
function IC(l, Z) {
  return l || (Z != null && Z.classList.contains("target") ? "target" : Z != null && Z.classList.contains("source") ? "source" : null);
}
function C8(l, Z) {
  let u = null;
  return Z ? u = !0 : l && !Z && (u = !1), u;
}
const UC = () => !0;
function r8(l, { connectionMode: Z, connectionRadius: u, handleId: s, nodeId: G, edgeUpdaterType: i, isTarget: m, domNode: a, nodeLookup: n, lib: p, autoPanOnConnect: y, flowId: h, panBy: S, cancelConnection: t, onConnectStart: W, onConnect: V, onConnectEnd: R, isValidConnection: x = UC, onReconnectEnd: r, updateConnection: k, getTransform: U, getFromHandle: w, autoPanSpeed: z }) {
  const D = tC(l.target);
  let C = 0, j;
  const { x: E, y: g } = ed(l), A = D == null ? void 0 : D.elementFromPoint(E, g), J = IC(i, A), F = a == null ? void 0 : a.getBoundingClientRect();
  if (!F || !J)
    return;
  const v = MC(G, J, s, n, Z);
  if (!v)
    return;
  let T = ed(l, F), f = !1, O = null, _ = !1, il = null;
  function Zl() {
    if (!y || !F)
      return;
    const [el, xl] = LC(T, F, z);
    S({ x: el, y: xl }), C = requestAnimationFrame(Zl);
  }
  const ol = {
    ...v,
    nodeId: G,
    type: J,
    position: v.position
  }, Wl = n.get(G), Rl = {
    inProgress: !0,
    isValid: null,
    from: ln(Wl, ol, Tl.Left, !0),
    fromHandle: ol,
    fromPosition: ol.position,
    fromNode: Wl,
    to: T,
    toHandle: null,
    toPosition: iM[ol.position],
    toNode: null
  };
  k(Rl);
  let kl = Rl;
  W == null || W(l, { nodeId: G, handleId: s, handleType: J });
  function zl(el) {
    if (!w() || !ol) {
      Vl(el);
      return;
    }
    const xl = U();
    T = ed(el, F), j = U8(Xn(T, xl, !1, [1, 1]), u, n, ol), f || (Zl(), f = !0);
    const hl = CC(el, {
      handle: j,
      connectionMode: Z,
      fromNodeId: G,
      fromHandleId: s,
      fromType: m ? "target" : "source",
      isValidConnection: x,
      doc: D,
      lib: p,
      flowId: h,
      nodeLookup: n
    });
    il = hl.handleDomNode, O = hl.connection, _ = C8(!!j, hl.isValid);
    const cl = {
      // from stays the same
      ...kl,
      isValid: _,
      to: j && _ ? yC({ x: j.x, y: j.y }, xl) : T,
      toHandle: hl.toHandle,
      toPosition: _ && hl.toHandle ? hl.toHandle.position : iM[ol.position],
      toNode: hl.toHandle ? n.get(hl.toHandle.nodeId) : null
    };
    _ && j && kl.toHandle && cl.toHandle && kl.toHandle.type === cl.toHandle.type && kl.toHandle.nodeId === cl.toHandle.nodeId && kl.toHandle.id === cl.toHandle.id && kl.to.x === cl.to.x && kl.to.y === cl.to.y || (k(cl), kl = cl);
  }
  function Vl(el) {
    (j || il) && O && _ && (V == null || V(O));
    const { inProgress: xl, ...hl } = kl, cl = {
      ...hl,
      toPosition: kl.toHandle ? kl.toPosition : null
    };
    R == null || R(el, cl), i && (r == null || r(el, cl)), t(), cancelAnimationFrame(C), f = !1, _ = !1, O = null, il = null, D.removeEventListener("mousemove", zl), D.removeEventListener("mouseup", Vl), D.removeEventListener("touchmove", zl), D.removeEventListener("touchend", Vl);
  }
  D.addEventListener("mousemove", zl), D.addEventListener("mouseup", Vl), D.addEventListener("touchmove", zl), D.addEventListener("touchend", Vl);
}
function CC(l, { handle: Z, connectionMode: u, fromNodeId: s, fromHandleId: G, fromType: i, doc: m, lib: a, flowId: n, isValidConnection: p = UC, nodeLookup: y }) {
  const h = i === "target", S = Z ? m.querySelector(`.${a}-flow__handle[data-id="${n}-${Z == null ? void 0 : Z.nodeId}-${Z == null ? void 0 : Z.id}-${Z == null ? void 0 : Z.type}"]`) : null, { x: t, y: W } = ed(l), V = m.elementFromPoint(t, W), R = V != null && V.classList.contains(`${a}-flow__handle`) ? V : S, x = {
    handleDomNode: R,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (R) {
    const r = IC(void 0, R), k = R.getAttribute("data-nodeid"), U = R.getAttribute("data-handleid"), w = R.classList.contains("connectable"), z = R.classList.contains("connectableend");
    if (!k || !r)
      return x;
    const D = {
      source: h ? k : s,
      sourceHandle: h ? U : G,
      target: h ? s : k,
      targetHandle: h ? G : U
    };
    x.connection = D;
    const j = w && z && (u === Lo.Strict ? h && r === "source" || !h && r === "target" : k !== s || U !== G);
    x.isValid = j && p(D), x.toHandle = MC(k, r, U, y, u, !1);
  }
  return x;
}
const QW = {
  onPointerDown: r8,
  isValid: CC
};
function F8({ domNode: l, panZoom: Z, getTransform: u, getViewScale: s }) {
  const G = lu(l);
  function i({ translateExtent: a, width: n, height: p, zoomStep: y = 10, pannable: h = !0, zoomable: S = !0, inversePan: t = !1 }) {
    const W = (k) => {
      const U = u();
      if (k.sourceEvent.type !== "wheel" || !Z)
        return;
      const w = -k.sourceEvent.deltaY * (k.sourceEvent.deltaMode === 1 ? 0.05 : k.sourceEvent.deltaMode ? 1 : 2e-3) * y, z = U[2] * Math.pow(2, w);
      Z.scaleTo(z);
    };
    let V = [0, 0];
    const R = (k) => {
      (k.sourceEvent.type === "mousedown" || k.sourceEvent.type === "touchstart") && (V = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ]);
    }, x = (k) => {
      const U = u();
      if (k.sourceEvent.type !== "mousemove" && k.sourceEvent.type !== "touchmove" || !Z)
        return;
      const w = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ], z = [w[0] - V[0], w[1] - V[1]];
      V = w;
      const D = s() * Math.max(U[2], Math.log(U[2])) * (t ? -1 : 1), C = {
        x: U[0] - z[0] * D,
        y: U[1] - z[1] * D
      }, j = [
        [0, 0],
        [n, p]
      ];
      Z.setViewportConstrained({
        x: C.x,
        y: C.y,
        zoom: U[2]
      }, j, a);
    }, r = GC().on("start", R).on("zoom", h ? x : null).on("zoom.wheel", S ? W : null);
    G.call(r, {});
  }
  function m() {
    G.on("zoom", null);
  }
  return {
    update: i,
    destroy: m,
    pointer: vu
  };
}
const N8 = (l, Z) => l.x !== Z.x || l.y !== Z.y || l.zoom !== Z.k, by = (l) => ({
  x: l.x,
  y: l.y,
  zoom: l.k
}), PK = ({ x: l, y: Z, zoom: u }) => qh.translate(l, Z).scale(u), Ei = (l, Z) => l.target.closest(`.${Z}`), rC = (l, Z) => Z === 2 && Array.isArray(l) && l.includes(2), OK = (l, Z = 0, u = () => {
}) => {
  const s = typeof Z == "number" && Z > 0;
  return s || u(), s ? l.transition().duration(Z).on("end", u) : l;
}, FC = (l) => {
  const Z = l.ctrlKey && kh() ? 10 : 1;
  return -l.deltaY * (l.deltaMode === 1 ? 0.05 : l.deltaMode ? 1 : 2e-3) * Z;
};
function w8({ zoomPanValues: l, noWheelClassName: Z, d3Selection: u, d3Zoom: s, panOnScrollMode: G, panOnScrollSpeed: i, zoomOnPinch: m, onPanZoomStart: a, onPanZoom: n, onPanZoomEnd: p }) {
  return (y) => {
    if (Ei(y, Z))
      return !1;
    y.preventDefault(), y.stopImmediatePropagation();
    const h = u.property("__zoom").k || 1;
    if (y.ctrlKey && m) {
      const R = vu(y), x = FC(y), r = h * Math.pow(2, x);
      s.scaleTo(u, r, R, y);
      return;
    }
    const S = y.deltaMode === 1 ? 20 : 1;
    let t = G === hm.Vertical ? 0 : y.deltaX * S, W = G === hm.Horizontal ? 0 : y.deltaY * S;
    !kh() && y.shiftKey && G !== hm.Vertical && (t = y.deltaY * S, W = 0), s.translateBy(
      u,
      -(t / h) * i,
      -(W / h) * i,
      // @ts-ignore
      { internal: !0 }
    );
    const V = by(u.property("__zoom"));
    clearTimeout(l.panScrollTimeout), l.isPanScrolling || (l.isPanScrolling = !0, a == null || a(y, V)), l.isPanScrolling && (n == null || n(y, V), l.panScrollTimeout = setTimeout(() => {
      p == null || p(y, V), l.isPanScrolling = !1;
    }, 150));
  };
}
function z8({ noWheelClassName: l, preventScrolling: Z, d3ZoomHandler: u }) {
  return function(s, G) {
    if (!Z && s.type === "wheel" && !s.ctrlKey || Ei(s, l))
      return null;
    s.preventDefault(), u.call(this, s, G);
  };
}
function J8({ zoomPanValues: l, onDraggingChange: Z, onPanZoomStart: u }) {
  return (s) => {
    var i, m, a;
    if ((i = s.sourceEvent) != null && i.internal)
      return;
    const G = by(s.transform);
    l.mouseButton = ((m = s.sourceEvent) == null ? void 0 : m.button) || 0, l.isZoomingOrPanning = !0, l.prevViewport = G, ((a = s.sourceEvent) == null ? void 0 : a.type) === "mousedown" && Z(!0), u && (u == null || u(s.sourceEvent, G));
  };
}
function H8({ zoomPanValues: l, panOnDrag: Z, onPaneContextMenu: u, onTransformChange: s, onPanZoom: G }) {
  return (i) => {
    var m, a;
    l.usedRightMouseButton = !!(u && rC(Z, l.mouseButton ?? 0)), (m = i.sourceEvent) != null && m.sync || s([i.transform.x, i.transform.y, i.transform.k]), G && !((a = i.sourceEvent) != null && a.internal) && (G == null || G(i.sourceEvent, by(i.transform)));
  };
}
function g8({ zoomPanValues: l, panOnDrag: Z, panOnScroll: u, onDraggingChange: s, onPanZoomEnd: G, onPaneContextMenu: i }) {
  return (m) => {
    var a;
    if (!((a = m.sourceEvent) != null && a.internal) && (l.isZoomingOrPanning = !1, i && rC(Z, l.mouseButton ?? 0) && !l.usedRightMouseButton && m.sourceEvent && i(m.sourceEvent), l.usedRightMouseButton = !1, s(!1), G && N8(l.prevViewport, m.transform))) {
      const n = by(m.transform);
      l.prevViewport = n, clearTimeout(l.timerId), l.timerId = setTimeout(
        () => {
          G == null || G(m.sourceEvent, n);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        u ? 150 : 0
      );
    }
  };
}
function v8({ zoomActivationKeyPressed: l, zoomOnScroll: Z, zoomOnPinch: u, panOnDrag: s, panOnScroll: G, zoomOnDoubleClick: i, userSelectionActive: m, noWheelClassName: a, noPanClassName: n, lib: p }) {
  return (y) => {
    var W;
    const h = l || Z, S = u && y.ctrlKey;
    if (y.button === 1 && y.type === "mousedown" && (Ei(y, `${p}-flow__node`) || Ei(y, `${p}-flow__edge`)))
      return !0;
    if (!s && !h && !G && !i && !u || m || Ei(y, a) && y.type === "wheel" || Ei(y, n) && (y.type !== "wheel" || G && y.type === "wheel" && !l) || !u && y.ctrlKey && y.type === "wheel")
      return !1;
    if (!u && y.type === "touchstart" && ((W = y.touches) == null ? void 0 : W.length) > 1)
      return y.preventDefault(), !1;
    if (!h && !G && !S && y.type === "wheel" || !s && (y.type === "mousedown" || y.type === "touchstart") || Array.isArray(s) && !s.includes(y.button) && y.type === "mousedown")
      return !1;
    const t = Array.isArray(s) && s.includes(y.button) || !y.button || y.button <= 1;
    return (!y.ctrlKey || y.type === "wheel") && t;
  };
}
function T8({ domNode: l, minZoom: Z, maxZoom: u, paneClickDistance: s, translateExtent: G, viewport: i, onPanZoom: m, onPanZoomStart: a, onPanZoomEnd: n, onDraggingChange: p }) {
  const y = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, h = l.getBoundingClientRect(), S = GC().clickDistance(!Bu(s) || s < 0 ? 0 : s).scaleExtent([Z, u]).translateExtent(G), t = lu(l).call(S);
  k({
    x: i.x,
    y: i.y,
    zoom: ho(i.zoom, Z, u)
  }, [
    [0, 0],
    [h.width, h.height]
  ], G);
  const W = t.on("wheel.zoom"), V = t.on("dblclick.zoom");
  S.wheelDelta(FC);
  function R(A, J) {
    return t ? new Promise((F) => {
      S == null || S.transform(OK(t, J == null ? void 0 : J.duration, () => F(!0)), A);
    }) : Promise.resolve(!1);
  }
  function x({ noWheelClassName: A, noPanClassName: J, onPaneContextMenu: F, userSelectionActive: v, panOnScroll: T, panOnDrag: f, panOnScrollMode: O, panOnScrollSpeed: _, preventScrolling: il, zoomOnPinch: Zl, zoomOnScroll: ol, zoomOnDoubleClick: Wl, zoomActivationKeyPressed: ml, lib: Rl, onTransformChange: kl }) {
    v && !y.isZoomingOrPanning && r();
    const Vl = T && !ml && !v ? w8({
      zoomPanValues: y,
      noWheelClassName: A,
      d3Selection: t,
      d3Zoom: S,
      panOnScrollMode: O,
      panOnScrollSpeed: _,
      zoomOnPinch: Zl,
      onPanZoomStart: a,
      onPanZoom: m,
      onPanZoomEnd: n
    }) : z8({
      noWheelClassName: A,
      preventScrolling: il,
      d3ZoomHandler: W
    });
    if (t.on("wheel.zoom", Vl, { passive: !1 }), !v) {
      const xl = J8({
        zoomPanValues: y,
        onDraggingChange: p,
        onPanZoomStart: a
      });
      S.on("start", xl);
      const hl = H8({
        zoomPanValues: y,
        panOnDrag: f,
        onPaneContextMenu: !!F,
        onPanZoom: m,
        onTransformChange: kl
      });
      S.on("zoom", hl);
      const cl = g8({
        zoomPanValues: y,
        panOnDrag: f,
        panOnScroll: T,
        onPaneContextMenu: F,
        onPanZoomEnd: n,
        onDraggingChange: p
      });
      S.on("end", cl);
    }
    const el = v8({
      zoomActivationKeyPressed: ml,
      panOnDrag: f,
      zoomOnScroll: ol,
      panOnScroll: T,
      zoomOnDoubleClick: Wl,
      zoomOnPinch: Zl,
      userSelectionActive: v,
      noPanClassName: J,
      noWheelClassName: A,
      lib: Rl
    });
    S.filter(el), Wl ? t.on("dblclick.zoom", V) : t.on("dblclick.zoom", null);
  }
  function r() {
    S.on("zoom", null);
  }
  async function k(A, J, F) {
    const v = PK(A), T = S == null ? void 0 : S.constrain()(v, J, F);
    return T && await R(T), new Promise((f) => f(T));
  }
  async function U(A, J) {
    const F = PK(A);
    return await R(F, J), new Promise((v) => v(F));
  }
  function w(A) {
    if (t) {
      const J = PK(A), F = t.property("__zoom");
      (F.k !== A.zoom || F.x !== A.x || F.y !== A.y) && (S == null || S.transform(t, J, null, { sync: !0 }));
    }
  }
  function z() {
    const A = t ? dC(t.node()) : { x: 0, y: 0, k: 1 };
    return { x: A.x, y: A.y, zoom: A.k };
  }
  function D(A, J) {
    return t ? new Promise((F) => {
      S == null || S.scaleTo(OK(t, J == null ? void 0 : J.duration, () => F(!0)), A);
    }) : Promise.resolve(!1);
  }
  function C(A, J) {
    return t ? new Promise((F) => {
      S == null || S.scaleBy(OK(t, J == null ? void 0 : J.duration, () => F(!0)), A);
    }) : Promise.resolve(!1);
  }
  function j(A) {
    S == null || S.scaleExtent(A);
  }
  function E(A) {
    S == null || S.translateExtent(A);
  }
  function g(A) {
    const J = !Bu(A) || A < 0 ? 0 : A;
    S == null || S.clickDistance(J);
  }
  return {
    update: x,
    destroy: r,
    setViewport: U,
    setViewportConstrained: k,
    getViewport: z,
    scaleTo: D,
    scaleBy: C,
    setScaleExtent: j,
    setTranslateExtent: E,
    syncViewport: w,
    setClickDistance: g
  };
}
var wa;
(function(l) {
  l.Line = "line", l.Handle = "handle";
})(wa || (wa = {}));
function f8({ width: l, prevWidth: Z, height: u, prevHeight: s, affectsX: G, affectsY: i }) {
  const m = l - Z, a = u - s, n = [m > 0 ? 1 : m < 0 ? -1 : 0, a > 0 ? 1 : a < 0 ? -1 : 0];
  return m && G && (n[0] = n[0] * -1), a && i && (n[1] = n[1] * -1), n;
}
function E8(l) {
  const Z = l.includes("right") || l.includes("left"), u = l.includes("bottom") || l.includes("top"), s = l.includes("left"), G = l.includes("top");
  return {
    isHorizontal: Z,
    isVertical: u,
    affectsX: s,
    affectsY: G
  };
}
function ZG(l, Z) {
  return Math.max(0, Z - l);
}
function cG(l, Z) {
  return Math.max(0, l - Z);
}
function _L(l, Z, u) {
  return Math.max(0, Z - l, l - u);
}
function XM(l, Z) {
  return l ? !Z : Z;
}
function B8(l, Z, u, s, G, i, m, a) {
  let { affectsX: n, affectsY: p } = Z;
  const { isHorizontal: y, isVertical: h } = Z, S = y && h, { xSnapped: t, ySnapped: W } = u, { minWidth: V, maxWidth: R, minHeight: x, maxHeight: r } = s, { x: k, y: U, width: w, height: z, aspectRatio: D } = l;
  let C = Math.floor(y ? t - l.pointerX : 0), j = Math.floor(h ? W - l.pointerY : 0);
  const E = w + (n ? -C : C), g = z + (p ? -j : j), A = -i[0] * w, J = -i[1] * z;
  let F = _L(E, V, R), v = _L(g, x, r);
  if (m) {
    let O = 0, _ = 0;
    n && C < 0 ? O = ZG(k + C + A, m[0][0]) : !n && C > 0 && (O = cG(k + E + A, m[1][0])), p && j < 0 ? _ = ZG(U + j + J, m[0][1]) : !p && j > 0 && (_ = cG(U + g + J, m[1][1])), F = Math.max(F, O), v = Math.max(v, _);
  }
  if (a) {
    let O = 0, _ = 0;
    n && C > 0 ? O = cG(k + C, a[0][0]) : !n && C < 0 && (O = ZG(k + E, a[1][0])), p && j > 0 ? _ = cG(U + j, a[0][1]) : !p && j < 0 && (_ = ZG(U + g, a[1][1])), F = Math.max(F, O), v = Math.max(v, _);
  }
  if (G) {
    if (y) {
      const O = _L(E / D, x, r) * D;
      if (F = Math.max(F, O), m) {
        let _ = 0;
        !n && !p || n && !p && S ? _ = cG(U + J + E / D, m[1][1]) * D : _ = ZG(U + J + (n ? C : -C) / D, m[0][1]) * D, F = Math.max(F, _);
      }
      if (a) {
        let _ = 0;
        !n && !p || n && !p && S ? _ = ZG(U + E / D, a[1][1]) * D : _ = cG(U + (n ? C : -C) / D, a[0][1]) * D, F = Math.max(F, _);
      }
    }
    if (h) {
      const O = _L(g * D, V, R) / D;
      if (v = Math.max(v, O), m) {
        let _ = 0;
        !n && !p || p && !n && S ? _ = cG(k + g * D + A, m[1][0]) / D : _ = ZG(k + (p ? j : -j) * D + A, m[0][0]) / D, v = Math.max(v, _);
      }
      if (a) {
        let _ = 0;
        !n && !p || p && !n && S ? _ = ZG(k + g * D, a[1][0]) / D : _ = cG(k + (p ? j : -j) * D, a[0][0]) / D, v = Math.max(v, _);
      }
    }
  }
  j = j + (j < 0 ? v : -v), C = C + (C < 0 ? F : -F), G && (S ? E > g * D ? j = (XM(n, p) ? -C : C) / D : C = (XM(n, p) ? -j : j) * D : y ? (j = C / D, p = n) : (C = j * D, n = p));
  const T = n ? k + C : k, f = p ? U + j : U;
  return {
    width: w + (n ? -C : C),
    height: z + (p ? -j : j),
    x: i[0] * C * (n ? -1 : 1) + T,
    y: i[1] * j * (p ? -1 : 1) + f
  };
}
const NC = { width: 0, height: 0, x: 0, y: 0 }, D8 = {
  ...NC,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function j8(l) {
  return [
    [0, 0],
    [l.measured.width, l.measured.height]
  ];
}
function Q8(l, Z, u) {
  const s = Z.position.x + l.position.x, G = Z.position.y + l.position.y, i = l.measured.width ?? 0, m = l.measured.height ?? 0, a = u[0] * i, n = u[1] * m;
  return [
    [s - a, G - n],
    [s + i - a, G + m - n]
  ];
}
function P8({ domNode: l, nodeId: Z, getStoreItems: u, onChange: s, onEnd: G }) {
  const i = lu(l);
  function m({ controlPosition: n, boundaries: p, keepAspectRatio: y, onResizeStart: h, onResize: S, onResizeEnd: t, shouldResize: W }) {
    let V = { ...NC }, R = { ...D8 };
    const x = E8(n);
    let r, k = [], U, w, z;
    const D = xU().on("start", (C) => {
      const { nodeLookup: j, transform: E, snapGrid: g, snapToGrid: A, nodeOrigin: J } = u();
      if (r = j.get(Z), !r)
        return;
      const { xSnapped: F, ySnapped: v } = Na(C.sourceEvent, { transform: E, snapGrid: g, snapToGrid: A });
      V = {
        width: r.measured.width ?? 0,
        height: r.measured.height ?? 0,
        x: r.position.x ?? 0,
        y: r.position.y ?? 0
      }, R = {
        ...V,
        pointerX: F,
        pointerY: v,
        aspectRatio: V.width / V.height
      }, U = void 0, r.parentId && (r.extent === "parent" || r.expandParent) && (U = j.get(r.parentId), w = U && r.extent === "parent" ? j8(U) : void 0), k = [], z = void 0;
      for (const [T, f] of j)
        if (f.parentId === Z && (k.push({
          id: T,
          position: { ...f.position },
          extent: f.extent
        }), f.extent === "parent" || f.expandParent)) {
          const O = Q8(f, r, f.origin ?? J);
          z ? z = [
            [Math.min(O[0][0], z[0][0]), Math.min(O[0][1], z[0][1])],
            [Math.max(O[1][0], z[1][0]), Math.max(O[1][1], z[1][1])]
          ] : z = O;
        }
      h == null || h(C, { ...V });
    }).on("drag", (C) => {
      const { transform: j, snapGrid: E, snapToGrid: g, nodeOrigin: A } = u(), J = Na(C.sourceEvent, { transform: j, snapGrid: E, snapToGrid: g }), F = [];
      if (!r)
        return;
      const { x: v, y: T, width: f, height: O } = V, _ = {}, il = r.origin ?? A, { width: Zl, height: ol, x: Wl, y: ml } = B8(R, x, J, p, y, il, w, z), Rl = Zl !== f, kl = ol !== O, zl = Wl !== v && Rl, Vl = ml !== T && kl;
      if (!zl && !Vl && !Rl && !kl)
        return;
      if ((zl || Vl || il[0] === 1 || il[1] === 1) && (_.x = zl ? Wl : V.x, _.y = Vl ? ml : V.y, V.x = _.x, V.y = _.y, k.length > 0)) {
        const cl = Wl - v, wl = ml - T;
        for (const Jl of k)
          Jl.position = {
            x: Jl.position.x - cl + il[0] * (Zl - f),
            y: Jl.position.y - wl + il[1] * (ol - O)
          }, F.push(Jl);
      }
      if ((Rl || kl) && (_.width = Rl ? Zl : V.width, _.height = kl ? ol : V.height, V.width = _.width, V.height = _.height), U && r.expandParent) {
        const cl = il[0] * (_.width ?? 0);
        _.x && _.x < cl && (V.x = cl, R.x = R.x - (_.x - cl));
        const wl = il[1] * (_.height ?? 0);
        _.y && _.y < wl && (V.y = wl, R.y = R.y - (_.y - wl));
      }
      const el = f8({
        width: V.width,
        prevWidth: f,
        height: V.height,
        prevHeight: O,
        affectsX: x.affectsX,
        affectsY: x.affectsY
      }), xl = { ...V, direction: el };
      (W == null ? void 0 : W(C, xl)) !== !1 && (S == null || S(C, xl), s(_, F));
    }).on("end", (C) => {
      t == null || t(C, { ...V }), G == null || G();
    });
    i.call(D);
  }
  function a() {
    i.on(".drag", null);
  }
  return {
    update: m,
    destroy: a
  };
}
var wC = { exports: {} }, AK = {}, KM;
function O8() {
  if (KM) return AK;
  KM = 1;
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var l = M, Z = s1();
    function u(y, h) {
      return y === h && (y !== 0 || 1 / y === 1 / h) || y !== y && h !== h;
    }
    var s = typeof Object.is == "function" ? Object.is : u, G = Z.useSyncExternalStore, i = l.useRef, m = l.useEffect, a = l.useMemo, n = l.useDebugValue;
    function p(y, h, S, t, W) {
      var V = i(null), R;
      V.current === null ? (R = {
        hasValue: !1,
        value: null
      }, V.current = R) : R = V.current;
      var x = a(function() {
        var w = !1, z, D, C = function(A) {
          if (!w) {
            w = !0, z = A;
            var J = t(A);
            if (W !== void 0 && R.hasValue) {
              var F = R.value;
              if (W(F, J))
                return D = F, F;
            }
            return D = J, J;
          }
          var v = z, T = D;
          if (s(v, A))
            return T;
          var f = t(A);
          return W !== void 0 && W(T, f) ? T : (z = A, D = f, f);
        }, j = S === void 0 ? null : S, E = function() {
          return C(h());
        }, g = j === null ? void 0 : function() {
          return C(j());
        };
        return [E, g];
      }, [h, S, t, W]), r = x[0], k = x[1], U = G(y, r, k);
      return m(function() {
        R.hasValue = !0, R.value = U;
      }, [U]), n(U), U;
    }
    AK.useSyncExternalStoreWithSelector = p, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), AK;
}
wC.exports = O8();
var A8 = wC.exports;
const $8 = /* @__PURE__ */ wh(A8), q8 = { BASE_URL: "./", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, WM = (l) => {
  let Z;
  const u = /* @__PURE__ */ new Set(), s = (y, h) => {
    const S = typeof y == "function" ? y(Z) : y;
    if (!Object.is(S, Z)) {
      const t = Z;
      Z = h ?? (typeof S != "object" || S === null) ? S : Object.assign({}, Z, S), u.forEach((W) => W(Z, t));
    }
  }, G = () => Z, n = { setState: s, getState: G, getInitialState: () => p, subscribe: (y) => (u.add(y), () => u.delete(y)), destroy: () => {
    (q8 ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), u.clear();
  } }, p = Z = l(s, G, n);
  return n;
}, _8 = (l) => l ? WM(l) : WM, { useDebugValue: lO } = tl, { useSyncExternalStoreWithSelector: ZO } = $8, cO = (l) => l;
function zC(l, Z = cO, u) {
  const s = ZO(
    l.subscribe,
    l.getState,
    l.getServerState || l.getInitialState,
    Z,
    u
  );
  return lO(s), s;
}
const VM = (l, Z) => {
  const u = _8(l), s = (G, i = Z) => zC(u, G, i);
  return Object.assign(s, u), s;
}, bO = (l, Z) => l ? VM(l, Z) : VM;
function uc(l, Z) {
  if (Object.is(l, Z))
    return !0;
  if (typeof l != "object" || l === null || typeof Z != "object" || Z === null)
    return !1;
  if (l instanceof Map && Z instanceof Map) {
    if (l.size !== Z.size) return !1;
    for (const [s, G] of l)
      if (!Object.is(G, Z.get(s)))
        return !1;
    return !0;
  }
  if (l instanceof Set && Z instanceof Set) {
    if (l.size !== Z.size) return !1;
    for (const s of l)
      if (!Z.has(s))
        return !1;
    return !0;
  }
  const u = Object.keys(l);
  if (u.length !== Object.keys(Z).length)
    return !1;
  for (const s of u)
    if (!Object.prototype.hasOwnProperty.call(Z, s) || !Object.is(l[s], Z[s]))
      return !1;
  return !0;
}
const uy = M.createContext(null), uO = uy.Provider, JC = Sd.error001();
function yZ(l, Z) {
  const u = M.useContext(uy);
  if (u === null)
    throw new Error(JC);
  return zC(u, l, Z);
}
function lc() {
  const l = M.useContext(uy);
  if (l === null)
    throw new Error(JC);
  return M.useMemo(() => ({
    getState: l.getState,
    setState: l.setState,
    subscribe: l.subscribe
  }), [l]);
}
const xM = { display: "none" }, sO = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, HC = "react-flow__node-desc", gC = "react-flow__edge-desc", dO = "react-flow__aria-live", GO = (l) => l.ariaLiveMessage;
function mO({ rfId: l }) {
  const Z = yZ(GO);
  return B.jsx("div", { id: `${dO}-${l}`, "aria-live": "assertive", "aria-atomic": "true", style: sO, children: Z });
}
function iO({ rfId: l, disableKeyboardA11y: Z }) {
  return B.jsxs(B.Fragment, { children: [B.jsxs("div", { id: `${HC}-${l}`, style: xM, children: ["Press enter or space to select a node.", !Z && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), B.jsx("div", { id: `${gC}-${l}`, style: xM, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !Z && B.jsx(mO, { rfId: l })] });
}
const oO = (l) => l.userSelectionActive ? "none" : "all";
function Zn({ position: l = "top-left", children: Z, className: u, style: s, ...G }) {
  const i = yZ(oO), m = `${l}`.split("-");
  return B.jsx("div", { className: Lc(["react-flow__panel", u, ...m]), style: { ...s, pointerEvents: i }, ...G, children: Z });
}
function eO({ proOptions: l, position: Z = "bottom-right" }) {
  return l != null && l.hideAttribution ? null : B.jsx(Zn, { position: Z, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: B.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const aO = (l) => {
  const Z = [], u = [];
  for (const [, s] of l.nodeLookup)
    s.selected && Z.push(s.internals.userNode);
  for (const [, s] of l.edgeLookup)
    s.selected && u.push(s);
  return { selectedNodes: Z, selectedEdges: u };
}, lh = (l) => l.id;
function nO(l, Z) {
  return uc(l.selectedNodes.map(lh), Z.selectedNodes.map(lh)) && uc(l.selectedEdges.map(lh), Z.selectedEdges.map(lh));
}
function pO({ onSelectionChange: l }) {
  const Z = lc(), { selectedNodes: u, selectedEdges: s } = yZ(aO, nO);
  return M.useEffect(() => {
    const G = { nodes: u, edges: s };
    l == null || l(G), Z.getState().onSelectionChangeHandlers.forEach((i) => i(G));
  }, [u, s, l]), null;
}
const LO = (l) => !!l.onSelectionChangeHandlers;
function hO({ onSelectionChange: l }) {
  const Z = yZ(LO);
  return l || Z ? B.jsx(pO, { onSelectionChange: l }) : null;
}
const vC = [0, 0], yO = { x: 0, y: 0, zoom: 1 }, SO = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], RM = [...SO, "rfId"], tO = (l) => ({
  setNodes: l.setNodes,
  setEdges: l.setEdges,
  setMinZoom: l.setMinZoom,
  setMaxZoom: l.setMaxZoom,
  setTranslateExtent: l.setTranslateExtent,
  setNodeExtent: l.setNodeExtent,
  reset: l.reset,
  setDefaultNodesAndEdges: l.setDefaultNodesAndEdges,
  setPaneClickDistance: l.setPaneClickDistance
}), YM = {
  // these are values that are also passed directly to other components
  // than the StoreUpdater. We can reduce the number of setStore calls
  // by setting the same values here as prev fields.
  translateExtent: Aa,
  nodeOrigin: vC,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function XO(l) {
  const { setNodes: Z, setEdges: u, setMinZoom: s, setMaxZoom: G, setTranslateExtent: i, setNodeExtent: m, reset: a, setDefaultNodesAndEdges: n, setPaneClickDistance: p } = yZ(tO, uc), y = lc();
  M.useEffect(() => (n(l.defaultNodes, l.defaultEdges), () => {
    h.current = YM, a();
  }), []);
  const h = M.useRef(YM);
  return M.useEffect(
    () => {
      for (const S of RM) {
        const t = l[S], W = h.current[S];
        t !== W && (typeof l[S] > "u" || (S === "nodes" ? Z(t) : S === "edges" ? u(t) : S === "minZoom" ? s(t) : S === "maxZoom" ? G(t) : S === "translateExtent" ? i(t) : S === "nodeExtent" ? m(t) : S === "paneClickDistance" ? p(t) : S === "fitView" ? y.setState({ fitViewOnInit: t }) : S === "fitViewOptions" ? y.setState({ fitViewOnInitOptions: t }) : y.setState({ [S]: t })));
      }
      h.current = l;
    },
    // Only re-run the effect if one of the fields we track changes
    RM.map((S) => l[S])
  ), null;
}
function kM() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function KO(l) {
  var s;
  const [Z, u] = M.useState(l === "system" ? null : l);
  return M.useEffect(() => {
    if (l !== "system") {
      u(l);
      return;
    }
    const G = kM(), i = () => u(G != null && G.matches ? "dark" : "light");
    return i(), G == null || G.addEventListener("change", i), () => {
      G == null || G.removeEventListener("change", i);
    };
  }, [l]), Z !== null ? Z : (s = kM()) != null && s.matches ? "dark" : "light";
}
const MM = typeof document < "u" ? document : null;
function cn(l = null, Z = { target: MM, actInsideInputWithModifier: !0 }) {
  const [u, s] = M.useState(!1), G = M.useRef(!1), i = M.useRef(/* @__PURE__ */ new Set([])), [m, a] = M.useMemo(() => {
    if (l !== null) {
      const p = (Array.isArray(l) ? l : [l]).filter((h) => typeof h == "string").map((h) => h.split("+")), y = p.reduce((h, S) => h.concat(...S), []);
      return [p, y];
    }
    return [[], []];
  }, [l]);
  return M.useEffect(() => {
    const n = (Z == null ? void 0 : Z.target) || MM;
    if (l !== null) {
      const p = (S) => {
        if (G.current = S.ctrlKey || S.metaKey || S.shiftKey, (!G.current || G.current && !Z.actInsideInputWithModifier) && EW(S))
          return !1;
        const W = UM(S.code, a);
        i.current.add(S[W]), IM(m, i.current, !1) && (S.preventDefault(), s(!0));
      }, y = (S) => {
        if ((!G.current || G.current && !Z.actInsideInputWithModifier) && EW(S))
          return !1;
        const W = UM(S.code, a);
        IM(m, i.current, !0) ? (s(!1), i.current.clear()) : i.current.delete(S[W]), S.key === "Meta" && i.current.clear(), G.current = !1;
      }, h = () => {
        i.current.clear(), s(!1);
      };
      return n == null || n.addEventListener("keydown", p), n == null || n.addEventListener("keyup", y), window.addEventListener("blur", h), window.addEventListener("contextmenu", h), () => {
        n == null || n.removeEventListener("keydown", p), n == null || n.removeEventListener("keyup", y), window.removeEventListener("blur", h), window.removeEventListener("contextmenu", h);
      };
    }
  }, [l, s]), u;
}
function IM(l, Z, u) {
  return l.filter((s) => u || s.length === Z.size).some((s) => s.every((G) => Z.has(G)));
}
function UM(l, Z) {
  return Z.includes(l) ? "code" : "key";
}
const WO = () => {
  const l = lc();
  return M.useMemo(() => ({
    zoomIn: (Z) => {
      const { panZoom: u } = l.getState();
      return u ? u.scaleBy(1.2, { duration: Z == null ? void 0 : Z.duration }) : Promise.resolve(!1);
    },
    zoomOut: (Z) => {
      const { panZoom: u } = l.getState();
      return u ? u.scaleBy(1 / 1.2, { duration: Z == null ? void 0 : Z.duration }) : Promise.resolve(!1);
    },
    zoomTo: (Z, u) => {
      const { panZoom: s } = l.getState();
      return s ? s.scaleTo(Z, { duration: u == null ? void 0 : u.duration }) : Promise.resolve(!1);
    },
    getZoom: () => l.getState().transform[2],
    setViewport: async (Z, u) => {
      const { transform: [s, G, i], panZoom: m } = l.getState();
      return m ? (await m.setViewport({
        x: Z.x ?? s,
        y: Z.y ?? G,
        zoom: Z.zoom ?? i
      }, { duration: u == null ? void 0 : u.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [Z, u, s] = l.getState().transform;
      return { x: Z, y: u, zoom: s };
    },
    fitView: (Z) => {
      const { nodeLookup: u, minZoom: s, maxZoom: G, panZoom: i, domNode: m } = l.getState();
      if (!i || !m)
        return Promise.resolve(!1);
      const a = vW(u, Z), { width: n, height: p } = cy(m);
      return TW({
        nodes: a,
        width: n,
        height: p,
        minZoom: s,
        maxZoom: G,
        panZoom: i
      }, Z);
    },
    setCenter: async (Z, u, s) => {
      const { width: G, height: i, maxZoom: m, panZoom: a } = l.getState(), n = typeof (s == null ? void 0 : s.zoom) < "u" ? s.zoom : m, p = G / 2 - Z * n, y = i / 2 - u * n;
      return a ? (await a.setViewport({
        x: p,
        y,
        zoom: n
      }, { duration: s == null ? void 0 : s.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (Z, u) => {
      const { width: s, height: G, minZoom: i, maxZoom: m, panZoom: a } = l.getState(), n = QV(Z, s, G, i, m, (u == null ? void 0 : u.padding) ?? 0.1);
      return a ? (await a.setViewport(n, { duration: u == null ? void 0 : u.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (Z, u = { snapToGrid: !0 }) => {
      const { transform: s, snapGrid: G, domNode: i } = l.getState();
      if (!i)
        return Z;
      const { x: m, y: a } = i.getBoundingClientRect(), n = {
        x: Z.x - m,
        y: Z.y - a
      };
      return Xn(n, s, u.snapToGrid, G);
    },
    flowToScreenPosition: (Z) => {
      const { transform: u, domNode: s } = l.getState();
      if (!s)
        return Z;
      const { x: G, y: i } = s.getBoundingClientRect(), m = yC(Z, u);
      return {
        x: m.x + G,
        y: m.y + i
      };
    }
  }), []);
};
function TC(l, Z) {
  const u = [], s = /* @__PURE__ */ new Map(), G = [];
  for (const i of l)
    if (i.type === "add") {
      G.push(i);
      continue;
    } else if (i.type === "remove" || i.type === "replace")
      s.set(i.id, [i]);
    else {
      const m = s.get(i.id);
      m ? m.push(i) : s.set(i.id, [i]);
    }
  for (const i of Z) {
    const m = s.get(i.id);
    if (!m) {
      u.push(i);
      continue;
    }
    if (m[0].type === "remove")
      continue;
    if (m[0].type === "replace") {
      u.push({ ...m[0].item });
      continue;
    }
    const a = { ...i };
    for (const n of m)
      VO(n, a);
    u.push(a);
  }
  return G.length && G.forEach((i) => {
    i.index !== void 0 ? u.splice(i.index, 0, { ...i.item }) : u.push({ ...i.item });
  }), u;
}
function VO(l, Z) {
  switch (l.type) {
    case "select": {
      Z.selected = l.selected;
      break;
    }
    case "position": {
      typeof l.position < "u" && (Z.position = l.position), typeof l.dragging < "u" && (Z.dragging = l.dragging);
      break;
    }
    case "dimensions": {
      typeof l.dimensions < "u" && (Z.measured ?? (Z.measured = {}), Z.measured.width = l.dimensions.width, Z.measured.height = l.dimensions.height, l.setAttributes && (Z.width = l.dimensions.width, Z.height = l.dimensions.height)), typeof l.resizing == "boolean" && (Z.resizing = l.resizing);
      break;
    }
  }
}
function xO(l, Z) {
  return TC(l, Z);
}
function RO(l, Z) {
  return TC(l, Z);
}
function um(l, Z) {
  return {
    id: l,
    type: "select",
    selected: Z
  };
}
function Bi(l, Z = /* @__PURE__ */ new Set(), u = !1) {
  const s = [];
  for (const [G, i] of l) {
    const m = Z.has(G);
    !(i.selected === void 0 && !m) && i.selected !== m && (u && (i.selected = m), s.push(um(i.id, m)));
  }
  return s;
}
function CM({ items: l = [], lookup: Z }) {
  var G;
  const u = [], s = new Map(l.map((i) => [i.id, i]));
  for (const [i, m] of l.entries()) {
    const a = Z.get(m.id), n = ((G = a == null ? void 0 : a.internals) == null ? void 0 : G.userNode) ?? a;
    n !== void 0 && n !== m && u.push({ id: m.id, item: m, type: "replace" }), n === void 0 && u.push({ item: m, type: "add", index: i });
  }
  for (const [i] of Z)
    s.get(i) === void 0 && u.push({ id: i, type: "remove" });
  return u;
}
function rM(l) {
  return {
    id: l.id,
    type: "remove"
  };
}
const FM = (l) => b8(l), YO = (l) => eC(l);
function fC(l) {
  return M.forwardRef(l);
}
const kO = typeof window < "u" ? M.useLayoutEffect : M.useEffect;
function NM(l) {
  const [Z, u] = M.useState(!1), [s] = M.useState(() => MO(() => u(!0)));
  return kO(() => {
    if (!Z) {
      s.reset();
      return;
    }
    const G = s.get();
    G.length && (l(G), s.reset()), u(!1);
  }, [Z]), s;
}
function MO(l) {
  let Z = [];
  return {
    get: () => Z,
    reset: () => {
      Z = [];
    },
    push: (u) => {
      Z.push(u), l();
    }
  };
}
const EC = M.createContext(null);
function IO({ children: l }) {
  const Z = lc(), u = M.useCallback((a) => {
    const { nodes: n = [], setNodes: p, hasDefaultNodes: y, onNodesChange: h, nodeLookup: S } = Z.getState();
    let t = n;
    for (const W of a)
      t = typeof W == "function" ? W(t) : W;
    y ? p(t) : h && h(CM({
      items: t,
      lookup: S
    }));
  }, []), s = NM(u), G = M.useCallback((a) => {
    const { edges: n = [], setEdges: p, hasDefaultEdges: y, onEdgesChange: h, edgeLookup: S } = Z.getState();
    let t = n;
    for (const W of a)
      t = typeof W == "function" ? W(t) : W;
    y ? p(t) : h && h(CM({
      items: t,
      lookup: S
    }));
  }, []), i = NM(G), m = M.useMemo(() => ({ nodeQueue: s, edgeQueue: i }), []);
  return B.jsx(EC.Provider, { value: m, children: l });
}
function UO() {
  const l = M.useContext(EC);
  if (!l)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return l;
}
const CO = (l) => !!l.panZoom;
function sy() {
  const l = WO(), Z = lc(), u = UO(), s = yZ(CO), G = M.useMemo(() => {
    const i = (h) => Z.getState().nodeLookup.get(h), m = (h) => {
      u.nodeQueue.push(h);
    }, a = (h) => {
      u.edgeQueue.push(h);
    }, n = (h) => {
      var x, r;
      const { nodeLookup: S, nodeOrigin: t } = Z.getState(), W = FM(h) ? h : S.get(h.id), V = W.parentId ? SC(W.position, W.measured, W.parentId, S, t) : W.position, R = {
        id: W.id,
        position: V,
        width: ((x = W.measured) == null ? void 0 : x.width) ?? W.width,
        height: ((r = W.measured) == null ? void 0 : r.height) ?? W.height,
        data: W.data
      };
      return yo(R);
    }, p = (h, S, t = { replace: !1 }) => {
      m((W) => W.map((V) => {
        if (V.id === h) {
          const R = typeof S == "function" ? S(V) : S;
          return t.replace && FM(R) ? R : { ...V, ...R };
        }
        return V;
      }));
    }, y = (h, S, t = { replace: !1 }) => {
      a((W) => W.map((V) => {
        if (V.id === h) {
          const R = typeof S == "function" ? S(V) : S;
          return t.replace && YO(R) ? R : { ...V, ...R };
        }
        return V;
      }));
    };
    return {
      getNodes: () => Z.getState().nodes.map((h) => ({ ...h })),
      getNode: (h) => {
        var S;
        return (S = i(h)) == null ? void 0 : S.internals.userNode;
      },
      getInternalNode: i,
      getEdges: () => {
        const { edges: h = [] } = Z.getState();
        return h.map((S) => ({ ...S }));
      },
      getEdge: (h) => Z.getState().edgeLookup.get(h),
      setNodes: m,
      setEdges: a,
      addNodes: (h) => {
        const S = Array.isArray(h) ? h : [h];
        u.nodeQueue.push((t) => [...t, ...S]);
      },
      addEdges: (h) => {
        const S = Array.isArray(h) ? h : [h];
        u.edgeQueue.push((t) => [...t, ...S]);
      },
      toObject: () => {
        const { nodes: h = [], edges: S = [], transform: t } = Z.getState(), [W, V, R] = t;
        return {
          nodes: h.map((x) => ({ ...x })),
          edges: S.map((x) => ({ ...x })),
          viewport: {
            x: W,
            y: V,
            zoom: R
          }
        };
      },
      deleteElements: async ({ nodes: h = [], edges: S = [] }) => {
        const { nodes: t, edges: W, onNodesDelete: V, onEdgesDelete: R, triggerNodeChanges: x, triggerEdgeChanges: r, onDelete: k, onBeforeDelete: U } = Z.getState(), { nodes: w, edges: z } = await d8({
          nodesToRemove: h,
          edgesToRemove: S,
          nodes: t,
          edges: W,
          onBeforeDelete: U
        }), D = z.length > 0, C = w.length > 0;
        if (D) {
          const j = z.map(rM);
          R == null || R(z), r(j);
        }
        if (C) {
          const j = w.map(rM);
          V == null || V(w), x(j);
        }
        return (C || D) && (k == null || k({ nodes: w, edges: z })), { deletedNodes: w, deletedEdges: z };
      },
      getIntersectingNodes: (h, S = !0, t) => {
        const W = eM(h), V = W ? h : n(h), R = t !== void 0;
        return V ? (t || Z.getState().nodes).filter((x) => {
          const r = Z.getState().nodeLookup.get(x.id);
          if (r && !W && (x.id === h.id || !r.internals.positionAbsolute))
            return !1;
          const k = yo(R ? x : r), U = _a(k, V);
          return S && U > 0 || U >= V.width * V.height;
        }) : [];
      },
      isNodeIntersecting: (h, S, t = !0) => {
        const V = eM(h) ? h : n(h);
        if (!V)
          return !1;
        const R = _a(V, S);
        return t && R > 0 || R >= V.width * V.height;
      },
      updateNode: p,
      updateNodeData: (h, S, t = { replace: !1 }) => {
        p(h, (W) => {
          const V = typeof S == "function" ? S(W) : S;
          return t.replace ? { ...W, data: V } : { ...W, data: { ...W.data, ...V } };
        }, t);
      },
      updateEdge: y,
      updateEdgeData: (h, S, t = { replace: !1 }) => {
        y(h, (W) => {
          const V = typeof S == "function" ? S(W) : S;
          return t.replace ? { ...W, data: V } : { ...W, data: { ...W.data, ...V } };
        }, t);
      },
      getNodesBounds: (h) => {
        const { nodeLookup: S, nodeOrigin: t } = Z.getState();
        return u8(h, { nodeLookup: S, nodeOrigin: t });
      },
      getHandleConnections: ({ type: h, id: S, nodeId: t }) => {
        var W;
        return Array.from(((W = Z.getState().connectionLookup.get(`${t}-${h}-${S ?? null}`)) == null ? void 0 : W.values()) ?? []);
      }
    };
  }, []);
  return M.useMemo(() => ({
    ...G,
    ...l,
    viewportInitialized: s
  }), [s]);
}
const wM = (l) => l.selected, rO = { actInsideInputWithModifier: !1 }, FO = typeof window < "u" ? window : void 0;
function NO({ deleteKeyCode: l, multiSelectionKeyCode: Z }) {
  const u = lc(), { deleteElements: s } = sy(), G = cn(l, rO), i = cn(Z, { target: FO });
  M.useEffect(() => {
    if (G) {
      const { edges: m, nodes: a } = u.getState();
      s({ nodes: a.filter(wM), edges: m.filter(wM) }), u.setState({ nodesSelectionActive: !1 });
    }
  }, [G]), M.useEffect(() => {
    u.setState({ multiSelectionActive: i });
  }, [i]);
}
function wO(l) {
  const Z = lc();
  M.useEffect(() => {
    const u = () => {
      var G, i;
      if (!l.current)
        return !1;
      const s = cy(l.current);
      (s.height === 0 || s.width === 0) && ((i = (G = Z.getState()).onError) == null || i.call(G, "004", Sd.error004())), Z.setState({ width: s.width || 500, height: s.height || 500 });
    };
    if (l.current) {
      u(), window.addEventListener("resize", u);
      const s = new ResizeObserver(() => u());
      return s.observe(l.current), () => {
        window.removeEventListener("resize", u), s && l.current && s.unobserve(l.current);
      };
    }
  }, []);
}
const dy = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, zO = (l) => ({
  userSelectionActive: l.userSelectionActive,
  lib: l.lib
});
function JO({ onPaneContextMenu: l, zoomOnScroll: Z = !0, zoomOnPinch: u = !0, panOnScroll: s = !1, panOnScrollSpeed: G = 0.5, panOnScrollMode: i = hm.Free, zoomOnDoubleClick: m = !0, panOnDrag: a = !0, defaultViewport: n, translateExtent: p, minZoom: y, maxZoom: h, zoomActivationKeyCode: S, preventScrolling: t = !0, children: W, noWheelClassName: V, noPanClassName: R, onViewportChange: x, isControlledViewport: r, paneClickDistance: k }) {
  const U = lc(), w = M.useRef(null), { userSelectionActive: z, lib: D } = yZ(zO, uc), C = cn(S), j = M.useRef();
  wO(w);
  const E = M.useCallback((g) => {
    x == null || x({ x: g[0], y: g[1], zoom: g[2] }), r || U.setState({ transform: g });
  }, [x, r]);
  return M.useEffect(() => {
    if (w.current) {
      j.current = T8({
        domNode: w.current,
        minZoom: y,
        maxZoom: h,
        translateExtent: p,
        viewport: n,
        paneClickDistance: k,
        onDraggingChange: (F) => U.setState({ paneDragging: F }),
        onPanZoomStart: (F, v) => {
          const { onViewportChangeStart: T, onMoveStart: f } = U.getState();
          f == null || f(F, v), T == null || T(v);
        },
        onPanZoom: (F, v) => {
          const { onViewportChange: T, onMove: f } = U.getState();
          f == null || f(F, v), T == null || T(v);
        },
        onPanZoomEnd: (F, v) => {
          const { onViewportChangeEnd: T, onMoveEnd: f } = U.getState();
          f == null || f(F, v), T == null || T(v);
        }
      });
      const { x: g, y: A, zoom: J } = j.current.getViewport();
      return U.setState({
        panZoom: j.current,
        transform: [g, A, J],
        domNode: w.current.closest(".react-flow")
      }), () => {
        var F;
        (F = j.current) == null || F.destroy();
      };
    }
  }, []), M.useEffect(() => {
    var g;
    (g = j.current) == null || g.update({
      onPaneContextMenu: l,
      zoomOnScroll: Z,
      zoomOnPinch: u,
      panOnScroll: s,
      panOnScrollSpeed: G,
      panOnScrollMode: i,
      zoomOnDoubleClick: m,
      panOnDrag: a,
      zoomActivationKeyPressed: C,
      preventScrolling: t,
      noPanClassName: R,
      userSelectionActive: z,
      noWheelClassName: V,
      lib: D,
      onTransformChange: E
    });
  }, [
    l,
    Z,
    u,
    s,
    G,
    i,
    m,
    a,
    C,
    t,
    R,
    z,
    V,
    D,
    E
  ]), B.jsx("div", { className: "react-flow__renderer", ref: w, style: dy, children: W });
}
const HO = (l) => ({
  userSelectionActive: l.userSelectionActive,
  userSelectionRect: l.userSelectionRect
});
function gO() {
  const { userSelectionActive: l, userSelectionRect: Z } = yZ(HO, uc);
  return l && Z ? B.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: Z.width,
    height: Z.height,
    transform: `translate(${Z.x}px, ${Z.y}px)`
  } }) : null;
}
const $K = (l, Z) => (u) => {
  u.target === Z.current && (l == null || l(u));
}, vO = (l) => ({
  userSelectionActive: l.userSelectionActive,
  elementsSelectable: l.elementsSelectable,
  dragging: l.paneDragging
});
function TO({ isSelecting: l, selectionKeyPressed: Z, selectionMode: u = $a.Full, panOnDrag: s, selectionOnDrag: G, onSelectionStart: i, onSelectionEnd: m, onPaneClick: a, onPaneContextMenu: n, onPaneScroll: p, onPaneMouseEnter: y, onPaneMouseMove: h, onPaneMouseLeave: S, children: t }) {
  const W = M.useRef(null), V = lc(), R = M.useRef(0), x = M.useRef(0), r = M.useRef(), k = M.useRef(/* @__PURE__ */ new Map()), { userSelectionActive: U, elementsSelectable: w, dragging: z } = yZ(vO, uc), D = w && (l || U), C = M.useRef(!1), j = M.useRef(!1), E = () => {
    V.setState({ userSelectionActive: !1, userSelectionRect: null }), R.current = 0, x.current = 0;
  }, g = (O) => {
    if (C.current) {
      C.current = !1;
      return;
    }
    a == null || a(O), V.getState().resetSelectedElements(), V.setState({ nodesSelectionActive: !1 });
  }, A = (O) => {
    if (Array.isArray(s) && (s != null && s.includes(2))) {
      O.preventDefault();
      return;
    }
    n == null || n(O);
  }, J = p ? (O) => p(O) : void 0, F = (O) => {
    var ml, Rl, kl, zl;
    const { resetSelectedElements: _, domNode: il, edgeLookup: Zl } = V.getState();
    if (r.current = il == null ? void 0 : il.getBoundingClientRect(), !w || !l || O.button !== 0 || O.target !== W.current || !r.current)
      return;
    (Rl = (ml = O.target) == null ? void 0 : ml.setPointerCapture) == null || Rl.call(ml, O.pointerId), j.current = !0, C.current = !1, k.current = /* @__PURE__ */ new Map();
    for (const [Vl, el] of Zl)
      k.current.set(el.source, ((kl = k.current.get(el.source)) == null ? void 0 : kl.add(Vl)) || /* @__PURE__ */ new Set([Vl])), k.current.set(el.target, ((zl = k.current.get(el.target)) == null ? void 0 : zl.add(Vl)) || /* @__PURE__ */ new Set([Vl]));
    const { x: ol, y: Wl } = ed(O.nativeEvent, r.current);
    _(), V.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: ol,
        startY: Wl,
        x: ol,
        y: Wl
      }
    }), i == null || i(O);
  }, v = (O) => {
    const { userSelectionRect: _, edgeLookup: il, transform: Zl, nodeLookup: ol, triggerNodeChanges: Wl, triggerEdgeChanges: ml } = V.getState();
    if (!r.current || !_)
      return;
    C.current = !0;
    const { x: Rl, y: kl } = ed(O.nativeEvent, r.current), { startX: zl, startY: Vl } = _, el = {
      startX: zl,
      startY: Vl,
      x: Rl < zl ? Rl : zl,
      y: kl < Vl ? kl : Vl,
      width: Math.abs(Rl - zl),
      height: Math.abs(kl - Vl)
    }, xl = aC(ol, el, Zl, u === $a.Partial, !0), hl = /* @__PURE__ */ new Set(), cl = /* @__PURE__ */ new Set();
    for (const wl of xl) {
      cl.add(wl.id);
      const Jl = k.current.get(wl.id);
      if (Jl)
        for (const cZ of Jl)
          hl.add(cZ);
    }
    if (R.current !== cl.size) {
      R.current = cl.size;
      const wl = Bi(ol, cl, !0);
      Wl(wl);
    }
    if (x.current !== hl.size) {
      x.current = hl.size;
      const wl = Bi(il, hl);
      ml(wl);
    }
    V.setState({
      userSelectionRect: el,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, T = (O) => {
    var il, Zl;
    if (O.button !== 0 || !j.current)
      return;
    (Zl = (il = O.target) == null ? void 0 : il.releasePointerCapture) == null || Zl.call(il, O.pointerId);
    const { userSelectionRect: _ } = V.getState();
    !U && _ && O.target === W.current && (g == null || g(O)), R.current > 0 && V.setState({ nodesSelectionActive: !0 }), E(), m == null || m(O), (Z || G) && (C.current = !1), j.current = !1;
  }, f = s === !0 || Array.isArray(s) && s.includes(0);
  return B.jsxs("div", { className: Lc(["react-flow__pane", { draggable: f, dragging: z, selection: l }]), onClick: D ? void 0 : $K(g, W), onContextMenu: $K(A, W), onWheel: $K(J, W), onPointerEnter: D ? void 0 : y, onPointerDown: D ? F : h, onPointerMove: D ? v : h, onPointerUp: D ? T : void 0, onPointerLeave: S, ref: W, style: dy, children: [t, B.jsx(gO, {})] });
}
function PW({ id: l, store: Z, unselect: u = !1, nodeRef: s }) {
  const { addSelectedNodes: G, unselectNodesAndEdges: i, multiSelectionActive: m, nodeLookup: a, onError: n } = Z.getState(), p = a.get(l);
  if (!p) {
    n == null || n("012", Sd.error012(l));
    return;
  }
  Z.setState({ nodesSelectionActive: !1 }), p.selected ? (u || p.selected && m) && (i({ nodes: [p], edges: [] }), requestAnimationFrame(() => {
    var y;
    return (y = s == null ? void 0 : s.current) == null ? void 0 : y.blur();
  })) : G([l]);
}
function BC({ nodeRef: l, disabled: Z = !1, noDragClassName: u, handleSelector: s, nodeId: G, isSelectable: i, nodeClickDistance: m }) {
  const a = lc(), [n, p] = M.useState(!1), y = M.useRef();
  return M.useEffect(() => {
    y.current = k8({
      getStoreItems: () => a.getState(),
      onNodeMouseDown: (h) => {
        PW({
          id: h,
          store: a,
          nodeRef: l
        });
      },
      onDragStart: () => {
        p(!0);
      },
      onDragStop: () => {
        p(!1);
      }
    });
  }, []), M.useEffect(() => {
    var h, S;
    if (Z)
      (h = y.current) == null || h.destroy();
    else if (l.current)
      return (S = y.current) == null || S.update({
        noDragClassName: u,
        handleSelector: s,
        domNode: l.current,
        isSelectable: i,
        nodeId: G,
        nodeClickDistance: m
      }), () => {
        var t;
        (t = y.current) == null || t.destroy();
      };
  }, [u, s, Z, i, l, G]), n;
}
const fO = (l) => (Z) => Z.selected && (Z.draggable || l && typeof Z.draggable > "u");
function DC() {
  const l = lc();
  return M.useCallback((u) => {
    const { nodeExtent: s, snapToGrid: G, snapGrid: i, nodesDraggable: m, onError: a, updateNodePositions: n, nodeLookup: p, nodeOrigin: y } = l.getState(), h = /* @__PURE__ */ new Map(), S = fO(m), t = G ? i[0] : 5, W = G ? i[1] : 5, V = u.direction.x * t * u.factor, R = u.direction.y * W * u.factor;
    for (const [, x] of p) {
      if (!S(x))
        continue;
      let r = {
        x: x.internals.positionAbsolute.x + V,
        y: x.internals.positionAbsolute.y + R
      };
      G && (r = Zy(r, i));
      const { position: k, positionAbsolute: U } = nC({
        nodeId: x.id,
        nextPosition: r,
        nodeLookup: p,
        nodeExtent: s,
        nodeOrigin: y,
        onError: a
      });
      x.position = k, x.internals.positionAbsolute = U, h.set(x.id, x);
    }
    n(h);
  }, []);
}
const _V = M.createContext(null), EO = _V.Provider;
_V.Consumer;
const lx = () => M.useContext(_V), BO = (l) => ({
  connectOnClick: l.connectOnClick,
  noPanClassName: l.noPanClassName,
  rfId: l.rfId
}), DO = (l, Z, u) => (s) => {
  const { connectionClickStartHandle: G, connectionMode: i, connection: m } = s, { fromHandle: a, toHandle: n, isValid: p } = m, y = (n == null ? void 0 : n.nodeId) === l && (n == null ? void 0 : n.id) === Z && (n == null ? void 0 : n.type) === u;
  return {
    connectingFrom: (a == null ? void 0 : a.nodeId) === l && (a == null ? void 0 : a.id) === Z && (a == null ? void 0 : a.type) === u,
    connectingTo: y,
    clickConnecting: (G == null ? void 0 : G.nodeId) === l && (G == null ? void 0 : G.id) === Z && (G == null ? void 0 : G.type) === u,
    isPossibleEndHandle: i === Lo.Strict ? (a == null ? void 0 : a.type) !== u : l !== (a == null ? void 0 : a.nodeId) || Z !== (a == null ? void 0 : a.id),
    connectionInProcess: !!a,
    valid: y && p
  };
};
function jO({ type: l = "source", position: Z = Tl.Top, isValidConnection: u, isConnectable: s = !0, isConnectableStart: G = !0, isConnectableEnd: i = !0, id: m, onConnect: a, children: n, className: p, onMouseDown: y, onTouchStart: h, ...S }, t) {
  var F, v;
  const W = m || null, V = l === "target", R = lc(), x = lx(), { connectOnClick: r, noPanClassName: k, rfId: U } = yZ(BO, uc), { connectingFrom: w, connectingTo: z, clickConnecting: D, isPossibleEndHandle: C, connectionInProcess: j, valid: E } = yZ(DO(x, W, l), uc);
  x || (v = (F = R.getState()).onError) == null || v.call(F, "010", Sd.error010());
  const g = (T) => {
    const { defaultEdgeOptions: f, onConnect: O, hasDefaultEdges: _ } = R.getState(), il = {
      ...f,
      ...T
    };
    if (_) {
      const { edges: Zl, setEdges: ol } = R.getState();
      ol(n8(il, Zl));
    }
    O == null || O(il), a == null || a(il);
  }, A = (T) => {
    if (!x)
      return;
    const f = XC(T.nativeEvent);
    if (G && (f && T.button === 0 || !f)) {
      const O = R.getState();
      QW.onPointerDown(T.nativeEvent, {
        autoPanOnConnect: O.autoPanOnConnect,
        connectionMode: O.connectionMode,
        connectionRadius: O.connectionRadius,
        domNode: O.domNode,
        nodeLookup: O.nodeLookup,
        lib: O.lib,
        isTarget: V,
        handleId: W,
        nodeId: x,
        flowId: O.rfId,
        panBy: O.panBy,
        cancelConnection: O.cancelConnection,
        onConnectStart: O.onConnectStart,
        onConnectEnd: O.onConnectEnd,
        updateConnection: O.updateConnection,
        onConnect: g,
        isValidConnection: u || O.isValidConnection,
        getTransform: () => R.getState().transform,
        getFromHandle: () => R.getState().connection.fromHandle,
        autoPanSpeed: O.autoPanSpeed
      });
    }
    f ? y == null || y(T) : h == null || h(T);
  }, J = (T) => {
    const { onClickConnectStart: f, onClickConnectEnd: O, connectionClickStartHandle: _, connectionMode: il, isValidConnection: Zl, lib: ol, rfId: Wl, nodeLookup: ml, connection: Rl } = R.getState();
    if (!x || !_ && !G)
      return;
    if (!_) {
      f == null || f(T.nativeEvent, { nodeId: x, handleId: W, handleType: l }), R.setState({ connectionClickStartHandle: { nodeId: x, type: l, id: W } });
      return;
    }
    const kl = tC(T.target), zl = u || Zl, { connection: Vl, isValid: el } = QW.isValid(T.nativeEvent, {
      handle: {
        nodeId: x,
        id: W,
        type: l
      },
      connectionMode: il,
      fromNodeId: _.nodeId,
      fromHandleId: _.id || null,
      fromType: _.type,
      isValidConnection: zl,
      flowId: Wl,
      doc: kl,
      lib: ol,
      nodeLookup: ml
    });
    el && Vl && g(Vl);
    const xl = structuredClone(Rl);
    delete xl.inProgress, xl.toPosition = xl.toHandle ? xl.toHandle.position : null, O == null || O(T, xl), R.setState({ connectionClickStartHandle: null });
  };
  return B.jsx("div", { "data-handleid": W, "data-nodeid": x, "data-handlepos": Z, "data-id": `${U}-${x}-${W}-${l}`, className: Lc([
    "react-flow__handle",
    `react-flow__handle-${Z}`,
    "nodrag",
    k,
    p,
    {
      source: !V,
      target: V,
      connectable: s,
      connectablestart: G,
      connectableend: i,
      clickconnecting: D,
      connectingfrom: w,
      connectingto: z,
      valid: E,
      // shows where you can start a connection from
      // and where you can end it while connecting
      connectionindicator: s && (!j || C) && (j ? i : G)
    }
  ]), onMouseDown: A, onTouchStart: A, onClick: r ? J : void 0, ref: t, ...S, children: n });
}
const Rm = M.memo(fC(jO));
function QO({ data: l, isConnectable: Z, sourcePosition: u = Tl.Bottom }) {
  return B.jsxs(B.Fragment, { children: [l == null ? void 0 : l.label, B.jsx(Rm, { type: "source", position: u, isConnectable: Z })] });
}
function PO({ data: l, isConnectable: Z, targetPosition: u = Tl.Top, sourcePosition: s = Tl.Bottom }) {
  return B.jsxs(B.Fragment, { children: [B.jsx(Rm, { type: "target", position: u, isConnectable: Z }), l == null ? void 0 : l.label, B.jsx(Rm, { type: "source", position: s, isConnectable: Z })] });
}
function OO() {
  return null;
}
function AO({ data: l, isConnectable: Z, targetPosition: u = Tl.Top }) {
  return B.jsxs(B.Fragment, { children: [B.jsx(Rm, { type: "target", position: u, isConnectable: Z }), l == null ? void 0 : l.label] });
}
const Mh = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, zM = {
  input: QO,
  default: PO,
  output: AO,
  group: OO
};
function $O(l) {
  var Z, u, s, G;
  return l.internals.handleBounds === void 0 ? {
    width: l.width ?? l.initialWidth ?? ((Z = l.style) == null ? void 0 : Z.width),
    height: l.height ?? l.initialHeight ?? ((u = l.style) == null ? void 0 : u.height)
  } : {
    width: l.width ?? ((s = l.style) == null ? void 0 : s.width),
    height: l.height ?? ((G = l.style) == null ? void 0 : G.height)
  };
}
const qO = (l) => {
  const { width: Z, height: u, x: s, y: G } = Mo(l.nodeLookup, {
    filter: (i) => !!i.selected
  });
  return {
    width: Bu(Z) ? Z : null,
    height: Bu(u) ? u : null,
    userSelectionActive: l.userSelectionActive,
    transformString: `translate(${l.transform[0]}px,${l.transform[1]}px) scale(${l.transform[2]}) translate(${s}px,${G}px)`
  };
};
function _O({ onSelectionContextMenu: l, noPanClassName: Z, disableKeyboardA11y: u }) {
  const s = lc(), { width: G, height: i, transformString: m, userSelectionActive: a } = yZ(qO, uc), n = DC(), p = M.useRef(null);
  if (M.useEffect(() => {
    var S;
    u || (S = p.current) == null || S.focus({
      preventScroll: !0
    });
  }, [u]), BC({
    nodeRef: p
  }), a || !G || !i)
    return null;
  const y = l ? (S) => {
    const t = s.getState().nodes.filter((W) => W.selected);
    l(S, t);
  } : void 0, h = (S) => {
    Object.prototype.hasOwnProperty.call(Mh, S.key) && n({
      direction: Mh[S.key],
      factor: S.shiftKey ? 4 : 1
    });
  };
  return B.jsx("div", { className: Lc(["react-flow__nodesselection", "react-flow__container", Z]), style: {
    transform: m
  }, children: B.jsx("div", { ref: p, className: "react-flow__nodesselection-rect", onContextMenu: y, tabIndex: u ? void 0 : -1, onKeyDown: u ? void 0 : h, style: {
    width: G,
    height: i
  } }) });
}
const JM = typeof window < "u" ? window : void 0, lA = (l) => ({ nodesSelectionActive: l.nodesSelectionActive, userSelectionActive: l.userSelectionActive });
function jC({ children: l, onPaneClick: Z, onPaneMouseEnter: u, onPaneMouseMove: s, onPaneMouseLeave: G, onPaneContextMenu: i, onPaneScroll: m, paneClickDistance: a, deleteKeyCode: n, selectionKeyCode: p, selectionOnDrag: y, selectionMode: h, onSelectionStart: S, onSelectionEnd: t, multiSelectionKeyCode: W, panActivationKeyCode: V, zoomActivationKeyCode: R, elementsSelectable: x, zoomOnScroll: r, zoomOnPinch: k, panOnScroll: U, panOnScrollSpeed: w, panOnScrollMode: z, zoomOnDoubleClick: D, panOnDrag: C, defaultViewport: j, translateExtent: E, minZoom: g, maxZoom: A, preventScrolling: J, onSelectionContextMenu: F, noWheelClassName: v, noPanClassName: T, disableKeyboardA11y: f, onViewportChange: O, isControlledViewport: _ }) {
  const { nodesSelectionActive: il, userSelectionActive: Zl } = yZ(lA), ol = cn(p, { target: JM }), Wl = cn(V, { target: JM }), ml = Wl || C, Rl = Wl || U, kl = y && ml !== !0, zl = ol || Zl || kl;
  return NO({ deleteKeyCode: n, multiSelectionKeyCode: W }), B.jsx(JO, { onPaneContextMenu: i, elementsSelectable: x, zoomOnScroll: r, zoomOnPinch: k, panOnScroll: Rl, panOnScrollSpeed: w, panOnScrollMode: z, zoomOnDoubleClick: D, panOnDrag: !ol && ml, defaultViewport: j, translateExtent: E, minZoom: g, maxZoom: A, zoomActivationKeyCode: R, preventScrolling: J, noWheelClassName: v, noPanClassName: T, onViewportChange: O, isControlledViewport: _, paneClickDistance: a, children: B.jsxs(TO, { onSelectionStart: S, onSelectionEnd: t, onPaneClick: Z, onPaneMouseEnter: u, onPaneMouseMove: s, onPaneMouseLeave: G, onPaneContextMenu: i, onPaneScroll: m, panOnDrag: ml, isSelecting: !!zl, selectionMode: h, selectionKeyPressed: ol, selectionOnDrag: kl, children: [l, il && B.jsx(_O, { onSelectionContextMenu: F, noPanClassName: T, disableKeyboardA11y: f })] }) });
}
jC.displayName = "FlowRenderer";
const ZA = M.memo(jC), cA = (l) => (Z) => l ? aC(Z.nodeLookup, { x: 0, y: 0, width: Z.width, height: Z.height }, Z.transform, !0).map((u) => u.id) : Array.from(Z.nodeLookup.keys());
function bA(l) {
  return yZ(M.useCallback(cA(l), [l]), uc);
}
const uA = (l) => l.updateNodeInternals;
function sA() {
  const l = yZ(uA), [Z] = M.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((u) => {
    const s = /* @__PURE__ */ new Map();
    u.forEach((G) => {
      const i = G.target.getAttribute("data-id");
      s.set(i, {
        id: i,
        nodeElement: G.target,
        force: !0
      });
    }), l(s);
  }));
  return M.useEffect(() => () => {
    Z == null || Z.disconnect();
  }, [Z]), Z;
}
function dA({ node: l, nodeType: Z, hasDimensions: u, resizeObserver: s }) {
  const G = lc(), i = M.useRef(null), m = M.useRef(null), a = M.useRef(l.sourcePosition), n = M.useRef(l.targetPosition), p = M.useRef(Z), y = u && !!l.internals.handleBounds;
  return M.useEffect(() => {
    i.current && !l.hidden && (!y || m.current !== i.current) && (m.current && (s == null || s.unobserve(m.current)), s == null || s.observe(i.current), m.current = i.current);
  }, [y, l.hidden]), M.useEffect(() => () => {
    m.current && (s == null || s.unobserve(m.current), m.current = null);
  }, []), M.useEffect(() => {
    if (i.current) {
      const h = p.current !== Z, S = a.current !== l.sourcePosition, t = n.current !== l.targetPosition;
      (h || S || t) && (p.current = Z, a.current = l.sourcePosition, n.current = l.targetPosition, G.getState().updateNodeInternals(/* @__PURE__ */ new Map([[l.id, { id: l.id, nodeElement: i.current, force: !0 }]])));
    }
  }, [l.id, Z, l.sourcePosition, l.targetPosition]), i;
}
function GA({ id: l, onClick: Z, onMouseEnter: u, onMouseMove: s, onMouseLeave: G, onContextMenu: i, onDoubleClick: m, nodesDraggable: a, elementsSelectable: n, nodesConnectable: p, nodesFocusable: y, resizeObserver: h, noDragClassName: S, noPanClassName: t, disableKeyboardA11y: W, rfId: V, nodeTypes: R, nodeExtent: x, nodeClickDistance: r, onError: k }) {
  const { node: U, internals: w, isParent: z } = yZ((Vl) => {
    const el = Vl.nodeLookup.get(l), xl = Vl.parentLookup.has(l);
    return {
      node: el,
      internals: el.internals,
      isParent: xl
    };
  }, uc);
  let D = U.type || "default", C = (R == null ? void 0 : R[D]) || zM[D];
  C === void 0 && (k == null || k("003", Sd.error003(D)), D = "default", C = zM.default);
  const j = !!(U.draggable || a && typeof U.draggable > "u"), E = !!(U.selectable || n && typeof U.selectable > "u"), g = !!(U.connectable || p && typeof U.connectable > "u"), A = !!(U.focusable || y && typeof U.focusable > "u"), J = lc(), F = PV(U), v = dA({ node: U, nodeType: D, hasDimensions: F, resizeObserver: h }), T = BC({
    nodeRef: v,
    disabled: U.hidden || !j,
    noDragClassName: S,
    handleSelector: U.dragHandle,
    nodeId: l,
    isSelectable: E,
    nodeClickDistance: r
  }), f = DC();
  if (U.hidden)
    return null;
  const O = td(U), _ = $O(U), il = E || j || Z || u || s || G, Zl = u ? (Vl) => u(Vl, { ...w.userNode }) : void 0, ol = s ? (Vl) => s(Vl, { ...w.userNode }) : void 0, Wl = G ? (Vl) => G(Vl, { ...w.userNode }) : void 0, ml = i ? (Vl) => i(Vl, { ...w.userNode }) : void 0, Rl = m ? (Vl) => m(Vl, { ...w.userNode }) : void 0, kl = (Vl) => {
    const { selectNodesOnDrag: el, nodeDragThreshold: xl } = J.getState();
    E && (!el || !j || xl > 0) && PW({
      id: l,
      store: J,
      nodeRef: v
    }), Z && Z(Vl, { ...w.userNode });
  }, zl = (Vl) => {
    if (!(EW(Vl.nativeEvent) || W))
      if (mC.includes(Vl.key) && E) {
        const el = Vl.key === "Escape";
        PW({
          id: l,
          store: J,
          unselect: el,
          nodeRef: v
        });
      } else j && U.selected && Object.prototype.hasOwnProperty.call(Mh, Vl.key) && (J.setState({
        ariaLiveMessage: `Moved selected node ${Vl.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~w.positionAbsolute.x}, y: ${~~w.positionAbsolute.y}`
      }), f({
        direction: Mh[Vl.key],
        factor: Vl.shiftKey ? 4 : 1
      }));
  };
  return B.jsx("div", { className: Lc([
    "react-flow__node",
    `react-flow__node-${D}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [t]: j
    },
    U.className,
    {
      selected: U.selected,
      selectable: E,
      parent: z,
      draggable: j,
      dragging: T
    }
  ]), ref: v, style: {
    zIndex: w.z,
    transform: `translate(${w.positionAbsolute.x}px,${w.positionAbsolute.y}px)`,
    pointerEvents: il ? "all" : "none",
    visibility: F ? "visible" : "hidden",
    ...U.style,
    ..._
  }, "data-id": l, "data-testid": `rf__node-${l}`, onMouseEnter: Zl, onMouseMove: ol, onMouseLeave: Wl, onContextMenu: ml, onClick: kl, onDoubleClick: Rl, onKeyDown: A ? zl : void 0, tabIndex: A ? 0 : void 0, role: A ? "button" : void 0, "aria-describedby": W ? void 0 : `${HC}-${V}`, "aria-label": U.ariaLabel, children: B.jsx(EO, { value: l, children: B.jsx(C, { id: l, data: U.data, type: D, positionAbsoluteX: w.positionAbsolute.x, positionAbsoluteY: w.positionAbsolute.y, selected: U.selected, selectable: E, draggable: j, deletable: U.deletable ?? !0, isConnectable: g, sourcePosition: U.sourcePosition, targetPosition: U.targetPosition, dragging: T, dragHandle: U.dragHandle, zIndex: w.z, parentId: U.parentId, ...O }) }) });
}
const mA = (l) => ({
  nodesDraggable: l.nodesDraggable,
  nodesConnectable: l.nodesConnectable,
  nodesFocusable: l.nodesFocusable,
  elementsSelectable: l.elementsSelectable,
  onError: l.onError
});
function QC(l) {
  const { nodesDraggable: Z, nodesConnectable: u, nodesFocusable: s, elementsSelectable: G, onError: i } = yZ(mA, uc), m = bA(l.onlyRenderVisibleElements), a = sA();
  return B.jsx("div", { className: "react-flow__nodes", style: dy, children: m.map((n) => (
    // The split of responsibilities between NodeRenderer and
    // NodeComponentWrapper may appear weird. However, it’s designed to
    // minimize the cost of updates when individual nodes change.
    //
    // For example, when you’re dragging a single node, that node gets
    // updated multiple times per second. If `NodeRenderer` were to update
    // every time, it would have to re-run the `nodes.map()` loop every
    // time. This gets pricey with hundreds of nodes, especially if every
    // loop cycle does more than just rendering a JSX element!
    //
    // As a result of this choice, we took the following implementation
    // decisions:
    // - NodeRenderer subscribes *only* to node IDs – and therefore
    //   rerender *only* when visible nodes are added or removed.
    // - NodeRenderer performs all operations the result of which can be
    //   shared between nodes (such as creating the `ResizeObserver`
    //   instance, or subscribing to `selector`). This means extra prop
    //   drilling into `NodeComponentWrapper`, but it means we need to run
    //   these operations only once – instead of once per node.
    // - Any operations that you’d normally write inside `nodes.map` are
    //   moved into `NodeComponentWrapper`. This ensures they are
    //   memorized – so if `NodeRenderer` *has* to rerender, it only
    //   needs to regenerate the list of nodes, nothing else.
    B.jsx(GA, { id: n, nodeTypes: l.nodeTypes, nodeExtent: l.nodeExtent, onClick: l.onNodeClick, onMouseEnter: l.onNodeMouseEnter, onMouseMove: l.onNodeMouseMove, onMouseLeave: l.onNodeMouseLeave, onContextMenu: l.onNodeContextMenu, onDoubleClick: l.onNodeDoubleClick, noDragClassName: l.noDragClassName, noPanClassName: l.noPanClassName, rfId: l.rfId, disableKeyboardA11y: l.disableKeyboardA11y, resizeObserver: a, nodesDraggable: Z, nodesConnectable: u, nodesFocusable: s, elementsSelectable: G, nodeClickDistance: l.nodeClickDistance, onError: i }, n)
  )) });
}
QC.displayName = "NodeRenderer";
const iA = M.memo(QC);
function oA(l) {
  return yZ(M.useCallback((u) => {
    if (!l)
      return u.edges.map((G) => G.id);
    const s = [];
    if (u.width && u.height)
      for (const G of u.edges) {
        const i = u.nodeLookup.get(G.source), m = u.nodeLookup.get(G.target);
        i && m && o8({
          sourceNode: i,
          targetNode: m,
          width: u.width,
          height: u.height,
          transform: u.transform
        }) && s.push(G.id);
      }
    return s;
  }, [l]), uc);
}
const eA = ({ color: l = "none", strokeWidth: Z = 1 }) => B.jsx("polyline", { style: {
  stroke: l,
  strokeWidth: Z
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), aA = ({ color: l = "none", strokeWidth: Z = 1 }) => B.jsx("polyline", { style: {
  stroke: l,
  fill: l,
  strokeWidth: Z
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), HM = {
  [qa.Arrow]: eA,
  [qa.ArrowClosed]: aA
};
function nA(l) {
  const Z = lc();
  return M.useMemo(() => {
    var G, i;
    return Object.prototype.hasOwnProperty.call(HM, l) ? HM[l] : ((i = (G = Z.getState()).onError) == null || i.call(G, "009", Sd.error009(l)), null);
  }, [l]);
}
const pA = ({ id: l, type: Z, color: u, width: s = 12.5, height: G = 12.5, markerUnits: i = "strokeWidth", strokeWidth: m, orient: a = "auto-start-reverse" }) => {
  const n = nA(Z);
  return n ? B.jsx("marker", { className: "react-flow__arrowhead", id: l, markerWidth: `${s}`, markerHeight: `${G}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: a, refX: "0", refY: "0", children: B.jsx(n, { color: u, strokeWidth: m }) }) : null;
}, PC = ({ defaultColor: l, rfId: Z }) => {
  const u = yZ((i) => i.edges), s = yZ((i) => i.defaultEdgeOptions), G = M.useMemo(() => S8(u, {
    id: Z,
    defaultColor: l,
    defaultMarkerStart: s == null ? void 0 : s.markerStart,
    defaultMarkerEnd: s == null ? void 0 : s.markerEnd
  }), [u, s, Z, l]);
  return G.length ? B.jsx("svg", { className: "react-flow__marker", children: B.jsx("defs", { children: G.map((i) => B.jsx(pA, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null;
};
PC.displayName = "MarkerDefinitions";
var LA = M.memo(PC);
function OC({ x: l, y: Z, label: u, labelStyle: s = {}, labelShowBg: G = !0, labelBgStyle: i = {}, labelBgPadding: m = [2, 4], labelBgBorderRadius: a = 2, children: n, className: p, ...y }) {
  const [h, S] = M.useState({ x: 1, y: 0, width: 0, height: 0 }), t = Lc(["react-flow__edge-textwrapper", p]), W = M.useRef(null);
  return M.useEffect(() => {
    if (W.current) {
      const V = W.current.getBBox();
      S({
        x: V.x,
        y: V.y,
        width: V.width,
        height: V.height
      });
    }
  }, [u]), typeof u > "u" || !u ? null : B.jsxs("g", { transform: `translate(${l - h.width / 2} ${Z - h.height / 2})`, className: t, visibility: h.width ? "visible" : "hidden", ...y, children: [G && B.jsx("rect", { width: h.width + 2 * m[0], x: -m[0], y: -m[1], height: h.height + 2 * m[1], className: "react-flow__edge-textbg", style: i, rx: a, ry: a }), B.jsx("text", { className: "react-flow__edge-text", y: h.height / 2, dy: "0.3em", ref: W, style: s, children: u }), n] });
}
OC.displayName = "EdgeText";
const hA = M.memo(OC);
function Kn({ id: l, path: Z, labelX: u, labelY: s, label: G, labelStyle: i, labelShowBg: m, labelBgStyle: a, labelBgPadding: n, labelBgBorderRadius: p, style: y, markerEnd: h, markerStart: S, className: t, interactionWidth: W = 20 }) {
  return B.jsxs(B.Fragment, { children: [B.jsx("path", { id: l, style: y, d: Z, fill: "none", className: Lc(["react-flow__edge-path", t]), markerEnd: h, markerStart: S }), W && B.jsx("path", { d: Z, fill: "none", strokeOpacity: 0, strokeWidth: W, className: "react-flow__edge-interaction" }), G && Bu(u) && Bu(s) ? B.jsx(hA, { x: u, y: s, label: G, labelStyle: i, labelShowBg: m, labelBgStyle: a, labelBgPadding: n, labelBgBorderRadius: p }) : null] });
}
function gM({ pos: l, x1: Z, y1: u, x2: s, y2: G }) {
  return l === Tl.Left || l === Tl.Right ? [0.5 * (Z + s), u] : [Z, 0.5 * (u + G)];
}
function AC({ sourceX: l, sourceY: Z, sourcePosition: u = Tl.Bottom, targetX: s, targetY: G, targetPosition: i = Tl.Top }) {
  const [m, a] = gM({
    pos: u,
    x1: l,
    y1: Z,
    x2: s,
    y2: G
  }), [n, p] = gM({
    pos: i,
    x1: s,
    y1: G,
    x2: l,
    y2: Z
  }), [y, h, S, t] = KC({
    sourceX: l,
    sourceY: Z,
    targetX: s,
    targetY: G,
    sourceControlX: m,
    sourceControlY: a,
    targetControlX: n,
    targetControlY: p
  });
  return [
    `M${l},${Z} C${m},${a} ${n},${p} ${s},${G}`,
    y,
    h,
    S,
    t
  ];
}
function $C(l) {
  return M.memo(({ id: Z, sourceX: u, sourceY: s, targetX: G, targetY: i, sourcePosition: m = Tl.Bottom, targetPosition: a = Tl.Top, label: n, labelStyle: p, labelShowBg: y, labelBgStyle: h, labelBgPadding: S, labelBgBorderRadius: t, style: W, markerEnd: V, markerStart: R, interactionWidth: x }) => {
    const [r, k, U] = AC({
      sourceX: u,
      sourceY: s,
      sourcePosition: m,
      targetX: G,
      targetY: i,
      targetPosition: a
    }), w = l.isInternal ? void 0 : Z;
    return B.jsx(Kn, { id: w, path: r, labelX: k, labelY: U, label: n, labelStyle: p, labelShowBg: y, labelBgStyle: h, labelBgPadding: S, labelBgBorderRadius: t, style: W, markerEnd: V, markerStart: R, interactionWidth: x });
  });
}
const yA = $C({ isInternal: !1 }), qC = $C({ isInternal: !0 });
yA.displayName = "SimpleBezierEdge";
qC.displayName = "SimpleBezierEdgeInternal";
function _C(l) {
  return M.memo(({ id: Z, sourceX: u, sourceY: s, targetX: G, targetY: i, label: m, labelStyle: a, labelShowBg: n, labelBgStyle: p, labelBgPadding: y, labelBgBorderRadius: h, style: S, sourcePosition: t = Tl.Bottom, targetPosition: W = Tl.Top, markerEnd: V, markerStart: R, pathOptions: x, interactionWidth: r }) => {
    const [k, U, w] = BW({
      sourceX: u,
      sourceY: s,
      sourcePosition: t,
      targetX: G,
      targetY: i,
      targetPosition: W,
      borderRadius: x == null ? void 0 : x.borderRadius,
      offset: x == null ? void 0 : x.offset
    }), z = l.isInternal ? void 0 : Z;
    return B.jsx(Kn, { id: z, path: k, labelX: U, labelY: w, label: m, labelStyle: a, labelShowBg: n, labelBgStyle: p, labelBgPadding: y, labelBgBorderRadius: h, style: S, markerEnd: V, markerStart: R, interactionWidth: r });
  });
}
const lr = _C({ isInternal: !1 }), Zr = _C({ isInternal: !0 });
lr.displayName = "SmoothStepEdge";
Zr.displayName = "SmoothStepEdgeInternal";
function cr(l) {
  return M.memo(({ id: Z, ...u }) => {
    var G;
    const s = l.isInternal ? void 0 : Z;
    return B.jsx(lr, { ...u, id: s, pathOptions: M.useMemo(() => {
      var i;
      return { borderRadius: 0, offset: (i = u.pathOptions) == null ? void 0 : i.offset };
    }, [(G = u.pathOptions) == null ? void 0 : G.offset]) });
  });
}
const SA = cr({ isInternal: !1 }), br = cr({ isInternal: !0 });
SA.displayName = "StepEdge";
br.displayName = "StepEdgeInternal";
function ur(l) {
  return M.memo(({ id: Z, sourceX: u, sourceY: s, targetX: G, targetY: i, label: m, labelStyle: a, labelShowBg: n, labelBgStyle: p, labelBgPadding: y, labelBgBorderRadius: h, style: S, markerEnd: t, markerStart: W, interactionWidth: V }) => {
    const [R, x, r] = xC({ sourceX: u, sourceY: s, targetX: G, targetY: i }), k = l.isInternal ? void 0 : Z;
    return B.jsx(Kn, { id: k, path: R, labelX: x, labelY: r, label: m, labelStyle: a, labelShowBg: n, labelBgStyle: p, labelBgPadding: y, labelBgBorderRadius: h, style: S, markerEnd: t, markerStart: W, interactionWidth: V });
  });
}
const tA = ur({ isInternal: !1 }), sr = ur({ isInternal: !0 });
tA.displayName = "StraightEdge";
sr.displayName = "StraightEdgeInternal";
function dr(l) {
  return M.memo(({ id: Z, sourceX: u, sourceY: s, targetX: G, targetY: i, sourcePosition: m = Tl.Bottom, targetPosition: a = Tl.Top, label: n, labelStyle: p, labelShowBg: y, labelBgStyle: h, labelBgPadding: S, labelBgBorderRadius: t, style: W, markerEnd: V, markerStart: R, pathOptions: x, interactionWidth: r }) => {
    const [k, U, w] = WC({
      sourceX: u,
      sourceY: s,
      sourcePosition: m,
      targetX: G,
      targetY: i,
      targetPosition: a,
      curvature: x == null ? void 0 : x.curvature
    }), z = l.isInternal ? void 0 : Z;
    return B.jsx(Kn, { id: z, path: k, labelX: U, labelY: w, label: n, labelStyle: p, labelShowBg: y, labelBgStyle: h, labelBgPadding: S, labelBgBorderRadius: t, style: W, markerEnd: V, markerStart: R, interactionWidth: r });
  });
}
const XA = dr({ isInternal: !1 }), Gr = dr({ isInternal: !0 });
XA.displayName = "BezierEdge";
Gr.displayName = "BezierEdgeInternal";
const vM = {
  default: Gr,
  straight: sr,
  step: br,
  smoothstep: Zr,
  simplebezier: qC
}, TM = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, KA = (l, Z, u) => u === Tl.Left ? l - Z : u === Tl.Right ? l + Z : l, WA = (l, Z, u) => u === Tl.Top ? l - Z : u === Tl.Bottom ? l + Z : l, fM = "react-flow__edgeupdater";
function EM({ position: l, centerX: Z, centerY: u, radius: s = 10, onMouseDown: G, onMouseEnter: i, onMouseOut: m, type: a }) {
  return B.jsx("circle", { onMouseDown: G, onMouseEnter: i, onMouseOut: m, className: Lc([fM, `${fM}-${a}`]), cx: KA(Z, s, l), cy: WA(u, s, l), r: s, stroke: "transparent", fill: "transparent" });
}
function VA({ isReconnectable: l, reconnectRadius: Z, edge: u, sourceX: s, sourceY: G, targetX: i, targetY: m, sourcePosition: a, targetPosition: n, onReconnect: p, onReconnectStart: y, onReconnectEnd: h, setReconnecting: S, setUpdateHover: t }) {
  const W = lc(), V = (U, w) => {
    if (U.button !== 0)
      return;
    const { autoPanOnConnect: z, domNode: D, isValidConnection: C, connectionMode: j, connectionRadius: E, lib: g, onConnectStart: A, onConnectEnd: J, cancelConnection: F, nodeLookup: v, rfId: T, panBy: f, updateConnection: O } = W.getState(), _ = w.type === "target";
    S(!0), y == null || y(U, u, w.type);
    const il = (ol, Wl) => {
      S(!1), h == null || h(ol, u, w.type, Wl);
    }, Zl = (ol) => p == null ? void 0 : p(u, ol);
    QW.onPointerDown(U.nativeEvent, {
      autoPanOnConnect: z,
      connectionMode: j,
      connectionRadius: E,
      domNode: D,
      handleId: w.id,
      nodeId: w.nodeId,
      nodeLookup: v,
      isTarget: _,
      edgeUpdaterType: w.type,
      lib: g,
      flowId: T,
      cancelConnection: F,
      panBy: f,
      isValidConnection: C,
      onConnect: Zl,
      onConnectStart: A,
      onConnectEnd: J,
      onReconnectEnd: il,
      updateConnection: O,
      getTransform: () => W.getState().transform,
      getFromHandle: () => W.getState().connection.fromHandle
    });
  }, R = (U) => V(U, { nodeId: u.target, id: u.targetHandle ?? null, type: "target" }), x = (U) => V(U, { nodeId: u.source, id: u.sourceHandle ?? null, type: "source" }), r = () => t(!0), k = () => t(!1);
  return B.jsxs(B.Fragment, { children: [(l === !0 || l === "source") && B.jsx(EM, { position: a, centerX: s, centerY: G, radius: Z, onMouseDown: R, onMouseEnter: r, onMouseOut: k, type: "source" }), (l === !0 || l === "target") && B.jsx(EM, { position: n, centerX: i, centerY: m, radius: Z, onMouseDown: x, onMouseEnter: r, onMouseOut: k, type: "target" })] });
}
function xA({ id: l, edgesFocusable: Z, edgesReconnectable: u, elementsSelectable: s, onClick: G, onDoubleClick: i, onContextMenu: m, onMouseEnter: a, onMouseMove: n, onMouseLeave: p, reconnectRadius: y, onReconnect: h, onReconnectStart: S, onReconnectEnd: t, rfId: W, edgeTypes: V, noPanClassName: R, onError: x, disableKeyboardA11y: r }) {
  let k = yZ((cl) => cl.edgeLookup.get(l));
  const U = yZ((cl) => cl.defaultEdgeOptions);
  k = U ? { ...U, ...k } : k;
  let w = k.type || "default", z = (V == null ? void 0 : V[w]) || vM[w];
  z === void 0 && (x == null || x("011", Sd.error011(w)), w = "default", z = vM.default);
  const D = !!(k.focusable || Z && typeof k.focusable > "u"), C = typeof h < "u" && (k.reconnectable || u && typeof k.reconnectable > "u"), j = !!(k.selectable || s && typeof k.selectable > "u"), E = M.useRef(null), [g, A] = M.useState(!1), [J, F] = M.useState(!1), v = lc(), { zIndex: T, sourceX: f, sourceY: O, targetX: _, targetY: il, sourcePosition: Zl, targetPosition: ol } = yZ(M.useCallback((cl) => {
    const wl = cl.nodeLookup.get(k.source), Jl = cl.nodeLookup.get(k.target);
    if (!wl || !Jl)
      return {
        zIndex: k.zIndex,
        ...TM
      };
    const cZ = y8({
      id: l,
      sourceNode: wl,
      targetNode: Jl,
      sourceHandle: k.sourceHandle || null,
      targetHandle: k.targetHandle || null,
      connectionMode: cl.connectionMode,
      onError: x
    });
    return {
      zIndex: i8({
        selected: k.selected,
        zIndex: k.zIndex,
        sourceNode: wl,
        targetNode: Jl,
        elevateOnSelect: cl.elevateEdgesOnSelect
      }),
      ...cZ || TM
    };
  }, [k.source, k.target, k.sourceHandle, k.targetHandle, k.selected, k.zIndex]), uc), Wl = M.useMemo(() => k.markerStart ? `url('#${DW(k.markerStart, W)}')` : void 0, [k.markerStart, W]), ml = M.useMemo(() => k.markerEnd ? `url('#${DW(k.markerEnd, W)}')` : void 0, [k.markerEnd, W]);
  if (k.hidden || f === null || O === null || _ === null || il === null)
    return null;
  const Rl = (cl) => {
    var uZ;
    const { addSelectedEdges: wl, unselectNodesAndEdges: Jl, multiSelectionActive: cZ } = v.getState();
    j && (v.setState({ nodesSelectionActive: !1 }), k.selected && cZ ? (Jl({ nodes: [], edges: [k] }), (uZ = E.current) == null || uZ.blur()) : wl([l])), G && G(cl, k);
  }, kl = i ? (cl) => {
    i(cl, { ...k });
  } : void 0, zl = m ? (cl) => {
    m(cl, { ...k });
  } : void 0, Vl = a ? (cl) => {
    a(cl, { ...k });
  } : void 0, el = n ? (cl) => {
    n(cl, { ...k });
  } : void 0, xl = p ? (cl) => {
    p(cl, { ...k });
  } : void 0, hl = (cl) => {
    var wl;
    if (!r && mC.includes(cl.key) && j) {
      const { unselectNodesAndEdges: Jl, addSelectedEdges: cZ } = v.getState();
      cl.key === "Escape" ? ((wl = E.current) == null || wl.blur(), Jl({ edges: [k] })) : cZ([l]);
    }
  };
  return B.jsx("svg", { style: { zIndex: T }, children: B.jsxs("g", { className: Lc([
    "react-flow__edge",
    `react-flow__edge-${w}`,
    k.className,
    R,
    {
      selected: k.selected,
      animated: k.animated,
      inactive: !j && !G,
      updating: g,
      selectable: j
    }
  ]), onClick: Rl, onDoubleClick: kl, onContextMenu: zl, onMouseEnter: Vl, onMouseMove: el, onMouseLeave: xl, onKeyDown: D ? hl : void 0, tabIndex: D ? 0 : void 0, role: D ? "button" : "img", "data-id": l, "data-testid": `rf__edge-${l}`, "aria-label": k.ariaLabel === null ? void 0 : k.ariaLabel || `Edge from ${k.source} to ${k.target}`, "aria-describedby": D ? `${gC}-${W}` : void 0, ref: E, children: [!J && B.jsx(z, { id: l, source: k.source, target: k.target, type: k.type, selected: k.selected, animated: k.animated, selectable: j, deletable: k.deletable ?? !0, label: k.label, labelStyle: k.labelStyle, labelShowBg: k.labelShowBg, labelBgStyle: k.labelBgStyle, labelBgPadding: k.labelBgPadding, labelBgBorderRadius: k.labelBgBorderRadius, sourceX: f, sourceY: O, targetX: _, targetY: il, sourcePosition: Zl, targetPosition: ol, data: k.data, style: k.style, sourceHandleId: k.sourceHandle, targetHandleId: k.targetHandle, markerStart: Wl, markerEnd: ml, pathOptions: "pathOptions" in k ? k.pathOptions : void 0, interactionWidth: k.interactionWidth }), C && B.jsx(VA, { edge: k, isReconnectable: C, reconnectRadius: y, onReconnect: h, onReconnectStart: S, onReconnectEnd: t, sourceX: f, sourceY: O, targetX: _, targetY: il, sourcePosition: Zl, targetPosition: ol, setUpdateHover: A, setReconnecting: F })] }) });
}
const RA = (l) => ({
  width: l.width,
  height: l.height,
  edgesFocusable: l.edgesFocusable,
  edgesReconnectable: l.edgesReconnectable,
  elementsSelectable: l.elementsSelectable,
  connectionMode: l.connectionMode,
  onError: l.onError
});
function mr({ defaultMarkerColor: l, onlyRenderVisibleElements: Z, rfId: u, edgeTypes: s, noPanClassName: G, onReconnect: i, onEdgeContextMenu: m, onEdgeMouseEnter: a, onEdgeMouseMove: n, onEdgeMouseLeave: p, onEdgeClick: y, reconnectRadius: h, onEdgeDoubleClick: S, onReconnectStart: t, onReconnectEnd: W, disableKeyboardA11y: V }) {
  const { edgesFocusable: R, edgesReconnectable: x, elementsSelectable: r, onError: k } = yZ(RA, uc), U = oA(Z);
  return B.jsxs("div", { className: "react-flow__edges", children: [B.jsx(LA, { defaultColor: l, rfId: u }), U.map((w) => B.jsx(xA, { id: w, edgesFocusable: R, edgesReconnectable: x, elementsSelectable: r, noPanClassName: G, onReconnect: i, onContextMenu: m, onMouseEnter: a, onMouseMove: n, onMouseLeave: p, onClick: y, reconnectRadius: h, onDoubleClick: S, onReconnectStart: t, onReconnectEnd: W, rfId: u, onError: k, edgeTypes: s, disableKeyboardA11y: V }, w))] });
}
mr.displayName = "EdgeRenderer";
const YA = M.memo(mr), kA = (l) => `translate(${l.transform[0]}px,${l.transform[1]}px) scale(${l.transform[2]})`;
function MA({ children: l }) {
  const Z = yZ(kA);
  return B.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: Z }, children: l });
}
function IA(l) {
  const Z = sy(), u = M.useRef(!1);
  M.useEffect(() => {
    !u.current && Z.viewportInitialized && l && (setTimeout(() => l(Z), 1), u.current = !0);
  }, [l, Z.viewportInitialized]);
}
const UA = (l) => {
  var Z;
  return (Z = l.panZoom) == null ? void 0 : Z.syncViewport;
};
function CA(l) {
  const Z = yZ(UA), u = lc();
  return M.useEffect(() => {
    l && (Z == null || Z(l), u.setState({ transform: [l.x, l.y, l.zoom] }));
  }, [l, Z]), null;
}
function rA(l) {
  return l.connection.inProgress ? { ...l.connection, to: Xn(l.connection.to, l.transform) } : { ...l.connection };
}
function FA(l) {
  return rA;
}
function NA(l) {
  const Z = FA();
  return yZ(Z, uc);
}
const wA = (l) => ({
  nodesConnectable: l.nodesConnectable,
  isValid: l.connection.isValid,
  inProgress: l.connection.inProgress,
  width: l.width,
  height: l.height
});
function zA({ containerStyle: l, style: Z, type: u, component: s }) {
  const { nodesConnectable: G, width: i, height: m, isValid: a, inProgress: n } = yZ(wA, uc);
  return !(i && G && n) ? null : B.jsx("svg", { style: l, width: i, height: m, className: "react-flow__connectionline react-flow__container", children: B.jsx("g", { className: Lc(["react-flow__connection", oC(a)]), children: B.jsx(ir, { style: Z, type: u, CustomComponent: s, isValid: a }) }) });
}
const ir = ({ style: l, type: Z = sG.Bezier, CustomComponent: u, isValid: s }) => {
  const { inProgress: G, from: i, fromNode: m, fromHandle: a, fromPosition: n, to: p, toNode: y, toHandle: h, toPosition: S } = NA();
  if (!G)
    return;
  if (u)
    return B.jsx(u, { connectionLineType: Z, connectionLineStyle: l, fromNode: m, fromHandle: a, fromX: i.x, fromY: i.y, toX: p.x, toY: p.y, fromPosition: n, toPosition: S, connectionStatus: oC(s), toNode: y, toHandle: h });
  let t = "";
  const W = {
    sourceX: i.x,
    sourceY: i.y,
    sourcePosition: n,
    targetX: p.x,
    targetY: p.y,
    targetPosition: S
  };
  switch (Z) {
    case sG.Bezier:
      [t] = WC(W);
      break;
    case sG.SimpleBezier:
      [t] = AC(W);
      break;
    case sG.Step:
      [t] = BW({
        ...W,
        borderRadius: 0
      });
      break;
    case sG.SmoothStep:
      [t] = BW(W);
      break;
    default:
      [t] = xC(W);
  }
  return B.jsx("path", { d: t, fill: "none", className: "react-flow__connection-path", style: l });
};
ir.displayName = "ConnectionLine";
const JA = {};
function BM(l = JA) {
  M.useRef(l), lc(), M.useEffect(() => {
  }, [l]);
}
function HA() {
  lc(), M.useRef(!1), M.useEffect(() => {
  }, []);
}
function or({ nodeTypes: l, edgeTypes: Z, onInit: u, onNodeClick: s, onEdgeClick: G, onNodeDoubleClick: i, onEdgeDoubleClick: m, onNodeMouseEnter: a, onNodeMouseMove: n, onNodeMouseLeave: p, onNodeContextMenu: y, onSelectionContextMenu: h, onSelectionStart: S, onSelectionEnd: t, connectionLineType: W, connectionLineStyle: V, connectionLineComponent: R, connectionLineContainerStyle: x, selectionKeyCode: r, selectionOnDrag: k, selectionMode: U, multiSelectionKeyCode: w, panActivationKeyCode: z, zoomActivationKeyCode: D, deleteKeyCode: C, onlyRenderVisibleElements: j, elementsSelectable: E, defaultViewport: g, translateExtent: A, minZoom: J, maxZoom: F, preventScrolling: v, defaultMarkerColor: T, zoomOnScroll: f, zoomOnPinch: O, panOnScroll: _, panOnScrollSpeed: il, panOnScrollMode: Zl, zoomOnDoubleClick: ol, panOnDrag: Wl, onPaneClick: ml, onPaneMouseEnter: Rl, onPaneMouseMove: kl, onPaneMouseLeave: zl, onPaneScroll: Vl, onPaneContextMenu: el, paneClickDistance: xl, nodeClickDistance: hl, onEdgeContextMenu: cl, onEdgeMouseEnter: wl, onEdgeMouseMove: Jl, onEdgeMouseLeave: cZ, reconnectRadius: uZ, onReconnect: UZ, onReconnectStart: hc, onReconnectEnd: Zb, noDragClassName: yc, noWheelClassName: nb, noPanClassName: Nc, disableKeyboardA11y: oc, nodeExtent: cb, rfId: sc, viewport: Vc, onViewportChange: BZ }) {
  return BM(l), BM(Z), HA(), IA(u), CA(Vc), B.jsx(ZA, { onPaneClick: ml, onPaneMouseEnter: Rl, onPaneMouseMove: kl, onPaneMouseLeave: zl, onPaneContextMenu: el, onPaneScroll: Vl, paneClickDistance: xl, deleteKeyCode: C, selectionKeyCode: r, selectionOnDrag: k, selectionMode: U, onSelectionStart: S, onSelectionEnd: t, multiSelectionKeyCode: w, panActivationKeyCode: z, zoomActivationKeyCode: D, elementsSelectable: E, zoomOnScroll: f, zoomOnPinch: O, zoomOnDoubleClick: ol, panOnScroll: _, panOnScrollSpeed: il, panOnScrollMode: Zl, panOnDrag: Wl, defaultViewport: g, translateExtent: A, minZoom: J, maxZoom: F, onSelectionContextMenu: h, preventScrolling: v, noDragClassName: yc, noWheelClassName: nb, noPanClassName: Nc, disableKeyboardA11y: oc, onViewportChange: BZ, isControlledViewport: !!Vc, children: B.jsxs(MA, { children: [B.jsx(YA, { edgeTypes: Z, onEdgeClick: G, onEdgeDoubleClick: m, onReconnect: UZ, onReconnectStart: hc, onReconnectEnd: Zb, onlyRenderVisibleElements: j, onEdgeContextMenu: cl, onEdgeMouseEnter: wl, onEdgeMouseMove: Jl, onEdgeMouseLeave: cZ, reconnectRadius: uZ, defaultMarkerColor: T, noPanClassName: Nc, disableKeyboardA11y: oc, rfId: sc }), B.jsx(zA, { style: V, type: W, component: R, containerStyle: x }), B.jsx("div", { className: "react-flow__edgelabel-renderer" }), B.jsx(iA, { nodeTypes: l, onNodeClick: s, onNodeDoubleClick: i, onNodeMouseEnter: a, onNodeMouseMove: n, onNodeMouseLeave: p, onNodeContextMenu: y, nodeClickDistance: hl, onlyRenderVisibleElements: j, noPanClassName: Nc, noDragClassName: yc, disableKeyboardA11y: oc, nodeExtent: cb, rfId: sc }), B.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
or.displayName = "GraphView";
const gA = M.memo(or), DM = ({ nodes: l, edges: Z, defaultNodes: u, defaultEdges: s, width: G, height: i, fitView: m, nodeOrigin: a, nodeExtent: n } = {}) => {
  const p = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Map(), t = s ?? Z ?? [], W = u ?? l ?? [], V = a ?? [0, 0], R = n ?? Aa;
  YC(h, S, t), jW(W, p, y, {
    nodeOrigin: V,
    nodeExtent: R,
    elevateNodesOnSelect: !1
  });
  let x = [0, 0, 1];
  if (m && G && i) {
    const r = Mo(p, {
      filter: (z) => !!((z.width || z.initialWidth) && (z.height || z.initialHeight))
    }), { x: k, y: U, zoom: w } = QV(r, G, i, 0.5, 2, 0.1);
    x = [k, U, w];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: x,
    nodes: W,
    nodeLookup: p,
    parentLookup: y,
    edges: t,
    edgeLookup: S,
    connectionLookup: h,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: u !== void 0,
    hasDefaultEdges: s !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: Aa,
    nodeExtent: R,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: Lo.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: V,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    fitViewOnInit: !1,
    fitViewDone: !1,
    fitViewOnInitOptions: void 0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    connection: { ...iC },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: G8,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, vA = ({ nodes: l, edges: Z, defaultNodes: u, defaultEdges: s, width: G, height: i, fitView: m, nodeOrigin: a, nodeExtent: n }) => bO((p, y) => ({
  ...DM({ nodes: l, edges: Z, width: G, height: i, fitView: m, nodeOrigin: a, nodeExtent: n, defaultNodes: u, defaultEdges: s }),
  setNodes: (h) => {
    const { nodeLookup: S, parentLookup: t, nodeOrigin: W, elevateNodesOnSelect: V } = y();
    jW(h, S, t, {
      nodeOrigin: W,
      nodeExtent: n,
      elevateNodesOnSelect: V,
      checkEquality: !0
    }), p({ nodes: h });
  },
  setEdges: (h) => {
    const { connectionLookup: S, edgeLookup: t } = y();
    YC(S, t, h), p({ edges: h });
  },
  setDefaultNodesAndEdges: (h, S) => {
    if (h) {
      const { setNodes: t } = y();
      t(h), p({ hasDefaultNodes: !0 });
    }
    if (S) {
      const { setEdges: t } = y();
      t(S), p({ hasDefaultEdges: !0 });
    }
  },
  // Every node gets registerd at a ResizeObserver. Whenever a node
  // changes its dimensions, this function is called to measure the
  // new dimensions and update the nodes.
  updateNodeInternals: (h, S = { triggerFitView: !0 }) => {
    const { triggerNodeChanges: t, nodeLookup: W, parentLookup: V, fitViewOnInit: R, fitViewDone: x, fitViewOnInitOptions: r, domNode: k, nodeOrigin: U, nodeExtent: w, debug: z, fitViewSync: D } = y(), { changes: C, updatedInternals: j } = x8(h, W, V, k, U, w);
    if (j) {
      if (K8(W, V, { nodeOrigin: U, nodeExtent: w }), S.triggerFitView) {
        let E = x;
        !x && R && (E = D({
          ...r,
          nodes: r == null ? void 0 : r.nodes
        })), p({ fitViewDone: E });
      } else
        p({});
      (C == null ? void 0 : C.length) > 0 && (z && console.log("React Flow: trigger node changes", C), t == null || t(C));
    }
  },
  updateNodePositions: (h, S = !1) => {
    const t = [], W = [];
    for (const [V, R] of h) {
      const x = {
        id: V,
        type: "position",
        position: R.position,
        dragging: S
      };
      R != null && R.expandParent && (R != null && R.parentId) && x.position && (t.push({
        id: V,
        parentId: R.parentId,
        rect: {
          ...R.internals.positionAbsolute,
          width: R.measured.width,
          height: R.measured.height
        }
      }), x.position.x = Math.max(0, x.position.x), x.position.y = Math.max(0, x.position.y)), W.push(x);
    }
    if (t.length > 0) {
      const { nodeLookup: V, parentLookup: R, nodeOrigin: x } = y(), r = qV(t, V, R, x);
      W.push(...r);
    }
    y().triggerNodeChanges(W);
  },
  triggerNodeChanges: (h) => {
    const { onNodesChange: S, setNodes: t, nodes: W, hasDefaultNodes: V, debug: R } = y();
    if (h != null && h.length) {
      if (V) {
        const x = xO(h, W);
        t(x);
      }
      R && console.log("React Flow: trigger node changes", h), S == null || S(h);
    }
  },
  triggerEdgeChanges: (h) => {
    const { onEdgesChange: S, setEdges: t, edges: W, hasDefaultEdges: V, debug: R } = y();
    if (h != null && h.length) {
      if (V) {
        const x = RO(h, W);
        t(x);
      }
      R && console.log("React Flow: trigger edge changes", h), S == null || S(h);
    }
  },
  addSelectedNodes: (h) => {
    const { multiSelectionActive: S, edgeLookup: t, nodeLookup: W, triggerNodeChanges: V, triggerEdgeChanges: R } = y();
    if (S) {
      const x = h.map((r) => um(r, !0));
      V(x);
      return;
    }
    V(Bi(W, /* @__PURE__ */ new Set([...h]), !0)), R(Bi(t));
  },
  addSelectedEdges: (h) => {
    const { multiSelectionActive: S, edgeLookup: t, nodeLookup: W, triggerNodeChanges: V, triggerEdgeChanges: R } = y();
    if (S) {
      const x = h.map((r) => um(r, !0));
      R(x);
      return;
    }
    R(Bi(t, /* @__PURE__ */ new Set([...h]))), V(Bi(W, /* @__PURE__ */ new Set(), !0));
  },
  unselectNodesAndEdges: ({ nodes: h, edges: S } = {}) => {
    const { edges: t, nodes: W, nodeLookup: V, triggerNodeChanges: R, triggerEdgeChanges: x } = y(), r = h || W, k = S || t, U = r.map((z) => {
      const D = V.get(z.id);
      return D && (D.selected = !1), um(z.id, !1);
    }), w = k.map((z) => um(z.id, !1));
    R(U), x(w);
  },
  setMinZoom: (h) => {
    const { panZoom: S, maxZoom: t } = y();
    S == null || S.setScaleExtent([h, t]), p({ minZoom: h });
  },
  setMaxZoom: (h) => {
    const { panZoom: S, minZoom: t } = y();
    S == null || S.setScaleExtent([t, h]), p({ maxZoom: h });
  },
  setTranslateExtent: (h) => {
    var S;
    (S = y().panZoom) == null || S.setTranslateExtent(h), p({ translateExtent: h });
  },
  setPaneClickDistance: (h) => {
    var S;
    (S = y().panZoom) == null || S.setClickDistance(h);
  },
  resetSelectedElements: () => {
    const { edges: h, nodes: S, triggerNodeChanges: t, triggerEdgeChanges: W } = y(), V = S.reduce((x, r) => r.selected ? [...x, um(r.id, !1)] : x, []), R = h.reduce((x, r) => r.selected ? [...x, um(r.id, !1)] : x, []);
    t(V), W(R);
  },
  setNodeExtent: (h) => {
    const { nodes: S, nodeLookup: t, parentLookup: W, nodeOrigin: V, elevateNodesOnSelect: R, nodeExtent: x } = y();
    h[0][0] === x[0][0] && h[0][1] === x[0][1] && h[1][0] === x[1][0] && h[1][1] === x[1][1] || (jW(S, t, W, {
      nodeOrigin: V,
      nodeExtent: h,
      elevateNodesOnSelect: R,
      checkEquality: !1
    }), p({ nodeExtent: h }));
  },
  panBy: (h) => {
    const { transform: S, width: t, height: W, panZoom: V, translateExtent: R } = y();
    return R8({ delta: h, panZoom: V, transform: S, translateExtent: R, width: t, height: W });
  },
  fitView: (h) => {
    const { panZoom: S, width: t, height: W, minZoom: V, maxZoom: R, nodeLookup: x } = y();
    if (!S)
      return Promise.resolve(!1);
    const r = vW(x, h);
    return TW({
      nodes: r,
      width: t,
      height: W,
      panZoom: S,
      minZoom: V,
      maxZoom: R
    }, h);
  },
  // we can't call an asnychronous function in updateNodeInternals
  // for that we created this sync version of fitView
  fitViewSync: (h) => {
    const { panZoom: S, width: t, height: W, minZoom: V, maxZoom: R, nodeLookup: x } = y();
    if (!S)
      return !1;
    const r = vW(x, h);
    return TW({
      nodes: r,
      width: t,
      height: W,
      panZoom: S,
      minZoom: V,
      maxZoom: R
    }, h), r.size > 0;
  },
  cancelConnection: () => {
    p({
      connection: { ...iC }
    });
  },
  updateConnection: (h) => {
    p({ connection: h });
  },
  reset: () => p({ ...DM() })
}), Object.is);
function er({ initialNodes: l, initialEdges: Z, defaultNodes: u, defaultEdges: s, initialWidth: G, initialHeight: i, fitView: m, nodeOrigin: a, nodeExtent: n, children: p }) {
  const [y] = M.useState(() => vA({
    nodes: l,
    edges: Z,
    defaultNodes: u,
    defaultEdges: s,
    width: G,
    height: i,
    fitView: m,
    nodeOrigin: a,
    nodeExtent: n
  }));
  return B.jsx(uO, { value: y, children: B.jsx(IO, { children: p }) });
}
function TA({ children: l, nodes: Z, edges: u, defaultNodes: s, defaultEdges: G, width: i, height: m, fitView: a, nodeOrigin: n, nodeExtent: p }) {
  return M.useContext(uy) ? B.jsx(B.Fragment, { children: l }) : B.jsx(er, { initialNodes: Z, initialEdges: u, defaultNodes: s, defaultEdges: G, initialWidth: i, initialHeight: m, fitView: a, nodeOrigin: n, nodeExtent: p, children: l });
}
const fA = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function EA({ nodes: l, edges: Z, defaultNodes: u, defaultEdges: s, className: G, nodeTypes: i, edgeTypes: m, onNodeClick: a, onEdgeClick: n, onInit: p, onMove: y, onMoveStart: h, onMoveEnd: S, onConnect: t, onConnectStart: W, onConnectEnd: V, onClickConnectStart: R, onClickConnectEnd: x, onNodeMouseEnter: r, onNodeMouseMove: k, onNodeMouseLeave: U, onNodeContextMenu: w, onNodeDoubleClick: z, onNodeDragStart: D, onNodeDrag: C, onNodeDragStop: j, onNodesDelete: E, onEdgesDelete: g, onDelete: A, onSelectionChange: J, onSelectionDragStart: F, onSelectionDrag: v, onSelectionDragStop: T, onSelectionContextMenu: f, onSelectionStart: O, onSelectionEnd: _, onBeforeDelete: il, connectionMode: Zl, connectionLineType: ol = sG.Bezier, connectionLineStyle: Wl, connectionLineComponent: ml, connectionLineContainerStyle: Rl, deleteKeyCode: kl = "Backspace", selectionKeyCode: zl = "Shift", selectionOnDrag: Vl = !1, selectionMode: el = $a.Full, panActivationKeyCode: xl = "Space", multiSelectionKeyCode: hl = kh() ? "Meta" : "Control", zoomActivationKeyCode: cl = kh() ? "Meta" : "Control", snapToGrid: wl, snapGrid: Jl, onlyRenderVisibleElements: cZ = !1, selectNodesOnDrag: uZ, nodesDraggable: UZ, nodesConnectable: hc, nodesFocusable: Zb, nodeOrigin: yc = vC, edgesFocusable: nb, edgesReconnectable: Nc, elementsSelectable: oc = !0, defaultViewport: cb = yO, minZoom: sc = 0.5, maxZoom: Vc = 2, translateExtent: BZ = Aa, preventScrolling: Rb = !0, nodeExtent: Tb, defaultMarkerColor: tu = "#b1b1b7", zoomOnScroll: Il = !0, zoomOnPinch: El = !0, panOnScroll: sZ = !1, panOnScrollSpeed: YZ = 0.5, panOnScrollMode: kZ = hm.Free, zoomOnDoubleClick: ec = !0, panOnDrag: Zc = !0, onPaneClick: bb, onPaneMouseEnter: zZ, onPaneMouseMove: pb, onPaneMouseLeave: gZ, onPaneScroll: vZ, onPaneContextMenu: cu, paneClickDistance: Yb = 0, nodeClickDistance: Rs = 0, children: Xd, onReconnect: tG, onReconnectStart: Ys, onReconnectEnd: ks, onEdgeContextMenu: Xu, onEdgeDoubleClick: Qu, onEdgeMouseEnter: Ku, onEdgeMouseMove: fb, onEdgeMouseLeave: Eb, reconnectRadius: bu = 10, onNodesChange: Ms, onEdgesChange: Pu, noDragClassName: P = "nodrag", noWheelClassName: yl = "nowheel", noPanClassName: Kl = "nopan", fitView: Bl, fitViewOptions: oZ, connectOnClick: aZ, attributionPosition: jl, proOptions: dZ, defaultEdgeOptions: ac, elevateNodesOnSelect: JZ, elevateEdgesOnSelect: DZ, disableKeyboardA11y: xc = !1, autoPanOnConnect: uu, autoPanOnNodeDrag: kb, autoPanSpeed: Sc, connectionRadius: Lb, isValidConnection: GZ, onError: Wu, style: Ou, id: Kd, nodeDragThreshold: XG, viewport: KG, onViewportChange: WG, width: VG, height: xG, colorMode: RG = "light", debug: wm, ...Co }, YG) {
  const Vu = Kd || "1", Mb = KO(RG);
  return B.jsx("div", { ...Co, style: { ...Ou, ...fA }, ref: YG, className: Lc(["react-flow", G, Mb]), "data-testid": "rf__wrapper", id: Kd, children: B.jsxs(TA, { nodes: l, edges: Z, width: VG, height: xG, fitView: Bl, nodeOrigin: yc, nodeExtent: Tb, children: [B.jsx(gA, { onInit: p, onNodeClick: a, onEdgeClick: n, onNodeMouseEnter: r, onNodeMouseMove: k, onNodeMouseLeave: U, onNodeContextMenu: w, onNodeDoubleClick: z, nodeTypes: i, edgeTypes: m, connectionLineType: ol, connectionLineStyle: Wl, connectionLineComponent: ml, connectionLineContainerStyle: Rl, selectionKeyCode: zl, selectionOnDrag: Vl, selectionMode: el, deleteKeyCode: kl, multiSelectionKeyCode: hl, panActivationKeyCode: xl, zoomActivationKeyCode: cl, onlyRenderVisibleElements: cZ, defaultViewport: cb, translateExtent: BZ, minZoom: sc, maxZoom: Vc, preventScrolling: Rb, zoomOnScroll: Il, zoomOnPinch: El, zoomOnDoubleClick: ec, panOnScroll: sZ, panOnScrollSpeed: YZ, panOnScrollMode: kZ, panOnDrag: Zc, onPaneClick: bb, onPaneMouseEnter: zZ, onPaneMouseMove: pb, onPaneMouseLeave: gZ, onPaneScroll: vZ, onPaneContextMenu: cu, paneClickDistance: Yb, nodeClickDistance: Rs, onSelectionContextMenu: f, onSelectionStart: O, onSelectionEnd: _, onReconnect: tG, onReconnectStart: Ys, onReconnectEnd: ks, onEdgeContextMenu: Xu, onEdgeDoubleClick: Qu, onEdgeMouseEnter: Ku, onEdgeMouseMove: fb, onEdgeMouseLeave: Eb, reconnectRadius: bu, defaultMarkerColor: tu, noDragClassName: P, noWheelClassName: yl, noPanClassName: Kl, rfId: Vu, disableKeyboardA11y: xc, nodeExtent: Tb, viewport: KG, onViewportChange: WG }), B.jsx(XO, { nodes: l, edges: Z, defaultNodes: u, defaultEdges: s, onConnect: t, onConnectStart: W, onConnectEnd: V, onClickConnectStart: R, onClickConnectEnd: x, nodesDraggable: UZ, nodesConnectable: hc, nodesFocusable: Zb, edgesFocusable: nb, edgesReconnectable: Nc, elementsSelectable: oc, elevateNodesOnSelect: JZ, elevateEdgesOnSelect: DZ, minZoom: sc, maxZoom: Vc, nodeExtent: Tb, onNodesChange: Ms, onEdgesChange: Pu, snapToGrid: wl, snapGrid: Jl, connectionMode: Zl, translateExtent: BZ, connectOnClick: aZ, defaultEdgeOptions: ac, fitView: Bl, fitViewOptions: oZ, onNodesDelete: E, onEdgesDelete: g, onDelete: A, onNodeDragStart: D, onNodeDrag: C, onNodeDragStop: j, onSelectionDrag: v, onSelectionDragStart: F, onSelectionDragStop: T, onMove: y, onMoveStart: h, onMoveEnd: S, noPanClassName: Kl, nodeOrigin: yc, rfId: Vu, autoPanOnConnect: uu, autoPanOnNodeDrag: kb, autoPanSpeed: Sc, onError: Wu, connectionRadius: Lb, isValidConnection: GZ, selectNodesOnDrag: uZ, nodeDragThreshold: XG, onBeforeDelete: il, paneClickDistance: Yb, debug: wm }), B.jsx(hO, { onSelectionChange: J }), Xd, B.jsx(eO, { proOptions: dZ, position: jl }), B.jsx(iO, { rfId: Vu, disableKeyboardA11y: xc })] }) });
}
var BA = fC(EA);
const DA = (l) => (Z) => {
  if (Z.nodeLookup.size === 0)
    return !1;
  for (const [, { hidden: u, internals: s }] of Z.nodeLookup)
    if ((l.includeHiddenNodes || !u) && (s.handleBounds === void 0 || !PV(s.userNode)))
      return !1;
  return !0;
}, jA = {
  includeHiddenNodes: !1
};
function QA(l = jA) {
  return yZ(DA(l));
}
function PA({ dimensions: l, lineWidth: Z, variant: u, className: s }) {
  return B.jsx("path", { strokeWidth: Z, d: `M${l[0] / 2} 0 V${l[1]} M0 ${l[1] / 2} H${l[0]}`, className: Lc(["react-flow__background-pattern", u, s]) });
}
function OA({ radius: l, className: Z }) {
  return B.jsx("circle", { cx: l, cy: l, r: l, className: Lc(["react-flow__background-pattern", "dots", Z]) });
}
var pG;
(function(l) {
  l.Lines = "lines", l.Dots = "dots", l.Cross = "cross";
})(pG || (pG = {}));
const AA = {
  [pG.Dots]: 1,
  [pG.Lines]: 1,
  [pG.Cross]: 6
}, $A = (l) => ({ transform: l.transform, patternId: `pattern-${l.rfId}` });
function ar({
  id: l,
  variant: Z = pG.Dots,
  // only used for dots and cross
  gap: u = 20,
  // only used for lines and cross
  size: s,
  lineWidth: G = 1,
  offset: i = 0,
  color: m,
  bgColor: a,
  style: n,
  className: p,
  patternClassName: y
}) {
  const h = M.useRef(null), { transform: S, patternId: t } = yZ($A, uc), W = s || AA[Z], V = Z === pG.Dots, R = Z === pG.Cross, x = Array.isArray(u) ? u : [u, u], r = [x[0] * S[2] || 1, x[1] * S[2] || 1], k = W * S[2], U = Array.isArray(i) ? i : [i, i], w = R ? [k, k] : r, z = [
    U[0] * S[2] || 1 + w[0] / 2,
    U[1] * S[2] || 1 + w[1] / 2
  ], D = `${t}${l || ""}`;
  return B.jsxs("svg", { className: Lc(["react-flow__background", p]), style: {
    ...n,
    ...dy,
    "--xy-background-color-props": a,
    "--xy-background-pattern-color-props": m
  }, ref: h, "data-testid": "rf__background", children: [B.jsx("pattern", { id: D, x: S[0] % r[0], y: S[1] % r[1], width: r[0], height: r[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${z[0]},-${z[1]})`, children: V ? B.jsx(OA, { radius: k / 2, className: y }) : B.jsx(PA, { dimensions: w, lineWidth: G, variant: Z, className: y }) }), B.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${D})` })] });
}
ar.displayName = "Background";
M.memo(ar);
function qA() {
  return B.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: B.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function _A() {
  return B.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: B.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function l7() {
  return B.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: B.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function Z7() {
  return B.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: B.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function c7() {
  return B.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: B.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Zh({ children: l, className: Z, ...u }) {
  return B.jsx("button", { type: "button", className: Lc(["react-flow__controls-button", Z]), ...u, children: l });
}
const b7 = (l) => ({
  isInteractive: l.nodesDraggable || l.nodesConnectable || l.elementsSelectable,
  minZoomReached: l.transform[2] <= l.minZoom,
  maxZoomReached: l.transform[2] >= l.maxZoom
});
function nr({ style: l, showZoom: Z = !0, showFitView: u = !0, showInteractive: s = !0, fitViewOptions: G, onZoomIn: i, onZoomOut: m, onFitView: a, onInteractiveChange: n, className: p, children: y, position: h = "bottom-left", orientation: S = "vertical", "aria-label": t = "React Flow controls" }) {
  const W = lc(), { isInteractive: V, minZoomReached: R, maxZoomReached: x } = yZ(b7, uc), { zoomIn: r, zoomOut: k, fitView: U } = sy(), w = () => {
    r(), i == null || i();
  }, z = () => {
    k(), m == null || m();
  }, D = () => {
    U(G), a == null || a();
  }, C = () => {
    W.setState({
      nodesDraggable: !V,
      nodesConnectable: !V,
      elementsSelectable: !V
    }), n == null || n(!V);
  }, j = S === "horizontal" ? "horizontal" : "vertical";
  return B.jsxs(Zn, { className: Lc(["react-flow__controls", j, p]), position: h, style: l, "data-testid": "rf__controls", "aria-label": t, children: [Z && B.jsxs(B.Fragment, { children: [B.jsx(Zh, { onClick: w, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: x, children: B.jsx(qA, {}) }), B.jsx(Zh, { onClick: z, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: R, children: B.jsx(_A, {}) })] }), u && B.jsx(Zh, { className: "react-flow__controls-fitview", onClick: D, title: "fit view", "aria-label": "fit view", children: B.jsx(l7, {}) }), s && B.jsx(Zh, { className: "react-flow__controls-interactive", onClick: C, title: "toggle interactivity", "aria-label": "toggle interactivity", children: V ? B.jsx(c7, {}) : B.jsx(Z7, {}) }), y] });
}
nr.displayName = "Controls";
const u7 = M.memo(nr);
function s7({ id: l, x: Z, y: u, width: s, height: G, style: i, color: m, strokeColor: a, strokeWidth: n, className: p, borderRadius: y, shapeRendering: h, selected: S, onClick: t }) {
  const { background: W, backgroundColor: V } = i || {}, R = m || W || V;
  return B.jsx("rect", { className: Lc(["react-flow__minimap-node", { selected: S }, p]), x: Z, y: u, rx: y, ry: y, width: s, height: G, style: {
    fill: R,
    stroke: a,
    strokeWidth: n
  }, shapeRendering: h, onClick: t ? (x) => t(x, l) : void 0 });
}
const d7 = M.memo(s7), G7 = (l) => l.nodes.map((Z) => Z.id), qK = (l) => l instanceof Function ? l : () => l;
function m7({
  nodeStrokeColor: l,
  nodeColor: Z,
  nodeClassName: u = "",
  nodeBorderRadius: s = 5,
  nodeStrokeWidth: G,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: i = d7,
  onClick: m
}) {
  const a = yZ(G7, uc), n = qK(Z), p = qK(l), y = qK(u), h = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return B.jsx(B.Fragment, { children: a.map((S) => (
    // The split of responsibilities between MiniMapNodes and
    // NodeComponentWrapper may appear weird. However, it’s designed to
    // minimize the cost of updates when individual nodes change.
    //
    // For more details, see a similar commit in `NodeRenderer/index.tsx`.
    B.jsx(o7, { id: S, nodeColorFunc: n, nodeStrokeColorFunc: p, nodeClassNameFunc: y, nodeBorderRadius: s, nodeStrokeWidth: G, NodeComponent: i, onClick: m, shapeRendering: h }, S)
  )) });
}
function i7({ id: l, nodeColorFunc: Z, nodeStrokeColorFunc: u, nodeClassNameFunc: s, nodeBorderRadius: G, nodeStrokeWidth: i, shapeRendering: m, NodeComponent: a, onClick: n }) {
  const { node: p, x: y, y: h, width: S, height: t } = yZ((W) => {
    const V = W.nodeLookup.get(l), { x: R, y: x } = V.internals.positionAbsolute, { width: r, height: k } = td(V);
    return {
      node: V,
      x: R,
      y: x,
      width: r,
      height: k
    };
  }, uc);
  return !p || p.hidden || !PV(p) ? null : B.jsx(a, { x: y, y: h, width: S, height: t, style: p.style, selected: !!p.selected, className: s(p), color: Z(p), borderRadius: G, strokeColor: u(p), strokeWidth: i, shapeRendering: m, onClick: n, id: p.id });
}
const o7 = M.memo(i7);
var e7 = M.memo(m7);
const a7 = 200, n7 = 150, p7 = (l) => {
  const Z = {
    x: -l.transform[0] / l.transform[2],
    y: -l.transform[1] / l.transform[2],
    width: l.width / l.transform[2],
    height: l.height / l.transform[2]
  };
  return {
    viewBB: Z,
    boundingRect: l.nodeLookup.size > 0 ? hC(Mo(l.nodeLookup), Z) : Z,
    rfId: l.rfId,
    panZoom: l.panZoom,
    translateExtent: l.translateExtent,
    flowWidth: l.width,
    flowHeight: l.height
  };
}, L7 = "react-flow__minimap-desc";
function pr({
  style: l,
  className: Z,
  nodeStrokeColor: u,
  nodeColor: s,
  nodeClassName: G = "",
  nodeBorderRadius: i = 5,
  nodeStrokeWidth: m,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: a,
  bgColor: n,
  maskColor: p,
  maskStrokeColor: y,
  maskStrokeWidth: h,
  position: S = "bottom-right",
  onClick: t,
  onNodeClick: W,
  pannable: V = !1,
  zoomable: R = !1,
  ariaLabel: x = "React Flow mini map",
  inversePan: r,
  zoomStep: k = 10,
  offsetScale: U = 5
}) {
  const w = lc(), z = M.useRef(null), { boundingRect: D, viewBB: C, rfId: j, panZoom: E, translateExtent: g, flowWidth: A, flowHeight: J } = yZ(p7, uc), F = (l == null ? void 0 : l.width) ?? a7, v = (l == null ? void 0 : l.height) ?? n7, T = D.width / F, f = D.height / v, O = Math.max(T, f), _ = O * F, il = O * v, Zl = U * O, ol = D.x - (_ - D.width) / 2 - Zl, Wl = D.y - (il - D.height) / 2 - Zl, ml = _ + Zl * 2, Rl = il + Zl * 2, kl = `${L7}-${j}`, zl = M.useRef(0), Vl = M.useRef();
  zl.current = O, M.useEffect(() => {
    if (z.current && E)
      return Vl.current = F8({
        domNode: z.current,
        panZoom: E,
        getTransform: () => w.getState().transform,
        getViewScale: () => zl.current
      }), () => {
        var hl;
        (hl = Vl.current) == null || hl.destroy();
      };
  }, [E]), M.useEffect(() => {
    var hl;
    (hl = Vl.current) == null || hl.update({
      translateExtent: g,
      width: A,
      height: J,
      inversePan: r,
      pannable: V,
      zoomStep: k,
      zoomable: R
    });
  }, [V, R, r, k, g, A, J]);
  const el = t ? (hl) => {
    var Jl;
    const [cl, wl] = ((Jl = Vl.current) == null ? void 0 : Jl.pointer(hl)) || [0, 0];
    t(hl, { x: cl, y: wl });
  } : void 0, xl = W ? M.useCallback((hl, cl) => {
    const wl = w.getState().nodeLookup.get(cl);
    W(hl, wl);
  }, []) : void 0;
  return B.jsx(Zn, { position: S, style: {
    ...l,
    "--xy-minimap-background-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-mask-background-color-props": typeof p == "string" ? p : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof y == "string" ? y : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof h == "number" ? h * O : void 0,
    "--xy-minimap-node-background-color-props": typeof s == "string" ? s : void 0,
    "--xy-minimap-node-stroke-color-props": typeof u == "string" ? u : void 0,
    "--xy-minimap-node-stroke-width-props": typeof m == "string" ? m : void 0
  }, className: Lc(["react-flow__minimap", Z]), "data-testid": "rf__minimap", children: B.jsxs("svg", { width: F, height: v, viewBox: `${ol} ${Wl} ${ml} ${Rl}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": kl, ref: z, onClick: el, children: [x && B.jsx("title", { id: kl, children: x }), B.jsx(e7, { onClick: xl, nodeColor: s, nodeStrokeColor: u, nodeBorderRadius: i, nodeClassName: G, nodeStrokeWidth: m, nodeComponent: a }), B.jsx("path", { className: "react-flow__minimap-mask", d: `M${ol - Zl},${Wl - Zl}h${ml + Zl * 2}v${Rl + Zl * 2}h${-ml - Zl * 2}z
        M${C.x},${C.y}h${C.width}v${C.height}h${-C.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
pr.displayName = "MiniMap";
M.memo(pr);
function h7({ nodeId: l, position: Z, variant: u = wa.Handle, className: s, style: G = {}, children: i, color: m, minWidth: a = 10, minHeight: n = 10, maxWidth: p = Number.MAX_VALUE, maxHeight: y = Number.MAX_VALUE, keepAspectRatio: h = !1, shouldResize: S, onResizeStart: t, onResize: W, onResizeEnd: V }) {
  const R = lx(), x = typeof l == "string" ? l : R, r = lc(), k = M.useRef(null), U = u === wa.Line ? "right" : "bottom-right", w = Z ?? U, z = M.useRef(null);
  M.useEffect(() => {
    if (!(!k.current || !x))
      return z.current || (z.current = P8({
        domNode: k.current,
        nodeId: x,
        getStoreItems: () => {
          const { nodeLookup: E, transform: g, snapGrid: A, snapToGrid: J, nodeOrigin: F } = r.getState();
          return {
            nodeLookup: E,
            transform: g,
            snapGrid: A,
            snapToGrid: J,
            nodeOrigin: F
          };
        },
        onChange: (E, g) => {
          const { triggerNodeChanges: A, nodeLookup: J, parentLookup: F, nodeOrigin: v } = r.getState(), T = [], f = { x: E.x, y: E.y }, O = J.get(x);
          if (O && O.expandParent && O.parentId) {
            const _ = O.origin ?? v, il = E.width ?? O.measured.width, Zl = E.height ?? O.measured.height, ol = {
              id: O.id,
              parentId: O.parentId,
              rect: {
                width: il,
                height: Zl,
                ...SC({
                  x: E.x ?? O.position.x,
                  y: E.y ?? O.position.y
                }, { width: il, height: Zl }, O.parentId, J, _)
              }
            }, Wl = qV([ol], J, F, v);
            T.push(...Wl), f.x = E.x ? Math.max(_[0] * il, E.x) : void 0, f.y = E.y ? Math.max(_[1] * Zl, E.y) : void 0;
          }
          if (f.x !== void 0 && f.y !== void 0) {
            const _ = {
              id: x,
              type: "position",
              position: { ...f }
            };
            T.push(_);
          }
          if (E.width !== void 0 && E.height !== void 0) {
            const _ = {
              id: x,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: E.width,
                height: E.height
              }
            };
            T.push(_);
          }
          for (const _ of g) {
            const il = {
              ..._,
              type: "position"
            };
            T.push(il);
          }
          A(T);
        },
        onEnd: () => {
          const E = {
            id: x,
            type: "dimensions",
            resizing: !1
          };
          r.getState().triggerNodeChanges([E]);
        }
      })), z.current.update({
        controlPosition: w,
        boundaries: {
          minWidth: a,
          minHeight: n,
          maxWidth: p,
          maxHeight: y
        },
        keepAspectRatio: h,
        onResizeStart: t,
        onResize: W,
        onResizeEnd: V,
        shouldResize: S
      }), () => {
        var E;
        (E = z.current) == null || E.destroy();
      };
  }, [
    w,
    a,
    n,
    p,
    y,
    h,
    t,
    W,
    V,
    S
  ]);
  const D = w.split("-"), C = u === wa.Line ? "borderColor" : "backgroundColor", j = m ? { ...G, [C]: m } : G;
  return B.jsx("div", { className: Lc(["react-flow__resize-control", "nodrag", ...D, u, s]), ref: k, style: j, children: i });
}
M.memo(h7);
const y7 = (l) => {
  var Z;
  return (Z = l.domNode) == null ? void 0 : Z.querySelector(".react-flow__renderer");
};
function S7({ children: l }) {
  const Z = yZ(y7);
  return Z ? xo.createPortal(l, Z) : null;
}
const t7 = (l, Z) => (l == null ? void 0 : l.internals.positionAbsolute.x) !== (Z == null ? void 0 : Z.internals.positionAbsolute.x) || (l == null ? void 0 : l.internals.positionAbsolute.y) !== (Z == null ? void 0 : Z.internals.positionAbsolute.y) || (l == null ? void 0 : l.measured.width) !== (Z == null ? void 0 : Z.measured.width) || (l == null ? void 0 : l.measured.height) !== (Z == null ? void 0 : Z.measured.height) || (l == null ? void 0 : l.selected) !== (Z == null ? void 0 : Z.selected) || (l == null ? void 0 : l.internals.z) !== (Z == null ? void 0 : Z.internals.z), X7 = (l, Z) => {
  if (l.size !== Z.size)
    return !1;
  for (const [u, s] of l)
    if (t7(s, Z.get(u)))
      return !1;
  return !0;
}, K7 = (l) => ({
  x: l.transform[0],
  y: l.transform[1],
  zoom: l.transform[2],
  selectedNodesCount: l.nodes.filter((Z) => Z.selected).length
});
function W7({ nodeId: l, children: Z, className: u, style: s, isVisible: G, position: i = Tl.Top, offset: m = 10, align: a = "center", ...n }) {
  const p = lx(), y = M.useCallback((w) => (Array.isArray(l) ? l : [l || p || ""]).reduce((C, j) => {
    const E = w.nodeLookup.get(j);
    return E && C.set(E.id, E), C;
  }, /* @__PURE__ */ new Map()), [l, p]), h = yZ(y, X7), { x: S, y: t, zoom: W, selectedNodesCount: V } = yZ(K7, uc);
  if (!(typeof G == "boolean" ? G : h.size === 1 && h.values().next().value.selected && V === 1) || !h.size)
    return null;
  const x = Mo(h), r = Array.from(h.values()), k = Math.max(...r.map((w) => w.internals.z + 1)), U = {
    position: "absolute",
    transform: t8(x, { x: S, y: t, zoom: W }, i, m, a),
    zIndex: k,
    ...s
  };
  return B.jsx(S7, { children: B.jsx("div", { style: U, className: Lc(["react-flow__node-toolbar", u]), ...n, "data-id": r.reduce((w, z) => `${w}${z.id} `, "").trim(), children: Z }) });
}
function V7({
  className: l,
  noIndicator: Z,
  variant: u,
  children: s,
  ...G
}) {
  return u || (u = "outline"), /* @__PURE__ */ B.jsx(
    uD,
    {
      ...G,
      variant: u,
      className: Um(l, [
        "gap-1",
        "pressed:scale-[0.97] pressed:opacity-75",
        "group-data-[ui=button-group]:pressed:scale-100",
        "group-data-[ui=button-group]:pressed:opacity-100",
        u === "unstyle" ? "" : "px-2.5"
      ]),
      children: (i) => /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
        typeof s == "function" ? s(i) : s,
        !Z && /* @__PURE__ */ B.jsx(
          $B,
          {
            strokeWidth: 2.5,
            className: lb(
              !!s && "ms-1",
              "[.justify-start_&]:ms-auto [[data-variant=outline]:not(:hover)_&]:text-muted"
            )
          }
        )
      ] })
    }
  );
}
function x7({ className: l, ...Z }) {
  return /* @__PURE__ */ B.jsx(
    lD,
    {
      ...Z,
      className: Um(
        l,
        lb(
          "dark:bg-zinc-800",
          "dark:ring-zinc-700",
          "max-w-72",
          "rounded-lg",
          "min-w-[max(144px,var(--trigger-width))]",
          "has-[[data-ui=item]_[data-ui=icon]]:min-w-[max(200px,var(--trigger-width))]",
          "has-[[data-ui=item]_kbd]:min-w-[max(176px,var(--trigger-width))]"
        )
      )
    }
  );
}
function R7(l) {
  return /* @__PURE__ */ B.jsx(
    hB,
    {
      ...l,
      className: lb(
        "flex max-h-[inherit] flex-col overflow-auto outline-none",
        "p-1 has-[header]:px-2 has-[header]:pt-0",
        // MeuItem style
        "[&_[data-ui=item]]:flex-1",
        "[&_[data-ui=item]]:grid",
        "[&_[data-ui=item]:has([data-ui=label])]:grid-cols-[16px_1fr_minmax(50px,max-content)]",
        "[&_[data-ui=item]]:items-center",
        "[&_[data-ui=item]]:gap-x-2",
        // icon
        "[&_[data-ui=item]>[data-ui=icon]:not([class*=text-])]:text-muted",
        "[&_[data-ui=item][data-destructive]>[data-ui=icon]]:text-destructive/75",
        "[&:has([data-ui=icon]+[data-ui=label])_[data-ui=item]>[data-ui=icon]:not([class*=size-])]:size-4",
        "[&:has([data-ui=icon]+[data-ui=label])_[data-ui=item]>[data-ui=icon]]:col-start-1",
        "[&_[data-ui=item]>[data-ui=label]]:col-span-full",
        "[&:has([data-ui=icon]+[data-ui=label])_[data-ui=item]>[data-ui=label]]:col-start-2",
        // kbd
        "[&:has([data-ui=kbd])_[data-ui=item]>[data-ui=label]]:col-end-[-2]",
        "[&_[data-ui=item]>[data-ui=kbd]]:col-span-1",
        "[&_[data-ui=item]>[data-ui=kbd]]:row-start-1",
        "[&_[data-ui=item]>[data-ui=kbd]]:col-start-3",
        "[&_[data-ui=item]>[data-ui=kbd]]:justify-self-end",
        "[&_[data-ui=item][data-destructive]>[data-ui=kbd]]:text-destructive",
        // Description
        "[&_[data-ui=item]>[data-ui=description]]:col-span-full",
        "[&:has([data-ui=kbd])_[data-ui=item]>[data-ui=description]]:col-end-[-2]",
        "[&:has([data-ui=icon]+[data-ui=label]+[data-ui=description])_[data-ui=item]>[data-ui=description]]:col-start-2",
        l.className
      )
    }
  );
}
function Y7({ className: l }) {
  return /* @__PURE__ */ B.jsx(
    $4,
    {
      className: lb(
        "my-1 w-[calc(100%-24px)] self-center border-t border-zinc-950/5 dark:border-white/10",
        l
      )
    }
  );
}
function _K({ destructive: l, ...Z }) {
  return /* @__PURE__ */ B.jsx(
    SB,
    {
      ...Z,
      className: nW(
        Z.className,
        (u, { isFocused: s, isDisabled: G }) => lb([
          "group flex cursor-default select-none items-center gap-x-2 outline-none",
          "px-3 py-2.5 sm:py-1.5 [&[data-selection-mode]]:px-2",
          "rounded-md",
          "text-base/6 sm:text-sm/6",
          G && "opacity-50",
          s && "bg-zinc-100 dark:bg-zinc-700",
          l && "text-destructive",
          u
        ])
      ),
      children: nW(
        Z.children,
        (u, { selectionMode: s, isSelected: G, isHovered: i }) => /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
          s !== "none" && /* @__PURE__ */ B.jsx(
            "span",
            {
              "data-ui": "icon",
              className: lb(
                "flex w-4 self-start",
                G && "mt-[5px]"
              ),
              children: G && /* @__PURE__ */ B.jsx(AB, { className: "size-4" })
            }
          ),
          /* @__PURE__ */ B.jsx(
            "div",
            {
              "data-ui": "item",
              "data-destructive": l || void 0,
              "data-hovered": i,
              children: u
            }
          ),
          /* @__PURE__ */ B.jsx(qB, { className: "-me-2 hidden size-4 text-muted group-data-[has-submenu]:inline-block" })
        ] })
      )
    }
  );
}
function lW({
  className: l,
  ...Z
}) {
  return /* @__PURE__ */ B.jsx(
    "span",
    {
      slot: "label",
      "data-ui": "label",
      className: lb("mb-0 truncate", l),
      ...Z
    }
  );
}
function ZW({
  className: l,
  ...Z
}) {
  return /* @__PURE__ */ B.jsx(
    cD,
    {
      slot: "description",
      "data-ui": "description",
      className: l,
      ...Z
    }
  );
}
function k7({ timeout: l = 2e3 } = {}) {
  const [Z, u] = tl.useState(null), [s, G] = tl.useState(!1), [i, m] = tl.useState(null), a = (y) => {
    window.clearTimeout(i), m(window.setTimeout(() => G(!1), l)), G(y);
  };
  return { copy: (y) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(y).then(() => a(!0)).catch((h) => u(h)) : u(new Error("useCopyToClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    G(!1), u(null), window.clearTimeout(i);
  }, error: Z, copied: s };
}
var Wn = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(l) {
    return this.listeners.add(l), this.onSubscribe(), () => {
      this.listeners.delete(l), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Ym = typeof window > "u" || "Deno" in globalThis;
function pu() {
}
function M7(l, Z) {
  return typeof l == "function" ? l(Z) : l;
}
function OW(l) {
  return typeof l == "number" && l >= 0 && l !== 1 / 0;
}
function Lr(l, Z) {
  return Math.max(l + (Z || 0) - Date.now(), 0);
}
function Ai(l, Z) {
  return typeof l == "function" ? l(Z) : l;
}
function Tu(l, Z) {
  return typeof l == "function" ? l(Z) : l;
}
function jM(l, Z) {
  const {
    type: u = "all",
    exact: s,
    fetchStatus: G,
    predicate: i,
    queryKey: m,
    stale: a
  } = l;
  if (m) {
    if (s) {
      if (Z.queryHash !== Zx(m, Z.options))
        return !1;
    } else if (!un(Z.queryKey, m))
      return !1;
  }
  if (u !== "all") {
    const n = Z.isActive();
    if (u === "active" && !n || u === "inactive" && n)
      return !1;
  }
  return !(typeof a == "boolean" && Z.isStale() !== a || G && G !== Z.state.fetchStatus || i && !i(Z));
}
function QM(l, Z) {
  const { exact: u, status: s, predicate: G, mutationKey: i } = l;
  if (i) {
    if (!Z.options.mutationKey)
      return !1;
    if (u) {
      if (bn(Z.options.mutationKey) !== bn(i))
        return !1;
    } else if (!un(Z.options.mutationKey, i))
      return !1;
  }
  return !(s && Z.state.status !== s || G && !G(Z));
}
function Zx(l, Z) {
  return ((Z == null ? void 0 : Z.queryKeyHashFn) || bn)(l);
}
function bn(l) {
  return JSON.stringify(
    l,
    (Z, u) => qW(u) ? Object.keys(u).sort().reduce((s, G) => (s[G] = u[G], s), {}) : u
  );
}
function un(l, Z) {
  return l === Z ? !0 : typeof l != typeof Z ? !1 : l && Z && typeof l == "object" && typeof Z == "object" ? !Object.keys(Z).some((u) => !un(l[u], Z[u])) : !1;
}
function AW(l, Z) {
  if (l === Z)
    return l;
  const u = PM(l) && PM(Z);
  if (u || qW(l) && qW(Z)) {
    const s = u ? l : Object.keys(l), G = s.length, i = u ? Z : Object.keys(Z), m = i.length, a = u ? [] : {};
    let n = 0;
    for (let p = 0; p < m; p++) {
      const y = u ? p : i[p];
      (!u && s.includes(y) || u) && l[y] === void 0 && Z[y] === void 0 ? (a[y] = void 0, n++) : (a[y] = AW(l[y], Z[y]), a[y] === l[y] && l[y] !== void 0 && n++);
    }
    return G === m && n === G ? l : a;
  }
  return Z;
}
function $W(l, Z) {
  if (!Z || Object.keys(l).length !== Object.keys(Z).length)
    return !1;
  for (const u in l)
    if (l[u] !== Z[u])
      return !1;
  return !0;
}
function PM(l) {
  return Array.isArray(l) && l.length === Object.keys(l).length;
}
function qW(l) {
  if (!OM(l))
    return !1;
  const Z = l.constructor;
  if (Z === void 0)
    return !0;
  const u = Z.prototype;
  return !(!OM(u) || !u.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(l) !== Object.prototype);
}
function OM(l) {
  return Object.prototype.toString.call(l) === "[object Object]";
}
function I7(l) {
  return new Promise((Z) => {
    setTimeout(Z, l);
  });
}
function _W(l, Z, u) {
  if (typeof u.structuralSharing == "function")
    return u.structuralSharing(l, Z);
  if (u.structuralSharing !== !1) {
    try {
      return AW(l, Z);
    } catch (s) {
      console.error(
        `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${u.queryHash}]: ${s}`
      );
    }
    return AW(l, Z);
  }
  return Z;
}
function U7(l) {
  return l;
}
function C7(l, Z, u = 0) {
  const s = [...l, Z];
  return u && s.length > u ? s.slice(1) : s;
}
function r7(l, Z, u = 0) {
  const s = [Z, ...l];
  return u && s.length > u ? s.slice(0, -1) : s;
}
var Ih = Symbol();
function hr(l, Z) {
  return l.queryFn === Ih && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${l.queryHash}'`
  ), !l.queryFn && (Z != null && Z.initialPromise) ? () => Z.initialPromise : !l.queryFn || l.queryFn === Ih ? () => Promise.reject(new Error(`Missing queryFn: '${l.queryHash}'`)) : l.queryFn;
}
var Gm, dG, $i, FI, F7 = (FI = class extends Wn {
  constructor() {
    super();
    ZZ(this, Gm);
    ZZ(this, dG);
    ZZ(this, $i);
    vl(this, $i, (Z) => {
      if (!Ym && window.addEventListener) {
        const u = () => Z();
        return window.addEventListener("visibilitychange", u, !1), () => {
          window.removeEventListener("visibilitychange", u);
        };
      }
    });
  }
  onSubscribe() {
    ll(this, dG) || this.setEventListener(ll(this, $i));
  }
  onUnsubscribe() {
    var Z;
    this.hasListeners() || ((Z = ll(this, dG)) == null || Z.call(this), vl(this, dG, void 0));
  }
  setEventListener(Z) {
    var u;
    vl(this, $i, Z), (u = ll(this, dG)) == null || u.call(this), vl(this, dG, Z((s) => {
      typeof s == "boolean" ? this.setFocused(s) : this.onFocus();
    }));
  }
  setFocused(Z) {
    ll(this, Gm) !== Z && (vl(this, Gm, Z), this.onFocus());
  }
  onFocus() {
    const Z = this.isFocused();
    this.listeners.forEach((u) => {
      u(Z);
    });
  }
  isFocused() {
    var Z;
    return typeof ll(this, Gm) == "boolean" ? ll(this, Gm) : ((Z = globalThis.document) == null ? void 0 : Z.visibilityState) !== "hidden";
  }
}, Gm = new WeakMap(), dG = new WeakMap(), $i = new WeakMap(), FI), cx = new F7(), qi, GG, _i, NI, N7 = (NI = class extends Wn {
  constructor() {
    super();
    ZZ(this, qi, !0);
    ZZ(this, GG);
    ZZ(this, _i);
    vl(this, _i, (Z) => {
      if (!Ym && window.addEventListener) {
        const u = () => Z(!0), s = () => Z(!1);
        return window.addEventListener("online", u, !1), window.addEventListener("offline", s, !1), () => {
          window.removeEventListener("online", u), window.removeEventListener("offline", s);
        };
      }
    });
  }
  onSubscribe() {
    ll(this, GG) || this.setEventListener(ll(this, _i));
  }
  onUnsubscribe() {
    var Z;
    this.hasListeners() || ((Z = ll(this, GG)) == null || Z.call(this), vl(this, GG, void 0));
  }
  setEventListener(Z) {
    var u;
    vl(this, _i, Z), (u = ll(this, GG)) == null || u.call(this), vl(this, GG, Z(this.setOnline.bind(this)));
  }
  setOnline(Z) {
    ll(this, qi) !== Z && (vl(this, qi, Z), this.listeners.forEach((s) => {
      s(Z);
    }));
  }
  isOnline() {
    return ll(this, qi);
  }
}, qi = new WeakMap(), GG = new WeakMap(), _i = new WeakMap(), NI), Uh = new N7();
function lV() {
  let l, Z;
  const u = new Promise((G, i) => {
    l = G, Z = i;
  });
  u.status = "pending", u.catch(() => {
  });
  function s(G) {
    Object.assign(u, G), delete u.resolve, delete u.reject;
  }
  return u.resolve = (G) => {
    s({
      status: "fulfilled",
      value: G
    }), l(G);
  }, u.reject = (G) => {
    s({
      status: "rejected",
      reason: G
    }), Z(G);
  }, u;
}
function w7(l) {
  return Math.min(1e3 * 2 ** l, 3e4);
}
function yr(l) {
  return (l ?? "online") === "online" ? Uh.isOnline() : !0;
}
var Sr = class extends Error {
  constructor(l) {
    super("CancelledError"), this.revert = l == null ? void 0 : l.revert, this.silent = l == null ? void 0 : l.silent;
  }
};
function cW(l) {
  return l instanceof Sr;
}
function tr(l) {
  let Z = !1, u = 0, s = !1, G;
  const i = lV(), m = (V) => {
    var R;
    s || (S(new Sr(V)), (R = l.abort) == null || R.call(l));
  }, a = () => {
    Z = !0;
  }, n = () => {
    Z = !1;
  }, p = () => cx.isFocused() && (l.networkMode === "always" || Uh.isOnline()) && l.canRun(), y = () => yr(l.networkMode) && l.canRun(), h = (V) => {
    var R;
    s || (s = !0, (R = l.onSuccess) == null || R.call(l, V), G == null || G(), i.resolve(V));
  }, S = (V) => {
    var R;
    s || (s = !0, (R = l.onError) == null || R.call(l, V), G == null || G(), i.reject(V));
  }, t = () => new Promise((V) => {
    var R;
    G = (x) => {
      (s || p()) && V(x);
    }, (R = l.onPause) == null || R.call(l);
  }).then(() => {
    var V;
    G = void 0, s || (V = l.onContinue) == null || V.call(l);
  }), W = () => {
    if (s)
      return;
    let V;
    const R = u === 0 ? l.initialPromise : void 0;
    try {
      V = R ?? l.fn();
    } catch (x) {
      V = Promise.reject(x);
    }
    Promise.resolve(V).then(h).catch((x) => {
      var z;
      if (s)
        return;
      const r = l.retry ?? (Ym ? 0 : 3), k = l.retryDelay ?? w7, U = typeof k == "function" ? k(u, x) : k, w = r === !0 || typeof r == "number" && u < r || typeof r == "function" && r(u, x);
      if (Z || !w) {
        S(x);
        return;
      }
      u++, (z = l.onFail) == null || z.call(l, u, x), I7(U).then(() => p() ? void 0 : t()).then(() => {
        Z ? S(x) : W();
      });
    });
  };
  return {
    promise: i,
    cancel: m,
    continue: () => (G == null || G(), i),
    cancelRetry: a,
    continueRetry: n,
    canStart: y,
    start: () => (y() ? W() : t().then(W), i)
  };
}
function z7() {
  let l = [], Z = 0, u = (a) => {
    a();
  }, s = (a) => {
    a();
  }, G = (a) => setTimeout(a, 0);
  const i = (a) => {
    Z ? l.push(a) : G(() => {
      u(a);
    });
  }, m = () => {
    const a = l;
    l = [], a.length && G(() => {
      s(() => {
        a.forEach((n) => {
          u(n);
        });
      });
    });
  };
  return {
    batch: (a) => {
      let n;
      Z++;
      try {
        n = a();
      } finally {
        Z--, Z || m();
      }
      return n;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (a) => (...n) => {
      i(() => {
        a(...n);
      });
    },
    schedule: i,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (a) => {
      u = a;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (a) => {
      s = a;
    },
    setScheduler: (a) => {
      G = a;
    }
  };
}
var _c = z7(), mm, wI, Xr = (wI = class {
  constructor() {
    ZZ(this, mm);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), OW(this.gcTime) && vl(this, mm, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(l) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      l ?? (Ym ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    ll(this, mm) && (clearTimeout(ll(this, mm)), vl(this, mm, void 0));
  }
}, mm = new WeakMap(), wI), lo, Zo, nu, eb, mn, im, Hu, bd, zI, J7 = (zI = class extends Xr {
  constructor(Z) {
    super();
    ZZ(this, Hu);
    ZZ(this, lo);
    ZZ(this, Zo);
    ZZ(this, nu);
    ZZ(this, eb);
    ZZ(this, mn);
    ZZ(this, im);
    vl(this, im, !1), vl(this, mn, Z.defaultOptions), this.setOptions(Z.options), this.observers = [], vl(this, nu, Z.cache), this.queryKey = Z.queryKey, this.queryHash = Z.queryHash, vl(this, lo, H7(this.options)), this.state = Z.state ?? ll(this, lo), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var Z;
    return (Z = ll(this, eb)) == null ? void 0 : Z.promise;
  }
  setOptions(Z) {
    this.options = { ...ll(this, mn), ...Z }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && ll(this, nu).remove(this);
  }
  setData(Z, u) {
    const s = _W(this.state.data, Z, this.options);
    return XZ(this, Hu, bd).call(this, {
      data: s,
      type: "success",
      dataUpdatedAt: u == null ? void 0 : u.updatedAt,
      manual: u == null ? void 0 : u.manual
    }), s;
  }
  setState(Z, u) {
    XZ(this, Hu, bd).call(this, { type: "setState", state: Z, setStateOptions: u });
  }
  cancel(Z) {
    var s, G;
    const u = (s = ll(this, eb)) == null ? void 0 : s.promise;
    return (G = ll(this, eb)) == null || G.cancel(Z), u ? u.then(pu).catch(pu) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(ll(this, lo));
  }
  isActive() {
    return this.observers.some(
      (Z) => Tu(Z.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Ih || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (Z) => Z.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(Z = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !Lr(this.state.dataUpdatedAt, Z);
  }
  onFocus() {
    var u;
    const Z = this.observers.find((s) => s.shouldFetchOnWindowFocus());
    Z == null || Z.refetch({ cancelRefetch: !1 }), (u = ll(this, eb)) == null || u.continue();
  }
  onOnline() {
    var u;
    const Z = this.observers.find((s) => s.shouldFetchOnReconnect());
    Z == null || Z.refetch({ cancelRefetch: !1 }), (u = ll(this, eb)) == null || u.continue();
  }
  addObserver(Z) {
    this.observers.includes(Z) || (this.observers.push(Z), this.clearGcTimeout(), ll(this, nu).notify({ type: "observerAdded", query: this, observer: Z }));
  }
  removeObserver(Z) {
    this.observers.includes(Z) && (this.observers = this.observers.filter((u) => u !== Z), this.observers.length || (ll(this, eb) && (ll(this, im) ? ll(this, eb).cancel({ revert: !0 }) : ll(this, eb).cancelRetry()), this.scheduleGc()), ll(this, nu).notify({ type: "observerRemoved", query: this, observer: Z }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || XZ(this, Hu, bd).call(this, { type: "invalidate" });
  }
  fetch(Z, u) {
    var n, p, y;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (u != null && u.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (ll(this, eb))
        return ll(this, eb).continueRetry(), ll(this, eb).promise;
    }
    if (Z && this.setOptions(Z), !this.options.queryFn) {
      const h = this.observers.find((S) => S.options.queryFn);
      h && this.setOptions(h.options);
    }
    Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    );
    const s = new AbortController(), G = (h) => {
      Object.defineProperty(h, "signal", {
        enumerable: !0,
        get: () => (vl(this, im, !0), s.signal)
      });
    }, i = () => {
      const h = hr(this.options, u), S = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return G(S), vl(this, im, !1), this.options.persister ? this.options.persister(
        h,
        S,
        this
      ) : h(S);
    }, m = {
      fetchOptions: u,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: i
    };
    G(m), (n = this.options.behavior) == null || n.onFetch(
      m,
      this
    ), vl(this, Zo, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((p = m.fetchOptions) == null ? void 0 : p.meta)) && XZ(this, Hu, bd).call(this, { type: "fetch", meta: (y = m.fetchOptions) == null ? void 0 : y.meta });
    const a = (h) => {
      var S, t, W, V;
      cW(h) && h.silent || XZ(this, Hu, bd).call(this, {
        type: "error",
        error: h
      }), cW(h) || ((t = (S = ll(this, nu).config).onError) == null || t.call(
        S,
        h,
        this
      ), (V = (W = ll(this, nu).config).onSettled) == null || V.call(
        W,
        this.state.data,
        h,
        this
      )), this.scheduleGc();
    };
    return vl(this, eb, tr({
      initialPromise: u == null ? void 0 : u.initialPromise,
      fn: m.fetchFn,
      abort: s.abort.bind(s),
      onSuccess: (h) => {
        var S, t, W, V;
        if (h === void 0) {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), a(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(h);
        } catch (R) {
          a(R);
          return;
        }
        (t = (S = ll(this, nu).config).onSuccess) == null || t.call(S, h, this), (V = (W = ll(this, nu).config).onSettled) == null || V.call(
          W,
          h,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: a,
      onFail: (h, S) => {
        XZ(this, Hu, bd).call(this, { type: "failed", failureCount: h, error: S });
      },
      onPause: () => {
        XZ(this, Hu, bd).call(this, { type: "pause" });
      },
      onContinue: () => {
        XZ(this, Hu, bd).call(this, { type: "continue" });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay,
      networkMode: m.options.networkMode,
      canRun: () => !0
    })), ll(this, eb).start();
  }
}, lo = new WeakMap(), Zo = new WeakMap(), nu = new WeakMap(), eb = new WeakMap(), mn = new WeakMap(), im = new WeakMap(), Hu = new WeakSet(), bd = function(Z) {
  const u = (s) => {
    switch (Z.type) {
      case "failed":
        return {
          ...s,
          fetchFailureCount: Z.failureCount,
          fetchFailureReason: Z.error
        };
      case "pause":
        return {
          ...s,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...s,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...s,
          ...Kr(s.data, this.options),
          fetchMeta: Z.meta ?? null
        };
      case "success":
        return {
          ...s,
          data: Z.data,
          dataUpdateCount: s.dataUpdateCount + 1,
          dataUpdatedAt: Z.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!Z.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const G = Z.error;
        return cW(G) && G.revert && ll(this, Zo) ? { ...ll(this, Zo), fetchStatus: "idle" } : {
          ...s,
          error: G,
          errorUpdateCount: s.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: s.fetchFailureCount + 1,
          fetchFailureReason: G,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...s,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...s,
          ...Z.state
        };
    }
  };
  this.state = u(this.state), _c.batch(() => {
    this.observers.forEach((s) => {
      s.onQueryUpdate();
    }), ll(this, nu).notify({ query: this, type: "updated", action: Z });
  });
}, zI);
function Kr(l, Z) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: yr(Z.networkMode) ? "fetching" : "paused",
    ...l === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function H7(l) {
  const Z = typeof l.initialData == "function" ? l.initialData() : l.initialData, u = Z !== void 0, s = u ? typeof l.initialDataUpdatedAt == "function" ? l.initialDataUpdatedAt() : l.initialDataUpdatedAt : 0;
  return {
    data: Z,
    dataUpdateCount: 0,
    dataUpdatedAt: u ? s ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: u ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var es, JI, g7 = (JI = class extends Wn {
  constructor(Z = {}) {
    super();
    ZZ(this, es);
    this.config = Z, vl(this, es, /* @__PURE__ */ new Map());
  }
  build(Z, u, s) {
    const G = u.queryKey, i = u.queryHash ?? Zx(G, u);
    let m = this.get(i);
    return m || (m = new J7({
      cache: this,
      queryKey: G,
      queryHash: i,
      options: Z.defaultQueryOptions(u),
      state: s,
      defaultOptions: Z.getQueryDefaults(G)
    }), this.add(m)), m;
  }
  add(Z) {
    ll(this, es).has(Z.queryHash) || (ll(this, es).set(Z.queryHash, Z), this.notify({
      type: "added",
      query: Z
    }));
  }
  remove(Z) {
    const u = ll(this, es).get(Z.queryHash);
    u && (Z.destroy(), u === Z && ll(this, es).delete(Z.queryHash), this.notify({ type: "removed", query: Z }));
  }
  clear() {
    _c.batch(() => {
      this.getAll().forEach((Z) => {
        this.remove(Z);
      });
    });
  }
  get(Z) {
    return ll(this, es).get(Z);
  }
  getAll() {
    return [...ll(this, es).values()];
  }
  find(Z) {
    const u = { exact: !0, ...Z };
    return this.getAll().find(
      (s) => jM(u, s)
    );
  }
  findAll(Z = {}) {
    const u = this.getAll();
    return Object.keys(Z).length > 0 ? u.filter((s) => jM(Z, s)) : u;
  }
  notify(Z) {
    _c.batch(() => {
      this.listeners.forEach((u) => {
        u(Z);
      });
    });
  }
  onFocus() {
    _c.batch(() => {
      this.getAll().forEach((Z) => {
        Z.onFocus();
      });
    });
  }
  onOnline() {
    _c.batch(() => {
      this.getAll().forEach((Z) => {
        Z.onOnline();
      });
    });
  }
}, es = new WeakMap(), JI), as, Vb, om, ns, bG, HI, v7 = (HI = class extends Xr {
  constructor(Z) {
    super();
    ZZ(this, ns);
    ZZ(this, as);
    ZZ(this, Vb);
    ZZ(this, om);
    this.mutationId = Z.mutationId, vl(this, Vb, Z.mutationCache), vl(this, as, []), this.state = Z.state || T7(), this.setOptions(Z.options), this.scheduleGc();
  }
  setOptions(Z) {
    this.options = Z, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(Z) {
    ll(this, as).includes(Z) || (ll(this, as).push(Z), this.clearGcTimeout(), ll(this, Vb).notify({
      type: "observerAdded",
      mutation: this,
      observer: Z
    }));
  }
  removeObserver(Z) {
    vl(this, as, ll(this, as).filter((u) => u !== Z)), this.scheduleGc(), ll(this, Vb).notify({
      type: "observerRemoved",
      mutation: this,
      observer: Z
    });
  }
  optionalRemove() {
    ll(this, as).length || (this.state.status === "pending" ? this.scheduleGc() : ll(this, Vb).remove(this));
  }
  continue() {
    var Z;
    return ((Z = ll(this, om)) == null ? void 0 : Z.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(Z) {
    var G, i, m, a, n, p, y, h, S, t, W, V, R, x, r, k, U, w, z, D;
    vl(this, om, tr({
      fn: () => this.options.mutationFn ? this.options.mutationFn(Z) : Promise.reject(new Error("No mutationFn found")),
      onFail: (C, j) => {
        XZ(this, ns, bG).call(this, { type: "failed", failureCount: C, error: j });
      },
      onPause: () => {
        XZ(this, ns, bG).call(this, { type: "pause" });
      },
      onContinue: () => {
        XZ(this, ns, bG).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => ll(this, Vb).canRun(this)
    }));
    const u = this.state.status === "pending", s = !ll(this, om).canStart();
    try {
      if (!u) {
        XZ(this, ns, bG).call(this, { type: "pending", variables: Z, isPaused: s }), await ((i = (G = ll(this, Vb).config).onMutate) == null ? void 0 : i.call(
          G,
          Z,
          this
        ));
        const j = await ((a = (m = this.options).onMutate) == null ? void 0 : a.call(m, Z));
        j !== this.state.context && XZ(this, ns, bG).call(this, {
          type: "pending",
          context: j,
          variables: Z,
          isPaused: s
        });
      }
      const C = await ll(this, om).start();
      return await ((p = (n = ll(this, Vb).config).onSuccess) == null ? void 0 : p.call(
        n,
        C,
        Z,
        this.state.context,
        this
      )), await ((h = (y = this.options).onSuccess) == null ? void 0 : h.call(y, C, Z, this.state.context)), await ((t = (S = ll(this, Vb).config).onSettled) == null ? void 0 : t.call(
        S,
        C,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((V = (W = this.options).onSettled) == null ? void 0 : V.call(W, C, null, Z, this.state.context)), XZ(this, ns, bG).call(this, { type: "success", data: C }), C;
    } catch (C) {
      try {
        throw await ((x = (R = ll(this, Vb).config).onError) == null ? void 0 : x.call(
          R,
          C,
          Z,
          this.state.context,
          this
        )), await ((k = (r = this.options).onError) == null ? void 0 : k.call(
          r,
          C,
          Z,
          this.state.context
        )), await ((w = (U = ll(this, Vb).config).onSettled) == null ? void 0 : w.call(
          U,
          void 0,
          C,
          this.state.variables,
          this.state.context,
          this
        )), await ((D = (z = this.options).onSettled) == null ? void 0 : D.call(
          z,
          void 0,
          C,
          Z,
          this.state.context
        )), C;
      } finally {
        XZ(this, ns, bG).call(this, { type: "error", error: C });
      }
    } finally {
      ll(this, Vb).runNext(this);
    }
  }
}, as = new WeakMap(), Vb = new WeakMap(), om = new WeakMap(), ns = new WeakSet(), bG = function(Z) {
  const u = (s) => {
    switch (Z.type) {
      case "failed":
        return {
          ...s,
          failureCount: Z.failureCount,
          failureReason: Z.error
        };
      case "pause":
        return {
          ...s,
          isPaused: !0
        };
      case "continue":
        return {
          ...s,
          isPaused: !1
        };
      case "pending":
        return {
          ...s,
          context: Z.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: Z.isPaused,
          status: "pending",
          variables: Z.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...s,
          data: Z.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...s,
          data: void 0,
          error: Z.error,
          failureCount: s.failureCount + 1,
          failureReason: Z.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = u(this.state), _c.batch(() => {
    ll(this, as).forEach((s) => {
      s.onMutationUpdate(Z);
    }), ll(this, Vb).notify({
      mutation: this,
      type: "updated",
      action: Z
    });
  });
}, HI);
function T7() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var _b, on, gI, f7 = (gI = class extends Wn {
  constructor(Z = {}) {
    super();
    ZZ(this, _b);
    ZZ(this, on);
    this.config = Z, vl(this, _b, /* @__PURE__ */ new Map()), vl(this, on, Date.now());
  }
  build(Z, u, s) {
    const G = new v7({
      mutationCache: this,
      mutationId: ++gL(this, on)._,
      options: Z.defaultMutationOptions(u),
      state: s
    });
    return this.add(G), G;
  }
  add(Z) {
    const u = ch(Z), s = ll(this, _b).get(u) ?? [];
    s.push(Z), ll(this, _b).set(u, s), this.notify({ type: "added", mutation: Z });
  }
  remove(Z) {
    var s;
    const u = ch(Z);
    if (ll(this, _b).has(u)) {
      const G = (s = ll(this, _b).get(u)) == null ? void 0 : s.filter((i) => i !== Z);
      G && (G.length === 0 ? ll(this, _b).delete(u) : ll(this, _b).set(u, G));
    }
    this.notify({ type: "removed", mutation: Z });
  }
  canRun(Z) {
    var s;
    const u = (s = ll(this, _b).get(ch(Z))) == null ? void 0 : s.find((G) => G.state.status === "pending");
    return !u || u === Z;
  }
  runNext(Z) {
    var s;
    const u = (s = ll(this, _b).get(ch(Z))) == null ? void 0 : s.find((G) => G !== Z && G.state.isPaused);
    return (u == null ? void 0 : u.continue()) ?? Promise.resolve();
  }
  clear() {
    _c.batch(() => {
      this.getAll().forEach((Z) => {
        this.remove(Z);
      });
    });
  }
  getAll() {
    return [...ll(this, _b).values()].flat();
  }
  find(Z) {
    const u = { exact: !0, ...Z };
    return this.getAll().find(
      (s) => QM(u, s)
    );
  }
  findAll(Z = {}) {
    return this.getAll().filter((u) => QM(Z, u));
  }
  notify(Z) {
    _c.batch(() => {
      this.listeners.forEach((u) => {
        u(Z);
      });
    });
  }
  resumePausedMutations() {
    const Z = this.getAll().filter((u) => u.state.isPaused);
    return _c.batch(
      () => Promise.all(
        Z.map((u) => u.continue().catch(pu))
      )
    );
  }
}, _b = new WeakMap(), on = new WeakMap(), gI);
function ch(l) {
  var Z;
  return ((Z = l.options.scope) == null ? void 0 : Z.id) ?? String(l.mutationId);
}
function AM(l) {
  return {
    onFetch: (Z, u) => {
      var y, h, S, t, W;
      const s = Z.options, G = (S = (h = (y = Z.fetchOptions) == null ? void 0 : y.meta) == null ? void 0 : h.fetchMore) == null ? void 0 : S.direction, i = ((t = Z.state.data) == null ? void 0 : t.pages) || [], m = ((W = Z.state.data) == null ? void 0 : W.pageParams) || [];
      let a = { pages: [], pageParams: [] }, n = 0;
      const p = async () => {
        let V = !1;
        const R = (k) => {
          Object.defineProperty(k, "signal", {
            enumerable: !0,
            get: () => (Z.signal.aborted ? V = !0 : Z.signal.addEventListener("abort", () => {
              V = !0;
            }), Z.signal)
          });
        }, x = hr(Z.options, Z.fetchOptions), r = async (k, U, w) => {
          if (V)
            return Promise.reject();
          if (U == null && k.pages.length)
            return Promise.resolve(k);
          const z = {
            queryKey: Z.queryKey,
            pageParam: U,
            direction: w ? "backward" : "forward",
            meta: Z.options.meta
          };
          R(z);
          const D = await x(
            z
          ), { maxPages: C } = Z.options, j = w ? r7 : C7;
          return {
            pages: j(k.pages, D, C),
            pageParams: j(k.pageParams, U, C)
          };
        };
        if (G && i.length) {
          const k = G === "backward", U = k ? E7 : $M, w = {
            pages: i,
            pageParams: m
          }, z = U(s, w);
          a = await r(w, z, k);
        } else {
          const k = l ?? i.length;
          do {
            const U = n === 0 ? m[0] ?? s.initialPageParam : $M(s, a);
            if (n > 0 && U == null)
              break;
            a = await r(a, U), n++;
          } while (n < k);
        }
        return a;
      };
      Z.options.persister ? Z.fetchFn = () => {
        var V, R;
        return (R = (V = Z.options).persister) == null ? void 0 : R.call(
          V,
          p,
          {
            queryKey: Z.queryKey,
            meta: Z.options.meta,
            signal: Z.signal
          },
          u
        );
      } : Z.fetchFn = p;
    }
  };
}
function $M(l, { pages: Z, pageParams: u }) {
  const s = Z.length - 1;
  return Z.length > 0 ? l.getNextPageParam(
    Z[s],
    Z,
    u[s],
    u
  ) : void 0;
}
function E7(l, { pages: Z, pageParams: u }) {
  var s;
  return Z.length > 0 ? (s = l.getPreviousPageParam) == null ? void 0 : s.call(l, Z[0], Z, u[0], u) : void 0;
}
var ic, mG, iG, co, bo, oG, uo, so, vI, B7 = (vI = class {
  constructor(l = {}) {
    ZZ(this, ic);
    ZZ(this, mG);
    ZZ(this, iG);
    ZZ(this, co);
    ZZ(this, bo);
    ZZ(this, oG);
    ZZ(this, uo);
    ZZ(this, so);
    vl(this, ic, l.queryCache || new g7()), vl(this, mG, l.mutationCache || new f7()), vl(this, iG, l.defaultOptions || {}), vl(this, co, /* @__PURE__ */ new Map()), vl(this, bo, /* @__PURE__ */ new Map()), vl(this, oG, 0);
  }
  mount() {
    gL(this, oG)._++, ll(this, oG) === 1 && (vl(this, uo, cx.subscribe(async (l) => {
      l && (await this.resumePausedMutations(), ll(this, ic).onFocus());
    })), vl(this, so, Uh.subscribe(async (l) => {
      l && (await this.resumePausedMutations(), ll(this, ic).onOnline());
    })));
  }
  unmount() {
    var l, Z;
    gL(this, oG)._--, ll(this, oG) === 0 && ((l = ll(this, uo)) == null || l.call(this), vl(this, uo, void 0), (Z = ll(this, so)) == null || Z.call(this), vl(this, so, void 0));
  }
  isFetching(l) {
    return ll(this, ic).findAll({ ...l, fetchStatus: "fetching" }).length;
  }
  isMutating(l) {
    return ll(this, mG).findAll({ ...l, status: "pending" }).length;
  }
  getQueryData(l) {
    var u;
    const Z = this.defaultQueryOptions({ queryKey: l });
    return (u = ll(this, ic).get(Z.queryHash)) == null ? void 0 : u.state.data;
  }
  ensureQueryData(l) {
    const Z = this.getQueryData(l.queryKey);
    if (Z === void 0)
      return this.fetchQuery(l);
    {
      const u = this.defaultQueryOptions(l), s = ll(this, ic).build(this, u);
      return l.revalidateIfStale && s.isStaleByTime(Ai(u.staleTime, s)) && this.prefetchQuery(u), Promise.resolve(Z);
    }
  }
  getQueriesData(l) {
    return ll(this, ic).findAll(l).map(({ queryKey: Z, state: u }) => {
      const s = u.data;
      return [Z, s];
    });
  }
  setQueryData(l, Z, u) {
    const s = this.defaultQueryOptions({ queryKey: l }), G = ll(this, ic).get(
      s.queryHash
    ), i = G == null ? void 0 : G.state.data, m = M7(Z, i);
    if (m !== void 0)
      return ll(this, ic).build(this, s).setData(m, { ...u, manual: !0 });
  }
  setQueriesData(l, Z, u) {
    return _c.batch(
      () => ll(this, ic).findAll(l).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, Z, u)
      ])
    );
  }
  getQueryState(l) {
    var u;
    const Z = this.defaultQueryOptions({ queryKey: l });
    return (u = ll(this, ic).get(Z.queryHash)) == null ? void 0 : u.state;
  }
  removeQueries(l) {
    const Z = ll(this, ic);
    _c.batch(() => {
      Z.findAll(l).forEach((u) => {
        Z.remove(u);
      });
    });
  }
  resetQueries(l, Z) {
    const u = ll(this, ic), s = {
      type: "active",
      ...l
    };
    return _c.batch(() => (u.findAll(l).forEach((G) => {
      G.reset();
    }), this.refetchQueries(s, Z)));
  }
  cancelQueries(l = {}, Z = {}) {
    const u = { revert: !0, ...Z }, s = _c.batch(
      () => ll(this, ic).findAll(l).map((G) => G.cancel(u))
    );
    return Promise.all(s).then(pu).catch(pu);
  }
  invalidateQueries(l = {}, Z = {}) {
    return _c.batch(() => {
      if (ll(this, ic).findAll(l).forEach((s) => {
        s.invalidate();
      }), l.refetchType === "none")
        return Promise.resolve();
      const u = {
        ...l,
        type: l.refetchType ?? l.type ?? "active"
      };
      return this.refetchQueries(u, Z);
    });
  }
  refetchQueries(l = {}, Z) {
    const u = {
      ...Z,
      cancelRefetch: (Z == null ? void 0 : Z.cancelRefetch) ?? !0
    }, s = _c.batch(
      () => ll(this, ic).findAll(l).filter((G) => !G.isDisabled()).map((G) => {
        let i = G.fetch(void 0, u);
        return u.throwOnError || (i = i.catch(pu)), G.state.fetchStatus === "paused" ? Promise.resolve() : i;
      })
    );
    return Promise.all(s).then(pu);
  }
  fetchQuery(l) {
    const Z = this.defaultQueryOptions(l);
    Z.retry === void 0 && (Z.retry = !1);
    const u = ll(this, ic).build(this, Z);
    return u.isStaleByTime(
      Ai(Z.staleTime, u)
    ) ? u.fetch(Z) : Promise.resolve(u.state.data);
  }
  prefetchQuery(l) {
    return this.fetchQuery(l).then(pu).catch(pu);
  }
  fetchInfiniteQuery(l) {
    return l.behavior = AM(l.pages), this.fetchQuery(l);
  }
  prefetchInfiniteQuery(l) {
    return this.fetchInfiniteQuery(l).then(pu).catch(pu);
  }
  ensureInfiniteQueryData(l) {
    return l.behavior = AM(l.pages), this.ensureQueryData(l);
  }
  resumePausedMutations() {
    return Uh.isOnline() ? ll(this, mG).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return ll(this, ic);
  }
  getMutationCache() {
    return ll(this, mG);
  }
  getDefaultOptions() {
    return ll(this, iG);
  }
  setDefaultOptions(l) {
    vl(this, iG, l);
  }
  setQueryDefaults(l, Z) {
    ll(this, co).set(bn(l), {
      queryKey: l,
      defaultOptions: Z
    });
  }
  getQueryDefaults(l) {
    const Z = [...ll(this, co).values()];
    let u = {};
    return Z.forEach((s) => {
      un(l, s.queryKey) && (u = { ...u, ...s.defaultOptions });
    }), u;
  }
  setMutationDefaults(l, Z) {
    ll(this, bo).set(bn(l), {
      mutationKey: l,
      defaultOptions: Z
    });
  }
  getMutationDefaults(l) {
    const Z = [...ll(this, bo).values()];
    let u = {};
    return Z.forEach((s) => {
      un(l, s.mutationKey) && (u = { ...u, ...s.defaultOptions });
    }), u;
  }
  defaultQueryOptions(l) {
    if (l._defaulted)
      return l;
    const Z = {
      ...ll(this, iG).queries,
      ...this.getQueryDefaults(l.queryKey),
      ...l,
      _defaulted: !0
    };
    return Z.queryHash || (Z.queryHash = Zx(
      Z.queryKey,
      Z
    )), Z.refetchOnReconnect === void 0 && (Z.refetchOnReconnect = Z.networkMode !== "always"), Z.throwOnError === void 0 && (Z.throwOnError = !!Z.suspense), !Z.networkMode && Z.persister && (Z.networkMode = "offlineFirst"), Z.enabled !== !0 && Z.queryFn === Ih && (Z.enabled = !1), Z;
  }
  defaultMutationOptions(l) {
    return l != null && l._defaulted ? l : {
      ...ll(this, iG).mutations,
      ...(l == null ? void 0 : l.mutationKey) && this.getMutationDefaults(l.mutationKey),
      ...l,
      _defaulted: !0
    };
  }
  clear() {
    ll(this, ic).clear(), ll(this, mG).clear();
  }
}, ic = new WeakMap(), mG = new WeakMap(), iG = new WeakMap(), co = new WeakMap(), bo = new WeakMap(), oG = new WeakMap(), uo = new WeakMap(), so = new WeakMap(), vI), Hb, KZ, en, xb, em, Go, eG, ps, an, mo, io, am, nm, aG, oo, wZ, ra, ZV, cV, bV, uV, sV, dV, GV, Wr, TI, D7 = (TI = class extends Wn {
  constructor(Z, u) {
    super();
    ZZ(this, wZ);
    ZZ(this, Hb);
    ZZ(this, KZ);
    ZZ(this, en);
    ZZ(this, xb);
    ZZ(this, em);
    ZZ(this, Go);
    ZZ(this, eG);
    ZZ(this, ps);
    ZZ(this, an);
    ZZ(this, mo);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    ZZ(this, io);
    ZZ(this, am);
    ZZ(this, nm);
    ZZ(this, aG);
    ZZ(this, oo, /* @__PURE__ */ new Set());
    this.options = u, vl(this, Hb, Z), vl(this, ps, null), vl(this, eG, lV()), this.options.experimental_prefetchInRender || ll(this, eG).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(u);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (ll(this, KZ).addObserver(this), qM(ll(this, KZ), this.options) ? XZ(this, wZ, ra).call(this) : this.updateResult(), XZ(this, wZ, uV).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return mV(
      ll(this, KZ),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return mV(
      ll(this, KZ),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), XZ(this, wZ, sV).call(this), XZ(this, wZ, dV).call(this), ll(this, KZ).removeObserver(this);
  }
  setOptions(Z, u) {
    const s = this.options, G = ll(this, KZ);
    if (this.options = ll(this, Hb).defaultQueryOptions(Z), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Tu(this.options.enabled, ll(this, KZ)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    XZ(this, wZ, GV).call(this), ll(this, KZ).setOptions(this.options), s._defaulted && !$W(this.options, s) && ll(this, Hb).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: ll(this, KZ),
      observer: this
    });
    const i = this.hasListeners();
    i && _M(
      ll(this, KZ),
      G,
      this.options,
      s
    ) && XZ(this, wZ, ra).call(this), this.updateResult(u), i && (ll(this, KZ) !== G || Tu(this.options.enabled, ll(this, KZ)) !== Tu(s.enabled, ll(this, KZ)) || Ai(this.options.staleTime, ll(this, KZ)) !== Ai(s.staleTime, ll(this, KZ))) && XZ(this, wZ, ZV).call(this);
    const m = XZ(this, wZ, cV).call(this);
    i && (ll(this, KZ) !== G || Tu(this.options.enabled, ll(this, KZ)) !== Tu(s.enabled, ll(this, KZ)) || m !== ll(this, aG)) && XZ(this, wZ, bV).call(this, m);
  }
  getOptimisticResult(Z) {
    const u = ll(this, Hb).getQueryCache().build(ll(this, Hb), Z), s = this.createResult(u, Z);
    return Q7(this, s) && (vl(this, xb, s), vl(this, Go, this.options), vl(this, em, ll(this, KZ).state)), s;
  }
  getCurrentResult() {
    return ll(this, xb);
  }
  trackResult(Z, u) {
    const s = {};
    return Object.keys(Z).forEach((G) => {
      Object.defineProperty(s, G, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(G), u == null || u(G), Z[G])
      });
    }), s;
  }
  trackProp(Z) {
    ll(this, oo).add(Z);
  }
  getCurrentQuery() {
    return ll(this, KZ);
  }
  refetch({ ...Z } = {}) {
    return this.fetch({
      ...Z
    });
  }
  fetchOptimistic(Z) {
    const u = ll(this, Hb).defaultQueryOptions(Z), s = ll(this, Hb).getQueryCache().build(ll(this, Hb), u);
    return s.fetch().then(() => this.createResult(s, u));
  }
  fetch(Z) {
    return XZ(this, wZ, ra).call(this, {
      ...Z,
      cancelRefetch: Z.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), ll(this, xb)));
  }
  createResult(Z, u) {
    var D;
    const s = ll(this, KZ), G = this.options, i = ll(this, xb), m = ll(this, em), a = ll(this, Go), p = Z !== s ? Z.state : ll(this, en), { state: y } = Z;
    let h = { ...y }, S = !1, t;
    if (u._optimisticResults) {
      const C = this.hasListeners(), j = !C && qM(Z, u), E = C && _M(Z, s, u, G);
      (j || E) && (h = {
        ...h,
        ...Kr(y.data, Z.options)
      }), u._optimisticResults === "isRestoring" && (h.fetchStatus = "idle");
    }
    let { error: W, errorUpdatedAt: V, status: R } = h;
    if (u.select && h.data !== void 0)
      if (i && h.data === (m == null ? void 0 : m.data) && u.select === ll(this, an))
        t = ll(this, mo);
      else
        try {
          vl(this, an, u.select), t = u.select(h.data), t = _W(i == null ? void 0 : i.data, t, u), vl(this, mo, t), vl(this, ps, null);
        } catch (C) {
          vl(this, ps, C);
        }
    else
      t = h.data;
    if (u.placeholderData !== void 0 && t === void 0 && R === "pending") {
      let C;
      if (i != null && i.isPlaceholderData && u.placeholderData === (a == null ? void 0 : a.placeholderData))
        C = i.data;
      else if (C = typeof u.placeholderData == "function" ? u.placeholderData(
        (D = ll(this, io)) == null ? void 0 : D.state.data,
        ll(this, io)
      ) : u.placeholderData, u.select && C !== void 0)
        try {
          C = u.select(C), vl(this, ps, null);
        } catch (j) {
          vl(this, ps, j);
        }
      C !== void 0 && (R = "success", t = _W(
        i == null ? void 0 : i.data,
        C,
        u
      ), S = !0);
    }
    ll(this, ps) && (W = ll(this, ps), t = ll(this, mo), V = Date.now(), R = "error");
    const x = h.fetchStatus === "fetching", r = R === "pending", k = R === "error", U = r && x, w = t !== void 0;
    return {
      status: R,
      fetchStatus: h.fetchStatus,
      isPending: r,
      isSuccess: R === "success",
      isError: k,
      isInitialLoading: U,
      isLoading: U,
      data: t,
      dataUpdatedAt: h.dataUpdatedAt,
      error: W,
      errorUpdatedAt: V,
      failureCount: h.fetchFailureCount,
      failureReason: h.fetchFailureReason,
      errorUpdateCount: h.errorUpdateCount,
      isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
      isFetchedAfterMount: h.dataUpdateCount > p.dataUpdateCount || h.errorUpdateCount > p.errorUpdateCount,
      isFetching: x,
      isRefetching: x && !r,
      isLoadingError: k && !w,
      isPaused: h.fetchStatus === "paused",
      isPlaceholderData: S,
      isRefetchError: k && w,
      isStale: bx(Z, u),
      refetch: this.refetch,
      promise: ll(this, eG)
    };
  }
  updateResult(Z) {
    const u = ll(this, xb), s = this.createResult(ll(this, KZ), this.options);
    if (vl(this, em, ll(this, KZ).state), vl(this, Go, this.options), ll(this, em).data !== void 0 && vl(this, io, ll(this, KZ)), $W(s, u))
      return;
    if (this.options.experimental_prefetchInRender) {
      const m = (p) => {
        s.status === "error" ? p.reject(s.error) : s.data !== void 0 && p.resolve(s.data);
      }, a = () => {
        const p = vl(this, eG, s.promise = lV());
        m(p);
      }, n = ll(this, eG);
      switch (n.status) {
        case "pending":
          m(n);
          break;
        case "fulfilled":
          (s.status === "error" || s.data !== n.value) && a();
          break;
        case "rejected":
          (s.status !== "error" || s.error !== n.reason) && a();
          break;
      }
    }
    vl(this, xb, s);
    const G = {}, i = () => {
      if (!u)
        return !0;
      const { notifyOnChangeProps: m } = this.options, a = typeof m == "function" ? m() : m;
      if (a === "all" || !a && !ll(this, oo).size)
        return !0;
      const n = new Set(
        a ?? ll(this, oo)
      );
      return this.options.throwOnError && n.add("error"), Object.keys(ll(this, xb)).some((p) => {
        const y = p;
        return ll(this, xb)[y] !== u[y] && n.has(y);
      });
    };
    (Z == null ? void 0 : Z.listeners) !== !1 && i() && (G.listeners = !0), XZ(this, wZ, Wr).call(this, { ...G, ...Z });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && XZ(this, wZ, uV).call(this);
  }
}, Hb = new WeakMap(), KZ = new WeakMap(), en = new WeakMap(), xb = new WeakMap(), em = new WeakMap(), Go = new WeakMap(), eG = new WeakMap(), ps = new WeakMap(), an = new WeakMap(), mo = new WeakMap(), io = new WeakMap(), am = new WeakMap(), nm = new WeakMap(), aG = new WeakMap(), oo = new WeakMap(), wZ = new WeakSet(), ra = function(Z) {
  XZ(this, wZ, GV).call(this);
  let u = ll(this, KZ).fetch(
    this.options,
    Z
  );
  return Z != null && Z.throwOnError || (u = u.catch(pu)), u;
}, ZV = function() {
  XZ(this, wZ, sV).call(this);
  const Z = Ai(
    this.options.staleTime,
    ll(this, KZ)
  );
  if (Ym || ll(this, xb).isStale || !OW(Z))
    return;
  const s = Lr(ll(this, xb).dataUpdatedAt, Z) + 1;
  vl(this, am, setTimeout(() => {
    ll(this, xb).isStale || this.updateResult();
  }, s));
}, cV = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(ll(this, KZ)) : this.options.refetchInterval) ?? !1;
}, bV = function(Z) {
  XZ(this, wZ, dV).call(this), vl(this, aG, Z), !(Ym || Tu(this.options.enabled, ll(this, KZ)) === !1 || !OW(ll(this, aG)) || ll(this, aG) === 0) && vl(this, nm, setInterval(() => {
    (this.options.refetchIntervalInBackground || cx.isFocused()) && XZ(this, wZ, ra).call(this);
  }, ll(this, aG)));
}, uV = function() {
  XZ(this, wZ, ZV).call(this), XZ(this, wZ, bV).call(this, XZ(this, wZ, cV).call(this));
}, sV = function() {
  ll(this, am) && (clearTimeout(ll(this, am)), vl(this, am, void 0));
}, dV = function() {
  ll(this, nm) && (clearInterval(ll(this, nm)), vl(this, nm, void 0));
}, GV = function() {
  const Z = ll(this, Hb).getQueryCache().build(ll(this, Hb), this.options);
  if (Z === ll(this, KZ))
    return;
  const u = ll(this, KZ);
  vl(this, KZ, Z), vl(this, en, Z.state), this.hasListeners() && (u == null || u.removeObserver(this), Z.addObserver(this));
}, Wr = function(Z) {
  _c.batch(() => {
    Z.listeners && this.listeners.forEach((u) => {
      u(ll(this, xb));
    }), ll(this, Hb).getQueryCache().notify({
      query: ll(this, KZ),
      type: "observerResultsUpdated"
    });
  });
}, TI);
function j7(l, Z) {
  return Tu(Z.enabled, l) !== !1 && l.state.data === void 0 && !(l.state.status === "error" && Z.retryOnMount === !1);
}
function qM(l, Z) {
  return j7(l, Z) || l.state.data !== void 0 && mV(l, Z, Z.refetchOnMount);
}
function mV(l, Z, u) {
  if (Tu(Z.enabled, l) !== !1) {
    const s = typeof u == "function" ? u(l) : u;
    return s === "always" || s !== !1 && bx(l, Z);
  }
  return !1;
}
function _M(l, Z, u, s) {
  return (l !== Z || Tu(s.enabled, l) === !1) && (!u.suspense || l.state.status !== "error") && bx(l, u);
}
function bx(l, Z) {
  return Tu(Z.enabled, l) !== !1 && l.isStaleByTime(Ai(Z.staleTime, l));
}
function Q7(l, Z) {
  return !$W(l.getCurrentResult(), Z);
}
var Vr = M.createContext(
  void 0
), P7 = (l) => {
  const Z = M.useContext(Vr);
  if (!Z)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return Z;
}, xr = ({
  client: l,
  children: Z
}) => (M.useEffect(() => (l.mount(), () => {
  l.unmount();
}), [l]), /* @__PURE__ */ B.jsx(Vr.Provider, { value: l, children: Z })), Rr = M.createContext(!1), O7 = () => M.useContext(Rr);
Rr.Provider;
function A7() {
  let l = !1;
  return {
    clearReset: () => {
      l = !1;
    },
    reset: () => {
      l = !0;
    },
    isReset: () => l
  };
}
var $7 = M.createContext(A7()), q7 = () => M.useContext($7);
function _7(l, Z) {
  return typeof l == "function" ? l(...Z) : !!l;
}
function l6() {
}
var Z6 = (l, Z) => {
  (l.suspense || l.throwOnError) && (Z.isReset() || (l.retryOnMount = !1));
}, c6 = (l) => {
  M.useEffect(() => {
    l.clearReset();
  }, [l]);
}, b6 = ({
  result: l,
  errorResetBoundary: Z,
  throwOnError: u,
  query: s
}) => l.isError && !Z.isReset() && !l.isFetching && s && _7(u, [l.error, s]), u6 = (l) => {
  l.suspense && (typeof l.staleTime != "number" && (l.staleTime = 1e3), typeof l.gcTime == "number" && (l.gcTime = Math.max(l.gcTime, 1e3)));
}, s6 = (l, Z) => l.isLoading && l.isFetching && !Z, d6 = (l, Z) => (l == null ? void 0 : l.suspense) && Z.isPending, lI = (l, Z, u) => Z.fetchOptimistic(l).catch(() => {
  u.clearReset();
});
function G6(l, Z, u) {
  var y, h, S, t, W;
  if (typeof l != "object" || Array.isArray(l))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const s = P7(), G = O7(), i = q7(), m = s.defaultQueryOptions(l);
  (h = (y = s.getDefaultOptions().queries) == null ? void 0 : y._experimental_beforeQuery) == null || h.call(
    y,
    m
  ), m._optimisticResults = G ? "isRestoring" : "optimistic", u6(m), Z6(m, i), c6(i);
  const a = !s.getQueryCache().get(m.queryHash), [n] = M.useState(
    () => new Z(
      s,
      m
    )
  ), p = n.getOptimisticResult(m);
  if (M.useSyncExternalStore(
    M.useCallback(
      (V) => {
        const R = G ? () => {
        } : n.subscribe(_c.batchCalls(V));
        return n.updateResult(), R;
      },
      [n, G]
    ),
    () => n.getCurrentResult(),
    () => n.getCurrentResult()
  ), M.useEffect(() => {
    n.setOptions(m, { listeners: !1 });
  }, [m, n]), d6(m, p))
    throw lI(m, n, i);
  if (b6({
    result: p,
    errorResetBoundary: i,
    throwOnError: m.throwOnError,
    query: s.getQueryCache().get(m.queryHash)
  }))
    throw p.error;
  if ((t = (S = s.getDefaultOptions().queries) == null ? void 0 : S._experimental_afterQuery) == null || t.call(
    S,
    m,
    p
  ), m.experimental_prefetchInRender && !Ym && s6(p, G)) {
    const V = a ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      lI(m, n, i)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (W = s.getQueryCache().get(m.queryHash)) == null ? void 0 : W.promise
    );
    V == null || V.catch(l6).finally(() => {
      n.hasListeners() || n.updateResult();
    });
  }
  return m.notifyOnChangeProps ? p : n.trackResult(p);
}
function m6(l, Z) {
  return G6(l, D7);
}
function Io(l, Z, u) {
  return l.fields = Z || [], l.fname = u, l;
}
function i6(l) {
  return l.length === 1 ? o6(l[0]) : e6(l);
}
const o6 = (l) => function(Z) {
  return Z[l];
}, e6 = (l) => {
  const Z = l.length;
  return function(u) {
    for (let s = 0; s < Z; ++s)
      u = u[l[s]];
    return u;
  };
};
function bW(l) {
  throw Error(l);
}
function a6(l) {
  const Z = [], u = l.length;
  let s = null, G = 0, i = "", m, a, n;
  l = l + "";
  function p() {
    Z.push(i + l.substring(m, a)), i = "", m = a + 1;
  }
  for (m = a = 0; a < u; ++a)
    if (n = l[a], n === "\\")
      i += l.substring(m, a++), m = a;
    else if (n === s)
      p(), s = null, G = -1;
    else {
      if (s)
        continue;
      m === G && n === '"' || m === G && n === "'" ? (m = a + 1, s = n) : n === "." && !G ? a > m ? p() : m = a + 1 : n === "[" ? (a > m && p(), G = m = a + 1) : n === "]" && (G || bW("Access path missing open bracket: " + l), G > 0 && p(), G = 0, m = a + 1);
    }
  return G && bW("Access path missing closing bracket: " + l), s && bW("Access path missing closing quote: " + l), a > m && (a++, p()), Z;
}
function n6(l, Z, u) {
  const s = a6(l);
  return l = s.length === 1 ? s[0] : l, Io(i6(s), [l], l);
}
n6("id");
Io((l) => l, [], "identity");
Io(() => 0, [], "zero");
Io(() => 1, [], "one");
Io(() => !0, [], "true");
Io(() => !1, [], "false");
var Yr = Array.isArray;
function p6(l) {
  return l[l.length - 1];
}
function L6(l) {
  return l == null || l === "" ? null : +l;
}
function h6(l) {
  return l != null ? Yr(l) ? l : [l] : [];
}
function y6(l) {
  const Z = {}, u = l.length;
  for (let s = 0; s < u; ++s) Z[l[s]] = !0;
  return Z;
}
function za(l, Z) {
  return l == null || Z == null ? NaN : l < Z ? -1 : l > Z ? 1 : l >= Z ? 0 : NaN;
}
function S6(l, Z) {
  return l == null || Z == null ? NaN : Z < l ? -1 : Z > l ? 1 : Z >= l ? 0 : NaN;
}
function ux(l) {
  let Z, u, s;
  l.length !== 2 ? (Z = za, u = (a, n) => za(l(a), n), s = (a, n) => l(a) - n) : (Z = l === za || l === S6 ? l : t6, u = l, s = l);
  function G(a, n, p = 0, y = a.length) {
    if (p < y) {
      if (Z(n, n) !== 0) return y;
      do {
        const h = p + y >>> 1;
        u(a[h], n) < 0 ? p = h + 1 : y = h;
      } while (p < y);
    }
    return p;
  }
  function i(a, n, p = 0, y = a.length) {
    if (p < y) {
      if (Z(n, n) !== 0) return y;
      do {
        const h = p + y >>> 1;
        u(a[h], n) <= 0 ? p = h + 1 : y = h;
      } while (p < y);
    }
    return p;
  }
  function m(a, n, p = 0, y = a.length) {
    const h = G(a, n, p, y - 1);
    return h > p && s(a[h - 1], n) > -s(a[h], n) ? h - 1 : h;
  }
  return { left: G, center: m, right: i };
}
function t6() {
  return 0;
}
function kr(l) {
  return l === null ? NaN : +l;
}
const X6 = ux(za), km = X6.right;
ux(kr).center;
class ZI extends Map {
  constructor(Z, u = V6) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: u } }), Z != null) for (const [s, G] of Z) this.set(s, G);
  }
  get(Z) {
    return super.get(cI(this, Z));
  }
  has(Z) {
    return super.has(cI(this, Z));
  }
  set(Z, u) {
    return super.set(K6(this, Z), u);
  }
  delete(Z) {
    return super.delete(W6(this, Z));
  }
}
function cI({ _intern: l, _key: Z }, u) {
  const s = Z(u);
  return l.has(s) ? l.get(s) : u;
}
function K6({ _intern: l, _key: Z }, u) {
  const s = Z(u);
  return l.has(s) ? l.get(s) : (l.set(s, u), u);
}
function W6({ _intern: l, _key: Z }, u) {
  const s = Z(u);
  return l.has(s) && (u = l.get(s), l.delete(s)), u;
}
function V6(l) {
  return l !== null && typeof l == "object" ? l.valueOf() : l;
}
const x6 = Math.sqrt(50), R6 = Math.sqrt(10), Y6 = Math.sqrt(2);
function Ch(l, Z, u) {
  const s = (Z - l) / Math.max(0, u), G = Math.floor(Math.log10(s)), i = s / Math.pow(10, G), m = i >= x6 ? 10 : i >= R6 ? 5 : i >= Y6 ? 2 : 1;
  let a, n, p;
  return G < 0 ? (p = Math.pow(10, -G) / m, a = Math.round(l * p), n = Math.round(Z * p), a / p < l && ++a, n / p > Z && --n, p = -p) : (p = Math.pow(10, G) * m, a = Math.round(l / p), n = Math.round(Z / p), a * p < l && ++a, n * p > Z && --n), n < a && 0.5 <= u && u < 2 ? Ch(l, Z, u * 2) : [a, n, p];
}
function iV(l, Z, u) {
  if (Z = +Z, l = +l, u = +u, !(u > 0)) return [];
  if (l === Z) return [l];
  const s = Z < l, [G, i, m] = s ? Ch(Z, l, u) : Ch(l, Z, u);
  if (!(i >= G)) return [];
  const a = i - G + 1, n = new Array(a);
  if (s)
    if (m < 0) for (let p = 0; p < a; ++p) n[p] = (i - p) / -m;
    else for (let p = 0; p < a; ++p) n[p] = (i - p) * m;
  else if (m < 0) for (let p = 0; p < a; ++p) n[p] = (G + p) / -m;
  else for (let p = 0; p < a; ++p) n[p] = (G + p) * m;
  return n;
}
function oV(l, Z, u) {
  return Z = +Z, l = +l, u = +u, Ch(l, Z, u)[2];
}
function eV(l, Z, u) {
  Z = +Z, l = +l, u = +u;
  const s = Z < l, G = s ? oV(Z, l, u) : oV(l, Z, u);
  return (s ? -1 : 1) * (G < 0 ? 1 / -G : G);
}
function k6(l, Z, u = kr) {
  if (!(!(s = l.length) || isNaN(Z = +Z))) {
    if (Z <= 0 || s < 2) return +u(l[0], 0, l);
    if (Z >= 1) return +u(l[s - 1], s - 1, l);
    var s, G = (s - 1) * Z, i = Math.floor(G), m = +u(l[i], i, l), a = +u(l[i + 1], i + 1, l);
    return m + (a - m) * (G - i);
  }
}
function M6(l, Z, u) {
  l = +l, Z = +Z, u = (G = arguments.length) < 2 ? (Z = l, l = 0, 1) : G < 3 ? 1 : +u;
  for (var s = -1, G = Math.max(0, Math.ceil((Z - l) / u)) | 0, i = new Array(G); ++s < G; )
    i[s] = l + s * u;
  return i;
}
function Vs(l, Z) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(l);
      break;
    default:
      this.range(Z).domain(l);
      break;
  }
  return this;
}
function yG(l, Z) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof l == "function" ? this.interpolator(l) : this.range(l);
      break;
    }
    default: {
      this.domain(l), typeof Z == "function" ? this.interpolator(Z) : this.range(Z);
      break;
    }
  }
  return this;
}
const bI = Symbol("implicit");
function sx() {
  var l = new ZI(), Z = [], u = [], s = bI;
  function G(i) {
    let m = l.get(i);
    if (m === void 0) {
      if (s !== bI) return s;
      l.set(i, m = Z.push(i) - 1);
    }
    return u[m % u.length];
  }
  return G.domain = function(i) {
    if (!arguments.length) return Z.slice();
    Z = [], l = new ZI();
    for (const m of i)
      l.has(m) || l.set(m, Z.push(m) - 1);
    return G;
  }, G.range = function(i) {
    return arguments.length ? (u = Array.from(i), G) : u.slice();
  }, G.unknown = function(i) {
    return arguments.length ? (s = i, G) : s;
  }, G.copy = function() {
    return sx(Z, u).unknown(s);
  }, Vs.apply(G, arguments), G;
}
function I6(l) {
  return function() {
    return l;
  };
}
function aV(l) {
  return +l;
}
var uI = [0, 1];
function vb(l) {
  return l;
}
function nV(l, Z) {
  return (Z -= l = +l) ? function(u) {
    return (u - l) / Z;
  } : I6(isNaN(Z) ? NaN : 0.5);
}
function U6(l, Z) {
  var u;
  return l > Z && (u = l, l = Z, Z = u), function(s) {
    return Math.max(l, Math.min(Z, s));
  };
}
function C6(l, Z, u) {
  var s = l[0], G = l[1], i = Z[0], m = Z[1];
  return G < s ? (s = nV(G, s), i = u(m, i)) : (s = nV(s, G), i = u(i, m)), function(a) {
    return i(s(a));
  };
}
function r6(l, Z, u) {
  var s = Math.min(l.length, Z.length) - 1, G = new Array(s), i = new Array(s), m = -1;
  for (l[s] < l[0] && (l = l.slice().reverse(), Z = Z.slice().reverse()); ++m < s; )
    G[m] = nV(l[m], l[m + 1]), i[m] = u(Z[m], Z[m + 1]);
  return function(a) {
    var n = km(l, a, 1, s) - 1;
    return i[n](G[n](a));
  };
}
function Vn(l, Z) {
  return Z.domain(l.domain()).range(l.range()).interpolate(l.interpolate()).clamp(l.clamp()).unknown(l.unknown());
}
function Gy() {
  var l = uI, Z = uI, u = Cm, s, G, i, m = vb, a, n, p;
  function y() {
    var S = Math.min(l.length, Z.length);
    return m !== vb && (m = U6(l[0], l[S - 1])), a = S > 2 ? r6 : C6, n = p = null, h;
  }
  function h(S) {
    return S == null || isNaN(S = +S) ? i : (n || (n = a(l.map(s), Z, u)))(s(m(S)));
  }
  return h.invert = function(S) {
    return m(G((p || (p = a(Z, l.map(s), hu)))(S)));
  }, h.domain = function(S) {
    return arguments.length ? (l = Array.from(S, aV), y()) : l.slice();
  }, h.range = function(S) {
    return arguments.length ? (Z = Array.from(S), y()) : Z.slice();
  }, h.rangeRound = function(S) {
    return Z = Array.from(S), u = Oh, y();
  }, h.clamp = function(S) {
    return arguments.length ? (m = S ? !0 : vb, y()) : m !== vb;
  }, h.interpolate = function(S) {
    return arguments.length ? (u = S, y()) : u;
  }, h.unknown = function(S) {
    return arguments.length ? (i = S, h) : i;
  }, function(S, t) {
    return s = S, G = t, y();
  };
}
function Mr() {
  return Gy()(vb, vb);
}
function F6(l) {
  return Math.abs(l = Math.round(l)) >= 1e21 ? l.toLocaleString("en").replace(/,/g, "") : l.toString(10);
}
function rh(l, Z) {
  if ((u = (l = Z ? l.toExponential(Z - 1) : l.toExponential()).indexOf("e")) < 0) return null;
  var u, s = l.slice(0, u);
  return [
    s.length > 1 ? s[0] + s.slice(2) : s,
    +l.slice(u + 1)
  ];
}
function to(l) {
  return l = rh(Math.abs(l)), l ? l[1] : NaN;
}
function N6(l, Z) {
  return function(u, s) {
    for (var G = u.length, i = [], m = 0, a = l[0], n = 0; G > 0 && a > 0 && (n + a + 1 > s && (a = Math.max(1, s - n)), i.push(u.substring(G -= a, G + a)), !((n += a + 1) > s)); )
      a = l[m = (m + 1) % l.length];
    return i.reverse().join(Z);
  };
}
function w6(l) {
  return function(Z) {
    return Z.replace(/[0-9]/g, function(u) {
      return l[+u];
    });
  };
}
var z6 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function sn(l) {
  if (!(Z = z6.exec(l))) throw new Error("invalid format: " + l);
  var Z;
  return new dx({
    fill: Z[1],
    align: Z[2],
    sign: Z[3],
    symbol: Z[4],
    zero: Z[5],
    width: Z[6],
    comma: Z[7],
    precision: Z[8] && Z[8].slice(1),
    trim: Z[9],
    type: Z[10]
  });
}
sn.prototype = dx.prototype;
function dx(l) {
  this.fill = l.fill === void 0 ? " " : l.fill + "", this.align = l.align === void 0 ? ">" : l.align + "", this.sign = l.sign === void 0 ? "-" : l.sign + "", this.symbol = l.symbol === void 0 ? "" : l.symbol + "", this.zero = !!l.zero, this.width = l.width === void 0 ? void 0 : +l.width, this.comma = !!l.comma, this.precision = l.precision === void 0 ? void 0 : +l.precision, this.trim = !!l.trim, this.type = l.type === void 0 ? "" : l.type + "";
}
dx.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function J6(l) {
  l: for (var Z = l.length, u = 1, s = -1, G; u < Z; ++u)
    switch (l[u]) {
      case ".":
        s = G = u;
        break;
      case "0":
        s === 0 && (s = u), G = u;
        break;
      default:
        if (!+l[u]) break l;
        s > 0 && (s = 0);
        break;
    }
  return s > 0 ? l.slice(0, s) + l.slice(G + 1) : l;
}
var Ir;
function H6(l, Z) {
  var u = rh(l, Z);
  if (!u) return l + "";
  var s = u[0], G = u[1], i = G - (Ir = Math.max(-8, Math.min(8, Math.floor(G / 3))) * 3) + 1, m = s.length;
  return i === m ? s : i > m ? s + new Array(i - m + 1).join("0") : i > 0 ? s.slice(0, i) + "." + s.slice(i) : "0." + new Array(1 - i).join("0") + rh(l, Math.max(0, Z + i - 1))[0];
}
function sI(l, Z) {
  var u = rh(l, Z);
  if (!u) return l + "";
  var s = u[0], G = u[1];
  return G < 0 ? "0." + new Array(-G).join("0") + s : s.length > G + 1 ? s.slice(0, G + 1) + "." + s.slice(G + 1) : s + new Array(G - s.length + 2).join("0");
}
const dI = {
  "%": (l, Z) => (l * 100).toFixed(Z),
  b: (l) => Math.round(l).toString(2),
  c: (l) => l + "",
  d: F6,
  e: (l, Z) => l.toExponential(Z),
  f: (l, Z) => l.toFixed(Z),
  g: (l, Z) => l.toPrecision(Z),
  o: (l) => Math.round(l).toString(8),
  p: (l, Z) => sI(l * 100, Z),
  r: sI,
  s: H6,
  X: (l) => Math.round(l).toString(16).toUpperCase(),
  x: (l) => Math.round(l).toString(16)
};
function GI(l) {
  return l;
}
var mI = Array.prototype.map, iI = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function g6(l) {
  var Z = l.grouping === void 0 || l.thousands === void 0 ? GI : N6(mI.call(l.grouping, Number), l.thousands + ""), u = l.currency === void 0 ? "" : l.currency[0] + "", s = l.currency === void 0 ? "" : l.currency[1] + "", G = l.decimal === void 0 ? "." : l.decimal + "", i = l.numerals === void 0 ? GI : w6(mI.call(l.numerals, String)), m = l.percent === void 0 ? "%" : l.percent + "", a = l.minus === void 0 ? "−" : l.minus + "", n = l.nan === void 0 ? "NaN" : l.nan + "";
  function p(h) {
    h = sn(h);
    var S = h.fill, t = h.align, W = h.sign, V = h.symbol, R = h.zero, x = h.width, r = h.comma, k = h.precision, U = h.trim, w = h.type;
    w === "n" ? (r = !0, w = "g") : dI[w] || (k === void 0 && (k = 12), U = !0, w = "g"), (R || S === "0" && t === "=") && (R = !0, S = "0", t = "=");
    var z = V === "$" ? u : V === "#" && /[boxX]/.test(w) ? "0" + w.toLowerCase() : "", D = V === "$" ? s : /[%p]/.test(w) ? m : "", C = dI[w], j = /[defgprs%]/.test(w);
    k = k === void 0 ? 6 : /[gprs]/.test(w) ? Math.max(1, Math.min(21, k)) : Math.max(0, Math.min(20, k));
    function E(g) {
      var A = z, J = D, F, v, T;
      if (w === "c")
        J = C(g) + J, g = "";
      else {
        g = +g;
        var f = g < 0 || 1 / g < 0;
        if (g = isNaN(g) ? n : C(Math.abs(g), k), U && (g = J6(g)), f && +g == 0 && W !== "+" && (f = !1), A = (f ? W === "(" ? W : a : W === "-" || W === "(" ? "" : W) + A, J = (w === "s" ? iI[8 + Ir / 3] : "") + J + (f && W === "(" ? ")" : ""), j) {
          for (F = -1, v = g.length; ++F < v; )
            if (T = g.charCodeAt(F), 48 > T || T > 57) {
              J = (T === 46 ? G + g.slice(F + 1) : g.slice(F)) + J, g = g.slice(0, F);
              break;
            }
        }
      }
      r && !R && (g = Z(g, 1 / 0));
      var O = A.length + g.length + J.length, _ = O < x ? new Array(x - O + 1).join(S) : "";
      switch (r && R && (g = Z(_ + g, _.length ? x - J.length : 1 / 0), _ = ""), t) {
        case "<":
          g = A + g + J + _;
          break;
        case "=":
          g = A + _ + g + J;
          break;
        case "^":
          g = _.slice(0, O = _.length >> 1) + A + g + J + _.slice(O);
          break;
        default:
          g = _ + A + g + J;
          break;
      }
      return i(g);
    }
    return E.toString = function() {
      return h + "";
    }, E;
  }
  function y(h, S) {
    var t = p((h = sn(h), h.type = "f", h)), W = Math.max(-8, Math.min(8, Math.floor(to(S) / 3))) * 3, V = Math.pow(10, -W), R = iI[8 + W / 3];
    return function(x) {
      return t(V * x) + R;
    };
  }
  return {
    format: p,
    formatPrefix: y
  };
}
var bh, Gx, Ur;
v6({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function v6(l) {
  return bh = g6(l), Gx = bh.format, Ur = bh.formatPrefix, bh;
}
function T6(l) {
  return Math.max(0, -to(Math.abs(l)));
}
function f6(l, Z) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(to(Z) / 3))) * 3 - to(Math.abs(l)));
}
function E6(l, Z) {
  return l = Math.abs(l), Z = Math.abs(Z) - l, Math.max(0, to(Z) - to(l)) + 1;
}
function Cr(l, Z, u, s) {
  var G = eV(l, Z, u), i;
  switch (s = sn(s ?? ",f"), s.type) {
    case "s": {
      var m = Math.max(Math.abs(l), Math.abs(Z));
      return s.precision == null && !isNaN(i = f6(G, m)) && (s.precision = i), Ur(s, m);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      s.precision == null && !isNaN(i = E6(G, Math.max(Math.abs(l), Math.abs(Z)))) && (s.precision = i - (s.type === "e"));
      break;
    }
    case "f":
    case "%": {
      s.precision == null && !isNaN(i = T6(G)) && (s.precision = i - (s.type === "%") * 2);
      break;
    }
  }
  return Gx(s);
}
function rm(l) {
  var Z = l.domain;
  return l.ticks = function(u) {
    var s = Z();
    return iV(s[0], s[s.length - 1], u ?? 10);
  }, l.tickFormat = function(u, s) {
    var G = Z();
    return Cr(G[0], G[G.length - 1], u ?? 10, s);
  }, l.nice = function(u) {
    u == null && (u = 10);
    var s = Z(), G = 0, i = s.length - 1, m = s[G], a = s[i], n, p, y = 10;
    for (a < m && (p = m, m = a, a = p, p = G, G = i, i = p); y-- > 0; ) {
      if (p = oV(m, a, u), p === n)
        return s[G] = m, s[i] = a, Z(s);
      if (p > 0)
        m = Math.floor(m / p) * p, a = Math.ceil(a / p) * p;
      else if (p < 0)
        m = Math.ceil(m * p) / p, a = Math.floor(a * p) / p;
      else
        break;
      n = p;
    }
    return l;
  }, l;
}
function rr() {
  var l = Mr();
  return l.copy = function() {
    return Vn(l, rr());
  }, Vs.apply(l, arguments), rm(l);
}
function Fr(l) {
  var Z;
  function u(s) {
    return s == null || isNaN(s = +s) ? Z : s;
  }
  return u.invert = u, u.domain = u.range = function(s) {
    return arguments.length ? (l = Array.from(s, aV), u) : l.slice();
  }, u.unknown = function(s) {
    return arguments.length ? (Z = s, u) : Z;
  }, u.copy = function() {
    return Fr(l).unknown(Z);
  }, l = arguments.length ? Array.from(l, aV) : [0, 1], rm(u);
}
function Nr(l, Z) {
  l = l.slice();
  var u = 0, s = l.length - 1, G = l[u], i = l[s], m;
  return i < G && (m = u, u = s, s = m, m = G, G = i, i = m), l[u] = Z.floor(G), l[s] = Z.ceil(i), l;
}
function oI(l) {
  return Math.log(l);
}
function eI(l) {
  return Math.exp(l);
}
function B6(l) {
  return -Math.log(-l);
}
function D6(l) {
  return -Math.exp(-l);
}
function j6(l) {
  return isFinite(l) ? +("1e" + l) : l < 0 ? 0 : l;
}
function Q6(l) {
  return l === 10 ? j6 : l === Math.E ? Math.exp : (Z) => Math.pow(l, Z);
}
function P6(l) {
  return l === Math.E ? Math.log : l === 10 && Math.log10 || l === 2 && Math.log2 || (l = Math.log(l), (Z) => Math.log(Z) / l);
}
function aI(l) {
  return (Z, u) => -l(-Z, u);
}
function mx(l) {
  const Z = l(oI, eI), u = Z.domain;
  let s = 10, G, i;
  function m() {
    return G = P6(s), i = Q6(s), u()[0] < 0 ? (G = aI(G), i = aI(i), l(B6, D6)) : l(oI, eI), Z;
  }
  return Z.base = function(a) {
    return arguments.length ? (s = +a, m()) : s;
  }, Z.domain = function(a) {
    return arguments.length ? (u(a), m()) : u();
  }, Z.ticks = (a) => {
    const n = u();
    let p = n[0], y = n[n.length - 1];
    const h = y < p;
    h && ([p, y] = [y, p]);
    let S = G(p), t = G(y), W, V;
    const R = a == null ? 10 : +a;
    let x = [];
    if (!(s % 1) && t - S < R) {
      if (S = Math.floor(S), t = Math.ceil(t), p > 0) {
        for (; S <= t; ++S)
          for (W = 1; W < s; ++W)
            if (V = S < 0 ? W / i(-S) : W * i(S), !(V < p)) {
              if (V > y) break;
              x.push(V);
            }
      } else for (; S <= t; ++S)
        for (W = s - 1; W >= 1; --W)
          if (V = S > 0 ? W / i(-S) : W * i(S), !(V < p)) {
            if (V > y) break;
            x.push(V);
          }
      x.length * 2 < R && (x = iV(p, y, R));
    } else
      x = iV(S, t, Math.min(t - S, R)).map(i);
    return h ? x.reverse() : x;
  }, Z.tickFormat = (a, n) => {
    if (a == null && (a = 10), n == null && (n = s === 10 ? "s" : ","), typeof n != "function" && (!(s % 1) && (n = sn(n)).precision == null && (n.trim = !0), n = Gx(n)), a === 1 / 0) return n;
    const p = Math.max(1, s * a / Z.ticks().length);
    return (y) => {
      let h = y / i(Math.round(G(y)));
      return h * s < s - 0.5 && (h *= s), h <= p ? n(y) : "";
    };
  }, Z.nice = () => u(Nr(u(), {
    floor: (a) => i(Math.floor(G(a))),
    ceil: (a) => i(Math.ceil(G(a)))
  })), Z;
}
function wr() {
  const l = mx(Gy()).domain([1, 10]);
  return l.copy = () => Vn(l, wr()).base(l.base()), Vs.apply(l, arguments), l;
}
function nI(l) {
  return function(Z) {
    return Math.sign(Z) * Math.log1p(Math.abs(Z / l));
  };
}
function pI(l) {
  return function(Z) {
    return Math.sign(Z) * Math.expm1(Math.abs(Z)) * l;
  };
}
function ix(l) {
  var Z = 1, u = l(nI(Z), pI(Z));
  return u.constant = function(s) {
    return arguments.length ? l(nI(Z = +s), pI(Z)) : Z;
  }, rm(u);
}
function zr() {
  var l = ix(Gy());
  return l.copy = function() {
    return Vn(l, zr()).constant(l.constant());
  }, Vs.apply(l, arguments);
}
function LI(l) {
  return function(Z) {
    return Z < 0 ? -Math.pow(-Z, l) : Math.pow(Z, l);
  };
}
function O6(l) {
  return l < 0 ? -Math.sqrt(-l) : Math.sqrt(l);
}
function A6(l) {
  return l < 0 ? -l * l : l * l;
}
function ox(l) {
  var Z = l(vb, vb), u = 1;
  function s() {
    return u === 1 ? l(vb, vb) : u === 0.5 ? l(O6, A6) : l(LI(u), LI(1 / u));
  }
  return Z.exponent = function(G) {
    return arguments.length ? (u = +G, s()) : u;
  }, rm(Z);
}
function ex() {
  var l = ox(Gy());
  return l.copy = function() {
    return Vn(l, ex()).exponent(l.exponent());
  }, Vs.apply(l, arguments), l;
}
function $6() {
  return ex.apply(null, arguments).exponent(0.5);
}
function Jr() {
  var l = [], Z = [], u = [], s;
  function G() {
    var m = 0, a = Math.max(1, Z.length);
    for (u = new Array(a - 1); ++m < a; ) u[m - 1] = k6(l, m / a);
    return i;
  }
  function i(m) {
    return m == null || isNaN(m = +m) ? s : Z[km(u, m)];
  }
  return i.invertExtent = function(m) {
    var a = Z.indexOf(m);
    return a < 0 ? [NaN, NaN] : [
      a > 0 ? u[a - 1] : l[0],
      a < u.length ? u[a] : l[l.length - 1]
    ];
  }, i.domain = function(m) {
    if (!arguments.length) return l.slice();
    l = [];
    for (let a of m) a != null && !isNaN(a = +a) && l.push(a);
    return l.sort(za), G();
  }, i.range = function(m) {
    return arguments.length ? (Z = Array.from(m), G()) : Z.slice();
  }, i.unknown = function(m) {
    return arguments.length ? (s = m, i) : s;
  }, i.quantiles = function() {
    return u.slice();
  }, i.copy = function() {
    return Jr().domain(l).range(Z).unknown(s);
  }, Vs.apply(i, arguments);
}
function Hr() {
  var l = 0, Z = 1, u = 1, s = [0.5], G = [0, 1], i;
  function m(n) {
    return n != null && n <= n ? G[km(s, n, 0, u)] : i;
  }
  function a() {
    var n = -1;
    for (s = new Array(u); ++n < u; ) s[n] = ((n + 1) * Z - (n - u) * l) / (u + 1);
    return m;
  }
  return m.domain = function(n) {
    return arguments.length ? ([l, Z] = n, l = +l, Z = +Z, a()) : [l, Z];
  }, m.range = function(n) {
    return arguments.length ? (u = (G = Array.from(n)).length - 1, a()) : G.slice();
  }, m.invertExtent = function(n) {
    var p = G.indexOf(n);
    return p < 0 ? [NaN, NaN] : p < 1 ? [l, s[0]] : p >= u ? [s[u - 1], Z] : [s[p - 1], s[p]];
  }, m.unknown = function(n) {
    return arguments.length && (i = n), m;
  }, m.thresholds = function() {
    return s.slice();
  }, m.copy = function() {
    return Hr().domain([l, Z]).range(G).unknown(i);
  }, Vs.apply(rm(m), arguments);
}
function gr() {
  var l = [0.5], Z = [0, 1], u, s = 1;
  function G(i) {
    return i != null && i <= i ? Z[km(l, i, 0, s)] : u;
  }
  return G.domain = function(i) {
    return arguments.length ? (l = Array.from(i), s = Math.min(l.length, Z.length - 1), G) : l.slice();
  }, G.range = function(i) {
    return arguments.length ? (Z = Array.from(i), s = Math.min(l.length, Z.length - 1), G) : Z.slice();
  }, G.invertExtent = function(i) {
    var m = Z.indexOf(i);
    return [l[m - 1], l[m]];
  }, G.unknown = function(i) {
    return arguments.length ? (u = i, G) : u;
  }, G.copy = function() {
    return gr().domain(l).range(Z).unknown(u);
  }, Vs.apply(G, arguments);
}
const uW = /* @__PURE__ */ new Date(), sW = /* @__PURE__ */ new Date();
function Fc(l, Z, u, s) {
  function G(i) {
    return l(i = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+i)), i;
  }
  return G.floor = (i) => (l(i = /* @__PURE__ */ new Date(+i)), i), G.ceil = (i) => (l(i = new Date(i - 1)), Z(i, 1), l(i), i), G.round = (i) => {
    const m = G(i), a = G.ceil(i);
    return i - m < a - i ? m : a;
  }, G.offset = (i, m) => (Z(i = /* @__PURE__ */ new Date(+i), m == null ? 1 : Math.floor(m)), i), G.range = (i, m, a) => {
    const n = [];
    if (i = G.ceil(i), a = a == null ? 1 : Math.floor(a), !(i < m) || !(a > 0)) return n;
    let p;
    do
      n.push(p = /* @__PURE__ */ new Date(+i)), Z(i, a), l(i);
    while (p < i && i < m);
    return n;
  }, G.filter = (i) => Fc((m) => {
    if (m >= m) for (; l(m), !i(m); ) m.setTime(m - 1);
  }, (m, a) => {
    if (m >= m)
      if (a < 0) for (; ++a <= 0; )
        for (; Z(m, -1), !i(m); )
          ;
      else for (; --a >= 0; )
        for (; Z(m, 1), !i(m); )
          ;
  }), u && (G.count = (i, m) => (uW.setTime(+i), sW.setTime(+m), l(uW), l(sW), Math.floor(u(uW, sW))), G.every = (i) => (i = Math.floor(i), !isFinite(i) || !(i > 0) ? null : i > 1 ? G.filter(s ? (m) => s(m) % i === 0 : (m) => G.count(0, m) % i === 0) : G)), G;
}
const Xo = Fc(() => {
}, (l, Z) => {
  l.setTime(+l + Z);
}, (l, Z) => Z - l);
Xo.every = (l) => (l = Math.floor(l), !isFinite(l) || !(l > 0) ? null : l > 1 ? Fc((Z) => {
  Z.setTime(Math.floor(Z / l) * l);
}, (Z, u) => {
  Z.setTime(+Z + u * l);
}, (Z, u) => (u - Z) / l) : Xo);
Xo.range;
const md = 1e3, yu = md * 60, id = yu * 60, Ld = id * 24, ax = Ld * 7, hI = Ld * 30, dW = Ld * 365, od = Fc((l) => {
  l.setTime(l - l.getMilliseconds());
}, (l, Z) => {
  l.setTime(+l + Z * md);
}, (l, Z) => (Z - l) / md, (l) => l.getUTCSeconds());
od.range;
const my = Fc((l) => {
  l.setTime(l - l.getMilliseconds() - l.getSeconds() * md);
}, (l, Z) => {
  l.setTime(+l + Z * yu);
}, (l, Z) => (Z - l) / yu, (l) => l.getMinutes());
my.range;
const iy = Fc((l) => {
  l.setUTCSeconds(0, 0);
}, (l, Z) => {
  l.setTime(+l + Z * yu);
}, (l, Z) => (Z - l) / yu, (l) => l.getUTCMinutes());
iy.range;
const oy = Fc((l) => {
  l.setTime(l - l.getMilliseconds() - l.getSeconds() * md - l.getMinutes() * yu);
}, (l, Z) => {
  l.setTime(+l + Z * id);
}, (l, Z) => (Z - l) / id, (l) => l.getHours());
oy.range;
const ey = Fc((l) => {
  l.setUTCMinutes(0, 0, 0);
}, (l, Z) => {
  l.setTime(+l + Z * id);
}, (l, Z) => (Z - l) / id, (l) => l.getUTCHours());
ey.range;
const LG = Fc(
  (l) => l.setHours(0, 0, 0, 0),
  (l, Z) => l.setDate(l.getDate() + Z),
  (l, Z) => (Z - l - (Z.getTimezoneOffset() - l.getTimezoneOffset()) * yu) / Ld,
  (l) => l.getDate() - 1
);
LG.range;
const ym = Fc((l) => {
  l.setUTCHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setUTCDate(l.getUTCDate() + Z);
}, (l, Z) => (Z - l) / Ld, (l) => l.getUTCDate() - 1);
ym.range;
const vr = Fc((l) => {
  l.setUTCHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setUTCDate(l.getUTCDate() + Z);
}, (l, Z) => (Z - l) / Ld, (l) => Math.floor(l / Ld));
vr.range;
function Fm(l) {
  return Fc((Z) => {
    Z.setDate(Z.getDate() - (Z.getDay() + 7 - l) % 7), Z.setHours(0, 0, 0, 0);
  }, (Z, u) => {
    Z.setDate(Z.getDate() + u * 7);
  }, (Z, u) => (u - Z - (u.getTimezoneOffset() - Z.getTimezoneOffset()) * yu) / ax);
}
const xn = Fm(0), Fh = Fm(1), q6 = Fm(2), _6 = Fm(3), Ko = Fm(4), l$ = Fm(5), Z$ = Fm(6);
xn.range;
Fh.range;
q6.range;
_6.range;
Ko.range;
l$.range;
Z$.range;
function Nm(l) {
  return Fc((Z) => {
    Z.setUTCDate(Z.getUTCDate() - (Z.getUTCDay() + 7 - l) % 7), Z.setUTCHours(0, 0, 0, 0);
  }, (Z, u) => {
    Z.setUTCDate(Z.getUTCDate() + u * 7);
  }, (Z, u) => (u - Z) / ax);
}
const Rn = Nm(0), Nh = Nm(1), c$ = Nm(2), b$ = Nm(3), Wo = Nm(4), u$ = Nm(5), s$ = Nm(6);
Rn.range;
Nh.range;
c$.range;
b$.range;
Wo.range;
u$.range;
s$.range;
const dn = Fc((l) => {
  l.setDate(1), l.setHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setMonth(l.getMonth() + Z);
}, (l, Z) => Z.getMonth() - l.getMonth() + (Z.getFullYear() - l.getFullYear()) * 12, (l) => l.getMonth());
dn.range;
const Gn = Fc((l) => {
  l.setUTCDate(1), l.setUTCHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setUTCMonth(l.getUTCMonth() + Z);
}, (l, Z) => Z.getUTCMonth() - l.getUTCMonth() + (Z.getUTCFullYear() - l.getUTCFullYear()) * 12, (l) => l.getUTCMonth());
Gn.range;
const ts = Fc((l) => {
  l.setMonth(0, 1), l.setHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setFullYear(l.getFullYear() + Z);
}, (l, Z) => Z.getFullYear() - l.getFullYear(), (l) => l.getFullYear());
ts.every = (l) => !isFinite(l = Math.floor(l)) || !(l > 0) ? null : Fc((Z) => {
  Z.setFullYear(Math.floor(Z.getFullYear() / l) * l), Z.setMonth(0, 1), Z.setHours(0, 0, 0, 0);
}, (Z, u) => {
  Z.setFullYear(Z.getFullYear() + u * l);
});
ts.range;
const Xs = Fc((l) => {
  l.setUTCMonth(0, 1), l.setUTCHours(0, 0, 0, 0);
}, (l, Z) => {
  l.setUTCFullYear(l.getUTCFullYear() + Z);
}, (l, Z) => Z.getUTCFullYear() - l.getUTCFullYear(), (l) => l.getUTCFullYear());
Xs.every = (l) => !isFinite(l = Math.floor(l)) || !(l > 0) ? null : Fc((Z) => {
  Z.setUTCFullYear(Math.floor(Z.getUTCFullYear() / l) * l), Z.setUTCMonth(0, 1), Z.setUTCHours(0, 0, 0, 0);
}, (Z, u) => {
  Z.setUTCFullYear(Z.getUTCFullYear() + u * l);
});
Xs.range;
function Tr(l, Z, u, s, G, i) {
  const m = [
    [od, 1, md],
    [od, 5, 5 * md],
    [od, 15, 15 * md],
    [od, 30, 30 * md],
    [i, 1, yu],
    [i, 5, 5 * yu],
    [i, 15, 15 * yu],
    [i, 30, 30 * yu],
    [G, 1, id],
    [G, 3, 3 * id],
    [G, 6, 6 * id],
    [G, 12, 12 * id],
    [s, 1, Ld],
    [s, 2, 2 * Ld],
    [u, 1, ax],
    [Z, 1, hI],
    [Z, 3, 3 * hI],
    [l, 1, dW]
  ];
  function a(p, y, h) {
    const S = y < p;
    S && ([p, y] = [y, p]);
    const t = h && typeof h.range == "function" ? h : n(p, y, h), W = t ? t.range(p, +y + 1) : [];
    return S ? W.reverse() : W;
  }
  function n(p, y, h) {
    const S = Math.abs(y - p) / h, t = ux(([, , R]) => R).right(m, S);
    if (t === m.length) return l.every(eV(p / dW, y / dW, h));
    if (t === 0) return Xo.every(Math.max(eV(p, y, h), 1));
    const [W, V] = m[S / m[t - 1][2] < m[t][2] / S ? t - 1 : t];
    return W.every(V);
  }
  return [a, n];
}
const [d$, G$] = Tr(Xs, Gn, Rn, vr, ey, iy), [m$, i$] = Tr(ts, dn, xn, LG, oy, my);
function GW(l) {
  if (0 <= l.y && l.y < 100) {
    var Z = new Date(-1, l.m, l.d, l.H, l.M, l.S, l.L);
    return Z.setFullYear(l.y), Z;
  }
  return new Date(l.y, l.m, l.d, l.H, l.M, l.S, l.L);
}
function mW(l) {
  if (0 <= l.y && l.y < 100) {
    var Z = new Date(Date.UTC(-1, l.m, l.d, l.H, l.M, l.S, l.L));
    return Z.setUTCFullYear(l.y), Z;
  }
  return new Date(Date.UTC(l.y, l.m, l.d, l.H, l.M, l.S, l.L));
}
function Va(l, Z, u) {
  return { y: l, m: Z, d: u, H: 0, M: 0, S: 0, L: 0 };
}
function o$(l) {
  var Z = l.dateTime, u = l.date, s = l.time, G = l.periods, i = l.days, m = l.shortDays, a = l.months, n = l.shortMonths, p = xa(G), y = Ra(G), h = xa(i), S = Ra(i), t = xa(m), W = Ra(m), V = xa(a), R = Ra(a), x = xa(n), r = Ra(n), k = {
    a: f,
    A: O,
    b: _,
    B: il,
    c: null,
    d: WI,
    e: WI,
    f: F$,
    g: E$,
    G: D$,
    H: U$,
    I: C$,
    j: r$,
    L: fr,
    m: N$,
    M: w$,
    p: Zl,
    q: ol,
    Q: RI,
    s: YI,
    S: z$,
    u: J$,
    U: H$,
    V: g$,
    w: v$,
    W: T$,
    x: null,
    X: null,
    y: f$,
    Y: B$,
    Z: j$,
    "%": xI
  }, U = {
    a: Wl,
    A: ml,
    b: Rl,
    B: kl,
    c: null,
    d: VI,
    e: VI,
    f: A$,
    g: dq,
    G: mq,
    H: Q$,
    I: P$,
    j: O$,
    L: Br,
    m: $$,
    M: q$,
    p: zl,
    q: Vl,
    Q: RI,
    s: YI,
    S: _$,
    u: lq,
    U: Zq,
    V: cq,
    w: bq,
    W: uq,
    x: null,
    X: null,
    y: sq,
    Y: Gq,
    Z: iq,
    "%": xI
  }, w = {
    a: E,
    A: g,
    b: A,
    B: J,
    c: F,
    d: XI,
    e: XI,
    f: Y$,
    g: tI,
    G: SI,
    H: KI,
    I: KI,
    j: W$,
    L: R$,
    m: K$,
    M: V$,
    p: j,
    q: X$,
    Q: M$,
    s: I$,
    S: x$,
    u: L$,
    U: h$,
    V: y$,
    w: p$,
    W: S$,
    x: v,
    X: T,
    y: tI,
    Y: SI,
    Z: t$,
    "%": k$
  };
  k.x = z(u, k), k.X = z(s, k), k.c = z(Z, k), U.x = z(u, U), U.X = z(s, U), U.c = z(Z, U);
  function z(el, xl) {
    return function(hl) {
      var cl = [], wl = -1, Jl = 0, cZ = el.length, uZ, UZ, hc;
      for (hl instanceof Date || (hl = /* @__PURE__ */ new Date(+hl)); ++wl < cZ; )
        el.charCodeAt(wl) === 37 && (cl.push(el.slice(Jl, wl)), (UZ = yI[uZ = el.charAt(++wl)]) != null ? uZ = el.charAt(++wl) : UZ = uZ === "e" ? " " : "0", (hc = xl[uZ]) && (uZ = hc(hl, UZ)), cl.push(uZ), Jl = wl + 1);
      return cl.push(el.slice(Jl, wl)), cl.join("");
    };
  }
  function D(el, xl) {
    return function(hl) {
      var cl = Va(1900, void 0, 1), wl = C(cl, el, hl += "", 0), Jl, cZ;
      if (wl != hl.length) return null;
      if ("Q" in cl) return new Date(cl.Q);
      if ("s" in cl) return new Date(cl.s * 1e3 + ("L" in cl ? cl.L : 0));
      if (xl && !("Z" in cl) && (cl.Z = 0), "p" in cl && (cl.H = cl.H % 12 + cl.p * 12), cl.m === void 0 && (cl.m = "q" in cl ? cl.q : 0), "V" in cl) {
        if (cl.V < 1 || cl.V > 53) return null;
        "w" in cl || (cl.w = 1), "Z" in cl ? (Jl = mW(Va(cl.y, 0, 1)), cZ = Jl.getUTCDay(), Jl = cZ > 4 || cZ === 0 ? Nh.ceil(Jl) : Nh(Jl), Jl = ym.offset(Jl, (cl.V - 1) * 7), cl.y = Jl.getUTCFullYear(), cl.m = Jl.getUTCMonth(), cl.d = Jl.getUTCDate() + (cl.w + 6) % 7) : (Jl = GW(Va(cl.y, 0, 1)), cZ = Jl.getDay(), Jl = cZ > 4 || cZ === 0 ? Fh.ceil(Jl) : Fh(Jl), Jl = LG.offset(Jl, (cl.V - 1) * 7), cl.y = Jl.getFullYear(), cl.m = Jl.getMonth(), cl.d = Jl.getDate() + (cl.w + 6) % 7);
      } else ("W" in cl || "U" in cl) && ("w" in cl || (cl.w = "u" in cl ? cl.u % 7 : "W" in cl ? 1 : 0), cZ = "Z" in cl ? mW(Va(cl.y, 0, 1)).getUTCDay() : GW(Va(cl.y, 0, 1)).getDay(), cl.m = 0, cl.d = "W" in cl ? (cl.w + 6) % 7 + cl.W * 7 - (cZ + 5) % 7 : cl.w + cl.U * 7 - (cZ + 6) % 7);
      return "Z" in cl ? (cl.H += cl.Z / 100 | 0, cl.M += cl.Z % 100, mW(cl)) : GW(cl);
    };
  }
  function C(el, xl, hl, cl) {
    for (var wl = 0, Jl = xl.length, cZ = hl.length, uZ, UZ; wl < Jl; ) {
      if (cl >= cZ) return -1;
      if (uZ = xl.charCodeAt(wl++), uZ === 37) {
        if (uZ = xl.charAt(wl++), UZ = w[uZ in yI ? xl.charAt(wl++) : uZ], !UZ || (cl = UZ(el, hl, cl)) < 0) return -1;
      } else if (uZ != hl.charCodeAt(cl++))
        return -1;
    }
    return cl;
  }
  function j(el, xl, hl) {
    var cl = p.exec(xl.slice(hl));
    return cl ? (el.p = y.get(cl[0].toLowerCase()), hl + cl[0].length) : -1;
  }
  function E(el, xl, hl) {
    var cl = t.exec(xl.slice(hl));
    return cl ? (el.w = W.get(cl[0].toLowerCase()), hl + cl[0].length) : -1;
  }
  function g(el, xl, hl) {
    var cl = h.exec(xl.slice(hl));
    return cl ? (el.w = S.get(cl[0].toLowerCase()), hl + cl[0].length) : -1;
  }
  function A(el, xl, hl) {
    var cl = x.exec(xl.slice(hl));
    return cl ? (el.m = r.get(cl[0].toLowerCase()), hl + cl[0].length) : -1;
  }
  function J(el, xl, hl) {
    var cl = V.exec(xl.slice(hl));
    return cl ? (el.m = R.get(cl[0].toLowerCase()), hl + cl[0].length) : -1;
  }
  function F(el, xl, hl) {
    return C(el, Z, xl, hl);
  }
  function v(el, xl, hl) {
    return C(el, u, xl, hl);
  }
  function T(el, xl, hl) {
    return C(el, s, xl, hl);
  }
  function f(el) {
    return m[el.getDay()];
  }
  function O(el) {
    return i[el.getDay()];
  }
  function _(el) {
    return n[el.getMonth()];
  }
  function il(el) {
    return a[el.getMonth()];
  }
  function Zl(el) {
    return G[+(el.getHours() >= 12)];
  }
  function ol(el) {
    return 1 + ~~(el.getMonth() / 3);
  }
  function Wl(el) {
    return m[el.getUTCDay()];
  }
  function ml(el) {
    return i[el.getUTCDay()];
  }
  function Rl(el) {
    return n[el.getUTCMonth()];
  }
  function kl(el) {
    return a[el.getUTCMonth()];
  }
  function zl(el) {
    return G[+(el.getUTCHours() >= 12)];
  }
  function Vl(el) {
    return 1 + ~~(el.getUTCMonth() / 3);
  }
  return {
    format: function(el) {
      var xl = z(el += "", k);
      return xl.toString = function() {
        return el;
      }, xl;
    },
    parse: function(el) {
      var xl = D(el += "", !1);
      return xl.toString = function() {
        return el;
      }, xl;
    },
    utcFormat: function(el) {
      var xl = z(el += "", U);
      return xl.toString = function() {
        return el;
      }, xl;
    },
    utcParse: function(el) {
      var xl = D(el += "", !0);
      return xl.toString = function() {
        return el;
      }, xl;
    }
  };
}
var yI = { "-": "", _: " ", 0: "0" }, fc = /^\s*\d+/, e$ = /^%/, a$ = /[\\^$*+?|[\]().{}]/g;
function IZ(l, Z, u) {
  var s = l < 0 ? "-" : "", G = (s ? -l : l) + "", i = G.length;
  return s + (i < u ? new Array(u - i + 1).join(Z) + G : G);
}
function n$(l) {
  return l.replace(a$, "\\$&");
}
function xa(l) {
  return new RegExp("^(?:" + l.map(n$).join("|") + ")", "i");
}
function Ra(l) {
  return new Map(l.map((Z, u) => [Z.toLowerCase(), u]));
}
function p$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 1));
  return s ? (l.w = +s[0], u + s[0].length) : -1;
}
function L$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 1));
  return s ? (l.u = +s[0], u + s[0].length) : -1;
}
function h$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.U = +s[0], u + s[0].length) : -1;
}
function y$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.V = +s[0], u + s[0].length) : -1;
}
function S$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.W = +s[0], u + s[0].length) : -1;
}
function SI(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 4));
  return s ? (l.y = +s[0], u + s[0].length) : -1;
}
function tI(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.y = +s[0] + (+s[0] > 68 ? 1900 : 2e3), u + s[0].length) : -1;
}
function t$(l, Z, u) {
  var s = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(Z.slice(u, u + 6));
  return s ? (l.Z = s[1] ? 0 : -(s[2] + (s[3] || "00")), u + s[0].length) : -1;
}
function X$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 1));
  return s ? (l.q = s[0] * 3 - 3, u + s[0].length) : -1;
}
function K$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.m = s[0] - 1, u + s[0].length) : -1;
}
function XI(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.d = +s[0], u + s[0].length) : -1;
}
function W$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 3));
  return s ? (l.m = 0, l.d = +s[0], u + s[0].length) : -1;
}
function KI(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.H = +s[0], u + s[0].length) : -1;
}
function V$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.M = +s[0], u + s[0].length) : -1;
}
function x$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 2));
  return s ? (l.S = +s[0], u + s[0].length) : -1;
}
function R$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 3));
  return s ? (l.L = +s[0], u + s[0].length) : -1;
}
function Y$(l, Z, u) {
  var s = fc.exec(Z.slice(u, u + 6));
  return s ? (l.L = Math.floor(s[0] / 1e3), u + s[0].length) : -1;
}
function k$(l, Z, u) {
  var s = e$.exec(Z.slice(u, u + 1));
  return s ? u + s[0].length : -1;
}
function M$(l, Z, u) {
  var s = fc.exec(Z.slice(u));
  return s ? (l.Q = +s[0], u + s[0].length) : -1;
}
function I$(l, Z, u) {
  var s = fc.exec(Z.slice(u));
  return s ? (l.s = +s[0], u + s[0].length) : -1;
}
function WI(l, Z) {
  return IZ(l.getDate(), Z, 2);
}
function U$(l, Z) {
  return IZ(l.getHours(), Z, 2);
}
function C$(l, Z) {
  return IZ(l.getHours() % 12 || 12, Z, 2);
}
function r$(l, Z) {
  return IZ(1 + LG.count(ts(l), l), Z, 3);
}
function fr(l, Z) {
  return IZ(l.getMilliseconds(), Z, 3);
}
function F$(l, Z) {
  return fr(l, Z) + "000";
}
function N$(l, Z) {
  return IZ(l.getMonth() + 1, Z, 2);
}
function w$(l, Z) {
  return IZ(l.getMinutes(), Z, 2);
}
function z$(l, Z) {
  return IZ(l.getSeconds(), Z, 2);
}
function J$(l) {
  var Z = l.getDay();
  return Z === 0 ? 7 : Z;
}
function H$(l, Z) {
  return IZ(xn.count(ts(l) - 1, l), Z, 2);
}
function Er(l) {
  var Z = l.getDay();
  return Z >= 4 || Z === 0 ? Ko(l) : Ko.ceil(l);
}
function g$(l, Z) {
  return l = Er(l), IZ(Ko.count(ts(l), l) + (ts(l).getDay() === 4), Z, 2);
}
function v$(l) {
  return l.getDay();
}
function T$(l, Z) {
  return IZ(Fh.count(ts(l) - 1, l), Z, 2);
}
function f$(l, Z) {
  return IZ(l.getFullYear() % 100, Z, 2);
}
function E$(l, Z) {
  return l = Er(l), IZ(l.getFullYear() % 100, Z, 2);
}
function B$(l, Z) {
  return IZ(l.getFullYear() % 1e4, Z, 4);
}
function D$(l, Z) {
  var u = l.getDay();
  return l = u >= 4 || u === 0 ? Ko(l) : Ko.ceil(l), IZ(l.getFullYear() % 1e4, Z, 4);
}
function j$(l) {
  var Z = l.getTimezoneOffset();
  return (Z > 0 ? "-" : (Z *= -1, "+")) + IZ(Z / 60 | 0, "0", 2) + IZ(Z % 60, "0", 2);
}
function VI(l, Z) {
  return IZ(l.getUTCDate(), Z, 2);
}
function Q$(l, Z) {
  return IZ(l.getUTCHours(), Z, 2);
}
function P$(l, Z) {
  return IZ(l.getUTCHours() % 12 || 12, Z, 2);
}
function O$(l, Z) {
  return IZ(1 + ym.count(Xs(l), l), Z, 3);
}
function Br(l, Z) {
  return IZ(l.getUTCMilliseconds(), Z, 3);
}
function A$(l, Z) {
  return Br(l, Z) + "000";
}
function $$(l, Z) {
  return IZ(l.getUTCMonth() + 1, Z, 2);
}
function q$(l, Z) {
  return IZ(l.getUTCMinutes(), Z, 2);
}
function _$(l, Z) {
  return IZ(l.getUTCSeconds(), Z, 2);
}
function lq(l) {
  var Z = l.getUTCDay();
  return Z === 0 ? 7 : Z;
}
function Zq(l, Z) {
  return IZ(Rn.count(Xs(l) - 1, l), Z, 2);
}
function Dr(l) {
  var Z = l.getUTCDay();
  return Z >= 4 || Z === 0 ? Wo(l) : Wo.ceil(l);
}
function cq(l, Z) {
  return l = Dr(l), IZ(Wo.count(Xs(l), l) + (Xs(l).getUTCDay() === 4), Z, 2);
}
function bq(l) {
  return l.getUTCDay();
}
function uq(l, Z) {
  return IZ(Nh.count(Xs(l) - 1, l), Z, 2);
}
function sq(l, Z) {
  return IZ(l.getUTCFullYear() % 100, Z, 2);
}
function dq(l, Z) {
  return l = Dr(l), IZ(l.getUTCFullYear() % 100, Z, 2);
}
function Gq(l, Z) {
  return IZ(l.getUTCFullYear() % 1e4, Z, 4);
}
function mq(l, Z) {
  var u = l.getUTCDay();
  return l = u >= 4 || u === 0 ? Wo(l) : Wo.ceil(l), IZ(l.getUTCFullYear() % 1e4, Z, 4);
}
function iq() {
  return "+0000";
}
function xI() {
  return "%";
}
function RI(l) {
  return +l;
}
function YI(l) {
  return Math.floor(+l / 1e3);
}
var Ji, jr, Qr;
oq({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function oq(l) {
  return Ji = o$(l), jr = Ji.format, Ji.parse, Qr = Ji.utcFormat, Ji.utcParse, Ji;
}
function eq(l) {
  return new Date(l);
}
function aq(l) {
  return l instanceof Date ? +l : +/* @__PURE__ */ new Date(+l);
}
function nx(l, Z, u, s, G, i, m, a, n, p) {
  var y = Mr(), h = y.invert, S = y.domain, t = p(".%L"), W = p(":%S"), V = p("%I:%M"), R = p("%I %p"), x = p("%a %d"), r = p("%b %d"), k = p("%B"), U = p("%Y");
  function w(z) {
    return (n(z) < z ? t : a(z) < z ? W : m(z) < z ? V : i(z) < z ? R : s(z) < z ? G(z) < z ? x : r : u(z) < z ? k : U)(z);
  }
  return y.invert = function(z) {
    return new Date(h(z));
  }, y.domain = function(z) {
    return arguments.length ? S(Array.from(z, aq)) : S().map(eq);
  }, y.ticks = function(z) {
    var D = S();
    return l(D[0], D[D.length - 1], z ?? 10);
  }, y.tickFormat = function(z, D) {
    return D == null ? w : p(D);
  }, y.nice = function(z) {
    var D = S();
    return (!z || typeof z.range != "function") && (z = Z(D[0], D[D.length - 1], z ?? 10)), z ? S(Nr(D, z)) : y;
  }, y.copy = function() {
    return Vn(y, nx(l, Z, u, s, G, i, m, a, n, p));
  }, y;
}
function nq() {
  return Vs.apply(nx(m$, i$, ts, dn, xn, LG, oy, my, od, jr).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function pq() {
  return Vs.apply(nx(d$, G$, Xs, Gn, Rn, ym, ey, iy, od, Qr).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function ay() {
  var l = 0, Z = 1, u, s, G, i, m = vb, a = !1, n;
  function p(h) {
    return h == null || isNaN(h = +h) ? n : m(G === 0 ? 0.5 : (h = (i(h) - u) * G, a ? Math.max(0, Math.min(1, h)) : h));
  }
  p.domain = function(h) {
    return arguments.length ? ([l, Z] = h, u = i(l = +l), s = i(Z = +Z), G = u === s ? 0 : 1 / (s - u), p) : [l, Z];
  }, p.clamp = function(h) {
    return arguments.length ? (a = !!h, p) : a;
  }, p.interpolator = function(h) {
    return arguments.length ? (m = h, p) : m;
  };
  function y(h) {
    return function(S) {
      var t, W;
      return arguments.length ? ([t, W] = S, m = h(t, W), p) : [m(0), m(1)];
    };
  }
  return p.range = y(Cm), p.rangeRound = y(Oh), p.unknown = function(h) {
    return arguments.length ? (n = h, p) : n;
  }, function(h) {
    return i = h, u = h(l), s = h(Z), G = u === s ? 0 : 1 / (s - u), p;
  };
}
function SG(l, Z) {
  return Z.domain(l.domain()).interpolator(l.interpolator()).clamp(l.clamp()).unknown(l.unknown());
}
function px() {
  var l = rm(ay()(vb));
  return l.copy = function() {
    return SG(l, px());
  }, yG.apply(l, arguments);
}
function Pr() {
  var l = mx(ay()).domain([1, 10]);
  return l.copy = function() {
    return SG(l, Pr()).base(l.base());
  }, yG.apply(l, arguments);
}
function Or() {
  var l = ix(ay());
  return l.copy = function() {
    return SG(l, Or()).constant(l.constant());
  }, yG.apply(l, arguments);
}
function Lx() {
  var l = ox(ay());
  return l.copy = function() {
    return SG(l, Lx()).exponent(l.exponent());
  }, yG.apply(l, arguments);
}
function Lq() {
  return Lx.apply(null, arguments).exponent(0.5);
}
function ny() {
  var l = 0, Z = 0.5, u = 1, s = 1, G, i, m, a, n, p = vb, y, h = !1, S;
  function t(V) {
    return isNaN(V = +V) ? S : (V = 0.5 + ((V = +y(V)) - i) * (s * V < s * i ? a : n), p(h ? Math.max(0, Math.min(1, V)) : V));
  }
  t.domain = function(V) {
    return arguments.length ? ([l, Z, u] = V, G = y(l = +l), i = y(Z = +Z), m = y(u = +u), a = G === i ? 0 : 0.5 / (i - G), n = i === m ? 0 : 0.5 / (m - i), s = i < G ? -1 : 1, t) : [l, Z, u];
  }, t.clamp = function(V) {
    return arguments.length ? (h = !!V, t) : h;
  }, t.interpolator = function(V) {
    return arguments.length ? (p = V, t) : p;
  };
  function W(V) {
    return function(R) {
      var x, r, k;
      return arguments.length ? ([x, r, k] = R, p = fV(V, [x, r, k]), t) : [p(0), p(0.5), p(1)];
    };
  }
  return t.range = W(Cm), t.rangeRound = W(Oh), t.unknown = function(V) {
    return arguments.length ? (S = V, t) : S;
  }, function(V) {
    return y = V, G = V(l), i = V(Z), m = V(u), a = G === i ? 0 : 0.5 / (i - G), n = i === m ? 0 : 0.5 / (m - i), s = i < G ? -1 : 1, t;
  };
}
function Ar() {
  var l = rm(ny()(vb));
  return l.copy = function() {
    return SG(l, Ar());
  }, yG.apply(l, arguments);
}
function $r() {
  var l = mx(ny()).domain([0.1, 1, 10]);
  return l.copy = function() {
    return SG(l, $r()).base(l.base());
  }, yG.apply(l, arguments);
}
function qr() {
  var l = ix(ny());
  return l.copy = function() {
    return SG(l, qr()).constant(l.constant());
  }, yG.apply(l, arguments);
}
function hx() {
  var l = ox(ny());
  return l.copy = function() {
    return SG(l, hx()).exponent(l.exponent());
  }, yG.apply(l, arguments);
}
function hq() {
  return hx.apply(null, arguments).exponent(0.5);
}
function xs(l) {
  for (var Z = l.length / 6 | 0, u = new Array(Z), s = 0; s < Z; ) u[s] = "#" + l.slice(s * 6, ++s * 6);
  return u;
}
const yq = xs("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"), Sq = xs("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"), tq = xs("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"), Xq = xs("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0"), Kq = xs("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"), Wq = xs("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"), Vq = xs("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"), xq = xs("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"), Rq = xs("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"), Yq = xs("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"), yx = "year", Sx = "quarter", tx = "month", Xx = "week", Kx = "date", Wx = "day", Vx = "dayofyear", xx = "hours", Rx = "minutes", Yx = "seconds", kx = "milliseconds", kq = [yx, Sx, tx, Xx, Kx, Wx, Vx, xx, Rx, Yx, kx];
kq.reduce((l, Z, u) => (l[Z] = 1 + u, l), {});
yx + "", Sx + "", dn.every(3), tx + "", Xx + "", Kx + "", Wx + "", Vx + "", xx + "", Rx + "", Yx + "", kx + "";
yx + "", Sx + "", Gn.every(3), tx + "", Xx + "", Kx + "", Wx + "", Vx + "", xx + "", Rx + "", Yx + "", kx + "";
function Mq(l, Z, u) {
  const s = l - Z + u * 2;
  return l ? s > 0 ? s : 1 : 0;
}
const Iq = "identity", Mx = "linear", Vo = "log", Ix = "pow", Ux = "sqrt", Cx = "symlog", Uq = "time", Cq = "utc", Uo = "sequential", Yn = "diverging", kI = "quantile", rq = "quantize", Fq = "threshold", Nq = "ordinal", wq = "point", zq = "band", Jq = "bin-ordinal", Ec = "continuous", py = "discrete", Ly = "discretizing", ju = "interpolating", _r = "temporal";
function Hq(l) {
  return function(Z) {
    let u = Z[0], s = Z[1], G;
    return s < u && (G = u, u = s, s = G), [l.invert(u), l.invert(s)];
  };
}
function gq(l) {
  return function(Z) {
    const u = l.range();
    let s = Z[0], G = Z[1], i = -1, m, a, n, p;
    for (G < s && (a = s, s = G, G = a), n = 0, p = u.length; n < p; ++n)
      u[n] >= s && u[n] <= G && (i < 0 && (i = n), m = n);
    if (!(i < 0))
      return s = l.invertExtent(u[i]), G = l.invertExtent(u[m]), [s[0] === void 0 ? s[1] : s[0], G[1] === void 0 ? G[0] : G[1]];
  };
}
function rx() {
  const l = sx().unknown(void 0), Z = l.domain, u = l.range;
  let s = [0, 1], G, i, m = !1, a = 0, n = 0, p = 0.5;
  delete l.unknown;
  function y() {
    const h = Z().length, S = s[1] < s[0], t = s[1 - S], W = Mq(h, a, n);
    let V = s[S - 0];
    G = (t - V) / (W || 1), m && (G = Math.floor(G)), V += (t - V - G * (h - a)) * p, i = G * (1 - a), m && (V = Math.round(V), i = Math.round(i));
    const R = M6(h).map((x) => V + G * x);
    return u(S ? R.reverse() : R);
  }
  return l.domain = function(h) {
    return arguments.length ? (Z(h), y()) : Z();
  }, l.range = function(h) {
    return arguments.length ? (s = [+h[0], +h[1]], y()) : s.slice();
  }, l.rangeRound = function(h) {
    return s = [+h[0], +h[1]], m = !0, y();
  }, l.bandwidth = function() {
    return i;
  }, l.step = function() {
    return G;
  }, l.round = function(h) {
    return arguments.length ? (m = !!h, y()) : m;
  }, l.padding = function(h) {
    return arguments.length ? (n = Math.max(0, Math.min(1, h)), a = n, y()) : a;
  }, l.paddingInner = function(h) {
    return arguments.length ? (a = Math.max(0, Math.min(1, h)), y()) : a;
  }, l.paddingOuter = function(h) {
    return arguments.length ? (n = Math.max(0, Math.min(1, h)), y()) : n;
  }, l.align = function(h) {
    return arguments.length ? (p = Math.max(0, Math.min(1, h)), y()) : p;
  }, l.invertRange = function(h) {
    if (h[0] == null || h[1] == null) return;
    const S = s[1] < s[0], t = S ? u().reverse() : u(), W = t.length - 1;
    let V = +h[0], R = +h[1], x, r, k;
    if (!(V !== V || R !== R) && (R < V && (k = V, V = R, R = k), !(R < t[0] || V > s[1 - S])))
      return x = Math.max(0, km(t, V) - 1), r = V === R ? x : km(t, R) - 1, V - t[x] > i + 1e-10 && ++x, S && (k = x, x = W - r, r = W - k), x > r ? void 0 : Z().slice(x, r + 1);
  }, l.invert = function(h) {
    const S = l.invertRange([h, h]);
    return S && S[0];
  }, l.copy = function() {
    return rx().domain(Z()).range(s).round(m).paddingInner(a).paddingOuter(n).align(p);
  }, y();
}
function lF(l) {
  const Z = l.copy;
  return l.padding = l.paddingOuter, delete l.paddingInner, l.copy = function() {
    return lF(Z());
  }, l;
}
function vq() {
  return lF(rx().paddingInner(1));
}
var Tq = Array.prototype.map;
function fq(l) {
  return Tq.call(l, L6);
}
const Eq = Array.prototype.slice;
function ZF() {
  let l = [], Z = [];
  function u(s) {
    return s == null || s !== s ? void 0 : Z[(km(l, s) - 1) % Z.length];
  }
  return u.domain = function(s) {
    return arguments.length ? (l = fq(s), u) : l.slice();
  }, u.range = function(s) {
    return arguments.length ? (Z = Eq.call(s), u) : Z.slice();
  }, u.tickFormat = function(s, G) {
    return Cr(l[0], p6(l), s ?? 10, G);
  }, u.copy = function() {
    return ZF().domain(u.domain()).range(u.range());
  }, u;
}
const pV = /* @__PURE__ */ new Map(), Bq = Symbol("vega_scale");
function Dq(l) {
  return l[Bq] = !0, l;
}
function jq(l, Z, u) {
  const s = function() {
    const i = Z();
    return i.invertRange || (i.invertRange = i.invert ? Hq(i) : i.invertExtent ? gq(i) : void 0), i.type = l, Dq(i);
  };
  return s.metadata = y6(h6(u)), s;
}
function OZ(l, Z, u) {
  return arguments.length > 1 ? (pV.set(l, jq(l, Z, u)), this) : Qq(l) ? pV.get(l) : void 0;
}
OZ(Iq, Fr);
OZ(Mx, rr, Ec);
OZ(Vo, wr, [Ec, Vo]);
OZ(Ix, ex, Ec);
OZ(Ux, $6, Ec);
OZ(Cx, zr, Ec);
OZ(Uq, nq, [Ec, _r]);
OZ(Cq, pq, [Ec, _r]);
OZ(Uo, px, [Ec, ju]);
OZ(`${Uo}-${Mx}`, px, [Ec, ju]);
OZ(`${Uo}-${Vo}`, Pr, [Ec, ju, Vo]);
OZ(`${Uo}-${Ix}`, Lx, [Ec, ju]);
OZ(`${Uo}-${Ux}`, Lq, [Ec, ju]);
OZ(`${Uo}-${Cx}`, Or, [Ec, ju]);
OZ(`${Yn}-${Mx}`, Ar, [Ec, ju]);
OZ(`${Yn}-${Vo}`, $r, [Ec, ju, Vo]);
OZ(`${Yn}-${Ix}`, hx, [Ec, ju]);
OZ(`${Yn}-${Ux}`, hq, [Ec, ju]);
OZ(`${Yn}-${Cx}`, qr, [Ec, ju]);
OZ(kI, Jr, [Ly, kI]);
OZ(rq, Hr, Ly);
OZ(Fq, gr, Ly);
OZ(Jq, ZF, [py, Ly]);
OZ(Nq, sx, py);
OZ(zq, rx, py);
OZ(wq, vq, py);
function Qq(l) {
  return pV.has(l);
}
function Pq(l, Z, u) {
  return fV(Oq("rgb", u), l);
}
function Oq(l, Z) {
  const u = gQ[Aq(l)];
  return Z != null && u && u.gamma ? u.gamma(Z) : u;
}
function Aq(l) {
  return "interpolate" + l.toLowerCase().split("-").map((Z) => Z[0].toUpperCase() + Z.slice(1)).join("");
}
const $q = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, qq = {
  accent: Sq,
  category10: yq,
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  dark2: tq,
  observable10: Xq,
  paired: Kq,
  pastel1: Wq,
  pastel2: Vq,
  set1: xq,
  set2: Rq,
  set3: Yq,
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5"
};
function cF(l) {
  if (Yr(l)) return l;
  const Z = l.length / 6 | 0, u = new Array(Z);
  for (let s = 0; s < Z; )
    u[s] = "#" + l.slice(s * 6, ++s * 6);
  return u;
}
function bF(l, Z) {
  for (const u in l) LV(u, Z(l[u]));
}
const MI = {};
bF(qq, cF);
bF($q, (l) => Pq(cF(l)));
function LV(l, Z) {
  return l = l && l.toLowerCase(), arguments.length > 1 ? (MI[l] = Z, this) : MI[l];
}
function uh(l) {
  throw new Error('Could not dynamically require "' + l + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var uF = { exports: {} };
(function(l, Z) {
  (function(u) {
    l.exports = u();
  })(function() {
    return (/* @__PURE__ */ function() {
      function u(s, G, i) {
        function m(p, y) {
          if (!G[p]) {
            if (!s[p]) {
              var h = typeof uh == "function" && uh;
              if (!y && h) return h(p, !0);
              if (a) return a(p, !0);
              var S = new Error("Cannot find module '" + p + "'");
              throw S.code = "MODULE_NOT_FOUND", S;
            }
            var t = G[p] = { exports: {} };
            s[p][0].call(t.exports, function(W) {
              var V = s[p][1][W];
              return m(V || W);
            }, t, t.exports, u, s, G, i);
          }
          return G[p].exports;
        }
        for (var a = typeof uh == "function" && uh, n = 0; n < i.length; n++) m(i[n]);
        return m;
      }
      return u;
    }())({ 1: [function(u, s, G) {
      Object.defineProperty(G, "__esModule", {
        value: !0
      });
      var i = /* @__PURE__ */ function() {
        function p(y, h) {
          for (var S = 0; S < h.length; S++) {
            var t = h[S];
            t.enumerable = t.enumerable || !1, t.configurable = !0, "value" in t && (t.writable = !0), Object.defineProperty(y, t.key, t);
          }
        }
        return function(y, h, S) {
          return h && p(y.prototype, h), S && p(y, S), y;
        };
      }();
      function m(p, y) {
        if (!(p instanceof y))
          throw new TypeError("Cannot call a class as a function");
      }
      var a = function() {
        function p() {
          var y = this, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, S = h.defaultLayoutOptions, t = S === void 0 ? {} : S, W = h.algorithms, V = W === void 0 ? ["layered", "stress", "mrtree", "radial", "force", "disco", "sporeOverlap", "sporeCompaction", "rectpacking"] : W, R = h.workerFactory, x = h.workerUrl;
          if (m(this, p), this.defaultLayoutOptions = t, this.initialized = !1, typeof x > "u" && typeof R > "u")
            throw new Error("Cannot construct an ELK without both 'workerUrl' and 'workerFactory'.");
          var r = R;
          typeof x < "u" && typeof R > "u" && (r = function(w) {
            return new Worker(w);
          });
          var k = r(x);
          if (typeof k.postMessage != "function")
            throw new TypeError("Created worker does not provide the required 'postMessage' function.");
          this.worker = new n(k), this.worker.postMessage({
            cmd: "register",
            algorithms: V
          }).then(function(U) {
            return y.initialized = !0;
          }).catch(console.err);
        }
        return i(p, [{
          key: "layout",
          value: function(h) {
            var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = S.layoutOptions, W = t === void 0 ? this.defaultLayoutOptions : t, V = S.logging, R = V === void 0 ? !1 : V, x = S.measureExecutionTime, r = x === void 0 ? !1 : x;
            return h ? this.worker.postMessage({
              cmd: "layout",
              graph: h,
              layoutOptions: W,
              options: {
                logging: R,
                measureExecutionTime: r
              }
            }) : Promise.reject(new Error("Missing mandatory parameter 'graph'."));
          }
        }, {
          key: "knownLayoutAlgorithms",
          value: function() {
            return this.worker.postMessage({ cmd: "algorithms" });
          }
        }, {
          key: "knownLayoutOptions",
          value: function() {
            return this.worker.postMessage({ cmd: "options" });
          }
        }, {
          key: "knownLayoutCategories",
          value: function() {
            return this.worker.postMessage({ cmd: "categories" });
          }
        }, {
          key: "terminateWorker",
          value: function() {
            this.worker && this.worker.terminate();
          }
        }]), p;
      }();
      G.default = a;
      var n = function() {
        function p(y) {
          var h = this;
          if (m(this, p), y === void 0)
            throw new Error("Missing mandatory parameter 'worker'.");
          this.resolvers = {}, this.worker = y, this.worker.onmessage = function(S) {
            setTimeout(function() {
              h.receive(h, S);
            }, 0);
          };
        }
        return i(p, [{
          key: "postMessage",
          value: function(h) {
            var S = this.id || 0;
            this.id = S + 1, h.id = S;
            var t = this;
            return new Promise(function(W, V) {
              t.resolvers[S] = function(R, x) {
                R ? (t.convertGwtStyleError(R), V(R)) : W(x);
              }, t.worker.postMessage(h);
            });
          }
        }, {
          key: "receive",
          value: function(h, S) {
            var t = S.data, W = h.resolvers[t.id];
            W && (delete h.resolvers[t.id], t.error ? W(t.error) : W(null, t.data));
          }
        }, {
          key: "terminate",
          value: function() {
            this.worker && this.worker.terminate();
          }
        }, {
          key: "convertGwtStyleError",
          value: function(h) {
            if (h) {
              var S = h.__java$exception;
              S && (S.cause && S.cause.backingJsObject && (h.cause = S.cause.backingJsObject, this.convertGwtStyleError(h.cause)), delete h.__java$exception);
            }
          }
        }]), p;
      }();
    }, {}], 2: [function(u, s, G) {
      var i = u("./elk-api.js").default;
      Object.defineProperty(s.exports, "__esModule", {
        value: !0
      }), s.exports = i, i.default = i;
    }, { "./elk-api.js": 1 }] }, {}, [2])(2);
  });
})(uF);
var _q = uF.exports;
const l_ = /* @__PURE__ */ wh(_q), sF = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3ZhciBKb2U9dHlwZW9mIGdsb2JhbFRoaXM8InUiP2dsb2JhbFRoaXM6dHlwZW9mIHdpbmRvdzwidSI/d2luZG93OnR5cGVvZiBnbG9iYWw8InUiP2dsb2JhbDp0eXBlb2Ygc2VsZjwidSI/c2VsZjp7fSxab2U9e2V4cG9ydHM6e319OyhmdW5jdGlvbihRb2UsT1llKXt2YXIgUzt0eXBlb2Ygd2luZG93PCJ1Ij9TPXdpbmRvdzp0eXBlb2YgSm9lPCJ1Ij9TPUpvZTp0eXBlb2Ygc2VsZjwidSImJihTPXNlbGYpO3ZhciBxbj0yMTQ3NDgzNjQ3LFVTPXszOjF9LE1lPXszOjEsNDoxLDU6MX0sem09ezIwNDoxLDUxOjF9LCRtPXsyMDQ6MSw1MToxLDEyODoxfSxmXz17MjI5OjEsMzoxfSxzdD17NTE6MX0saDE9ezg1OjF9LEdkPXsyMDoxLDMxOjEsMTY6MX0sU3M9MjA2MyxEaT17MjA6MSwzMToxLDE2OjEsMjE6MX0sekY9ezg1OjEsMTM5OjEsMTMzOjF9LGVpZT17MjA6MSwzMToxLDE2OjEsMjE6MSw4NzoxfSwkRj17MjA6MSwzMToxLDE2OjEsMjc3OjEsMjE6MSw4NzoxfSxDdT17NTE6MSwxMjg6MX0scjY9ezM1ODoxLDQ0OjF9LFg9ezM6MSw2OjEsNDoxLDU6MX0sS3M9MTYzODQsSWE9ezE1OToxfSxKZT17NDE6MX0sV1M9ezIwMjoxfSxqUz17bDo0MTk0MzAzLG06NDE5NDMwMyxoOjUyNDI4N30sdDY9ezI1MzoxLDM6MSwzNDoxfSxUdT17MjA6MX0sbmllPXsyMDoxLDE2OjF9LEJGPXszOjEsMjA6MSwzMToxLDE2OjF9LEJtPXszMDc6MSwzOjEsMjA6MSwzMToxLDE2OjEsMTU6MSw1OToxfSxIYj17MzoxLDQ6MSw1OjEsMTczOjF9LEdtPXszOjEsODU6MX0sbzY9ezIwOjEsMTY6MSwyMToxfSxRZz17MzoxLDIwOjEsMzE6MSwxNjoxLDIxOjF9LHJpZT17MjA6MSwxNjoxLDIxOjEsODc6MX0sYnU9NDYxODQ1OTA3LEl1PS04NjIwNDg5NDMsVlM9ezM6MSw2OjEsNDoxLDU6MSwxNzM6MX0sTGw9MTAyNCx5Mj0xMDczNzQxODI0LFc9ezM6MSw2OjEsNDoxLDk6MSw1OjF9LEhtPXsyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjF9LHRpZT17MjA6MSwzMToxLDU2OjEsMTY6MSwxNToxLDU5OjF9LEluPXs0NjoxfSxVYj17MzgwOjF9LGcwPTFlLTQsYnQ9LTIxNDc0ODM2NDgsS3U9ezM6MSwxMDM6MSw2MzoxLDgyOjF9LFhzPXsyMDE6MSwzOjEsNDoxfSxiYz0xZTMsenI9NjU1MzUsaDA9MTkwMCxrbj17NTM6MSwzOjEsNDoxfSxvaWU9ezM6MSw0OjEsMzQ6MSwyMDY6MX0sX2E9NDE5NDMwMyxYdT0xMDQ4NTc1LHFTPTUyNDI4OCxlaD00MTk0MzA0LHBfPTE3NTkyMTg2MDQ0NDE2LFdiPTFlOSxZUz0tMTc1OTIxODYwNDQ0MTYsaTY9ezM6MSwxMDM6MSw3NzoxLDYzOjEsODI6MX0saWllPXszOjEsMjk2OjEsODI6MX0saHI9MS8wLFZyPS0xLzAsSGQ9NDA5NixhNj17MzoxLDQ6MSwzNzY6MX0sRnQ9NjU1MzYsS1M9NTUyOTYsWHQ9ezEwOToxLDM6MSw0OjF9LGw2PTFlNSxhaWU9LjMwMTAyOTk5NTY2Mzk4MTIsVXQ9NDI5NDk2NzI5NSxzNj17NDQ6MX0sbGllPXszOjEsNDoxLDIwOjEsMzE6MSw1NjoxLDEzOjEsMTY6MSwxNToxLDU5OjF9LHNpZT17MzoxLDIwOjEsMzE6MSw1NjoxLDE2OjEsMTU6MSw1OToxfSx1aWU9ezIwOjEsMTY6MSwxNToxfSx1Nj17MzoxLDUwOjF9LFhTPXsxODk6MX0saHA9ezM6MSw0OjEsODU6MX0sR0Y9ezM6MSw0OjEsMjA6MSwzMToxLDE2OjEsNDk6MSwyMToxfSx3Mj0xNDkwMTE2MTE5Mzg0NzY1NmUtMjQsRTI9MTExMDIyMzAyNDYyNTE1NjVlLTMyLGM2PTE1NTI1NDg1LEpTPTU5NjA0NjQ0Nzc1MzkwNjNlLTIzLEhGPTE2Nzc3MjE2LGpiPTE2Nzc3MjE1LGNpZT17MzoxLDQ6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNTk6MX0sXzY9ezM6MSwzNDoxLDIyOjEsMzA0OjF9LF9pZT17MzoxLDQ6MSw1OjEsODU2OjF9LFVGPXs1MzM6MSw2ODc6MX0sTm49ezUwOjF9LEpzPXsxNzg6MSw0NjoxfSxwbD17MTM0OjF9LHh1PXsxODM6MSwzOjEsNDoxfSxkaWU9ezIxNzoxLDMzNjoxfSxXRj17MzoxLDQ6MSw1OjEsNjAzOjF9LENzPS4wMSxqRj17MzoxLDk2OjEsMTM3OjF9LGdfPXsyMDU6MX0sZDY9MS41NzA3OTYzMjY3OTQ4OTY2LG1wPTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MixVZD17MzoxLDQ6MSw1OjEsMTk4OjF9LGZpZT17MzoxLDY6MSw0OjEsNToxLDEwMDoxLDExNToxfSxacz0uMDAxLFVtPTEuNjAwMDAwMDIzODQxODU4LGpvPXszOjEsNjoxLDQ6MSw5OjEsNToxLDEyNjoxfSxwaWU9ezM6MSw2OjEsNDoxLDU6MSwxNTA6MSwxMDA6MSwxMTU6MX0sc3I9ezQ3OjF9LGY2PXszOjEsNjoxLDQ6MSw1OjEsNDgzOjEsMTUwOjEsMTAwOjEsMTE1OjF9LEljPXszOjEsNjoxLDQ6MSw1OjEsMTUwOjEsMTk5OjEsMjEwOjEsMTAwOjEsMTE1OjF9LGdpZT17MzoxLDY6MSw0OjEsNToxLDE1MDoxLDIwNDI6MSwyMTA6MSwxMDA6MSwxMTU6MX0saGllPXszOjEsNDoxLDE0MDoxLDIxNDoxLDQyMzoxfSxtaWU9ezM6MSw0OjEsMTA3OjEsMjE0OjEsNDIzOjF9LFpTPXsyMzA6MX0sVkY9ezM6MSw0OjEsNToxLDYwMToxfSxXdD17MTA2OjEsNDc6MX0scUY9ezQxMzoxLDIzMDoxfSx5aWU9ezg0NjoxLDM6MSw0OjF9LHdpZT17MzoxLDQ6MSw1OjEsODU0OjF9LFFzPTFlLTUscDY9MWUtNixnNj0uMDk5OTk5OTk5OTk5OTk5OTgsVmI9MWUtOCxFaWU9NC43MTIzODg5ODAzODQ2OSxZRj0zLjE0MTU5MjY1MzU4OTc5MyxoNj0uMTAwMDAwMDAxNDkwMTE2MTIsS0Y9LTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MixxYj17MzoxLDY6MSw0OjEsNToxLDUzNDoxLDEwMDoxLDExNToxfSxoXz02LjI4MzE4NTMwNzE3OTU4NixYRj01ZS0zMjQsdmllPXszOjEsNDoxLDU6MSwxMDA6MX0sU2llPTUuNDk3Nzg3MTQzNzgyMTM4LENpZT0zLjkyNjk5MDgxNjk4NzI0MTQsVGllPTIuMzU2MTk0NDkwMTkyMzQ1LHlwPXszNDE6MX0sV2Q9ezI5NToxfSxtMT0uMDUsYmllPTEuMjk5OTk5OTUyMzE2Mjg0MixKRj17MzoxLDM0OjEsMjI6MSwzNDc6MX0sSWllPXs5NDoxLDkzOjF9LEdvPTMyNzY4LHhpZT17MTEwOjEsOTQ6MSw5MzoxLDU4OjEsNTQ6MSw5OToxfSx3cD17MTk1OjEsMzoxLDQ6MX0sZXU9ezM6MSw0OjEsMjA6MSwzMToxLDU2OjEsMTY6MSwxNToxLDU5OjEsNzA6MSw2NjoxLDYxOjF9LG02PXszOjEsNDoxLDIwOjEsMzE6MSw1NjoxLDE2OjEsNTE6MSwxNToxLDU5OjEsNzA6MSw2NjoxLDYxOjEsNTk2OjF9LFpGPXs0MjQ6MSw2ODY6MX0sUGllPXszOjEsNDoxLDIwOjEsMzE6MSw1NjoxLDE2OjEsMTU6MSw3MDoxLDYxOjF9LFFTPXszNzg6MSwxNTI6MX0seTY9ezM6MSw0OjEsNToxLDEyOToxfSxOaWU9ezM6MSw0OjEsMjA6MSwzMToxLDU2OjEsMTY6MSwxNToxLDU5OjEsNzA6MSw2MToxfSxRRj17MzoxLDY6MSw0OjEsNToxLDE5ODoxfSxBaWU9ezM6MSw0OjEsNToxLDE3MzoxLDM3OToxfSx3Nj17Nzk6MX0sZXo9ezM6MSwyMDoxLDE2OjEsMTU6MSw2MToxLDU5NzoxLDc5OjEsNzE6MSw5NzoxfSxGaT04MTkyLGpkPTIwNDgsRXA9ezM6MSw0OjEsNToxLDI1NDoxfSxuej17MzoxLDQ6MSw1OjEsNjg4OjF9LExpZT17MzoxLDQ6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNTk6MSw3MDoxLDY2OjEsNjE6MSw3MToxfSxFbz17MzoxLDQ6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNTk6MSw3MDoxLDY2OjEsNjE6MSw3OToxLDcxOjEsOTc6MX0sa2llPXszOjEsNDoxLDU6MSw2ODk6MX0scno9ezM6MSw0OjEsMjA6MSwzMToxLDU2OjEsMTY6MSwxNToxLDcwOjEsNjE6MSw3OToxLDcxOjEsOTc6MX0sWWI9ezIwOjEsMzE6MSw1NjoxLDE2OjEsMTU6MSw2MToxLDcxOjF9LEtiPXs1MToxLDEyODoxLDI4NzoxfSxYYj17NzY6MSwzNDM6MX0sdnA9MTM1MixKYj0tMzI3Njgsem49ezU3OjF9LE9pZT17MzoxLDQ6MSw1OjEsMTI0OjF9LE1pZT17OTQ6MSw5MzoxLDU5OToxLDIwMzQ6MX0sV209MTExNDExMSxqbT17MzoxLDEyMjoxfSxaYj17MzoxLDQ6MSw1OjEsMzgxOjF9LGwsUWIsRTY7ZnVuY3Rpb24gTVllKGUsbil7dHlwZW9mIHdpbmRvdz09Im9iamVjdCImJnR5cGVvZiB3aW5kb3cuJGd3dD09Im9iamVjdCImJih3aW5kb3cuJGd3dFtlXT1uKX1mdW5jdGlvbiBSWWUoZSxuLHIsdCl7UmllKCk7dmFyIG89RTY7ZnVuY3Rpb24gaSgpe2Zvcih2YXIgcz0wO3M8by5sZW5ndGg7cysrKW9bc10oKX1pZihlKXRyeXtOWWUoaSkoKX1jYXRjaChzKXtlKG4scyl9ZWxzZSBOWWUoaSkoKX1mdW5jdGlvbiBSaWUoKXtFNj09bnVsbCYmKEU2PVtdKX1mdW5jdGlvbiBEWWUoKXtSaWUoKTtmb3IodmFyIGU9RTYsbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspZS5wdXNoKGFyZ3VtZW50c1tuXSl9ZnVuY3Rpb24gbmgoKXt9ZnVuY3Rpb24gdm8oZSl7dmFyIG47cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJmUudHlwZU1hcmtlcj09PW5oP3lfKHdhKGUpKSsiQCIrKG49dXIoZSk+Pj4wLG4udG9TdHJpbmcoMTYpKTplLnRvU3RyaW5nKCl9ZnVuY3Rpb24gRlllKGUpe2Z1bmN0aW9uIG4oKXt9cmV0dXJuIG4ucHJvdG90eXBlPWV8fHt9LG5ldyBufWZ1bmN0aW9uIERpZShlLG4scil7dmFyIHQ9ZnVuY3Rpb24oKXtyZXR1cm4gZS5hcHBseSh0LGFyZ3VtZW50cyl9O3JldHVybiBuLmFwcGx5KHQsciksdH1mdW5jdGlvbiBGKCl7fWZ1bmN0aW9uIHAoZSxuLHIpe3ZhciB0PVFiLG8saT10W2VdLHM9aSBpbnN0YW5jZW9mIEFycmF5P2lbMF06bnVsbDtpJiYhcz9sPWk6KGw9KG89biYmbi5wcm90b3R5cGUsIW8mJihvPVFiW25dKSxGWWUobykpLGwuY2FzdGFibGVUeXBlTWFwPXIsIW4mJihsLnR5cGVNYXJrZXI9bmgpLHRbZV09bCk7Zm9yKHZhciB1PTM7dTxhcmd1bWVudHMubGVuZ3RoOysrdSlhcmd1bWVudHNbdV0ucHJvdG90eXBlPWw7cyYmKGwuX19fY2xheno9cyl9Uy5nb29nPVMuZ29vZ3x8e30sUy5nb29nLmdsb2JhbD1TLmdvb2cuZ2xvYmFsfHxTLFFiPXt9O2Z1bmN0aW9uIEZpZShlLG4pe3JldHVybiBEKGUpPT09RChuKX1mdW5jdGlvbiB6aWUoKXt9ZnVuY3Rpb24gWW4oZSxuKXtyZXR1cm4gdXQoZSk/VGUoZSxuKTpxZChlKT9yY2UoZSxuKTpWZChlKT8oVmUoZSksRChlKT09PUQobikpOnR6KGUpP2UuZXF1YWxzXzAobik6UCQoZSk/RmllKGUsbik6ZiQoZSxuKX1mdW5jdGlvbiB3YShlKXtyZXR1cm4gdXQoZSk/c2U6cWQoZSk/JHI6VmQoZSk/QXI6dHooZSl8fFAkKGUpP2UuX19fY2xheno6ZS5fX19jbGF6enx8QXJyYXkuaXNBcnJheShlKSYmSShjdWUsMSl8fGN1ZX1mdW5jdGlvbiB1cihlKXtyZXR1cm4gdXQoZSk/TmMoZSk6cWQoZSk/Y2goZSk6VmQoZSk/WHVlKGUpOnR6KGUpP2UuaGFzaENvZGVfMSgpOlAkKGUpP1IxKGUpOnAkKGUpfXAoMSxudWxsLHt9LHppZSksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gRmllKHRoaXMsbil9LGwuZ2V0Q2xhc3NfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9fX2NsYXp6fSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gUjEodGhpcyl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB5Xyh3YSh0aGlzKSkrIkAiKyhuPXVyKHRoaXMpPj4+MCxuLnRvU3RyaW5nKDE2KSl9LGwuZXF1YWxzPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmVxdWFsc18wKGUpfSxsLmhhc2hDb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzaENvZGVfMSgpfSxsLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9TdHJpbmdfMCgpfTtmdW5jdGlvbiB2NihlLG4pe3JldHVybiB1dChlKT8hIVVpZVtuXTplLmNhc3RhYmxlVHlwZU1hcD8hIWUuY2FzdGFibGVUeXBlTWFwW25dOnFkKGUpPyEhSGllW25dOlZkKGUpPyEhR2llW25dOiExfWZ1bmN0aW9uIGEoZSxuKXtyZXR1cm4gaUUoZT09bnVsbHx8djYoZSxuKSksZX1mdW5jdGlvbiBtXyhlKXt2YXIgbjtyZXR1cm4gaUUoZT09bnVsbHx8QXJyYXkuaXNBcnJheShlKSYmKG49Z0MoZSksIShuPj0xNCYmbjw9MTYpKSksZX1mdW5jdGlvbiBpZShlKXtyZXR1cm4gaUUoZT09bnVsbHx8VmQoZSkpLGV9ZnVuY3Rpb24gJChlKXtyZXR1cm4gaUUoZT09bnVsbHx8cWQoZSkpLGV9ZnVuY3Rpb24gJGllKGUpe3JldHVybiBpRShlPT1udWxsfHxDNihlKSYmZS50eXBlTWFya2VyIT09bmgpLGV9ZnVuY3Rpb24geG4oZSl7cmV0dXJuIGlFKGU9PW51bGx8fHV0KGUpKSxlfWZ1bmN0aW9uIFM2KGUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfWZ1bmN0aW9uIHR6KGUpe3JldHVybiFBcnJheS5pc0FycmF5KGUpJiZlLnR5cGVNYXJrZXI9PT1uaH1mdW5jdGlvbiBMKGUsbil7cmV0dXJuIGUhPW51bGwmJnY2KGUsbil9ZnVuY3Rpb24gVmQoZSl7cmV0dXJuIHR5cGVvZiBlPT0iYm9vbGVhbiJ9ZnVuY3Rpb24gcWQoZSl7cmV0dXJuIHR5cGVvZiBlPT0ibnVtYmVyIn1mdW5jdGlvbiBCaWUoZSl7cmV0dXJuIGUhPW51bGwmJkM2KGUpJiZlLnR5cGVNYXJrZXIhPT1uaH1mdW5jdGlvbiB1dChlKXtyZXR1cm4gdHlwZW9mIGU9PSJzdHJpbmcifWZ1bmN0aW9uIEM2KGUpe3JldHVybiB0eXBlb2YgZT09Im9iamVjdCJ8fHR5cGVvZiBlPT0iZnVuY3Rpb24ifWZ1bmN0aW9uIEQoZSl7cmV0dXJuIGU/P251bGx9ZnVuY3Rpb24gS3IoZSl7cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGUscW4pLC0yMTQ3NDgzNjQ4KXwwfWZ1bmN0aW9uIGVJKGUpe3JldHVybiBpRShlPT1udWxsKSxlfXZhciBHaWUsSGllLFVpZTtmdW5jdGlvbiBKdShlKXtlLnR5cGVOYW1lPT1udWxsJiYkWWUoZSl9ZnVuY3Rpb24gaXMoZSl7cmV0dXJuIGUuZW51bUNvbnN0YW50c0Z1bmMmJmUuZW51bUNvbnN0YW50c0Z1bmMoKX1mdW5jdGlvbiB5XyhlKXtyZXR1cm4gSnUoZSksZS50eXBlTmFtZX1mdW5jdGlvbiBveihlKXtyZXR1cm4oZS5tb2RpZmllcnMmMj8iaW50ZXJmYWNlICI6ZS5tb2RpZmllcnMmMT8iIjoiY2xhc3MgIikrKEp1KGUpLGUudHlwZU5hbWUpfWZ1bmN0aW9uIGl6KCl7dGhpcy50eXBlTmFtZT1udWxsLHRoaXMuc2ltcGxlTmFtZT1udWxsLHRoaXMucGFja2FnZU5hbWU9bnVsbCx0aGlzLmNvbXBvdW5kTmFtZT1udWxsLHRoaXMuY2Fub25pY2FsTmFtZT1udWxsLHRoaXMudHlwZUlkPW51bGwsdGhpcy5hcnJheUxpdGVyYWxzPW51bGx9ZnVuY3Rpb24gVDYoZSxuKXt2YXIgcjtyZXR1cm4gcj1uZXcgaXosci5wYWNrYWdlTmFtZT1lLHIuY29tcG91bmROYW1lPW4scn1mdW5jdGlvbiBnKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1UNihlLG4pLGppZShyLHQpLHR9ZnVuY3Rpb24gY24oZSxuLHIsdCxvLGkpe3ZhciBzO3JldHVybiBzPVQ2KGUsbiksamllKHIscykscy5tb2RpZmllcnM9bz84OjAscy5lbnVtU3VwZXJjbGFzcz10LHMuZW51bUNvbnN0YW50c0Z1bmM9byxzLmVudW1WYWx1ZU9mRnVuYz1pLHN9ZnVuY3Rpb24gQ3IoZSxuKXt2YXIgcjtyZXR1cm4gcj1UNihlLG4pLHIubW9kaWZpZXJzPTIscn1mdW5jdGlvbiBWbShlLG4pe3ZhciByO3JldHVybiByPVQ2KCIiLGUpLHIudHlwZUlkPW4sci5tb2RpZmllcnM9MSxyfWZ1bmN0aW9uIFdpZShlLG4pe3ZhciByPWUuYXJyYXlMaXRlcmFscz1lLmFycmF5TGl0ZXJhbHN8fFtdO3JldHVybiByW25dfHwocltuXT1lLmNyZWF0ZUNsYXNzTGl0ZXJhbEZvckFycmF5KG4pKX1mdW5jdGlvbiB6WWUoZSl7aWYoZS5pc1ByaW1pdGl2ZSgpKXJldHVybiBudWxsO3ZhciBuPWUudHlwZUlkO3JldHVybiBRYltuXX1mdW5jdGlvbiAkWWUoZSl7aWYoZS5pc0FycmF5XzEoKSl7dmFyIG49ZS5jb21wb25lbnRUeXBlO24uaXNQcmltaXRpdmUoKT9lLnR5cGVOYW1lPSJbIituLnR5cGVJZDpuLmlzQXJyYXlfMSgpP2UudHlwZU5hbWU9IlsiK24uZ2V0TmFtZSgpOmUudHlwZU5hbWU9IltMIituLmdldE5hbWUoKSsiOyIsZS5jYW5vbmljYWxOYW1lPW4uZ2V0Q2Fub25pY2FsTmFtZSgpKyJbXSIsZS5zaW1wbGVOYW1lPW4uZ2V0U2ltcGxlTmFtZSgpKyJbXSI7cmV0dXJufXZhciByPWUucGFja2FnZU5hbWUsdD1lLmNvbXBvdW5kTmFtZTt0PXQuc3BsaXQoIi8iKSxlLnR5cGVOYW1lPWI2KCIuIixbcixiNigiJCIsdCldKSxlLmNhbm9uaWNhbE5hbWU9YjYoIi4iLFtyLGI2KCIuIix0KV0pLGUuc2ltcGxlTmFtZT10W3QubGVuZ3RoLTFdfWZ1bmN0aW9uIGI2KGUsbil7Zm9yKHZhciByPTA7IW5bcl18fG5bcl09PSIiOylyKys7Zm9yKHZhciB0PW5bcisrXTtyPG4ubGVuZ3RoO3IrKykhbltyXXx8bltyXT09IiJ8fCh0Kz1lK25bcl0pO3JldHVybiB0fWZ1bmN0aW9uIGppZShlLG4pe2lmKGUpe24udHlwZUlkPWU7dmFyIHI9elllKG4pO2lmKCFyKXtRYltlXT1bbl07cmV0dXJufXIuX19fY2xheno9bn19cCgyOTcsMSx7Mjk3OjEsMjEyNDoxfSxpeiksbC5jcmVhdGVDbGFzc0xpdGVyYWxGb3JBcnJheT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1uZXcgaXosci5tb2RpZmllcnM9NCxuPjE/ci5jb21wb25lbnRUeXBlPVdpZSh0aGlzLG4tMSk6ci5jb21wb25lbnRUeXBlPXRoaXMscn0sbC5nZXRDYW5vbmljYWxOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIEp1KHRoaXMpLHRoaXMuY2Fub25pY2FsTmFtZX0sbC5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHlfKHRoaXMpfSxsLmdldFNpbXBsZU5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gSnUodGhpcyksdGhpcy5zaW1wbGVOYW1lfSxsLmlzQXJyYXlfMT1mdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGlmaWVycyY0KSE9MH0sbC5pc1ByaW1pdGl2ZT1mdW5jdGlvbigpe3JldHVybih0aGlzLm1vZGlmaWVycyYxKSE9MH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIG96KHRoaXMpfSxsLm1vZGlmaWVycz0wO3ZhciBRcj1nKCJqYXZhLmxhbmciLCJPYmplY3QiLDEpLGF6PWcoImphdmEubGFuZyIsIkNsYXNzIiwyOTcpO3AoMjA5NiwxLFVTKSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5iYXNlIiwiT3B0aW9uYWwiLDIwOTYpO2Z1bmN0aW9uIHYyKCl7djI9RixJNj1uZXcgVmllfWZ1bmN0aW9uIFZpZSgpe31wKDExOTEsMjA5NixVUyxWaWUpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIG49PT10aGlzfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gMjA0MDczMjMzMn0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIk9wdGlvbmFsLmFic2VudCgpIn0sbC50cmFuc2Zvcm09ZnVuY3Rpb24obil7cmV0dXJuIHZuKG4pLHYyKCksSTZ9O3ZhciBJNjtnKCJjb20uZ29vZ2xlLmNvbW1vbi5iYXNlIiwiQWJzZW50IiwxMTkxKTtmdW5jdGlvbiBCWWUoZSxuLHIpe2lmKHZuKG4pLHIuaGFzTmV4dF8wKCkpZm9yKGRCKG4scWllKHIubmV4dF8xKCkpKTtyLmhhc05leHRfMCgpOylkQihuLGUuc2VwYXJhdG9yKSxkQihuLHFpZShyLm5leHRfMSgpKSk7cmV0dXJuIG59ZnVuY3Rpb24gR1llKGUsbixyKXt2YXIgdDt0cnl7QlllKGUsbixyKX1jYXRjaChvKXt0aHJvdyBvPXdyKG8pLEwobyw2MDYpPyh0PW8sYihuZXcgQiQodCkpKTpiKG8pfXJldHVybiBufWZ1bmN0aW9uIGx6KGUsbil7cmV0dXJuIEdZZShlLG5ldyBDMCxuKS5zdHJpbmd9ZnVuY3Rpb24gcWllKGUpe3JldHVybiB3bChlKSxMKGUsNDg0KT9hKGUsNDg0KTp2byhlKX1mdW5jdGlvbiB4Nigpe3RoaXMuc2VwYXJhdG9yPXhuKHZuKCIsICIpKX1wKDYzNiwxLHt9LHg2KSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5iYXNlIiwiSm9pbmVyIiw2MzYpO2Z1bmN0aW9uIG51KGUsbil7cmV0dXJuIEQoZSk9PT1EKG4pfHxlIT1udWxsJiZZbihlLG4pfWZ1bmN0aW9uIEhZZShlLG4pe2lmKGU8MClyZXR1cm4gUzIoIiVzICglcykgbXVzdCBub3QgYmUgbmVnYXRpdmUiLFAoSShRciwxKSxNZSwxLDUsWyJpbmRleCIsSihlKV0pKTtpZihuPDApdGhyb3cgYihuZXcgR2UoIm5lZ2F0aXZlIHNpemU6ICIrbikpO3JldHVybiBTMigiJXMgKCVzKSBtdXN0IGJlIGxlc3MgdGhhbiBzaXplICglcykiLFAoSShRciwxKSxNZSwxLDUsWyJpbmRleCIsSihlKSxKKG4pXSkpfWZ1bmN0aW9uIHN6KGUsbixyKXtpZihlPDApcmV0dXJuIFMyKCIlcyAoJXMpIG11c3Qgbm90IGJlIG5lZ2F0aXZlIixQKEkoUXIsMSksTWUsMSw1LFtyLEooZSldKSk7aWYobjwwKXRocm93IGIobmV3IEdlKCJuZWdhdGl2ZSBzaXplOiAiK24pKTtyZXR1cm4gUzIoIiVzICglcykgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIHNpemUgKCVzKSIsUChJKFFyLDEpLE1lLDEsNSxbcixKKGUpLEoobildKSl9ZnVuY3Rpb24gVVllKGUsbixyKXtyZXR1cm4gZTwwfHxlPnI/c3ooZSxyLCJzdGFydCBpbmRleCIpOm48MHx8bj5yP3N6KG4sciwiZW5kIGluZGV4Iik6UzIoImVuZCBpbmRleCAoJXMpIG11c3Qgbm90IGJlIGxlc3MgdGhhbiBzdGFydCBpbmRleCAoJXMpIixQKEkoUXIsMSksTWUsMSw1LFtKKG4pLEooZSldKSl9ZnVuY3Rpb24gdXooZSl7aWYoIWUpdGhyb3cgYihuZXcgVEMpfWZ1bmN0aW9uIGN6KGUsbil7aWYoIWUpdGhyb3cgYihuZXcgR2UobikpfWZ1bmN0aW9uIFlpZShlLG4pe2lmKCFlKXRocm93IGIobmV3IEdlKFMyKCJ2YWx1ZSBhbHJlYWR5IHByZXNlbnQ6ICVzIixQKEkoUXIsMSksTWUsMSw1LFtuXSkpKSl9ZnVuY3Rpb24gS2llKGUsbixyLHQpe2lmKCFlKXRocm93IGIobmV3IEdlKFMyKG4sUChJKFFyLDEpLE1lLDEsNSxbcix0XSkpKSl9ZnVuY3Rpb24gZUMoZSxuKXtpZihlPDB8fGU+PW4pdGhyb3cgYihuZXcgbm8oSFllKGUsbikpKTtyZXR1cm4gZX1mdW5jdGlvbiB2bihlKXtpZihlPT1udWxsKXRocm93IGIobmV3IF9oKTtyZXR1cm4gZX1mdW5jdGlvbiBuSShlLG4pe2lmKGU9PW51bGwpdGhyb3cgYihuZXcgZGgobikpO3JldHVybiBlfWZ1bmN0aW9uIF96KGUsbil7aWYoZTwwfHxlPm4pdGhyb3cgYihuZXcgbm8oc3ooZSxuLCJpbmRleCIpKSk7cmV0dXJuIGV9ZnVuY3Rpb24gWGllKGUsbixyKXtpZihlPDB8fG48ZXx8bj5yKXRocm93IGIobmV3IG5vKFVZZShlLG4scikpKX1mdW5jdGlvbiBkeihlKXtpZighZSl0aHJvdyBiKG5ldyB6aSl9ZnVuY3Rpb24gcW0oZSl7aWYoIWUpdGhyb3cgYihuZXcgcm8oIm5vIGNhbGxzIHRvIG5leHQoKSBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHJlbW92ZSgpIikpfXZhciBXWWU9Q3IoImNvbS5nb29nbGUuY29tbW9uLmJhc2UiLCJQcmVkaWNhdGUiKTtmdW5jdGlvbiBqWWUoZSl7dmFyIG4scix0LG87Zm9yKG49eF8oT24obmV3IExhKCJQcmVkaWNhdGVzLiIpLCJhbmQiKSw0MCkscj0hMCxvPW5ldyBxMihlKTtvLmk8by50aGlzJDAxXzAuc2l6ZV8xKCk7KXQ9KHJuKG8uaTxvLnRoaXMkMDFfMC5zaXplXzEoKSksby50aGlzJDAxXzAuZ2V0XzAoby5sYXN0PW8uaSsrKSkscnx8KG4uc3RyaW5nKz0iLCIpLG4uc3RyaW5nKz0iIit0LHI9ITE7cmV0dXJuKG4uc3RyaW5nKz0iKSIsbikuc3RyaW5nfWZ1bmN0aW9uIEppZShlLG4pe3ZhciByO2ZvcihyPTA7cjxlLmNvbXBvbmVudHMuYXJyYXkubGVuZ3RoO3IrKylpZighYShpMGUoZS5jb21wb25lbnRzLHIpLDE3OCkuYXBwbHlfMShuKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBaaWUoZSl7dGhpcy5jb21wb25lbnRzPWV9cCg1ODksMSx7MTc4OjEsNTg5OjEsMzoxLDQ2OjF9LFppZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEppZSh0aGlzLG4pfSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIEppZSh0aGlzLG4pfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sNTg5KT8ocj1hKG4sNTg5KSxxeih0aGlzLmNvbXBvbmVudHMsci5jb21wb25lbnRzKSk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBHQih0aGlzLmNvbXBvbmVudHMpKzMwNjY1NDI1Mn0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIGpZZSh0aGlzLmNvbXBvbmVudHMpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5iYXNlIiwiUHJlZGljYXRlcy9BbmRQcmVkaWNhdGUiLDU4OSk7ZnVuY3Rpb24gckkoZSl7dGhpcy5yZWZlcmVuY2U9ZX1wKDQxOSwyMDk2LHs0MTk6MSwzOjF9LHJJKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sNDE5KT8ocj1hKG4sNDE5KSxZbih0aGlzLnJlZmVyZW5jZSxyLnJlZmVyZW5jZSkpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gMTUwMjQ3NjU3Mit1cih0aGlzLnJlZmVyZW5jZSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJPcHRpb25hbC5vZigiK3RoaXMucmVmZXJlbmNlKyIpIn0sbC50cmFuc2Zvcm09ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBySShuSShuLmFwcGx5XzAodGhpcy5yZWZlcmVuY2UpLCJ0aGUgRnVuY3Rpb24gcGFzc2VkIHRvIE9wdGlvbmFsLnRyYW5zZm9ybSgpIG11c3Qgbm90IHJldHVybiBudWxsLiIpKX0sZygiY29tLmdvb2dsZS5jb21tb24uYmFzZSIsIlByZXNlbnQiLDQxOSk7ZnVuY3Rpb24gUzIoZSxuKXt2YXIgcix0LG8saSxzO2ZvcihlPWU9PW51bGw/Im51bGwiOihWZShlKSxlKSxvPTA7bzxuLmxlbmd0aDtvKyspbltvXT1WWWUobltvXSk7Zm9yKHI9bmV3IGZoLHM9MCx0PTA7dDxuLmxlbmd0aCYmKGk9ZS5pbmRleE9mKCIlcyIscyksaSE9LTEpOylyLnN0cmluZys9IiIrWWEoZT09bnVsbD8ibnVsbCI6KFZlKGUpLGUpLHMsaSksZWkocixuW3QrK10pLHM9aSsyO2lmKHljZShyLGUscyxlLmxlbmd0aCksdDxuLmxlbmd0aCl7Zm9yKHIuc3RyaW5nKz0iIFsiLGVpKHIsblt0KytdKTt0PG4ubGVuZ3RoOylyLnN0cmluZys9IiwgIixlaShyLG5bdCsrXSk7ci5zdHJpbmcrPSJdIn1yZXR1cm4gci5zdHJpbmd9ZnVuY3Rpb24gVlllKGUpe3ZhciBuLHIsdDtpZihlPT1udWxsKXJldHVybiJudWxsIjt0cnl7cmV0dXJuIHZvKGUpfWNhdGNoKG8pe2lmKG89d3IobyksTChvLDEwMykpcmV0dXJuIG49byx0PXlfKHdhKGUpKSsiQCIrKHI9KG5jKCksWkcoZSk+Pj4wKSxyLnRvU3RyaW5nKDE2KSksZWVuKHRlbigpLChJeSgpLCJFeGNlcHRpb24gZHVyaW5nIGxlbmllbnRGb3JtYXQgZm9yICIrdCksbiksIjwiK3QrIiB0aHJldyAiK3lfKG4uX19fY2xhenopKyI+Ijt0aHJvdyBiKG8pfX1mdW5jdGlvbiB3dChlLG4pe2ZvcihWZShuKTtlLmhhc05leHRfMCgpOyluLmFjY2VwdChlLm5leHRfMSgpKX1mdW5jdGlvbiBRaWUoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gZWFlKCl7dGhyb3cgYihuZXcgVG4pfXAoMjA0LDEsem0pLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLnJlbW92ZT1mdW5jdGlvbigpe2VhZSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiVW5tb2RpZmlhYmxlSXRlcmF0b3IiLDIwNCkscCgyMDc2LDIwNCwkbSksbC5yZW1vdmU9ZnVuY3Rpb24oKXtlYWUoKX0sbC5hZGRfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuc2V0XzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiVW5tb2RpZmlhYmxlTGlzdEl0ZXJhdG9yIiwyMDc2KTtmdW5jdGlvbiBQNihlKXtmei5jYWxsKHRoaXMsZSwwKX1mdW5jdGlvbiBmeihlLG4pe196KG4sZSksdGhpcy5zaXplXzA9ZSx0aGlzLnBvc2l0aW9uPW59cCgzOTksMjA3NiwkbSksbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbjx0aGlzLnNpemVfMH0sbC5oYXNQcmV2aW91cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uPjB9LGwubmV4dF8xPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbj49dGhpcy5zaXplXzApdGhyb3cgYihuZXcgUG8pO3JldHVybiB0aGlzLmdldF8wKHRoaXMucG9zaXRpb24rKyl9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbn0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbjw9MCl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIHRoaXMuZ2V0XzAoLS10aGlzLnBvc2l0aW9uKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb24tMX0sbC5wb3NpdGlvbj0wLGwuc2l6ZV8wPTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0SW5kZXhlZExpc3RJdGVyYXRvciIsMzk5KTtmdW5jdGlvbiBONihlKXtzd2l0Y2goZHooZS5zdGF0ZSE9MyksZS5zdGF0ZSl7Y2FzZSAyOnJldHVybiExO2Nhc2UgMDpyZXR1cm4hMH1yZXR1cm4gcVllKGUpfWZ1bmN0aW9uIHB6KGUpe3ZhciBuO2lmKCFONihlKSl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIGUuc3RhdGU9MSxuPWUubmV4dF8wLGUubmV4dF8wPW51bGwsbn1mdW5jdGlvbiBxWWUoZSl7cmV0dXJuIGUuc3RhdGU9MyxlLm5leHRfMD1lLmNvbXB1dGVOZXh0KCksZS5zdGF0ZSE9Mj8oZS5zdGF0ZT0wLCEwKTohMX1wKDcxMywyMDQsem0pLGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIE42KHRoaXMpfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBweih0aGlzKX0sbC5zdGF0ZT0xLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdEl0ZXJhdG9yIiw3MTMpO2Z1bmN0aW9uIFlZZShlLG4scil7dmFyIHQ7cmV0dXJuIHQ9YShlLmFzTWFwXzAoKS5nZXRfMyhuKSwxNiksISF0JiZ0LmNvbnRhaW5zKHIpfWZ1bmN0aW9uIEtZZShlLG4pe3ZhciByLHQ7Zm9yKHQ9ZS5hc01hcF8wKCkudmFsdWVzXzAoKS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspaWYocj1hKHQubmV4dF8xKCksMTYpLHIuY29udGFpbnMobikpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcmgoZSl7dmFyIG47cmV0dXJuIG49ZS5rZXlTZXQsbnx8KGUua2V5U2V0PWUuY3JlYXRlS2V5U2V0KCkpfWZ1bmN0aW9uIEE2KGUpe3ZhciBuO3JldHVybiBuPWUua2V5c18wLG58fChlLmtleXNfMD1uZXcgUnNlKGUpKX1mdW5jdGlvbiBuYWUoZSxuLHIpe3ZhciB0O3JldHVybiB0PWEoZS5hc01hcF8wKCkuZ2V0XzMobiksMTYpLCEhdCYmdC5yZW1vdmVfMShyKX1wKDIwODQsMSx7MjI5OjF9KSxsLmFzTWFwXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmFzTWFwLG58fCh0aGlzLmFzTWFwPXRoaXMuY3JlYXRlQXNNYXAoKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIF81KHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiB1cih0aGlzLmFzTWFwXzAoKSl9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVfMSgpPT0wfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHJoKHRoaXMpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdm8odGhpcy5hc01hcF8wKCkpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNdWx0aW1hcCIsMjA4NCk7ZnVuY3Rpb24gdEkoZSl7dmFyIG4scjtmb3Iocj1lLm1hcF8wLnZhbHVlc18wKCkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49YShyLm5leHRfMSgpLDE2KSxuLmNsZWFyXzAoKTtlLm1hcF8wLmNsZWFyXzAoKSxlLnRvdGFsU2l6ZT0wfWZ1bmN0aW9uIHJhZShlLG4pe3JldHVybiBlLm1hcF8wLmNvbnRhaW5zS2V5KG4pfWZ1bmN0aW9uIEMyKGUpe3ZhciBuO3JldHVybiBuPWUuZW50cmllc18wLG58fChlLmVudHJpZXNfMD1uZXcgYnooZSkpfWZ1bmN0aW9uIFpuKGUsbil7dmFyIHI7cmV0dXJuIHI9YShlLm1hcF8wLmdldF8zKG4pLDE2KSwhciYmKHI9ZS5jcmVhdGVDb2xsZWN0aW9uXzAobikpLGUud3JhcENvbGxlY3Rpb24obixyKX1mdW5jdGlvbiBiZShlLG4scil7dmFyIHQ7aWYodD1hKGUubWFwXzAuZ2V0XzMobiksMTYpLHQpcmV0dXJuIHQuYWRkXzIocik/KCsrZS50b3RhbFNpemUsITApOiExO2lmKHQ9ZS5jcmVhdGVDb2xsZWN0aW9uXzAobiksdC5hZGRfMihyKSlyZXR1cm4rK2UudG90YWxTaXplLGUubWFwXzAucHV0KG4sdCksITA7dGhyb3cgYihuZXcgQiQoIk5ldyBDb2xsZWN0aW9uIHZpb2xhdGVkIHRoZSBDb2xsZWN0aW9uIHNwZWMiKSl9ZnVuY3Rpb24gbkMoZSxuKXt2YXIgcix0O3JldHVybiByPWEoZS5tYXBfMC5yZW1vdmVfMChuKSwxNikscj8odD1lLmNyZWF0ZUNvbGxlY3Rpb24oKSx0LmFkZEFsbChyKSxlLnRvdGFsU2l6ZS09ci5zaXplXzEoKSxyLmNsZWFyXzAoKSxlLnVubW9kaWZpYWJsZUNvbGxlY3Rpb25TdWJjbGFzcyh0KSk6ZS5jcmVhdGVVbm1vZGlmaWFibGVFbXB0eUNvbGxlY3Rpb24oKX1mdW5jdGlvbiBYWWUoZSxuKXt2YXIgcix0O3I9YShzWGUoZS5tYXBfMCxuKSwxNiksciYmKHQ9ci5zaXplXzEoKSxyLmNsZWFyXzAoKSxlLnRvdGFsU2l6ZS09dCl9ZnVuY3Rpb24gb0koZSl7dmFyIG47cmV0dXJuIG49ZS52YWx1ZXMsbnx8KGUudmFsdWVzPW5ldyB4eihlKSl9ZnVuY3Rpb24gdGFlKGUsbixyLHQpe3JldHVybiBMKHIsNTkpP25ldyB3YWUoZSxuLHIsdCk6bmV3IFN6KGUsbixyLHQpfWZ1bmN0aW9uIG9hZShlKXt1eihlLmlzRW1wdHkoKSksdGhpcy5tYXBfMD1lfWZ1bmN0aW9uIEpZZShlKXtyZXR1cm4gTChlLDE1KT9hKGUsMTUpLmxpc3RJdGVyYXRvcl8wKCk6ZS5pdGVyYXRvcl8wKCl9ZnVuY3Rpb24gWlllKGUpe3ZhciBuLHI7cmV0dXJuIG49ZS5nZXRLZXkoKSxyPWEoZS5nZXRWYWx1ZSgpLDE2KSxhQyhyLnNwbGl0ZXJhdG9yXzAoKSxuZXcgeGFlKG4pKX1wKDc0MiwyMDg0LGZfKSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0SSh0aGlzKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gcmFlKHRoaXMsbil9LGwuY3JlYXRlQXNNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFltKHRoaXMsdGhpcy5tYXBfMCl9LGwuY3JlYXRlQ29sbGVjdGlvbl8wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNyZWF0ZUNvbGxlY3Rpb24oKX0sbC5jcmVhdGVLZXlTZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNwKHRoaXMsdGhpcy5tYXBfMCl9LGwuY3JlYXRlVW5tb2RpZmlhYmxlRW1wdHlDb2xsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5tb2RpZmlhYmxlQ29sbGVjdGlvblN1YmNsYXNzKHRoaXMuY3JlYXRlQ29sbGVjdGlvbigpKX0sbC5lbnRyeUl0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBzYWUodGhpcyl9LGwuZW50cnlTcGxpdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBGNih0aGlzLm1hcF8wLmVudHJ5U2V0XzAoKS5zcGxpdGVyYXRvcl8wKCksbmV3IElhZSw2NCx0aGlzLnRvdGFsU2l6ZSl9LGwuZ2V0XzE9ZnVuY3Rpb24obil7cmV0dXJuIFpuKHRoaXMsbil9LGwucmVtb3ZlQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBuQyh0aGlzLG4pfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvdGFsU2l6ZX0sbC51bm1vZGlmaWFibGVDb2xsZWN0aW9uU3ViY2xhc3M9ZnVuY3Rpb24obil7cmV0dXJuIE5lKCksbmV3IHB5KG4pfSxsLnZhbHVlSXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgYWFlKHRoaXMpfSxsLnZhbHVlU3BsaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gRjYodGhpcy5tYXBfMC52YWx1ZXNfMCgpLnNwbGl0ZXJhdG9yXzAoKSxuZXcgbGFlLDY0LHRoaXMudG90YWxTaXplKX0sbC53cmFwQ29sbGVjdGlvbj1mdW5jdGlvbihuLHIpe3JldHVybiBuZXcgbEkodGhpcyxuLHIsbnVsbCl9LGwudG90YWxTaXplPTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcCIsNzQyKTtmdW5jdGlvbiB0aChlKXt2YXIgbjtyZXR1cm4gbj1lLmFzTWFwLG58fChlLmFzTWFwPW5ldyBZbShlLGUubWFwXzApKX1wKDE2OTYsNzQyLGZfKSxsLmNyZWF0ZUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF9pKHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXkpfSxsLmNyZWF0ZVVubW9kaWZpYWJsZUVtcHR5Q29sbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiBOZSgpLE5lKCksT3R9LGwuZ2V0XzE9ZnVuY3Rpb24obil7cmV0dXJuIGEoWm4odGhpcyxuKSwxNSl9LGwucmVtb3ZlQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBhKG5DKHRoaXMsbiksMTUpfSxsLmFzTWFwXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGgodGhpcyl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIF81KHRoaXMsbil9LGwuZ2V0XzI9ZnVuY3Rpb24obil7cmV0dXJuIGEoWm4odGhpcyxuKSwxNSl9LGwucmVtb3ZlQWxsXzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobkModGhpcyxuKSwxNSl9LGwudW5tb2RpZmlhYmxlQ29sbGVjdGlvblN1YmNsYXNzPWZ1bmN0aW9uKG4pe3JldHVybiBKNShhKG4sMTUpKX0sbC53cmFwQ29sbGVjdGlvbj1mdW5jdGlvbihuLHIpe3JldHVybiB0YWUodGhpcyxuLGEociwxNSksbnVsbCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdExpc3RNdWx0aW1hcCIsMTY5Nik7ZnVuY3Rpb24gaWFlKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMua2V5SXRlcmF0b3I9ZS5tYXBfMC5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLHRoaXMua2V5PW51bGwsdGhpcy5jb2xsZWN0aW9uPW51bGwsdGhpcy52YWx1ZUl0ZXJhdG9yPSh5SSgpLGw1KX1wKDc0OCwxLHN0KSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXlJdGVyYXRvci5oYXNOZXh0XzAoKXx8dGhpcy52YWx1ZUl0ZXJhdG9yLmhhc05leHRfMCgpfSxsLm5leHRfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLnZhbHVlSXRlcmF0b3IuaGFzTmV4dF8wKCl8fChuPWEodGhpcy5rZXlJdGVyYXRvci5uZXh0XzEoKSw0NCksdGhpcy5rZXk9bi5nZXRLZXkoKSx0aGlzLmNvbGxlY3Rpb249YShuLmdldFZhbHVlKCksMTYpLHRoaXMudmFsdWVJdGVyYXRvcj10aGlzLmNvbGxlY3Rpb24uaXRlcmF0b3JfMCgpKSx0aGlzLm91dHB1dCh0aGlzLmtleSx0aGlzLnZhbHVlSXRlcmF0b3IubmV4dF8xKCkpfSxsLnJlbW92ZT1mdW5jdGlvbigpe3RoaXMudmFsdWVJdGVyYXRvci5yZW1vdmUoKSxhKHdsKHRoaXMuY29sbGVjdGlvbiksMTYpLmlzRW1wdHkoKSYmdGhpcy5rZXlJdGVyYXRvci5yZW1vdmUoKSwtLXRoaXMudGhpcyQwMS50b3RhbFNpemV9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvSXRyIiw3NDgpO2Z1bmN0aW9uIGFhZShlKXtpYWUuY2FsbCh0aGlzLGUpfXAoMTEyOSw3NDgsc3QsYWFlKSxsLm91dHB1dD1mdW5jdGlvbihuLHIpe3JldHVybiByfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwLzEiLDExMjkpO2Z1bmN0aW9uIGxhZSgpe31wKDExMzAsMSx7fSxsYWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDE2KS5zcGxpdGVyYXRvcl8wKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvMW1ldGhvZHJlZiRzcGxpdGVyYXRvciRUeXBlIiwxMTMwKTtmdW5jdGlvbiBzYWUoZSl7aWFlLmNhbGwodGhpcyxlKX1wKDExMzEsNzQ4LHN0LHNhZSksbC5vdXRwdXQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gbmV3IHcxKG4scil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvMiIsMTEzMSk7ZnVuY3Rpb24gVDIoZSxuKXt2YXIgcix0O2ZvcihWZShuKSx0PWUuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSw0NCksbi5hY2NlcHRfMShyLmdldEtleSgpLHIuZ2V0VmFsdWUoKSl9ZnVuY3Rpb24gTDYoZSxuLHIsdCl7dmFyIG8saTtyZXR1cm4gVmUodCksVmUociksbz1lLmdldF8zKG4pLGk9bz09bnVsbD9yOkMxZShhKG8sMTUpLGEociwxNikpLGk9PW51bGw/ZS5yZW1vdmVfMChuKTplLnB1dChuLGkpLGl9dmFyIGd6PUNyKCJqYXZhLnV0aWwiLCJNYXAiKTtmdW5jdGlvbiBrNihlLG4pe3ZhciByLHQsbztyZXR1cm4gcj1uLmdldEtleSgpLG89bi5nZXRWYWx1ZSgpLHQ9ZS5nZXRfMyhyKSwhKCEoRChvKT09PUQodCl8fG8hPW51bGwmJlluKG8sdCkpfHx0PT1udWxsJiYhZS5jb250YWluc0tleShyKSl9ZnVuY3Rpb24gaHooZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1lLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspaWYodD1hKG8ubmV4dF8xKCksNDQpLGk9dC5nZXRLZXkoKSxEKG4pPT09RChpKXx8biE9bnVsbCYmWW4obixpKSlyZXR1cm4gciYmKHQ9bmV3IFhJKHQuZ2V0S2V5KCksdC5nZXRWYWx1ZSgpKSxvLnJlbW92ZSgpKSx0O3JldHVybiBudWxsfWZ1bmN0aW9uIGIyKGUsbil7dmFyIHIsdDtmb3IoVmUobiksdD1uLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksNDQpLGUucHV0KHIuZ2V0S2V5KCksci5nZXRWYWx1ZSgpKX1mdW5jdGlvbiB1YWUoZSl7dmFyIG4scix0O2Zvcih0PW5ldyBPXygiLCAiLCJ7IiwifSIpLHI9ZS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49YShyLm5leHRfMSgpLDQ0KSxvYyh0LGNhZShlLG4uZ2V0S2V5KCkpKyI9IitjYWUoZSxuLmdldFZhbHVlKCkpKTtyZXR1cm4gdC5idWlsZGVyP3Quc3VmZml4Lmxlbmd0aD09MD90LmJ1aWxkZXIuc3RyaW5nOnQuYnVpbGRlci5zdHJpbmcrKCIiK3Quc3VmZml4KTp0LmVtcHR5VmFsdWV9ZnVuY3Rpb24gY2FlKGUsbil7cmV0dXJuIEQobik9PT1EKGUpPyIodGhpcyBNYXApIjpuPT1udWxsPyJudWxsIjp2byhuKX1mdW5jdGlvbiBPNihlKXtyZXR1cm4gZT9lLmtleTpudWxsfWZ1bmN0aW9uIF9vKGUpe3JldHVybiBlP2UuZ2V0VmFsdWUoKTpudWxsfXAoMjA2NSwxLGgxKSxsLmZvckVhY2g9ZnVuY3Rpb24obil7VDIodGhpcyxuKX0sbC5tZXJnZT1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIEw2KHRoaXMsbixyLHQpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLmVudHJ5U2V0XzAoKS5jbGVhcl8wKCl9LGwuY29udGFpbnNFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gazYodGhpcyxuKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4hIWh6KHRoaXMsbiwhMSl9LGwuY29udGFpbnNWYWx1ZT1mdW5jdGlvbihuKXt2YXIgcix0LG87Zm9yKHQ9dGhpcy5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9YSh0Lm5leHRfMSgpLDQ0KSxvPXIuZ2V0VmFsdWUoKSxEKG4pPT09RChvKXx8biE9bnVsbCYmWW4obixvKSlyZXR1cm4hMDtyZXR1cm4hMX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcix0LG87aWYobj09PXRoaXMpcmV0dXJuITA7aWYoIUwobiw4NSl8fChvPWEobiw4NSksdGhpcy5zaXplXzEoKSE9by5zaXplXzEoKSkpcmV0dXJuITE7Zm9yKHQ9by5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9YSh0Lm5leHRfMSgpLDQ0KSwhdGhpcy5jb250YWluc0VudHJ5KHIpKXJldHVybiExO3JldHVybiEwfSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiBfbyhoeih0aGlzLG4sITEpKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIEJCKHRoaXMuZW50cnlTZXRfMCgpKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8xKCk9PTB9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGtfKHRoaXMpfSxsLnB1dD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IGtjKCJQdXQgbm90IHN1cHBvcnRlZCBvbiB0aGlzIG1hcCIpKX0sbC5wdXRBbGw9ZnVuY3Rpb24obil7YjIodGhpcyxuKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXtyZXR1cm4gX28oaHoodGhpcyxuLCEwKSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cnlTZXRfMCgpLnNpemVfMSgpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdWFlKHRoaXMpfSxsLnZhbHVlc18wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB0Yyh0aGlzKX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3RNYXAiLDIwNjUpO2Z1bmN0aW9uIF9hZShlKXt2YXIgbjtyZXR1cm4gbj1lLmVudHJ5U2V0LG58fChlLmVudHJ5U2V0PWUuY3JlYXRlRW50cnlTZXQoKSl9cCgyMDg1LDIwNjUsaDEpLGwuY3JlYXRlS2V5U2V0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBpSSh0aGlzKX0sbC5lbnRyeVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIF9hZSh0aGlzKX0sbC5rZXlTZXRfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMua2V5U2V0LG58fCh0aGlzLmtleVNldD10aGlzLmNyZWF0ZUtleVNldCgpKX0sbC52YWx1ZXNfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMudmFsdWVzLG58fCh0aGlzLnZhbHVlcz1uZXcgUHNlKHRoaXMpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk1hcHMvVmlld0NhY2hpbmdBYnN0cmFjdE1hcCIsMjA4NSk7ZnVuY3Rpb24gUVllKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKFhkKGUuc3VibWFwLG4pLDE2KSxyPyh0PW4sZS50aGlzJDAxXzEud3JhcENvbGxlY3Rpb24odCxyKSk6bnVsbH1mdW5jdGlvbiBlS2UoZSxuKXt2YXIgcix0O3JldHVybiByPWEoZS5zdWJtYXAucmVtb3ZlXzAobiksMTYpLHI/KHQ9ZS50aGlzJDAxXzEuY3JlYXRlQ29sbGVjdGlvbigpLHQuYWRkQWxsKHIpLGUudGhpcyQwMV8xLnRvdGFsU2l6ZS09ci5zaXplXzEoKSxyLmNsZWFyXzAoKSx0KTpudWxsfWZ1bmN0aW9uIGRhZShlLG4pe3ZhciByO3JldHVybiByPW4uZ2V0S2V5KCksbmV3IHcxKHIsZS50aGlzJDAxXzEud3JhcENvbGxlY3Rpb24ocixhKG4uZ2V0VmFsdWUoKSwxNikpKX1mdW5jdGlvbiBZbShlLG4pe3RoaXMudGhpcyQwMV8xPWUsdGhpcy5zdWJtYXA9bn1wKDQwMiwyMDg1LGgxLFltKSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiBRWWUodGhpcyxuKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXtyZXR1cm4gZUtlKHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe3RoaXMuc3VibWFwPT10aGlzLnRoaXMkMDFfMS5tYXBfMD90aGlzLnRoaXMkMDFfMS5jbGVhcl8wKCk6Z0kobmV3IEV6KHRoaXMpKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gVHNlKHRoaXMuc3VibWFwLG4pfSxsLmNyZWF0ZUVudHJ5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGhhZSh0aGlzKX0sbC5jcmVhdGVFbnRyeVNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZUVudHJ5U2V0XzAoKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW58fFluKHRoaXMuc3VibWFwLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdXIodGhpcy5zdWJtYXApfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMV8xLmtleVNldF8wKCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3VibWFwLnNpemVfMSgpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdm8odGhpcy5zdWJtYXApfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL0FzTWFwIiw0MDIpO2Z1bmN0aW9uIEV0KGUsbil7dmFyIHIsdDtmb3IoVmUobiksdD1lLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPXQubmV4dF8xKCksbi5hY2NlcHQocil9dmFyIHhhPUNyKCJqYXZhLmxhbmciLCJJdGVyYWJsZSIpO2Z1bmN0aW9uIGZ0KGUsbil7dmFyIHIsdCxvO2ZvcihWZShuKSxyPSExLG89bi5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1vLm5leHRfMSgpLHI9cnxlLmFkZF8yKHQpO3JldHVybiByfWZ1bmN0aW9uIFlkKGUsbixyKXt2YXIgdCxvO2ZvcihvPWUuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KWlmKHQ9by5uZXh0XzEoKSxEKG4pPT09RCh0KXx8biE9bnVsbCYmWW4obix0KSlyZXR1cm4gciYmby5yZW1vdmUoKSwhMDtyZXR1cm4hMX1mdW5jdGlvbiBteihlKXt2YXIgbjtmb3Iobj1lLml0ZXJhdG9yXzAoKTtuLmhhc05leHRfMCgpOyluLm5leHRfMSgpLG4ucmVtb3ZlKCl9ZnVuY3Rpb24gckMoZSxuKXt2YXIgcix0O2ZvcihWZShuKSx0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9dC5uZXh0XzEoKSwhZS5jb250YWlucyhyKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB5eihlLG4pe3ZhciByLHQsbztmb3IoVmUobikscj0hMSx0PW5ldyBUKGUpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPUModCksbi5jb250YWlucyhvKSYmKEoyKHQpLHI9ITApO3JldHVybiByfWZ1bmN0aW9uIHd6KGUpe3JldHVybiBlLnRvQXJyYXlfMChCKFFyLE1lLDEsZS5zaXplXzEoKSw1LDEpKX1mdW5jdGlvbiBJMihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPWUuc2l6ZV8xKCksbi5sZW5ndGg8aSYmKG49U3gobmV3IEFycmF5KGkpLG4pKSxvPW4sdD1lLml0ZXJhdG9yXzAoKSxyPTA7cjxpOysrcilUcihvLHIsdC5uZXh0XzEoKSk7cmV0dXJuIG4ubGVuZ3RoPmkmJlRyKG4saSxudWxsKSxufWZ1bmN0aW9uIG0wKGUpe3ZhciBuLHIsdDtmb3IodD1uZXcgT18oIiwgIiwiWyIsIl0iKSxyPWUuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49ci5uZXh0XzEoKSxvYyh0LEQobik9PT1EKGUpPyIodGhpcyBDb2xsZWN0aW9uKSI6bj09bnVsbD8ibnVsbCI6dm8obikpO3JldHVybiB0LmJ1aWxkZXI/dC5zdWZmaXgubGVuZ3RoPT0wP3QuYnVpbGRlci5zdHJpbmc6dC5idWlsZGVyLnN0cmluZysoIiIrdC5zdWZmaXgpOnQuZW1wdHlWYWx1ZX1wKDMxLDEsR2QpLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe0V0KHRoaXMsbil9LGwucGFyYWxsZWxTdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJlYW0oKX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB4ZSh0aGlzLDApfSxsLnN0cmVhbT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2UobnVsbCx0aGlzLnNwbGl0ZXJhdG9yXzAoKSl9LGwuYWRkXzI9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcga2MoIkFkZCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgY29sbGVjdGlvbiIpKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7cmV0dXJuIGZ0KHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe216KHRoaXMpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBZZCh0aGlzLG4sITEpfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiByQyh0aGlzLG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzEoKT09MH0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gWWQodGhpcyxuLCEwKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHd6KHRoaXMpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gSTIodGhpcyxuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIG0wKHRoaXMpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdENvbGxlY3Rpb24iLDMxKTt2YXIgZ2w9Q3IoImphdmEudXRpbCIsIlNldCIpO2Z1bmN0aW9uIGZhZShlLG4pe3ZhciByO3JldHVybiBEKG4pPT09RChlKT8hMDohTChuLDIxKXx8KHI9YShuLDIxKSxyLnNpemVfMSgpIT1lLnNpemVfMSgpKT8hMTplLmNvbnRhaW5zQWxsKHIpfWZ1bmN0aW9uIHBhZShlLG4pe3ZhciByLHQsbyxpO2lmKFZlKG4pLGk9ZS5tYXBfMC5zaXplXzEoKSxpPG4uc2l6ZV8xKCkpZm9yKHI9ZS5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtyLmhhc05leHRfMCgpOyl0PXIubmV4dF8xKCksbi5jb250YWlucyh0KSYmci5yZW1vdmUoKTtlbHNlIGZvcihvPW4uaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9by5uZXh0XzEoKSxlLm1hcF8wLnJlbW92ZV8wKHQpIT1udWxsO3JldHVybiBpIT1lLm1hcF8wLnNpemVfMSgpfXAoU3MsMzEsRGkpLGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gZmFlKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBCQih0aGlzKX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3RTZXQiLFNzKSxwKDIwNjgsU3MsRGkpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJTZXRzL0ltcHJvdmVkQWJzdHJhY3RTZXQiLDIwNjgpO2Z1bmN0aW9uIGdhZShlLG4pe3ZhciByLHQsbztyZXR1cm4gTChuLDQ0KT8ocj1hKG4sNDQpLHQ9ci5nZXRLZXkoKSxvPVhkKGUubWFwXzEoKSx0KSxudShvLHIuZ2V0VmFsdWUoKSkmJihvIT1udWxsfHxlLm1hcF8xKCkuY29udGFpbnNLZXkodCkpKTohMX1wKDIwNjksMjA2OCxEaSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5tYXBfMSgpLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gZ2FlKHRoaXMsbil9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8xKCkuaXNFbXB0eSgpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiB0aGlzLmNvbnRhaW5zKG4pJiZMKG4sNDQpPyhyPWEobiw0NCksdGhpcy5tYXBfMSgpLmtleVNldF8wKCkucmVtb3ZlXzEoci5nZXRLZXkoKSkpOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8xKCkuc2l6ZV8xKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNYXBzL0VudHJ5U2V0IiwyMDY5KTtmdW5jdGlvbiBoYWUoZSl7dGhpcy50aGlzJDExPWV9cCgxMTI3LDIwNjksRGksaGFlKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBSeih0aGlzLnRoaXMkMTEuc3VibWFwLmVudHJ5U2V0XzAoKSxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBFeih0aGlzLnRoaXMkMTEpfSxsLm1hcF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQxMX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gUnoodGhpcy50aGlzJDExLnN1Ym1hcC5lbnRyeVNldF8wKCksbik/KHI9YSh3bChhKG4sNDQpKSw0NCksWFllKHRoaXMudGhpcyQxMS50aGlzJDAxXzEsci5nZXRLZXkoKSksITApOiExfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYUModGhpcy50aGlzJDExLnN1Ym1hcC5lbnRyeVNldF8wKCkuc3BsaXRlcmF0b3JfMCgpLG5ldyBtYWUodGhpcy50aGlzJDExKSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvQXNNYXAvQXNNYXBFbnRyaWVzIiwxMTI3KTtmdW5jdGlvbiBtYWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDExMjgsMSx7fSxtYWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gZGFlKHRoaXMuJCRvdXRlcl8wLGEobiw0NCkpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL0FzTWFwL0FzTWFwRW50cmllcy8wbWV0aG9kcmVmJHdyYXBFbnRyeSRUeXBlIiwxMTI4KTtmdW5jdGlvbiBFeihlKXt0aGlzLnRoaXMkMTE9ZSx0aGlzLmRlbGVnYXRlSXRlcmF0b3I9dGhpcy50aGlzJDExLnN1Ym1hcC5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpfXAoNzQ2LDEsc3QsRXopLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPWEodGhpcy5kZWxlZ2F0ZUl0ZXJhdG9yLm5leHRfMSgpLDQ0KSx0aGlzLmNvbGxlY3Rpb249YShuLmdldFZhbHVlKCksMTYpLGRhZSh0aGlzLnRoaXMkMTEsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVJdGVyYXRvci5oYXNOZXh0XzAoKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtxbSghIXRoaXMuY29sbGVjdGlvbiksdGhpcy5kZWxlZ2F0ZUl0ZXJhdG9yLnJlbW92ZSgpLHRoaXMudGhpcyQxMS50aGlzJDAxXzEudG90YWxTaXplLT10aGlzLmNvbGxlY3Rpb24uc2l6ZV8xKCksdGhpcy5jb2xsZWN0aW9uLmNsZWFyXzAoKSx0aGlzLmNvbGxlY3Rpb249bnVsbH0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9Bc01hcC9Bc01hcEl0ZXJhdG9yIiw3NDYpO2Z1bmN0aW9uIGlJKGUpe3RoaXMubWFwXzA9YSh2bihlKSw4NSl9cCg1NDIsMjA2OCxEaSxpSSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5tYXBfMC5jbGVhcl8wKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubWFwXzAuY29udGFpbnNLZXkobil9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3ZuKG4pLHRoaXMubWFwXzAuZm9yRWFjaChuZXcgeHNlKG4pKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwXzAuaXNFbXB0eSgpfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGsyKHRoaXMubWFwXzAuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSl9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubWFwXzAuY29udGFpbnNLZXkobik/KHRoaXMubWFwXzAucmVtb3ZlXzAobiksITApOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLnNpemVfMSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTWFwcy9LZXlTZXQiLDU0Mik7ZnVuY3Rpb24gU3AoZSxuKXt0aGlzLnRoaXMkMDE9ZSxpSS5jYWxsKHRoaXMsbil9cCgzMjcsNTQyLERpLFNwKSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt2YXIgbjtnSSgobj10aGlzLm1hcF8wLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCksbmV3IHZ6KHRoaXMsbikpKX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXBfMC5rZXlTZXRfMCgpLmNvbnRhaW5zQWxsKG4pfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bnx8WW4odGhpcy5tYXBfMC5rZXlTZXRfMCgpLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdXIodGhpcy5tYXBfMC5rZXlTZXRfMCgpKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5tYXBfMC5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyB2eih0aGlzLG4pfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByLHQ7cmV0dXJuIHQ9MCxyPWEodGhpcy5tYXBfMC5yZW1vdmVfMChuKSwxNiksciYmKHQ9ci5zaXplXzEoKSxyLmNsZWFyXzAoKSx0aGlzLnRoaXMkMDEudG90YWxTaXplLT10KSx0PjB9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLmtleVNldF8wKCkuc3BsaXRlcmF0b3JfMCgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL0tleVNldCIsMzI3KTtmdW5jdGlvbiB2eihlLG4pe3RoaXMudGhpcyQxMT1lLHRoaXMudmFsJGVudHJ5SXRlcmF0b3IyPW59cCg3NDcsMSxzdCx2eiksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGVudHJ5SXRlcmF0b3IyLmhhc05leHRfMCgpfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJ5PWEodGhpcy52YWwkZW50cnlJdGVyYXRvcjIubmV4dF8xKCksNDQpLHRoaXMuZW50cnkuZ2V0S2V5KCl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7dmFyIG47cW0oISF0aGlzLmVudHJ5KSxuPWEodGhpcy5lbnRyeS5nZXRWYWx1ZSgpLDE2KSx0aGlzLnZhbCRlbnRyeUl0ZXJhdG9yMi5yZW1vdmUoKSx0aGlzLnRoaXMkMTEudGhpcyQwMS50b3RhbFNpemUtPW4uc2l6ZV8xKCksbi5jbGVhcl8wKCksdGhpcy5lbnRyeT1udWxsfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL0tleVNldC8xIiw3NDcpO2Z1bmN0aW9uIHRDKGUsbil7dGhpcy50aGlzJDAxXzA9ZSxZbS5jYWxsKHRoaXMsZSxuKX1wKDUwMyw0MDIsezg1OjEsMTMzOjF9LHRDKSxsLmNyZWF0ZUtleVNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZUtleVNldF8wKCl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXlTZXRfMSgpfSxsLmNyZWF0ZUtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvQyh0aGlzLnRoaXMkMDFfMCx0aGlzLnNvcnRlZE1hcCgpKX0sbC5maXJzdEtleT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRlZE1hcCgpLmZpcnN0S2V5KCl9LGwua2V5U2V0XzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLnNvcnRlZEtleVNldCxufHwodGhpcy5zb3J0ZWRLZXlTZXQ9dGhpcy5jcmVhdGVLZXlTZXRfMCgpKX0sbC5sYXN0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc29ydGVkTWFwKCkubGFzdEtleSgpfSxsLnNvcnRlZE1hcD1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMuc3VibWFwLDEzMyl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvU29ydGVkQXNNYXAiLDUwMyk7ZnVuY3Rpb24geDIoZSxuKXt0aGlzLnRoaXMkMDE9ZSx0Qy5jYWxsKHRoaXMsZSxuKX1wKDQ0Niw1MDMsekYseDIpLGwuY3JlYXRlS2V5U2V0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBLbSh0aGlzLnRoaXMkMDEsYShhKHRoaXMuc3VibWFwLDEzMyksMTM5KSl9LGwuY3JlYXRlS2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEttKHRoaXMudGhpcyQwMSxhKGEodGhpcy5zdWJtYXAsMTMzKSwxMzkpKX0sbC5rZXlTZXRfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuc29ydGVkS2V5U2V0LGEobnx8KHRoaXMuc29ydGVkS2V5U2V0PW5ldyBLbSh0aGlzLnRoaXMkMDEsYShhKHRoaXMuc3VibWFwLDEzMyksMTM5KSkpLDI3Nyl9LGwua2V5U2V0XzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLnNvcnRlZEtleVNldCxhKG58fCh0aGlzLnNvcnRlZEtleVNldD1uZXcgS20odGhpcy50aGlzJDAxLGEoYSh0aGlzLnN1Ym1hcCwxMzMpLDEzOSkpKSwyNzcpfSxsLnNvcnRlZE1hcD1mdW5jdGlvbigpe3JldHVybiBhKGEodGhpcy5zdWJtYXAsMTMzKSwxMzkpfSxsLmNlaWxpbmdLZXk9ZnVuY3Rpb24obil7cmV0dXJuIGEoYSh0aGlzLnN1Ym1hcCwxMzMpLDEzOSkuY2VpbGluZ0tleShuKX0sbC5mbG9vcktleT1mdW5jdGlvbihuKXtyZXR1cm4gYShhKHRoaXMuc3VibWFwLDEzMyksMTM5KS5mbG9vcktleShuKX0sbC5oZWFkTWFwPWZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyB4Mih0aGlzLnRoaXMkMDEsYShhKHRoaXMuc3VibWFwLDEzMyksMTM5KS5oZWFkTWFwKG4scikpfSxsLmhpZ2hlcktleT1mdW5jdGlvbihuKXtyZXR1cm4gYShhKHRoaXMuc3VibWFwLDEzMyksMTM5KS5oaWdoZXJLZXkobil9LGwubG93ZXJLZXk9ZnVuY3Rpb24obil7cmV0dXJuIGEoYSh0aGlzLnN1Ym1hcCwxMzMpLDEzOSkubG93ZXJLZXkobil9LGwudGFpbE1hcD1mdW5jdGlvbihuLHIpe3JldHVybiBuZXcgeDIodGhpcy50aGlzJDAxLGEoYSh0aGlzLnN1Ym1hcCwxMzMpLDEzOSkudGFpbE1hcChuLHIpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9OYXZpZ2FibGVBc01hcCIsNDQ2KTtmdW5jdGlvbiBvQyhlLG4pe1NwLmNhbGwodGhpcyxlLG4pfXAoNTAyLDMyNyxlaWUsb0MpLGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLmtleVNldF8wKCkuc3BsaXRlcmF0b3JfMCgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL1NvcnRlZEtleVNldCIsNTAyKTtmdW5jdGlvbiBLbShlLG4pe29DLmNhbGwodGhpcyxlLG4pfXAoNDAxLDUwMiwkRixLbSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9OYXZpZ2FibGVLZXlTZXQiLDQwMSk7ZnVuY3Rpb24gaUMoZSl7ZS5hbmNlc3Rvcj9pQyhlLmFuY2VzdG9yKTplLnRoaXMkMDFfMC5tYXBfMC5wdXQoZS5rZXksZS5kZWxlZ2F0ZSl9ZnVuY3Rpb24gZGEoZSl7dmFyIG47aWYoZS5hbmNlc3Rvcil7aWYoZGEoZS5hbmNlc3RvciksZS5hbmNlc3Rvci5kZWxlZ2F0ZSE9ZS5hbmNlc3RvckRlbGVnYXRlKXRocm93IGIobmV3IFhhKX1lbHNlIGUuZGVsZWdhdGUuaXNFbXB0eSgpJiYobj1hKGUudGhpcyQwMV8wLm1hcF8wLmdldF8zKGUua2V5KSwxNiksbiYmKGUuZGVsZWdhdGU9bikpfWZ1bmN0aW9uIGFJKGUpe2UuYW5jZXN0b3I/YUkoZS5hbmNlc3Rvcik6ZS5kZWxlZ2F0ZS5pc0VtcHR5KCkmJmUudGhpcyQwMV8wLm1hcF8wLnJlbW92ZV8wKGUua2V5KX1mdW5jdGlvbiB5YWUoZSl7cmV0dXJuIGRhKGUpLGUuZGVsZWdhdGUuc2l6ZV8xKCl9ZnVuY3Rpb24gbEkoZSxuLHIsdCl7dGhpcy50aGlzJDAxXzA9ZSx0aGlzLmtleT1uLHRoaXMuZGVsZWdhdGU9cix0aGlzLmFuY2VzdG9yPXQsdGhpcy5hbmNlc3RvckRlbGVnYXRlPXQ/dC5kZWxlZ2F0ZTpudWxsfXAoNTUxLDMxLEdkLGxJKSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3ZhciByLHQ7cmV0dXJuIGRhKHRoaXMpLHQ9dGhpcy5kZWxlZ2F0ZS5pc0VtcHR5KCkscj10aGlzLmRlbGVnYXRlLmFkZF8yKG4pLHImJigrK3RoaXMudGhpcyQwMV8wLnRvdGFsU2l6ZSx0JiZpQyh0aGlzKSkscn0sbC5hZGRBbGw9ZnVuY3Rpb24obil7dmFyIHIsdCxvO3JldHVybiBuLmlzRW1wdHkoKT8hMToobz0oZGEodGhpcyksdGhpcy5kZWxlZ2F0ZS5zaXplXzEoKSkscj10aGlzLmRlbGVnYXRlLmFkZEFsbChuKSxyJiYodD10aGlzLmRlbGVnYXRlLnNpemVfMSgpLHRoaXMudGhpcyQwMV8wLnRvdGFsU2l6ZSs9dC1vLG89PTAmJmlDKHRoaXMpKSxyKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dmFyIG47bj0oZGEodGhpcyksdGhpcy5kZWxlZ2F0ZS5zaXplXzEoKSksbiE9MCYmKHRoaXMuZGVsZWdhdGUuY2xlYXJfMCgpLHRoaXMudGhpcyQwMV8wLnRvdGFsU2l6ZS09bixhSSh0aGlzKSl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIGRhKHRoaXMpLHRoaXMuZGVsZWdhdGUuY29udGFpbnMobil9LGwuY29udGFpbnNBbGw9ZnVuY3Rpb24obil7cmV0dXJuIGRhKHRoaXMpLHRoaXMuZGVsZWdhdGUuY29udGFpbnNBbGwobil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIG49PT10aGlzPyEwOihkYSh0aGlzKSxZbih0aGlzLmRlbGVnYXRlLG4pKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIGRhKHRoaXMpLHVyKHRoaXMuZGVsZWdhdGUpfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gZGEodGhpcyksbmV3IEN6KHRoaXMpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBkYSh0aGlzKSxyPXRoaXMuZGVsZWdhdGUucmVtb3ZlXzEobiksciYmKC0tdGhpcy50aGlzJDAxXzAudG90YWxTaXplLGFJKHRoaXMpKSxyfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB5YWUodGhpcyl9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBkYSh0aGlzKSx0aGlzLmRlbGVnYXRlLnNwbGl0ZXJhdG9yXzAoKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIGRhKHRoaXMpLHZvKHRoaXMuZGVsZWdhdGUpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL1dyYXBwZWRDb2xsZWN0aW9uIiw1NTEpO2Z1bmN0aW9uIHdfKGUsbil7dmFyIHIsdDtmb3Iocj1lLnRvQXJyYXkoKSxfeShyLDAsci5sZW5ndGgsbiksdD0wO3Q8ci5sZW5ndGg7dCsrKWUuc2V0XzIodCxyW3RdKX12YXIgamE9Q3IoImphdmEudXRpbCIsIkxpc3QiKTtmdW5jdGlvbiBTeihlLG4scix0KXt0aGlzLnRoaXMkMDE9ZSxsSS5jYWxsKHRoaXMsZSxuLHIsdCl9cCg3NDQsNTUxLHsyMDoxLDMxOjEsMTY6MSwxNToxfSxTeiksbC5zb3J0XzA9ZnVuY3Rpb24obil7d18odGhpcyxuKX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIGRhKHRoaXMpLHRoaXMuZGVsZWdhdGUuc3BsaXRlcmF0b3JfMCgpfSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7dmFyIHQ7ZGEodGhpcyksdD10aGlzLmRlbGVnYXRlLmlzRW1wdHkoKSxhKHRoaXMuZGVsZWdhdGUsMTUpLmFkZF8zKG4sciksKyt0aGlzLnRoaXMkMDEudG90YWxTaXplLHQmJmlDKHRoaXMpfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpO3JldHVybiByLmlzRW1wdHkoKT8hMTooaT0oZGEodGhpcyksdGhpcy5kZWxlZ2F0ZS5zaXplXzEoKSksdD1hKHRoaXMuZGVsZWdhdGUsMTUpLmFkZEFsbF8wKG4sciksdCYmKG89dGhpcy5kZWxlZ2F0ZS5zaXplXzEoKSx0aGlzLnRoaXMkMDEudG90YWxTaXplKz1vLWksaT09MCYmaUModGhpcykpLHQpfSxsLmdldF8wPWZ1bmN0aW9uKG4pe3JldHVybiBkYSh0aGlzKSxhKHRoaXMuZGVsZWdhdGUsMTUpLmdldF8wKG4pfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXtyZXR1cm4gZGEodGhpcyksYSh0aGlzLmRlbGVnYXRlLDE1KS5pbmRleE9mXzAobil9LGwubGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gZGEodGhpcyksbmV3IFNhZSh0aGlzKX0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gZGEodGhpcyksbmV3IENhZSh0aGlzLG4pfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBkYSh0aGlzKSxyPWEodGhpcy5kZWxlZ2F0ZSwxNSkucmVtb3ZlXzIobiksLS10aGlzLnRoaXMkMDEudG90YWxTaXplLGFJKHRoaXMpLHJ9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gZGEodGhpcyksYSh0aGlzLmRlbGVnYXRlLDE1KS5zZXRfMihuLHIpfSxsLnN1Ykxpc3Q9ZnVuY3Rpb24obixyKXtyZXR1cm4gZGEodGhpcyksdGFlKHRoaXMudGhpcyQwMSx0aGlzLmtleSxhKHRoaXMuZGVsZWdhdGUsMTUpLnN1Ykxpc3QobixyKSx0aGlzLmFuY2VzdG9yP3RoaXMuYW5jZXN0b3I6dGhpcyl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvV3JhcHBlZExpc3QiLDc0NCk7ZnVuY3Rpb24gd2FlKGUsbixyLHQpe1N6LmNhbGwodGhpcyxlLG4scix0KX1wKDExMjYsNzQ0LHsyMDoxLDMxOjEsMTY6MSwxNToxLDU5OjF9LHdhZSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9SYW5kb21BY2Nlc3NXcmFwcGVkTGlzdCIsMTEyNik7ZnVuY3Rpb24gRWFlKGUpe2Uub3JpZ2luYWxEZWxlZ2F0ZT1lLnRoaXMkMTFfMC5kZWxlZ2F0ZX1mdW5jdGlvbiB2YWUoZSl7ZS5kZWxlZ2F0ZUl0ZXJhdG9yLnJlbW92ZSgpLC0tZS50aGlzJDExXzAudGhpcyQwMV8wLnRvdGFsU2l6ZSxhSShlLnRoaXMkMTFfMCl9ZnVuY3Rpb24gWG0oZSl7aWYoZGEoZS50aGlzJDExXzApLGUudGhpcyQxMV8wLmRlbGVnYXRlIT1lLm9yaWdpbmFsRGVsZWdhdGUpdGhyb3cgYihuZXcgWGEpfWZ1bmN0aW9uIEN6KGUpe3RoaXMudGhpcyQxMV8wPWUsRWFlKHRoaXMpLHRoaXMuZGVsZWdhdGVJdGVyYXRvcj1KWWUoZS5kZWxlZ2F0ZSl9ZnVuY3Rpb24gbktlKGUsbil7dGhpcy50aGlzJDExXzA9ZSxFYWUodGhpcyksdGhpcy5kZWxlZ2F0ZUl0ZXJhdG9yPW59cCg2MjgsMSxzdCxDeiksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIFhtKHRoaXMpLHRoaXMuZGVsZWdhdGVJdGVyYXRvci5oYXNOZXh0XzAoKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gWG0odGhpcyksdGhpcy5kZWxlZ2F0ZUl0ZXJhdG9yLm5leHRfMSgpfSxsLnJlbW92ZT1mdW5jdGlvbigpe3ZhZSh0aGlzKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9XcmFwcGVkQ29sbGVjdGlvbi9XcmFwcGVkSXRlcmF0b3IiLDYyOCk7ZnVuY3Rpb24gU2FlKGUpe3RoaXMudGhpcyQxMT1lLEN6LmNhbGwodGhpcyxlKX1mdW5jdGlvbiBDYWUoZSxuKXt0aGlzLnRoaXMkMTE9ZSxuS2UuY2FsbCh0aGlzLGUsYShlLmRlbGVnYXRlLDE1KS5saXN0SXRlcmF0b3JfMShuKSl9cCg3NDUsNjI4LEN1LFNhZSxDYWUpLGwucmVtb3ZlPWZ1bmN0aW9uKCl7dmFlKHRoaXMpfSxsLmFkZF8xPWZ1bmN0aW9uKG4pe3ZhciByO3I9eWFlKHRoaXMudGhpcyQxMSk9PTAsKFhtKHRoaXMpLGEodGhpcy5kZWxlZ2F0ZUl0ZXJhdG9yLDEyOCkpLmFkZF8xKG4pLCsrdGhpcy50aGlzJDExLnRoaXMkMDEudG90YWxTaXplLHImJmlDKHRoaXMudGhpcyQxMSl9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4oWG0odGhpcyksYSh0aGlzLmRlbGVnYXRlSXRlcmF0b3IsMTI4KSkuaGFzUHJldmlvdXMoKX0sbC5uZXh0SW5kZXhfMD1mdW5jdGlvbigpe3JldHVybihYbSh0aGlzKSxhKHRoaXMuZGVsZWdhdGVJdGVyYXRvciwxMjgpKS5uZXh0SW5kZXhfMCgpfSxsLnByZXZpb3VzXzA9ZnVuY3Rpb24oKXtyZXR1cm4oWG0odGhpcyksYSh0aGlzLmRlbGVnYXRlSXRlcmF0b3IsMTI4KSkucHJldmlvdXNfMCgpfSxsLnByZXZpb3VzSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4oWG0odGhpcyksYSh0aGlzLmRlbGVnYXRlSXRlcmF0b3IsMTI4KSkucHJldmlvdXNJbmRleCgpfSxsLnNldF8xPWZ1bmN0aW9uKG4peyhYbSh0aGlzKSxhKHRoaXMuZGVsZWdhdGVJdGVyYXRvciwxMjgpKS5zZXRfMShuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TWFwQmFzZWRNdWx0aW1hcC9XcmFwcGVkTGlzdC9XcmFwcGVkTGlzdEl0ZXJhdG9yIiw3NDUpO2Z1bmN0aW9uIFR6KGUsbixyKXtsSS5jYWxsKHRoaXMsZSxuLHIsbnVsbCl9cCg3NDMsNTUxLGVpZSxUeiksbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIGRhKHRoaXMpLHRoaXMuZGVsZWdhdGUuc3BsaXRlcmF0b3JfMCgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL1dyYXBwZWRTb3J0ZWRTZXQiLDc0Myk7ZnVuY3Rpb24gVGFlKGUsbixyKXtUei5jYWxsKHRoaXMsZSxuLHIpfXAoMTEyNSw3NDMsJEYsVGFlKSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBCYXNlZE11bHRpbWFwL1dyYXBwZWROYXZpZ2FibGVTZXQiLDExMjUpO2Z1bmN0aW9uIGJhZShlLG4scil7bEkuY2FsbCh0aGlzLGUsbixyLG51bGwpfXAoMTEyNCw1NTEsRGksYmFlKSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gZGEodGhpcyksdGhpcy5kZWxlZ2F0ZS5zcGxpdGVyYXRvcl8wKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvV3JhcHBlZFNldCIsMTEyNCk7ZnVuY3Rpb24gSWFlKCl7fXAoMTEzMywxLHt9LElhZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBaWWUoYShuLDQ0KSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvbGFtYmRhJDEkVHlwZSIsMTEzMyk7ZnVuY3Rpb24geGFlKGUpe3RoaXMua2V5XzA9ZX1wKDExMzIsMSx7fSx4YWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IHcxKHRoaXMua2V5XzAsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE1hcEJhc2VkTXVsdGltYXAvbGFtYmRhJDIkVHlwZSIsMTEzMik7dmFyIEVfPUNyKCJqYXZhLnV0aWwiLCJNYXAvRW50cnkiKTtwKDM1OCwxLHI2KSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sNDQpPyhyPWEobiw0NCksbnUodGhpcy5nZXRLZXkoKSxyLmdldEtleSgpKSYmbnUodGhpcy5nZXRWYWx1ZSgpLHIuZ2V0VmFsdWUoKSkpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiBuPXRoaXMuZ2V0S2V5KCkscj10aGlzLmdldFZhbHVlKCksKG49PW51bGw/MDp1cihuKSleKHI9PW51bGw/MDp1cihyKSl9LGwuc2V0VmFsdWU9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRLZXkoKSsiPSIrdGhpcy5nZXRWYWx1ZSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNYXBFbnRyeSIsMzU4KSxwKDIwODYsMzEsR2QpLGwuY2xlYXJfMD1mdW5jdGlvbigpe3RoaXMubXVsdGltYXBfMCgpLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDQ0KT8ocj1hKG4sNDQpLFlZZSh0aGlzLm11bHRpbWFwXzAoKSxyLmdldEtleSgpLHIuZ2V0VmFsdWUoKSkpOiExfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sNDQpPyhyPWEobiw0NCksbmFlKHRoaXMubXVsdGltYXBfMCgpLHIuZ2V0S2V5KCksci5nZXRWYWx1ZSgpKSk6ITF9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubXVsdGltYXBfMCgpLnRvdGFsU2l6ZX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk11bHRpbWFwcy9FbnRyaWVzIiwyMDg2KTtmdW5jdGlvbiBieihlKXt0aGlzLnRoaXMkMDE9ZX1wKDc0OSwyMDg2LEdkLGJ6KSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLmVudHJ5SXRlcmF0b3IoKX0sbC5tdWx0aW1hcF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5lbnRyeVNwbGl0ZXJhdG9yKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE11bHRpbWFwL0VudHJpZXMiLDc0OSk7ZnVuY3Rpb24gSXooZSl7YnouY2FsbCh0aGlzLGUpfXAoNzUwLDc0OSxEaSxJeiksbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5lbnRyeVNwbGl0ZXJhdG9yKCl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIGwkKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBxc2UodGhpcyl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdE11bHRpbWFwL0VudHJ5U2V0Iiw3NTApO2Z1bmN0aW9uIHh6KGUpe3RoaXMudGhpcyQwMT1lfXAoNzUxLDMxLEdkLHh6KSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLnRoaXMkMDEuY2xlYXJfMCgpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBLWWUodGhpcy50aGlzJDAxLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLnZhbHVlSXRlcmF0b3JfMCgpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEudG90YWxTaXplfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLnZhbHVlU3BsaXRlcmF0b3IoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TXVsdGltYXAvVmFsdWVzIiw3NTEpO2Z1bmN0aW9uIHJLZShlKXtlLnZhbCRiYWNraW5nRW50cnkyLmdldEtleSgpLGEoZS52YWwkYmFja2luZ0VudHJ5Mi5nZXRWYWx1ZSgpLDE2KS5zaXplXzEoKSxQeigpfWZ1bmN0aW9uIHRLZShlLG4pe3ZhciByLHQsbztmb3IodD1uLnZhbCRiYWNraW5nRW50cnkyLmdldEtleSgpLHI9YShuLnZhbCRiYWNraW5nRW50cnkyLmdldFZhbHVlKCksMTYpLnNpemVfMSgpLG89MDtvPHI7bysrKWUuYWNjZXB0KHQpfWZ1bmN0aW9uIFB6KCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIENwKGUpe3ZhciBuO3JldHVybiBuPWUuZW50cnlTZXQsIW4mJihlLmVudHJ5U2V0PW49bmV3IFBhZShlKSksbn1mdW5jdGlvbiBvS2UoZSxuKXt2bihuKSxDcChlKS5mb3JFYWNoXzAobmV3IEJzZSl9cCgyMDg3LDMxLHs4NDk6MSwyMDoxLDMxOjEsMTY6MX0pLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3ZuKG4pLENwKHRoaXMpLmZvckVhY2hfMChuZXcgR3NlKG4pKX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49Q3AodGhpcykuc3BsaXRlcmF0b3JfMCgpLEY2KG4sbmV3IFVzZSw2NHxuLmNoYXJhY3RlcmlzdGljc18wKCkmMTI5Nix0aGlzLm11bHRpbWFwLnRvdGFsU2l6ZSl9LGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIFB6KCksITB9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB2bih0aGlzKSx2bihuKSxMKG4sNTUyKT9kWGUoYShuLDg0OSkpOiFuLmlzRW1wdHkoKSYmaTUodGhpcyxuLml0ZXJhdG9yXzAoKSl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9YShYZCh0aCh0aGlzLm11bHRpbWFwKSxuKSwxNiksKHI/ci5zaXplXzEoKTowKT4wfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBmWGUodGhpcyxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKENwKHRoaXMpKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIENwKHRoaXMpLmlzRW1wdHkoKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gTXNlKHRoaXMsbiwxKT4wfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdm8oQ3AodGhpcykpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RNdWx0aXNldCIsMjA4NykscCgyMDg5LDIwNjgsRGkpLGwuY2xlYXJfMD1mdW5jdGlvbigpe3RJKHRoaXMudGhpcyQwMS5tdWx0aW1hcCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7dmFyIHIsdDtyZXR1cm4gTChuLDUwNCk/KHQ9YShuLDQyNSksYSh0LnZhbCRiYWNraW5nRW50cnkyLmdldFZhbHVlKCksMTYpLnNpemVfMSgpPD0wPyExOihyPU9zZSh0aGlzLnRoaXMkMDEsdC52YWwkYmFja2luZ0VudHJ5Mi5nZXRLZXkoKSkscj09YSh0LnZhbCRiYWNraW5nRW50cnkyLmdldFZhbHVlKCksMTYpLnNpemVfMSgpKSk6ITF9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGk7cmV0dXJuIEwobiw1MDQpJiYodD1hKG4sNDI1KSxyPXQudmFsJGJhY2tpbmdFbnRyeTIuZ2V0S2V5KCksbz1hKHQudmFsJGJhY2tpbmdFbnRyeTIuZ2V0VmFsdWUoKSwxNikuc2l6ZV8xKCksbyE9MCk/KGk9dGhpcy50aGlzJDAxLGdYZShpLHIsbykpOiExfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTXVsdGlzZXRzL0VudHJ5U2V0IiwyMDg5KTtmdW5jdGlvbiBQYWUoZSl7dGhpcy50aGlzJDAxPWV9cCgxMTM5LDIwODksRGksUGFlKSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEZzZShfYWUodGgodGhpcy50aGlzJDAxLm11bHRpbWFwKSkuaXRlcmF0b3JfMCgpKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGgodGhpcy50aGlzJDAxLm11bHRpbWFwKS5zaXplXzEoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFic3RyYWN0TXVsdGlzZXQvRW50cnlTZXQiLDExMzkpO2Z1bmN0aW9uIE56KGUpe29hZS5jYWxsKHRoaXMsZSl9cCg2MjcsNzQyLGZfKSxsLmNyZWF0ZUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVDb2xsZWN0aW9uXzEoKX0sbC5jcmVhdGVVbm1vZGlmaWFibGVFbXB0eUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVVbm1vZGlmaWFibGVFbXB0eUNvbGxlY3Rpb25fMCgpfSxsLmdldF8xPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmdldF80KG4pfSxsLnJlbW92ZUFsbD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5yZW1vdmVBbGxfMShuKX0sbC5hc01hcF8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5hc01hcCxufHwodGhpcy5hc01hcD10aGlzLmNyZWF0ZUFzTWFwKCkpfSxsLmNyZWF0ZVVubW9kaWZpYWJsZUVtcHR5Q29sbGVjdGlvbl8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksTmUoKSxleH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gXzUodGhpcyxuKX0sbC5nZXRfND1mdW5jdGlvbihuKXtyZXR1cm4gYShabih0aGlzLG4pLDIxKX0sbC5yZW1vdmVBbGxfMT1mdW5jdGlvbihuKXtyZXR1cm4gYShuQyh0aGlzLG4pLDIxKX0sbC51bm1vZGlmaWFibGVDb2xsZWN0aW9uU3ViY2xhc3M9ZnVuY3Rpb24obil7cmV0dXJuIE5lKCksbmV3IG15KGEobiwyMSkpfSxsLndyYXBDb2xsZWN0aW9uPWZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBiYWUodGhpcyxuLGEociwyMSkpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RTZXRNdWx0aW1hcCIsNjI3KTtmdW5jdGlvbiBBeihlKXt2YXIgbjtyZXR1cm4gbj1lLnZhbHVlcyxufHwoZS52YWx1ZXM9bmV3IHh6KGUpKX1wKDE3MjMsNjI3LGZfKSxsLmNyZWF0ZUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEZjKHRoaXMudmFsdWVDb21wYXJhdG9yKX0sbC5jcmVhdGVDb2xsZWN0aW9uXzE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEZjKHRoaXMudmFsdWVDb21wYXJhdG9yKX0sbC5jcmVhdGVVbm1vZGlmaWFibGVFbXB0eUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gcyQobmV3IEZjKHRoaXMudmFsdWVDb21wYXJhdG9yKSl9LGwuY3JlYXRlVW5tb2RpZmlhYmxlRW1wdHlDb2xsZWN0aW9uXzA9ZnVuY3Rpb24oKXtyZXR1cm4gcyQobmV3IEZjKHRoaXMudmFsdWVDb21wYXJhdG9yKSl9LGwuZ2V0XzE9ZnVuY3Rpb24obil7cmV0dXJuIGEoYShabih0aGlzLG4pLDIxKSw4Nyl9LGwuZ2V0XzQ9ZnVuY3Rpb24obil7cmV0dXJuIGEoYShabih0aGlzLG4pLDIxKSw4Nyl9LGwucmVtb3ZlQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBhKGEobkModGhpcyxuKSwyMSksODcpfSxsLnJlbW92ZUFsbF8xPWZ1bmN0aW9uKG4pe3JldHVybiBhKGEobkModGhpcyxuKSwyMSksODcpfSxsLnVubW9kaWZpYWJsZUNvbGxlY3Rpb25TdWJjbGFzcz1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDI3Nyk/cyQoYShuLDI3NykpOihOZSgpLG5ldyBWQihhKG4sODcpKSl9LGwuYXNNYXBfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuYXNNYXAsbnx8KHRoaXMuYXNNYXA9TCh0aGlzLm1hcF8wLDEzOSk/bmV3IHgyKHRoaXMsYSh0aGlzLm1hcF8wLDEzOSkpOkwodGhpcy5tYXBfMCwxMzMpP25ldyB0Qyh0aGlzLGEodGhpcy5tYXBfMCwxMzMpKTpuZXcgWW0odGhpcyx0aGlzLm1hcF8wKSl9LGwud3JhcENvbGxlY3Rpb249ZnVuY3Rpb24obixyKXtyZXR1cm4gTChyLDI3Nyk/bmV3IFRhZSh0aGlzLG4sYShyLDI3NykpOm5ldyBUeih0aGlzLG4sYShyLDg3KSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdFNvcnRlZFNldE11bHRpbWFwIiwxNzIzKTtmdW5jdGlvbiBpS2UoZSl7TnouY2FsbCh0aGlzLGUpfXAoMTcyNCwxNzIzLGZfKSxsLmFzTWFwXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmFzTWFwLGEoYShufHwodGhpcy5hc01hcD1MKHRoaXMubWFwXzAsMTM5KT9uZXcgeDIodGhpcyxhKHRoaXMubWFwXzAsMTM5KSk6TCh0aGlzLm1hcF8wLDEzMyk/bmV3IHRDKHRoaXMsYSh0aGlzLm1hcF8wLDEzMykpOm5ldyBZbSh0aGlzLHRoaXMubWFwXzApKSwxMzMpLDEzOSl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmtleVNldCxhKGEobnx8KHRoaXMua2V5U2V0PUwodGhpcy5tYXBfMCwxMzkpP25ldyBLbSh0aGlzLGEodGhpcy5tYXBfMCwxMzkpKTpMKHRoaXMubWFwXzAsMTMzKT9uZXcgb0ModGhpcyxhKHRoaXMubWFwXzAsMTMzKSk6bmV3IFNwKHRoaXMsdGhpcy5tYXBfMCkpLDg3KSwyNzcpfSxsLmNyZWF0ZUtleVNldD1mdW5jdGlvbigpe3JldHVybiBMKHRoaXMubWFwXzAsMTM5KT9uZXcgS20odGhpcyxhKHRoaXMubWFwXzAsMTM5KSk6TCh0aGlzLm1hcF8wLDEzMyk/bmV3IG9DKHRoaXMsYSh0aGlzLm1hcF8wLDEzMykpOm5ldyBTcCh0aGlzLHRoaXMubWFwXzApfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQWJzdHJhY3RTb3J0ZWRLZXlTb3J0ZWRTZXRNdWx0aW1hcCIsMTcyNCkscCgyMTA5LDEsezIwNDY6MX0pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIEVYZSh0aGlzLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gQkIoKG49dGhpcy5jZWxsU2V0LG58fCh0aGlzLmNlbGxTZXQ9bmV3IE02KHRoaXMpKSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdWFlKChuPXRoaXMucm93TWFwLG58fCh0aGlzLnJvd01hcD1uZXcgT3oodGhpcykpKSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdFRhYmxlIiwyMTA5KTtmdW5jdGlvbiBNNihlKXt0aGlzLnRoaXMkMDE9ZX1wKDY3OSxTcyxEaSxNNiksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7QWFlKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7dmFyIHIsdDtyZXR1cm4gTChuLDQ3OSk/KHI9YShuLDY5NyksdD1hKFhkKGthZSh0aGlzLnRoaXMkMDEpLHkwKHIudGhpcyQwMS5yb3dMaXN0LHIucm93SW5kZXgpKSw4NSksISF0JiZSeih0LmVudHJ5U2V0XzAoKSxuZXcgdzEoeTAoci50aGlzJDAxLmNvbHVtbkxpc3Qsci5jb2x1bW5JbmRleCksb2goci50aGlzJDAxLHIucm93SW5kZXgsci5jb2x1bW5JbmRleCkpKSk6ITF9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBsS2UodGhpcy50aGlzJDAxKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcix0O3JldHVybiBMKG4sNDc5KT8ocj1hKG4sNjk3KSx0PWEoWGQoa2FlKHRoaXMudGhpcyQwMSkseTAoci50aGlzJDAxLnJvd0xpc3Qsci5yb3dJbmRleCkpLDg1KSwhIXQmJkVLZSh0LmVudHJ5U2V0XzAoKSxuZXcgdzEoeTAoci50aGlzJDAxLmNvbHVtbkxpc3Qsci5jb2x1bW5JbmRleCksb2goci50aGlzJDAxLHIucm93SW5kZXgsci5jb2x1bW5JbmRleCkpKSk6ITF9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIE1hZSh0aGlzLnRoaXMkMDEpfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gc0tlKHRoaXMudGhpcyQwMSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdFRhYmxlL0NlbGxTZXQiLDY3OSk7ZnVuY3Rpb24gTmFlKGUpe3RoaXMudGhpcyQwMT1lfXAoMjAyNSwzMSxHZCxOYWUpLGwuY2xlYXJfMD1mdW5jdGlvbigpe0FhZSgpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB1S2UodGhpcy50aGlzJDAxLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gZktlKHRoaXMudGhpcyQwMSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIE1hZSh0aGlzLnRoaXMkMDEpfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gUmFlKHRoaXMudGhpcyQwMSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBYnN0cmFjdFRhYmxlL1ZhbHVlcyIsMjAyNSk7ZnVuY3Rpb24gYUtlKGUpe29hZS5jYWxsKHRoaXMsZSl9cCgxNjk3LDE2OTYsZl8pLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheUxpc3RNdWx0aW1hcEd3dFNlcmlhbGl6YXRpb25EZXBlbmRlbmNpZXMiLDE2OTcpO2Z1bmN0aW9uIFI2KCl7THouY2FsbCh0aGlzLDEyLDMpfWZ1bmN0aW9uIEx6KGUsbil7YUtlLmNhbGwodGhpcyxuZXcgRWgoS2QoZSkpKSxQYShuLCJleHBlY3RlZFZhbHVlc1BlcktleSIpLHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXk9bn1wKDUyMCwxNjk3LGZfLFI2LEx6KSxsLmNyZWF0ZUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IF9pKHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXkpfSxsLmV4cGVjdGVkVmFsdWVzUGVyS2V5PTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFycmF5TGlzdE11bHRpbWFwIiw1MjApO2Z1bmN0aW9uIG9oKGUsbixyKXtyZXR1cm4gZUMobixlLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSksZUMocixlLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSksZS5hcnJheVtuXVtyXX1mdW5jdGlvbiBsS2UoZSl7cmV0dXJuIG5ldyBGYWUoZSxlLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSplLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSl9ZnVuY3Rpb24gc0tlKGUpe3JldHVybiB6NihlLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSplLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSwyNzMsbmV3IHphZShlKSl9ZnVuY3Rpb24gQWFlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIHVLZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKHU9ZS5hcnJheSxjPTAsXz11Lmxlbmd0aDtjPF87KytjKWZvcihzPXVbY10sdD1zLG89MCxpPXQubGVuZ3RoO288aTsrK28paWYocj10W29dLEQobik9PT1EKHIpfHxuIT1udWxsJiZZbihuLHIpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGNLZShlKXt2YXIgbixyLHQsbztmb3Iocj1lLmFycmF5LHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLG8wZShuLG4ubGVuZ3RoLG51bGwpfWZ1bmN0aW9uIHZfKGUsbixyKXt2YXIgdCxvO3JldHVybiBvPWEoTjIoZS5yb3dLZXlUb0luZGV4LG4pLDE3KSx0PWEoTjIoZS5jb2x1bW5LZXlUb0luZGV4LHIpLDE3KSwhb3x8IXQ/bnVsbDpvaChlLG8udmFsdWVfMCx0LnZhbHVlXzApfWZ1bmN0aW9uIExhZShlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9bi9lLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKXwwLHI9biVlLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSxvaChlLHQscil9ZnVuY3Rpb24gX0tlKGUsbixyLHQpe3ZhciBvLGk7cmV0dXJuIHZuKG4pLHZuKHIpLGk9YShOMihlLnJvd0tleVRvSW5kZXgsbiksMTcpLEtpZSghIWksIlJvdyAlcyBub3QgaW4gJXMiLG4sZS5yb3dMaXN0KSxvPWEoTjIoZS5jb2x1bW5LZXlUb0luZGV4LHIpLDE3KSxLaWUoISFvLCJDb2x1bW4gJXMgbm90IGluICVzIixyLGUuY29sdW1uTGlzdCksT2FlKGUsaS52YWx1ZV8wLG8udmFsdWVfMCx0KX1mdW5jdGlvbiBrYWUoZSl7dmFyIG47cmV0dXJuIG49ZS5yb3dNYXAsbnx8KGUucm93TWFwPW5ldyBPeihlKSl9ZnVuY3Rpb24gT2FlKGUsbixyLHQpe3ZhciBvO3JldHVybiBlQyhuLGUucm93TGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKSxlQyhyLGUuY29sdW1uTGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKSxvPWUuYXJyYXlbbl1bcl0sVHIoZS5hcnJheVtuXSxyLHQpLG99ZnVuY3Rpb24gTWFlKGUpe3JldHVybiBlLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSplLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKX1mdW5jdGlvbiBkS2UoZSl7dmFyIG47cmV0dXJuIG49ZS52YWx1ZXMsbnx8KGUudmFsdWVzPW5ldyBOYWUoZSkpfWZ1bmN0aW9uIGZLZShlKXtyZXR1cm4gbmV3IEJhZShlLGUucm93TGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKmUuY29sdW1uTGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKX1mdW5jdGlvbiBSYWUoZSl7cmV0dXJuIHo2KGUucm93TGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKmUuY29sdW1uTGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpLDE2LG5ldyAkYWUoZSkpfWZ1bmN0aW9uIERhZShlLG4pe3ZhciByO3RoaXMucm93TGlzdD0oeTEoKSx2bihlKSx5MSgpLCR6KGUpKSx0aGlzLmNvbHVtbkxpc3Q9KHZuKG4pLCR6KG4pKSx1eih0aGlzLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5pc0VtcHR5KCk9PXRoaXMuY29sdW1uTGlzdC5kZWxlZ2F0ZUxpc3RfMCgpLmlzRW1wdHkoKSksdGhpcy5yb3dLZXlUb0luZGV4PUNzZSh0aGlzLnJvd0xpc3QpLHRoaXMuY29sdW1uS2V5VG9JbmRleD1Dc2UodGhpcy5jb2x1bW5MaXN0KSxyPWJfKFFyLFtYLE1lXSxbNSwxXSw1LFt0aGlzLnJvd0xpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKSx0aGlzLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKV0sMiksdGhpcy5hcnJheT1yLGNLZSh0aGlzKX1wKDY3OCwyMTA5LHs2Nzg6MSwyMDQ2OjEsMzoxfSxEYWUpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlIiw2NzgpO2Z1bmN0aW9uIEZhZShlLG4pe3RoaXMudGhpcyQwMT1lLFA2LmNhbGwodGhpcyxuKX1wKDIwMjEsMzk5LCRtLEZhZSksbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IGt6KHRoaXMudGhpcyQwMSxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFycmF5VGFibGUvMSIsMjAyMSk7ZnVuY3Rpb24gemFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgyMDIyLDEse30semFlKSxsLmFwcGx5XzI9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBreih0aGlzLiQkb3V0ZXJfMCxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFycmF5VGFibGUvMW1ldGhvZHJlZiRnZXRDZWxsJFR5cGUiLDIwMjIpLHAoMjExMCwxLHs2OTc6MX0pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIG49PT10aGlzPyEwOkwobiw0NzkpPyhyPWEobiw2OTcpLG51KHkwKHRoaXMudGhpcyQwMS5yb3dMaXN0LHRoaXMucm93SW5kZXgpLHkwKHIudGhpcyQwMS5yb3dMaXN0LHIucm93SW5kZXgpKSYmbnUoeTAodGhpcy50aGlzJDAxLmNvbHVtbkxpc3QsdGhpcy5jb2x1bW5JbmRleCkseTAoci50aGlzJDAxLmNvbHVtbkxpc3Qsci5jb2x1bW5JbmRleCkpJiZudShvaCh0aGlzLnRoaXMkMDEsdGhpcy5yb3dJbmRleCx0aGlzLmNvbHVtbkluZGV4KSxvaChyLnRoaXMkMDEsci5yb3dJbmRleCxyLmNvbHVtbkluZGV4KSkpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4ga0MoUChJKFFyLDEpLE1lLDEsNSxbeTAodGhpcy50aGlzJDAxLnJvd0xpc3QsdGhpcy5yb3dJbmRleCkseTAodGhpcy50aGlzJDAxLmNvbHVtbkxpc3QsdGhpcy5jb2x1bW5JbmRleCksb2godGhpcy50aGlzJDAxLHRoaXMucm93SW5kZXgsdGhpcy5jb2x1bW5JbmRleCldKSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiIoIit5MCh0aGlzLnRoaXMkMDEucm93TGlzdCx0aGlzLnJvd0luZGV4KSsiLCIreTAodGhpcy50aGlzJDAxLmNvbHVtbkxpc3QsdGhpcy5jb2x1bW5JbmRleCkrIik9IitvaCh0aGlzLnRoaXMkMDEsdGhpcy5yb3dJbmRleCx0aGlzLmNvbHVtbkluZGV4KX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlRhYmxlcy9BYnN0cmFjdENlbGwiLDIxMTApO2Z1bmN0aW9uIGt6KGUsbil7dGhpcy50aGlzJDAxPWUsdGhpcy52YWwkaW5kZXgyPW4sdGhpcy5yb3dJbmRleD10aGlzLnZhbCRpbmRleDIvdGhpcy50aGlzJDAxLmNvbHVtbkxpc3QuZGVsZWdhdGVMaXN0XzAoKS5zaXplXzEoKXwwLHRoaXMuY29sdW1uSW5kZXg9dGhpcy52YWwkaW5kZXgyJXRoaXMudGhpcyQwMS5jb2x1bW5MaXN0LmRlbGVnYXRlTGlzdF8wKCkuc2l6ZV8xKCl9cCg0NzksMjExMCx7NDc5OjEsNjk3OjF9LGt6KSxsLmNvbHVtbkluZGV4PTAsbC5yb3dJbmRleD0wLGwudmFsJGluZGV4Mj0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlLzIiLDQ3OSk7ZnVuY3Rpb24gJGFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgyMDI0LDEse30sJGFlKSxsLmFwcGx5XzI9ZnVuY3Rpb24obil7cmV0dXJuIExhZSh0aGlzLiQkb3V0ZXJfMCxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFycmF5VGFibGUvMm1ldGhvZHJlZiRnZXRWYWx1ZSRUeXBlIiwyMDI0KTtmdW5jdGlvbiBCYWUoZSxuKXt0aGlzLnRoaXMkMDE9ZSxQNi5jYWxsKHRoaXMsbil9cCgyMDIzLDM5OSwkbSxCYWUpLGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIExhZSh0aGlzLnRoaXMkMDEsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlLzMiLDIwMjMpO2Z1bmN0aW9uIHBLZShlLG4pe2UuZW50cnlJdGVyYXRvcigpLmZvckVhY2hSZW1haW5pbmcobil9cCgyMDc3LDIwNjUsaDEpLGwuY2xlYXJfMD1mdW5jdGlvbigpe2dJKHRoaXMuZW50cnlJdGVyYXRvcigpKX0sbC5lbnRyeVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBJc2UodGhpcyl9LGwuZW50cnlTcGxpdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgTl9lKHRoaXMuZW50cnlJdGVyYXRvcigpLHRoaXMuc2l6ZV8xKCkpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTWFwcy9JdGVyYXRvckJhc2VkQWJzdHJhY3RNYXAiLDIwNzcpO2Z1bmN0aW9uIEdhZShlLG4pe3JldHVybiBlQyhuLGUua2V5SW5kZXguZGVsZWdhdGUubWFwXzAuc2l6ZV8xKCkpLG5ldyBXYWUoZSxuKX1mdW5jdGlvbiBnS2UoZSxuKXtyZXR1cm4gcTYoZS5rZXlJbmRleCkuYXNMaXN0XzEoKS5nZXRfMChuKX1mdW5jdGlvbiBIYWUoZSl7dGhpcy5rZXlJbmRleD1lfXAoODQyLDIwNzcsaDEpLGwuY2xlYXJfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gc2xlKHRoaXMua2V5SW5kZXgsbil9LGwuZW50cnlJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgamFlKHRoaXMsdGhpcy5rZXlJbmRleC5kZWxlZ2F0ZS5tYXBfMC5zaXplXzEoKSl9LGwuZW50cnlTcGxpdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiB6Nih0aGlzLmtleUluZGV4LmRlbGVnYXRlLm1hcF8wLnNpemVfMSgpLDE2LG5ldyBVYWUodGhpcykpfSxsLmdldF8zPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPWEoTjIodGhpcy5rZXlJbmRleCxuKSwxNykscj90aGlzLmdldFZhbHVlXzAoci52YWx1ZV8wKTpudWxsfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXlJbmRleC5kZWxlZ2F0ZS5tYXBfMC5pc0VtcHR5KCl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gcTYodGhpcy5rZXlJbmRleCl9LGwucHV0PWZ1bmN0aW9uKG4scil7dmFyIHQ7aWYodD1hKE4yKHRoaXMua2V5SW5kZXgsbiksMTcpLCF0KXRocm93IGIobmV3IEdlKHRoaXMuZ2V0S2V5Um9sZSgpKyIgIituKyIgbm90IGluICIrcTYodGhpcy5rZXlJbmRleCkpKTtyZXR1cm4gdGhpcy5zZXRWYWx1ZV8wKHQudmFsdWVfMCxyKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5SW5kZXguZGVsZWdhdGUubWFwXzAuc2l6ZV8xKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlL0FycmF5TWFwIiw4NDIpO2Z1bmN0aW9uIFVhZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMjAyMCwxLHt9LFVhZSksbC5hcHBseV8yPWZ1bmN0aW9uKG4pe3JldHVybiBHYWUodGhpcy4kJG91dGVyXzAsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlL0FycmF5TWFwLzBtZXRob2RyZWYkZ2V0RW50cnkkVHlwZSIsMjAyMCk7ZnVuY3Rpb24gV2FlKGUsbil7dGhpcy50aGlzJDExPWUsdGhpcy52YWwkaW5kZXgyPW59cCgyMDE4LDM1OCxyNixXYWUpLGwuZ2V0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIGdLZSh0aGlzLnRoaXMkMTEsdGhpcy52YWwkaW5kZXgyKX0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMTEuZ2V0VmFsdWVfMCh0aGlzLnZhbCRpbmRleDIpfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRoaXMkMTEuc2V0VmFsdWVfMCh0aGlzLnZhbCRpbmRleDIsbil9LGwudmFsJGluZGV4Mj0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlL0FycmF5TWFwLzEiLDIwMTgpO2Z1bmN0aW9uIGphZShlLG4pe3RoaXMudGhpcyQxMT1lLFA2LmNhbGwodGhpcyxuKX1wKDIwMTksMzk5LCRtLGphZSksbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gR2FlKHRoaXMudGhpcyQxMSxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkFycmF5VGFibGUvQXJyYXlNYXAvMiIsMjAxOSk7ZnVuY3Rpb24gVmFlKGUsbil7dGhpcy50aGlzJDAxPWUsSGFlLmNhbGwodGhpcyxlLmNvbHVtbktleVRvSW5kZXgpLHRoaXMucm93SW5kZXg9bn1wKDIwMTcsODQyLGgxLFZhZSksbC5nZXRLZXlSb2xlPWZ1bmN0aW9uKCl7cmV0dXJuIkNvbHVtbiJ9LGwuZ2V0VmFsdWVfMD1mdW5jdGlvbihuKXtyZXR1cm4gb2godGhpcy50aGlzJDAxLHRoaXMucm93SW5kZXgsbil9LGwuc2V0VmFsdWVfMD1mdW5jdGlvbihuLHIpe3JldHVybiBPYWUodGhpcy50aGlzJDAxLHRoaXMucm93SW5kZXgsbixyKX0sbC5yb3dJbmRleD0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlL1JvdyIsMjAxNyk7ZnVuY3Rpb24gaEtlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIG1LZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBPeihlKXt0aGlzLnRoaXMkMDE9ZSxIYWUuY2FsbCh0aGlzLGUucm93S2V5VG9JbmRleCl9cCg4NDMsODQyLGgxLE96KSxsLmdldFZhbHVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBWYWUodGhpcy50aGlzJDAxLG4pfSxsLnB1dD1mdW5jdGlvbihuLHIpe3JldHVybiBhKHIsODUpLGhLZSgpfSxsLnNldFZhbHVlXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gYShyLDg1KSxtS2UoKX0sbC5nZXRLZXlSb2xlPWZ1bmN0aW9uKCl7cmV0dXJuIlJvdyJ9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJBcnJheVRhYmxlL1Jvd01hcCIsODQzKTtmdW5jdGlvbiBENihlLG4pe2lmKGU9PW51bGwpdGhyb3cgYihuZXcgZGgoIm51bGwga2V5IGluIGVudHJ5OiBudWxsPSIrbikpO2lmKG49PW51bGwpdGhyb3cgYihuZXcgZGgoIm51bGwgdmFsdWUgaW4gZW50cnk6ICIrZSsiPW51bGwiKSl9ZnVuY3Rpb24gUGEoZSxuKXtpZihlPDApdGhyb3cgYihuZXcgR2UobisiIGNhbm5vdCBiZSBuZWdhdGl2ZSBidXQgd2FzOiAiK2UpKTtyZXR1cm4gZX1mdW5jdGlvbiBGNihlLG4scix0KXtyZXR1cm4gY3ooKHImS3MpPT0wLCJmbGF0TWFwIGRvZXMgbm90IHN1cHBvcnQgU1VCU0laRUQgY2hhcmFjdGVyaXN0aWMiKSxjeigociY0KT09MCwiZmxhdE1hcCBkb2VzIG5vdCBzdXBwb3J0IFNPUlRFRCBjaGFyYWN0ZXJpc3RpYyIpLHZuKGUpLHZuKG4pLG5ldyBubGUoZSxuLHIsdCl9ZnVuY3Rpb24gejYoZSxuLHIpe3JldHVybiBuZXcgWGFlKENlbihlKS5zcGxpdGVyYXRvcl8xKCkscixuKX1mdW5jdGlvbiBhQyhlLG4pe3JldHVybiB2bihlKSx2bihuKSxuZXcgcWFlKGUsbil9ZnVuY3Rpb24gTXooZSxuKXtmb3IoO2UudHJ5QWR2YW5jZShuKTspO31mdW5jdGlvbiBxYWUoZSxuKXt0aGlzLnZhbCRmcm9tU3BsaXRlcmF0b3IxPWUsdGhpcy52YWwkZnVuY3Rpb24yPW59cCgxMTU3LDEsSWEscWFlKSxsLmhhc0NoYXJhY3RlcmlzdGljcz1mdW5jdGlvbihuKXtyZXR1cm4odGhpcy52YWwkZnJvbVNwbGl0ZXJhdG9yMS5jaGFyYWN0ZXJpc3RpY3NfMCgpJi0yNjImbikhPTB9LGwuY2hhcmFjdGVyaXN0aWNzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWwkZnJvbVNwbGl0ZXJhdG9yMS5jaGFyYWN0ZXJpc3RpY3NfMCgpJi0yNjJ9LGwuZXN0aW1hdGVTaXplXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWwkZnJvbVNwbGl0ZXJhdG9yMS5lc3RpbWF0ZVNpemVfMCgpfSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7dGhpcy52YWwkZnJvbVNwbGl0ZXJhdG9yMS5mb3JFYWNoUmVtYWluaW5nKG5ldyBLYWUobix0aGlzLnZhbCRmdW5jdGlvbjIpKX0sbC50cnlBZHZhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnZhbCRmcm9tU3BsaXRlcmF0b3IxLnRyeUFkdmFuY2UobmV3IFlhZShuLHRoaXMudmFsJGZ1bmN0aW9uMikpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ29sbGVjdFNwbGl0ZXJhdG9ycy8xIiwxMTU3KTtmdW5jdGlvbiBZYWUoZSxuKXt0aGlzLmFjdGlvbl8wPWUsdGhpcy5mdW5jdGlvbl8xPW59cCgxMTU4LDEsSmUsWWFlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt0aGlzLmFjdGlvbl8wLmFjY2VwdCh0aGlzLmZ1bmN0aW9uXzEuYXBwbHlfMChuKSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJDb2xsZWN0U3BsaXRlcmF0b3JzLzEvbGFtYmRhJDAkVHlwZSIsMTE1OCk7ZnVuY3Rpb24gS2FlKGUsbil7dGhpcy5hY3Rpb25fMD1lLHRoaXMuZnVuY3Rpb25fMT1ufXAoMTE1OSwxLEplLEthZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7dGhpcy5hY3Rpb25fMC5hY2NlcHQodGhpcy5mdW5jdGlvbl8xLmFwcGx5XzAobikpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ29sbGVjdFNwbGl0ZXJhdG9ycy8xL2xhbWJkYSQxJFR5cGUiLDExNTkpO2Z1bmN0aW9uIFhhZShlLG4scil7dGhpcy52YWwkZnVuY3Rpb24yPW4sdGhpcy52YWwkZXh0cmFDaGFyYWN0ZXJpc3RpY3MzPXIsdGhpcy5kZWxlZ2F0ZT1lfXAoMTE1NCwxLElhLFhhZSksbC5oYXNDaGFyYWN0ZXJpc3RpY3M9ZnVuY3Rpb24obil7cmV0dXJuKCgxNjQ2NHx0aGlzLnZhbCRleHRyYUNoYXJhY3RlcmlzdGljczMpJm4pIT0wfSxsLmNoYXJhY3RlcmlzdGljc18wPWZ1bmN0aW9uKCl7cmV0dXJuIDE2NDY0fHRoaXMudmFsJGV4dHJhQ2hhcmFjdGVyaXN0aWNzM30sbC5lc3RpbWF0ZVNpemVfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlLmVzdGltYXRlU2l6ZV8wKCl9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt0aGlzLmRlbGVnYXRlLmZvckVhY2hSZW1haW5pbmdfMChuZXcgWmFlKG4sdGhpcy52YWwkZnVuY3Rpb24yKSl9LGwudHJ5QWR2YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS50cnlBZHZhbmNlXzAobmV3IEphZShuLHRoaXMudmFsJGZ1bmN0aW9uMikpfSxsLnZhbCRleHRyYUNoYXJhY3RlcmlzdGljczM9MCxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ29sbGVjdFNwbGl0ZXJhdG9ycy8xV2l0aENoYXJhY3RlcmlzdGljcyIsMTE1NCk7ZnVuY3Rpb24gSmFlKGUsbil7dGhpcy5hY3Rpb25fMD1lLHRoaXMuZnVuY3Rpb25fMT1ufXAoMTE1NSwxLFdTLEphZSksbC5hY2NlcHRfMD1mdW5jdGlvbihuKXt0aGlzLmFjdGlvbl8wLmFjY2VwdCh0aGlzLmZ1bmN0aW9uXzEuYXBwbHlfMihuKSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJDb2xsZWN0U3BsaXRlcmF0b3JzLzFXaXRoQ2hhcmFjdGVyaXN0aWNzL2xhbWJkYSQwJFR5cGUiLDExNTUpO2Z1bmN0aW9uIFphZShlLG4pe3RoaXMuYWN0aW9uXzA9ZSx0aGlzLmZ1bmN0aW9uXzE9bn1wKDExNTYsMSxXUyxaYWUpLGwuYWNjZXB0XzA9ZnVuY3Rpb24obil7dGhpcy5hY3Rpb25fMC5hY2NlcHQodGhpcy5mdW5jdGlvbl8xLmFwcGx5XzIobikpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ29sbGVjdFNwbGl0ZXJhdG9ycy8xV2l0aENoYXJhY3RlcmlzdGljcy9sYW1iZGEkMSRUeXBlIiwxMTU2KTtmdW5jdGlvbiB5S2UoZSxuKXtyZXR1cm4gZS5wcmVmaXg9YShlLmZ1bmN0aW9uXzAuYXBwbHlfMChuKSwxNTkpfWZ1bmN0aW9uIHdLZShlLG4scil7dmFyIHQ7dD1hKGUuZnVuY3Rpb25fMC5hcHBseV8wKHIpLDE1OSksdCYmdC5mb3JFYWNoUmVtYWluaW5nKG4pfXAoMTE1MCwxLElhKSxsLmhhc0NoYXJhY3RlcmlzdGljcz1mdW5jdGlvbihuKXtyZXR1cm4odGhpcy5jaGFyYWN0ZXJpc3RpY3MmbikhPTB9LGwuY2hhcmFjdGVyaXN0aWNzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFyYWN0ZXJpc3RpY3N9LGwuZXN0aW1hdGVTaXplXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVmaXgmJih0aGlzLmVzdGltYXRlZFNpemU9bkIodGhpcy5lc3RpbWF0ZWRTaXplLHRoaXMucHJlZml4LmVzdGltYXRlU2l6ZV8wKCkpKSxuQih0aGlzLmVzdGltYXRlZFNpemUsMCl9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt0aGlzLnByZWZpeCYmKHRoaXMucHJlZml4LmZvckVhY2hSZW1haW5pbmcobiksdGhpcy5wcmVmaXg9bnVsbCksdGhpcy5mcm9tLmZvckVhY2hSZW1haW5pbmcobmV3IGVsZSh0aGlzLG4pKSx0aGlzLmVzdGltYXRlZFNpemU9MH0sbC50cnlBZHZhbmNlPWZ1bmN0aW9uKG4pe2Zvcig7Oyl7aWYodGhpcy5wcmVmaXgmJnRoaXMucHJlZml4LnRyeUFkdmFuY2UobikpcmV0dXJuIFIyKHRoaXMuZXN0aW1hdGVkU2l6ZSxqUykmJih0aGlzLmVzdGltYXRlZFNpemU9aGwodGhpcy5lc3RpbWF0ZWRTaXplLDEpKSwhMDtpZih0aGlzLnByZWZpeD1udWxsLCF0aGlzLmZyb20udHJ5QWR2YW5jZShuZXcgUWFlKHRoaXMpKSlyZXR1cm4hMX19LGwuY2hhcmFjdGVyaXN0aWNzPTAsbC5lc3RpbWF0ZWRTaXplPTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkNvbGxlY3RTcGxpdGVyYXRvcnMvRmxhdE1hcFNwbGl0ZXJhdG9yIiwxMTUwKTtmdW5jdGlvbiBRYWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDExNTIsMSxKZSxRYWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3lLZSh0aGlzLiQkb3V0ZXJfMCxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkNvbGxlY3RTcGxpdGVyYXRvcnMvRmxhdE1hcFNwbGl0ZXJhdG9yL2xhbWJkYSQwJFR5cGUiLDExNTIpO2Z1bmN0aW9uIGVsZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5hY3Rpb25fMT1ufXAoMTE1MywxLEplLGVsZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7d0tlKHRoaXMuJCRvdXRlcl8wLHRoaXMuYWN0aW9uXzEsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJDb2xsZWN0U3BsaXRlcmF0b3JzL0ZsYXRNYXBTcGxpdGVyYXRvci9sYW1iZGEkMSRUeXBlIiwxMTUzKTtmdW5jdGlvbiBubGUoZSxuLHIsdCl7dGhpcy5wcmVmaXg9bnVsbCx0aGlzLmZyb209ZSx0aGlzLmZ1bmN0aW9uXzA9bix0aGlzLmNoYXJhY3RlcmlzdGljcz1yLHRoaXMuZXN0aW1hdGVkU2l6ZT10fXAoMTE1MSwxMTUwLElhLG5sZSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkNvbGxlY3RTcGxpdGVyYXRvcnMvRmxhdE1hcFNwbGl0ZXJhdG9yT2ZPYmplY3QiLDExNTEpO2Z1bmN0aW9uIFJ6KGUsbil7dm4oZSk7dHJ5e3JldHVybiBlLmNvbnRhaW5zKG4pfWNhdGNoKHIpe2lmKHI9d3IociksTChyLDIxMil8fEwociwxNjkpKXJldHVybiExO3Rocm93IGIocil9fWZ1bmN0aW9uIEVLZShlLG4pe3ZuKGUpO3RyeXtyZXR1cm4gZS5yZW1vdmVfMShuKX1jYXRjaChyKXtpZihyPXdyKHIpLEwociwyMTIpfHxMKHIsMTY5KSlyZXR1cm4hMTt0aHJvdyBiKHIpfX1mdW5jdGlvbiBEeihlLG4pe3ZhciByLHQ7aWYoTChuLDI1Mykpe3Q9YShuLDI1Myk7dHJ5e3JldHVybiByPWUuY29tcGFyZVRvKHQpLHI9PTB9Y2F0Y2gobyl7aWYobz13cihvKSxMKG8sMjEyKSlyZXR1cm4hMTt0aHJvdyBiKG8pfX1yZXR1cm4hMX1mdW5jdGlvbiAkNihlKXt0aGlzLmVuZHBvaW50PWV9cCgyNTMsMSx0NiksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5jb21wYXJlVG8oYShuLDI1MykpfSxsLmNvbXBhcmVUbz1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gbj09KEg2KCksVTYpPzE6bj09KEI2KCksRzYpPy0xOihyPSh2SSgpLHdDKHRoaXMuZW5kcG9pbnQsbi5lbmRwb2ludCkpLHIhPTA/cjpMKHRoaXMsNTI2KT09TChuLDUyNik/MDpMKHRoaXMsNTI2KT8xOi0xKX0sbC5lbmRwb2ludF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kcG9pbnR9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIER6KHRoaXMsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJDdXQiLDI1Myk7ZnVuY3Rpb24gQjYoKXtCNj1GLEc2PW5ldyBybGV9ZnVuY3Rpb24gcmxlKCl7JDYuY2FsbCh0aGlzLCIiKX1wKDE4MjMsMjUzLHQ2LHJsZSksbC5jb21wYXJlVG89ZnVuY3Rpb24obil7cmV0dXJuIG49PXRoaXM/MDoxfSxsLmRlc2NyaWJlQXNMb3dlckJvdW5kPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3ICQkKX0sbC5kZXNjcmliZUFzVXBwZXJCb3VuZD1mdW5jdGlvbihuKXtuLnN0cmluZys9IiviiJ4pIn0sbC5lbmRwb2ludF8wPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgcm8oInJhbmdlIHVuYm91bmRlZCBvbiB0aGlzIHNpZGUiKSl9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBuYygpLFpHKHRoaXMpfSxsLmlzTGVzc1RoYW49ZnVuY3Rpb24obil7cmV0dXJuITF9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiIr4oieIn07dmFyIEc2O2coImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJDdXQvQWJvdmVBbGwiLDE4MjMpO2Z1bmN0aW9uIHRsZShlKXskNi5jYWxsKHRoaXMsYSh2bihlKSwzNCkpfXAoNTI2LDI1Myx7MjUzOjEsNTI2OjEsMzoxLDM0OjF9LHRsZSksbC5kZXNjcmliZUFzTG93ZXJCb3VuZD1mdW5jdGlvbihuKXtlaSgobi5zdHJpbmcrPSIoIixuKSx0aGlzLmVuZHBvaW50KX0sbC5kZXNjcmliZUFzVXBwZXJCb3VuZD1mdW5jdGlvbihuKXt4XyhlaShuLHRoaXMuZW5kcG9pbnQpLDkzKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJufnVyKHRoaXMuZW5kcG9pbnQpfSxsLmlzTGVzc1RoYW49ZnVuY3Rpb24obil7cmV0dXJuIHZJKCksd0ModGhpcy5lbmRwb2ludCxuKTwwfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iLyIrdGhpcy5lbmRwb2ludCsiXFwifSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ3V0L0Fib3ZlVmFsdWUiLDUyNik7ZnVuY3Rpb24gSDYoKXtINj1GLFU2PW5ldyBvbGV9ZnVuY3Rpb24gb2xlKCl7JDYuY2FsbCh0aGlzLCIiKX1wKDE4MjIsMjUzLHQ2LG9sZSksbC5jb21wYXJlVG89ZnVuY3Rpb24obil7cmV0dXJuIG49PXRoaXM/MDotMX0sbC5kZXNjcmliZUFzTG93ZXJCb3VuZD1mdW5jdGlvbihuKXtuLnN0cmluZys9Iigt4oieIn0sbC5kZXNjcmliZUFzVXBwZXJCb3VuZD1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyAkJCl9LGwuZW5kcG9pbnRfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IHJvKCJyYW5nZSB1bmJvdW5kZWQgb24gdGhpcyBzaWRlIikpfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gbmMoKSxaRyh0aGlzKX0sbC5pc0xlc3NUaGFuPWZ1bmN0aW9uKG4pe3JldHVybiEwfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iLeKIniJ9O3ZhciBVNjtnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiQ3V0L0JlbG93QWxsIiwxODIyKTtmdW5jdGlvbiBpbGUoZSl7JDYuY2FsbCh0aGlzLGEodm4oZSksMzQpKX1wKDE4MjQsMjUzLHQ2LGlsZSksbC5kZXNjcmliZUFzTG93ZXJCb3VuZD1mdW5jdGlvbihuKXtlaSgobi5zdHJpbmcrPSJbIixuKSx0aGlzLmVuZHBvaW50KX0sbC5kZXNjcmliZUFzVXBwZXJCb3VuZD1mdW5jdGlvbihuKXt4XyhlaShuLHRoaXMuZW5kcG9pbnQpLDQxKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMuZW5kcG9pbnQpfSxsLmlzTGVzc1RoYW49ZnVuY3Rpb24obil7cmV0dXJuIHZJKCksd0ModGhpcy5lbmRwb2ludCxuKTw9MH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIlxcIit0aGlzLmVuZHBvaW50KyIvIn0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkN1dC9CZWxvd1ZhbHVlIiwxODI0KTtmdW5jdGlvbiBXNigpe3YyKCl9ZnVuY3Rpb24gTmEoZSl7dmFyIG4scix0LG87Zm9yKHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSx2bihuKTtyZXR1cm4gbmV3IGFsZShlKX1wKDU0NywxLFR1KSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gaktlKGEobkkodGhpcywidXNlIE9wdGlvbmFsLm9yTnVsbCgpIGluc3RlYWQgb2YgT3B0aW9uYWwub3IobnVsbCkiKSwyMCkuaXRlcmF0b3JfMCgpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZsdWVudEl0ZXJhYmxlIiw1NDcpO2Z1bmN0aW9uIFAyKGUpe3RoaXMudmFsJGlucHV0czE9ZSxXNi5jYWxsKHRoaXMpfXAoNDQyLDU0NyxUdSxQMiksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBYZShRZSh0aGlzLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZsdWVudEl0ZXJhYmxlLzIiLDQ0Mik7ZnVuY3Rpb24gUHUoZSl7cmV0dXJuIG5ldyBYZShuZXcgRnooZS52YWwkaW5wdXRzMS5sZW5ndGgsZS52YWwkaW5wdXRzMSkpfWZ1bmN0aW9uIGFsZShlKXt0aGlzLnZhbCRpbnB1dHMxPWUsVzYuY2FsbCh0aGlzKX1wKDEwNTksNTQ3LFR1LGFsZSksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIFB1KHRoaXMpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiRmx1ZW50SXRlcmFibGUvMyIsMTA1OSk7ZnVuY3Rpb24gRnooZSxuKXt0aGlzLnZhbCRpbnB1dHMzPW4sUDYuY2FsbCh0aGlzLGUpfXAoNzI0LDM5OSwkbSxGeiksbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy52YWwkaW5wdXRzM1tuXS5pdGVyYXRvcl8wKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJGbHVlbnRJdGVyYWJsZS8zLzEiLDcyNCkscCgyMDcwLDEse30pLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB2byh0aGlzLmRlbGVnYXRlXzAoKS5jb2xsKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZvcndhcmRpbmdPYmplY3QiLDIwNzApLHAoMjA3MSwyMDcwLG5pZSksbC5kZWxlZ2F0ZV8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMSgpfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLnBhcmFsbGVsU3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyZWFtKCl9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywwKX0sbC5zdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNlKG51bGwsdGhpcy5zcGxpdGVyYXRvcl8wKCkpfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlXzEoKSxkMGUoKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMSgpLGYwZSgpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLmRlbGVnYXRlXzEoKSxwMGUoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZV8xKCkuY29udGFpbnMobil9LGwuY29udGFpbnNBbGw9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMSgpLmNvbnRhaW5zQWxsKG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZV8xKCkuY29sbC5pc0VtcHR5KCl9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlXzEoKS5pdGVyYXRvcl8wKCl9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMSgpLGgwZSgpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlXzEoKS5jb2xsLnNpemVfMSgpfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZV8xKCkudG9BcnJheSgpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZV8xKCkudG9BcnJheV8wKG4pfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiRm9yd2FyZGluZ0NvbGxlY3Rpb24iLDIwNzEpO2Z1bmN0aW9uIHJ1KCl7cnU9RixuZXcgenooKE5lKCksTmUoKSxPdCkpfXAoMjA3OCwzMSxCRiksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3JfMSgpfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmFzTGlzdF8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5hc0xpc3RfMCxufHwodGhpcy5hc0xpc3RfMD10aGlzLmNyZWF0ZUFzTGlzdCgpKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBuIT1udWxsJiZZZCh0aGlzLG4sITEpfSxsLmNyZWF0ZUFzTGlzdD1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLnNpemVfMSgpKXtjYXNlIDA6cmV0dXJuIHkxKCkseTEoKSxWNjtjYXNlIDE6cmV0dXJuIHkxKCksbmV3IHA1KHZuKHRoaXMuaXRlcmF0b3JfMSgpLm5leHRfMSgpKSk7ZGVmYXVsdDpyZXR1cm4gbmV3IHIkKHRoaXMsdGhpcy50b0FycmF5KCkpfX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVDb2xsZWN0aW9uIiwyMDc4KTtmdW5jdGlvbiB6eihlKXtydSgpLHRoaXMuZGVsZWdhdGU9ZX1wKDcyNywyMDc4LEJGLHp6KSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYWgodGhpcy5kZWxlZ2F0ZS5pdGVyYXRvcl8wKCkpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBuIT1udWxsJiZ0aGlzLmRlbGVnYXRlLmNvbnRhaW5zKG4pfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlLmNvbnRhaW5zQWxsKG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS5pc0VtcHR5KCl9LGwuaXRlcmF0b3JfMT1mdW5jdGlvbigpe3JldHVybiBhaCh0aGlzLmRlbGVnYXRlLml0ZXJhdG9yXzAoKSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUuc2l6ZV8xKCl9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlLnRvQXJyYXkoKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGUudG9BcnJheV8wKG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdm8odGhpcy5kZWxlZ2F0ZSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJGb3J3YXJkaW5nSW1tdXRhYmxlQ29sbGVjdGlvbiIsNzI3KTtmdW5jdGlvbiB5MSgpe3kxPUYscnUoKSxWNj1uZXcgZDUoKE5lKCksTmUoKSxPdCkpfWZ1bmN0aW9uIGo2KGUsbil7cmV0dXJuIG5ldyBJbGUoZSxlLnNpemVfMSgpLG4pfWZ1bmN0aW9uIHZLZShlKXt2YXIgbjtyZXR1cm4gbj0odm4oZSksZT9uZXcgUWkoZSk6UW0oZS5pdGVyYXRvcl8wKCkpKSxPQyhuKSxzSShuKX1mdW5jdGlvbiAkeihlKXt5MSgpO3ZhciBuO3N3aXRjaChuPWUudG9BcnJheSgpLG4ubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIFY2O2Nhc2UgMTpyZXR1cm4gbmV3IHA1KHZuKG5bMF0pKTtkZWZhdWx0OnJldHVybiBuZXcgZDUoU0tlKG4pKX19ZnVuY3Rpb24gU0tlKGUpe3ZhciBuLHIsdDtmb3Iocj0wLHQ9ZS5sZW5ndGg7cjx0O3IrKylpZihlW3JdPT1udWxsKXRocm93IGIobmV3IGRoKCJhdCBpbmRleCAiK3IpKTtyZXR1cm4gbj1lLG5ldyBlYShuKX1mdW5jdGlvbiBzSShlKXt2YXIgbjtzd2l0Y2goZS5zaXplXzEoKSl7Y2FzZSAwOnJldHVybiBWNjtjYXNlIDE6cmV0dXJuIG5ldyBwNSh2bihlLmdldF8wKDApKSk7ZGVmYXVsdDpyZXR1cm4gbj1lLG5ldyBkNShuKX19cCgzMDcsMjA3OCxCbSksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3JfMSgpfSxsLmxpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlzdEl0ZXJhdG9yXzIoMCl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubGlzdEl0ZXJhdG9yXzIobil9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3dfKHRoaXMsbil9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLnN1Ykxpc3RfMChuLHIpfSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLmFzTGlzdF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHJYZSh0aGlzLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdFhlKHRoaXMpfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXtyZXR1cm4gbj09bnVsbD8tMTpvWGUodGhpcyxuKX0sbC5pdGVyYXRvcl8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlzdEl0ZXJhdG9yXzIoMCl9LGwubGlzdEl0ZXJhdG9yXzI9ZnVuY3Rpb24obil7cmV0dXJuIGo2KHRoaXMsbil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLnN1Ykxpc3RfMD1mdW5jdGlvbihuLHIpe3ZhciB0O3JldHVybiBzSSgodD1uZXcgd3NlKHRoaXMpLG5ldyBPYyh0LG4scikpKX07dmFyIFY2O2coImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVMaXN0IiwzMDcpO2Z1bmN0aW9uIHkwKGUsbil7cmV0dXJuIGUuZGVsZWdhdGVMaXN0XzAoKS5nZXRfMChuKX1wKDIxMDUsMzA3LEJtKSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYWgodGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLml0ZXJhdG9yXzAoKSl9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiBzSSh0aGlzLmRlbGVnYXRlTGlzdF8wKCkuc3ViTGlzdChuLHIpKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gbiE9bnVsbCYmdGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLmNvbnRhaW5zKG4pfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8wKCkuY29udGFpbnNBbGwobil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIFluKHRoaXMuZGVsZWdhdGVMaXN0XzAoKSxuKX0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4geTAodGhpcyxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMuZGVsZWdhdGVMaXN0XzAoKSl9LGwuaW5kZXhPZl8wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8wKCkuaW5kZXhPZl8wKG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLmlzRW1wdHkoKX0sbC5pdGVyYXRvcl8xPWZ1bmN0aW9uKCl7cmV0dXJuIGFoKHRoaXMuZGVsZWdhdGVMaXN0XzAoKS5pdGVyYXRvcl8wKCkpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8wKCkuc2l6ZV8xKCl9LGwuc3ViTGlzdF8wPWZ1bmN0aW9uKG4scil7cmV0dXJuIHNJKHRoaXMuZGVsZWdhdGVMaXN0XzAoKS5zdWJMaXN0KG4scikpfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLnRvQXJyYXlfMChCKFFyLE1lLDEsdGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpLDUsMSkpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMCgpLnRvQXJyYXlfMChuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHZvKHRoaXMuZGVsZWdhdGVMaXN0XzAoKSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJGb3J3YXJkaW5nSW1tdXRhYmxlTGlzdCIsMjEwNSk7ZnVuY3Rpb24gdUkoKXt1ST1GLGxsZT1uZXcgbyQoUChJKEVfLDEpLEhiLDQ0LDAsW10pKX1mdW5jdGlvbiBTXyhlKXtyZXR1cm4gZS5jYWNoZWRFbnRyeVNldD9lLmNhY2hlZEVudHJ5U2V0OmUuY2FjaGVkRW50cnlTZXQ9ZS5jcmVhdGVFbnRyeVNldF8xKCl9ZnVuY3Rpb24gcTYoZSl7cmV0dXJuIGUuY2FjaGVkS2V5U2V0P2UuY2FjaGVkS2V5U2V0OmUuY2FjaGVkS2V5U2V0PWUuY3JlYXRlS2V5U2V0XzEoKX1mdW5jdGlvbiBDS2UoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gVEtlKGUpe3VJKCk7dmFyIG4scix0O3N3aXRjaCh0PWUuYXJyYXkubGVuZ3RoLHQpe2Nhc2UgMDpyZXR1cm4gbGxlO2Nhc2UgMTpyZXR1cm4gbj1hKFVsZShuZXcgVChlKSksNDQpLGJLZShuLmdldEtleSgpLG4uZ2V0VmFsdWUoKSk7ZGVmYXVsdDpyZXR1cm4gcj1hKElzKGUsQihFXyxIYiw0NCxlLmFycmF5Lmxlbmd0aCwwLDEpKSwxNzMpLG5ldyB0JChyKX19ZnVuY3Rpb24gYktlKGUsbil7cmV0dXJuIHVJKCksRDYoZSxuKSxuZXcgZXVlKGUsbil9ZnVuY3Rpb24gSUtlKGUsbixyLHQpe3JldHVybiB1SSgpLG5ldyBvJChQKEkoRV8sMSksSGIsNDQsMCxbKEQ2KGUsbiksbmV3IHcxKGUsbikpLChENihyLHQpLG5ldyB3MShyLHQpKV0pKX1wKDcyOSwxLEdtKSxsLmVudHJ5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gU18odGhpcyl9LGwuZm9yRWFjaD1mdW5jdGlvbihuKXtUMih0aGlzLG4pfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHE2KHRoaXMpfSxsLm1lcmdlPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gTDYodGhpcyxuLHIsdCl9LGwudmFsdWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXNfMigpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZ2V0XzMobikhPW51bGx9LGwuY29udGFpbnNWYWx1ZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy52YWx1ZXNfMigpLmNvbnRhaW5zKG4pfSxsLmNyZWF0ZUtleVNldF8xPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMbGUodGhpcyl9LGwuY3JlYXRlVmFsdWVzPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBPbGUodGhpcyl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIGFYZSh0aGlzLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gU18odGhpcykuaGFzaENvZGVfMSgpfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzEoKT09MH0sbC5wdXQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gQ0tlKCl9LGwucmVtb3ZlXzA9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdVhlKHRoaXMpfSxsLnZhbHVlc18yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FjaGVkVmFsdWVzP3RoaXMuY2FjaGVkVmFsdWVzOnRoaXMuY2FjaGVkVmFsdWVzPXRoaXMuY3JlYXRlVmFsdWVzKCl9LGwuY2FjaGVkRW50cnlTZXQ9bnVsbCxsLmNhY2hlZEtleVNldD1udWxsLGwuY2FjaGVkVmFsdWVzPW51bGw7dmFyIGxsZTtnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW1tdXRhYmxlTWFwIiw3MjkpO2Z1bmN0aW9uIHNsZShlLG4pe3JldHVybiBUc2UoZS5kZWxlZ2F0ZSxuKX1mdW5jdGlvbiBOMihlLG4pe3JldHVybiBuPT1udWxsP251bGw6WGQoZS5kZWxlZ2F0ZSxuKX1mdW5jdGlvbiB4S2UoZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKG49bmV3IERjLHQ9ZSxvPTAsaT10Lmxlbmd0aDtvPGk7KytvKWlmKHI9dFtvXSxzPXZuKHIuZ2V0S2V5KCkpLHU9UmMobixzLHZuKHIuZ2V0VmFsdWUoKSkpLHUhPW51bGwpdGhyb3cgYihuZXcgR2UoImR1cGxpY2F0ZSBrZXk6ICIrcykpO3RoaXMuZGVsZWdhdGU9KE5lKCksbmV3IFE1KG4pKX1wKDczMCw3MjksR20pLGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIHNsZSh0aGlzLG4pfSxsLmNvbnRhaW5zVmFsdWU9ZnVuY3Rpb24obil7cmV0dXJuIHcwZSh0aGlzLmRlbGVnYXRlLG4pfSxsLmNyZWF0ZUVudHJ5U2V0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gY2xlKG5ldyB1bGUodGhpcykpfSxsLmNyZWF0ZUtleVNldF8xPWZ1bmN0aW9uKCl7cmV0dXJuIGNsZSh2MGUodGhpcy5kZWxlZ2F0ZSkpfSxsLmNyZWF0ZVZhbHVlcz1mdW5jdGlvbigpe3JldHVybiBydSgpLG5ldyB6eihTMGUodGhpcy5kZWxlZ2F0ZSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBFMGUodGhpcy5kZWxlZ2F0ZSxuKX0sbC5nZXRfMz1mdW5jdGlvbihuKXtyZXR1cm4gTjIodGhpcyxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMuZGVsZWdhdGUubWFwXzApfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS5tYXBfMC5pc0VtcHR5KCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUubWFwXzAuc2l6ZV8xKCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB2byh0aGlzLmRlbGVnYXRlLm1hcF8wKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZvcndhcmRpbmdJbW11dGFibGVNYXAiLDczMCkscCgyMDcyLDIwNzEsbzYpLGwuZGVsZWdhdGVfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlXzIoKX0sbC5kZWxlZ2F0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMigpfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHhlKHRoaXMsMSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIG49PT10aGlzfHx0aGlzLmRlbGVnYXRlXzIoKS5lcXVhbHNfMChuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVfMigpLmhhc2hDb2RlXzEoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZvcndhcmRpbmdTZXQiLDIwNzIpO2Z1bmN0aW9uIHVsZShlKXt0aGlzLnRoaXMkMDE9ZX1wKDEwODUsMjA3MixvNix1bGUpLGwuZGVsZWdhdGVfMD1mdW5jdGlvbigpe3JldHVybiBoeSh0aGlzLnRoaXMkMDEuZGVsZWdhdGUpfSxsLmRlbGVnYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gaHkodGhpcy50aGlzJDAxLmRlbGVnYXRlKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtpZihMKG4sNDQpJiZhKG4sNDQpLmdldEtleSgpPT1udWxsKXJldHVybiExO3RyeXtyZXR1cm4gQzBlKGh5KHRoaXMudGhpcyQwMS5kZWxlZ2F0ZSksbil9Y2F0Y2gocil7aWYocj13cihyKSxMKHIsMjEyKSlyZXR1cm4hMTt0aHJvdyBiKHIpfX0sbC5kZWxlZ2F0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIGh5KHRoaXMudGhpcyQwMS5kZWxlZ2F0ZSl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPVQwZShoeSh0aGlzLnRoaXMkMDEuZGVsZWdhdGUpLG4pLGh5KHRoaXMudGhpcyQwMS5kZWxlZ2F0ZSkuY29sbC5zaXplXzEoKTxyLmxlbmd0aCYmVHIocixoeSh0aGlzLnRoaXMkMDEuZGVsZWdhdGUpLmNvbGwuc2l6ZV8xKCksbnVsbCkscn0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZvcndhcmRpbmdJbW11dGFibGVNYXAvMSIsMTA4NSk7ZnVuY3Rpb24gY2xlKGUpe3N3aXRjaChydSgpLGUuc2l6ZV8xKCkpe2Nhc2UgMDpyZXR1cm4gZjUoKSxhJDtjYXNlIDE6cmV0dXJuIG5ldyBsaChlLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSk7ZGVmYXVsdDpyZXR1cm4gbmV3IGkkKGUpfX1wKDIwNzksMjA3OCxRZyksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlcmF0b3JfMSgpfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHhlKHRoaXMsMSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIGwkKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBxc2UodGhpcyl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVTZXQiLDIwNzkpO2Z1bmN0aW9uIF9sZShlKXtydSgpLHRoaXMuZGVsZWdhdGU9KE5lKCksbmV3IG15KGUpKX1wKDcxOSwyMDc5LFFnKSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYWgobmV3IGd5KHRoaXMuZGVsZWdhdGUuY29sbC5pdGVyYXRvcl8wKCkpKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gbiE9bnVsbCYmTUModGhpcy5kZWxlZ2F0ZSxuKX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gZzBlKHRoaXMuZGVsZWdhdGUsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiB1cih0aGlzLmRlbGVnYXRlLmNvbGwpfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS5jb2xsLmlzRW1wdHkoKX0sbC5pdGVyYXRvcl8xPWZ1bmN0aW9uKCl7cmV0dXJuIGFoKG5ldyBneSh0aGlzLmRlbGVnYXRlLmNvbGwuaXRlcmF0b3JfMCgpKSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUuY29sbC5zaXplXzEoKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUuY29sbC50b0FycmF5KCl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiBtMGUodGhpcy5kZWxlZ2F0ZSxuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHZvKHRoaXMuZGVsZWdhdGUuY29sbCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJGb3J3YXJkaW5nSW1tdXRhYmxlU2V0Iiw3MTkpLHAoMjA3MywyMDcyLHJpZSksbC5kZWxlZ2F0ZV8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5tb2RpZmlhYmxlRGVsZWdhdGV9LGwuZGVsZWdhdGVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVubW9kaWZpYWJsZURlbGVnYXRlfSxsLmRlbGVnYXRlXzI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bm1vZGlmaWFibGVEZWxlZ2F0ZX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBseCh0aGlzKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkZvcndhcmRpbmdTb3J0ZWRTZXQiLDIwNzMpO2Z1bmN0aW9uIGxDKGUpe2Uuc2l6ZV8wPTAsTEMoZS5oYXNoVGFibGVLVG9WLG51bGwpLExDKGUuaGFzaFRhYmxlVlRvSyxudWxsKSxlLmZpcnN0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLGUubGFzdEluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCwrK2UubW9kQ291bnR9ZnVuY3Rpb24gZGxlKGUsbil7cmV0dXJuISFMMihlLG4sU24oQXQoYnUsTHUoU24oQXQobj09bnVsbD8wOnVyKG4pLEl1KSksMTUpKSkpfWZ1bmN0aW9uIFRwKGUsbil7dmFyIHIsdCxvLGkscztmb3Iobz1uLmtleUhhc2gmZS5tYXNrLGk9bnVsbCx0PWUuaGFzaFRhYmxlS1RvVltvXTs7dD10Lm5leHRJbktUb1ZCdWNrZXQpe2lmKHQ9PW4pe2k/aS5uZXh0SW5LVG9WQnVja2V0PW4ubmV4dEluS1RvVkJ1Y2tldDplLmhhc2hUYWJsZUtUb1Zbb109bi5uZXh0SW5LVG9WQnVja2V0O2JyZWFrfWk9dH1mb3Iocz1uLnZhbHVlSGFzaCZlLm1hc2ssaT1udWxsLHI9ZS5oYXNoVGFibGVWVG9LW3NdOztyPXIubmV4dEluVlRvS0J1Y2tldCl7aWYocj09bil7aT9pLm5leHRJblZUb0tCdWNrZXQ9bi5uZXh0SW5WVG9LQnVja2V0OmUuaGFzaFRhYmxlVlRvS1tzXT1uLm5leHRJblZUb0tCdWNrZXQ7YnJlYWt9aT1yfW4ucHJldkluS2V5SW5zZXJ0aW9uT3JkZXI/bi5wcmV2SW5LZXlJbnNlcnRpb25PcmRlci5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj1uLm5leHRJbktleUluc2VydGlvbk9yZGVyOmUuZmlyc3RJbktleUluc2VydGlvbk9yZGVyPW4ubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXIsbi5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj9uLm5leHRJbktleUluc2VydGlvbk9yZGVyLnByZXZJbktleUluc2VydGlvbk9yZGVyPW4ucHJldkluS2V5SW5zZXJ0aW9uT3JkZXI6ZS5sYXN0SW5LZXlJbnNlcnRpb25PcmRlcj1uLnByZXZJbktleUluc2VydGlvbk9yZGVyLC0tZS5zaXplXzAsKytlLm1vZENvdW50fWZ1bmN0aW9uIGZsZShlLG4pe3ZhciByO2Zvcih2bihuKSxyPWUuZmlyc3RJbktleUluc2VydGlvbk9yZGVyO3I7cj1yLm5leHRJbktleUluc2VydGlvbk9yZGVyKW4uYWNjZXB0XzEoci5rZXksci52YWx1ZV8wKX1mdW5jdGlvbiBicChlLG4pe3JldHVybiBjWGUoQTIoZSxuLFNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpKSl9ZnVuY3Rpb24gc0MoZSxuLHIpe3ZhciB0LG87dD1uLmtleUhhc2gmZS5tYXNrLG4ubmV4dEluS1RvVkJ1Y2tldD1lLmhhc2hUYWJsZUtUb1ZbdF0sZS5oYXNoVGFibGVLVG9WW3RdPW4sbz1uLnZhbHVlSGFzaCZlLm1hc2ssbi5uZXh0SW5WVG9LQnVja2V0PWUuaGFzaFRhYmxlVlRvS1tvXSxlLmhhc2hUYWJsZVZUb0tbb109bixyPyhuLnByZXZJbktleUluc2VydGlvbk9yZGVyPXIucHJldkluS2V5SW5zZXJ0aW9uT3JkZXIsbi5wcmV2SW5LZXlJbnNlcnRpb25PcmRlcj9uLnByZXZJbktleUluc2VydGlvbk9yZGVyLm5leHRJbktleUluc2VydGlvbk9yZGVyPW46ZS5maXJzdEluS2V5SW5zZXJ0aW9uT3JkZXI9bixuLm5leHRJbktleUluc2VydGlvbk9yZGVyPXIubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXIsbi5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj9uLm5leHRJbktleUluc2VydGlvbk9yZGVyLnByZXZJbktleUluc2VydGlvbk9yZGVyPW46ZS5sYXN0SW5LZXlJbnNlcnRpb25PcmRlcj1uKToobi5wcmV2SW5LZXlJbnNlcnRpb25PcmRlcj1lLmxhc3RJbktleUluc2VydGlvbk9yZGVyLG4ubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCxlLmxhc3RJbktleUluc2VydGlvbk9yZGVyP2UubGFzdEluS2V5SW5zZXJ0aW9uT3JkZXIubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXI9bjplLmZpcnN0SW5LZXlJbnNlcnRpb25PcmRlcj1uLGUubGFzdEluS2V5SW5zZXJ0aW9uT3JkZXI9biksKytlLnNpemVfMCwrK2UubW9kQ291bnR9ZnVuY3Rpb24gWTYoZSl7dmFyIG47cmV0dXJuIG49ZS5pbnZlcnNlLG58fChlLmludmVyc2U9bmV3IEo2KGUpKX1mdW5jdGlvbiBjSShlLG4scil7dmFyIHQsbyxpLHMsdTtpZih0PVNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpLHU9U24oQXQoYnUsTHUoU24oQXQocj09bnVsbD8wOnVyKHIpLEl1KSksMTUpKSksaT1BMihlLG4sdCksaSYmdT09aS52YWx1ZUhhc2gmJm51KHIsaS52YWx1ZV8wKSlyZXR1cm4gcjtpZihzPUwyKGUscix1KSxzKXRocm93IGIobmV3IEdlKCJ2YWx1ZSBhbHJlYWR5IHByZXNlbnQ6ICIrcikpO3JldHVybiBvPW5ldyBkSShuLHQscix1KSxpPyhUcChlLGkpLHNDKGUsbyxpKSxpLnByZXZJbktleUluc2VydGlvbk9yZGVyPW51bGwsaS5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLGkudmFsdWVfMCk6KHNDKGUsbyxudWxsKSxwbGUoZSksbnVsbCl9ZnVuY3Rpb24gUEtlKGUsbixyLHQpe3ZhciBvLGkscyx1LGM7aWYoYz1TbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSxvPVNuKEF0KGJ1LEx1KFNuKEF0KHI9PW51bGw/MDp1cihyKSxJdSkpLDE1KSkpLHU9TDIoZSxuLGMpLHM9QTIoZSxyLG8pLHUmJm89PXUua2V5SGFzaCYmbnUocix1LmtleSkpcmV0dXJuIHI7aWYocyYmIXQpdGhyb3cgYihuZXcgR2UoImtleSBhbHJlYWR5IHByZXNlbnQ6ICIrcikpO3JldHVybiB1JiZUcChlLHUpLHMmJlRwKGUscyksaT1uZXcgZEkocixvLG4sYyksc0MoZSxpLHMpLHMmJihzLnByZXZJbktleUluc2VydGlvbk9yZGVyPW51bGwscy5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsKSx1JiYodS5wcmV2SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLHUubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCkscGxlKGUpLHU/dS5rZXk6bnVsbH1mdW5jdGlvbiBwbGUoZSl7dmFyIG4scix0O2lmKHQ9ZS5oYXNoVGFibGVLVG9WLFRsZShlLnNpemVfMCx0Lmxlbmd0aCkpe2ZvcihyPXQubGVuZ3RoKjIsZS5oYXNoVGFibGVLVG9WPUIoWDYsVlMsMzAzLHIsMCwxKSxlLmhhc2hUYWJsZVZUb0s9QihYNixWUywzMDMsciwwLDEpLGUubWFzaz1yLTEsZS5zaXplXzA9MCxuPWUuZmlyc3RJbktleUluc2VydGlvbk9yZGVyO247bj1uLm5leHRJbktleUluc2VydGlvbk9yZGVyKXNDKGUsbixuKTsrK2UubW9kQ291bnR9fWZ1bmN0aW9uIEEyKGUsbixyKXt2YXIgdDtmb3IodD1lLmhhc2hUYWJsZUtUb1ZbciZlLm1hc2tdO3Q7dD10Lm5leHRJbktUb1ZCdWNrZXQpaWYocj09dC5rZXlIYXNoJiZudShuLHQua2V5KSlyZXR1cm4gdDtyZXR1cm4gbnVsbH1mdW5jdGlvbiBMMihlLG4scil7dmFyIHQ7Zm9yKHQ9ZS5oYXNoVGFibGVWVG9LW3ImZS5tYXNrXTt0O3Q9dC5uZXh0SW5WVG9LQnVja2V0KWlmKHI9PXQudmFsdWVIYXNoJiZudShuLHQudmFsdWVfMCkpcmV0dXJuIHQ7cmV0dXJuIG51bGx9ZnVuY3Rpb24gX0koKXt2YXIgZTtQYSgxNiwiZXhwZWN0ZWRTaXplIiksZT1DbGUoMTYpLHRoaXMuaGFzaFRhYmxlS1RvVj1CKFg2LFZTLDMwMyxlLDAsMSksdGhpcy5oYXNoVGFibGVWVG9LPUIoWDYsVlMsMzAzLGUsMCwxKSx0aGlzLmZpcnN0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLHRoaXMubGFzdEluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCx0aGlzLnNpemVfMD0wLHRoaXMubWFzaz1lLTEsdGhpcy5tb2RDb3VudD0wfXAoNTQzLDIwNzcsR20sX0kpLGwucHV0QWxsPWZ1bmN0aW9uKG4pe2IyKHRoaXMsbil9LGwudmFsdWVzXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmludmVyc2UsbmV3IFo2KG58fCh0aGlzLmludmVyc2U9bmV3IEo2KHRoaXMpKSl9LGwuY2xlYXJfMD1mdW5jdGlvbigpe2xDKHRoaXMpfSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiEhQTIodGhpcyxuLFNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpKX0sbC5jb250YWluc1ZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiBkbGUodGhpcyxuKX0sbC5lbnRyeUl0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBobGUodGhpcyx0aGlzKX0sbC5mb3JFYWNoPWZ1bmN0aW9uKG4pe2ZsZSh0aGlzLG4pfSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiBicCh0aGlzLG4pfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBRNih0aGlzKX0sbC5wdXQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gY0kodGhpcyxuLHIpfSxsLnJlbW92ZV8wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPUEyKHRoaXMsbixTbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSkscj8oVHAodGhpcyxyKSxyLnByZXZJbktleUluc2VydGlvbk9yZGVyPW51bGwsci5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLHIudmFsdWVfMCk6bnVsbH0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzB9LGwudmFsdWVzXzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmludmVyc2UsbmV3IFo2KG58fCh0aGlzLmludmVyc2U9bmV3IEo2KHRoaXMpKSl9LGwubWFzaz0wLGwubW9kQ291bnQ9MCxsLnNpemVfMD0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoQmlNYXAiLDU0Myk7ZnVuY3Rpb24gZ2xlKGUpe2lmKGUudGhpcyQwMS5tb2RDb3VudCE9ZS5leHBlY3RlZE1vZENvdW50KXRocm93IGIobmV3IFhhKTtyZXR1cm4hIWUubmV4dF8wJiZlLnJlbWFpbmluZz4wfWZ1bmN0aW9uIEs2KGUpe3RoaXMudGhpcyQwMT1lLHRoaXMubmV4dF8wPXRoaXMudGhpcyQwMS5maXJzdEluS2V5SW5zZXJ0aW9uT3JkZXIsdGhpcy5leHBlY3RlZE1vZENvdW50PXRoaXMudGhpcyQwMS5tb2RDb3VudCx0aGlzLnJlbWFpbmluZz10aGlzLnRoaXMkMDEuc2l6ZV8wfXAoNTQ0LDEsc3QpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiBnbGUodGhpcyl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7dmFyIG47aWYoIWdsZSh0aGlzKSl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIG49YSh3bCh0aGlzLm5leHRfMCksMzAzKSx0aGlzLm5leHRfMD1uLm5leHRJbktleUluc2VydGlvbk9yZGVyLHRoaXMudG9SZW1vdmU9biwtLXRoaXMucmVtYWluaW5nLHRoaXMub3V0cHV0XzAobil9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7aWYodGhpcy50aGlzJDAxLm1vZENvdW50IT10aGlzLmV4cGVjdGVkTW9kQ291bnQpdGhyb3cgYihuZXcgWGEpO2lmKCF0aGlzLnRvUmVtb3ZlKXRocm93IGIobmV3IHJvKCJubyBjYWxscyB0byBuZXh0KCkgc2luY2UgdGhlIGxhc3QgY2FsbCB0byByZW1vdmUoKSIpKTtUcCh0aGlzLnRoaXMkMDEsdGhpcy50b1JlbW92ZSksdGhpcy5leHBlY3RlZE1vZENvdW50PXRoaXMudGhpcyQwMS5tb2RDb3VudCx0aGlzLnRvUmVtb3ZlPW51bGx9LGwuZXhwZWN0ZWRNb2RDb3VudD0wLGwucmVtYWluaW5nPTAsbC50b1JlbW92ZT1udWxsLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoQmlNYXAvSXRyIiw1NDQpO2Z1bmN0aW9uIGhsZShlLG4pe3RoaXMudGhpcyQwMj1uLEs2LmNhbGwodGhpcyxlKX1wKDEwMjMsNTQ0LHN0LGhsZSksbC5vdXRwdXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IG1sZSh0aGlzLG4pfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSGFzaEJpTWFwLzEiLDEwMjMpO2Z1bmN0aW9uIG1sZShlLG4pe3RoaXMudGhpcyQxMT1lLHRoaXMuZGVsZWdhdGU9bn1wKExsLDM1OCxyNixtbGUpLGwuZ2V0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUua2V5fSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUudmFsdWVfMH0sbC5zZXRWYWx1ZT1mdW5jdGlvbihuKXt2YXIgcix0LG87cmV0dXJuIHQ9dGhpcy5kZWxlZ2F0ZS52YWx1ZV8wLG89U24oQXQoYnUsTHUoU24oQXQobj09bnVsbD8wOnVyKG4pLEl1KSksMTUpKSksbz09dGhpcy5kZWxlZ2F0ZS52YWx1ZUhhc2gmJihEKG4pPT09RCh0KXx8biE9bnVsbCYmWW4obix0KSk/bjooWWllKCFMMih0aGlzLnRoaXMkMTEudGhpcyQwMixuLG8pLG4pLFRwKHRoaXMudGhpcyQxMS50aGlzJDAyLHRoaXMuZGVsZWdhdGUpLHI9bmV3IGRJKHRoaXMuZGVsZWdhdGUua2V5LHRoaXMuZGVsZWdhdGUua2V5SGFzaCxuLG8pLHNDKHRoaXMudGhpcyQxMS50aGlzJDAyLHIsdGhpcy5kZWxlZ2F0ZSksdGhpcy5kZWxlZ2F0ZS5wcmV2SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLHRoaXMuZGVsZWdhdGUubmV4dEluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCx0aGlzLnRoaXMkMTEuZXhwZWN0ZWRNb2RDb3VudD10aGlzLnRoaXMkMTEudGhpcyQwMi5tb2RDb3VudCx0aGlzLnRoaXMkMTEudG9SZW1vdmU9PXRoaXMuZGVsZWdhdGUmJih0aGlzLnRoaXMkMTEudG9SZW1vdmU9ciksdGhpcy5kZWxlZ2F0ZT1yLHQpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSGFzaEJpTWFwLzEvTWFwRW50cnkiLExsKTtmdW5jdGlvbiB3MShlLG4pe3RoaXMua2V5PWUsdGhpcy52YWx1ZV8wPW59cCgyNDYsMzU4LHszNTg6MSwyNDY6MSwzOjEsNDQ6MX0sdzEpLGwuZ2V0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5zZXRWYWx1ZT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVFbnRyeSIsMjQ2KTtmdW5jdGlvbiBkSShlLG4scix0KXt3MS5jYWxsKHRoaXMsZSxyKSx0aGlzLmtleUhhc2g9bix0aGlzLnZhbHVlSGFzaD10fXAoMzAzLDI0Nix7MzU4OjEsMzAzOjEsMjQ2OjEsMzoxLDQ0OjF9LGRJKSxsLmtleUhhc2g9MCxsLnZhbHVlSGFzaD0wO3ZhciBYNj1nKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSGFzaEJpTWFwL0JpRW50cnkiLDMwMyk7ZnVuY3Rpb24gZkkoZSxuKXtyZXR1cm4gbFhlKEwyKGUudGhpcyQwMSxuLFNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpKSl9ZnVuY3Rpb24gSjYoZSl7dGhpcy50aGlzJDAxPWV9ZnVuY3Rpb24gTktlKGUsbixyKXtlLmFjY2VwdF8xKHIsbil9cCg2MTksMjA3NyxHbSxKNiksbC5wdXRBbGw9ZnVuY3Rpb24obil7YjIodGhpcyxuKX0sbC52YWx1ZXNfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgUTYodGhpcy50aGlzJDAxKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7bEModGhpcy50aGlzJDAxKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gZGxlKHRoaXMudGhpcyQwMSxuKX0sbC5lbnRyeUl0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB5bGUodGhpcyx0aGlzLnRoaXMkMDEpfSxsLmZvckVhY2g9ZnVuY3Rpb24obil7dm4obiksZmxlKHRoaXMudGhpcyQwMSxuZXcgdmxlKG4pKX0sbC5nZXRfMz1mdW5jdGlvbihuKXtyZXR1cm4gZkkodGhpcyxuKX0sbC5rZXlTZXRfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgWjYodGhpcyl9LGwucHV0PWZ1bmN0aW9uKG4scil7cmV0dXJuIFBLZSh0aGlzLnRoaXMkMDEsbixyLCExKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1MMih0aGlzLnRoaXMkMDEsbixTbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSkscj8oVHAodGhpcy50aGlzJDAxLHIpLHIucHJldkluS2V5SW5zZXJ0aW9uT3JkZXI9bnVsbCxyLm5leHRJbktleUluc2VydGlvbk9yZGVyPW51bGwsci5rZXkpOm51bGx9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzB9LGwudmFsdWVzXzE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFE2KHRoaXMudGhpcyQwMSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoQmlNYXAvSW52ZXJzZSIsNjE5KTtmdW5jdGlvbiB5bGUoZSxuKXt0aGlzLnRoaXMkMTE9ZSxLNi5jYWxsKHRoaXMsbil9cCgxMDIwLDU0NCxzdCx5bGUpLGwub3V0cHV0XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyB3bGUodGhpcyxuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkhhc2hCaU1hcC9JbnZlcnNlLzEiLDEwMjApO2Z1bmN0aW9uIHdsZShlLG4pe3RoaXMudGhpcyQyMT1lLHRoaXMuZGVsZWdhdGU9bn1wKDEwMjEsMzU4LHI2LHdsZSksbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZS52YWx1ZV8wfSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUua2V5fSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3ZhciByLHQsbztyZXR1cm4gbz10aGlzLmRlbGVnYXRlLmtleSxyPVNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpLHI9PXRoaXMuZGVsZWdhdGUua2V5SGFzaCYmKEQobik9PT1EKG8pfHxuIT1udWxsJiZZbihuLG8pKT9uOihZaWUoIUEyKHRoaXMudGhpcyQyMS50aGlzJDExLnRoaXMkMDEsbixyKSxuKSxUcCh0aGlzLnRoaXMkMjEudGhpcyQxMS50aGlzJDAxLHRoaXMuZGVsZWdhdGUpLHQ9bmV3IGRJKG4scix0aGlzLmRlbGVnYXRlLnZhbHVlXzAsdGhpcy5kZWxlZ2F0ZS52YWx1ZUhhc2gpLHRoaXMuZGVsZWdhdGU9dCxzQyh0aGlzLnRoaXMkMjEudGhpcyQxMS50aGlzJDAxLHQsbnVsbCksdGhpcy50aGlzJDIxLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy50aGlzJDIxLnRoaXMkMTEudGhpcyQwMS5tb2RDb3VudCxvKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkhhc2hCaU1hcC9JbnZlcnNlLzEvSW52ZXJzZUVudHJ5IiwxMDIxKTtmdW5jdGlvbiBaNihlKXt0aGlzLnRoaXMkMTE9ZSxpSS5jYWxsKHRoaXMsZSl9cCg2MjAsNTQyLERpLFo2KSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEVsZSh0aGlzLnRoaXMkMTEudGhpcyQwMSl9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9TDIodGhpcy50aGlzJDExLnRoaXMkMDEsbixTbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSkscj8oVHAodGhpcy50aGlzJDExLnRoaXMkMDEsciksITApOiExfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSGFzaEJpTWFwL0ludmVyc2UvSW52ZXJzZUtleVNldCIsNjIwKTtmdW5jdGlvbiBFbGUoZSl7SzYuY2FsbCh0aGlzLGUpfXAoMTAxOSw1NDQsc3QsRWxlKSxsLm91dHB1dF8wPWZ1bmN0aW9uKG4pe3JldHVybiBuLnZhbHVlXzB9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoQmlNYXAvSW52ZXJzZS9JbnZlcnNlS2V5U2V0LzEiLDEwMTkpO2Z1bmN0aW9uIHZsZShlKXt0aGlzLmFjdGlvbl8wPWV9cCgxMDIyLDEse30sdmxlKSxsLmFjY2VwdF8xPWZ1bmN0aW9uKG4scil7TktlKHRoaXMuYWN0aW9uXzAsbixyKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkhhc2hCaU1hcC9JbnZlcnNlL2xhbWJkYSQwJFR5cGUiLDEwMjIpO2Z1bmN0aW9uIFE2KGUpe3RoaXMudGhpcyQwMT1lLGlJLmNhbGwodGhpcyxlKX1wKDYxOCw1NDIsRGksUTYpLGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgU2xlKHRoaXMudGhpcyQwMSl9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9QTIodGhpcy50aGlzJDAxLG4sU24oQXQoYnUsTHUoU24oQXQobj09bnVsbD8wOnVyKG4pLEl1KSksMTUpKSkpLHI/KFRwKHRoaXMudGhpcyQwMSxyKSxyLnByZXZJbktleUluc2VydGlvbk9yZGVyPW51bGwsci5uZXh0SW5LZXlJbnNlcnRpb25PcmRlcj1udWxsLCEwKTohMX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkhhc2hCaU1hcC9LZXlTZXQiLDYxOCk7ZnVuY3Rpb24gU2xlKGUpe0s2LmNhbGwodGhpcyxlKX1wKDEwMTgsNTQ0LHN0LFNsZSksbC5vdXRwdXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gbi5rZXl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoQmlNYXAvS2V5U2V0LzEiLDEwMTgpO2Z1bmN0aW9uIEFLZShlKXtOei5jYWxsKHRoaXMsZSl9cCgxMTIzLDYyNyxmXyksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkhhc2hNdWx0aW1hcEd3dFNlcmlhbGl6YXRpb25EZXBlbmRlbmNpZXMiLDExMjMpO2Z1bmN0aW9uIEUxKCl7QUtlLmNhbGwodGhpcyxuZXcgRWgoS2QoMTIpKSksdXooITApLHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXk9Mn1wKDI3MSwxMTIzLGZfLEUxKSxsLmNyZWF0ZUNvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHJ4KEtkKHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXkpKX0sbC5jcmVhdGVDb2xsZWN0aW9uXzE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHJ4KEtkKHRoaXMuZXhwZWN0ZWRWYWx1ZXNQZXJLZXkpKX0sbC5leHBlY3RlZFZhbHVlc1BlcktleT0yLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJIYXNoTXVsdGltYXAiLDI3MSk7ZnVuY3Rpb24gQ2xlKGUpe3ZhciBuO3JldHVybiBlPVMuTWF0aC5tYXgoZSwyKSxuPVgkKGUpLGU+bj8objw8PTEsbj4wP246eTIpOm59ZnVuY3Rpb24gVGxlKGUsbil7cmV0dXJuIGU+biYmbjx5Mn1wKDIwOTcsMzA3LEJtKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlQ29sbGVjdGlvbigpLmNvbnRhaW5zKG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUNvbGxlY3Rpb24oKS5pc0VtcHR5KCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVDb2xsZWN0aW9uKCkuc2l6ZV8xKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVBc0xpc3QiLDIwOTcpO2Z1bmN0aW9uIExLZShlKXt0aGlzLmRlbGVnYXRlPShOZSgpLG5ldyBRNShlKSl9cCgyMDMwLDczMCxHbSksbC52YWx1ZXNfMj1mdW5jdGlvbigpe3JldHVybiBydSgpLG5ldyBsaCh0aGlzLnNpbmdsZVZhbHVlKX0sbC52YWx1ZXNfMD1mdW5jdGlvbigpe3JldHVybiBydSgpLG5ldyBsaCh0aGlzLnNpbmdsZVZhbHVlKX0sbC52YWx1ZXNfMT1mdW5jdGlvbigpe3JldHVybiBydSgpLG5ldyBsaCh0aGlzLnNpbmdsZVZhbHVlKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZUJpTWFwIiwyMDMwKSxwKDIwNzUsMSx7fSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZUNvbGxlY3Rpb24vQnVpbGRlciIsMjA3NSk7ZnVuY3Rpb24gYmxlKGUpe19sZS5jYWxsKHRoaXMsZSl9ZnVuY3Rpb24geGMoZSl7c3dpdGNoKHJ1KCksZS5zaXplXzApe2Nhc2UgMDpyZXR1cm4gZjUoKSxhJDtjYXNlIDE6cmV0dXJuIG5ldyBsaChVbGUobmV3IHdoKGUpKSk7ZGVmYXVsdDpyZXR1cm4gbmV3IGJsZShlKX19cCgxMDM1LDcxOSxRZyxibGUpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVFbnVtU2V0IiwxMDM1KTtmdW5jdGlvbiBJbGUoZSxuLHIpe3RoaXMudGhpcyQwMT1lLGZ6LmNhbGwodGhpcyxuLHIpfXAoOTgwLDM5OSwkbSxJbGUpLGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGhpcyQwMS5nZXRfMChuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZUxpc3QvMSIsOTgwKTtmdW5jdGlvbiB4bGUoZSl7dGhpcy5jb250ZW50cz0oUGEoZSwiaW5pdGlhbEFycmF5U2l6ZSIpLG5ldyBfaShlKSl9cCg5NzksMjA3NSx7fSx4bGUpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVMaXN0L0J1aWxkZXIiLDk3OSk7ZnVuY3Rpb24gZTUoZSl7dGhpcy52YWwkZW50cnlJdGVyYXRvcjI9ZX1wKDYyMywyMDQsem0sZTUpLGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGVudHJ5SXRlcmF0b3IyLmhhc05leHRfMCgpfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMudmFsJGVudHJ5SXRlcmF0b3IyLm5leHRfMSgpLDQ0KS5nZXRLZXkoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcC8xIiw2MjMpO2Z1bmN0aW9uIFBsZSgpe31wKDEwNTQsMSx7fSxQbGUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDQ0KS5nZXRLZXkoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcC8ybWV0aG9kcmVmJGdldEtleSRUeXBlIiwxMDU0KTtmdW5jdGlvbiBrS2UoZSxuLHIpe3JldHVybiBlZShlLmVudHJpZXNfMCwodUkoKSxENihuLHIpLG5ldyB3MShuLHIpKSksZX1mdW5jdGlvbiBObGUoZSl7dGhpcy5lbnRyaWVzXzA9KFBhKGUsImluaXRpYWxBcnJheVNpemUiKSxuZXcgX2koZSkpfXAoMTA1MywxLHt9LE5sZSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcC9CdWlsZGVyIiwxMDUzKSxwKDIwOTgsMjA3OSxRZyksbC5hc0xpc3RfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuYXNMaXN0LG58fCh0aGlzLmFzTGlzdD1uZXcgcjUodGhpcykpfSxsLmNyZWF0ZUFzTGlzdD1mdW5jdGlvbigpe3JldHVybiBuZXcgciQodGhpcyxJMih0aGlzLEIoUXIsTWUsMSx0aGlzLnNpemVfMSgpLDUsMSkpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZVNldC9DYWNoaW5nQXNMaXN0IiwyMDk4KSxwKDIwOTksMjA5OCxRZyksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49U18odGhpcy5tYXBfMCkuaXRlcmF0b3JfMSgpLG5ldyBlNShuKX0sbC5jcmVhdGVBc0xpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHI1KHRoaXMpfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXt2YXIgcix0O2Zvcih2bihuKSx0PXRoaXMuc2l6ZV8xKCkscj0wO3I8dDtyKyspbi5hY2NlcHQoYShTXyh0aGlzLm1hcF8wKS5hc0xpc3RfMSgpLmdldF8wKHIpLDQ0KS5nZXRLZXkoKSl9LGwuaXRlcmF0b3JfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuYXNMaXN0LGo2KG58fCh0aGlzLmFzTGlzdD1uZXcgcjUodGhpcykpLDApfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gejYodGhpcy5zaXplXzEoKSwxMjk2LG5ldyBEbGUodGhpcykpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW5kZXhlZEltbXV0YWJsZVNldCIsMjA5OSk7ZnVuY3Rpb24gQWxlKGUsbil7cmV0dXJuIGEoU18oZS5tYXBfMCkuYXNMaXN0XzEoKS5nZXRfMChuKSw0NCkuZ2V0S2V5KCl9ZnVuY3Rpb24gTGxlKGUpe3J1KCksdGhpcy5tYXBfMD1lfXAoMTIzMCwyMDk5LFFnLExsZSksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49U18odGhpcy5tYXBfMCkuaXRlcmF0b3JfMSgpLG5ldyBlNShuKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXBfMC5jb250YWluc0tleShuKX0sbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7dm4obiksVDIodGhpcy5tYXBfMCxuZXcga2xlKG4pKX0sbC5pdGVyYXRvcl8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49U18odGhpcy5tYXBfMCkuaXRlcmF0b3JfMSgpLG5ldyBlNShuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5zaXplXzEoKX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIGFDKFNfKHRoaXMubWFwXzApLnNwbGl0ZXJhdG9yXzAoKSxuZXcgUGxlKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcEtleVNldCIsMTIzMCk7ZnVuY3Rpb24ga2xlKGUpe3RoaXMuYWN0aW9uXzA9ZX1wKDEyMzEsMSx7fSxrbGUpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXtydSgpLHRoaXMuYWN0aW9uXzAuYWNjZXB0KG4pfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW1tdXRhYmxlTWFwS2V5U2V0L2xhbWJkYSQwJFR5cGUiLDEyMzEpO2Z1bmN0aW9uIE9sZShlKXtydSgpLHRoaXMubWFwXzA9ZX1wKDEyMjcsMjA3OCxCRixPbGUpLGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgbjUodGhpcyl9LGwuYXNMaXN0XzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1TXyh0aGlzLm1hcF8wKS5hc0xpc3RfMSgpLG5ldyBSbGUodGhpcyxuKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gbiE9bnVsbCYmQktlKG5ldyBuNSh0aGlzKSxuKX0sbC5pdGVyYXRvcl8xPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuNSh0aGlzKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5zaXplXzEoKX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIGFDKFNfKHRoaXMubWFwXzApLnNwbGl0ZXJhdG9yXzAoKSxuZXcgTWxlKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcFZhbHVlcyIsMTIyNyk7ZnVuY3Rpb24gTWxlKCl7fXAoMTIyOCwxLHt9LE1sZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNDQpLmdldFZhbHVlKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJbW11dGFibGVNYXBWYWx1ZXMvMG1ldGhvZHJlZiRnZXRWYWx1ZSRUeXBlIiwxMjI4KTtmdW5jdGlvbiBuNShlKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmVudHJ5SXRyPVNfKHRoaXMudGhpcyQwMS5tYXBfMCkuaXRlcmF0b3JfMSgpfXAoNjM3LDIwNCx6bSxuNSksbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnRyeUl0ci5oYXNOZXh0XzAoKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLmVudHJ5SXRyLm5leHRfMSgpLDQ0KS5nZXRWYWx1ZSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW1tdXRhYmxlTWFwVmFsdWVzLzEiLDYzNyk7ZnVuY3Rpb24gUmxlKGUsbil7eTEoKSx0aGlzLnRoaXMkMDE9ZSx0aGlzLnZhbCRlbnRyeUxpc3QyPW59cCgxMjI5LDIwOTcsQm0sUmxlKSxsLmRlbGVnYXRlQ29sbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDF9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEodGhpcy52YWwkZW50cnlMaXN0Mi5nZXRfMChuKSw0NCkuZ2V0VmFsdWUoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkltbXV0YWJsZU1hcFZhbHVlcy8yIiwxMjI5KTtmdW5jdGlvbiBEbGUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEyMzIsMSx7fSxEbGUpLGwuYXBwbHlfMj1mdW5jdGlvbihuKXtyZXR1cm4gQWxlKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW5kZXhlZEltbXV0YWJsZVNldC8wbWV0aG9kcmVmJGdldCRUeXBlIiwxMjMyKTtmdW5jdGlvbiByNShlKXt5MSgpLHRoaXMudGhpcyQwMT1lfXAoNjM4LDIwOTcsQm0scjUpLGwuZGVsZWdhdGVDb2xsZWN0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMX0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gQWxlKHRoaXMudGhpcyQwMSxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLm1hcF8wLnNpemVfMSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSW5kZXhlZEltbXV0YWJsZVNldC8xIiw2MzgpO2Z1bmN0aW9uIHQ1KGUsbil7dmFyIHI7cmV0dXJuIEwobiwxNik/KHI9YShuLDE2KSxlLmFkZEFsbChyKSk6aTUoZSxhKHZuKG4pLDIwKS5pdGVyYXRvcl8wKCkpfWZ1bmN0aW9uIHBJKGUsbil7cmV0dXJuICRLZShlLml0ZXJhdG9yXzAoKSxuKX1mdW5jdGlvbiBvNShlLG4pe3JldHVybiBXS2UoZS5pdGVyYXRvcl8wKCksbikhPS0xfWZ1bmN0aW9uIE9LZShlKXtyZXR1cm4gdm4oZSksbmV3IFAyKGUpfWZ1bmN0aW9uIGloKGUsbil7cmV0dXJuIHZuKGUpLHZuKG4pLG5ldyBGbGUoZSxuKX1mdW5jdGlvbiBNS2UoZSl7cmV0dXJuIHZuKGUpLEdsZShuZXcgWGUoUWUoZS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpfWZ1bmN0aW9uIFJLZShlKXt2YXIgbjtpZihlKXtpZihuPWUsbi5pc0VtcHR5KCkpdGhyb3cgYihuZXcgUG8pO3JldHVybiBuLmdldF8wKG4uc2l6ZV8xKCktMSl9cmV0dXJuIEhsZShlLml0ZXJhdG9yXzAoKSl9ZnVuY3Rpb24gSm0oZSl7cmV0dXJuIEwoZSwxNik/YShlLDE2KS5pc0VtcHR5KCk6IWUuaXRlcmF0b3JfMCgpLmhhc05leHRfMCgpfWZ1bmN0aW9uIERLZShlLG4pe3JldHVybiB2bihlKSx2bihuKSxuZXcgJGxlKGUsbil9ZnVuY3Rpb24gWmUoKXt9cCg0MywxLHt9LFplKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyMCkuaXRlcmF0b3JfMCgpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkl0ZXJhYmxlcy8xMCIsNDMpO2Z1bmN0aW9uIEJ6KGUpe3JldHVybiBIS2UoZS52YWwkdW5maWx0ZXJlZDEuaXRlcmF0b3JfMCgpLGUudmFsJHJldGFpbklmVHJ1ZTIpfWZ1bmN0aW9uIEZsZShlLG4pe3RoaXMudmFsJHVuZmlsdGVyZWQxPWUsdGhpcy52YWwkcmV0YWluSWZUcnVlMj1uLFc2LmNhbGwodGhpcyl9ZnVuY3Rpb24gRktlKGUsbixyKXtlLnRlc3RfMChyKSYmbi5hY2NlcHQocil9cCgxMDU1LDU0NyxUdSxGbGUpLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3ZuKG4pLHRoaXMudmFsJHVuZmlsdGVyZWQxLmZvckVhY2hfMChuZXcgemxlKHRoaXMudmFsJHJldGFpbklmVHJ1ZTIsbikpfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gQnoodGhpcyl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJdGVyYWJsZXMvNCIsMTA1NSk7ZnVuY3Rpb24gemxlKGUsbil7dGhpcy5yZXRhaW5JZlRydWVfMD1lLHRoaXMuYWN0aW9uXzE9bn1wKDEwNTYsMSxKZSx6bGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0ZLZSh0aGlzLnJldGFpbklmVHJ1ZV8wLHRoaXMuYWN0aW9uXzEsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJdGVyYWJsZXMvNC9sYW1iZGEkMCRUeXBlIiwxMDU2KTtmdW5jdGlvbiAkbGUoZSxuKXt0aGlzLnZhbCRmcm9tSXRlcmFibGUxPWUsdGhpcy52YWwkZnVuY3Rpb24yPW4sVzYuY2FsbCh0aGlzKX1wKDEwNTcsNTQ3LFR1LCRsZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7dm4obiksRXQodGhpcy52YWwkZnJvbUl0ZXJhYmxlMSxuZXcgQmxlKG4sdGhpcy52YWwkZnVuY3Rpb24yKSl9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBRZShuZXcgWWUodGhpcy52YWwkZnJvbUl0ZXJhYmxlMSksdGhpcy52YWwkZnVuY3Rpb24yKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkl0ZXJhYmxlcy81IiwxMDU3KTtmdW5jdGlvbiBCbGUoZSxuKXt0aGlzLmFjdGlvbl8wPWUsdGhpcy5mdW5jdGlvbl8xPW59cCgxMDU4LDEsSmUsQmxlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt0aGlzLmFjdGlvbl8wLmFjY2VwdChBemUobikpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSXRlcmFibGVzLzUvbGFtYmRhJDAkVHlwZSIsMTA1OCk7ZnVuY3Rpb24gaTUoZSxuKXt2YXIgcjtmb3Iodm4oZSksdm4obikscj0hMTtuLmhhc05leHRfMCgpOylyPXJ8ZS5hZGRfMihuLm5leHRfMSgpKTtyZXR1cm4gcn1mdW5jdGlvbiB6S2UoZSl7dmFyIG47Zm9yKHZuKGUpLGN6KCEwLCJudW1iZXJUb0FkdmFuY2UgbXVzdCBiZSBub25uZWdhdGl2ZSIpLG49MDtuPDAmJl9uKGUpO24rKyl0bihlKTtyZXR1cm4gbn1mdW5jdGlvbiAkS2UoZSxuKXt2YXIgcjtmb3Iodm4obik7ZS5oYXNOZXh0XzAoKTspaWYocj1lLm5leHRfMSgpLCFVSyhhKHIsMTApKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBnSShlKXtmb3Iodm4oZSk7ZS5oYXNOZXh0XzAoKTspZS5uZXh0XzEoKSxlLnJlbW92ZSgpfWZ1bmN0aW9uIEJLZShlLG4pe2lmKG49PW51bGwpe2Zvcig7ZS5lbnRyeUl0ci5oYXNOZXh0XzAoKTspaWYoYShlLmVudHJ5SXRyLm5leHRfMSgpLDQ0KS5nZXRWYWx1ZSgpPT1udWxsKXJldHVybiEwfWVsc2UgZm9yKDtlLmVudHJ5SXRyLmhhc05leHRfMCgpOylpZihZbihuLGEoZS5lbnRyeUl0ci5uZXh0XzEoKSw0NCkuZ2V0VmFsdWUoKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gR0tlKGUsbil7Zm9yKHZhciByLHQ7ZS5oYXNOZXh0XzAoKTspaWYoIW4uaGFzTmV4dF8wKCl8fChyPWUubmV4dF8xKCksdD1uLm5leHRfMSgpLCEoRChyKT09PUQodCl8fHIhPW51bGwmJlluKHIsdCkpKSlyZXR1cm4hMTtyZXR1cm4hbi5oYXNOZXh0XzAoKX1mdW5jdGlvbiBIS2UoZSxuKXtyZXR1cm4gdm4oZSksdm4obiksbmV3IGpsZShlLG4pfWZ1bmN0aW9uIEdsZShlKXt2YXIgbjtpZihuPXpLZShlKSwhX24oZSkpdGhyb3cgYihuZXcgbm8oInBvc2l0aW9uICgwKSBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRoYXQgcmVtYWluZWQgKCIrbisiKSIpKTtyZXR1cm4gdG4oZSl9ZnVuY3Rpb24gSGxlKGUpe2Zvcih2YXIgbjs7KWlmKG49ZS5uZXh0XzEoKSwhZS5oYXNOZXh0XzAoKSlyZXR1cm4gbn1mdW5jdGlvbiBVS2UoZSl7cmV0dXJuIERDKGUudmFsJGVkZ2VzSXRlcjIpP0hsZShlKTpudWxsfWZ1bmN0aW9uIGhJKGUpe3JldHVybiBlLmhhc05leHRfMCgpP2UubmV4dF8xKCk6bnVsbH1mdW5jdGlvbiBVbGUoZSl7dmFyIG4scix0O2lmKG49ZS5uZXh0XzEoKSwhZS5oYXNOZXh0XzAoKSlyZXR1cm4gbjtmb3IodD1laShPbihuZXcgQzAsImV4cGVjdGVkIG9uZSBlbGVtZW50IGJ1dCB3YXM6IDwiKSxuKSxyPTA7cjw0JiZlLmhhc05leHRfMCgpO3IrKyllaSgodC5zdHJpbmcrPSIsICIsdCksZS5uZXh0XzEoKSk7dGhyb3cgZS5oYXNOZXh0XzAoKSYmKHQuc3RyaW5nKz0iLCAuLi4iKSx0LnN0cmluZys9Ij4iLGIobmV3IEdlKHQuc3RyaW5nKSl9ZnVuY3Rpb24gV0tlKGUsbil7dmFyIHIsdDtmb3IobkkobiwicHJlZGljYXRlIiksdD0wO2UuaGFzTmV4dF8wKCk7dCsrKWlmKHI9ZS5uZXh0XzEoKSxuLmFwcGx5XzEocikpcmV0dXJuIHQ7cmV0dXJuLTF9ZnVuY3Rpb24gWnUoZSl7dmFyIG47Zm9yKG49MDtlLmhhc05leHRfMCgpOyllLm5leHRfMSgpLG49TnQobiwxKTtyZXR1cm4gYkkobil9ZnVuY3Rpb24gaktlKGUpe3ZhciBuLHI7Zm9yKHI9eF8obmV3IEMwLDkxKSxuPSEwO2UuaGFzTmV4dF8wKCk7KW58fChyLnN0cmluZys9IiwgIiksbj0hMSxlaShyLGUubmV4dF8xKCkpO3JldHVybihyLnN0cmluZys9Il0iLHIpLnN0cmluZ31mdW5jdGlvbiBRZShlLG4pe3JldHVybiB2bihuKSxuZXcgVmxlKGUsbil9ZnVuY3Rpb24gYWgoZSl7dmFyIG47cmV0dXJuIHZuKGUpLEwoZSwyMDQpPyhuPWEoZSwyMDQpLG4pOm5ldyBXbGUoZSl9ZnVuY3Rpb24gV2xlKGUpe3RoaXMudmFsJGl0ZXJhdG9yMT1lfXAoMTA4NywyMDQsem0sV2xlKSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbCRpdGVyYXRvcjEuaGFzTmV4dF8wKCl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGl0ZXJhdG9yMS5uZXh0XzEoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkl0ZXJhdG9ycy8xIiwxMDg3KTtmdW5jdGlvbiBqbGUoZSxuKXt0aGlzLnZhbCR1bmZpbHRlcmVkMT1lLHRoaXMudmFsJHJldGFpbklmVHJ1ZTI9bn1wKDEwODgsNzEzLHptLGpsZSksbC5jb21wdXRlTmV4dD1mdW5jdGlvbigpe2Zvcih2YXIgbjt0aGlzLnZhbCR1bmZpbHRlcmVkMS5oYXNOZXh0XzAoKTspaWYobj10aGlzLnZhbCR1bmZpbHRlcmVkMS5uZXh0XzEoKSx0aGlzLnZhbCRyZXRhaW5JZlRydWUyLmFwcGx5XzEobikpcmV0dXJuIG47cmV0dXJuIHRoaXMuc3RhdGU9MixudWxsfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiSXRlcmF0b3JzLzUiLDEwODgpO2Z1bmN0aW9uIG1JKGUpe3RoaXMuYmFja2luZ0l0ZXJhdG9yPWEodm4oZSksNTEpfXAoNDk3LDEsc3QpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tpbmdJdGVyYXRvci5oYXNOZXh0XzAoKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2Zvcm1fMCh0aGlzLmJhY2tpbmdJdGVyYXRvci5uZXh0XzEoKSl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7dGhpcy5iYWNraW5nSXRlcmF0b3IucmVtb3ZlKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJUcmFuc2Zvcm1lZEl0ZXJhdG9yIiw0OTcpO2Z1bmN0aW9uIFZsZShlLG4pe3RoaXMudmFsJGZ1bmN0aW9uMj1uLG1JLmNhbGwodGhpcyxlKX1wKDEwODksNDk3LHN0LFZsZSksbC50cmFuc2Zvcm1fMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy52YWwkZnVuY3Rpb24yLmFwcGx5XzAobil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJdGVyYXRvcnMvNiIsMTA4OSk7ZnVuY3Rpb24gR3ooZSl7dGhpcy52YWwkdmFsdWUxPWV9cCg3MzIsMjA0LHptLEd6KSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiF0aGlzLmRvbmVfMH0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtpZih0aGlzLmRvbmVfMCl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIHRoaXMuZG9uZV8wPSEwLHRoaXMudmFsJHZhbHVlMX0sbC5kb25lXzA9ITEsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkl0ZXJhdG9ycy85Iiw3MzIpO2Z1bmN0aW9uIHFsZSgpe3FsZT1GLEtsZT1uZXcgWWxlKEIoUXIsTWUsMSwwLDUsMSkpfWZ1bmN0aW9uIFlsZShlKXtmei5jYWxsKHRoaXMsMCwwKSx0aGlzLmFycmF5PWUsdGhpcy5vZmZzZXQ9MH1wKDEwODYsMzk5LCRtLFlsZSksbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5hcnJheVt0aGlzLm9mZnNldCtuXX0sbC5vZmZzZXQ9MDt2YXIgS2xlO2coImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJdGVyYXRvcnMvQXJyYXlJdHIiLDEwODYpO2Z1bmN0aW9uIFZLZShlKXtmb3IoOyFlLnRvcE1ldGFJdGVyYXRvcnx8IWUudG9wTWV0YUl0ZXJhdG9yLmhhc05leHRfMCgpOylpZihlLm1ldGFJdGVyYXRvcnMmJiFZMihlLm1ldGFJdGVyYXRvcnMpKWUudG9wTWV0YUl0ZXJhdG9yPWEobWgoZS5tZXRhSXRlcmF0b3JzKSw1MSk7ZWxzZSByZXR1cm4gbnVsbDtyZXR1cm4gZS50b3BNZXRhSXRlcmF0b3J9ZnVuY3Rpb24gX24oZSl7Zm9yKHZhciBuOyFhKHZuKGUuaXRlcmF0b3IpLDUxKS5oYXNOZXh0XzAoKTspe2lmKGUudG9wTWV0YUl0ZXJhdG9yPVZLZShlKSwhZS50b3BNZXRhSXRlcmF0b3IpcmV0dXJuITE7aWYoZS5pdGVyYXRvcj1hKGUudG9wTWV0YUl0ZXJhdG9yLm5leHRfMSgpLDUxKSxMKGUuaXRlcmF0b3IsMzgpKXtpZihuPWEoZS5pdGVyYXRvciwzOCksZS5pdGVyYXRvcj1uLml0ZXJhdG9yLCFlLm1ldGFJdGVyYXRvcnMmJihlLm1ldGFJdGVyYXRvcnM9bmV3IEFwKSxJMChlLm1ldGFJdGVyYXRvcnMsZS50b3BNZXRhSXRlcmF0b3IpLG4ubWV0YUl0ZXJhdG9ycylmb3IoOyFZMihuLm1ldGFJdGVyYXRvcnMpOylJMChlLm1ldGFJdGVyYXRvcnMsYShVWmUobi5tZXRhSXRlcmF0b3JzKSw1MSkpO2UudG9wTWV0YUl0ZXJhdG9yPW4udG9wTWV0YUl0ZXJhdG9yfX1yZXR1cm4hMH1mdW5jdGlvbiB0bihlKXtpZihfbihlKSlyZXR1cm4gZS50b1JlbW92ZT1lLml0ZXJhdG9yLGUuaXRlcmF0b3IubmV4dF8xKCk7dGhyb3cgYihuZXcgUG8pfWZ1bmN0aW9uIFhlKGUpe3RoaXMuaXRlcmF0b3I9KHFsZSgpLEtsZSksdGhpcy50b3BNZXRhSXRlcmF0b3I9YSh2bihlKSw1MSl9cCgzOCwxLHszODoxLDUxOjF9LFhlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gX24odGhpcyl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRuKHRoaXMpfSxsLnJlbW92ZT1mdW5jdGlvbigpe2lmKCF0aGlzLnRvUmVtb3ZlKXRocm93IGIobmV3IHJvKCJubyBjYWxscyB0byBuZXh0KCkgc2luY2UgdGhlIGxhc3QgY2FsbCB0byByZW1vdmUoKSIpKTt0aGlzLnRvUmVtb3ZlLnJlbW92ZSgpLHRoaXMudG9SZW1vdmU9bnVsbH0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkl0ZXJhdG9ycy9Db25jYXRlbmF0ZWRJdGVyYXRvciIsMzgpO2Z1bmN0aW9uIFhsZShlLG4pe3JldHVybiBlLm9yZGluYWwtbi5vcmRpbmFsfWZ1bmN0aW9uIHFLZShlKXtyZXR1cm4gZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsfWZ1bmN0aW9uIGE1KGUpe3JldHVybiBlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWx9ZnVuY3Rpb24gbW4oZSxuKXt0aGlzLm5hbWVfMD1lLHRoaXMub3JkaW5hbD1ufWZ1bmN0aW9uIHluKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKG49e30sdD1lLG89MCxpPXQubGVuZ3RoO288aTsrK28pcj10W29dLG5bIjoiKyhyLm5hbWVfMCE9bnVsbD9yLm5hbWVfMDoiIityLm9yZGluYWwpXT1yO3JldHVybiBufWZ1bmN0aW9uIHduKGUsbil7dmFyIHI7cmV0dXJuIFZlKG4pLHI9ZVsiOiIrbl0sSEMoISFyLCJFbnVtIGNvbnN0YW50IHVuZGVmaW5lZDogIituKSxyfWZ1bmN0aW9uIFlLZShlLG4pe3ZhciByO3JldHVybiByPShWZShlKSxlKS5lbnVtVmFsdWVPZkZ1bmMsUUcoISFyKSxWZShuKSxyKG4pfXAoMjIsMSx7MzoxLDM0OjEsMjI6MX0pLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIFhsZSh0aGlzLGEobiwyMikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFIxKHRoaXMpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYTUodGhpcyl9LGwub3JkaW5hbD0wO3ZhciBnbj1nKCJqYXZhLmxhbmciLCJFbnVtIiwyMik7ZnVuY3Rpb24geUkoKXt5ST1GLGw1PW5ldyBKbGV9ZnVuY3Rpb24gSmxlKCl7bW4uY2FsbCh0aGlzLCJJTlNUQU5DRSIsMCl9ZnVuY3Rpb24gS0tlKGUpe3JldHVybiB5SSgpLHduKChRbGUoKSxlc2UpLGUpfWZ1bmN0aW9uIFhLZSgpe3JldHVybiB5SSgpLFAoSShabGUsMSksVyw1NDksMCxbbDVdKX1wKDU0OSwyMix7NTQ5OjEsMzoxLDM0OjEsMjI6MSw1MToxfSxKbGUpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiExfSxsLm5leHRfMT1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBvKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtxbSghMSl9O3ZhciBsNSxabGU9Y24oImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJJdGVyYXRvcnMvRW1wdHlNb2RpZmlhYmxlSXRlcmF0b3IiLDU0OSxnbixYS2UsS0tlKTtmdW5jdGlvbiBRbGUoKXtRbGU9Rixlc2U9eW4oKHlJKCksUChJKFpsZSwxKSxXLDU0OSwwLFtsNV0pKSl9dmFyIGVzZTtmdW5jdGlvbiBKS2UoZSl7TnouY2FsbCh0aGlzLGUpfXAoMTkwNyw2MjcsZl8pLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJMaW5rZWRIYXNoTXVsdGltYXBHd3RTZXJpYWxpemF0aW9uRGVwZW5kZW5jaWVzIiwxOTA3KTtmdW5jdGlvbiBuc2UoKXtKS2UuY2FsbCh0aGlzLG5ldyBpRyhLZCgxNikpKSxQYSgyLCJleHBlY3RlZFZhbHVlc1BlcktleSIpLHRoaXMudmFsdWVTZXRDYXBhY2l0eT0yLHRoaXMubXVsdGltYXBIZWFkZXJFbnRyeT1uZXcgVXoobnVsbCxudWxsLDAsbnVsbCksdUModGhpcy5tdWx0aW1hcEhlYWRlckVudHJ5LHRoaXMubXVsdGltYXBIZWFkZXJFbnRyeSl9ZnVuY3Rpb24gdUMoZSxuKXtlLnN1Y2Nlc3NvckluTXVsdGltYXA9bixuLnByZWRlY2Vzc29ySW5NdWx0aW1hcD1lfWZ1bmN0aW9uIHJzZShlLG4pe2Uuc2V0U3VjY2Vzc29ySW5WYWx1ZVNldChuKSxuLnNldFByZWRlY2Vzc29ySW5WYWx1ZVNldChlKX1wKDE5MDgsMTkwNyxmXyxuc2UpLGwuY3JlYXRlQ29sbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiBuZXcgdGsoS2QodGhpcy52YWx1ZVNldENhcGFjaXR5KSl9LGwuY2xlYXJfMD1mdW5jdGlvbigpe3RJKHRoaXMpLHVDKHRoaXMubXVsdGltYXBIZWFkZXJFbnRyeSx0aGlzLm11bHRpbWFwSGVhZGVyRW50cnkpfSxsLmNyZWF0ZUNvbGxlY3Rpb25fMT1mdW5jdGlvbigpe3JldHVybiBuZXcgdGsoS2QodGhpcy52YWx1ZVNldENhcGFjaXR5KSl9LGwuY3JlYXRlQ29sbGVjdGlvbl8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgYXNlKHRoaXMsbix0aGlzLnZhbHVlU2V0Q2FwYWNpdHkpfSxsLmVudHJ5SXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEh6KHRoaXMpfSxsLmVudHJ5U3BsaXRlcmF0b3I9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbmV3IHhlKChuPXRoaXMuZW50cmllc18wLGEobnx8KHRoaXMuZW50cmllc18wPW5ldyBJeih0aGlzKSksMjEpKSwxNyl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmtleVNldCxufHwodGhpcy5rZXlTZXQ9bmV3IFNwKHRoaXMsdGhpcy5tYXBfMCkpfSxsLnZhbHVlSXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgUXoobmV3IEh6KHRoaXMpKX0sbC52YWx1ZVNwbGl0ZXJhdG9yPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIGFDKG5ldyB4ZSgobj10aGlzLmVudHJpZXNfMCxhKG58fCh0aGlzLmVudHJpZXNfMD1uZXcgSXoodGhpcykpLDIxKSksMTcpLG5ldyB0c2UpfSxsLnZhbHVlU2V0Q2FwYWNpdHk9MixnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlua2VkSGFzaE11bHRpbWFwIiwxOTA4KTtmdW5jdGlvbiB0c2UoKXt9cCgxOTExLDEse30sdHNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiw0NCkuZ2V0VmFsdWUoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpbmtlZEhhc2hNdWx0aW1hcC8wbWV0aG9kcmVmJGdldFZhbHVlJFR5cGUiLDE5MTEpO2Z1bmN0aW9uIFpLZShlKXt2YXIgbjtpZihlLm5leHRFbnRyeT09ZS50aGlzJDAxLm11bHRpbWFwSGVhZGVyRW50cnkpdGhyb3cgYihuZXcgUG8pO3JldHVybiBuPWUubmV4dEVudHJ5LGUudG9SZW1vdmU9bixlLm5leHRFbnRyeT1hKHdsKGUubmV4dEVudHJ5LnN1Y2Nlc3NvckluTXVsdGltYXApLDIyNyksbn1mdW5jdGlvbiBIeihlKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLm5leHRFbnRyeT1hKHdsKHRoaXMudGhpcyQwMS5tdWx0aW1hcEhlYWRlckVudHJ5LnN1Y2Nlc3NvckluTXVsdGltYXApLDIyNyl9cCg4MzQsMSxzdCxIeiksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIFpLZSh0aGlzKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0RW50cnkhPXRoaXMudGhpcyQwMS5tdWx0aW1hcEhlYWRlckVudHJ5fSxsLnJlbW92ZT1mdW5jdGlvbigpe3FtKCEhdGhpcy50b1JlbW92ZSksbmFlKHRoaXMudGhpcyQwMSx0aGlzLnRvUmVtb3ZlLmtleSx0aGlzLnRvUmVtb3ZlLnZhbHVlXzApLHRoaXMudG9SZW1vdmU9bnVsbH0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpbmtlZEhhc2hNdWx0aW1hcC8xIiw4MzQpO2Z1bmN0aW9uIFV6KGUsbixyLHQpe3cxLmNhbGwodGhpcyxlLG4pLHRoaXMuc21lYXJlZFZhbHVlSGFzaD1yLHRoaXMubmV4dEluVmFsdWVCdWNrZXQ9dH1wKDIyNywyNDYsezM1ODoxLDI0NjoxLDIyNzoxLDYwNDoxLDM6MSw0NDoxfSxVeiksbC5nZXRTdWNjZXNzb3JJblZhbHVlU2V0PWZ1bmN0aW9uKCl7cmV0dXJuIGEod2wodGhpcy5zdWNjZXNzb3JJblZhbHVlU2V0KSw2MDQpfSxsLnNldFByZWRlY2Vzc29ySW5WYWx1ZVNldD1mdW5jdGlvbihuKXt0aGlzLnByZWRlY2Vzc29ySW5WYWx1ZVNldD1ufSxsLnNldFN1Y2Nlc3NvckluVmFsdWVTZXQ9ZnVuY3Rpb24obil7dGhpcy5zdWNjZXNzb3JJblZhbHVlU2V0PW59LGwuc21lYXJlZFZhbHVlSGFzaD0wO3ZhciBvc2U9ZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpbmtlZEhhc2hNdWx0aW1hcC9WYWx1ZUVudHJ5IiwyMjcpO2Z1bmN0aW9uIFFLZShlKXt2YXIgbixyLHQsbyxpO2lmKFRsZShlLnNpemVfMCxlLmhhc2hUYWJsZS5sZW5ndGgpKWZvcih0PUIob3NlLFZTLDIyNyxlLmhhc2hUYWJsZS5sZW5ndGgqMiwwLDEpLGUuaGFzaFRhYmxlPXQsbz10Lmxlbmd0aC0xLHI9ZS5maXJzdEVudHJ5O3IhPWU7cj1yLmdldFN1Y2Nlc3NvckluVmFsdWVTZXQoKSlpPWEociwyMjcpLG49aS5zbWVhcmVkVmFsdWVIYXNoJm8saS5uZXh0SW5WYWx1ZUJ1Y2tldD10W25dLHRbbl09aX1mdW5jdGlvbiBpc2UoZSxuKXt2YXIgcix0LG8saTtmb3IoaT1TbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSxyPWkmZS5oYXNoVGFibGUubGVuZ3RoLTEsbz1udWxsLHQ9ZS5oYXNoVGFibGVbcl07dDtvPXQsdD10Lm5leHRJblZhbHVlQnVja2V0KWlmKHQuc21lYXJlZFZhbHVlSGFzaD09aSYmbnUodC52YWx1ZV8wLG4pKXJldHVybiBvP28ubmV4dEluVmFsdWVCdWNrZXQ9dC5uZXh0SW5WYWx1ZUJ1Y2tldDplLmhhc2hUYWJsZVtyXT10Lm5leHRJblZhbHVlQnVja2V0LHJzZShhKHdsKHQucHJlZGVjZXNzb3JJblZhbHVlU2V0KSw2MDQpLGEod2wodC5zdWNjZXNzb3JJblZhbHVlU2V0KSw2MDQpKSx1QyhhKHdsKHQucHJlZGVjZXNzb3JJbk11bHRpbWFwKSwyMjcpLGEod2wodC5zdWNjZXNzb3JJbk11bHRpbWFwKSwyMjcpKSwtLWUuc2l6ZV8wLCsrZS5tb2RDb3VudCwhMDtyZXR1cm4hMX1mdW5jdGlvbiBhc2UoZSxuLHIpe3ZhciB0LG87dGhpcy50aGlzJDAxPWUsdGhpcy5rZXk9bix0aGlzLmZpcnN0RW50cnk9dGhpcyx0aGlzLmxhc3RFbnRyeT10aGlzLG89Q2xlKHIpLHQ9Qihvc2UsVlMsMjI3LG8sMCwxKSx0aGlzLmhhc2hUYWJsZT10fXAoMTkwOSwyMDY4LHs2MDQ6MSwyMDoxLDMxOjEsMTY6MSwyMToxfSxhc2UpLGwuYWRkXzI9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscztmb3Iocz1TbihBdChidSxMdShTbihBdChuPT1udWxsPzA6dXIobiksSXUpKSwxNSkpKSxyPXMmdGhpcy5oYXNoVGFibGUubGVuZ3RoLTEsaT10aGlzLmhhc2hUYWJsZVtyXSx0PWk7dDt0PXQubmV4dEluVmFsdWVCdWNrZXQpaWYodC5zbWVhcmVkVmFsdWVIYXNoPT1zJiZudSh0LnZhbHVlXzAsbikpcmV0dXJuITE7cmV0dXJuIG89bmV3IFV6KHRoaXMua2V5LG4scyxpKSxyc2UodGhpcy5sYXN0RW50cnksbyksby5zdWNjZXNzb3JJblZhbHVlU2V0PXRoaXMsdGhpcy5sYXN0RW50cnk9byx1QyhhKHdsKHRoaXMudGhpcyQwMS5tdWx0aW1hcEhlYWRlckVudHJ5LnByZWRlY2Vzc29ySW5NdWx0aW1hcCksMjI3KSxvKSx1QyhvLHRoaXMudGhpcyQwMS5tdWx0aW1hcEhlYWRlckVudHJ5KSx0aGlzLmhhc2hUYWJsZVtyXT1vLCsrdGhpcy5zaXplXzAsKyt0aGlzLm1vZENvdW50LFFLZSh0aGlzKSwhMH0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dmFyIG4scjtmb3IoTEModGhpcy5oYXNoVGFibGUsbnVsbCksdGhpcy5zaXplXzA9MCxuPXRoaXMuZmlyc3RFbnRyeTtuIT10aGlzO249bi5nZXRTdWNjZXNzb3JJblZhbHVlU2V0KCkpcj1hKG4sMjI3KSx1QyhhKHdsKHIucHJlZGVjZXNzb3JJbk11bHRpbWFwKSwyMjcpLGEod2woci5zdWNjZXNzb3JJbk11bHRpbWFwKSwyMjcpKTt0aGlzLmZpcnN0RW50cnk9dGhpcyx0aGlzLmxhc3RFbnRyeT10aGlzLCsrdGhpcy5tb2RDb3VudH0sbC5jb250YWlucz1mdW5jdGlvbihuKXt2YXIgcix0O2Zvcih0PVNuKEF0KGJ1LEx1KFNuKEF0KG49PW51bGw/MDp1cihuKSxJdSkpLDE1KSkpLHI9dGhpcy5oYXNoVGFibGVbdCZ0aGlzLmhhc2hUYWJsZS5sZW5ndGgtMV07cjtyPXIubmV4dEluVmFsdWVCdWNrZXQpaWYoci5zbWVhcmVkVmFsdWVIYXNoPT10JiZudShyLnZhbHVlXzAsbikpcmV0dXJuITA7cmV0dXJuITF9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3ZhciByO2Zvcih2bihuKSxyPXRoaXMuZmlyc3RFbnRyeTtyIT10aGlzO3I9ci5nZXRTdWNjZXNzb3JJblZhbHVlU2V0KCkpbi5hY2NlcHQoYShyLDIyNykudmFsdWVfMCl9LGwuZ2V0U3VjY2Vzc29ySW5WYWx1ZVNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0RW50cnl9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgbHNlKHRoaXMpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBpc2UodGhpcyxuKX0sbC5zZXRQcmVkZWNlc3NvckluVmFsdWVTZXQ9ZnVuY3Rpb24obil7dGhpcy5sYXN0RW50cnk9bn0sbC5zZXRTdWNjZXNzb3JJblZhbHVlU2V0PWZ1bmN0aW9uKG4pe3RoaXMuZmlyc3RFbnRyeT1ufSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVfMH0sbC5tb2RDb3VudD0wLGwuc2l6ZV8wPTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpbmtlZEhhc2hNdWx0aW1hcC9WYWx1ZVNldCIsMTkwOSk7ZnVuY3Rpb24gV3ooZSl7aWYoZS50aGlzJDExLm1vZENvdW50IT1lLmV4cGVjdGVkTW9kQ291bnQpdGhyb3cgYihuZXcgWGEpfWZ1bmN0aW9uIGxzZShlKXt0aGlzLnRoaXMkMTE9ZSx0aGlzLm5leHRFbnRyeT10aGlzLnRoaXMkMTEuZmlyc3RFbnRyeSx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy50aGlzJDExLm1vZENvdW50fXAoMTkxMCwxLHN0LGxzZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIFd6KHRoaXMpLHRoaXMubmV4dEVudHJ5IT10aGlzLnRoaXMkMTF9LGwubmV4dF8xPWZ1bmN0aW9uKCl7dmFyIG4scjtpZihXeih0aGlzKSx0aGlzLm5leHRFbnRyeT09dGhpcy50aGlzJDExKXRocm93IGIobmV3IFBvKTtyZXR1cm4gbj1hKHRoaXMubmV4dEVudHJ5LDIyNykscj1uLnZhbHVlXzAsdGhpcy50b1JlbW92ZT1uLHRoaXMubmV4dEVudHJ5PWEod2wobi5zdWNjZXNzb3JJblZhbHVlU2V0KSw2MDQpLHJ9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7V3oodGhpcykscW0oISF0aGlzLnRvUmVtb3ZlKSxpc2UodGhpcy50aGlzJDExLHRoaXMudG9SZW1vdmUudmFsdWVfMCksdGhpcy5leHBlY3RlZE1vZENvdW50PXRoaXMudGhpcyQxMS5tb2RDb3VudCx0aGlzLnRvUmVtb3ZlPW51bGx9LGwuZXhwZWN0ZWRNb2RDb3VudD0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJMaW5rZWRIYXNoTXVsdGltYXAvVmFsdWVTZXQvMSIsMTkxMCk7ZnVuY3Rpb24ganooZSxuLHIsdCl7dmFyIG8saSxzO3JldHVybiBzPW5ldyBoc2UobixyKSxlLmhlYWQ/dD8obz1hKHdsKGEoS2UoZS5rZXlUb0tleUxpc3QsbiksMjYwKSksMjYwKSwrK28uY291bnQscy5wcmV2aW91cz10LnByZXZpb3VzLHMucHJldmlvdXNTaWJsaW5nPXQucHJldmlvdXNTaWJsaW5nLHMubmV4dF8wPXQscy5uZXh0U2libGluZz10LHQucHJldmlvdXNTaWJsaW5nP3QucHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nPXM6by5oZWFkPXMsdC5wcmV2aW91cz90LnByZXZpb3VzLm5leHRfMD1zOmUuaGVhZD1zLHQucHJldmlvdXM9cyx0LnByZXZpb3VzU2libGluZz1zKTooYSh3bChlLnRhaWwpLDUxMSkubmV4dF8wPXMscy5wcmV2aW91cz1lLnRhaWwsZS50YWlsPXMsbz1hKEtlKGUua2V5VG9LZXlMaXN0LG4pLDI2MCksbz8oKytvLmNvdW50LGk9by50YWlsLGkubmV4dFNpYmxpbmc9cyxzLnByZXZpb3VzU2libGluZz1pLG8udGFpbD1zKTooQm4oZS5rZXlUb0tleUxpc3QsbixvPW5ldyBLeihzKSksKytlLm1vZENvdW50KSk6KGUuaGVhZD1lLnRhaWw9cyxCbihlLmtleVRvS2V5TGlzdCxuLG5ldyBLeihzKSksKytlLm1vZENvdW50KSwrK2Uuc2l6ZV8wLHN9ZnVuY3Rpb24gc3NlKGUpe2UuaGVhZD1udWxsLGUudGFpbD1udWxsLFppKGUua2V5VG9LZXlMaXN0KSxlLnNpemVfMD0wLCsrZS5tb2RDb3VudH1mdW5jdGlvbiB1c2UoZSxuKXtyZXR1cm4geWkoZS5rZXlUb0tleUxpc3Qsbil9ZnVuY3Rpb24gVnooZSxuKXt2YXIgcix0O3JldHVybiByPW4sdD1KNShRbShuZXcgYzUoZSxyKSkpLGdJKG5ldyBjNShlLHIpKSx0fWZ1bmN0aW9uIGVYZShlLG4pe3ZhciByO24ucHJldmlvdXM/bi5wcmV2aW91cy5uZXh0XzA9bi5uZXh0XzA6ZS5oZWFkPW4ubmV4dF8wLG4ubmV4dF8wP24ubmV4dF8wLnByZXZpb3VzPW4ucHJldmlvdXM6ZS50YWlsPW4ucHJldmlvdXMsIW4ucHJldmlvdXNTaWJsaW5nJiYhbi5uZXh0U2libGluZz8ocj1hKHdsKGEoaGgoZS5rZXlUb0tleUxpc3Qsbi5rZXkpLDI2MCkpLDI2MCksci5jb3VudD0wLCsrZS5tb2RDb3VudCk6KHI9YSh3bChhKEtlKGUua2V5VG9LZXlMaXN0LG4ua2V5KSwyNjApKSwyNjApLC0tci5jb3VudCxuLnByZXZpb3VzU2libGluZz9uLnByZXZpb3VzU2libGluZy5uZXh0U2libGluZz1uLm5leHRTaWJsaW5nOnIuaGVhZD1hKHdsKG4ubmV4dFNpYmxpbmcpLDUxMSksbi5uZXh0U2libGluZz9uLm5leHRTaWJsaW5nLnByZXZpb3VzU2libGluZz1uLnByZXZpb3VzU2libGluZzpyLnRhaWw9YSh3bChuLnByZXZpb3VzU2libGluZyksNTExKSksLS1lLnNpemVfMH1mdW5jdGlvbiBjc2UoKXt0aGlzLmtleVRvS2V5TGlzdD1uZXcgRWgoS2QoMTIpKX1wKDc4MCwyMDg0LGZfLGNzZSksbC5hc01hcF8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5hc01hcCxufHwodGhpcy5hc01hcD1uZXcgZSQodGhpcykpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBfNSh0aGlzLG4pfSxsLmdldF8xPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgdTUodGhpcyxuKX0sbC5yZW1vdmVBbGw9ZnVuY3Rpb24obil7cmV0dXJuIFZ6KHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe3NzZSh0aGlzKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gdXNlKHRoaXMsbil9LGwuY3JlYXRlQXNNYXA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGUkKHRoaXMpfSxsLmNyZWF0ZUtleVNldD1mdW5jdGlvbigpe3JldHVybiBuZXcgcHNlKHRoaXMpfSxsLmdldF8yPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgdTUodGhpcyxuKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaGVhZH0sbC5yZW1vdmVBbGxfMD1mdW5jdGlvbihuKXtyZXR1cm4gVnoodGhpcyxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzB9LGwubW9kQ291bnQ9MCxsLnNpemVfMD0wLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJMaW5rZWRMaXN0TXVsdGltYXAiLDc4MCk7ZnVuY3Rpb24gcXooZSxuKXt2YXIgcix0LG8saSxzO2lmKEQobik9PT1EKGUpKXJldHVybiEwO2lmKCFMKG4sMTUpfHwocz1hKG4sMTUpLGUuc2l6ZV8xKCkhPXMuc2l6ZV8xKCkpKXJldHVybiExO2ZvcihpPXMuaXRlcmF0b3JfMCgpLHQ9ZS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspaWYocj10Lm5leHRfMSgpLG89aS5uZXh0XzEoKSwhKEQocik9PT1EKG8pfHxyIT1udWxsJiZZbihyLG8pKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBfc2UoZSxuKXt2YXIgcix0O2ZvcihyPTAsdD1lLnNpemVfMSgpO3I8dDsrK3IpaWYoVW8obixlLmdldF8wKHIpKSlyZXR1cm4gcjtyZXR1cm4tMX1wKDU2LDMxLEhtKSxsLnNvcnRfMD1mdW5jdGlvbihuKXt3Xyh0aGlzLG4pfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHhlKHRoaXMsMTYpfSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcga2MoIkFkZCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgbGlzdCIpKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5hZGRfMyh0aGlzLnNpemVfMSgpLG4pLCEwfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpO2ZvcihWZShyKSx0PSExLGk9ci5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspbz1pLm5leHRfMSgpLHRoaXMuYWRkXzMobisrLG8pLHQ9ITA7cmV0dXJuIHR9LGwuY2xlYXJfMD1mdW5jdGlvbigpe3RoaXMucmVtb3ZlUmFuZ2UoMCx0aGlzLnNpemVfMSgpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gcXoodGhpcyxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIEdCKHRoaXMpfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXtyZXR1cm4gX3NlKHRoaXMsbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgcTIodGhpcyl9LGwubGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saXN0SXRlcmF0b3JfMSgwKX0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IHB0KHRoaXMsbil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcga2MoIlJlbW92ZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgbGlzdCIpKX0sbC5yZW1vdmVSYW5nZT1mdW5jdGlvbihuLHIpe3ZhciB0LG87Zm9yKG89dGhpcy5saXN0SXRlcmF0b3JfMShuKSx0PW47dDxyOysrdClvLm5leHRfMSgpLG8ucmVtb3ZlKCl9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXt0aHJvdyBiKG5ldyBrYygiU2V0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBsaXN0IikpfSxsLnN1Ykxpc3Q9ZnVuY3Rpb24obixyKXtyZXR1cm4gbmV3IE9jKHRoaXMsbixyKX0sbC5tb2RDb3VudD0wLGcoImphdmEudXRpbCIsIkFic3RyYWN0TGlzdCIsNTYpO2Z1bmN0aW9uIFptKGUsbixyKXt2YXIgdDt0PWUubGlzdEl0ZXJhdG9yXzEobiksdC5hZGRfMShyKX1mdW5jdGlvbiBkc2UoZSxuLHIpe3ZhciB0LG8saSxzO2ZvcihWZShyKSxzPSExLGk9ZS5saXN0SXRlcmF0b3JfMShuKSxvPXIuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9by5uZXh0XzEoKSxpLmFkZF8xKHQpLHM9ITA7cmV0dXJuIHN9ZnVuY3Rpb24gVmEoZSxuKXt2YXIgcjtyPWUubGlzdEl0ZXJhdG9yXzEobik7dHJ5e3JldHVybiByLm5leHRfMSgpfWNhdGNoKHQpe3Rocm93IHQ9d3IodCksTCh0LDExMik/YihuZXcgbm8oIkNhbid0IGdldCBlbGVtZW50ICIrbikpOmIodCl9fWZ1bmN0aW9uIHM1KGUsbil7dmFyIHIsdDtyPWUubGlzdEl0ZXJhdG9yXzEobik7dHJ5e3JldHVybiB0PXIubmV4dF8xKCksci5yZW1vdmUoKSx0fWNhdGNoKG8pe3Rocm93IG89d3IobyksTChvLDExMik/YihuZXcgbm8oIkNhbid0IHJlbW92ZSBlbGVtZW50ICIrbikpOmIobyl9fXAoMjA2Miw1NixIbSksbC5hZGRfMz1mdW5jdGlvbihuLHIpe1ptKHRoaXMsbixyKX0sbC5hZGRBbGxfMD1mdW5jdGlvbihuLHIpe3JldHVybiBkc2UodGhpcyxuLHIpfSxsLmdldF8wPWZ1bmN0aW9uKG4pe3JldHVybiBWYSh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saXN0SXRlcmF0b3JfMSgwKX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXtyZXR1cm4gczUodGhpcyxuKX0sbC5zZXRfMj1mdW5jdGlvbihuLHIpe3ZhciB0LG87dD10aGlzLmxpc3RJdGVyYXRvcl8xKG4pO3RyeXtyZXR1cm4gbz10Lm5leHRfMSgpLHQuc2V0XzEociksb31jYXRjaChpKXt0aHJvdyBpPXdyKGkpLEwoaSwxMTIpP2IobmV3IG5vKCJDYW4ndCBzZXQgZWxlbWVudCAiK24pKTpiKGkpfX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3RTZXF1ZW50aWFsTGlzdCIsMjA2Mik7ZnVuY3Rpb24gZnNlKGUsbil7cmV0dXJuIG5ldyB5c2UoZS50aGlzJDAxLGUudmFsJGtleTIsbil9ZnVuY3Rpb24gdTUoZSxuKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLnZhbCRrZXkyPW59cCg2NDYsMjA2MixIbSx1NSksbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gZnNlKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49YShLZSh0aGlzLnRoaXMkMDEua2V5VG9LZXlMaXN0LHRoaXMudmFsJGtleTIpLDI2MCksbj9uLmNvdW50OjB9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJMaW5rZWRMaXN0TXVsdGltYXAvMSIsNjQ2KTtmdW5jdGlvbiBwc2UoZSl7dGhpcy50aGlzJDAxPWV9cCgxMzE2LDIwNjgsRGkscHNlKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB1c2UodGhpcy50aGlzJDAxLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGdzZSh0aGlzLnRoaXMkMDEpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiFWeih0aGlzLnRoaXMkMDEsbikubGlzdC5pc0VtcHR5KCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFYyKHRoaXMudGhpcyQwMS5rZXlUb0tleUxpc3QpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlua2VkTGlzdE11bHRpbWFwLzFLZXlTZXRJbXBsIiwxMzE2KTtmdW5jdGlvbiBZeihlKXtpZihlLnRoaXMkMDEubW9kQ291bnQhPWUuZXhwZWN0ZWRNb2RDb3VudCl0aHJvdyBiKG5ldyBYYSl9ZnVuY3Rpb24gZ3NlKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMuc2VlbktleXM9bmV3IHJ4KEtkKHJoKHRoaXMudGhpcyQwMSkuc2l6ZV8xKCkpKSx0aGlzLm5leHRfMD10aGlzLnRoaXMkMDEuaGVhZCx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy50aGlzJDAxLm1vZENvdW50fXAoMTMxNSwxLHN0LGdzZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIFl6KHRoaXMpLCEhdGhpcy5uZXh0XzB9LGwubmV4dF8xPWZ1bmN0aW9uKCl7aWYoWXoodGhpcyksIXRoaXMubmV4dF8wKXRocm93IGIobmV3IFBvKTt0aGlzLmN1cnJlbnQ9dGhpcy5uZXh0XzAsWXIodGhpcy5zZWVuS2V5cyx0aGlzLmN1cnJlbnQua2V5KTtkbyB0aGlzLm5leHRfMD10aGlzLm5leHRfMC5uZXh0XzA7d2hpbGUodGhpcy5uZXh0XzAmJiFZcih0aGlzLnNlZW5LZXlzLHRoaXMubmV4dF8wLmtleSkpO3JldHVybiB0aGlzLmN1cnJlbnQua2V5fSxsLnJlbW92ZT1mdW5jdGlvbigpe1l6KHRoaXMpLHFtKCEhdGhpcy5jdXJyZW50KSxnSShuZXcgYzUodGhpcy50aGlzJDAxLHRoaXMuY3VycmVudC5rZXkpKSx0aGlzLmN1cnJlbnQ9bnVsbCx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy50aGlzJDAxLm1vZENvdW50fSxsLmV4cGVjdGVkTW9kQ291bnQ9MCxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlua2VkTGlzdE11bHRpbWFwL0Rpc3RpbmN0S2V5SXRlcmF0b3IiLDEzMTUpO2Z1bmN0aW9uIEt6KGUpe3RoaXMuaGVhZD1lLHRoaXMudGFpbD1lLGUucHJldmlvdXNTaWJsaW5nPW51bGwsZS5uZXh0U2libGluZz1udWxsLHRoaXMuY291bnQ9MX1wKDI2MCwxLHsyNjA6MX0sS3opLGwuY291bnQ9MCxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlua2VkTGlzdE11bHRpbWFwL0tleUxpc3QiLDI2MCk7ZnVuY3Rpb24gaHNlKGUsbil7dGhpcy5rZXk9ZSx0aGlzLnZhbHVlXzA9bn1wKDUxMSwzNTgsezM1ODoxLDUxMToxLDQ0OjF9LGhzZSksbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9LGwuZ2V0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPXRoaXMudmFsdWVfMCx0aGlzLnZhbHVlXzA9bixyfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlua2VkTGlzdE11bHRpbWFwL05vZGUiLDUxMSk7ZnVuY3Rpb24gWHooZSl7aWYoIWUubmV4dF8wKXRocm93IGIobmV3IFBvKTtyZXR1cm4gZS5wcmV2aW91cz1lLmN1cnJlbnQ9ZS5uZXh0XzAsZS5uZXh0XzA9ZS5uZXh0XzAubmV4dFNpYmxpbmcsKytlLm5leHRJbmRleCxlLmN1cnJlbnQudmFsdWVfMH1mdW5jdGlvbiBtc2UoZSl7aWYoIWUucHJldmlvdXMpdGhyb3cgYihuZXcgUG8pO3JldHVybiBlLm5leHRfMD1lLmN1cnJlbnQ9ZS5wcmV2aW91cyxlLnByZXZpb3VzPWUucHJldmlvdXMucHJldmlvdXNTaWJsaW5nLC0tZS5uZXh0SW5kZXgsZS5jdXJyZW50LnZhbHVlXzB9ZnVuY3Rpb24gYzUoZSxuKXt2YXIgcjt0aGlzLnRoaXMkMDE9ZSx0aGlzLmtleT1uLHI9YShLZShlLmtleVRvS2V5TGlzdCxuKSwyNjApLHRoaXMubmV4dF8wPXI/ci5oZWFkOm51bGx9ZnVuY3Rpb24geXNlKGUsbixyKXt2YXIgdCxvO2lmKHRoaXMudGhpcyQwMT1lLHQ9YShLZShlLmtleVRvS2V5TGlzdCxuKSwyNjApLG89dD90LmNvdW50OjAsX3oocixvKSxyPj0oby8yfDApKWZvcih0aGlzLnByZXZpb3VzPXQ/dC50YWlsOm51bGwsdGhpcy5uZXh0SW5kZXg9bztyKys8bzspbXNlKHRoaXMpO2Vsc2UgZm9yKHRoaXMubmV4dF8wPXQ/dC5oZWFkOm51bGw7ci0tID4wOylYeih0aGlzKTt0aGlzLmtleT1uLHRoaXMuY3VycmVudD1udWxsfXAoNTY2LDEsQ3UsYzUseXNlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5hZGRfMT1mdW5jdGlvbihuKXt0aGlzLnByZXZpb3VzPWp6KHRoaXMudGhpcyQwMSx0aGlzLmtleSxuLHRoaXMubmV4dF8wKSwrK3RoaXMubmV4dEluZGV4LHRoaXMuY3VycmVudD1udWxsfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5uZXh0XzB9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMucHJldmlvdXN9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIFh6KHRoaXMpfSxsLm5leHRJbmRleF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dEluZGV4fSxsLnByZXZpb3VzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbXNlKHRoaXMpfSxsLnByZXZpb3VzSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0SW5kZXgtMX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtxbSghIXRoaXMuY3VycmVudCksdGhpcy5jdXJyZW50IT10aGlzLm5leHRfMD8odGhpcy5wcmV2aW91cz10aGlzLmN1cnJlbnQucHJldmlvdXNTaWJsaW5nLC0tdGhpcy5uZXh0SW5kZXgpOnRoaXMubmV4dF8wPXRoaXMuY3VycmVudC5uZXh0U2libGluZyxlWGUodGhpcy50aGlzJDAxLHRoaXMuY3VycmVudCksdGhpcy5jdXJyZW50PW51bGx9LGwuc2V0XzE9ZnVuY3Rpb24obil7ZHooISF0aGlzLmN1cnJlbnQpLHRoaXMuY3VycmVudC52YWx1ZV8wPW59LGwubmV4dEluZGV4PTAsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpbmtlZExpc3RNdWx0aW1hcC9WYWx1ZUZvcktleUl0ZXJhdG9yIiw1NjYpO2Z1bmN0aW9uIG5YZShlKXtyZXR1cm4gUGEoZSwiYXJyYXlTaXplIiksYkkoTnQoTnQoNSxlKSxlLzEwfDApKX1mdW5jdGlvbiByWGUoZSxuKXt2YXIgcix0LG87aWYoRChuKT09PUQodm4oZSkpKXJldHVybiEwO2lmKCFMKG4sMTUpfHwodD1hKG4sMTUpLG89ZS5zaXplXzEoKSxvIT10LnNpemVfMSgpKSlyZXR1cm4hMTtpZihMKHQsNTkpKXtmb3Iocj0wO3I8bztyKyspaWYoIW51KGUuZ2V0XzAociksdC5nZXRfMChyKSkpcmV0dXJuITE7cmV0dXJuITB9ZWxzZSByZXR1cm4gR0tlKGUuaXRlcmF0b3JfMCgpLHQuaXRlcmF0b3JfMCgpKX1mdW5jdGlvbiB0WGUoZSl7dmFyIG4scix0O2ZvcihuPTEsdD1lLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPXQubmV4dF8xKCksbj0zMSpuKyhyPT1udWxsPzA6dXIocikpLG49fn5uO3JldHVybiBufWZ1bmN0aW9uIG9YZShlLG4pe3ZhciByLHQ7aWYodD1lLnNpemVfMSgpLG49PW51bGwpe2ZvcihyPTA7cjx0O3IrKylpZihlLmdldF8wKHIpPT1udWxsKXJldHVybiByfWVsc2UgZm9yKHI9MDtyPHQ7cisrKWlmKFluKG4sZS5nZXRfMChyKSkpcmV0dXJuIHI7cmV0dXJuLTF9ZnVuY3Rpb24gdjEoZSl7cmV0dXJuIHZuKGUpLEwoZSwxNik/bmV3IFFpKGEoZSwxNikpOlFtKGUuaXRlcmF0b3JfMCgpKX1mdW5jdGlvbiBRbShlKXt2YXIgbjtyZXR1cm4gbj1uZXcgUSxpNShuLGUpLG59ZnVuY3Rpb24gVHMoZSl7dmFyIG4scjtyZXR1cm4gdm4oZSksbj1uWGUoZS5sZW5ndGgpLHI9bmV3IF9pKG4pLCRCKHIsZSkscn1mdW5jdGlvbiBOdShlKXtyZXR1cm4gUGEoZSwiaW5pdGlhbEFycmF5U2l6ZSIpLG5ldyBfaShlKX1mdW5jdGlvbiB3SShlKXtyZXR1cm4gbmV3IF9pKChQYShlLCJhcnJheVNpemUiKSxiSShOdChOdCg1LGUpLGUvMTB8MCkpKSl9ZnVuY3Rpb24gY0MoZSl7dmFyIG47cmV0dXJuIG49bmV3IHByLHQ1KG4sZSksbn1mdW5jdGlvbiBxYShlKXt2YXIgbixyO3JldHVybiBMKGUsMzA3KT8ocj12S2UoYShlLDMwNykpLG49cixuKTpMKGUsNDQxKT9hKGUsNDQxKS5mb3J3YXJkTGlzdDpMKGUsNTkpP25ldyB2c2UoZSk6bmV3IFp6KGUpfXAoMTAzMSw1NixIbSksbC5hZGRfMz1mdW5jdGlvbihuLHIpe3RoaXMuYmFja2luZ0xpc3QuYWRkXzMobixyKX0sbC5hZGRBbGxfMD1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmJhY2tpbmdMaXN0LmFkZEFsbF8wKG4scil9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFja2luZ0xpc3QuY29udGFpbnMobil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFja2luZ0xpc3QuZ2V0XzAobil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFja2luZ0xpc3QucmVtb3ZlXzIobil9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gdGhpcy5iYWNraW5nTGlzdC5zZXRfMihuLHIpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tpbmdMaXN0LnNpemVfMSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlzdHMvQWJzdHJhY3RMaXN0V3JhcHBlciIsMTAzMSkscCgxMDMyLDEwMzEsdGllKSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTGlzdHMvUmFuZG9tQWNjZXNzTGlzdFdyYXBwZXIiLDEwMzIpO2Z1bmN0aW9uIHdzZShlKXt0aGlzLmJhY2tpbmdMaXN0PWEodm4oZSksMTUpfXAoMTAzNCwxMDMyLHRpZSx3c2UpLGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFja2luZ0xpc3QubGlzdEl0ZXJhdG9yXzEobil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJMaXN0cy8xIiwxMDM0KTtmdW5jdGlvbiBFc2UoZSxuKXt2YXIgcix0O3JldHVybiB0PWV5KGUsbikscj1lLmZvcndhcmRMaXN0Lmxpc3RJdGVyYXRvcl8xKHQpLG5ldyBTc2UoZSxyKX1mdW5jdGlvbiBKeihlLG4pe3ZhciByO3JldHVybiByPWUuZm9yd2FyZExpc3Quc2l6ZV8xKCksZUMobixyKSxyLTEtbn1mdW5jdGlvbiBleShlLG4pe3ZhciByO3JldHVybiByPWUuZm9yd2FyZExpc3Quc2l6ZV8xKCksX3oobixyKSxyLW59ZnVuY3Rpb24gWnooZSl7dGhpcy5mb3J3YXJkTGlzdD1hKHZuKGUpLDE1KX1wKDQ0MSw1Nix7NDQxOjEsMjA6MSwzMToxLDU2OjEsMTY6MSwxNToxfSxaeiksbC5hZGRfMz1mdW5jdGlvbihuLHIpe3RoaXMuZm9yd2FyZExpc3QuYWRkXzMoZXkodGhpcyxuKSxyKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5mb3J3YXJkTGlzdC5jbGVhcl8wKCl9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZm9yd2FyZExpc3QuZ2V0XzAoSnoodGhpcyxuKSl9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBFc2UodGhpcywwKX0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gRXNlKHRoaXMsbil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZm9yd2FyZExpc3QucmVtb3ZlXzIoSnoodGhpcyxuKSl9LGwucmVtb3ZlUmFuZ2U9ZnVuY3Rpb24obixyKXsoWGllKG4scix0aGlzLmZvcndhcmRMaXN0LnNpemVfMSgpKSxxYSh0aGlzLmZvcndhcmRMaXN0LnN1Ykxpc3QoZXkodGhpcyxyKSxleSh0aGlzLG4pKSkpLmNsZWFyXzAoKX0sbC5zZXRfMj1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmZvcndhcmRMaXN0LnNldF8yKEp6KHRoaXMsbikscil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZm9yd2FyZExpc3Quc2l6ZV8xKCl9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiBYaWUobixyLHRoaXMuZm9yd2FyZExpc3Quc2l6ZV8xKCkpLHFhKHRoaXMuZm9yd2FyZExpc3Quc3ViTGlzdChleSh0aGlzLHIpLGV5KHRoaXMsbikpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpc3RzL1JldmVyc2VMaXN0Iiw0NDEpO2Z1bmN0aW9uIHZzZShlKXtaei5jYWxsKHRoaXMsZSl9cCgxMDMwLDQ0MSx7NDQxOjEsMjA6MSwzMToxLDU2OjEsMTY6MSwxNToxLDU5OjF9LHZzZSksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpc3RzL1JhbmRvbUFjY2Vzc1JldmVyc2VMaXN0IiwxMDMwKTtmdW5jdGlvbiBTc2UoZSxuKXt0aGlzLnRoaXMkMTE9ZSx0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyPW59cCgxMDMzLDEsQ3UsU3NlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5hZGRfMT1mdW5jdGlvbihuKXt0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyLmFkZF8xKG4pLHRoaXMudmFsJGZvcndhcmRJdGVyYXRvcjIucHJldmlvdXNfMCgpLHRoaXMuY2FuUmVtb3ZlT3JTZXQ9ITF9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGZvcndhcmRJdGVyYXRvcjIuaGFzUHJldmlvdXMoKX0sbC5oYXNQcmV2aW91cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyLmhhc05leHRfMCgpfSxsLm5leHRfMT1mdW5jdGlvbigpe2lmKCF0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyLmhhc1ByZXZpb3VzKCkpdGhyb3cgYihuZXcgUG8pO3JldHVybiB0aGlzLmNhblJlbW92ZU9yU2V0PSEwLHRoaXMudmFsJGZvcndhcmRJdGVyYXRvcjIucHJldmlvdXNfMCgpfSxsLm5leHRJbmRleF8wPWZ1bmN0aW9uKCl7cmV0dXJuIGV5KHRoaXMudGhpcyQxMSx0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyLm5leHRJbmRleF8wKCkpfSxsLnByZXZpb3VzXzA9ZnVuY3Rpb24oKXtpZighdGhpcy52YWwkZm9yd2FyZEl0ZXJhdG9yMi5oYXNOZXh0XzAoKSl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIHRoaXMuY2FuUmVtb3ZlT3JTZXQ9ITAsdGhpcy52YWwkZm9yd2FyZEl0ZXJhdG9yMi5uZXh0XzEoKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIGV5KHRoaXMudGhpcyQxMSx0aGlzLnZhbCRmb3J3YXJkSXRlcmF0b3IyLm5leHRJbmRleF8wKCkpLTF9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7cW0odGhpcy5jYW5SZW1vdmVPclNldCksdGhpcy52YWwkZm9yd2FyZEl0ZXJhdG9yMi5yZW1vdmUoKSx0aGlzLmNhblJlbW92ZU9yU2V0PSExfSxsLnNldF8xPWZ1bmN0aW9uKG4pe2R6KHRoaXMuY2FuUmVtb3ZlT3JTZXQpLHRoaXMudmFsJGZvcndhcmRJdGVyYXRvcjIuc2V0XzEobil9LGwuY2FuUmVtb3ZlT3JTZXQ9ITEsZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIkxpc3RzL1JldmVyc2VMaXN0LzEiLDEwMzMpO2Z1bmN0aW9uIGlYZShlLG4pe3JldHVybiBuZXcgYnNlKGUuaXRlcmF0b3JfMCgpLG4pfWZ1bmN0aW9uIEtkKGUpe3JldHVybiBlPDM/KFBhKGUsImV4cGVjdGVkU2l6ZSIpLGUrMSk6ZTx5Mj9LcihlLy43NSsxKTpxbn1mdW5jdGlvbiBhWGUoZSxuKXt2YXIgcjtyZXR1cm4gZT09PW4/ITA6TChuLDg1KT8ocj1hKG4sODUpLGwkKFNfKGUpLHIuZW50cnlTZXRfMCgpKSk6ITF9ZnVuY3Rpb24gQ3NlKGUpe3ZhciBuLHIsdCxvO2ZvcihuPW5ldyBObGUoZS5kZWxlZ2F0ZUxpc3RfMCgpLnNpemVfMSgpKSxvPTAsdD1haChlLmRlbGVnYXRlTGlzdF8wKCkuaXRlcmF0b3JfMCgpKTt0Lmhhc05leHRfMCgpOylyPXQubmV4dF8xKCksa0tlKG4scixKKG8rKykpO3JldHVybiBUS2Uobi5lbnRyaWVzXzApfWZ1bmN0aW9uIGxYZShlKXtyZXR1cm4gZT9lLmtleTpudWxsfWZ1bmN0aW9uIFRzZShlLG4pe3ZuKGUpO3RyeXtyZXR1cm4gZS5jb250YWluc0tleShuKX1jYXRjaChyKXtpZihyPXdyKHIpLEwociwyMTIpfHxMKHIsMTY5KSlyZXR1cm4hMTt0aHJvdyBiKHIpfX1mdW5jdGlvbiBYZChlLG4pe3ZuKGUpO3RyeXtyZXR1cm4gZS5nZXRfMyhuKX1jYXRjaChyKXtpZihyPXdyKHIpLEwociwyMTIpfHxMKHIsMTY5KSlyZXR1cm4gbnVsbDt0aHJvdyBiKHIpfX1mdW5jdGlvbiBzWGUoZSxuKXt2bihlKTt0cnl7cmV0dXJuIGUucmVtb3ZlXzAobil9Y2F0Y2gocil7aWYocj13cihyKSxMKHIsMjEyKXx8TChyLDE2OSkpcmV0dXJuIG51bGw7dGhyb3cgYihyKX19ZnVuY3Rpb24gdVhlKGUpe3ZhciBuLHIsdCxvO2ZvcihvPXhfKChQYShlLnNpemVfMSgpLCJzaXplIiksbmV3IGZoKSwxMjMpLHQ9ITAscj1TXyhlKS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspbj1hKHIubmV4dF8xKCksNDQpLHR8fChvLnN0cmluZys9IiwgIiksdD0hMSxlaSh4XyhlaShvLG4uZ2V0S2V5KCkpLDYxKSxuLmdldFZhbHVlKCkpO3JldHVybihvLnN0cmluZys9In0iLG8pLnN0cmluZ31mdW5jdGlvbiBjWGUoZSl7cmV0dXJuIGU/ZS52YWx1ZV8wOm51bGx9ZnVuY3Rpb24gRUkoZSl7cmV0dXJuIGEoZSw0NCkuZ2V0S2V5KCl9ZnVuY3Rpb24gazIoZSl7bUkuY2FsbCh0aGlzLGUpfXAoNDQwLDQ5NyxzdCxrMiksbC50cmFuc2Zvcm1fMD1mdW5jdGlvbihuKXtyZXR1cm4gRUkobil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNYXBzLzEiLDQ0MCk7ZnVuY3Rpb24gUXooZSl7bUkuY2FsbCh0aGlzLGUpfXAoNzEyLDQ5NyxzdCxReiksbC50cmFuc2Zvcm1fMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDQ0KS5nZXRWYWx1ZSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTWFwcy8yIiw3MTIpO2Z1bmN0aW9uIGJzZShlLG4pe3RoaXMudmFsJGZ1bmN0aW9uMj1uLG1JLmNhbGwodGhpcyxlKX1wKDk3NSw0OTcsc3QsYnNlKSxsLnRyYW5zZm9ybV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgdzEobixMc2UodGhpcy52YWwkZnVuY3Rpb24yLG4pKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk1hcHMvMyIsOTc1KTtmdW5jdGlvbiBJc2UoZSl7dGhpcy50aGlzJDExPWV9cCg5NzIsMjA2OSxEaSxJc2UpLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3BLZSh0aGlzLnRoaXMkMTEsbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMTEuZW50cnlJdGVyYXRvcigpfSxsLm1hcF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQxMX0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQxMS5lbnRyeVNwbGl0ZXJhdG9yKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNYXBzL0l0ZXJhdG9yQmFzZWRBYnN0cmFjdE1hcC8xIiw5NzIpO2Z1bmN0aW9uIHhzZShlKXt0aGlzLmFjdGlvbl8wPWV9cCg5NzMsMSx7fSx4c2UpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXt0aGlzLmFjdGlvbl8wLmFjY2VwdChuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk1hcHMvS2V5U2V0L2xhbWJkYSQwJFR5cGUiLDk3Myk7ZnVuY3Rpb24gUHNlKGUpe3RoaXMubWFwXzA9YSh2bihlKSw4NSl9cCg5NzEsMzEsR2QsUHNlKSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLm1hcF8wLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXBfMC5jb250YWluc1ZhbHVlKG4pfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXt2bihuKSx0aGlzLm1hcF8wLmZvckVhY2gobmV3IE5zZShuKSl9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLmlzRW1wdHkoKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBReih0aGlzLm1hcF8wLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCkpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByLHQ7dHJ5e3JldHVybiBZZCh0aGlzLG4sITApfWNhdGNoKG8pe2lmKG89d3IobyksTChvLDQ4KSl7Zm9yKHQ9dGhpcy5tYXBfMC5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9YSh0Lm5leHRfMSgpLDQ0KSxudShuLHIuZ2V0VmFsdWUoKSkpcmV0dXJuIHRoaXMubWFwXzAucmVtb3ZlXzAoci5nZXRLZXkoKSksITA7cmV0dXJuITF9ZWxzZSB0aHJvdyBiKG8pfX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5zaXplXzEoKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk1hcHMvVmFsdWVzIiw5NzEpO2Z1bmN0aW9uIE5zZShlKXt0aGlzLmFjdGlvbl8wPWV9cCg5NzQsMSx7fSxOc2UpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXt0aGlzLmFjdGlvbl8wLmFjY2VwdChyKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk1hcHMvVmFsdWVzL2xhbWJkYSQwJFR5cGUiLDk3NCk7ZnVuY3Rpb24gXzUoZSxuKXt2YXIgcjtyZXR1cm4gbj09PWU/ITA6TChuLDIyOSk/KHI9YShuLDIyOSksWW4oZS5hc01hcF8wKCksci5hc01hcF8wKCkpKTohMX1mdW5jdGlvbiBfWGUoZSxuKXtlLm11bHRpbWFwLmtleVNldF8wKCkucmVtb3ZlXzEobil9ZnVuY3Rpb24gZSQoZSl7dGhpcy5tdWx0aW1hcD1hKHZuKGUpLDIyOSl9cCg3NTIsMjA4NSxoMSxlJCksbC5nZXRfMz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tdWx0aW1hcC5jb250YWluc0tleShuKT90aGlzLm11bHRpbWFwLmdldF8xKG4pOm51bGx9LGwucmVtb3ZlXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubXVsdGltYXAuY29udGFpbnNLZXkobik/dGhpcy5tdWx0aW1hcC5yZW1vdmVBbGwobik6bnVsbH0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5tdWx0aW1hcC5jbGVhcl8wKCl9LGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubXVsdGltYXAuY29udGFpbnNLZXkobil9LGwuY3JlYXRlRW50cnlTZXRfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgQXNlKHRoaXMpfSxsLmNyZWF0ZUVudHJ5U2V0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlRW50cnlTZXRfMCgpfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aW1hcC5pc0VtcHR5KCl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aW1hcC5rZXlTZXRfMCgpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm11bHRpbWFwLmtleVNldF8wKCkuc2l6ZV8xKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aW1hcHMvQXNNYXAiLDc1Mik7ZnVuY3Rpb24gQXNlKGUpe3RoaXMudGhpcyQxMT1lfXAoMTEzNCwyMDY5LERpLEFzZSksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIGlYZSh0aGlzLnRoaXMkMTEubXVsdGltYXAua2V5U2V0XzAoKSxuZXcga3NlKHRoaXMpKX0sbC5tYXBfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMTF9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIGdhZSh0aGlzLG4pPyhyPWEod2woYShuLDQ0KSksNDQpLF9YZSh0aGlzLnRoaXMkMTEsci5nZXRLZXkoKSksITApOiExfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTXVsdGltYXBzL0FzTWFwL0VudHJ5U2V0IiwxMTM0KTtmdW5jdGlvbiBMc2UoZSxuKXtyZXR1cm4gZS50aGlzJDIxLnRoaXMkMTEubXVsdGltYXAuZ2V0XzEobil9ZnVuY3Rpb24ga3NlKGUpe3RoaXMudGhpcyQyMT1lfXAoMTEzOCwxLHt9LGtzZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBMc2UodGhpcyxuKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aW1hcHMvQXNNYXAvRW50cnlTZXQvMSIsMTEzOCk7ZnVuY3Rpb24gT3NlKGUsbil7dmFyIHI7cmV0dXJuIHI9YShYZCh0aChlLm11bHRpbWFwKSxuKSwxNikscj9yLnNpemVfMSgpOjB9ZnVuY3Rpb24gTXNlKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKFBhKHIsIm9jY3VycmVuY2VzIikscj09MClyZXR1cm4gdT1hKFhkKHRoKGUubXVsdGltYXApLG4pLDE2KSx1P3Uuc2l6ZV8xKCk6MDtpZihzPWEoWGQodGgoZS5tdWx0aW1hcCksbiksMTYpLCFzKXJldHVybiAwO2lmKGk9cy5zaXplXzEoKSxyPj1pKXMuY2xlYXJfMCgpO2Vsc2UgZm9yKG89cy5pdGVyYXRvcl8wKCksdD0wO3Q8cjt0Kyspby5uZXh0XzEoKSxvLnJlbW92ZSgpO3JldHVybiBpfWZ1bmN0aW9uIFJzZShlKXt0aGlzLm11bHRpbWFwPWV9cCg1NTIsMjA4Nyx7NTUyOjEsODQ5OjEsMjA6MSwzMToxLDE2OjF9LFJzZSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dEkodGhpcy5tdWx0aW1hcCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHJhZSh0aGlzLm11bHRpbWFwLG4pfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXt2bihuKSxFdChDMih0aGlzLm11bHRpbWFwKSxuZXcgJHNlKG4pKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBrMihDMih0aGlzLm11bHRpbWFwKS50aGlzJDAxLmVudHJ5SXRlcmF0b3IoKSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubXVsdGltYXAudG90YWxTaXplfSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYUMoQzIodGhpcy5tdWx0aW1hcCkuc3BsaXRlcmF0b3JfMCgpLG5ldyBEc2UpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTXVsdGltYXBzL0tleXMiLDU1Mik7ZnVuY3Rpb24gRHNlKCl7fXAoMTEzNiwxLHt9LERzZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNDQpLmdldEtleSgpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiTXVsdGltYXBzL0tleXMvMG1ldGhvZHJlZiRnZXRLZXkkVHlwZSIsMTEzNik7ZnVuY3Rpb24gRnNlKGUpe21JLmNhbGwodGhpcyxlKX1wKDExMzUsNDk3LHN0LEZzZSksbC50cmFuc2Zvcm1fMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IHpzZShhKG4sNDQpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk11bHRpbWFwcy9LZXlzLzEiLDExMzUpLHAoMjA4OCwxLHs0MjU6MX0pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIEwobiw1MDQpPyhyPWEobiw0MjUpLGEodGhpcy52YWwkYmFja2luZ0VudHJ5Mi5nZXRWYWx1ZSgpLDE2KS5zaXplXzEoKT09YShyLnZhbCRiYWNraW5nRW50cnkyLmdldFZhbHVlKCksMTYpLnNpemVfMSgpJiZudSh0aGlzLnZhbCRiYWNraW5nRW50cnkyLmdldEtleSgpLHIudmFsJGJhY2tpbmdFbnRyeTIuZ2V0S2V5KCkpKTohMX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy52YWwkYmFja2luZ0VudHJ5Mi5nZXRLZXkoKSwobj09bnVsbD8wOnVyKG4pKV5hKHRoaXMudmFsJGJhY2tpbmdFbnRyeTIuZ2V0VmFsdWUoKSwxNikuc2l6ZV8xKCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIHI9ejIodGhpcy52YWwkYmFja2luZ0VudHJ5Mi5nZXRLZXkoKSksbj1hKHRoaXMudmFsJGJhY2tpbmdFbnRyeTIuZ2V0VmFsdWUoKSwxNikuc2l6ZV8xKCksbj09MT9yOnIrIiB4ICIrbn0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk11bHRpc2V0cy9BYnN0cmFjdEVudHJ5IiwyMDg4KTtmdW5jdGlvbiB6c2UoZSl7dGhpcy52YWwkYmFja2luZ0VudHJ5Mj1lfXAoNTA0LDIwODgsezUwNDoxLDQyNToxfSx6c2UpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aW1hcHMvS2V5cy8xLzEiLDUwNCk7ZnVuY3Rpb24gJHNlKGUpe3RoaXMuY29uc3VtZXJfMD1lfXAoMTEzNywxLEplLCRzZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7dGhpcy5jb25zdW1lcl8wLmFjY2VwdChhKG4sNDQpLmdldEtleSgpKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIk11bHRpbWFwcy9LZXlzL2xhbWJkYSQxJFR5cGUiLDExMzcpO2Z1bmN0aW9uIEJzZSgpe31wKDExNDAsMSxKZSxCc2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3JLZShhKG4sNDI1KSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aXNldC9sYW1iZGEkMCRUeXBlIiwxMTQwKTtmdW5jdGlvbiBHc2UoZSl7dGhpcy5hY3Rpb25fMD1lfXAoNzUzLDEsSmUsR3NlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt0S2UodGhpcy5hY3Rpb25fMCxhKG4sNDI1KSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aXNldC9sYW1iZGEkMSRUeXBlIiw3NTMpO2Z1bmN0aW9uIGRYZShlKXtyZXR1cm4gQ3AoZSkuaXNFbXB0eSgpPyExOihvS2UoZSxuZXcgSHNlKSwhMCl9ZnVuY3Rpb24gZlhlKGUsbil7dmFyIHIsdCxvO2lmKG49PT1lKXJldHVybiEwO2lmKEwobiw1NTIpKXtpZihvPWEobiw4NDkpLGUubXVsdGltYXAudG90YWxTaXplIT1vLm11bHRpbWFwLnRvdGFsU2l6ZXx8Q3AoZSkuc2l6ZV8xKCkhPUNwKG8pLnNpemVfMSgpKXJldHVybiExO2Zvcih0PUNwKG8pLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylpZihyPWEodC5uZXh0XzEoKSw0MjUpLE9zZShlLHIudmFsJGJhY2tpbmdFbnRyeTIuZ2V0S2V5KCkpIT1hKHIudmFsJGJhY2tpbmdFbnRyeTIuZ2V0VmFsdWUoKSwxNikuc2l6ZV8xKCkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gcFhlKGUpe3JldHVybiBuZXcgeGUodVFlKGEoZS52YWwkYmFja2luZ0VudHJ5Mi5nZXRWYWx1ZSgpLDE2KS5zaXplXzEoKSxlLnZhbCRiYWNraW5nRW50cnkyLmdldEtleSgpKSwxNil9ZnVuY3Rpb24gZ1hlKGUsbixyKXt2YXIgdCxvLGkscztyZXR1cm4gUGEociwib2xkQ291bnQiKSxQYSgwLCJuZXdDb3VudCIpLHQ9YShYZCh0aChlLm11bHRpbWFwKSxuKSwxNiksKHQ/dC5zaXplXzEoKTowKT09cj8oUGEoMCwiY291bnQiKSxvPShpPWEoWGQodGgoZS5tdWx0aW1hcCksbiksMTYpLGk/aS5zaXplXzEoKTowKSxzPS1vLHM+MD9QeigpOnM8MCYmTXNlKGUsbiwtcyksITApOiExfWZ1bmN0aW9uIEhzZSgpe31wKDExNDEsMSx7fSxIc2UpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aXNldHMvMG1ldGhvZHJlZiRhZGQkVHlwZSIsMTE0MSk7ZnVuY3Rpb24gVXNlKCl7fXAoNzU0LDEse30sVXNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHBYZShhKG4sNDI1KSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJNdWx0aXNldHMvbGFtYmRhJDEkVHlwZSIsNzU0KSxwKDIxMDYsMSxVUyksZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlJhbmdlR3d0U2VyaWFsaXphdGlvbkRlcGVuZGVuY2llcyIsMjEwNik7ZnVuY3Rpb24gdkkoKXt2ST1GLG5ldyBuJCgoSDYoKSxVNiksKEI2KCksRzYpKX1mdW5jdGlvbiBXc2UoZSxuKXtyZXR1cm4gdm4obiksZS5sb3dlckJvdW5kLmlzTGVzc1RoYW4obikmJiFlLnVwcGVyQm91bmQuaXNMZXNzVGhhbihuKX1mdW5jdGlvbiBuJChlLG4pe2lmKHRoaXMubG93ZXJCb3VuZD1hKHZuKGUpLDI1MyksdGhpcy51cHBlckJvdW5kPWEodm4obiksMjUzKSxlLmNvbXBhcmVUbyhuKT4wfHxlPT0oQjYoKSxHNil8fG49PShINigpLFU2KSl0aHJvdyBiKG5ldyBHZSgiSW52YWxpZCByYW5nZTogIitWc2UoZSxuKSkpfWZ1bmN0aW9uIGpzZShlLG4pe3JldHVybiB2SSgpLG5ldyBuJChuZXcgaWxlKGUpLG5ldyB0bGUobikpfWZ1bmN0aW9uIFZzZShlLG4pe3ZhciByO3JldHVybiByPW5ldyBmaCxlLmRlc2NyaWJlQXNMb3dlckJvdW5kKHIpLHIuc3RyaW5nKz0iLi4iLG4uZGVzY3JpYmVBc1VwcGVyQm91bmQociksci5zdHJpbmd9cCg1MjEsMjEwNix7MTc4OjEsNTIxOjEsMzoxLDQ2OjF9LG4kKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIFdzZSh0aGlzLGEobiwzNCkpfSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gV3NlKHRoaXMsYShuLDM0KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIEwobiw1MjEpPyhyPWEobiw1MjEpLER6KHRoaXMubG93ZXJCb3VuZCxyLmxvd2VyQm91bmQpJiZEeih0aGlzLnVwcGVyQm91bmQsci51cHBlckJvdW5kKSk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvd2VyQm91bmQuaGFzaENvZGVfMSgpKjMxK3RoaXMudXBwZXJCb3VuZC5oYXNoQ29kZV8xKCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBWc2UodGhpcy5sb3dlckJvdW5kLHRoaXMudXBwZXJCb3VuZCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJSYW5nZSIsNTIxKTtmdW5jdGlvbiBoWGUoZSxuKXt0aGlzLmRlbGVnYXRlPWUsdGhpcy5kZWxlZ2F0ZUxpc3Q9bn1mdW5jdGlvbiByJChlLG4pe3kxKCksaFhlLmNhbGwodGhpcyxlLHNJKG5ldyBlYShuKSkpfXAoNjU0LDIwOTcsQm0sciQpLGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7cmV0dXJuIGo2KHRoaXMuZGVsZWdhdGVMaXN0LG4pfSxsLmRlbGVnYXRlQ29sbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlfSxsLmdldF8wPWZ1bmN0aW9uKG4pe3JldHVybiB5MCh0aGlzLmRlbGVnYXRlTGlzdCxuKX0sbC5saXN0SXRlcmF0b3JfMj1mdW5jdGlvbihuKXtyZXR1cm4gajYodGhpcy5kZWxlZ2F0ZUxpc3Qsbil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJSZWd1bGFySW1tdXRhYmxlQXNMaXN0Iiw2NTQpO2Z1bmN0aW9uIGQ1KGUpe3RoaXMuZGVsZWdhdGU9KE5lKCksTChlLDU5KT9uZXcgZWsoZSk6bmV3IG54KGUpKX1wKDY1NiwyMTA1LEJtLGQ1KSxsLmRlbGVnYXRlTGlzdF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGV9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJSZWd1bGFySW1tdXRhYmxlTGlzdCIsNjU2KTtmdW5jdGlvbiB0JChlKXt4S2UuY2FsbCh0aGlzLGUpfWZ1bmN0aW9uIG8kKGUpe3QkLmNhbGwodGhpcyxlKX1wKDU0OCw3MzAsR20sdCQsbyQpLGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJSZWd1bGFySW1tdXRhYmxlTWFwIiw1NDgpO2Z1bmN0aW9uIGY1KCl7ZjU9RixydSgpLGEkPW5ldyBpJCgoTmUoKSxOZSgpLGV4KSl9ZnVuY3Rpb24gaSQoZSl7ZjUoKSxfbGUuY2FsbCh0aGlzLGUpfXAoNzMxLDcxOSxRZyxpJCk7dmFyIGEkO2coImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJSZWd1bGFySW1tdXRhYmxlU2V0Iiw3MzEpO2Z1bmN0aW9uIGwkKGUsbil7dmFyIHI7aWYoRChlKT09PUQobikpcmV0dXJuITA7aWYoTChuLDIxKSl7cj1hKG4sMjEpO3RyeXtyZXR1cm4gZS5zaXplXzEoKT09ci5zaXplXzEoKSYmZS5jb250YWluc0FsbChyKX1jYXRjaCh0KXtpZih0PXdyKHQpLEwodCwxNjkpfHxMKHQsMjEyKSlyZXR1cm4hMTt0aHJvdyBiKHQpfX1yZXR1cm4hMX1mdW5jdGlvbiBxc2UoZSl7dmFyIG4scix0O2ZvcihuPTAsdD1lLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPXQubmV4dF8xKCksbis9ciE9bnVsbD91cihyKTowLG49fn5uO3JldHVybiBufWZ1bmN0aW9uIFNJKGUsbil7cmV0dXJuIG5JKGUsInNldDEiKSxuSShuLCJzZXQyIiksbmV3IFhzZShlLG4pfWZ1bmN0aW9uIENJKGUpe3JldHVybiBMKGUsMTYpP25ldyBuRShhKGUsMTYpKTptWGUoZS5pdGVyYXRvcl8wKCkpfWZ1bmN0aW9uIG1YZShlKXt2YXIgbjtyZXR1cm4gbj1uZXcgQnIsaTUobixlKSxufWZ1bmN0aW9uIFlzZShlKXt2YXIgbjtyZXR1cm4gbj1uZXcgcngoS2QoZS5sZW5ndGgpKSwkQihuLGUpLG59ZnVuY3Rpb24gVEkoZSl7dmFyIG47cmV0dXJuIGU/bmV3IGNHKGUpOihuPW5ldyBsdSx0NShuLGUpLG4pfWZ1bmN0aW9uIEtzZShlKXt2YXIgbjtyZXR1cm4gbj1uZXcga0csdDUobixlKSxufWZ1bmN0aW9uIHMkKGUpe3JldHVybiBMKGUsNjE2KT9lOm5ldyBRc2UoZSl9cCgyMDc0LFNzLERpKSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHUkKHRoaXMudmFsJHNldDExLHRoaXMudmFsJHNldDIyKX0sbC5hZGRfMj1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlNldHMvU2V0VmlldyIsMjA3NCk7ZnVuY3Rpb24gX0MoZSl7dmFyIG4scix0O2Zvcih0PTAscj1uZXcgd2goZS52YWwkc2V0MTEpO3IuaTxyLnRoaXMkMTEuYWxsLmxlbmd0aDspbj1lRShyKSxlLnZhbCRzZXQyMi5jb250YWlucyhuKSYmKyt0O3JldHVybiB0fWZ1bmN0aW9uIFhzZShlLG4pe3RoaXMudmFsJHNldDExPWUsdGhpcy52YWwkc2V0MjI9bn1wKDk3NiwyMDc0LERpLFhzZSksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1JCh0aGlzLnZhbCRzZXQxMSx0aGlzLnZhbCRzZXQyMil9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHJrKHRoaXMudmFsJHNldDExLG4pJiZ0aGlzLnZhbCRzZXQyMi5jb250YWlucyhuKX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gckModGhpcy52YWwkc2V0MTEsbikmJnRoaXMudmFsJHNldDIyLmNvbnRhaW5zQWxsKG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gbDBlKHRoaXMudmFsJHNldDIyLHRoaXMudmFsJHNldDExKX0sbC5wYXJhbGxlbFN0cmVhbT1mdW5jdGlvbigpe3JldHVybiBKbihuZXcgU2UobnVsbCxuZXcgeGUodGhpcy52YWwkc2V0MTEsMSkpLG5ldyBac2UodGhpcy52YWwkc2V0MjIpKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gX0ModGhpcyl9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIEpuKG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLnZhbCRzZXQxMSwxKSksbmV3IEpzZSh0aGlzLnZhbCRzZXQyMikpfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiU2V0cy8yIiw5NzYpO2Z1bmN0aW9uIEpzZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoOTc3LDEsSW4sSnNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy4kJG91dGVyXzAuY29udGFpbnMobil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJTZXRzLzIvMG1ldGhvZHJlZiRjb250YWlucyRUeXBlIiw5NzcpO2Z1bmN0aW9uIHUkKGUsbil7dGhpcy52YWwkc2V0MTI9ZSx0aGlzLnZhbCRzZXQyMz1uLHRoaXMuaXRyPW5ldyB3aCh0aGlzLnZhbCRzZXQxMil9cCg3MTQsNzEzLHptLHUkKSxsLmNvbXB1dGVOZXh0PWZ1bmN0aW9uKCl7Zm9yKHZhciBuO1FCKHRoaXMuaXRyKTspaWYobj1lRSh0aGlzLml0ciksdGhpcy52YWwkc2V0MjMuY29udGFpbnMobikpcmV0dXJuIG47cmV0dXJuIHRoaXMuc3RhdGU9MixudWxsfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiU2V0cy8yLzEiLDcxNCk7ZnVuY3Rpb24gWnNlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCg5NzgsMSxJbixac2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLiQkb3V0ZXJfMC5jb250YWlucyhuKX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlNldHMvMi8xbWV0aG9kcmVmJGNvbnRhaW5zJFR5cGUiLDk3OCk7ZnVuY3Rpb24gUXNlKGUpe3RoaXMuZGVsZWdhdGU9YSh2bihlKSwyNzcpLHRoaXMudW5tb2RpZmlhYmxlRGVsZWdhdGU9KE5lKCksbmV3IFZCKGUpKX1wKDYxNiwyMDczLHs2MTY6MSwzOjEsMjA6MSwxNjoxLDI3NzoxLDIxOjEsODc6MX0sUXNlKSxsLmRlbGVnYXRlXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51bm1vZGlmaWFibGVEZWxlZ2F0ZX0sbC5kZWxlZ2F0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudW5tb2RpZmlhYmxlRGVsZWdhdGV9LGwuZGVsZWdhdGVfMj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnVubW9kaWZpYWJsZURlbGVnYXRlfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXt0aGlzLmRlbGVnYXRlLmZvckVhY2hfMChuKX0sbC5wYXJhbGxlbFN0cmVhbT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlLnBhcmFsbGVsU3RyZWFtKCl9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGUuc3RyZWFtKCl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJTZXRzL1VubW9kaWZpYWJsZU5hdmlnYWJsZVNldCIsNjE2KTtmdW5jdGlvbiBldWUoZSxuKXtMS2UuY2FsbCh0aGlzLGNRZSh2bihlKSx2bihuKSkpLHRoaXMuc2luZ2xlVmFsdWU9bn1wKDIwMzEsMjAzMCxHbSxldWUpLGwudmFsdWVzXzI9ZnVuY3Rpb24oKXtyZXR1cm4gcnUoKSxuZXcgbGgodGhpcy5zaW5nbGVWYWx1ZSl9LGwudmFsdWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gcnUoKSxuZXcgbGgodGhpcy5zaW5nbGVWYWx1ZSl9LGwudmFsdWVzXzE9ZnVuY3Rpb24oKXtyZXR1cm4gcnUoKSxuZXcgbGgodGhpcy5zaW5nbGVWYWx1ZSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJTaW5nbGV0b25JbW11dGFibGVCaU1hcCIsMjAzMSk7ZnVuY3Rpb24gcDUoZSl7eTEoKSx0aGlzLmRlbGVnYXRlPShOZSgpLG5ldyBaNSh2bihlKSkpfXAoNjU3LDIxMDUsQm0scDUpLGwuZGVsZWdhdGVMaXN0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlNpbmdsZXRvbkltbXV0YWJsZUxpc3QiLDY1Nyk7ZnVuY3Rpb24gbGgoZSl7cnUoKSx0aGlzLmVsZW1lbnQ9dm4oZSl9cCgzNjMsMjA3OSxRZyxsaCksbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBHeih0aGlzLmVsZW1lbnQpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBZbih0aGlzLmVsZW1lbnQsbil9LGwuaXRlcmF0b3JfMT1mdW5jdGlvbigpe3JldHVybiBuZXcgR3oodGhpcy5lbGVtZW50KX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZygiY29tLmdvb2dsZS5jb21tb24uY29sbGVjdCIsIlNpbmdsZXRvbkltbXV0YWJsZVNldCIsMzYzKTtmdW5jdGlvbiB5WGUoZSl7dmFyIG4scix0LG87Zm9yKHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSx0RShuKX1mdW5jdGlvbiB3WGUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfO2Zvcih0PSExLG49MzM2LHI9MCxpPW5ldyB4bGUoZS5sZW5ndGgpLHU9ZSxjPTAsXz11Lmxlbmd0aDtjPF87KytjKXM9dVtjXSx0PXR8KFAwKHMpLCExKSxvPSh4MChzKSxzLnNwbGl0ZXJhdG9yKSxlZShpLmNvbnRlbnRzLHZuKG8pKSxuJj1vLmNoYXJhY3RlcmlzdGljc18wKCkscj1TWGUocixvLmVzdGltYXRlU2l6ZV8wKCkpO3JldHVybiBhKGEoQjFlKG5ldyBTZShudWxsLEY2KG5ldyB4ZSgoeTEoKSwkeihpLmNvbnRlbnRzKSksMTYpLG5ldyBudWUsbixyKSksbmV3IHJ1ZShlKSksNjg3KSw4NDgpfWZ1bmN0aW9uIG51ZSgpe31wKDExNDgsMSx7fSxudWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDE1OSl9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJTdHJlYW1zL2xhbWJkYSQwJFR5cGUiLDExNDgpO2Z1bmN0aW9uIHJ1ZShlKXt0aGlzLnN0cmVhbXNfMD1lfXAoMTE0OSwxLFViLHJ1ZSksbC5ydW49ZnVuY3Rpb24oKXt5WGUodGhpcy5zdHJlYW1zXzApfSxnKCJjb20uZ29vZ2xlLmNvbW1vbi5jb2xsZWN0IiwiU3RyZWFtcy9sYW1iZGEkMSRUeXBlIiwxMTQ5KTtmdW5jdGlvbiBFWGUoZSxuKXt2YXIgcix0LG87cmV0dXJuIG49PT1lPyEwOkwobiw2NzgpPyhvPWEobiwyMDQ2KSxmYWUoKHQ9ZS5jZWxsU2V0LHR8fChlLmNlbGxTZXQ9bmV3IE02KGUpKSksKHI9by5jZWxsU2V0LHJ8fChvLmNlbGxTZXQ9bmV3IE02KG8pKSkpKTohMX1mdW5jdGlvbiB0dWUoZSxuKXtpS2UuY2FsbCh0aGlzLG5ldyBtayhlKSksdGhpcy5rZXlDb21wYXJhdG9yPWUsdGhpcy52YWx1ZUNvbXBhcmF0b3I9bn1mdW5jdGlvbiB2WGUoZSxuKXtyZXR1cm4gbmV3IHR1ZShhKHZuKGUpLDUwKSxhKHZuKG4pLDUwKSl9cCgxNzI1LDE3MjQsZl8sdHVlKSxsLmFzTWFwXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmFzTWFwLGEoYShufHwodGhpcy5hc01hcD1MKHRoaXMubWFwXzAsMTM5KT9uZXcgeDIodGhpcyxhKHRoaXMubWFwXzAsMTM5KSk6TCh0aGlzLm1hcF8wLDEzMyk/bmV3IHRDKHRoaXMsYSh0aGlzLm1hcF8wLDEzMykpOm5ldyBZbSh0aGlzLHRoaXMubWFwXzApKSwxMzMpLDEzOSl9LGwuY3JlYXRlQ29sbGVjdGlvbj1mdW5jdGlvbigpe3JldHVybiBuZXcgRmModGhpcy52YWx1ZUNvbXBhcmF0b3IpfSxsLmNyZWF0ZUNvbGxlY3Rpb25fMT1mdW5jdGlvbigpe3JldHVybiBuZXcgRmModGhpcy52YWx1ZUNvbXBhcmF0b3IpfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5rZXlTZXQsYShhKG58fCh0aGlzLmtleVNldD1MKHRoaXMubWFwXzAsMTM5KT9uZXcgS20odGhpcyxhKHRoaXMubWFwXzAsMTM5KSk6TCh0aGlzLm1hcF8wLDEzMyk/bmV3IG9DKHRoaXMsYSh0aGlzLm1hcF8wLDEzMykpOm5ldyBTcCh0aGlzLHRoaXMubWFwXzApKSw4NyksMjc3KX0sbC5jcmVhdGVBc01hcD1mdW5jdGlvbigpe3JldHVybiBMKHRoaXMubWFwXzAsMTM5KT9uZXcgeDIodGhpcyxhKHRoaXMubWFwXzAsMTM5KSk6TCh0aGlzLm1hcF8wLDEzMyk/bmV3IHRDKHRoaXMsYSh0aGlzLm1hcF8wLDEzMykpOm5ldyBZbSh0aGlzLHRoaXMubWFwXzApfSxsLmNyZWF0ZUNvbGxlY3Rpb25fMD1mdW5jdGlvbihuKXtyZXR1cm4gbj09bnVsbCYmdGhpcy5rZXlDb21wYXJhdG9yLmNvbXBhcmVfMShuLG4pLG5ldyBGYyh0aGlzLnZhbHVlQ29tcGFyYXRvcil9LGcoImNvbS5nb29nbGUuY29tbW9uLmNvbGxlY3QiLCJUcmVlTXVsdGltYXAiLDE3MjUpO2Z1bmN0aW9uIGJzKCl7YnM9RixTLk1hdGgubG9nKDIpfWZ1bmN0aW9uIFMxKGUsbil7cmV0dXJuIGJzKCksa2woZzApLFMuTWF0aC5hYnMoZS1uKTw9ZzB8fGU9PW58fGlzTmFOKGUpJiZpc05hTihuKT8wOmU8bj8tMTplPm4/MTpDMShpc05hTihlKSxpc05hTihuKSl9ZnVuY3Rpb24gYyQoZSxuKXtyZXR1cm4gYnMoKSxrbChnMCksUy5NYXRoLmFicyhlLW4pPD1nMHx8ZT09bnx8aXNOYU4oZSkmJmlzTmFOKG4pfWZ1bmN0aW9uIFNYZShlLG4pe3ZhciByO3JldHVybiByPU50KGUsbikseDUoUDUoZSxuKSwwKXxCSShQNShlLHIpLDApP3I6TnQoalMsUDUodjAociw2MyksMSkpfWZ1bmN0aW9uIGtsKGUpe2lmKCEoZT49MCkpdGhyb3cgYihuZXcgR2UoInRvbGVyYW5jZSAoIitlKyIpIG11c3QgYmUgPj0gMCIpKTtyZXR1cm4gZX1mdW5jdGlvbiBDMShlLG4pe3JldHVybiBlPT1uPzA6ZT8xOi0xfWZ1bmN0aW9uIGJJKGUpe3JldHVybiBWbyhlLHFuKT4wP3FuOlZvKGUsYnQpPDA/YnQ6U24oZSl9ZnVuY3Rpb24gSUkoZSl7ZS5zdGFja1RyYWNlPUIoYUIsWCwzMTksMCwwLDEpfWZ1bmN0aW9uIENYZShlLG4pe25IKG4sIkNhbm5vdCBzdXBwcmVzcyBhIG51bGwgZXhjZXB0aW9uLiIpLEhDKG4hPWUsIkV4Y2VwdGlvbiBjYW4gbm90IHN1cHByZXNzIGl0c2VsZi4iKSwhZS5kaXNhYmxlU3VwcHJlc3Npb24mJihlLnN1cHByZXNzZWRFeGNlcHRpb25zPT1udWxsP2Uuc3VwcHJlc3NlZEV4Y2VwdGlvbnM9UChJKGc1LDEpLFgsODIsMCxbbl0pOmUuc3VwcHJlc3NlZEV4Y2VwdGlvbnNbZS5zdXBwcmVzc2VkRXhjZXB0aW9ucy5sZW5ndGhdPW4pfWZ1bmN0aW9uIHhJKGUpe3JldHVybiBlLndyaXRhYmxlU3RhY2tUcmFjZSYmKGUuYmFja2luZ0pzT2JqZWN0IT09Il9fbm9pbml0X18iJiZlLmluaXRpYWxpemVCYWNraW5nRXJyb3IoKSxlLnN0YWNrVHJhY2U9bnVsbCksZX1mdW5jdGlvbiBvdWUoZSxuKXtpZihuIGluc3RhbmNlb2YgT2JqZWN0KXRyeXtpZihuLl9famF2YSRleGNlcHRpb249ZSxuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZigibXNpZSIpIT0tMSYmJGRvYy5kb2N1bWVudE1vZGU8OSlyZXR1cm47dmFyIHI9ZTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLHtjYXVzZTp7Z2V0OmZ1bmN0aW9uKCl7dmFyIHQ9ci5nZXRDYXVzZSgpO3JldHVybiB0JiZ0LmdldEJhY2tpbmdKc09iamVjdCgpfX0sc3VwcHJlc3NlZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHIuZ2V0QmFja2luZ1N1cHByZXNzZWQoKX19fSl9Y2F0Y2h7fX1mdW5jdGlvbiBfJChlLG4scil7dmFyIHQsbyxpLHMsdTtmb3IoVFhlKGUpLG89KGUuc3VwcHJlc3NlZEV4Y2VwdGlvbnM9PW51bGwmJihlLnN1cHByZXNzZWRFeGNlcHRpb25zPUIoZzUsWCw4MiwwLDAsMSkpLGUuc3VwcHJlc3NlZEV4Y2VwdGlvbnMpLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpdD1vW2ldLF8kKHQpO3U9ZS5jYXVzZV8wLHUmJl8kKHUpfWZ1bmN0aW9uIFRYZShlKXt2YXIgbixyLHQsbztmb3Iobj0oZS5zdGFja1RyYWNlPT1udWxsJiYoZS5zdGFja1RyYWNlPShueSgpLG89bTUuZ2V0U3RhY2tUcmFjZShlKSxVWGUobykpKSxlLnN0YWNrVHJhY2UpLHI9MCx0PW4ubGVuZ3RoO3I8dDsrK3IpO31mdW5jdGlvbiBiWGUoZSxuKXtlLmJhY2tpbmdKc09iamVjdD1uLG91ZShlLG4pfWZ1bmN0aW9uIFBJKGUsbil7dmFyIHI7cmV0dXJuIHI9eV8oZS5fX19jbGF6eiksbj09bnVsbD9yOnIrIjogIitufWZ1bmN0aW9uIGl1ZSgpe0lJKHRoaXMpLHhJKHRoaXMpLHRoaXMuaW5pdGlhbGl6ZUJhY2tpbmdFcnJvcigpfWZ1bmN0aW9uIGF1ZShlKXtJSSh0aGlzKSx0aGlzLmRldGFpbE1lc3NhZ2U9ZSx4SSh0aGlzKSx0aGlzLmluaXRpYWxpemVCYWNraW5nRXJyb3IoKX1mdW5jdGlvbiBsdWUoZSxuKXtJSSh0aGlzKSx0aGlzLmNhdXNlXzA9bix0aGlzLmRldGFpbE1lc3NhZ2U9ZSx4SSh0aGlzKSx0aGlzLmluaXRpYWxpemVCYWNraW5nRXJyb3IoKX1mdW5jdGlvbiBJWGUoZSl7aWYoISgic3RhY2siaW4gZSkpdHJ5e3Rocm93IGV9Y2F0Y2h7fXJldHVybiBlfXAoODIsMSx7MzoxLDgyOjF9KSxsLmNyZWF0ZUVycm9yPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgRXJyb3Iobil9LGwuZ2V0QmFja2luZ0pzT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYmFja2luZ0pzT2JqZWN0fSxsLmdldEJhY2tpbmdTdXBwcmVzc2VkPWZ1bmN0aW9uKCl7dmFyIG4scix0O2Zvcih0PSh0aGlzLnN1cHByZXNzZWRFeGNlcHRpb25zPT1udWxsJiYodGhpcy5zdXBwcmVzc2VkRXhjZXB0aW9ucz1CKGc1LFgsODIsMCwwLDEpKSx0aGlzLnN1cHByZXNzZWRFeGNlcHRpb25zKSxyPUIoUXIsTWUsMSx0Lmxlbmd0aCw1LDEpLG49MDtuPHQubGVuZ3RoO24rKylyW25dPXRbbl0uYmFja2luZ0pzT2JqZWN0O3JldHVybiByfSxsLmdldENhdXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2F1c2VfMH0sbC5nZXRNZXNzYWdlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGV0YWlsTWVzc2FnZX0sbC5pbml0aWFsaXplQmFja2luZ0Vycm9yPWZ1bmN0aW9uKCl7YlhlKHRoaXMsSVhlKHRoaXMuY3JlYXRlRXJyb3IoUEkodGhpcyx0aGlzLmRldGFpbE1lc3NhZ2UpKSkpLGd1ZSh0aGlzKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIFBJKHRoaXMsdGhpcy5nZXRNZXNzYWdlKCkpfSxsLmJhY2tpbmdKc09iamVjdD0iX19ub2luaXRfXyIsbC5kaXNhYmxlU3VwcHJlc3Npb249ITEsbC53cml0YWJsZVN0YWNrVHJhY2U9ITA7dmFyIGc1PWcoImphdmEubGFuZyIsIlRocm93YWJsZSIsODIpO3AoMTAzLDgyLHszOjEsMTAzOjEsODI6MX0pLGcoImphdmEubGFuZyIsIkV4Y2VwdGlvbiIsMTAzKTtmdW5jdGlvbiBDXygpe2l1ZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIElvKGUpe2F1ZS5jYWxsKHRoaXMsZSl9cCg2MywxMDMsS3UsQ18sSW8pLGcoImphdmEubGFuZyIsIlJ1bnRpbWVFeGNlcHRpb24iLDYzKSxwKDYwNyw2MyxLdSksZygiamF2YS5sYW5nIiwiSnNFeGNlcHRpb24iLDYwNykscCg4NzUsNjA3LEt1KSxnKCJjb20uZ29vZ2xlLmd3dC5jb3JlLmNsaWVudC5pbXBsIiwiSmF2YVNjcmlwdEV4Y2VwdGlvbkJhc2UiLDg3NSk7ZnVuY3Rpb24gc3VlKCl7c3VlPUYsZCQ9bmV3IHppZX1mdW5jdGlvbiB4WGUoZSl7dmFyIG47ZS5tZXNzYWdlXzA9PW51bGwmJihuPUQoZS5lKT09PUQoZCQpP251bGw6ZS5lLGUubmFtZV8wPW49PW51bGw/Im51bGwiOkJpZShuKT9OWGUoJGllKG4pKTp1dChuKT8iU3RyaW5nIjp5Xyh3YShuKSksZS5kZXNjcmlwdGlvbj1lLmRlc2NyaXB0aW9uKyI6ICIrKEJpZShuKT9QWGUoJGllKG4pKTpuKyIiKSxlLm1lc3NhZ2VfMD0iKCIrZS5uYW1lXzArIikgIitlLmRlc2NyaXB0aW9uKX1mdW5jdGlvbiB1dWUoZSl7c3VlKCksSUkodGhpcykseEkodGhpcyksdGhpcy5iYWNraW5nSnNPYmplY3Q9ZSxvdWUodGhpcyxlKSx0aGlzLmRldGFpbE1lc3NhZ2U9ZT09bnVsbD8ibnVsbCI6dm8oZSksdGhpcy5kZXNjcmlwdGlvbj0iIix0aGlzLmU9ZSx0aGlzLmRlc2NyaXB0aW9uPSIifWZ1bmN0aW9uIFBYZShlKXtyZXR1cm4gZT09bnVsbD9udWxsOmUubWVzc2FnZX1mdW5jdGlvbiBOWGUoZSl7cmV0dXJuIGU9PW51bGw/bnVsbDplLm5hbWV9cCg0ODYsODc1LHs0ODY6MSwzOjEsMTAzOjEsNjM6MSw4MjoxfSx1dWUpLGwuZ2V0TWVzc2FnZT1mdW5jdGlvbigpe3JldHVybiB4WGUodGhpcyksdGhpcy5tZXNzYWdlXzB9LGwuZ2V0VGhyb3duPWZ1bmN0aW9uKCl7cmV0dXJuIEQodGhpcy5lKT09PUQoZCQpP251bGw6dGhpcy5lfTt2YXIgZCQ7ZygiY29tLmdvb2dsZS5nd3QuY29yZS5jbGllbnQiLCJKYXZhU2NyaXB0RXhjZXB0aW9uIiw0ODYpO2Z1bmN0aW9uIGYkKGUsbil7cmV0dXJuIGUmJmUuZXF1YWxzP2UuZXF1YWxzKG4pOkQoZSk9PT1EKG4pfWZ1bmN0aW9uIHAkKGUpe3JldHVybiBlJiZlLmhhc2hDb2RlP2UuaGFzaENvZGUoKTpSMShlKX12YXIgY3VlPWcoImNvbS5nb29nbGUuZ3d0LmNvcmUuY2xpZW50IiwiSmF2YVNjcmlwdE9iamVjdCQiLDApO2Z1bmN0aW9uIEFYZShlLG4pe3ZhciByPWg1W2UuY2hhckNvZGVBdCgwKV07cmV0dXJuIHI/P2V9ZnVuY3Rpb24gX3VlKGUpeyFoNSYmKGg1PUxYZSgpKTt2YXIgbj1lLnJlcGxhY2UoL1tceDAwLVx4MWZceGFkXHUwNjAwLVx1MDYwM1x1MDZkZFx1MDcwZlx1MTdiNFx1MTdiNVx1MjAwYi1cdTIwMGZcdTIwMjgtXHUyMDJlXHUyMDYwLVx1MjA2NFx1MjA2YS1cdTIwNmZcdWZlZmZcdWZmZjktXHVmZmZiIlxcXS9nLGZ1bmN0aW9uKHIpe3JldHVybiBBWGUocil9KTtyZXR1cm4nIicrbisnIid9ZnVuY3Rpb24gTFhlKCl7dmFyIGU9WyJcXHUwMDAwIiwiXFx1MDAwMSIsIlxcdTAwMDIiLCJcXHUwMDAzIiwiXFx1MDAwNCIsIlxcdTAwMDUiLCJcXHUwMDA2IiwiXFx1MDAwNyIsIlxcYiIsIlxcdCIsIlxcbiIsIlxcdTAwMEIiLCJcXGYiLCJcXHIiLCJcXHUwMDBFIiwiXFx1MDAwRiIsIlxcdTAwMTAiLCJcXHUwMDExIiwiXFx1MDAxMiIsIlxcdTAwMTMiLCJcXHUwMDE0IiwiXFx1MDAxNSIsIlxcdTAwMTYiLCJcXHUwMDE3IiwiXFx1MDAxOCIsIlxcdTAwMTkiLCJcXHUwMDFBIiwiXFx1MDAxQiIsIlxcdTAwMUMiLCJcXHUwMDFEIiwiXFx1MDAxRSIsIlxcdTAwMUYiXTtyZXR1cm4gZVszNF09J1xcIicsZVs5Ml09IlxcXFwiLGVbMTczXT0iXFx1MDBhZCIsZVsxNTM2XT0iXFx1MDYwMCIsZVsxNTM3XT0iXFx1MDYwMSIsZVsxNTM4XT0iXFx1MDYwMiIsZVsxNTM5XT0iXFx1MDYwMyIsZVsxNzU3XT0iXFx1MDZkZCIsZVsxODA3XT0iXFx1MDcwZiIsZVs2MDY4XT0iXFx1MTdiNCIsZVs2MDY5XT0iXFx1MTdiNSIsZVs4MjAzXT0iXFx1MjAwYiIsZVs4MjA0XT0iXFx1MjAwYyIsZVs4MjA1XT0iXFx1MjAwZCIsZVs4MjA2XT0iXFx1MjAwZSIsZVs4MjA3XT0iXFx1MjAwZiIsZVs4MjMyXT0iXFx1MjAyOCIsZVs4MjMzXT0iXFx1MjAyOSIsZVs4MjM0XT0iXFx1MjAyYSIsZVs4MjM1XT0iXFx1MjAyYiIsZVs4MjM2XT0iXFx1MjAyYyIsZVs4MjM3XT0iXFx1MjAyZCIsZVs4MjM4XT0iXFx1MjAyZSIsZVs4Mjg4XT0iXFx1MjA2MCIsZVs4Mjg5XT0iXFx1MjA2MSIsZVs4MjkwXT0iXFx1MjA2MiIsZVs4MjkxXT0iXFx1MjA2MyIsZVs4MjkyXT0iXFx1MjA2NCIsZVs4Mjk4XT0iXFx1MjA2YSIsZVs4Mjk5XT0iXFx1MjA2YiIsZVs4MzAwXT0iXFx1MjA2YyIsZVs4MzAxXT0iXFx1MjA2ZCIsZVs4MzAyXT0iXFx1MjA2ZSIsZVs4MzAzXT0iXFx1MjA2ZiIsZVs2NTI3OV09IlxcdWZlZmYiLGVbNjU1MjldPSJcXHVmZmY5IixlWzY1NTMwXT0iXFx1ZmZmYSIsZVs2NTUzMV09IlxcdWZmZmIiLGV9dmFyIGg1O3AoMjA0NywxLHt9KSxnKCJjb20uZ29vZ2xlLmd3dC5jb3JlLmNsaWVudCIsIlNjaGVkdWxlciIsMjA0Nyk7ZnVuY3Rpb24gTkkoKXtOST1GLG55KCl9ZnVuY3Rpb24ga1hlKGUsbixyKXtyZXR1cm4gZS5hcHBseShuLHIpfWZ1bmN0aW9uIE9YZSgpe3ZhciBlO3JldHVybiBBSSE9MCYmKGU9RGF0ZS5ub3coKSxlLWR1ZT4yZTMmJihkdWU9ZSxMST1TLnNldFRpbWVvdXQoJFhlLDEwKSkpLEFJKys9PTA/KEJYZSgoZyQoKSxoJCkpLCEwKTohMX1mdW5jdGlvbiBNWGUoZSl7cmV0dXJuIE5JKCksZnVuY3Rpb24oKXtyZXR1cm4gUlhlKGUsdGhpcyxhcmd1bWVudHMpfX1mdW5jdGlvbiBSWGUoZSxuLHIpe3ZhciB0O3Q9T1hlKCk7dHJ5e3JldHVybiBrWGUoZSxuLHIpfWZpbmFsbHl7RFhlKHQpfX1mdW5jdGlvbiBEWGUoZSl7ZSYmR1hlKChnJCgpLGgkKSksLS1BSSxlJiZMSSE9LTEmJih6WGUoTEkpLExJPS0xKX1mdW5jdGlvbiBGWGUoZSl7TkkoKSxTLnNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlfSwwKX1mdW5jdGlvbiB6WGUoZSl7Uy5jbGVhclRpbWVvdXQoZSl9ZnVuY3Rpb24gJFhlKCl7QUkhPTAmJihBST0wKSxMST0tMX12YXIgQUk9MCxkdWU9MCxMST0tMTtmdW5jdGlvbiBnJCgpe2ckPUYsaCQ9bmV3IGZ1ZX1mdW5jdGlvbiBCWGUoZSl7dmFyIG4scjtpZihlLmVudHJ5Q29tbWFuZHMpe3I9bnVsbDtkbyBuPWUuZW50cnlDb21tYW5kcyxlLmVudHJ5Q29tbWFuZHM9bnVsbCxyPXB1ZShuLHIpO3doaWxlKGUuZW50cnlDb21tYW5kcyk7ZS5lbnRyeUNvbW1hbmRzPXJ9fWZ1bmN0aW9uIEdYZShlKXt2YXIgbixyO2lmKGUuZmluYWxseUNvbW1hbmRzKXtyPW51bGw7ZG8gbj1lLmZpbmFsbHlDb21tYW5kcyxlLmZpbmFsbHlDb21tYW5kcz1udWxsLHI9cHVlKG4scik7d2hpbGUoZS5maW5hbGx5Q29tbWFuZHMpO2UuZmluYWxseUNvbW1hbmRzPXJ9fWZ1bmN0aW9uIGZ1ZSgpe31mdW5jdGlvbiBIWGUoZSxuKXtyZXR1cm4hZSYmKGU9W10pLGVbZS5sZW5ndGhdPW4sZX1mdW5jdGlvbiBwdWUoZSxuKXt2YXIgcix0LG8saTtmb3IodD0wLG89ZS5sZW5ndGg7dDxvO3QrKyl7aT1lW3RdO3RyeXtpWzFdP2lbMF0uJF9udWxsTWV0aG9kKCkmJihuPUhYZShuLGkpKTppWzBdLiRfbnVsbE1ldGhvZCgpfWNhdGNoKHMpe2lmKHM9d3IocyksTChzLDgyKSlyPXMsTkkoKSxGWGUoTChyLDQ4Nik/YShyLDQ4NikuZ2V0VGhyb3duKCk6cik7ZWxzZSB0aHJvdyBiKHMpfX1yZXR1cm4gbn1wKDkwMiwyMDQ3LHt9LGZ1ZSk7dmFyIGgkO2coImNvbS5nb29nbGUuZ3d0LmNvcmUuY2xpZW50LmltcGwiLCJTY2hlZHVsZXJJbXBsIiw5MDIpO2Z1bmN0aW9uIG55KCl7bnk9Rjt2YXIgZSxuO249IVZYZSgpLGU9bmV3IHd1ZSxtNT1uP25ldyBtdWU6ZX1mdW5jdGlvbiBndWUoZSl7bnkoKSxtNS5jb2xsZWN0KGUpfWZ1bmN0aW9uIFVYZShlKXt2YXIgbixyLHQsbztmb3Iobj0iY2FwdHVyZVN0YWNrVHJhY2UiLHI9ImluaXRpYWxpemVCYWNraW5nRXJyb3IiLG89Uy5NYXRoLm1pbihlLmxlbmd0aCw1KSx0PW8tMTt0Pj0wO3QtLSlpZihUZShlW3RdLm1ldGhvZE5hbWUsbil8fFRlKGVbdF0ubWV0aG9kTmFtZSxyKSl7ZS5sZW5ndGg+PXQrMSYmZS5zcGxpY2UoMCx0KzEpO2JyZWFrfXJldHVybiBlfWZ1bmN0aW9uIFdYZShlKXt2YXIgbj0vZnVuY3Rpb24oPzpccysoW1x3JF0rKSk/XHMqXCgvLHI9bi5leGVjKGUpO3JldHVybiByJiZyWzFdfHwiYW5vbnltb3VzIn1mdW5jdGlvbiBodWUoZSl7cmV0dXJuIG55KCkscGFyc2VJbnQoZSl8fC0xfWZ1bmN0aW9uIGpYZShlKXtueSgpO3ZhciBuPWUuYmFja2luZ0pzT2JqZWN0O2lmKG4mJm4uc3RhY2spe3ZhciByPW4uc3RhY2ssdD1uK2AKYDtyZXR1cm4gci5zdWJzdHJpbmcoMCx0Lmxlbmd0aCk9PXQmJihyPXIuc3Vic3RyaW5nKHQubGVuZ3RoKSksci5zcGxpdChgCmApfXJldHVybltdfWZ1bmN0aW9uIFZYZSgpe3JldHVybiBFcnJvci5zdGFja1RyYWNlTGltaXQ+MD8oUy5FcnJvci5zdGFja1RyYWNlTGltaXQ9RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PTY0LCEwKToic3RhY2siaW4gbmV3IEVycm9yfXZhciBtNTtwKDIwNTgsMSx7fSksZygiY29tLmdvb2dsZS5nd3QuY29yZS5jbGllbnQuaW1wbCIsIlN0YWNrVHJhY2VDcmVhdG9yL0NvbGxlY3RvciIsMjA1OCk7ZnVuY3Rpb24gbXVlKCl7fXAoODc2LDIwNTgse30sbXVlKSxsLmNvbGxlY3Q9ZnVuY3Rpb24obil7dmFyIHI9e30sdD1bXTtuLmZuU3RhY2s9dDtmb3IodmFyIG89YXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7bzspe3ZhciBpPShueSgpLG8ubmFtZXx8KG8ubmFtZT1XWGUoby50b1N0cmluZygpKSkpO3QucHVzaChpKTt2YXIgcz0iOiIraSx1PXJbc107aWYodSl7dmFyIGMsXztmb3IoYz0wLF89dS5sZW5ndGg7YzxfO2MrKylpZih1W2NdPT09bylyZXR1cm59KHV8fChyW3NdPVtdKSkucHVzaChvKSxvPW8uY2FsbGVyfX0sbC5nZXRTdGFja1RyYWNlPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpO2ZvcihvPShueSgpLG4mJm4uZm5TdGFjaz9uLmZuU3RhY2s6W10pLHQ9by5sZW5ndGgsaT1CKGFCLFgsMzE5LHQsMCwxKSxyPTA7cjx0O3IrKylpW3JdPW5ldyBSNShvW3JdLG51bGwsLTEpO3JldHVybiBpfSxnKCJjb20uZ29vZ2xlLmd3dC5jb3JlLmNsaWVudC5pbXBsIiwiU3RhY2tUcmFjZUNyZWF0b3IvQ29sbGVjdG9yTGVnYWN5Iiw4NzYpO2Z1bmN0aW9uIHl1ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtyZXR1cm4gXz0iIixuLmxlbmd0aD09MD9lLmNyZWF0ZVN0ZSgiVW5rbm93biIsImFub255bW91cyIsLTEsLTEpOihkPW5mKG4pLFRlKGQuc3Vic3RyKDAsMyksImF0ICIpJiYoZD0oSGUoMyxkLmxlbmd0aCsxKSxkLnN1YnN0cigzKSkpLGQ9ZC5yZXBsYWNlKC9cWy4qP1xdL2csIiIpLHM9ZC5pbmRleE9mKCIoIikscz09LTE/KHM9ZC5pbmRleE9mKCJAIikscz09LTE/KF89ZCxkPSIiKTooXz1uZigoSGUocysxLGQubGVuZ3RoKzEpLGQuc3Vic3RyKHMrMSkpKSxkPW5mKChndCgwLHMsZC5sZW5ndGgpLGQuc3Vic3RyKDAscykpKSkpOihyPWQuaW5kZXhPZigiKSIscyksXz0oZ3QocysxLHIsZC5sZW5ndGgpLGQuc3Vic3RyKHMrMSxyLShzKzEpKSksZD1uZigoZ3QoMCxzLGQubGVuZ3RoKSxkLnN1YnN0cigwLHMpKSkpLHM9b3UoZCx4aSg0NikpLHMhPS0xJiYoZD0oSGUocysxLGQubGVuZ3RoKzEpLGQuc3Vic3RyKHMrMSkpKSwoZC5sZW5ndGg9PTB8fFRlKGQsIkFub255bW91cyBmdW5jdGlvbiIpKSYmKGQ9ImFub255bW91cyIpLHU9akkoXyx4aSg1OCkpLG89Y0IoXyx4aSg1OCksdS0xKSxjPS0xLHQ9LTEsaT0iVW5rbm93biIsdSE9LTEmJm8hPS0xJiYoaT0oZ3QoMCxvLF8ubGVuZ3RoKSxfLnN1YnN0cigwLG8pKSxjPWh1ZSgoZ3QobysxLHUsXy5sZW5ndGgpLF8uc3Vic3RyKG8rMSx1LShvKzEpKSkpLHQ9aHVlKChIZSh1KzEsXy5sZW5ndGgrMSksXy5zdWJzdHIodSsxKSkpKSxlLmNyZWF0ZVN0ZShpLGQsYyx0KSl9cCgyMDU5LDIwNTgse30pLGwuY29sbGVjdD1mdW5jdGlvbihuKXt9LGwuY3JlYXRlU3RlPWZ1bmN0aW9uKG4scix0LG8pe3JldHVybiBuZXcgUjUocixuKyJAIitvLHQ8MD8tMTp0KX0sbC5nZXRTdGFja1RyYWNlPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdTtpZihpPWpYZShuKSxzPUIoYUIsWCwzMTksMCwwLDEpLHI9MCxvPWkubGVuZ3RoLG89PTApcmV0dXJuIHM7Zm9yKHU9eXVlKHRoaXMsaVswXSksVGUodS5tZXRob2ROYW1lLCJhbm9ueW1vdXMiKXx8KHNbcisrXT11KSx0PTE7dDxvO3QrKylzW3IrK109eXVlKHRoaXMsaVt0XSk7cmV0dXJuIHN9LGcoImNvbS5nb29nbGUuZ3d0LmNvcmUuY2xpZW50LmltcGwiLCJTdGFja1RyYWNlQ3JlYXRvci9Db2xsZWN0b3JNb2Rlcm4iLDIwNTkpO2Z1bmN0aW9uIHd1ZSgpe31wKDg3NywyMDU5LHt9LHd1ZSksbC5jcmVhdGVTdGU9ZnVuY3Rpb24obixyLHQsbyl7cmV0dXJuIG5ldyBSNShyLG4sLTEpfSxnKCJjb20uZ29vZ2xlLmd3dC5jb3JlLmNsaWVudC5pbXBsIiwiU3RhY2tUcmFjZUNyZWF0b3IvQ29sbGVjdG9yTW9kZXJuTm9Tb3VyY2VNYXAiLDg3Nyk7ZnVuY3Rpb24gbSQoKXttJD1GLG5ldyBzbn1mdW5jdGlvbiBrSShlLG4scil7dmFyIHQ7bi5zdHJpbmcubGVuZ3RoPjAmJihlZShlLnBhdHRlcm5QYXJ0cyxuZXcgUHVlKG4uc3RyaW5nLHIpKSx0PW4uc3RyaW5nLmxlbmd0aCwwPHQ/bi5zdHJpbmc9WWEobi5zdHJpbmcsMCwwKTowPnQmJihuLnN0cmluZys9bWNlKEIoZmwsWHMsMjgsLXQsMTUsMSkpKSl9ZnVuY3Rpb24gcVhlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7Zm9yKCFyJiYocj1wSmUobi5qc2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkpLG89KG4uanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCktci5zdGFuZGFyZE9mZnNldCkqNmU0LHU9bmV3IFQkKE50KEhvKG4uanNkYXRlLmdldFRpbWUoKSksbykpLGM9dSx1LmpzZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIT1uLmpzZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpJiYobz4wP28tPTg2NGU1Om8rPTg2NGU1LGM9bmV3IFQkKE50KEhvKG4uanNkYXRlLmdldFRpbWUoKSksbykpKSxkPW5ldyBmaCxfPWUucGF0dGVybi5sZW5ndGgsaT0wO2k8XzspaWYodD1JdChlLnBhdHRlcm4saSksdD49OTcmJnQ8PTEyMnx8dD49NjUmJnQ8PTkwKXtmb3Iocz1pKzE7czxfJiZJdChlLnBhdHRlcm4scyk9PXQ7KytzKTtySmUoZCx0LHMtaSx1LGMsciksaT1zfWVsc2UgaWYodD09Mzkpe2lmKCsraSxpPF8mJkl0KGUucGF0dGVybixpKT09Mzkpe2Quc3RyaW5nKz0iJyIsKytpO2NvbnRpbnVlfWZvcihmPSExOyFmOyl7Zm9yKHM9aTtzPF8mJkl0KGUucGF0dGVybixzKSE9Mzk7KSsrcztpZihzPj1fKXRocm93IGIobmV3IEdlKCJNaXNzaW5nIHRyYWlsaW5nICciKSk7cysxPF8mJkl0KGUucGF0dGVybixzKzEpPT0zOT8rK3M6Zj0hMCxPbihkLFlhKGUucGF0dGVybixpLHMpKSxpPXMrMX19ZWxzZSBkLnN0cmluZys9U3RyaW5nLmZyb21DaGFyQ29kZSh0KSwrK2k7cmV0dXJuIGQuc3RyaW5nfWZ1bmN0aW9uIFlYZShlLG4scil7dmFyIHQsbzt0PUhvKHIuanNkYXRlLmdldFRpbWUoKSksVm8odCwwKTwwPyhvPWJjLVNuKG1DKFBjKHQpLGJjKSksbz09YmMmJihvPTApKTpvPVNuKG1DKHQsYmMpKSxuPT0xPyhvPVMuTWF0aC5taW4oKG8rNTApLzEwMHwwLDkpLHhfKGUsNDgrbyZ6cikpOm49PTI/KG89Uy5NYXRoLm1pbigobys1KS8xMHwwLDk5KSxBdShlLG8sMikpOihBdShlLG8sMyksbj4zJiZBdShlLDAsbi0zKSl9ZnVuY3Rpb24gS1hlKGUsbixyKXt2YXIgdDtzd2l0Y2godD1yLmpzZGF0ZS5nZXRNb250aCgpLG4pe2Nhc2UgNTpPbihlLFAoSShzZSwxKSxYLDIsNixbIkoiLCJGIiwiTSIsIkEiLCJNIiwiSiIsIkoiLCJBIiwiUyIsIk8iLCJOIiwiRCJdKVt0XSk7YnJlYWs7Y2FzZSA0Ok9uKGUsUChJKHNlLDEpLFgsMiw2LFsiSmFudWFyeSIsIkZlYnJ1YXJ5IiwiTWFyY2giLCJBcHJpbCIsIk1heSIsIkp1bmUiLCJKdWx5IiwiQXVndXN0IiwiU2VwdGVtYmVyIiwiT2N0b2JlciIsIk5vdmVtYmVyIiwiRGVjZW1iZXIiXSlbdF0pO2JyZWFrO2Nhc2UgMzpPbihlLFAoSShzZSwxKSxYLDIsNixbIkphbiIsIkZlYiIsIk1hciIsIkFwciIsIk1heSIsIkp1biIsIkp1bCIsIkF1ZyIsIlNlcCIsIk9jdCIsIk5vdiIsIkRlYyJdKVt0XSk7YnJlYWs7ZGVmYXVsdDpBdShlLHQrMSxuKX19ZnVuY3Rpb24gWFhlKGUsbixyKXt2YXIgdDtzd2l0Y2godD1yLmpzZGF0ZS5nZXRGdWxsWWVhcigpLWgwK2gwLHQ8MCYmKHQ9LXQpLG4pe2Nhc2UgMTplLnN0cmluZys9dDticmVhaztjYXNlIDI6QXUoZSx0JTEwMCwyKTticmVhaztkZWZhdWx0OkF1KGUsdCxuKX19ZnVuY3Rpb24gSlhlKGUsbil7dmFyIHIsdDtmb3Iocj0oSGUobixlLmxlbmd0aCksZS5jaGFyQ29kZUF0KG4pKSx0PW4rMTt0PGUubGVuZ3RoJiYoSGUodCxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHQpPT1yKTspKyt0O3JldHVybiB0LW59ZnVuY3Rpb24gWlhlKGUpe3ZhciBuLHIsdDtmb3Iobj0hMSx0PWUucGF0dGVyblBhcnRzLmFycmF5Lmxlbmd0aCxyPTA7cjx0O3IrKyl5JChhKGxlKGUucGF0dGVyblBhcnRzLHIpLDQ0MykpPyFuJiZyKzE8dCYmeSQoYShsZShlLnBhdHRlcm5QYXJ0cyxyKzEpLDQ0MykpJiYobj0hMCxhKGxlKGUucGF0dGVyblBhcnRzLHIpLDQ0MykuYWJ1dFN0YXJ0PSEwKTpuPSExfWZ1bmN0aW9uIHkkKGUpe3ZhciBuO3JldHVybiBlLmNvdW50PD0wPyExOihuPW91KCJNTHlkaEhtc1NEa0siLHhpKEl0KGUudGV4dF8wLDApKSksbj4xfHxuPj0wJiZlLmNvdW50PDMpfWZ1bmN0aW9uIElwKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXztmb3Iocz1yLmxlbmd0aCxpPTAsbz0tMSxfPWhjZSgoSGUobixlLmxlbmd0aCsxKSxlLnN1YnN0cihuKSksKHNrKCksX0cpKSx1PTA7dTxzOysrdSljPXJbdV0ubGVuZ3RoLGM+aSYmcFplKF8saGNlKHJbdV0sX0cpKSYmKG89dSxpPWMpO3JldHVybiBvPj0wJiYodFswXT1uK2kpLG99ZnVuY3Rpb24gUVhlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7Zm9yKHM9bmV3IEF1ZSxfPVAoSShobiwxKSxrbiwyOCwxNSxbMF0pLG89LTEsaT0wLHQ9MCxjPTA7YzxlLnBhdHRlcm5QYXJ0cy5hcnJheS5sZW5ndGg7KytjKWlmKGQ9YShsZShlLnBhdHRlcm5QYXJ0cyxjKSw0NDMpLGQuY291bnQ+MCl7aWYobzwwJiZkLmFidXRTdGFydCYmKG89YyxpPV9bMF0sdD0wKSxvPj0wKXtpZih1PWQuY291bnQsYz09byYmKHUtPXQrKyx1PT0wKSlyZXR1cm4gMDtpZighdnVlKG4sXyxkLHUscykpe2M9by0xLF9bMF09aTtjb250aW51ZX19ZWxzZSBpZihvPS0xLCF2dWUobixfLGQsMCxzKSlyZXR1cm4gMH1lbHNle2lmKG89LTEsSXQoZC50ZXh0XzAsMCk9PTMyKXtpZihmPV9bMF0sRXVlKG4sXyksX1swXT5mKWNvbnRpbnVlfWVsc2UgaWYoZ1plKG4sZC50ZXh0XzAsX1swXSkpe19bMF0rPWQudGV4dF8wLmxlbmd0aDtjb250aW51ZX1yZXR1cm4gMH1yZXR1cm4gRUplKHMscik/X1swXTowfWZ1bmN0aW9uIGVKZShlLG4pe3ZhciByLHQsbztpZih0PW5ldyBESSxvPW5ldyBDJCh0LmpzZGF0ZS5nZXRGdWxsWWVhcigpLWgwLHQuanNkYXRlLmdldE1vbnRoKCksdC5qc2RhdGUuZ2V0RGF0ZSgpKSxyPVFYZShlLG4sbykscj09MHx8cjxuLmxlbmd0aCl0aHJvdyBiKG5ldyBHZShuKSk7cmV0dXJuIG99ZnVuY3Rpb24gT0koZSxuKXt2YXIgcix0LG87aWYobz0wLHQ9blswXSx0Pj1lLmxlbmd0aClyZXR1cm4tMTtmb3Iocj0oSGUodCxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHQpKTtyPj00OCYmcjw9NTcmJihvPW8qMTArKHItNDgpLCsrdCwhKHQ+PWUubGVuZ3RoKSk7KXI9KEhlKHQsZS5sZW5ndGgpLGUuY2hhckNvZGVBdCh0KSk7cmV0dXJuIHQ+blswXT9uWzBdPXQ6bz0tMSxvfWZ1bmN0aW9uIG5KZShlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHI9bmV3IGZoLHM9ITEsaT0wO2k8bi5sZW5ndGg7aSsrKXtpZih0PShIZShpLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoaSkpLHQ9PTMyKXtmb3Ioa0koZSxyLDApLHIuc3RyaW5nKz0iICIsa0koZSxyLDApO2krMTxuLmxlbmd0aCYmKEhlKGkrMSxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KGkrMSk9PTMyKTspKytpO2NvbnRpbnVlfWlmKHMpe3Q9PTM5P2krMTxuLmxlbmd0aCYmKEhlKGkrMSxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KGkrMSk9PTM5KT8oci5zdHJpbmcrPVN0cmluZy5mcm9tQ2hhckNvZGUodCksKytpKTpzPSExOnIuc3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO2NvbnRpbnVlfWlmKG91KCJHeU1MZGtIbXNTRWNEYWhLelp2Iix4aSh0KSk+MCl7a0koZSxyLDApLHIuc3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpLG89SlhlKG4saSksa0koZSxyLG8pLGkrPW8tMTtjb250aW51ZX10PT0zOT9pKzE8bi5sZW5ndGgmJihIZShpKzEsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChpKzEpPT0zOSk/KHIuc3RyaW5nKz0iJyIsKytpKTpzPSEwOnIuc3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpfWtJKGUsciwwKSxaWGUoZSl9ZnVuY3Rpb24gdyQoZSxuLHIpe3ZhciB0LG8saSxzO2lmKG5bMF0+PWUubGVuZ3RoKXJldHVybiByLnR6T2Zmc2V0PTAsITA7c3dpdGNoKEl0KGUsblswXSkpe2Nhc2UgNDM6bz0xO2JyZWFrO2Nhc2UgNDU6bz0tMTticmVhaztkZWZhdWx0OnJldHVybiByLnR6T2Zmc2V0PTAsITB9aWYoKytuWzBdLGk9blswXSxzPU9JKGUsbikscz09MCYmblswXT09aSlyZXR1cm4hMTtpZihuWzBdPGUubGVuZ3RoJiZJdChlLG5bMF0pPT01OCl7aWYodD1zKjYwLCsrblswXSxpPW5bMF0scz1PSShlLG4pLHM9PTAmJm5bMF09PWkpcmV0dXJuITE7dCs9c31lbHNlIHQ9cyx0PDI0JiZuWzBdLWk8PTI/dCo9NjA6dD10JTEwMCsodC8xMDB8MCkqNjA7cmV0dXJuIHQqPW8sci50ek9mZnNldD0tdCwhMH1mdW5jdGlvbiBFdWUoZSxuKXtmb3IoO25bMF08ZS5sZW5ndGgmJm91KGAgCVxyCmAseGkoSXQoZSxuWzBdKSkpPj0wOykrK25bMF19ZnVuY3Rpb24gckplKGUsbixyLHQsbyxpKXt2YXIgcyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7c3dpdGNoKG4pe2Nhc2UgNzE6dT10LmpzZGF0ZS5nZXRGdWxsWWVhcigpLWgwPj0tMTkwMD8xOjAscj49ND9PbihlLFAoSShzZSwxKSxYLDIsNixbIkJlZm9yZSBDaHJpc3QiLCJBbm5vIERvbWluaSJdKVt1XSk6T24oZSxQKEkoc2UsMSksWCwyLDYsWyJCQyIsIkFEIl0pW3VdKTticmVhaztjYXNlIDEyMTpYWGUoZSxyLHQpO2JyZWFrO2Nhc2UgNzc6S1hlKGUscix0KTticmVhaztjYXNlIDEwNzpjPW8uanNkYXRlLmdldEhvdXJzKCksYz09MD9BdShlLDI0LHIpOkF1KGUsYyxyKTticmVhaztjYXNlIDgzOllYZShlLHIsbyk7YnJlYWs7Y2FzZSA2OTpkPXQuanNkYXRlLmdldERheSgpLHI9PTU/T24oZSxQKEkoc2UsMSksWCwyLDYsWyJTIiwiTSIsIlQiLCJXIiwiVCIsIkYiLCJTIl0pW2RdKTpyPT00P09uKGUsUChJKHNlLDEpLFgsMiw2LFsiU3VuZGF5IiwiTW9uZGF5IiwiVHVlc2RheSIsIldlZG5lc2RheSIsIlRodXJzZGF5IiwiRnJpZGF5IiwiU2F0dXJkYXkiXSlbZF0pOk9uKGUsUChJKHNlLDEpLFgsMiw2LFsiU3VuIiwiTW9uIiwiVHVlIiwiV2VkIiwiVGh1IiwiRnJpIiwiU2F0Il0pW2RdKTticmVhaztjYXNlIDk3Om8uanNkYXRlLmdldEhvdXJzKCk+PTEyJiZvLmpzZGF0ZS5nZXRIb3VycygpPDI0P09uKGUsUChJKHNlLDEpLFgsMiw2LFsiQU0iLCJQTSJdKVsxXSk6T24oZSxQKEkoc2UsMSksWCwyLDYsWyJBTSIsIlBNIl0pWzBdKTticmVhaztjYXNlIDEwNDpmPW8uanNkYXRlLmdldEhvdXJzKCklMTIsZj09MD9BdShlLDEyLHIpOkF1KGUsZixyKTticmVhaztjYXNlIDc1Omg9by5qc2RhdGUuZ2V0SG91cnMoKSUxMixBdShlLGgscik7YnJlYWs7Y2FzZSA3MjptPW8uanNkYXRlLmdldEhvdXJzKCksQXUoZSxtLHIpO2JyZWFrO2Nhc2UgOTk6eT10LmpzZGF0ZS5nZXREYXkoKSxyPT01P09uKGUsUChJKHNlLDEpLFgsMiw2LFsiUyIsIk0iLCJUIiwiVyIsIlQiLCJGIiwiUyJdKVt5XSk6cj09ND9PbihlLFAoSShzZSwxKSxYLDIsNixbIlN1bmRheSIsIk1vbmRheSIsIlR1ZXNkYXkiLCJXZWRuZXNkYXkiLCJUaHVyc2RheSIsIkZyaWRheSIsIlNhdHVyZGF5Il0pW3ldKTpyPT0zP09uKGUsUChJKHNlLDEpLFgsMiw2LFsiU3VuIiwiTW9uIiwiVHVlIiwiV2VkIiwiVGh1IiwiRnJpIiwiU2F0Il0pW3ldKTpBdShlLHksMSk7YnJlYWs7Y2FzZSA3NjpFPXQuanNkYXRlLmdldE1vbnRoKCkscj09NT9PbihlLFAoSShzZSwxKSxYLDIsNixbIkoiLCJGIiwiTSIsIkEiLCJNIiwiSiIsIkoiLCJBIiwiUyIsIk8iLCJOIiwiRCJdKVtFXSk6cj09ND9PbihlLFAoSShzZSwxKSxYLDIsNixbIkphbnVhcnkiLCJGZWJydWFyeSIsIk1hcmNoIiwiQXByaWwiLCJNYXkiLCJKdW5lIiwiSnVseSIsIkF1Z3VzdCIsIlNlcHRlbWJlciIsIk9jdG9iZXIiLCJOb3ZlbWJlciIsIkRlY2VtYmVyIl0pW0VdKTpyPT0zP09uKGUsUChJKHNlLDEpLFgsMiw2LFsiSmFuIiwiRmViIiwiTWFyIiwiQXByIiwiTWF5IiwiSnVuIiwiSnVsIiwiQXVnIiwiU2VwIiwiT2N0IiwiTm92IiwiRGVjIl0pW0VdKTpBdShlLEUrMSxyKTticmVhaztjYXNlIDgxOnY9dC5qc2RhdGUuZ2V0TW9udGgoKS8zfDAscjw0P09uKGUsUChJKHNlLDEpLFgsMiw2LFsiUTEiLCJRMiIsIlEzIiwiUTQiXSlbdl0pOk9uKGUsUChJKHNlLDEpLFgsMiw2LFsiMXN0IHF1YXJ0ZXIiLCIybmQgcXVhcnRlciIsIjNyZCBxdWFydGVyIiwiNHRoIHF1YXJ0ZXIiXSlbdl0pO2JyZWFrO2Nhc2UgMTAwOng9dC5qc2RhdGUuZ2V0RGF0ZSgpLEF1KGUseCxyKTticmVhaztjYXNlIDEwOTpfPW8uanNkYXRlLmdldE1pbnV0ZXMoKSxBdShlLF8scik7YnJlYWs7Y2FzZSAxMTU6cz1vLmpzZGF0ZS5nZXRTZWNvbmRzKCksQXUoZSxzLHIpO2JyZWFrO2Nhc2UgMTIyOnI8ND9PbihlLGkudHpOYW1lc1swXSk6T24oZSxpLnR6TmFtZXNbMV0pO2JyZWFrO2Nhc2UgMTE4Ok9uKGUsaS50aW1lem9uZUlEKTticmVhaztjYXNlIDkwOnI8Mz9PbihlLF9KZShpKSk6cj09Mz9PbihlLGNKZShpKSk6T24oZSxkSmUoaS5zdGFuZGFyZE9mZnNldCkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuITF9cmV0dXJuITB9ZnVuY3Rpb24gdnVlKGUsbixyLHQsbyl7dmFyIGkscyx1O2lmKEV1ZShlLG4pLHM9blswXSxpPUl0KHIudGV4dF8wLDApLHU9LTEseSQocikpaWYodD4wKXtpZihzK3Q+ZS5sZW5ndGgpcmV0dXJuITE7dT1PSSgoZ3QoMCxzK3QsZS5sZW5ndGgpLGUuc3Vic3RyKDAscyt0KSksbil9ZWxzZSB1PU9JKGUsbik7c3dpdGNoKGkpe2Nhc2UgNzE6cmV0dXJuIHU9SXAoZSxzLFAoSShzZSwxKSxYLDIsNixbIkJlZm9yZSBDaHJpc3QiLCJBbm5vIERvbWluaSJdKSxuKSxvLmVyYT11LCEwO2Nhc2UgNzc6cmV0dXJuIGlKZShlLG4sbyx1LHMpO2Nhc2UgNzY6cmV0dXJuIGxKZShlLG4sbyx1LHMpO2Nhc2UgNjk6cmV0dXJuIHRKZShlLG4scyxvKTtjYXNlIDk5OnJldHVybiBhSmUoZSxuLHMsbyk7Y2FzZSA5NzpyZXR1cm4gdT1JcChlLHMsUChJKHNlLDEpLFgsMiw2LFsiQU0iLCJQTSJdKSxuKSxvLmFtcG09dSwhMDtjYXNlIDEyMTpyZXR1cm4gdUplKGUsbixzLHUscixvKTtjYXNlIDEwMDpyZXR1cm4gdTw9MD8hMTooby5kYXlPZk1vbnRoPXUsITApO2Nhc2UgODM6cmV0dXJuIHU8MD8hMTpvSmUodSxzLG5bMF0sbyk7Y2FzZSAxMDQ6dT09MTImJih1PTApO2Nhc2UgNzU6Y2FzZSA3MjpyZXR1cm4gdTwwPyExOihvLmhvdXJzPXUsby5taWRuaWdodElzMjQ9ITEsITApO2Nhc2UgMTA3OnJldHVybiB1PDA/ITE6KG8uaG91cnM9dSxvLm1pZG5pZ2h0SXMyND0hMCwhMCk7Y2FzZSAxMDk6cmV0dXJuIHU8MD8hMTooby5taW51dGVzPXUsITApO2Nhc2UgMTE1OnJldHVybiB1PDA/ITE6KG8uc2Vjb25kcz11LCEwKTtjYXNlIDkwOmlmKHM8ZS5sZW5ndGgmJihIZShzLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQocyk9PTkwKSlyZXR1cm4rK25bMF0sby50ek9mZnNldD0wLCEwO2Nhc2UgMTIyOmNhc2UgMTE4OnJldHVybiBzSmUoZSxzLG4sbyk7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdEplKGUsbixyLHQpe3ZhciBvO3JldHVybiBvPUlwKGUscixQKEkoc2UsMSksWCwyLDYsWyJTdW5kYXkiLCJNb25kYXkiLCJUdWVzZGF5IiwiV2VkbmVzZGF5IiwiVGh1cnNkYXkiLCJGcmlkYXkiLCJTYXR1cmRheSJdKSxuKSxvPDAmJihvPUlwKGUscixQKEkoc2UsMSksWCwyLDYsWyJTdW4iLCJNb24iLCJUdWUiLCJXZWQiLCJUaHUiLCJGcmkiLCJTYXQiXSksbikpLG88MD8hMToodC5kYXlPZldlZWs9bywhMCl9ZnVuY3Rpb24gb0plKGUsbixyLHQpe3ZhciBvLGk7aWYoaT1yLW4saTwzKWZvcig7aTwzOyllKj0xMCwrK2k7ZWxzZXtmb3Iobz0xO2k+Mzspbyo9MTAsLS1pO2U9KGUrKG8+PjEpKS9vfDB9cmV0dXJuIHQubWlsbGlzZWNvbmRzPWUsITB9ZnVuY3Rpb24gaUplKGUsbixyLHQsbyl7cmV0dXJuIHQ8MD8odD1JcChlLG8sUChJKHNlLDEpLFgsMiw2LFsiSmFudWFyeSIsIkZlYnJ1YXJ5IiwiTWFyY2giLCJBcHJpbCIsIk1heSIsIkp1bmUiLCJKdWx5IiwiQXVndXN0IiwiU2VwdGVtYmVyIiwiT2N0b2JlciIsIk5vdmVtYmVyIiwiRGVjZW1iZXIiXSksbiksdDwwJiYodD1JcChlLG8sUChJKHNlLDEpLFgsMiw2LFsiSmFuIiwiRmViIiwiTWFyIiwiQXByIiwiTWF5IiwiSnVuIiwiSnVsIiwiQXVnIiwiU2VwIiwiT2N0IiwiTm92IiwiRGVjIl0pLG4pKSx0PDA/ITE6KHIubW9udGg9dCwhMCkpOnQ+MD8oci5tb250aD10LTEsITApOiExfWZ1bmN0aW9uIGFKZShlLG4scix0KXt2YXIgbztyZXR1cm4gbz1JcChlLHIsUChJKHNlLDEpLFgsMiw2LFsiU3VuZGF5IiwiTW9uZGF5IiwiVHVlc2RheSIsIldlZG5lc2RheSIsIlRodXJzZGF5IiwiRnJpZGF5IiwiU2F0dXJkYXkiXSksbiksbzwwJiYobz1JcChlLHIsUChJKHNlLDEpLFgsMiw2LFsiU3VuIiwiTW9uIiwiVHVlIiwiV2VkIiwiVGh1IiwiRnJpIiwiU2F0Il0pLG4pKSxvPDA/ITE6KHQuZGF5T2ZXZWVrPW8sITApfWZ1bmN0aW9uIGxKZShlLG4scix0LG8pe3JldHVybiB0PDA/KHQ9SXAoZSxvLFAoSShzZSwxKSxYLDIsNixbIkphbnVhcnkiLCJGZWJydWFyeSIsIk1hcmNoIiwiQXByaWwiLCJNYXkiLCJKdW5lIiwiSnVseSIsIkF1Z3VzdCIsIlNlcHRlbWJlciIsIk9jdG9iZXIiLCJOb3ZlbWJlciIsIkRlY2VtYmVyIl0pLG4pLHQ8MCYmKHQ9SXAoZSxvLFAoSShzZSwxKSxYLDIsNixbIkphbiIsIkZlYiIsIk1hciIsIkFwciIsIk1heSIsIkp1biIsIkp1bCIsIkF1ZyIsIlNlcCIsIk9jdCIsIk5vdiIsIkRlYyJdKSxuKSksdDwwPyExOihyLm1vbnRoPXQsITApKTp0PjA/KHIubW9udGg9dC0xLCEwKTohMX1mdW5jdGlvbiBzSmUoZSxuLHIsdCl7cmV0dXJuKG4+PTAmJlRlKGUuc3Vic3RyKG4sMyksIkdNVCIpfHxuPj0wJiZUZShlLnN1YnN0cihuLDMpLCJVVEMiKSkmJihyWzBdPW4rMyksdyQoZSxyLHQpfWZ1bmN0aW9uIHVKZShlLG4scix0LG8saSl7dmFyIHMsdSxjLF87aWYodT0zMix0PDApe2lmKG5bMF0+PWUubGVuZ3RofHwodT1JdChlLG5bMF0pLHUhPTQzJiZ1IT00NSl8fCgrK25bMF0sdD1PSShlLG4pLHQ8MCkpcmV0dXJuITE7dT09NDUmJih0PS10KX1yZXR1cm4gdT09MzImJm5bMF0tcj09MiYmby5jb3VudD09MiYmKGM9bmV3IERJLF89Yy5qc2RhdGUuZ2V0RnVsbFllYXIoKS1oMCtoMC04MCxzPV8lMTAwLGkuYW1iaWd1b3VzWWVhcj10PT1zLHQrPShfLzEwMHwwKSoxMDArKHQ8cz8xMDA6MCkpLGkueWVhcj10LCEwfWZ1bmN0aW9uIEF1KGUsbixyKXt2YXIgdCxvO2Zvcih0PTEwLG89MDtvPHItMTtvKyspbjx0JiYoZS5zdHJpbmcrPSIwIiksdCo9MTA7ZS5zdHJpbmcrPW59cCgxMDY0LDEse30pLGcoImNvbS5nb29nbGUuZ3d0LmkxOG4uc2hhcmVkIiwiRGF0ZVRpbWVGb3JtYXQiLDEwNjQpO2Z1bmN0aW9uIEUkKCl7RSQ9RixtJCgpLHYkPW5ldyBzbn1mdW5jdGlvbiBTdWUoZSl7bSQoKSx0aGlzLnBhdHRlcm5QYXJ0cz1uZXcgUSx0aGlzLnBhdHRlcm49ZSxuSmUodGhpcyxlKX1mdW5jdGlvbiBNSShlLG4pe0UkKCk7dmFyIHIsdDtyZXR1cm4gcj1kQygoUkkoKSxSSSgpLE8yKSksdD1udWxsLG49PXImJih0PWEobmkodiQsZSksNjI0KSksdHx8KHQ9bmV3IFN1ZShlKSxuPT1yJiZ0byh2JCxlLHQpKSx0fXAoNjI0LDEwNjQsezYyNDoxfSxTdWUpO3ZhciB2JDtnKCJjb20uZ29vZ2xlLmd3dC5pMThuLmNsaWVudCIsIkRhdGVUaW1lRm9ybWF0Iiw2MjQpLHAoMjEwMSwxLHt9KSxnKCJjb20uZ29vZ2xlLmd3dC5pMThuLnNoYXJlZCIsIkRlZmF1bHREYXRlVGltZUZvcm1hdEluZm8iLDIxMDEpLHAoMjEwMiwyMTAxLHt9KSxnKCJjb20uZ29vZ2xlLmd3dC5pMThuLmNsaWVudCIsIkRlZmF1bHREYXRlVGltZUZvcm1hdEluZm8iLDIxMDIpO2Z1bmN0aW9uIFJJKCl7Ukk9RixPMj1uZXcgQ3VlfWZ1bmN0aW9uIGRDKGUpe3JldHVybiFlLmRhdGVUaW1lRm9ybWF0SW5mbyYmKGUuZGF0ZVRpbWVGb3JtYXRJbmZvPW5ldyB4dWUpLGUuZGF0ZVRpbWVGb3JtYXRJbmZvfWZ1bmN0aW9uIEN1ZSgpe31wKDExMjAsMSx7fSxDdWUpO3ZhciBPMjtnKCJjb20uZ29vZ2xlLmd3dC5pMThuLmNsaWVudCIsIkxvY2FsZUluZm8iLDExMjApO2Z1bmN0aW9uIGNKZShlKXt2YXIgbixyO3JldHVybiByPS1lLnN0YW5kYXJkT2Zmc2V0LG49UChJKGZsLDEpLFhzLDI4LDE1LFs0Myw0OCw0OCw1OCw0OCw0OF0pLHI8MCYmKG5bMF09NDUscj0tciksblsxXT1uWzFdKygoci82MHwwKS8xMHwwKSZ6cixuWzJdPW5bMl0rKHIvNjB8MCklMTAmenIsbls0XT1uWzRdKyhyJTYwLzEwfDApJnpyLG5bNV09bls1XStyJTEwJnpyLGl1KG4sMCxuLmxlbmd0aCl9ZnVuY3Rpb24gX0plKGUpe3ZhciBuLHI7cmV0dXJuIHI9LWUuc3RhbmRhcmRPZmZzZXQsbj1QKEkoZmwsMSksWHMsMjgsMTUsWzQzLDQ4LDQ4LDQ4LDQ4XSkscjwwJiYoblswXT00NSxyPS1yKSxuWzFdPW5bMV0rKChyLzYwfDApLzEwfDApJnpyLG5bMl09blsyXSsoci82MHwwKSUxMCZ6cixuWzNdPW5bM10rKHIlNjAvMTB8MCkmenIsbls0XT1uWzRdK3IlMTAmenIsaXUobiwwLG4ubGVuZ3RoKX1mdW5jdGlvbiBUdWUoKXt9ZnVuY3Rpb24gZEplKGUpe3ZhciBuO3JldHVybiBuPVAoSShmbCwxKSxYcywyOCwxNSxbNzEsNzcsODQsNDUsNDgsNDgsNTgsNDgsNDhdKSxlPD0wJiYoblszXT00MyxlPS1lKSxuWzRdPW5bNF0rKChlLzYwfDApLzEwfDApJnpyLG5bNV09bls1XSsoZS82MHwwKSUxMCZ6cixuWzddPW5bN10rKGUlNjAvMTB8MCkmenIsbls4XT1uWzhdK2UlMTAmenIsaXUobiwwLG4ubGVuZ3RoKX1mdW5jdGlvbiBmSmUoZSl7dmFyIG47cmV0dXJuIGU9PTA/IkV0Yy9HTVQiOihlPDA/KGU9LWUsbj0iRXRjL0dNVC0iKTpuPSJFdGMvR01UKyIsbitJdWUoZSkpfWZ1bmN0aW9uIGJ1ZShlKXt2YXIgbjtyZXR1cm4gZT09MD8iVVRDIjooZTwwPyhlPS1lLG49IlVUQysiKTpuPSJVVEMtIixuK0l1ZShlKSl9ZnVuY3Rpb24gcEplKGUpe3ZhciBuO3JldHVybiBuPW5ldyBUdWUsbi5zdGFuZGFyZE9mZnNldD1lLG4udGltZXpvbmVJRD1mSmUoZSksbi50ek5hbWVzPUIoc2UsWCwyLDIsNiwxKSxuLnR6TmFtZXNbMF09YnVlKGUpLG4udHpOYW1lc1sxXT1idWUoZSksbn1mdW5jdGlvbiBJdWUoZSl7dmFyIG4scjtyZXR1cm4gbj1lLzYwfDAscj1lJTYwLHI9PTA/IiIrbjoiIituKyI6IisoIiIrcil9cCgyMDI3LDEse30sVHVlKSxsLnN0YW5kYXJkT2Zmc2V0PTAsZygiY29tLmdvb2dsZS5nd3QuaTE4bi5jbGllbnQiLCJUaW1lWm9uZSIsMjAyNyk7ZnVuY3Rpb24geHVlKCl7fXAoMTI5MywyMTAyLHt9LHh1ZSksZygiY29tLmdvb2dsZS5nd3QuaTE4bi5jbGllbnQuaW1wbC5jbGRyIiwiRGF0ZVRpbWVGb3JtYXRJbmZvSW1wbCIsMTI5Myk7ZnVuY3Rpb24gUHVlKGUsbil7dGhpcy50ZXh0XzA9ZSx0aGlzLmNvdW50PW4sdGhpcy5hYnV0U3RhcnQ9ITF9cCg0NDMsMSx7NDQzOjF9LFB1ZSksbC5hYnV0U3RhcnQ9ITEsbC5jb3VudD0wLGcoImNvbS5nb29nbGUuZ3d0LmkxOG4uc2hhcmVkIiwiRGF0ZVRpbWVGb3JtYXQvUGF0dGVyblBhcnQiLDQ0Myk7ZnVuY3Rpb24gZ0plKGUsbil7cmV0dXJuIHNjZShIbyhlLmpzZGF0ZS5nZXRUaW1lKCkpLEhvKG4uanNkYXRlLmdldFRpbWUoKSkpfWZ1bmN0aW9uIE0yKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztuJT0yNCxlLmpzZGF0ZS5nZXRIb3VycygpIT1uJiYodD1uZXcgUy5EYXRlKGUuanNkYXRlLmdldFRpbWUoKSksdC5zZXREYXRlKHQuZ2V0RGF0ZSgpKzEpLHU9ZS5qc2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKS10LmdldFRpbWV6b25lT2Zmc2V0KCksdT4wJiYoYz11LzYwfDAsXz11JTYwLG89ZS5qc2RhdGUuZ2V0RGF0ZSgpLHI9ZS5qc2RhdGUuZ2V0SG91cnMoKSxyK2M+PTI0JiYrK28saT1uZXcgUy5EYXRlKGUuanNkYXRlLmdldEZ1bGxZZWFyKCksZS5qc2RhdGUuZ2V0TW9udGgoKSxvLG4rYyxlLmpzZGF0ZS5nZXRNaW51dGVzKCkrXyxlLmpzZGF0ZS5nZXRTZWNvbmRzKCksZS5qc2RhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpLGUuanNkYXRlLnNldFRpbWUoaS5nZXRUaW1lKCkpKSkscz1lLmpzZGF0ZS5nZXRUaW1lKCksZS5qc2RhdGUuc2V0VGltZShzKzM2ZTUpLGUuanNkYXRlLmdldEhvdXJzKCkhPW4mJmUuanNkYXRlLnNldFRpbWUocyl9ZnVuY3Rpb24gZkMoZSxuKXt2YXIgcjtyPWUuanNkYXRlLmdldEhvdXJzKCksZS5qc2RhdGUuc2V0RGF0ZShuKSxNMihlLHIpfWZ1bmN0aW9uIGhKZShlLG4pe2UuanNkYXRlLnNldEhvdXJzKG4pLE0yKGUsbil9ZnVuY3Rpb24gbUplKGUsbil7dmFyIHI7cj1lLmpzZGF0ZS5nZXRIb3VycygpKyhuLzYwfDApLGUuanNkYXRlLnNldE1pbnV0ZXMobiksTTIoZSxyKX1mdW5jdGlvbiB5SmUoZSxuKXt2YXIgcjtyPWUuanNkYXRlLmdldEhvdXJzKCksZS5qc2RhdGUuc2V0TW9udGgobiksTTIoZSxyKX1mdW5jdGlvbiB3SmUoZSxuKXt2YXIgcjtyPWUuanNkYXRlLmdldEhvdXJzKCkrKG4vMzYwMHwwKSxlLmpzZGF0ZS5zZXRTZWNvbmRzKG4pLE0yKGUscil9ZnVuY3Rpb24gTnVlKGUsbil7ZS5qc2RhdGUuc2V0VGltZShJXyhuKSl9ZnVuY3Rpb24gUyQoZSxuKXt2YXIgcjtyPWUuanNkYXRlLmdldEhvdXJzKCksZS5qc2RhdGUuc2V0RnVsbFllYXIobitoMCksTTIoZSxyKX1mdW5jdGlvbiBESSgpe3RoaXMuanNkYXRlPW5ldyBTLkRhdGV9ZnVuY3Rpb24gQyQoZSxuLHIpe3RoaXMuanNkYXRlPW5ldyBTLkRhdGUsdGhpcy5qc2RhdGUuc2V0RnVsbFllYXIoZStoMCxuLHIpLHRoaXMuanNkYXRlLnNldEhvdXJzKDAsMCwwLDApLE0yKHRoaXMsMCl9ZnVuY3Rpb24gVCQoZSl7dGhpcy5qc2RhdGU9bmV3IFMuRGF0ZShJXyhlKSl9ZnVuY3Rpb24gRkkoZSl7cmV0dXJuIGU8MTA/IjAiK2U6IiIrZX1wKDIwNiwxLG9pZSxESSxDJCxUJCksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gZ0plKHRoaXMsYShuLDIwNikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMjA2KSYmVDEoSG8odGhpcy5qc2RhdGUuZ2V0VGltZSgpKSxIbyhhKG4sMjA2KS5qc2RhdGUuZ2V0VGltZSgpKSl9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPUhvKHRoaXMuanNkYXRlLmdldFRpbWUoKSksU24oUDUobix2MChuLDMyKSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7cmV0dXJuIHQ9LXRoaXMuanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCksbj0odD49MD8iKyI6IiIpKyh0LzYwfDApLHI9RkkoUy5NYXRoLmFicyh0KSU2MCksKEEwZSgpLEwwZSlbdGhpcy5qc2RhdGUuZ2V0RGF5KCldKyIgIitrMGVbdGhpcy5qc2RhdGUuZ2V0TW9udGgoKV0rIiAiK0ZJKHRoaXMuanNkYXRlLmdldERhdGUoKSkrIiAiK0ZJKHRoaXMuanNkYXRlLmdldEhvdXJzKCkpKyI6IitGSSh0aGlzLmpzZGF0ZS5nZXRNaW51dGVzKCkpKyI6IitGSSh0aGlzLmpzZGF0ZS5nZXRTZWNvbmRzKCkpKyIgR01UIituK3IrIiAiK3RoaXMuanNkYXRlLmdldEZ1bGxZZWFyKCl9O3ZhciB6ST1nKCJqYXZhLnV0aWwiLCJEYXRlIiwyMDYpO2Z1bmN0aW9uIEVKZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2lmKGUuZXJhPT0wJiZlLnllYXI+MCYmKGUueWVhcj0tKGUueWVhci0xKSksZS55ZWFyPmJ0JiZTJChuLGUueWVhci1oMCkscz1uLmpzZGF0ZS5nZXREYXRlKCksZkMobiwxKSxlLm1vbnRoPj0wJiZ5SmUobixlLm1vbnRoKSxlLmRheU9mTW9udGg+PTA/ZkMobixlLmRheU9mTW9udGgpOmUubW9udGg+PTA/KGM9bmV3IEMkKG4uanNkYXRlLmdldEZ1bGxZZWFyKCktaDAsbi5qc2RhdGUuZ2V0TW9udGgoKSwzNSksdD0zNS1jLmpzZGF0ZS5nZXREYXRlKCksZkMobixTLk1hdGgubWluKHQscykpKTpmQyhuLHMpLGUuaG91cnM8MCYmKGUuaG91cnM9bi5qc2RhdGUuZ2V0SG91cnMoKSksZS5hbXBtPjAmJmUuaG91cnM8MTImJihlLmhvdXJzKz0xMiksaEplKG4sZS5ob3Vycz09MjQmJmUubWlkbmlnaHRJczI0PzA6ZS5ob3VycyksZS5taW51dGVzPj0wJiZtSmUobixlLm1pbnV0ZXMpLGUuc2Vjb25kcz49MCYmd0plKG4sZS5zZWNvbmRzKSxlLm1pbGxpc2Vjb25kcz49MCYmTnVlKG4sTnQoQXQoaEMoSG8obi5qc2RhdGUuZ2V0VGltZSgpKSxiYyksYmMpLGUubWlsbGlzZWNvbmRzKSksZS5hbWJpZ3VvdXNZZWFyJiYobz1uZXcgREksUyQobyxvLmpzZGF0ZS5nZXRGdWxsWWVhcigpLWgwLTgwKSx4NShIbyhuLmpzZGF0ZS5nZXRUaW1lKCkpLEhvKG8uanNkYXRlLmdldFRpbWUoKSkpJiZTJChuLG8uanNkYXRlLmdldEZ1bGxZZWFyKCktaDArMTAwKSksZS5kYXlPZldlZWs+PTApe2lmKGUuZGF5T2ZNb250aD09LTEpcj0oNytlLmRheU9mV2Vlay1uLmpzZGF0ZS5nZXREYXkoKSklNyxyPjMmJihyLT03KSx1PW4uanNkYXRlLmdldE1vbnRoKCksZkMobixuLmpzZGF0ZS5nZXREYXRlKCkrciksbi5qc2RhdGUuZ2V0TW9udGgoKSE9dSYmZkMobixuLmpzZGF0ZS5nZXREYXRlKCkrKHI+MD8tNzo3KSk7ZWxzZSBpZihuLmpzZGF0ZS5nZXREYXkoKSE9ZS5kYXlPZldlZWspcmV0dXJuITF9cmV0dXJuIGUudHpPZmZzZXQ+YnQmJihpPW4uanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCksTnVlKG4sTnQoSG8obi5qc2RhdGUuZ2V0VGltZSgpKSwoZS50ek9mZnNldC1pKSo2MCpiYykpKSwhMH1mdW5jdGlvbiBBdWUoKXtESS5jYWxsKHRoaXMpLHRoaXMuZXJhPS0xLHRoaXMuYW1iaWd1b3VzWWVhcj0hMSx0aGlzLnllYXI9YnQsdGhpcy5tb250aD0tMSx0aGlzLmRheU9mTW9udGg9LTEsdGhpcy5hbXBtPS0xLHRoaXMubWlkbmlnaHRJczI0PSExLHRoaXMuaG91cnM9LTEsdGhpcy5taW51dGVzPS0xLHRoaXMuc2Vjb25kcz0tMSx0aGlzLm1pbGxpc2Vjb25kcz0tMSx0aGlzLmRheU9mV2Vlaz0tMSx0aGlzLnR6T2Zmc2V0PWJ0fXAoMjAxNSwyMDYsb2llLEF1ZSksbC5hbWJpZ3VvdXNZZWFyPSExLGwuYW1wbT0wLGwuZGF5T2ZNb250aD0wLGwuZGF5T2ZXZWVrPTAsbC5lcmE9MCxsLmhvdXJzPTAsbC5taWRuaWdodElzMjQ9ITEsbC5taWxsaXNlY29uZHM9MCxsLm1pbnV0ZXM9MCxsLm1vbnRoPTAsbC5zZWNvbmRzPTAsbC50ek9mZnNldD0wLGwueWVhcj0wLGcoImNvbS5nb29nbGUuZ3d0LmkxOG4uc2hhcmVkLmltcGwiLCJEYXRlUmVjb3JkIiwyMDE1KSxwKDIwNjQsMSx7fSksbC5pc0FycmF5XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbC5pc0Jvb2xlYW49ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbC5pc051bWJlcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmlzT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuaXNTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sZygiY29tLmdvb2dsZS5nd3QuanNvbi5jbGllbnQiLCJKU09OVmFsdWUiLDIwNjQpO2Z1bmN0aW9uIEpkKGUsbil7dmFyIHI9ZS5qc0FycmF5W25dLHQ9KHY1KCksUzUpW3R5cGVvZiByXTtyZXR1cm4gdD90KHIpOngkKHR5cGVvZiByKX1mdW5jdGlvbiB2SmUoZSxuLHIpe3ZhciB0O3JldHVybiB0PUpkKGUsbikseTUoZSxuLHIpLHR9ZnVuY3Rpb24geTUoZSxuLHIpe2lmKHIpe3ZhciB0PXIuZ2V0VW53cmFwcGVyKCk7cj10KHIpfWVsc2Ugcj12b2lkIDA7ZS5qc0FycmF5W25dPXJ9ZnVuY3Rpb24gVF8oKXt0aGlzLmpzQXJyYXk9W119ZnVuY3Rpb24gYiQoZSl7dGhpcy5qc0FycmF5PWV9ZnVuY3Rpb24gU0plKGUpe3JldHVybiBlLmpzQXJyYXl9cCgyMjEsMjA2NCx7MjIxOjF9LFRfLGIkKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMjIxKT9mJCh0aGlzLmpzQXJyYXksYShuLDIyMSkuanNBcnJheSk6ITF9LGwuZ2V0VW53cmFwcGVyPWZ1bmN0aW9uKCl7cmV0dXJuIFNKZX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHAkKHRoaXMuanNBcnJheSl9LGwuaXNBcnJheV8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuLHIsdDtmb3IodD1uZXcgTGEoIlsiKSxyPTAsbj10aGlzLmpzQXJyYXkubGVuZ3RoO3I8bjtyKyspcj4wJiYodC5zdHJpbmcrPSIsIiksZWkodCxKZCh0aGlzLHIpKTtyZXR1cm4gdC5zdHJpbmcrPSJdIix0LnN0cmluZ30sZygiY29tLmdvb2dsZS5nd3QuanNvbi5jbGllbnQiLCJKU09OQXJyYXkiLDIyMSk7ZnVuY3Rpb24gTHVlKCl7THVlPUYsa3VlPW5ldyBJJCghMSksT3VlPW5ldyBJJCghMCl9ZnVuY3Rpb24gSSQoZSl7dGhpcy52YWx1ZV8wPWV9ZnVuY3Rpb24gQ0plKGUpe3JldHVybiBlLnZhbHVlXzB9cCg0OTMsMjA2NCx7NDkzOjF9LEkkKSxsLmdldFVud3JhcHBlcj1mdW5jdGlvbigpe3JldHVybiBDSmV9LGwuaXNCb29sZWFuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB6ZSgpLCIiK3RoaXMudmFsdWVfMH0sbC52YWx1ZV8wPSExO3ZhciBrdWUsT3VlO2coImNvbS5nb29nbGUuZ3d0Lmpzb24uY2xpZW50IiwiSlNPTkJvb2xlYW4iLDQ5Myk7ZnVuY3Rpb24gTXVlKGUpe0lvLmNhbGwodGhpcyxlKX1wKDk5Nyw2MyxLdSxNdWUpLGcoImNvbS5nb29nbGUuZ3d0Lmpzb24uY2xpZW50IiwiSlNPTkV4Y2VwdGlvbiIsOTk3KTtmdW5jdGlvbiBSdWUoKXtSdWU9RixGdWU9bmV3IER1ZX1mdW5jdGlvbiBEdWUoKXt9ZnVuY3Rpb24gVEplKCl7cmV0dXJuIG51bGx9cCgxMDM2LDIwNjQse30sRHVlKSxsLmdldFVud3JhcHBlcj1mdW5jdGlvbigpe3JldHVybiBUSmV9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJudWxsIn07dmFyIEZ1ZTtnKCJjb20uZ29vZ2xlLmd3dC5qc29uLmNsaWVudCIsIkpTT05OdWxsIiwxMDM2KTtmdW5jdGlvbiAkSShlKXt0aGlzLnZhbHVlXzA9ZX1mdW5jdGlvbiBiSmUoZSl7cmV0dXJuIGUudmFsdWVfMH1wKDI2MywyMDY0LHsyNjM6MX0sJEkpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyNjMpP3RoaXMudmFsdWVfMD09YShuLDI2MykudmFsdWVfMDohMX0sbC5nZXRVbndyYXBwZXI9ZnVuY3Rpb24oKXtyZXR1cm4gYkplfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gY2godGhpcy52YWx1ZV8wKX0sbC5pc051bWJlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wKyIifSxsLnZhbHVlXzA9MCxnKCJjb20uZ29vZ2xlLmd3dC5qc29uLmNsaWVudCIsIkpTT05OdW1iZXIiLDI2Myk7ZnVuY3Rpb24gdzUoZSxuKXt2YXIgcj1lLmpzT2JqZWN0LHQ9MDtmb3IodmFyIG8gaW4gcilyLmhhc093blByb3BlcnR5KG8pJiYoblt0KytdPW8pO3JldHVybiBufWZ1bmN0aW9uIElKZShlLG4pe3JldHVybiBuIGluIGUuanNPYmplY3R9ZnVuY3Rpb24gUXUoZSxuKXtpZihuPT1udWxsKXRocm93IGIobmV3IF9oKTtyZXR1cm4geEplKGUsbil9ZnVuY3Rpb24geEplKGUsbil7dmFyIHI9ZS5qc09iamVjdCx0O249U3RyaW5nKG4pLHIuaGFzT3duUHJvcGVydHkobikmJih0PXJbbl0pO3ZhciBvPSh2NSgpLFM1KVt0eXBlb2YgdF0saT1vP28odCk6eCQodHlwZW9mIHQpO3JldHVybiBpfWZ1bmN0aW9uIGFzKGUsbixyKXt2YXIgdDtpZihuPT1udWxsKXRocm93IGIobmV3IF9oKTtyZXR1cm4gdD1RdShlLG4pLFBKZShlLG4sciksdH1mdW5jdGlvbiBQSmUoZSxuLHIpe2lmKHIpe3ZhciB0PXIuZ2V0VW53cmFwcGVyKCk7ZS5qc09iamVjdFtuXT10KHIpfWVsc2UgZGVsZXRlIGUuanNPYmplY3Rbbl19ZnVuY3Rpb24gc2goKXtwQy5jYWxsKHRoaXMse30pfWZ1bmN0aW9uIHBDKGUpe3RoaXMuanNPYmplY3Q9ZX1mdW5jdGlvbiBOSmUoZSl7cmV0dXJuIGUuanNPYmplY3R9cCgxOTAsMjA2NCx7MTkwOjF9LHNoLHBDKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTkwKT9mJCh0aGlzLmpzT2JqZWN0LGEobiwxOTApLmpzT2JqZWN0KTohMX0sbC5nZXRVbndyYXBwZXI9ZnVuY3Rpb24oKXtyZXR1cm4gTkplfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gcCQodGhpcy5qc09iamVjdCl9LGwuaXNPYmplY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saSxzLHU7Zm9yKHU9bmV3IExhKCJ7Iiksbj0hMCxzPXc1KHRoaXMsQihzZSxYLDIsMCw2LDEpKSx0PXMsbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sbj9uPSExOnUuc3RyaW5nKz0iLCAiLE9uKHUsX3VlKHIpKSx1LnN0cmluZys9IjoiLGVpKHUsUXUodGhpcyxyKSk7cmV0dXJuIHUuc3RyaW5nKz0ifSIsdS5zdHJpbmd9LGcoImNvbS5nb29nbGUuZ3d0Lmpzb24uY2xpZW50IiwiSlNPTk9iamVjdCIsMTkwKTtmdW5jdGlvbiBFNShlLG4pe3RoaXMudGhpcyQwMT1lLHRoaXMudmFsJGtleXMyPW59cCg2MDUsU3MsRGksRTUpLGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pJiZJSmUodGhpcy50aGlzJDAxLHhuKG4pKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBxMihuZXcgZWEodGhpcy52YWwka2V5czIpKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWwka2V5czIubGVuZ3RofSxnKCJjb20uZ29vZ2xlLmd3dC5qc29uLmNsaWVudCIsIkpTT05PYmplY3QvMSIsNjA1KTtmdW5jdGlvbiB2NSgpe3Y1PUYsUzU9e2Jvb2xlYW46QUplLG51bWJlcjpMSmUsc3RyaW5nOmtKZSxvYmplY3Q6enVlLGZ1bmN0aW9uOnp1ZSx1bmRlZmluZWQ6T0plfX1mdW5jdGlvbiBBSmUoZSl7cmV0dXJuIEx1ZSgpLGU/T3VlOmt1ZX1mdW5jdGlvbiBMSmUoZSl7cmV0dXJuIG5ldyAkSShlKX1mdW5jdGlvbiB6dWUoZSl7aWYoIWUpcmV0dXJuIFJ1ZSgpLEZ1ZTt2YXIgbj1lLnZhbHVlT2Y/ZS52YWx1ZU9mKCk6ZTtpZihuIT09ZSl7dmFyIHI9UzVbdHlwZW9mIG5dO3JldHVybiByP3Iobik6eCQodHlwZW9mIG4pfWVsc2UgcmV0dXJuIGUgaW5zdGFuY2VvZiBBcnJheXx8ZSBpbnN0YW5jZW9mIFMuQXJyYXk/bmV3IGIkKGUpOm5ldyBwQyhlKX1mdW5jdGlvbiBrSmUoZSl7cmV0dXJuIG5ldyBaZChlKX1mdW5jdGlvbiBPSmUoKXtyZXR1cm4gbnVsbH1mdW5jdGlvbiB4JChlKXt0aHJvdyB2NSgpLGIobmV3IE11ZSgiVW5leHBlY3RlZCB0eXBlb2YgcmVzdWx0ICciK2UrIic7IHBsZWFzZSByZXBvcnQgdGhpcyBidWcgdG8gdGhlIEdXVCB0ZWFtIikpfXZhciBTNTtmdW5jdGlvbiBaZChlKXtpZihlPT1udWxsKXRocm93IGIobmV3IF9oKTt0aGlzLnZhbHVlXzA9ZX1mdW5jdGlvbiBNSmUoZSl7cmV0dXJuIGUudmFsdWVfMH1wKDIxMSwyMDY0LHsyMTE6MX0sWmQpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyMTEpP1RlKHRoaXMudmFsdWVfMCxhKG4sMjExKS52YWx1ZV8wKTohMX0sbC5nZXRVbndyYXBwZXI9ZnVuY3Rpb24oKXtyZXR1cm4gTUplfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gTmModGhpcy52YWx1ZV8wKX0sbC5pc1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gX3VlKHRoaXMudmFsdWVfMCl9LGcoImNvbS5nb29nbGUuZ3d0Lmpzb24uY2xpZW50IiwiSlNPTlN0cmluZyIsMjExKTtmdW5jdGlvbiBSSmUoZSxuKXt2YXIgcjtzd2l0Y2goZ0MoZSkpe2Nhc2UgNjpyZXR1cm4gdXQobik7Y2FzZSA3OnJldHVybiBxZChuKTtjYXNlIDg6cmV0dXJuIFZkKG4pO2Nhc2UgMzpyZXR1cm4gQXJyYXkuaXNBcnJheShuKSYmKHI9Z0MobiksIShyPj0xNCYmcjw9MTYpKTtjYXNlIDExOnJldHVybiBuIT1udWxsJiZ0eXBlb2Ygbj09ImZ1bmN0aW9uIjtjYXNlIDEyOnJldHVybiBuIT1udWxsJiYodHlwZW9mIG49PSJvYmplY3QifHx0eXBlb2Ygbj09ImZ1bmN0aW9uIik7Y2FzZSAwOnJldHVybiB2NihuLGUuX19lbGVtZW50VHlwZUlkJCk7Y2FzZSAyOnJldHVybiBDNihuKSYmbi50eXBlTWFya2VyIT09bmg7Y2FzZSAxOnJldHVybiBDNihuKSYmbi50eXBlTWFya2VyIT09bmh8fHY2KG4sZS5fX2VsZW1lbnRUeXBlSWQkKTtkZWZhdWx0OnJldHVybiEwfX1mdW5jdGlvbiBJKGUsbil7cmV0dXJuIFdpZShlLG4pfWZ1bmN0aW9uIGdDKGUpe3JldHVybiBlLl9fZWxlbWVudFR5cGVDYXRlZ29yeSQ9PW51bGw/MTA6ZS5fX2VsZW1lbnRUeXBlQ2F0ZWdvcnkkfWZ1bmN0aW9uIGJfKGUsbixyLHQsbyxpKXtyZXR1cm4gJHVlKGUsbixyLHQsbywwLGkpfWZ1bmN0aW9uICR1ZShlLG4scix0LG8saSxzKXt2YXIgdSxjLF8sZCxmO2lmKGQ9b1tpXSxfPWk9PXMtMSx1PV8/dDowLGY9QnVlKHUsZCksdCE9MTAmJlAoSShlLHMtaSksbltpXSxyW2ldLHUsZiksIV8pZm9yKCsraSxjPTA7YzxkOysrYylmW2NdPSR1ZShlLG4scix0LG8saSxzKTtyZXR1cm4gZn1mdW5jdGlvbiBCKGUsbixyLHQsbyxpKXt2YXIgcztyZXR1cm4gcz1CdWUobyx0KSxvIT0xMCYmUChJKGUsaSksbixyLG8scyksc31mdW5jdGlvbiBCdWUoZSxuKXt2YXIgcj1uZXcgQXJyYXkobiksdDtzd2l0Y2goZSl7Y2FzZSAxNDpjYXNlIDE1OnQ9MDticmVhaztjYXNlIDE2OnQ9ITE7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gcn1mb3IodmFyIG89MDtvPG47KytvKXJbb109dDtyZXR1cm4gcn1mdW5jdGlvbiBQJChlKXtyZXR1cm4gQXJyYXkuaXNBcnJheShlKSYmZS50eXBlTWFya2VyPT09bmh9ZnVuY3Rpb24gVHIoZSxuLHIpe3JldHVybiBIZW4ocj09bnVsbHx8UkplKGUscikpLGVbbl09cn1mdW5jdGlvbiBQKGUsbixyLHQsbyl7cmV0dXJuIG8uX19fY2xheno9ZSxvLmNhc3RhYmxlVHlwZU1hcD1uLG8udHlwZU1hcmtlcj1uaCxvLl9fZWxlbWVudFR5cGVJZCQ9cixvLl9fZWxlbWVudFR5cGVDYXRlZ29yeSQ9dCxvfWZ1bmN0aW9uIEM1KGUsbil7cmV0dXJuIGdDKG4pIT0xMCYmUCh3YShuKSxuLmNhc3RhYmxlVHlwZU1hcCxuLl9fZWxlbWVudFR5cGVJZCQsZ0MobiksZSksZX1mdW5jdGlvbiBUNShlKXt2YXIgbixyLHQ7cmV0dXJuIG49ZSZfYSxyPWU+PjIyJl9hLHQ9ZTwwP1h1OjAsbWkobixyLHQpfWZ1bmN0aW9uIEd1ZShlKXtyZXR1cm4gbWkoZS5sLGUubSxlLmgpfWZ1bmN0aW9uIG1pKGUsbixyKXtyZXR1cm57bDplLG06bixoOnJ9fWZ1bmN0aW9uIE4kKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYobi5sPT0wJiZuLm09PTAmJm4uaD09MCl0aHJvdyBiKG5ldyBHSSgiZGl2aWRlIGJ5IHplcm8iKSk7aWYoZS5sPT0wJiZlLm09PTAmJmUuaD09MClyZXR1cm4gciYmKHcwPW1pKDAsMCwwKSksbWkoMCwwLDApO2lmKG4uaD09cVMmJm4ubT09MCYmbi5sPT0wKXJldHVybiBESmUoZSxyKTtpZihjPSExLG4uaD4+MTkmJihuPXJ5KG4pLGM9IWMpLHM9QkplKG4pLGk9ITEsbz0hMSx0PSExLGUuaD09cVMmJmUubT09MCYmZS5sPT0wKWlmKG89ITAsaT0hMCxzPT0tMSllPUd1ZSgodHkoKSxrJCkpLHQ9ITAsYz0hYztlbHNlIHJldHVybiB1PUwkKGUscyksYyYmYjUodSksciYmKHcwPW1pKDAsMCwwKSksdTtlbHNlIGUuaD4+MTkmJihpPSEwLGU9cnkoZSksdD0hMCxjPSFjKTtyZXR1cm4gcyE9LTE/RkplKGUscyxjLGkscik6QSQoZSxuKTwwPyhyJiYoaT93MD1yeShlKTp3MD1taShlLmwsZS5tLGUuaCkpLG1pKDAsMCwwKSk6ekplKHQ/ZTptaShlLmwsZS5tLGUuaCksbixjLGksbyxyKX1mdW5jdGlvbiBESmUoZSxuKXtyZXR1cm4gZS5oPT1xUyYmZS5tPT0wJiZlLmw9PTA/KG4mJih3MD1taSgwLDAsMCkpLEd1ZSgodHkoKSxPJCkpKToobiYmKHcwPW1pKGUubCxlLm0sZS5oKSksbWkoMCwwLDApKX1mdW5jdGlvbiBGSmUoZSxuLHIsdCxvKXt2YXIgaTtyZXR1cm4gaT1MJChlLG4pLHImJmI1KGkpLG8mJihlPSRKZShlLG4pLHQ/dzA9cnkoZSk6dzA9bWkoZS5sLGUubSxlLmgpKSxpfWZ1bmN0aW9uIHpKZShlLG4scix0LG8saSl7dmFyIHMsdSxjLF8sZCxmLGg7Zm9yKF89SHVlKG4pLUh1ZShlKSxzPVV1ZShuLF8pLGM9bWkoMCwwLDApO18+PTAmJih1PUhKZShlLHMpLCEodSYmKF88MjI/Yy5sfD0xPDxfOl88NDQ/Yy5tfD0xPDxfLTIyOmMuaHw9MTw8Xy00NCxlLmw9PTAmJmUubT09MCYmZS5oPT0wKSkpOylkPXMubSxmPXMuaCxoPXMubCxzLmg9Zj4+PjEscy5tPWQ+Pj4xfChmJjEpPDwyMSxzLmw9aD4+PjF8KGQmMSk8PDIxLC0tXztyZXR1cm4gciYmYjUoYyksaSYmKHQ/KHcwPXJ5KGUpLG8mJih3MD1XdWUodzAsKHR5KCksTyQpKSkpOncwPW1pKGUubCxlLm0sZS5oKSksY31mdW5jdGlvbiAkSmUoZSxuKXt2YXIgcix0LG87cmV0dXJuIG48PTIyPyhyPWUubCYoMTw8biktMSx0PW89MCk6bjw9NDQ/KHI9ZS5sLHQ9ZS5tJigxPDxuLTIyKS0xLG89MCk6KHI9ZS5sLHQ9ZS5tLG89ZS5oJigxPDxuLTQ0KS0xKSxtaShyLHQsbyl9ZnVuY3Rpb24gYjUoZSl7dmFyIG4scix0O249fmUubCsxJl9hLHI9fmUubSsobj09MD8xOjApJl9hLHQ9fmUuaCsobj09MCYmcj09MD8xOjApJlh1LGUubD1uLGUubT1yLGUuaD10fWZ1bmN0aW9uIEh1ZShlKXt2YXIgbixyO3JldHVybiByPWJDKGUuaCkscj09MzI/KG49YkMoZS5tKSxuPT0zMj9iQyhlLmwpKzMyOm4rMjAtMTApOnItMTJ9ZnVuY3Rpb24gQkplKGUpe3ZhciBuLHIsdDtyZXR1cm4gcj1lLmwsciZyLTF8fCh0PWUubSx0JnQtMSl8fChuPWUuaCxuJm4tMSl8fG49PTAmJnQ9PTAmJnI9PTA/LTE6bj09MCYmdD09MCYmciE9MD9KJChyKTpuPT0wJiZ0IT0wJiZyPT0wP0okKHQpKzIyOm4hPTAmJnQ9PTAmJnI9PTA/SiQobikrNDQ6LTF9ZnVuY3Rpb24gR0plKGUpe3JldHVybiBlLmwrZS5tKmVoK2UuaCpwX31mdW5jdGlvbiBISmUoZSxuKXt2YXIgcix0LG87cmV0dXJuIG89ZS5oLW4uaCxvPDB8fChyPWUubC1uLmwsdD1lLm0tbi5tKyhyPj4yMiksbys9dD4+MjIsbzwwKT8hMTooZS5sPXImX2EsZS5tPXQmX2EsZS5oPW8mWHUsITApfXZhciB3MDtmdW5jdGlvbiBVSmUoZSxuKXt2YXIgcix0LG87cmV0dXJuIHI9ZS5sK24ubCx0PWUubStuLm0rKHI+PjIyKSxvPWUuaCtuLmgrKHQ+PjIyKSxtaShyJl9hLHQmX2EsbyZYdSl9ZnVuY3Rpb24gV0plKGUsbil7cmV0dXJuIG1pKGUubCZuLmwsZS5tJm4ubSxlLmgmbi5oKX1mdW5jdGlvbiBBJChlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87cmV0dXJuIGM9ZS5oPj4xOSxfPW4uaD4+MTksYyE9Xz9fLWM6KG89ZS5oLHU9bi5oLG8hPXU/by11Oih0PWUubSxzPW4ubSx0IT1zP3Qtczoocj1lLmwsaT1uLmwsci1pKSkpfWZ1bmN0aW9uIGpKZShlKXt2YXIgbixyLHQsbyxpO3JldHVybiBpc05hTihlKT8odHkoKSxNJCk6ZTwtOTIyMzM3MjAzNjg1NDc3NmUzPyh0eSgpLHF1ZSk6ZT49OTIyMzM3MjAzNjg1NDc3NmUzPyh0eSgpLGskKToobz0hMSxlPDAmJihvPSEwLGU9LWUpLHQ9MCxlPj1wXyYmKHQ9S3IoZS9wXyksZS09dCpwXykscj0wLGU+PWVoJiYocj1LcihlL2VoKSxlLT1yKmVoKSxuPUtyKGUpLGk9bWkobixyLHQpLG8mJmI1KGkpLGkpfWZ1bmN0aW9uIFZKZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZSxGZSxubjtyZXR1cm4gcj1lLmwmODE5MSx0PWUubD4+MTN8KGUubSYxNSk8PDksbz1lLm0+PjQmODE5MSxpPWUubT4+MTd8KGUuaCYyNTUpPDw1LHM9KGUuaCYxMDQ4MzIwKT4+OCx1PW4ubCY4MTkxLGM9bi5sPj4xM3wobi5tJjE1KTw8OSxfPW4ubT4+NCY4MTkxLGQ9bi5tPj4xN3wobi5oJjI1NSk8PDUsZj0obi5oJjEwNDgzMjApPj44LHZlPXIqdSx3ZT10KnUsRGU9byp1LEZlPWkqdSxubj1zKnUsYyE9MCYmKHdlKz1yKmMsRGUrPXQqYyxGZSs9bypjLG5uKz1pKmMpLF8hPTAmJihEZSs9cipfLEZlKz10Kl8sbm4rPW8qXyksZCE9MCYmKEZlKz1yKmQsbm4rPXQqZCksZiE9MCYmKG5uKz1yKmYpLG09dmUmX2EseT0od2UmNTExKTw8MTMsaD1tK3ksdj12ZT4+MjIseD13ZT4+OSxBPShEZSYyNjIxNDMpPDw0LGs9KEZlJjMxKTw8MTcsRT12K3grQStrLEg9RGU+PjE4LHE9RmU+PjUsbmU9KG5uJjQwOTUpPDw4LE09SCtxK25lLEUrPWg+PjIyLGgmPV9hLE0rPUU+PjIyLEUmPV9hLE0mPVh1LG1pKGgsRSxNKX1mdW5jdGlvbiByeShlKXt2YXIgbixyLHQ7cmV0dXJuIG49fmUubCsxJl9hLHI9fmUubSsobj09MD8xOjApJl9hLHQ9fmUuaCsobj09MCYmcj09MD8xOjApJlh1LG1pKG4scix0KX1mdW5jdGlvbiBxSmUoZSl7cmV0dXJuIG1pKH5lLmwmX2EsfmUubSZfYSx+ZS5oJlh1KX1mdW5jdGlvbiBZSmUoZSxuKXtyZXR1cm4gbWkoZS5sfG4ubCxlLm18bi5tLGUuaHxuLmgpfWZ1bmN0aW9uIFV1ZShlLG4pe3ZhciByLHQsbztyZXR1cm4gbiY9NjMsbjwyMj8ocj1lLmw8PG4sdD1lLm08PG58ZS5sPj4yMi1uLG89ZS5oPDxufGUubT4+MjItbik6bjw0ND8ocj0wLHQ9ZS5sPDxuLTIyLG89ZS5tPDxuLTIyfGUubD4+NDQtbik6KHI9MCx0PTAsbz1lLmw8PG4tNDQpLG1pKHImX2EsdCZfYSxvJlh1KX1mdW5jdGlvbiBMJChlLG4pe3ZhciByLHQsbyxpLHM7cmV0dXJuIG4mPTYzLHI9ZS5oLHQ9KHImcVMpIT0wLHQmJihyfD0tMTA0ODU3NiksbjwyMj8ocz1yPj5uLGk9ZS5tPj5ufHI8PDIyLW4sbz1lLmw+Pm58ZS5tPDwyMi1uKTpuPDQ0PyhzPXQ/WHU6MCxpPXI+Pm4tMjIsbz1lLm0+Pm4tMjJ8cjw8NDQtbik6KHM9dD9YdTowLGk9dD9fYTowLG89cj4+bi00NCksbWkobyZfYSxpJl9hLHMmWHUpfWZ1bmN0aW9uIEtKZShlLG4pe3ZhciByLHQsbyxpO3JldHVybiBuJj02MyxyPWUuaCZYdSxuPDIyPyhpPXI+Pj5uLG89ZS5tPj5ufHI8PDIyLW4sdD1lLmw+Pm58ZS5tPDwyMi1uKTpuPDQ0PyhpPTAsbz1yPj4+bi0yMix0PWUubT4+bi0yMnxlLmg8PDQ0LW4pOihpPTAsbz0wLHQ9cj4+Pm4tNDQpLG1pKHQmX2EsbyZfYSxpJlh1KX1mdW5jdGlvbiBXdWUoZSxuKXt2YXIgcix0LG87cmV0dXJuIHI9ZS5sLW4ubCx0PWUubS1uLm0rKHI+PjIyKSxvPWUuaC1uLmgrKHQ+PjIyKSxtaShyJl9hLHQmX2EsbyZYdSl9ZnVuY3Rpb24gWEplKGUpe3JldHVybiBBJChlLCh0eSgpLE0kKSk8MD8tR0plKHJ5KGUpKTplLmwrZS5tKmVoK2UuaCpwX31mdW5jdGlvbiBqdWUoZSl7cmV0dXJuIGUubHxlLm08PDIyfWZ1bmN0aW9uIFZ1ZShlKXt2YXIgbixyLHQsbyxpO2lmKGUubD09MCYmZS5tPT0wJiZlLmg9PTApcmV0dXJuIjAiO2lmKGUuaD09cVMmJmUubT09MCYmZS5sPT0wKXJldHVybiItOTIyMzM3MjAzNjg1NDc3NTgwOCI7aWYoZS5oPj4xOSlyZXR1cm4iLSIrVnVlKHJ5KGUpKTtmb3Iocj1lLHQ9IiI7IShyLmw9PTAmJnIubT09MCYmci5oPT0wKTspe2lmKG89VDUoV2IpLHI9TiQocixvLCEwKSxuPSIiK2p1ZSh3MCksIShyLmw9PTAmJnIubT09MCYmci5oPT0wKSlmb3IoaT05LW4ubGVuZ3RoO2k+MDtpLS0pbj0iMCIrbjt0PW4rdH1yZXR1cm4gdH1mdW5jdGlvbiBKSmUoZSxuKXtyZXR1cm4gbWkoZS5sXm4ubCxlLm1ebi5tLGUuaF5uLmgpfWZ1bmN0aW9uIHR5KCl7dHk9RixrJD1taShfYSxfYSw1MjQyODcpLHF1ZT1taSgwLDAscVMpLE8kPVQ1KDEpLFQ1KDIpLE0kPVQ1KDApfXZhciBrJCxxdWUsTyQsTSQ7ZnVuY3Rpb24gd3IoZSl7dmFyIG47cmV0dXJuIEwoZSw4Mik/ZToobj1lJiZlLl9famF2YSRleGNlcHRpb24sbnx8KG49bmV3IHV1ZShlKSxndWUobikpLG4pfWZ1bmN0aW9uIGIoZSl7cmV0dXJuIGUuYmFja2luZ0pzT2JqZWN0fWZ1bmN0aW9uIE50KGUsbil7dmFyIHI7cmV0dXJuIFNvKGUpJiZTbyhuKSYmKHI9ZStuLFlTPHImJnI8cF8pP3I6RTAoVUplKFNvKGUpP21sKGUpOmUsU28obik/bWwobik6bikpfWZ1bmN0aW9uIGV0KGUsbil7cmV0dXJuIEUwKFdKZShTbyhlKT9tbChlKTplLFNvKG4pP21sKG4pOm4pKX1mdW5jdGlvbiBWbyhlLG4pe3ZhciByO3JldHVybiBTbyhlKSYmU28obikmJihyPWUtbiwhaXNOYU4ocikpP3I6QSQoU28oZSk/bWwoZSk6ZSxTbyhuKT9tbChuKTpuKX1mdW5jdGlvbiBFMChlKXt2YXIgbjtyZXR1cm4gbj1lLmgsbj09MD9lLmwrZS5tKmVoOm49PVh1P2UubCtlLm0qZWgtcF86ZX1mdW5jdGlvbiBoQyhlLG4pe3ZhciByO3JldHVybiBTbyhlKSYmU28obikmJihyPWUvbixZUzxyJiZyPHBfKT9yPDA/Uy5NYXRoLmNlaWwocik6Uy5NYXRoLmZsb29yKHIpOkUwKE4kKFNvKGUpP21sKGUpOmUsU28obik/bWwobik6biwhMSkpfWZ1bmN0aW9uIFQxKGUsbil7cmV0dXJuIFZvKGUsbik9PTB9ZnVuY3Rpb24gSG8oZSl7cmV0dXJuIFlTPGUmJmU8cF8/ZTwwP1MuTWF0aC5jZWlsKGUpOlMuTWF0aC5mbG9vcihlKTpFMChqSmUoZSkpfWZ1bmN0aW9uIEk1KGUsbil7cmV0dXJuIFZvKGUsbik+MH1mdW5jdGlvbiBCSShlLG4pe3JldHVybiBWbyhlLG4pPj0wfWZ1bmN0aW9uIFNvKGUpe3JldHVybiB0eXBlb2YgZT09Im51bWJlciJ9ZnVuY3Rpb24geDUoZSxuKXtyZXR1cm4gVm8oZSxuKTwwfWZ1bmN0aW9uIG1DKGUsbil7dmFyIHI7cmV0dXJuIFNvKGUpJiZTbyhuKSYmKHI9ZSVuLFlTPHImJnI8cF8pP3I6RTAoKE4kKFNvKGUpP21sKGUpOmUsU28obik/bWwobik6biwhMCksdzApKX1mdW5jdGlvbiBBdChlLG4pe3ZhciByO3JldHVybiBTbyhlKSYmU28obikmJihyPWUqbixZUzxyJiZyPHBfKT9yOkUwKFZKZShTbyhlKT9tbChlKTplLFNvKG4pP21sKG4pOm4pKX1mdW5jdGlvbiBQYyhlKXt2YXIgbjtyZXR1cm4gU28oZSkmJihuPTAtZSwhaXNOYU4obikpP246RTAocnkoZSkpfWZ1bmN0aW9uIFIyKGUsbil7cmV0dXJuIFZvKGUsbikhPTB9ZnVuY3Rpb24gUiQoZSl7cmV0dXJuIEUwKHFKZShTbyhlKT9tbChlKTplKSl9ZnVuY3Rpb24gbHMoZSxuKXtyZXR1cm4gRTAoWUplKFNvKGUpP21sKGUpOmUsU28obik/bWwobik6bikpfWZ1bmN0aW9uIE9sKGUsbil7cmV0dXJuIEUwKFV1ZShTbyhlKT9tbChlKTplLG4pKX1mdW5jdGlvbiBiMShlLG4pe3JldHVybiBFMChMJChTbyhlKT9tbChlKTplLG4pKX1mdW5jdGlvbiB2MChlLG4pe3JldHVybiBFMChLSmUoU28oZSk/bWwoZSk6ZSxuKSl9ZnVuY3Rpb24gaGwoZSxuKXt2YXIgcjtyZXR1cm4gU28oZSkmJlNvKG4pJiYocj1lLW4sWVM8ciYmcjxwXyk/cjpFMChXdWUoU28oZSk/bWwoZSk6ZSxTbyhuKT9tbChuKTpuKSl9ZnVuY3Rpb24gbWwoZSl7dmFyIG4scix0LG87cmV0dXJuIG89ZSx0PTAsbzwwJiYobys9cF8sdD1YdSkscj1LcihvL2VoKSxuPUtyKG8tciplaCksbWkobixyLHQpfWZ1bmN0aW9uIElfKGUpe3ZhciBuO3JldHVybiBTbyhlKT8obj1lLG49PS0wPzA6bik6WEplKGUpfWZ1bmN0aW9uIFNuKGUpe3JldHVybiBTbyhlKT9lfDA6anVlKGUpfWZ1bmN0aW9uIEQyKGUpe3JldHVybiBTbyhlKT8iIitlOlZ1ZShlKX1mdW5jdGlvbiBQNShlLG4pe3JldHVybiBFMChKSmUoU28oZSk/bWwoZSk6ZSxTbyhuKT9tbChuKTpuKSl9ZnVuY3Rpb24gWkplKCl7aXJlKCksVVNuKCl9ZnVuY3Rpb24gUUplKGUsbil7cmV0dXJuIG4uc3BsaXQoZSl9cCgyMDYwLDEsezUzMzoxfSksZygiamF2YS5pbyIsIk91dHB1dFN0cmVhbSIsMjA2MCkscCgyMDYxLDIwNjAsezUzMzoxfSksZygiamF2YS5pbyIsIkZpbHRlck91dHB1dFN0cmVhbSIsMjA2MSk7ZnVuY3Rpb24gZVplKGUpe2UmJlBJKGUsZS5nZXRNZXNzYWdlKCkpfWZ1bmN0aW9uIFl1ZSgpe31wKDg3OCwyMDYxLHs1MzM6MX0sWXVlKSxnKCJqYXZhLmlvIiwiUHJpbnRTdHJlYW0iLDg3OCk7ZnVuY3Rpb24gTjUoZSxuLHIsdCl7dmFyIG87bz1lLnN0cmluZy5sZW5ndGgscj5vP3I9bzpIZShuLHIrMSksZS5zdHJpbmc9WWEoZS5zdHJpbmcsMCxuKSsoIiIrdCkrX0IoZS5zdHJpbmcscil9ZnVuY3Rpb24gQTUoZSxuKXtyZXR1cm4gWWEoZS5zdHJpbmcsMCxuKX1mdW5jdGlvbiB5QyhlKXt0aGlzLnN0cmluZz1lfXAoNDI3LDEsezQ4NDoxfSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RyaW5nfSxnKCJqYXZhLmxhbmciLCJBYnN0cmFjdFN0cmluZ0J1aWxkZXIiLDQyNyk7ZnVuY3Rpb24gR0koZSl7SW8uY2FsbCh0aGlzLGUpfXAoNTM4LDYzLEt1LEdJKSxnKCJqYXZhLmxhbmciLCJBcml0aG1ldGljRXhjZXB0aW9uIiw1MzgpO2Z1bmN0aW9uIEQkKCl7Q18uY2FsbCh0aGlzKX1mdW5jdGlvbiBubyhlKXtJby5jYWxsKHRoaXMsZSl9cCg3Nyw2MyxpNixEJCxubyksZygiamF2YS5sYW5nIiwiSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiIsNzcpO2Z1bmN0aW9uIEYkKCl7RCQuY2FsbCh0aGlzKX1mdW5jdGlvbiB6JChlKXtuby5jYWxsKHRoaXMsZSl9cCgzMzMsNzcsezM6MSwzMzM6MSwxMDM6MSw3NzoxLDYzOjEsODI6MX0sRiQseiQpLGcoImphdmEubGFuZyIsIkFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiIsMzMzKTtmdW5jdGlvbiBMNSgpe0NfLmNhbGwodGhpcyl9ZnVuY3Rpb24gS3VlKGUpe0lvLmNhbGwodGhpcyxlKX1wKDUzNyw2MyxLdSxMNSxLdWUpLGcoImphdmEubGFuZyIsIkFycmF5U3RvcmVFeGNlcHRpb24iLDUzNyk7ZnVuY3Rpb24gazUoZSl7YXVlLmNhbGwodGhpcyxlKX1mdW5jdGlvbiBuWmUoZSxuKXtsdWUuY2FsbCh0aGlzLGUsbil9cCgyOTYsODIsaWllLGs1KSxnKCJqYXZhLmxhbmciLCJFcnJvciIsMjk2KTtmdW5jdGlvbiAkJCgpe2l1ZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIEIkKGUpe25aZS5jYWxsKHRoaXMsZT09bnVsbD8ibnVsbCI6dm8oZSksTChlLDgyKT9hKGUsODIpOm51bGwpfXAoMjAwLDI5NixpaWUsJCQsQiQpLGcoImphdmEubGFuZyIsIkFzc2VydGlvbkVycm9yIiwyMDApO2Z1bmN0aW9uIHplKCl7emU9RixTMD0hMSxveT0hMH1mdW5jdGlvbiBhZShlKXtyZXR1cm4gVmUoZSksZX1mdW5jdGlvbiByWmUoZSxuKXtyZXR1cm4gdFplKChWZShlKSxlKSwoVmUobiksbikpfWZ1bmN0aW9uIFh1ZShlKXtyZXR1cm4gVmUoZSksZT8xMjMxOjEyMzd9ZnVuY3Rpb24gdFplKGUsbil7cmV0dXJuIHplKCksZT09bj8wOmU/MTotMX1mdW5jdGlvbiB3QyhlLG4pe3JldHVybiB6ZSgpLHV0KGUpP2xCKGUseG4obikpOnFkKGUpP081KGUsJChuKSk6VmQoZSk/clplKGUsaWUobikpOmUuY29tcGFyZVRvXzAobil9R2llPXszOjEsNDg1OjEsMzQ6MX07dmFyIFMwLG95LEFyPWcoImphdmEubGFuZyIsIkJvb2xlYW4iLDQ4NSk7ZnVuY3Rpb24gUWQoZSl7aWYoSCQ9PW51bGwmJihIJD1uZXcgUmVnRXhwKCJeXFxzKlsrLV0/KE5hTnxJbmZpbml0eXwoKFxcZCtcXC4/XFxkKil8KFxcLlxcZCspKShbZUVdWystXT9cXGQrKT9bZERmRl0/KVxccyokIikpLCFIJC50ZXN0KGUpKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytlKyciJykpO3JldHVybiBwYXJzZUZsb2F0KGUpfWZ1bmN0aW9uIEFhKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKGU9PW51bGwpdGhyb3cgYihuZXcgdHUoIm51bGwiKSk7Zm9yKGk9ZS5sZW5ndGgscz1pPjAmJihIZSgwLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQoMCk9PTQ1fHwoSGUoMCxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KDApPT00MykpPzE6MCx0PXM7dDxpO3QrKylpZihRdWUoKEhlKHQsZS5sZW5ndGgpLGUuY2hhckNvZGVBdCh0KSkpPT0tMSl0aHJvdyBiKG5ldyB0dSgnRm9yIGlucHV0IHN0cmluZzogIicrZSsnIicpKTtpZih1PXBhcnNlSW50KGUsMTApLG89dTxuLGlzTmFOKHUpKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytlKyciJykpO2lmKG98fHU+cil0aHJvdyBiKG5ldyB0dSgnRm9yIGlucHV0IHN0cmluZzogIicrZSsnIicpKTtyZXR1cm4gdX1mdW5jdGlvbiBISShlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmO2lmKGU9PW51bGwpdGhyb3cgYihuZXcgdHUoIm51bGwiKSk7aWYoXz1lLGk9ZS5sZW5ndGgsYz0hMSxpPjAmJihuPShIZSgwLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQoMCkpLChuPT00NXx8bj09NDMpJiYoZT0oSGUoMSxlLmxlbmd0aCsxKSxlLnN1YnN0cigxKSksLS1pLGM9bj09NDUpKSxpPT0wKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytfKyciJykpO2Zvcig7ZS5sZW5ndGg+MCYmKEhlKDAsZS5sZW5ndGgpLGUuY2hhckNvZGVBdCgwKT09NDgpOyllPShIZSgxLGUubGVuZ3RoKzEpLGUuc3Vic3RyKDEpKSwtLWk7aWYoaT4oX2NlKCksZGNlKVsxMF0pdGhyb3cgYihuZXcgdHUoJ0ZvciBpbnB1dCBzdHJpbmc6ICInK18rJyInKSk7Zm9yKG89MDtvPGk7bysrKWlmKFF1ZSgoSGUobyxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KG8pKSk9PS0xKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytfKyciJykpO2ZvcihmPTAscz1yQlsxMF0sZD1NNVsxMF0sdT1QYyh0QlsxMF0pLHI9ITAsdD1pJXMsdD4wJiYoZj0tcGFyc2VJbnQoKGd0KDAsdCxlLmxlbmd0aCksZS5zdWJzdHIoMCx0KSksMTApLGU9KEhlKHQsZS5sZW5ndGgrMSksZS5zdWJzdHIodCkpLGktPXQscj0hMSk7aT49czspe2lmKHQ9cGFyc2VJbnQoKGd0KDAscyxlLmxlbmd0aCksZS5zdWJzdHIoMCxzKSksMTApLGU9KEhlKHMsZS5sZW5ndGgrMSksZS5zdWJzdHIocykpLGktPXMscilyPSExO2Vsc2V7aWYoVm8oZix1KTwwKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytfKyciJykpO2Y9QXQoZixkKX1mPWhsKGYsdCl9aWYoVm8oZiwwKT4wKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytfKyciJykpO2lmKCFjJiYoZj1QYyhmKSxWbyhmLDApPDApKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytfKyciJykpO3JldHVybiBmfWZ1bmN0aW9uIEckKGUpe3JldHVybiBxZChlKT8oVmUoZSksZSk6ZS5kb3VibGVWYWx1ZSgpfXAoMjQyLDEsezM6MSwyNDI6MX0pO3ZhciBIJDtnKCJqYXZhLmxhbmciLCJOdW1iZXIiLDI0Mik7ZnVuY3Rpb24gb1plKGUsbil7cmV0dXJuIGUudmFsdWVfMC1uLnZhbHVlXzB9ZnVuY3Rpb24gSnVlKGUpe3RoaXMudmFsdWVfMD1lfXAoMjIyLDI0Mix7MzoxLDIyMjoxLDM0OjEsMjQyOjF9LEp1ZSksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gb1plKHRoaXMsYShuLDIyMikpfSxsLmRvdWJsZVZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDIyMikmJmEobiwyMjIpLnZhbHVlXzA9PXRoaXMudmFsdWVfMH0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIiIrdGhpcy52YWx1ZV8wfSxsLnZhbHVlXzA9MDt2YXIgdWg9ZygiamF2YS5sYW5nIiwiQnl0ZSIsMjIyKTtmdW5jdGlvbiBadWUoKXtadWU9RixVJD1CKHVoLFgsMjIyLDI1NiwwLDEpfWZ1bmN0aW9uIEVDKGUpe1p1ZSgpO3ZhciBuLHI7cmV0dXJuIG49ZSsxMjgscj1VJFtuXSwhciYmKHI9VSRbbl09bmV3IEp1ZShlKSkscn12YXIgVSQ7ZnVuY3Rpb24gaVplKGUsbil7cmV0dXJuIGUudmFsdWVfMC1uLnZhbHVlXzB9ZnVuY3Rpb24gVyQoZSl7dGhpcy52YWx1ZV8wPWV9ZnVuY3Rpb24gUXVlKGUpe3JldHVybiBlPj00OCYmZTw0OCtTLk1hdGgubWluKDEwLDEwKT9lLTQ4OmU+PTk3JiZlPDk3P2UtOTcrMTA6ZT49NjUmJmU8NjU/ZS02NSsxMDotMX1mdW5jdGlvbiB2QyhlKXt2YXIgbjtyZXR1cm4gZTwxMjg/KGVjZSgpLG49ViRbZV0sIW4mJihuPVYkW2VdPW5ldyBXJChlKSksbik6bmV3IFckKGUpfXAoMTgwLDEsezM6MSwxODA6MSwzNDoxfSxXJCksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gaVplKHRoaXMsYShuLDE4MCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTgwKSYmYShuLDE4MCkudmFsdWVfMD09dGhpcy52YWx1ZV8wfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnZhbHVlXzApfSxsLnZhbHVlXzA9MDt2YXIgaiQsRjI9ZygiamF2YS5sYW5nIiwiQ2hhcmFjdGVyIiwxODApO2Z1bmN0aW9uIGVjZSgpe2VjZT1GLFYkPUIoRjIsWCwxODAsMTI4LDAsMSl9dmFyIFYkO2Z1bmN0aW9uIG5jZSgpe0NfLmNhbGwodGhpcyl9ZnVuY3Rpb24gaXkoZSl7SW8uY2FsbCh0aGlzLGUpfXAoMjEyLDYzLHszOjEsMjEyOjEsMTAzOjEsNjM6MSw4MjoxfSxuY2UsaXkpLGcoImphdmEubGFuZyIsIkNsYXNzQ2FzdEV4Y2VwdGlvbiIsMjEyKTtmdW5jdGlvbiBPNShlLG4pe3JldHVybiBpcigoVmUoZSksZSksKFZlKG4pLG4pKX1mdW5jdGlvbiBSKGUpe3JldHVybiBWZShlKSxlfWZ1bmN0aW9uIHJjZShlLG4pe3JldHVybiBWZShlKSxEKGUpPT09RChuKX1mdW5jdGlvbiBTQyhlKXtyZXR1cm4gVmUoZSksZX1mdW5jdGlvbiBjaChlKXtyZXR1cm4gS3IoKFZlKGUpLGUpKX1mdW5jdGlvbiBhWmUoZSl7cmV0dXJuIEtyKChWZShlKSxlKSl9ZnVuY3Rpb24gbFplKGUpe3JldHVybiIiKyhWZShlKSxlKX1mdW5jdGlvbiBpcihlLG4pe3JldHVybiBlPG4/LTE6ZT5uPzE6ZT09bj9lPT0wP2lyKDEvZSwxL24pOjA6aXNOYU4oZSk/aXNOYU4obik/MDoxOi0xfWZ1bmN0aW9uIFVJKGUpe3JldHVybiFpc05hTihlKSYmIWlzRmluaXRlKGUpfUhpZT17MzoxLDM0OjEsMzQ1OjEsMjQyOjF9O3ZhciAkcj1nKCJqYXZhLmxhbmciLCJEb3VibGUiLDM0NSk7ZnVuY3Rpb24gc1plKGUsbil7cmV0dXJuIGlyKGUudmFsdWVfMCxuLnZhbHVlXzApfWZ1bmN0aW9uIENDKGUpe3RoaXMudmFsdWVfMD1lfWZ1bmN0aW9uIHEkKGUpe3RoaXMudmFsdWVfMD11WmUoZSl9ZnVuY3Rpb24gdVplKGUpe3ZhciBuO3JldHVybiBuPVFkKGUpLG4+MzQwMjgyMzQ2NjM4NTI4ODZlMjI/aHI6bjwtMzQwMjgyMzQ2NjM4NTI4ODZlMjI/VnI6bn1wKDE2MSwyNDIsezM6MSwzNDoxLDE2MToxLDI0MjoxfSxDQyxxJCksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gc1plKHRoaXMsYShuLDE2MSkpfSxsLmRvdWJsZVZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE2MSkmJnJjZSh0aGlzLnZhbHVlXzAsYShuLDE2MSkudmFsdWVfMCl9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBLcih0aGlzLnZhbHVlXzApfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iIit0aGlzLnZhbHVlXzB9LGwudmFsdWVfMD0wO3ZhciBheT1nKCJqYXZhLmxhbmciLCJGbG9hdCIsMTYxKTtmdW5jdGlvbiBUQygpe0NfLmNhbGwodGhpcyl9ZnVuY3Rpb24gR2UoZSl7SW8uY2FsbCh0aGlzLGUpfWZ1bmN0aW9uIHRjZShlKXtsdWUuY2FsbCh0aGlzLCJUaGUgZ2l2ZW4gc3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBmb3JtYXQgZm9yIGluZGl2aWR1YWwgc3BhY2luZ3MuIixlKX1wKDMzLDYzLHszOjEsMTAzOjEsMzM6MSw2MzoxLDgyOjF9LFRDLEdlLHRjZSksZygiamF2YS5sYW5nIiwiSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIiwzMyk7ZnVuY3Rpb24gemkoKXtDXy5jYWxsKHRoaXMpfWZ1bmN0aW9uIHJvKGUpe0lvLmNhbGwodGhpcyxlKX1wKDczLDYzLEt1LHppLHJvKSxnKCJqYXZhLmxhbmciLCJJbGxlZ2FsU3RhdGVFeGNlcHRpb24iLDczKTtmdW5jdGlvbiBZJChlLG4pe3JldHVybiBxbyhlLnZhbHVlXzAsbi52YWx1ZV8wKX1mdW5jdGlvbiBLJChlKXt0aGlzLnZhbHVlXzA9ZX1mdW5jdGlvbiBvY2UoZSl7cmV0dXJuIGUtPWU+PjEmMTQzMTY1NTc2NSxlPShlPj4yJjg1ODk5MzQ1OSkrKGUmODU4OTkzNDU5KSxlPShlPj40KStlJjI1MjY0NTEzNSxlKz1lPj44LGUrPWU+PjE2LGUmNjN9ZnVuY3Rpb24gcW8oZSxuKXtyZXR1cm4gZTxuPy0xOmU+bj8xOjB9ZnVuY3Rpb24gWCQoZSl7dmFyIG47aWYoZTwwKXJldHVybiBidDtpZihlPT0wKXJldHVybiAwO2ZvcihuPXkyOyEobiZlKTtuPj49MSk7cmV0dXJuIG59ZnVuY3Rpb24gYkMoZSl7dmFyIG4scix0O3JldHVybiBlPDA/MDplPT0wPzMyOih0PS0oZT4+MTYpLG49dD4+MTYmMTYscj0xNi1uLGU9ZT4+bix0PWUtMjU2LG49dD4+MTYmOCxyKz1uLGU8PD1uLHQ9ZS1IZCxuPXQ+PjE2JjQscis9bixlPDw9bix0PWUtS3Msbj10Pj4xNiYyLHIrPW4sZTw8PW4sdD1lPj4xNCxuPXQmfih0Pj4xKSxyKzItbil9ZnVuY3Rpb24gSiQoZSl7dmFyIG4scjtpZihlPT0wKXJldHVybiAzMjtmb3Iocj0wLG49MTshKG4mZSk7bjw8PTEpKytyO3JldHVybiByfWZ1bmN0aW9uIGNaZShlKXt2YXIgbjtyZXR1cm4gbj0oYWNlKCksbGNlKSxuW2U+Pj4yOF18bltlPj4yNCYxNV08PDR8bltlPj4yMCYxNV08PDh8bltlPj4xNiYxNV08PDEyfG5bZT4+MTImMTVdPDwxNnxuW2U+PjgmMTVdPDwyMHxuW2U+PjQmMTVdPDwyNHxuW2UmMTVdPDwyOH1mdW5jdGlvbiBMdShlLG4pe2Zvcig7bi0tID4wOyllPWU8PDF8KGU8MD8xOjApO3JldHVybiBlfWZ1bmN0aW9uIEooZSl7dmFyIG4scjtyZXR1cm4gZT4tMTI5JiZlPDEyOD8oaWNlKCksbj1lKzEyOCxyPVokW25dLCFyJiYocj1aJFtuXT1uZXcgSyQoZSkpLHIpOm5ldyBLJChlKX1wKDE3LDI0Mix7MzoxLDM0OjEsMTc6MSwyNDI6MX0sSyQpLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIFkkKHRoaXMsYShuLDE3KSl9LGwuZG91YmxlVmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTcpJiZhKG4sMTcpLnZhbHVlXzA9PXRoaXMudmFsdWVfMH0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIiIrdGhpcy52YWx1ZV8wfSxsLnZhbHVlXzA9MDt2YXIgdnQ9ZygiamF2YS5sYW5nIiwiSW50ZWdlciIsMTcpO2Z1bmN0aW9uIGljZSgpe2ljZT1GLFokPUIodnQsWCwxNywyNTYsMCwxKX12YXIgWiQ7ZnVuY3Rpb24gYWNlKCl7YWNlPUYsbGNlPVAoSShobiwxKSxrbiwyOCwxNSxbMCw4LDQsMTIsMiwxMCw2LDE0LDEsOSw1LDEzLDMsMTEsNywxNV0pfXZhciBsY2U7ZnVuY3Rpb24gX1plKGUsbil7cmV0dXJuIHNjZShlLnZhbHVlXzAsbi52YWx1ZV8wKX1mdW5jdGlvbiBRJChlKXt0aGlzLnZhbHVlXzA9ZX1mdW5jdGlvbiBzY2UoZSxuKXtyZXR1cm4gVm8oZSxuKTwwPy0xOlZvKGUsbik+MD8xOjB9ZnVuY3Rpb24gZFplKGUpe3JldHVybiBTbih2MChlLDMyKSleU24oZSl9ZnVuY3Rpb24gZWMoZSl7dmFyIG4scjtyZXR1cm4gVm8oZSwtMTI5KT4wJiZWbyhlLDEyOCk8MD8odWNlKCksbj1TbihlKSsxMjgscj1lQltuXSwhciYmKHI9ZUJbbl09bmV3IFEkKGUpKSxyKTpuZXcgUSQoZSl9cCgxNjgsMjQyLHszOjEsMzQ6MSwxNjg6MSwyNDI6MX0sUSQpLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIF9aZSh0aGlzLGEobiwxNjgpKX0sbC5kb3VibGVWYWx1ZT1mdW5jdGlvbigpe3JldHVybiBJXyh0aGlzLnZhbHVlXzApfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTY4KSYmVDEoYShuLDE2OCkudmFsdWVfMCx0aGlzLnZhbHVlXzApfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gZFplKHRoaXMudmFsdWVfMCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiIiK0QyKHRoaXMudmFsdWVfMCl9LGwudmFsdWVfMD0wO3ZhciBJMT1nKCJqYXZhLmxhbmciLCJMb25nIiwxNjgpO2Z1bmN0aW9uIHVjZSgpe3VjZT1GLGVCPUIoSTEsWCwxNjgsMjU2LDAsMSl9dmFyIGVCO2Z1bmN0aW9uIG5CKGUsbil7cmV0dXJuIFZvKGUsbik+MD9lOm59ZnVuY3Rpb24gSUMoZSl7cmV0dXJuIGU9PTB8fGlzTmFOKGUpP2U6ZTwwPy0xOjF9cCgyMTQwLDEse30pO2Z1bmN0aW9uIGNjZShlKXtJby5jYWxsKHRoaXMsZSl9cCgxOTA0LDYzLEt1LGNjZSksZygiamF2YS5sYW5nIiwiTmVnYXRpdmVBcnJheVNpemVFeGNlcHRpb24iLDE5MDQpO2Z1bmN0aW9uIF9oKCl7Q18uY2FsbCh0aGlzKX1mdW5jdGlvbiBkaChlKXtJby5jYWxsKHRoaXMsZSl9cCgxNjksNjA3LHszOjEsMTAzOjEsMTY5OjEsNjM6MSw4MjoxfSxfaCxkaCksbC5jcmVhdGVFcnJvcj1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihuKX0sZygiamF2YS5sYW5nIiwiTnVsbFBvaW50ZXJFeGNlcHRpb24iLDE2OSk7ZnVuY3Rpb24gX2NlKCl7X2NlPUY7dmFyIGU7Zm9yKHJCPVAoSShobiwxKSxrbiwyOCwxNSxbLTEsLTEsMzAsMTksMTUsMTMsMTEsMTEsMTAsOSw5LDgsOCw4LDgsNyw3LDcsNyw3LDcsNyw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNV0pLE01PUIoaG4sa24sMjgsMzcsMTUsMSksZGNlPVAoSShobiwxKSxrbiwyOCwxNSxbLTEsLTEsNjMsNDAsMzIsMjgsMjUsMjMsMjEsMjAsMTksMTksMTgsMTgsMTcsMTcsMTYsMTYsMTYsMTUsMTUsMTUsMTUsMTQsMTQsMTQsMTQsMTQsMTQsMTMsMTMsMTMsMTMsMTMsMTMsMTMsMTNdKSx0Qj1CKF9fLGE2LDI4LDM3LDE0LDEpLGU9MjtlPD0zNjtlKyspTTVbZV09S3IoUy5NYXRoLnBvdyhlLHJCW2VdKSksdEJbZV09aEMoalMsTTVbZV0pfXZhciByQixNNSxkY2UsdEI7ZnVuY3Rpb24gdHUoZSl7R2UuY2FsbCh0aGlzLGUpfXAoMTMwLDMzLHszOjEsMTAzOjEsMzM6MSwxMzA6MSw2MzoxLDgyOjF9LHR1KSxnKCJqYXZhLmxhbmciLCJOdW1iZXJGb3JtYXRFeGNlcHRpb24iLDEzMCk7ZnVuY3Rpb24gZlplKGUsbil7cmV0dXJuIGUudmFsdWVfMC1uLnZhbHVlXzB9ZnVuY3Rpb24gb0IoZSl7dGhpcy52YWx1ZV8wPWV9ZnVuY3Rpb24gbHkoZSl7dmFyIG4scjtyZXR1cm4gZT4tMTI5JiZlPDEyOD8oZmNlKCksbj1lKzEyOCxyPWlCW25dLCFyJiYocj1pQltuXT1uZXcgb0IoZSkpLHIpOm5ldyBvQihlKX1wKDE5MSwyNDIsezM6MSwzNDoxLDI0MjoxLDE5MToxfSxvQiksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gZlplKHRoaXMsYShuLDE5MSkpfSxsLmRvdWJsZVZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE5MSkmJmEobiwxOTEpLnZhbHVlXzA9PXRoaXMudmFsdWVfMH0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIiIrdGhpcy52YWx1ZV8wfSxsLnZhbHVlXzA9MDt2YXIgeDE9ZygiamF2YS5sYW5nIiwiU2hvcnQiLDE5MSk7ZnVuY3Rpb24gZmNlKCl7ZmNlPUYsaUI9Qih4MSxYLDE5MSwyNTYsMCwxKX12YXIgaUI7ZnVuY3Rpb24gUjUoZSxuLHIpe3RoaXMuY2xhc3NOYW1lPSJVbmtub3duIix0aGlzLm1ldGhvZE5hbWU9ZSx0aGlzLmZpbGVOYW1lPW4sdGhpcy5saW5lTnVtYmVyPXJ9cCgzMTksMSx7MzoxLDMxOToxfSxSNSksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDMxOSk/KHI9YShuLDMxOSksdGhpcy5saW5lTnVtYmVyPT1yLmxpbmVOdW1iZXImJnRoaXMubWV0aG9kTmFtZT09ci5tZXRob2ROYW1lJiZ0aGlzLmNsYXNzTmFtZT09ci5jbGFzc05hbWUmJnRoaXMuZmlsZU5hbWU9PXIuZmlsZU5hbWUpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4ga0MoUChJKFFyLDEpLE1lLDEsNSxbSih0aGlzLmxpbmVOdW1iZXIpLHRoaXMuY2xhc3NOYW1lLHRoaXMubWV0aG9kTmFtZSx0aGlzLmZpbGVOYW1lXSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc05hbWUrIi4iK3RoaXMubWV0aG9kTmFtZSsiKCIrKHRoaXMuZmlsZU5hbWUhPW51bGw/dGhpcy5maWxlTmFtZToiVW5rbm93biBTb3VyY2UiKSsodGhpcy5saW5lTnVtYmVyPj0wPyI6Iit0aGlzLmxpbmVOdW1iZXI6IiIpKyIpIn0sbC5saW5lTnVtYmVyPTA7dmFyIGFCPWcoImphdmEubGFuZyIsIlN0YWNrVHJhY2VFbGVtZW50IiwzMTkpO2Z1bmN0aW9uIEl0KGUsbil7cmV0dXJuIEhlKG4sZS5sZW5ndGgpLGUuY2hhckNvZGVBdChuKX1mdW5jdGlvbiBsQihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9KFZlKGUpLGUpLHQ9KFZlKG4pLG4pLHI9PXQ/MDpyPHQ/LTE6MX1mdW5jdGlvbiBwY2UoZSl7dmFyIG47cmV0dXJuIG49ZS5sZW5ndGgsVGUoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIi5zdWJzdHIoMjMtbixuKSxlKX1mdW5jdGlvbiBUZShlLG4pe3JldHVybiBWZShlKSxEKGUpPT09RChuKX1mdW5jdGlvbiBXSShlLG4pe3JldHVybiBWZShlKSxuPT1udWxsPyExOlRlKGUsbik/ITA6ZS5sZW5ndGg9PW4ubGVuZ3RoJiZUZShlLnRvTG93ZXJDYXNlKCksbi50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBnY2UoZSxuLHIsdCxvKXtmb3IoO248cjspdFtvKytdPUl0KGUsbisrKX1mdW5jdGlvbiBOYyhlKXt2YXIgbixyO2ZvcihuPTAscj0wO3I8ZS5sZW5ndGg7cisrKW49KG48PDUpLW4rKEhlKHIsZS5sZW5ndGgpLGUuY2hhckNvZGVBdChyKSl8MDtyZXR1cm4gbn1mdW5jdGlvbiBzeShlLG4scil7cmV0dXJuIHNCKGUseGkobikscil9ZnVuY3Rpb24gb3UoZSxuKXtyZXR1cm4gZS5pbmRleE9mKG4pfWZ1bmN0aW9uIHNCKGUsbixyKXtyZXR1cm4gZS5pbmRleE9mKG4scil9ZnVuY3Rpb24gdUIoZSl7cmV0dXJuIFZlKGUpLGV9ZnVuY3Rpb24gakkoZSxuKXtyZXR1cm4gZS5sYXN0SW5kZXhPZihuKX1mdW5jdGlvbiBjQihlLG4scil7cmV0dXJuIGUubGFzdEluZGV4T2YobixyKX1mdW5jdGlvbiBlZihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKHI9bmV3IFJlZ0V4cChuLCJnIiksYz1CKHNlLFgsMiwwLDYsMSksdD0wLF89ZSxpPW51bGw7OylpZih1PXIuZXhlYyhfKSx1PT1udWxsfHxfPT0iIil7Y1t0XT1fO2JyZWFrfWVsc2Ugcz11LmluZGV4LGNbdF09KGd0KDAscyxfLmxlbmd0aCksXy5zdWJzdHIoMCxzKSksXz1ZYShfLHMrdVswXS5sZW5ndGgsXy5sZW5ndGgpLHIubGFzdEluZGV4PTAsaT09XyYmKGNbdF09KGd0KDAsMSxfLmxlbmd0aCksXy5zdWJzdHIoMCwxKSksXz0oSGUoMSxfLmxlbmd0aCsxKSxfLnN1YnN0cigxKSkpLGk9XywrK3Q7aWYoZS5sZW5ndGg+MCl7Zm9yKG89Yy5sZW5ndGg7bz4wJiZjW28tMV09PSIiOyktLW87bzxjLmxlbmd0aCYmKGMubGVuZ3RoPW8pfXJldHVybiBjfWZ1bmN0aW9uIHBaZShlLG4pe3JldHVybiBUZShlLnN1YnN0cigwLG4ubGVuZ3RoKSxuKX1mdW5jdGlvbiBnWmUoZSxuLHIpe3JldHVybiByPj0wJiZUZShlLnN1YnN0cihyLG4ubGVuZ3RoKSxuKX1mdW5jdGlvbiBfQihlLG4pe3JldHVybiBIZShuLGUubGVuZ3RoKzEpLGUuc3Vic3RyKG4pfWZ1bmN0aW9uIFlhKGUsbixyKXtyZXR1cm4gZ3QobixyLGUubGVuZ3RoKSxlLnN1YnN0cihuLHItbil9ZnVuY3Rpb24gVkkoZSl7dmFyIG4scjtyZXR1cm4gcj1lLmxlbmd0aCxuPUIoZmwsWHMsMjgsciwxNSwxKSxnY2UoZSwwLHIsbiwwKSxufWZ1bmN0aW9uIGhjZShlLG4pe3JldHVybiBuPT0oc2soKSxzaygpLHBfZSk/ZS50b0xvY2FsZUxvd2VyQ2FzZSgpOmUudG9Mb3dlckNhc2UoKX1mdW5jdGlvbiBoWmUoZSl7cmV0dXJuIFZlKGUpLGV9ZnVuY3Rpb24gbmYoZSl7dmFyIG4scix0O2ZvcihyPWUubGVuZ3RoLHQ9MDt0PHImJihIZSh0LGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodCk8PTMyKTspKyt0O2ZvcihuPXI7bj50JiYoSGUobi0xLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQobi0xKTw9MzIpOyktLW47cmV0dXJuIHQ+MHx8bjxyPyhndCh0LG4sZS5sZW5ndGgpLGUuc3Vic3RyKHQsbi10KSk6ZX1mdW5jdGlvbiBtWmUoZSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlKX1mdW5jdGlvbiB4aShlKXt2YXIgbixyO3JldHVybiBlPj1GdD8obj1LUysoZS1GdD4+MTAmMTAyMykmenIscj01NjMyMCsoZS1GdCYxMDIzKSZ6cixTdHJpbmcuZnJvbUNoYXJDb2RlKG4pKygiIitTdHJpbmcuZnJvbUNoYXJDb2RlKHIpKSk6U3RyaW5nLmZyb21DaGFyQ29kZShlJnpyKX1mdW5jdGlvbiB6MihlKXtyZXR1cm4gZT09bnVsbD8ibnVsbCI6dm8oZSl9ZnVuY3Rpb24gbWNlKGUpe3JldHVybiBpdShlLDAsZS5sZW5ndGgpfWZ1bmN0aW9uIGl1KGUsbixyKXt2YXIgdCxvLGkscztmb3IoaT1uK3IsZ3QobixpLGUubGVuZ3RoKSxzPSIiLG89bjtvPGk7KXQ9Uy5NYXRoLm1pbihvKzFlNCxpKSxzKz1tWmUoZS5zbGljZShvLHQpKSxvPXQ7cmV0dXJuIHN9VWllPXszOjEsNDg0OjEsMzQ6MSwyOjF9O3ZhciBzZT1nKCJqYXZhLmxhbmciLCJTdHJpbmciLDIpO2Z1bmN0aW9uIHV5KGUsbil7cmV0dXJuIGUuc3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pLGV9ZnVuY3Rpb24geHAoZSxuKXtyZXR1cm4gZS5zdHJpbmcrPW4sZX1mdW5jdGlvbiBENShlLG4pe3JldHVybiBlLnN0cmluZys9bixlfWZ1bmN0aW9uICQyKGUsbil7cmV0dXJuIGUuc3RyaW5nKz0iIituLGV9ZnVuY3Rpb24gSnQoZSxuKXtyZXR1cm4gZS5zdHJpbmcrPSIiK24sZX1mdW5jdGlvbiBBYyhlLG4pe3JldHVybiBlLnN0cmluZys9bixlfWZ1bmN0aW9uIHlaZShlLG4pe3JldHVybiBONShlLG4sbisxLCIiKSxlfWZ1bmN0aW9uIExjKCl7eUMuY2FsbCh0aGlzLCIiKX1mdW5jdGlvbiBCMigpe3lDLmNhbGwodGhpcywiIil9ZnVuY3Rpb24geWwoZSl7eUMuY2FsbCh0aGlzLChWZShlKSxlKSl9cCgxMTEsNDI3LHs0ODQ6MX0sTGMsQjIseWwpLGcoImphdmEubGFuZyIsIlN0cmluZ0J1ZmZlciIsMTExKTtmdW5jdGlvbiB4XyhlLG4pe3JldHVybiBlLnN0cmluZys9U3RyaW5nLmZyb21DaGFyQ29kZShuKSxlfWZ1bmN0aW9uIFAxKGUsbil7cmV0dXJuIGUuc3RyaW5nKz1uLGV9ZnVuY3Rpb24gZEIoZSxuKXtyZXR1cm4gZS5zdHJpbmcrPSIiK24sZX1mdW5jdGlvbiBHMihlLG4pe3JldHVybiBlLnN0cmluZys9IiIrbixlfWZ1bmN0aW9uIHljZShlLG4scix0KXtyZXR1cm4gZS5zdHJpbmcrPSIiK1lhKG49PW51bGw/Im51bGwiOnZvKG4pLHIsdCksZX1mdW5jdGlvbiBlaShlLG4pe3JldHVybiBlLnN0cmluZys9IiIrbixlfWZ1bmN0aW9uIE9uKGUsbil7cmV0dXJuIGUuc3RyaW5nKz0iIituLGV9ZnVuY3Rpb24gd2NlKGUsbil7cmV0dXJuIGUuc3RyaW5nKz1pdShuLDAsbi5sZW5ndGgpLGV9ZnVuY3Rpb24gRWNlKGUsbixyKXtyZXR1cm4gZS5zdHJpbmcrPWl1KG4sMCxyKSxlfWZ1bmN0aW9uIHhDKGUsbixyKXtyZXR1cm4gTjUoZSxuLG4sciksZX1mdW5jdGlvbiBDMCgpe3lDLmNhbGwodGhpcywiIil9ZnVuY3Rpb24gZmgoKXt5Qy5jYWxsKHRoaXMsIiIpfWZ1bmN0aW9uIExhKGUpe3lDLmNhbGwodGhpcywoVmUoZSksZSkpfXAoMTA0LDQyNyx7NDg0OjF9LEMwLGZoLExhKSxnKCJqYXZhLmxhbmciLCJTdHJpbmdCdWlsZGVyIiwxMDQpO2Z1bmN0aW9uIGZCKGUpe25vLmNhbGwodGhpcyxlKX1wKDcwMiw3NyxpNixmQiksZygiamF2YS5sYW5nIiwiU3RyaW5nSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiIsNzAyKTtmdW5jdGlvbiBuYygpe25jPUYsdmNlPW5ldyBZdWV9ZnVuY3Rpb24gWG8oZSxuLHIsdCxvKXtuYygpO3ZhciBpLHMsdSxjLF8sZCxmO2lmKG5IKGUsInNyYyIpLG5IKHIsImRlc3QiKSxmPXdhKGUpLGM9d2EociksZUgoKGYubW9kaWZpZXJzJjQpIT0wLCJzcmNUeXBlIGlzIG5vdCBhbiBhcnJheSIpLGVIKChjLm1vZGlmaWVycyY0KSE9MCwiZGVzdFR5cGUgaXMgbm90IGFuIGFycmF5IiksZD1mLmNvbXBvbmVudFR5cGUscz1jLmNvbXBvbmVudFR5cGUsZUgoZC5tb2RpZmllcnMmMT9kPT1zOihzLm1vZGlmaWVycyYxKT09MCwiQXJyYXkgdHlwZXMgZG9uJ3QgbWF0Y2giKSx3WmUoZSxuLHIsdCxvKSwhKGQubW9kaWZpZXJzJjEpJiZmIT1jKWlmKF89bV8oZSksaT1tXyhyKSxEKGUpPT09RChyKSYmbjx0KWZvcihuKz1vLHU9dCtvO3UtLSA+dDspVHIoaSx1LF9bLS1uXSk7ZWxzZSBmb3IodT10K287dDx1OylUcihpLHQrKyxfW24rK10pO2Vsc2UgcUcoZSxuLHIsdCxvLCEwKX1mdW5jdGlvbiB3WmUoZSxuLHIsdCxvKXt2YXIgaSxzO2lmKHM9ZS5sZW5ndGgsaT1yLmxlbmd0aCxuPDB8fHQ8MHx8bzwwfHxuK28+c3x8dCtvPmkpdGhyb3cgYihuZXcgRCQpfXAoMjE0NSwxLHt9KTt2YXIgdmNlO2Z1bmN0aW9uIFRuKCl7Q18uY2FsbCh0aGlzKX1mdW5jdGlvbiBrYyhlKXtJby5jYWxsKHRoaXMsZSl9cCg0OCw2Myx7MzoxLDEwMzoxLDYzOjEsODI6MSw0ODoxfSxUbixrYyksZygiamF2YS5sYW5nIiwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24iLDQ4KTtmdW5jdGlvbiBTY2UoKXtTY2U9Rjt2YXIgZSxuLHI7Zm9yKG5ldyBQQygxLDApLG5ldyBQQygxMCwwKSxuZXcgUEMoMCwwKSxJY2U9QihGNSxYLDI0NywxMSwwLDEpLFBfPUIoZmwsWHMsMjgsMTAwLDE1LDEpLG1CPVAoSShjdCwxKSxYdCwyOCwxNSxbMSw1LDI1LDEyNSw2MjUsMzEyNSwxNTYyNSw3ODEyNSwzOTA2MjUsMTk1MzEyNSw5NzY1NjI1LDQ4ODI4MTI1LDI0NDE0MDYyNSwxMjIwNzAzMTI1LDYxMDM1MTU2MjUsMzA1MTc1NzgxMjUsMTUyNTg3ODkwNjI1LDc2MjkzOTQ1MzEyNSwzODE0Njk3MjY1NjI1LDE5MDczNDg2MzI4MTI1LDk1MzY3NDMxNjQwNjI1LDQ3NjgzNzE1ODIwMzEyNSwweDg3ODY3ODMyNmVhYzldKSx5Qj1CKGhuLGtuLDI4LG1CLmxlbmd0aCwxNSwxKSx3Qj1QKEkoY3QsMSksWHQsMjgsMTUsWzEsMTAsMTAwLGJjLDFlNCxsNiwxZTYsMWU3LDFlOCxXYiwxZTEwLDFlMTEsMWUxMiwxZTEzLDFlMTQsMWUxNSwxZTE2XSksRUI9QihobixrbiwyOCx3Qi5sZW5ndGgsMTUsMSksdkI9QihGNSxYLDI0NywxMSwwLDEpLGU9MDtlPHZCLmxlbmd0aDtlKyspSWNlW2VdPW5ldyBQQyhlLDApLHZCW2VdPW5ldyBQQygwLGUpLFBfW2VdPTQ4O2Zvcig7ZTxQXy5sZW5ndGg7ZSsrKVBfW2VdPTQ4O2ZvcihyPTA7cjx5Qi5sZW5ndGg7cisrKXlCW3JdPWhCKG1CW3JdKTtmb3Iobj0wO248RUIubGVuZ3RoO24rKylFQltuXT1oQih3QltuXSk7Y3koKX1mdW5jdGlvbiBDY2UoZSxuKXt2YXIgcix0LG8saSxzLHU7cmV0dXJuIG89cEIoZSksdT1wQihuKSxvPT11P2Uuc2NhbGU9PW4uc2NhbGUmJmUuYml0TGVuZ3RoPDU0JiZuLmJpdExlbmd0aDw1ND9lLnNtYWxsVmFsdWU8bi5zbWFsbFZhbHVlPy0xOmUuc21hbGxWYWx1ZT5uLnNtYWxsVmFsdWU/MTowOih0PWUuc2NhbGUtbi5zY2FsZSxyPShlLnByZWNpc2lvbj4wP2UucHJlY2lzaW9uOlMuTWF0aC5mbG9vcigoZS5iaXRMZW5ndGgtMSkqYWllKSsxKS0obi5wcmVjaXNpb24+MD9uLnByZWNpc2lvbjpTLk1hdGguZmxvb3IoKG4uYml0TGVuZ3RoLTEpKmFpZSkrMSkscj50KzE/bzpyPHQtMT8tbzooaT0oIWUuaW50VmFsJiYoZS5pbnRWYWw9QUMoSG8oZS5zbWFsbFZhbHVlKSkpLGUuaW50VmFsKSxzPSghbi5pbnRWYWwmJihuLmludFZhbD1BQyhIbyhuLnNtYWxsVmFsdWUpKSksbi5pbnRWYWwpLHQ8MD9pPVBwKGksJGNlKC10KSk6dD4wJiYocz1QcChzLCRjZSh0KSkpLHhjZShpLHMpKSk6bzx1Py0xOjF9ZnVuY3Rpb24gRVplKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztpZihyPTAscz0wLGk9bi5sZW5ndGgsdT1udWxsLF89bmV3IGZoLHM8aSYmKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKT09NDMpJiYoKytzLCsrcixzPGkmJihIZShzLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQocyk9PTQzfHwoSGUocyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHMpPT00NSkpKSl0aHJvdyBiKG5ldyB0dSgnRm9yIGlucHV0IHN0cmluZzogIicrbisnIicpKTtmb3IoO3M8aSYmKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKSE9NDYpJiYoSGUocyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHMpIT0xMDEpJiYoSGUocyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHMpIT02OSk7KSsrcztpZihfLnN0cmluZys9IiIrWWEobj09bnVsbD8ibnVsbCI6KFZlKG4pLG4pLHIscyksczxpJiYoSGUocyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHMpPT00Nikpe2ZvcigrK3Mscj1zO3M8aSYmKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKSE9MTAxKSYmKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKSE9NjkpOykrK3M7ZS5zY2FsZT1zLXIsXy5zdHJpbmcrPSIiK1lhKG49PW51bGw/Im51bGwiOihWZShuKSxuKSxyLHMpfWVsc2UgZS5zY2FsZT0wO2lmKHM8aSYmKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKT09MTAxfHwoSGUocyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHMpPT02OSkpJiYoKytzLHI9cyxzPGkmJihIZShzLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQocyk9PTQzKSYmKCsrcyxzPGkmJihIZShzLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQocykhPTQ1KSYmKytyKSx1PShndChyLGksbi5sZW5ndGgpLG4uc3Vic3RyKHIsaS1yKSksZS5zY2FsZT1lLnNjYWxlLUFhKHUsYnQscW4pLGUuc2NhbGUhPUtyKGUuc2NhbGUpKSl0aHJvdyBiKG5ldyB0dSgiU2NhbGUgb3V0IG9mIHJhbmdlLiIpKTtpZihjPV8uc3RyaW5nLGMubGVuZ3RoPDE2KXtpZihlLnNtYWxsVmFsdWU9KFNCPT1udWxsJiYoU0I9bmV3IFJlZ0V4cCgiXlsrLV0/XFxkKiQiLCJpIikpLFNCLnRlc3QoYyk/cGFyc2VJbnQoYywxMCk6TmFOKSxpc05hTihlLnNtYWxsVmFsdWUpKXRocm93IGIobmV3IHR1KCdGb3IgaW5wdXQgc3RyaW5nOiAiJytuKyciJykpO2UuYml0TGVuZ3RoPWhCKGUuc21hbGxWYWx1ZSl9ZWxzZSB2WmUoZSxuZXcgVDAoYykpO2ZvcihlLnByZWNpc2lvbj1fLnN0cmluZy5sZW5ndGgsbz0wO288Xy5zdHJpbmcubGVuZ3RoJiYodD1JdChfLnN0cmluZyxvKSwhKHQhPTQ1JiZ0IT00OCkpOysrbyktLWUucHJlY2lzaW9uO2UucHJlY2lzaW9uPT0wJiYoZS5wcmVjaXNpb249MSl9ZnVuY3Rpb24gdlplKGUsbil7dmFyIHI7ZS5pbnRWYWw9bixlLmJpdExlbmd0aD14WmUobiksZS5iaXRMZW5ndGg8NTQmJihlLnNtYWxsVmFsdWU9KHI9bi5udW1iZXJMZW5ndGg+MT9DZGUobi5kaWdpdHNbMF0sbi5kaWdpdHNbMV0pOkNkZShuLmRpZ2l0c1swXSwwKSxJXyhuLnNpZ24+MD9yOlBjKHIpKSkpfWZ1bmN0aW9uIHBCKGUpe3JldHVybiBlLmJpdExlbmd0aDw1ND9lLnNtYWxsVmFsdWU8MD8tMTplLnNtYWxsVmFsdWU+MD8xOjA6KCFlLmludFZhbCYmKGUuaW50VmFsPUFDKEhvKGUuc21hbGxWYWx1ZSkpKSxlLmludFZhbCkuc2lnbn1mdW5jdGlvbiBTWmUoZSl7dmFyIG4scix0LG87aWYodD1CNSgoIWUuaW50VmFsJiYoZS5pbnRWYWw9QUMoSG8oZS5zbWFsbFZhbHVlKSkpLGUuaW50VmFsKSwwKSxlLnNjYWxlPT0wfHxlLmJpdExlbmd0aD09MCYmZS5zbWFsbFZhbHVlIT0tMSYmZS5zY2FsZTwwKXJldHVybiB0O2lmKG49cEIoZSk8MD8xOjAscj1lLnNjYWxlLG89KHQubGVuZ3RoKzErUy5NYXRoLmFicyhLcihlLnNjYWxlKSksbmV3IGZoKSxuPT0xJiYoby5zdHJpbmcrPSItIiksZS5zY2FsZT4wKWlmKHItPXQubGVuZ3RoLW4scj49MCl7Zm9yKG8uc3RyaW5nKz0iMC4iO3I+UF8ubGVuZ3RoO3ItPVBfLmxlbmd0aCl3Y2UobyxQXyk7RWNlKG8sUF8sS3IocikpLE9uKG8sKEhlKG4sdC5sZW5ndGgrMSksdC5zdWJzdHIobikpKX1lbHNlIHI9bi1yLE9uKG8sWWEodCxuLEtyKHIpKSksby5zdHJpbmcrPSIuIixPbihvLF9CKHQsS3IocikpKTtlbHNle2ZvcihPbihvLChIZShuLHQubGVuZ3RoKzEpLHQuc3Vic3RyKG4pKSk7cjwtUF8ubGVuZ3RoO3IrPVBfLmxlbmd0aCl3Y2UobyxQXyk7RWNlKG8sUF8sS3IoLXIpKX1yZXR1cm4gby5zdHJpbmd9ZnVuY3Rpb24gVGNlKGUpe3ZhciBuLHIsdCxvLGk7cmV0dXJuIGUudG9TdHJpbmdJbWFnZSE9bnVsbD9lLnRvU3RyaW5nSW1hZ2U6ZS5iaXRMZW5ndGg8MzI/KGUudG9TdHJpbmdJbWFnZT1rWmUoSG8oZS5zbWFsbFZhbHVlKSxLcihlLnNjYWxlKSksZS50b1N0cmluZ0ltYWdlKToobz1CNSgoIWUuaW50VmFsJiYoZS5pbnRWYWw9QUMoSG8oZS5zbWFsbFZhbHVlKSkpLGUuaW50VmFsKSwwKSxlLnNjYWxlPT0wP286KG49KCFlLmludFZhbCYmKGUuaW50VmFsPUFDKEhvKGUuc21hbGxWYWx1ZSkpKSxlLmludFZhbCkuc2lnbjwwPzI6MSxyPW8ubGVuZ3RoLHQ9LWUuc2NhbGUrci1uLGk9bmV3IEMwLGkuc3RyaW5nKz0iIitvLGUuc2NhbGU+MCYmdD49LTY/dD49MD94QyhpLHItS3IoZS5zY2FsZSksIi4iKTooTjUoaSxuLTEsbi0xLCIwLiIpLHhDKGksbisxLGl1KFBfLDAsLUtyKHQpLTEpKSk6KHItbj49MSYmKHhDKGksbiwiLiIpLCsrcikseEMoaSxyLCJFIiksdD4wJiZ4QyhpLCsrciwiKyIpLHhDKGksKytyLCIiK0QyKEhvKHQpKSkpLGUudG9TdHJpbmdJbWFnZT1pLnN0cmluZyxlLnRvU3RyaW5nSW1hZ2UpKX1mdW5jdGlvbiBQQyhlLG4pe3RoaXMuc2NhbGU9bix0aGlzLmJpdExlbmd0aD1iY2UoZSksdGhpcy5iaXRMZW5ndGg8NTQ/dGhpcy5zbWFsbFZhbHVlPUlfKGUpOnRoaXMuaW50VmFsPShhdSgpLFZvKGUsMCk+PTA/YjAoZSk6VTIoYjAoUGMoZSkpKSl9ZnVuY3Rpb24gZ0IoZSl7U2NlKCksRVplKHRoaXMsZSl9ZnVuY3Rpb24gaEIoZSl7dmFyIG4scjtyZXR1cm4gZT4tMHg4MDAwMDAwMDAwMDAmJmU8MHg4MDAwMDAwMDAwMDA/ZT09MD8wOihuPWU8MCxuJiYoZT0tZSkscj1LcihTLk1hdGguZmxvb3IoUy5NYXRoLmxvZyhlKS8uNjkzMTQ3MTgwNTU5OTQ1MykpLCghbnx8ZSE9Uy5NYXRoLnBvdygyLHIpKSYmKytyLHIpOmJjZShIbyhlKSl9ZnVuY3Rpb24gYmNlKGUpe3ZhciBuO3JldHVybiBWbyhlLDApPDAmJihlPVIkKGUpKSxuPVNuKHYwKGUsMzIpKSw2NC0obiE9MD9iQyhuKTpiQyhTbihlKSkrMzIpfXAoMjQ3LDI0Mix7MzoxLDM0OjEsMjQyOjEsMjQ3OjF9LFBDLGdCKSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBDY2UodGhpcyxhKG4sMjQ3KSl9LGwuZG91YmxlVmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gUWQoVGNlKHRoaXMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdGhpcz09PW4/ITA6TChuLDI0Nyk/KHI9YShuLDI0NyksdGhpcy5zY2FsZT09ci5zY2FsZSYmQ2NlKHRoaXMscik9PTApOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5oYXNoQ29kZV8wIT0wP3RoaXMuaGFzaENvZGVfMDp0aGlzLmJpdExlbmd0aDw1ND8obj1Ibyh0aGlzLnNtYWxsVmFsdWUpLHRoaXMuaGFzaENvZGVfMD1TbihldChuLC0xKSksdGhpcy5oYXNoQ29kZV8wPTMzKnRoaXMuaGFzaENvZGVfMCtTbihldChiMShuLDMyKSwtMSkpLHRoaXMuaGFzaENvZGVfMD0xNyp0aGlzLmhhc2hDb2RlXzArS3IodGhpcy5zY2FsZSksdGhpcy5oYXNoQ29kZV8wKToodGhpcy5oYXNoQ29kZV8wPTE3Kk5jZSh0aGlzLmludFZhbCkrS3IodGhpcy5zY2FsZSksdGhpcy5oYXNoQ29kZV8wKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIFRjZSh0aGlzKX0sbC5iaXRMZW5ndGg9MCxsLmhhc2hDb2RlXzA9MCxsLnByZWNpc2lvbj0wLGwuc2NhbGU9MCxsLnNtYWxsVmFsdWU9MDt2YXIgSWNlLFBfLG1CLHlCLHdCLEVCLHZCLFNCLEY1PWcoImphdmEubWF0aCIsIkJpZ0RlY2ltYWwiLDI0Nyk7ZnVuY3Rpb24gYXUoKXthdT1GO3ZhciBlO2ZvcihxST1uZXcgcmMoMSwxKSx6NT1uZXcgcmMoMSwxMCksVzI9bmV3IHJjKDAsMCksT2NlPW5ldyByYygtMSwxKSxNY2U9UChJKE5wLDEpLFgsOTIsMCxbVzIscUksbmV3IHJjKDEsMiksbmV3IHJjKDEsMyksbmV3IHJjKDEsNCksbmV3IHJjKDEsNSksbmV3IHJjKDEsNiksbmV3IHJjKDEsNyksbmV3IHJjKDEsOCksbmV3IHJjKDEsOSksejVdKSxZST1CKE5wLFgsOTIsMzIsMCwxKSxlPTA7ZTxZSS5sZW5ndGg7ZSsrKVlJW2VdPUJJKE9sKDEsZSksMCk/YjAoT2woMSxlKSk6VTIoYjAoUGMoT2woMSxlKSkpKX1mdW5jdGlvbiB4Y2UoZSxuKXtyZXR1cm4gZS5zaWduPm4uc2lnbj8xOmUuc2lnbjxuLnNpZ24/LTE6ZS5udW1iZXJMZW5ndGg+bi5udW1iZXJMZW5ndGg/ZS5zaWduOmUubnVtYmVyTGVuZ3RoPG4ubnVtYmVyTGVuZ3RoPy1uLnNpZ246ZS5zaWduKmJCKGUuZGlnaXRzLG4uZGlnaXRzLGUubnVtYmVyTGVuZ3RoKX1mdW5jdGlvbiBIMihlKXtmb3IoO2UubnVtYmVyTGVuZ3RoPjAmJmUuZGlnaXRzWy0tZS5udW1iZXJMZW5ndGhdPT0wOyk7ZS5kaWdpdHNbZS5udW1iZXJMZW5ndGgrK109PTAmJihlLnNpZ249MCl9ZnVuY3Rpb24gQ0IoZSxuKXt2YXIgcjtyZXR1cm4gRChlKT09PUQobik/ITA6TChuLDkyKT8ocj1hKG4sOTIpLGUuc2lnbj09ci5zaWduJiZlLm51bWJlckxlbmd0aD09ci5udW1iZXJMZW5ndGgmJkNaZShlLHIuZGlnaXRzKSk6ITF9ZnVuY3Rpb24gQ1plKGUsbil7dmFyIHI7Zm9yKHI9ZS5udW1iZXJMZW5ndGgtMTtyPj0wJiZlLmRpZ2l0c1tyXT09PW5bcl07ci0tKTtyZXR1cm4gcjwwfWZ1bmN0aW9uIFBjZShlKXt2YXIgbjtpZihlLmZpcnN0Tm9uemVyb0RpZ2l0PT0tMil7aWYoZS5zaWduPT0wKW49LTE7ZWxzZSBmb3Iobj0wO2UuZGlnaXRzW25dPT0wO24rKyk7ZS5maXJzdE5vbnplcm9EaWdpdD1ufXJldHVybiBlLmZpcnN0Tm9uemVyb0RpZ2l0fWZ1bmN0aW9uIE5jZShlKXt2YXIgbjtpZihlLmhhc2hDb2RlXzAhPTApcmV0dXJuIGUuaGFzaENvZGVfMDtmb3Iobj0wO248ZS5kaWdpdHMubGVuZ3RoO24rKyllLmhhc2hDb2RlXzA9ZS5oYXNoQ29kZV8wKjMzKyhlLmRpZ2l0c1tuXSYtMSk7cmV0dXJuIGUuaGFzaENvZGVfMD1lLmhhc2hDb2RlXzAqZS5zaWduLGUuaGFzaENvZGVfMH1mdW5jdGlvbiBQcChlLG4pe3JldHVybiBuLnNpZ249PTB8fGUuc2lnbj09MD9XMjooY3koKSxqNShlLG4pKX1mdW5jdGlvbiBVMihlKXtyZXR1cm4gZS5zaWduPT0wP2U6bmV3IE5fKC1lLnNpZ24sZS5udW1iZXJMZW5ndGgsZS5kaWdpdHMpfWZ1bmN0aW9uIE5DKGUsbil7dmFyIHI7aWYobjwwKXRocm93IGIobmV3IEdJKCJOZWdhdGl2ZSBleHBvbmVudCIpKTtpZihuPT0wKXJldHVybiBxSTtpZihuPT0xfHxDQihlLHFJKXx8Q0IoZSxXMikpcmV0dXJuIGU7aWYoIUFjZShlLDApKXtmb3Iocj0xOyFBY2UoZSxyKTspKytyO3JldHVybiBQcChiWmUocipuKSxOQyhUQihlLHIpLG4pKX1yZXR1cm4gJFplKGUsbil9ZnVuY3Rpb24gcGgoZSxuKXtyZXR1cm4gbj09MHx8ZS5zaWduPT0wP2U6bj4wP1JjZShlLG4pOkRjZShlLC1uKX1mdW5jdGlvbiBUQihlLG4pe3JldHVybiBuPT0wfHxlLnNpZ249PTA/ZTpuPjA/RGNlKGUsbik6UmNlKGUsLW4pfWZ1bmN0aW9uIEFjZShlLG4pe3ZhciByLHQsbztpZihuPT0wKXJldHVybihlLmRpZ2l0c1swXSYxKSE9MDtpZihuPDApdGhyb3cgYihuZXcgR0koIk5lZ2F0aXZlIGJpdCBhZGRyZXNzIikpO2lmKG89bj4+NSxvPj1lLm51bWJlckxlbmd0aClyZXR1cm4gZS5zaWduPDA7aWYocj1lLmRpZ2l0c1tvXSxuPTE8PChuJjMxKSxlLnNpZ248MCl7aWYodD1QY2UoZSksbzx0KXJldHVybiExO3Q9PW8/cj0tcjpyPX5yfXJldHVybihyJm4pIT0wfWZ1bmN0aW9uIHJjKGUsbil7YXUoKSxOXy5jYWxsKHRoaXMsZSwxLFAoSShobiwxKSxrbiwyOCwxNSxbbl0pKX1mdW5jdGlvbiBMY2UoZSxuKXtOXy5jYWxsKHRoaXMsMSwyLFAoSShobiwxKSxrbiwyOCwxNSxbZSxuXSkpfWZ1bmN0aW9uIE5fKGUsbixyKXthdSgpLHRoaXMuc2lnbj1lLHRoaXMubnVtYmVyTGVuZ3RoPW4sdGhpcy5kaWdpdHM9cn1mdW5jdGlvbiBrY2UoZSl7YXUoKSxlLmxlbmd0aD09MD8odGhpcy5zaWduPTAsdGhpcy5udW1iZXJMZW5ndGg9MSx0aGlzLmRpZ2l0cz1QKEkoaG4sMSksa24sMjgsMTUsWzBdKSk6KHRoaXMuc2lnbj0xLHRoaXMubnVtYmVyTGVuZ3RoPWUubGVuZ3RoLHRoaXMuZGlnaXRzPWUsSDIodGhpcykpfWZ1bmN0aW9uIFQwKGUpe2F1KCksVFplLmNhbGwodGhpcyxlKX1mdW5jdGlvbiBUWmUoZSl7aWYoVmUoZSksZS5sZW5ndGg9PTApdGhyb3cgYihuZXcgdHUoIlplcm8gbGVuZ3RoIEJpZ0ludGVnZXIiKSk7SVplKHRoaXMsZSl9ZnVuY3Rpb24gYjAoZSl7YXUoKTt2YXIgbixyO3JldHVybiByPVNuKGUpLG49U24odjAoZSwzMikpLG4hPTA/bmV3IExjZShyLG4pOnI+MTB8fHI8MD9uZXcgcmMoMSxyKTpNY2Vbcl19ZnVuY3Rpb24gYlplKGUpe3ZhciBuLHIsdDtyZXR1cm4gZTxZSS5sZW5ndGg/WUlbZV06KHI9ZT4+NSxuPWUmMzEsdD1CKGhuLGtuLDI4LHIrMSwxNSwxKSx0W3JdPTE8PG4sbmV3IE5fKDEscisxLHQpKX1mdW5jdGlvbiBJWmUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKG09bi5sZW5ndGgsYz1tLEhlKDAsbi5sZW5ndGgpLG4uY2hhckNvZGVBdCgwKT09NDU/KGY9LTEsaD0xLC0tbSk6KGY9MSxoPTApLGk9KCQ1KCksemNlKVsxMF0sbz1tL2l8MCx2PW0laSx2IT0wJiYrK28sdT1CKGhuLGtuLDI4LG8sMTUsMSkscj1GY2VbOF0scz0wLHk9aCsodj09MD9pOnYpLEU9aDtFPGM7RT15LHk9RStpKXQ9QWEoKGd0KEUseSxuLmxlbmd0aCksbi5zdWJzdHIoRSx5LUUpKSxidCxxbiksXz0oY3koKSxJQih1LHUscyxyKSksXys9TVplKHUscyx0KSx1W3MrK109XztkPXMsZS5zaWduPWYsZS5udW1iZXJMZW5ndGg9ZCxlLmRpZ2l0cz11LEgyKGUpfWZ1bmN0aW9uIEFDKGUpe3JldHVybiBhdSgpLFZvKGUsMCk+PTA/YjAoZSk6VTIoYjAoUGMoZSkpKX1wKDkyLDI0Mix7MzoxLDM0OjEsMjQyOjEsOTI6MX0scmMsTGNlLE5fLGtjZSxUMCksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4geGNlKHRoaXMsYShuLDkyKSl9LGwuZG91YmxlVmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gUWQoQjUodGhpcywwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIENCKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBOY2UodGhpcyl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBCNSh0aGlzLDApfSxsLmZpcnN0Tm9uemVyb0RpZ2l0PS0yLGwuaGFzaENvZGVfMD0wLGwubnVtYmVyTGVuZ3RoPTAsbC5zaWduPTA7dmFyIE9jZSxxSSxNY2UsejUsWUksVzIsTnA9ZygiamF2YS5tYXRoIiwiQmlnSW50ZWdlciIsOTIpO2Z1bmN0aW9uIHhaZShlKXt2YXIgbixyLHQ7cmV0dXJuIGUuc2lnbj09MD8wOihuPWUubnVtYmVyTGVuZ3RoPDw1LHI9ZS5kaWdpdHNbZS5udW1iZXJMZW5ndGgtMV0sZS5zaWduPDAmJih0PVBjZShlKSx0PT1lLm51bWJlckxlbmd0aC0xJiYoLS1yLHI9cnwwKSksbi09YkMociksbil9ZnVuY3Rpb24gUmNlKGUsbil7dmFyIHIsdCxvLGk7cmV0dXJuIHI9bj4+NSxuJj0zMSxvPWUubnVtYmVyTGVuZ3RoK3IrKG49PTA/MDoxKSx0PUIoaG4sa24sMjgsbywxNSwxKSxQWmUodCxlLmRpZ2l0cyxyLG4pLGk9bmV3IE5fKGUuc2lnbixvLHQpLEgyKGkpLGl9ZnVuY3Rpb24gUFplKGUsbixyLHQpe3ZhciBvLGkscztpZih0PT0wKVhvKG4sMCxlLHIsZS5sZW5ndGgtcik7ZWxzZSBmb3Iocz0zMi10LGVbZS5sZW5ndGgtMV09MCxpPWUubGVuZ3RoLTE7aT5yO2ktLSllW2ldfD1uW2ktci0xXT4+PnMsZVtpLTFdPW5baS1yLTFdPDx0O2ZvcihvPTA7bzxyO28rKyllW29dPTB9ZnVuY3Rpb24gTlplKGUsbixyKXt2YXIgdCxvLGk7Zm9yKHQ9MCxvPTA7bzxyO28rKylpPW5bb10sZVtvXT1pPDwxfHQsdD1pPj4+MzE7dCE9MCYmKGVbcl09dCl9ZnVuY3Rpb24gRGNlKGUsbil7dmFyIHIsdCxvLGkscztpZih0PW4+PjUsbiY9MzEsdD49ZS5udW1iZXJMZW5ndGgpcmV0dXJuIGUuc2lnbjwwPyhhdSgpLE9jZSk6KGF1KCksVzIpO2lmKGk9ZS5udW1iZXJMZW5ndGgtdCxvPUIoaG4sa24sMjgsaSsxLDE1LDEpLEFaZShvLGksZS5kaWdpdHMsdCxuKSxlLnNpZ248MCl7Zm9yKHI9MDtyPHQmJmUuZGlnaXRzW3JdPT0wO3IrKyk7aWYocjx0fHxuPjAmJmUuZGlnaXRzW3JdPDwzMi1uKXtmb3Iocj0wO3I8aSYmb1tyXT09LTE7cisrKW9bcl09MDtyPT1pJiYrK2ksKytvW3JdfX1yZXR1cm4gcz1uZXcgTl8oZS5zaWduLGksbyksSDIocyksc31mdW5jdGlvbiBBWmUoZSxuLHIsdCxvKXt2YXIgaSxzLHU7Zm9yKGk9ITAscz0wO3M8dDtzKyspaT1pJnJbc109PTA7aWYobz09MClYbyhyLHQsZSwwLG4pLHM9bjtlbHNle2Zvcih1PTMyLW8saT1pJnJbc108PHU9PTAscz0wO3M8bi0xO3MrKyllW3NdPXJbcyt0XT4+Pm98cltzK3QrMV08PHU7ZVtzXT1yW3MrdF0+Pj5vLCsrc31yZXR1cm4gaX1mdW5jdGlvbiAkNSgpeyQ1PUYsRmNlPVAoSShobiwxKSxrbiwyOCwxNSxbYnQsMTE2MjI2MTQ2Nyx5MiwxMjIwNzAzMTI1LDM2Mjc5NzA1NiwxOTc3MzI2NzQzLHkyLDM4NzQyMDQ4OSxXYiwyMTQzNTg4ODEsNDI5OTgxNjk2LDgxNTczMDcyMSwxNDc1Nzg5MDU2LDE3MDg1OTM3NSwyNjg0MzU0NTYsNDEwMzM4NjczLDYxMjIyMDAzMiw4OTM4NzE3MzksMTI4ZTcsMTgwMTA4ODU0MSwxMTMzNzk5MDQsMTQ4MDM1ODg5LDE5MTEwMjk3NiwyNDQxNDA2MjUsMzA4OTE1Nzc2LDM4NzQyMDQ4OSw0ODE4OTAzMDQsNTk0ODIzMzIxLDcyOWU2LDg4NzUwMzY4MSx5MiwxMjkxNDY3OTY5LDE1NDQ4MDQ0MTYsMTgzODI2NTYyNSw2MDQ2NjE3Nl0pLHpjZT1QKEkoaG4sMSksa24sMjgsMTUsWy0xLC0xLDMxLDE5LDE1LDEzLDExLDExLDEwLDksOSw4LDgsOCw4LDcsNyw3LDcsNyw3LDcsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDVdKX1mdW5jdGlvbiBMWmUoZSl7dmFyIG4scix0O3JldHVybiBWbyhlLDApPj0wPyhyPWhDKGUsV2IpLHQ9bUMoZSxXYikpOihuPXYwKGUsMSkscj1oQyhuLDVlOCksdD1tQyhuLDVlOCksdD1OdChPbCh0LDEpLGV0KGUsMSkpKSxscyhPbCh0LDMyKSxldChyLFV0KSl9ZnVuY3Rpb24ga1plKGUsbil7JDUoKTt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2lmKGM9Vm8oZSwwKTwwLGMmJihlPVBjKGUpKSxWbyhlLDApPT0wKXN3aXRjaChuKXtjYXNlIDA6cmV0dXJuIjAiO2Nhc2UgMTpyZXR1cm4iMC4wIjtjYXNlIDI6cmV0dXJuIjAuMDAiO2Nhc2UgMzpyZXR1cm4iMC4wMDAiO2Nhc2UgNDpyZXR1cm4iMC4wMDAwIjtjYXNlIDU6cmV0dXJuIjAuMDAwMDAiO2Nhc2UgNjpyZXR1cm4iMC4wMDAwMDAiO2RlZmF1bHQ6cmV0dXJuIG09bmV3IEMwLG48MD9tLnN0cmluZys9IjBFKyI6bS5zdHJpbmcrPSIwRSIsbS5zdHJpbmcrPW49PWJ0PyIyMTQ3NDgzNjQ4IjoiIistbixtLnN0cmluZ31kPTE4LGY9QihmbCxYcywyOCxkKzEsMTUsMSkscj1kLEU9ZTtkbyBfPUUsRT1oQyhFLDEwKSxmWy0tcl09U24oTnQoNDgsaGwoXyxBdChFLDEwKSkpKSZ6cjt3aGlsZShWbyhFLDApIT0wKTtpZihvPWhsKGhsKGhsKGQsciksbiksMSksbj09MClyZXR1cm4gYyYmKGZbLS1yXT00NSksaXUoZixyLGQtcik7aWYobj4wJiZWbyhvLC02KT49MCl7aWYoVm8obywwKT49MCl7Zm9yKGk9citTbihvKSx1PWQtMTt1Pj1pO3UtLSlmW3UrMV09Zlt1XTtyZXR1cm4gZlsrK2ldPTQ2LGMmJihmWy0tcl09NDUpLGl1KGYscixkLXIrMSl9Zm9yKHM9Mjt4NShzLE50KFBjKG8pLDEpKTtzKyspZlstLXJdPTQ4O3JldHVybiBmWy0tcl09NDYsZlstLXJdPTQ4LGMmJihmWy0tcl09NDUpLGl1KGYscixkLXIpfXJldHVybiB5PXIrMSx0PWQsaD1uZXcgZmgsYyYmKGguc3RyaW5nKz0iLSIpLHQteT49MT8oeF8oaCxmW3JdKSxoLnN0cmluZys9Ii4iLGguc3RyaW5nKz1pdShmLHIrMSxkLXItMSkpOmguc3RyaW5nKz1pdShmLHIsZC1yKSxoLnN0cmluZys9IkUiLFZvKG8sMCk+MCYmKGguc3RyaW5nKz0iKyIpLGguc3RyaW5nKz0iIitEMihvKSxoLnN0cmluZ31mdW5jdGlvbiBCNShlLG4peyQ1KCk7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lO2lmKGs9ZS5zaWduLGQ9ZS5udW1iZXJMZW5ndGgsbz1lLmRpZ2l0cyxrPT0wKXN3aXRjaChuKXtjYXNlIDA6cmV0dXJuIjAiO2Nhc2UgMTpyZXR1cm4iMC4wIjtjYXNlIDI6cmV0dXJuIjAuMDAiO2Nhc2UgMzpyZXR1cm4iMC4wMDAiO2Nhc2UgNDpyZXR1cm4iMC4wMDAwIjtjYXNlIDU6cmV0dXJuIjAuMDAwMDAiO2Nhc2UgNjpyZXR1cm4iMC4wMDAwMDAiO2RlZmF1bHQ6cmV0dXJuIHg9bmV3IEMwLHguc3RyaW5nKz0iMEUiLHguc3RyaW5nKz0tbix4LnN0cmluZ31pZihFPWQqMTArMSs3LHY9QihmbCxYcywyOCxFKzEsMTUsMSkscj1FLGQ9PTEpaWYoaT1vWzBdLGk8MCl7bmU9ZXQoaSxVdCk7ZG8gZj1uZSxuZT1oQyhuZSwxMCksdlstLXJdPTQ4K1NuKGhsKGYsQXQobmUsMTApKSkmenI7d2hpbGUoVm8obmUsMCkhPTApfWVsc2V7bmU9aTtkbyBmPW5lLG5lPW5lLzEwfDAsdlstLXJdPTQ4KyhmLW5lKjEwKSZ6cjt3aGlsZShuZSE9MCl9ZWxzZXtNPUIoaG4sa24sMjgsZCwxNSwxKSxxPWQsWG8obywwLE0sMCxxKTtlOmZvcig7Oyl7Zm9yKEE9MCx1PXEtMTt1Pj0wO3UtLSlIPU50KE9sKEEsMzIpLGV0KE1bdV0sVXQpKSxtPUxaZShIKSxNW3VdPVNuKG0pLEE9U24oYjEobSwzMikpO3k9U24oQSksaD1yO2RvIHZbLS1yXT00OCt5JTEwJnpyO3doaWxlKCh5PXkvMTB8MCkhPTAmJnIhPTApO2Zvcih0PTktaCtyLHM9MDtzPHQmJnI+MDtzKyspdlstLXJdPTQ4O2ZvcihjPXEtMTtNW2NdPT0wO2MtLSlpZihjPT0wKWJyZWFrIGU7cT1jKzF9Zm9yKDt2W3JdPT00ODspKytyfXJldHVybiBfPWs8MCxfJiYodlstLXJdPTQ1KSxpdSh2LHIsRS1yKX12YXIgRmNlLHpjZTtmdW5jdGlvbiBHNShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKHM9ZS5zaWduLGM9bi5zaWduLHM9PTApcmV0dXJuIG47aWYoYz09MClyZXR1cm4gZTtpZihpPWUubnVtYmVyTGVuZ3RoLHU9bi5udW1iZXJMZW5ndGgsaSt1PT0yKXJldHVybiByPWV0KGUuZGlnaXRzWzBdLFV0KSx0PWV0KG4uZGlnaXRzWzBdLFV0KSxzPT1jPyhkPU50KHIsdCkseT1TbihkKSxtPVNuKHYwKGQsMzIpKSxtPT0wP25ldyByYyhzLHkpOm5ldyBOXyhzLDIsUChJKGhuLDEpLGtuLDI4LDE1LFt5LG1dKSkpOihhdSgpLEJJKHM8MD9obCh0LHIpOmhsKHIsdCksMCk/YjAoczwwP2hsKHQscik6aGwocix0KSk6VTIoYjAoUGMoczwwP2hsKHQscik6aGwocix0KSkpKSk7aWYocz09YyloPXMsZj1pPj11P0g1KGUuZGlnaXRzLGksbi5kaWdpdHMsdSk6SDUobi5kaWdpdHMsdSxlLmRpZ2l0cyxpKTtlbHNle2lmKG89aSE9dT9pPnU/MTotMTpiQihlLmRpZ2l0cyxuLmRpZ2l0cyxpKSxvPT0wKXJldHVybiBhdSgpLFcyO289PTE/KGg9cyxmPVc1KGUuZGlnaXRzLGksbi5kaWdpdHMsdSkpOihoPWMsZj1XNShuLmRpZ2l0cyx1LGUuZGlnaXRzLGkpKX1yZXR1cm4gXz1uZXcgTl8oaCxmLmxlbmd0aCxmKSxIMihfKSxffWZ1bmN0aW9uIEg1KGUsbixyLHQpe3ZhciBvO3JldHVybiBvPUIoaG4sa24sMjgsbisxLDE1LDEpLE9aZShvLGUsbixyLHQpLG99ZnVuY3Rpb24gT1plKGUsbixyLHQsbyl7dmFyIGkscztpZihpPU50KGV0KG5bMF0sVXQpLGV0KHRbMF0sVXQpKSxlWzBdPVNuKGkpLGk9YjEoaSwzMikscj49byl7Zm9yKHM9MTtzPG87cysrKWk9TnQoaSxOdChldChuW3NdLFV0KSxldCh0W3NdLFV0KSkpLGVbc109U24oaSksaT1iMShpLDMyKTtmb3IoO3M8cjtzKyspaT1OdChpLGV0KG5bc10sVXQpKSxlW3NdPVNuKGkpLGk9YjEoaSwzMil9ZWxzZXtmb3Iocz0xO3M8cjtzKyspaT1OdChpLE50KGV0KG5bc10sVXQpLGV0KHRbc10sVXQpKSksZVtzXT1TbihpKSxpPWIxKGksMzIpO2Zvcig7czxvO3MrKylpPU50KGksZXQodFtzXSxVdCkpLGVbc109U24oaSksaT1iMShpLDMyKX1WbyhpLDApIT0wJiYoZVtzXT1TbihpKSl9ZnVuY3Rpb24gYkIoZSxuLHIpe3ZhciB0O2Zvcih0PXItMTt0Pj0wJiZlW3RdPT09blt0XTt0LS0pO3JldHVybiB0PDA/MDp4NShldChlW3RdLFV0KSxldChuW3RdLFV0KSk/LTE6MX1mdW5jdGlvbiBNWmUoZSxuLHIpe3ZhciB0LG87Zm9yKHQ9ZXQocixVdCksbz0wO1ZvKHQsMCkhPTAmJm88bjtvKyspdD1OdCh0LGV0KGVbb10sVXQpKSxlW29dPVNuKHQpLHQ9YjEodCwzMik7cmV0dXJuIFNuKHQpfWZ1bmN0aW9uIFU1KGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGY7aWYocz1lLnNpZ24sYz1uLnNpZ24sYz09MClyZXR1cm4gZTtpZihzPT0wKXJldHVybiBuLnNpZ249PTA/bjpuZXcgTl8oLW4uc2lnbixuLm51bWJlckxlbmd0aCxuLmRpZ2l0cyk7aWYoaT1lLm51bWJlckxlbmd0aCx1PW4ubnVtYmVyTGVuZ3RoLGkrdT09MilyZXR1cm4gcj1ldChlLmRpZ2l0c1swXSxVdCksdD1ldChuLmRpZ2l0c1swXSxVdCksczwwJiYocj1QYyhyKSksYzwwJiYodD1QYyh0KSksYXUoKSxCSShobChyLHQpLDApP2IwKGhsKHIsdCkpOlUyKGIwKFBjKGhsKHIsdCkpKSk7aWYobz1pIT11P2k+dT8xOi0xOmJCKGUuZGlnaXRzLG4uZGlnaXRzLGkpLG89PS0xKWY9LWMsZD1zPT1jP1c1KG4uZGlnaXRzLHUsZS5kaWdpdHMsaSk6SDUobi5kaWdpdHMsdSxlLmRpZ2l0cyxpKTtlbHNlIGlmKGY9cyxzPT1jKXtpZihvPT0wKXJldHVybiBhdSgpLFcyO2Q9VzUoZS5kaWdpdHMsaSxuLmRpZ2l0cyx1KX1lbHNlIGQ9SDUoZS5kaWdpdHMsaSxuLmRpZ2l0cyx1KTtyZXR1cm4gXz1uZXcgTl8oZixkLmxlbmd0aCxkKSxIMihfKSxffWZ1bmN0aW9uIFc1KGUsbixyLHQpe3ZhciBvO3JldHVybiBvPUIoaG4sa24sMjgsbiwxNSwxKSxSWmUobyxlLG4scix0KSxvfWZ1bmN0aW9uIFJaZShlLG4scix0LG8pe3ZhciBpLHM7Zm9yKGk9MCxzPTA7czxvO3MrKylpPU50KGksaGwoZXQobltzXSxVdCksZXQodFtzXSxVdCkpKSxlW3NdPVNuKGkpLGk9YjEoaSwzMik7Zm9yKDtzPHI7cysrKWk9TnQoaSxldChuW3NdLFV0KSksZVtzXT1TbihpKSxpPWIxKGksMzIpfWZ1bmN0aW9uIGN5KCl7Y3k9Rjt2YXIgZSxuO2ZvcihnaD1CKE5wLFgsOTIsMzIsMCwxKSxqMj1CKE5wLFgsOTIsMzIsMCwxKSxlPTEsbj0wO248PTE4O24rKylnaFtuXT0oYXUoKSxWbyhlLDApPj0wP2IwKGUpOlUyKGIwKFBjKGUpKSkpLGoyW25dPUJJKE9sKGUsbiksMCk/YjAoT2woZSxuKSk6VTIoYjAoUGMoT2woZSxuKSkpKSxlPUF0KGUsNSk7Zm9yKDtuPGoyLmxlbmd0aDtuKyspZ2hbbl09UHAoZ2hbbi0xXSxnaFsxXSksajJbbl09UHAoajJbbi0xXSwoYXUoKSx6NSkpfWZ1bmN0aW9uIGo1KGUsbil7Y3koKTt2YXIgcix0LG8saSxzLHUsYyxfLGQ7cmV0dXJuIG4ubnVtYmVyTGVuZ3RoPmUubnVtYmVyTGVuZ3RoJiYodT1lLGU9bixuPXUpLG4ubnVtYmVyTGVuZ3RoPDYzP3paZShlLG4pOihzPShlLm51bWJlckxlbmd0aCYtMik8PDQsXz1UQihlLHMpLGQ9VEIobixzKSx0PVU1KGUscGgoXyxzKSksbz1VNShuLHBoKGQscykpLGM9ajUoXyxkKSxyPWo1KHQsbyksaT1qNShVNShfLHQpLFU1KG8sZCkpLGk9RzUoRzUoaSxjKSxyKSxpPXBoKGkscyksYz1waChjLHM8PDEpLEc1KEc1KGMsaSkscikpfWZ1bmN0aW9uIERaZShlLG4scix0LG8pe249PTB8fHQ9PTB8fChuPT0xP29bdF09SUIobyxyLHQsZVswXSk6dD09MT9vW25dPUlCKG8sZSxuLHJbMF0pOkZaZShlLHIsbyxuLHQpKX1mdW5jdGlvbiBGWmUoZSxuLHIsdCxvKXt2YXIgaSxzLHUsYztpZihEKGUpPT09RChuKSYmdD09byl7QmNlKGUsdCxyKTtyZXR1cm59Zm9yKHU9MDt1PHQ7dSsrKXtmb3Iocz0wLGk9ZVt1XSxjPTA7YzxvO2MrKylzPU50KE50KEF0KGV0KGksVXQpLGV0KG5bY10sVXQpKSxldChyW3UrY10sVXQpKSxldChTbihzKSxVdCkpLHJbdStjXT1TbihzKSxzPXYwKHMsMzIpO3JbdStvXT1TbihzKX19ZnVuY3Rpb24gSUIoZSxuLHIsdCl7Y3koKTt2YXIgbyxpO2ZvcihvPTAsaT0wO2k8cjtpKyspbz1OdChBdChldChuW2ldLFV0KSxldCh0LFV0KSksZXQoU24obyksVXQpKSxlW2ldPVNuKG8pLG89djAobywzMik7cmV0dXJuIFNuKG8pfWZ1bmN0aW9uIHpaZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGg7cmV0dXJuIHQ9ZS5udW1iZXJMZW5ndGgsaT1uLm51bWJlckxlbmd0aCx1PXQraSxjPWUuc2lnbiE9bi5zaWduPy0xOjEsdT09Mj8oZD1BdChldChlLmRpZ2l0c1swXSxVdCksZXQobi5kaWdpdHNbMF0sVXQpKSxoPVNuKGQpLGY9U24odjAoZCwzMikpLGY9PTA/bmV3IHJjKGMsaCk6bmV3IE5fKGMsMixQKEkoaG4sMSksa24sMjgsMTUsW2gsZl0pKSk6KHI9ZS5kaWdpdHMsbz1uLmRpZ2l0cyxzPUIoaG4sa24sMjgsdSwxNSwxKSxEWmUocix0LG8saSxzKSxfPW5ldyBOXyhjLHUscyksSDIoXyksXyl9ZnVuY3Rpb24gJFplKGUsbil7Y3koKTt2YXIgcix0O2Zvcih0PShhdSgpLHFJKSxyPWU7bj4xO24+Pj0xKW4mMSYmKHQ9UHAodCxyKSksci5udW1iZXJMZW5ndGg9PTE/cj1QcChyLHIpOnI9bmV3IGtjZShCY2Uoci5kaWdpdHMsci5udW1iZXJMZW5ndGgsQihobixrbiwyOCxyLm51bWJlckxlbmd0aDw8MSwxNSwxKSkpO3JldHVybiB0PVBwKHQsciksdH1mdW5jdGlvbiAkY2UoZSl7Y3koKTt2YXIgbixyLHQsbztpZihuPUtyKGUpLGU8ajIubGVuZ3RoKXJldHVybiBqMltuXTtpZihlPD01MClyZXR1cm4gTkMoKGF1KCksejUpLG4pO2lmKGU8PWJjKXJldHVybiBwaChOQyhnaFsxXSxuKSxuKTtpZihlPjFlNil0aHJvdyBiKG5ldyBHSSgicG93ZXIgb2YgdGVuIHRvbyBiaWciKSk7aWYoZTw9cW4pcmV0dXJuIHBoKE5DKGdoWzFdLG4pLG4pO2Zvcih0PU5DKGdoWzFdLHFuKSxvPXQscj1IbyhlLXFuKSxuPUtyKGUlcW4pO1ZvKHIscW4pPjA7KW89UHAobyx0KSxyPWhsKHIscW4pO2ZvcihvPVBwKG8sTkMoZ2hbMV0sbikpLG89cGgobyxxbikscj1IbyhlLXFuKTtWbyhyLHFuKT4wOylvPXBoKG8scW4pLHI9aGwocixxbik7cmV0dXJuIG89cGgobyxuKSxvfWZ1bmN0aW9uIEJjZShlLG4scil7dmFyIHQsbyxpLHMsdTtmb3IoaT0wO2k8bjtpKyspe2Zvcih0PTAsdT1pKzE7dTxuO3UrKyl0PU50KE50KEF0KGV0KGVbaV0sVXQpLGV0KGVbdV0sVXQpKSxldChyW2krdV0sVXQpKSxldChTbih0KSxVdCkpLHJbaSt1XT1Tbih0KSx0PXYwKHQsMzIpO3JbaStuXT1Tbih0KX1mb3IoTlplKHIscixuPDwxKSx0PTAsbz0wLHM9MDtvPG47KytvLHMrKyl0PU50KE50KEF0KGV0KGVbb10sVXQpLGV0KGVbb10sVXQpKSxldChyW3NdLFV0KSksZXQoU24odCksVXQpKSxyW3NdPVNuKHQpLHQ9djAodCwzMiksKytzLHQ9TnQodCxldChyW3NdLFV0KSkscltzXT1Tbih0KSx0PXYwKHQsMzIpO3JldHVybiByfXZhciBnaCxqMjtmdW5jdGlvbiB5aShlLG4pe3JldHVybiB1dChuKT9WNShlLG4pOiEhanQoZS5oYXNoQ29kZU1hcCxuKX1mdW5jdGlvbiBHY2UoZSxuLHIpe3ZhciB0LG87Zm9yKG89ci5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspaWYodD1hKG8ubmV4dF8xKCksNDQpLGUuZXF1YWxzXzEobix0LmdldFZhbHVlKCkpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEtlKGUsbil7cmV0dXJuIHV0KG4pP25pKGUsbik6X28oanQoZS5oYXNoQ29kZU1hcCxuKSl9ZnVuY3Rpb24gbmkoZSxuKXtyZXR1cm4gbj09bnVsbD9fbyhqdChlLmhhc2hDb2RlTWFwLG51bGwpKTpyRShlLnN0cmluZ01hcCxuKX1mdW5jdGlvbiBWNShlLG4pe3JldHVybiBuPT1udWxsPyEhanQoZS5oYXNoQ29kZU1hcCxudWxsKTpDUWUoZS5zdHJpbmdNYXAsbil9ZnVuY3Rpb24gQm4oZSxuLHIpe3JldHVybiB1dChuKT90byhlLG4scik6ZGkoZS5oYXNoQ29kZU1hcCxuLHIpfWZ1bmN0aW9uIHRvKGUsbixyKXtyZXR1cm4gbj09bnVsbD9kaShlLmhhc2hDb2RlTWFwLG51bGwscik6azEoZS5zdHJpbmdNYXAsbixyKX1mdW5jdGlvbiBoaChlLG4pe3JldHVybiB1dChuKT9uPT1udWxsP3JHKGUuaGFzaENvZGVNYXAsbnVsbCk6UTBlKGUuc3RyaW5nTWFwLG4pOnJHKGUuaGFzaENvZGVNYXAsbil9ZnVuY3Rpb24gWmkoZSl7ZS5oYXNoQ29kZU1hcD1uZXcgSzBlKGUpLGUuc3RyaW5nTWFwPW5ldyBlX2UoZSksKytlLm1vZENvdW50fWZ1bmN0aW9uIFYyKGUpe3JldHVybiBlLmhhc2hDb2RlTWFwLnNpemVfMCtlLnN0cmluZ01hcC5zaXplXzB9ZnVuY3Rpb24gSGNlKGUsbil7SEMoZT49MCwiTmVnYXRpdmUgaW5pdGlhbCBjYXBhY2l0eSIpLEhDKG4+PTAsIk5vbi1wb3NpdGl2ZSBsb2FkIGZhY3RvciIpLFppKHRoaXMpfXAoNDk4LDIwNjUsaDEpLGwuY2xlYXJfMD1mdW5jdGlvbigpe1ppKHRoaXMpfSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiB5aSh0aGlzLG4pfSxsLmNvbnRhaW5zVmFsdWU9ZnVuY3Rpb24obil7cmV0dXJuIEdjZSh0aGlzLG4sdGhpcy5zdHJpbmdNYXApfHxHY2UodGhpcyxuLHRoaXMuaGFzaENvZGVNYXApfSxsLmVudHJ5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEFfKHRoaXMpfSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiBLZSh0aGlzLG4pfSxsLnB1dD1mdW5jdGlvbihuLHIpe3JldHVybiBCbih0aGlzLG4scil9LGwucmVtb3ZlXzA9ZnVuY3Rpb24obil7cmV0dXJuIGhoKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFYyKHRoaXMpfSxsLm1vZENvdW50PTAsZygiamF2YS51dGlsIiwiQWJzdHJhY3RIYXNoTWFwIiw0OTgpO2Z1bmN0aW9uIFVjZShlLG4pe3JldHVybiBMKG4sNDQpP2s2KGUudGhpcyQwMSxhKG4sNDQpKTohMX1mdW5jdGlvbiBBXyhlKXt0aGlzLnRoaXMkMDE9ZX1wKDI2NyxTcyxEaSxBXyksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gVWNlKHRoaXMsbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgTF8odGhpcy50aGlzJDAxKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gVWNlKHRoaXMsbik/KHI9YShuLDQ0KS5nZXRLZXkoKSx0aGlzLnRoaXMkMDEucmVtb3ZlXzAociksITApOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuc2l6ZV8xKCl9LGcoImphdmEudXRpbCIsIkFic3RyYWN0SGFzaE1hcC9FbnRyeVNldCIsMjY3KTtmdW5jdGlvbiB4QihlKXtyZXR1cm4gZS5jdXJyZW50Lmhhc05leHRfMCgpPyEwOmUuY3VycmVudCE9ZS5zdHJpbmdNYXBFbnRyaWVzPyExOihlLmN1cnJlbnQ9bmV3IHRHKGUudGhpcyQwMS5oYXNoQ29kZU1hcCksZS5jdXJyZW50Lmhhc05leHRfMCgpKX1mdW5jdGlvbiBOMShlKXt2YXIgbjtyZXR1cm4gRGsoZS50aGlzJDAxLm1vZENvdW50LGUubGFzdE1vZENvdW50KSxybihlLmhhc05leHQpLGUubGFzdD1lLmN1cnJlbnQsbj1hKGUuY3VycmVudC5uZXh0XzEoKSw0NCksZS5oYXNOZXh0PXhCKGUpLG59ZnVuY3Rpb24gV2NlKGUpe2ZmKCEhZS5sYXN0KSxEayhlLnRoaXMkMDEubW9kQ291bnQsZS5sYXN0TW9kQ291bnQpLGUubGFzdC5yZW1vdmUoKSxlLmxhc3Q9bnVsbCxlLmhhc05leHQ9eEIoZSksZS5sYXN0TW9kQ291bnQ9ZS50aGlzJDAxLm1vZENvdW50fWZ1bmN0aW9uIExfKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMuc3RyaW5nTWFwRW50cmllcz1uZXcgb0codGhpcy50aGlzJDAxLnN0cmluZ01hcCksdGhpcy5jdXJyZW50PXRoaXMuc3RyaW5nTWFwRW50cmllcyx0aGlzLmhhc05leHQ9eEIodGhpcyksdGhpcy5sYXN0TW9kQ291bnQ9dGhpcy50aGlzJDAxLm1vZENvdW50fXAoMjY4LDEsc3QsTF8pLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBOMSh0aGlzKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNOZXh0fSxsLnJlbW92ZT1mdW5jdGlvbigpe1djZSh0aGlzKX0sbC5oYXNOZXh0PSExLGwubGFzdE1vZENvdW50PTAsZygiamF2YS51dGlsIiwiQWJzdHJhY3RIYXNoTWFwL0VudHJ5U2V0SXRlcmF0b3IiLDI2OCk7ZnVuY3Rpb24gcTUoZSl7cmV0dXJuIGUuaTxlLnRoaXMkMDFfMC5zaXplXzEoKX1mdW5jdGlvbiBQQihlKXtyZXR1cm4gcm4oZS5pPGUudGhpcyQwMV8wLnNpemVfMSgpKSxlLnRoaXMkMDFfMC5nZXRfMChlLmxhc3Q9ZS5pKyspfWZ1bmN0aW9uIEVhKGUpe2ZmKGUubGFzdCE9LTEpLGUudGhpcyQwMV8wLnJlbW92ZV8yKGUubGFzdCksZS5pPWUubGFzdCxlLmxhc3Q9LTF9ZnVuY3Rpb24gcTIoZSl7dGhpcy50aGlzJDAxXzA9ZX1wKDQyNiwxLHN0LHEyKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gcTUodGhpcyl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIFBCKHRoaXMpfSxsLnJlbW92ZT1mdW5jdGlvbigpe0VhKHRoaXMpfSxsLmk9MCxsLmxhc3Q9LTEsZygiamF2YS51dGlsIiwiQWJzdHJhY3RMaXN0L0l0ZXJhdG9ySW1wbCIsNDI2KTtmdW5jdGlvbiByZihlLG4pe2UudGhpcyQwMS5hZGRfMyhlLmksbiksKytlLmksZS5sYXN0PS0xfWZ1bmN0aW9uIHB0KGUsbil7dGhpcy50aGlzJDAxPWUscTIuY2FsbCh0aGlzLGUpLGRmKG4sZS5zaXplXzEoKSksdGhpcy5pPW59cCg5OCw0MjYsQ3UscHQpLGwucmVtb3ZlPWZ1bmN0aW9uKCl7RWEodGhpcyl9LGwuYWRkXzE9ZnVuY3Rpb24obil7cmYodGhpcyxuKX0sbC5oYXNQcmV2aW91cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmk+MH0sbC5uZXh0SW5kZXhfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLml9LGwucHJldmlvdXNfMD1mdW5jdGlvbigpe3JldHVybiBybih0aGlzLmk+MCksdGhpcy50aGlzJDAxLmdldF8wKHRoaXMubGFzdD0tLXRoaXMuaSl9LGwucHJldmlvdXNJbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmktMX0sbC5zZXRfMT1mdW5jdGlvbihuKXtmZih0aGlzLmxhc3QhPS0xKSx0aGlzLnRoaXMkMDEuc2V0XzIodGhpcy5sYXN0LG4pfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdExpc3QvTGlzdEl0ZXJhdG9ySW1wbCIsOTgpO2Z1bmN0aW9uIE9jKGUsbixyKXtTZGUobixyLGUuc2l6ZV8xKCkpLHRoaXMud3JhcHBlZD1lLHRoaXMuZnJvbUluZGV4PW4sdGhpcy5zaXplXzA9ci1ufXAoMjQ0LDU2LEhtLE9jKSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7ZGYobix0aGlzLnNpemVfMCksdGhpcy53cmFwcGVkLmFkZF8zKHRoaXMuZnJvbUluZGV4K24sciksKyt0aGlzLnNpemVfMH0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gQWUobix0aGlzLnNpemVfMCksdGhpcy53cmFwcGVkLmdldF8wKHRoaXMuZnJvbUluZGV4K24pfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBBZShuLHRoaXMuc2l6ZV8wKSxyPXRoaXMud3JhcHBlZC5yZW1vdmVfMih0aGlzLmZyb21JbmRleCtuKSwtLXRoaXMuc2l6ZV8wLHJ9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gQWUobix0aGlzLnNpemVfMCksdGhpcy53cmFwcGVkLnNldF8yKHRoaXMuZnJvbUluZGV4K24scil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wfSxsLmZyb21JbmRleD0wLGwuc2l6ZV8wPTAsZygiamF2YS51dGlsIiwiQWJzdHJhY3RMaXN0L1N1Ykxpc3QiLDI0NCk7ZnVuY3Rpb24ga18oZSl7dGhpcy50aGlzJDAxPWV9cCgyNjYsU3MsRGksa18pLGwuY2xlYXJfMD1mdW5jdGlvbigpe3RoaXMudGhpcyQwMS5jbGVhcl8wKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGhpcyQwMS5jb250YWluc0tleShuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy50aGlzJDAxLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCksbmV3IEtJKG4pfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRoaXMkMDEuY29udGFpbnNLZXkobik/KHRoaXMudGhpcyQwMS5yZW1vdmVfMChuKSwhMCk6ITF9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzEoKX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3RNYXAvMSIsMjY2KTtmdW5jdGlvbiBLSShlKXt0aGlzLnZhbCRvdXRlckl0ZXIyPWV9cCg1NDEsMSxzdCxLSSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49YSh0aGlzLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxuLmdldEtleSgpfSxsLnJlbW92ZT1mdW5jdGlvbigpe3RoaXMudmFsJG91dGVySXRlcjIucmVtb3ZlKCl9LGcoImphdmEudXRpbCIsIkFic3RyYWN0TWFwLzEvMSIsNTQxKTtmdW5jdGlvbiB0YyhlKXt0aGlzLnRoaXMkMDE9ZX1wKDIzMSwzMSxHZCx0YyksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aGlzJDAxLmNvbnRhaW5zVmFsdWUobil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMudGhpcyQwMS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyB0ZihuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLnNpemVfMSgpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdE1hcC8yIiwyMzEpO2Z1bmN0aW9uIHRmKGUpe3RoaXMudmFsJG91dGVySXRlcjI9ZX1wKDMwMSwxLHN0LHRmKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWwkb3V0ZXJJdGVyMi5oYXNOZXh0XzAoKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1hKHRoaXMudmFsJG91dGVySXRlcjIubmV4dF8xKCksNDQpLG4uZ2V0VmFsdWUoKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aGlzLnZhbCRvdXRlckl0ZXIyLnJlbW92ZSgpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdE1hcC8yLzEiLDMwMSk7ZnVuY3Rpb24gTkIoZSxuKXt2YXIgcjtyZXR1cm4gcj1lLnZhbHVlXzAsZS52YWx1ZV8wPW4scn1wKDQ5NCwxLHs0OTQ6MSw0NDoxfSksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDQ0KT8ocj1hKG4sNDQpLFVvKHRoaXMua2V5LHIuZ2V0S2V5KCkpJiZVbyh0aGlzLnZhbHVlXzAsci5nZXRWYWx1ZSgpKSk6ITF9LGwuZ2V0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIGtwKHRoaXMua2V5KV5rcCh0aGlzLnZhbHVlXzApfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiBOQih0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXkrIj0iK3RoaXMudmFsdWVfMH0sZygiamF2YS51dGlsIiwiQWJzdHJhY3RNYXAvQWJzdHJhY3RFbnRyeSIsNDk0KTtmdW5jdGlvbiBYSShlLG4pe3RoaXMua2V5PWUsdGhpcy52YWx1ZV8wPW59cCgzOTcsNDk0LHs0OTQ6MSwzOTc6MSw0NDoxfSxYSSksZygiamF2YS51dGlsIiwiQWJzdHJhY3RNYXAvU2ltcGxlRW50cnkiLDM5NykscCgyMDgyLDEsczYpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIEwobiw0NCk/KHI9YShuLDQ0KSxVbyh0aGlzLmdldEtleSgpLHIuZ2V0S2V5KCkpJiZVbyh0aGlzLmdldFZhbHVlKCksci5nZXRWYWx1ZSgpKSk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBrcCh0aGlzLmdldEtleSgpKV5rcCh0aGlzLmdldFZhbHVlKCkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRLZXkoKSsiPSIrdGhpcy5nZXRWYWx1ZSgpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdE1hcEVudHJ5IiwyMDgyKTtmdW5jdGlvbiBqY2UoZSxuKXt2YXIgcix0O3JldHVybiByPW4uZ2V0S2V5KCksdD1lLmdldEVudHJ5KHIpLCEhdCYmVW8odC52YWx1ZV8wLG4uZ2V0VmFsdWUoKSl9ZnVuY3Rpb24gQUIoZSxuKXt2YXIgcjtyZXR1cm4gcj1uLCEhZS5nZXRFbnRyeShyKX1mdW5jdGlvbiBWY2UoZSl7aWYoIWUpdGhyb3cgYihuZXcgUG8pO3JldHVybiBlLmtleX1wKDIwOTAsMjA2NSx6RiksbC5jZWlsaW5nS2V5PWZ1bmN0aW9uKG4pe3JldHVybiBPNih0aGlzLmdldENlaWxpbmdFbnRyeShuKSl9LGwuY29udGFpbnNFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gamNlKHRoaXMsbil9LGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIEFCKHRoaXMsbil9LGwuZW50cnlTZXRfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgWTUodGhpcyl9LGwuZmlyc3RLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gVmNlKHRoaXMuZ2V0Rmlyc3RFbnRyeSgpKX0sbC5mbG9vcktleT1mdW5jdGlvbihuKXtyZXR1cm4gTzYodGhpcy5nZXRGbG9vckVudHJ5KG4pKX0sbC5nZXRfMz1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1uLF9vKHRoaXMuZ2V0RW50cnkocikpfSxsLmhpZ2hlcktleT1mdW5jdGlvbihuKXtyZXR1cm4gTzYodGhpcy5nZXRIaWdoZXJFbnRyeShuKSl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHFjZSh0aGlzKX0sbC5sYXN0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIFZjZSh0aGlzLmdldExhc3RFbnRyeSgpKX0sbC5sb3dlcktleT1mdW5jdGlvbihuKXtyZXR1cm4gTzYodGhpcy5nZXRMb3dlckVudHJ5KG4pKX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3ROYXZpZ2FibGVNYXAiLDIwOTApO2Z1bmN0aW9uIFk1KGUpe3RoaXMudGhpcyQwMV8wPWV9cCg2MjksU3MsRGksWTUpLGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw0NCkmJmpjZSh0aGlzLnRoaXMkMDFfMCxhKG4sNDQpKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMV8wLmVudHJ5SXRlcmF0b3JfMCgpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sNDQpPyhyPWEobiw0NCksdGhpcy50aGlzJDAxXzAucmVtb3ZlRW50cnkocikpOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDFfMC5zaXplXzEoKX0sZygiamF2YS51dGlsIiwiQWJzdHJhY3ROYXZpZ2FibGVNYXAvRW50cnlTZXQiLDYyOSk7ZnVuY3Rpb24gcWNlKGUpe3RoaXMubWFwXzA9ZX1wKDExNDYsU3MsJEYscWNlKSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGx4KHRoaXMpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLm1hcF8wLmNsZWFyXzAoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gQUIodGhpcy5tYXBfMCxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5tYXBfMC5lbnRyeVNldF8wKCkudGhpcyQwMV8wLmVudHJ5SXRlcmF0b3JfMCgpLG5ldyBZY2Uobil9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7cmV0dXJuIEFCKHRoaXMubWFwXzAsbik/KHRoaXMubWFwXzAucmVtb3ZlXzAobiksITApOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLnNpemVfMSgpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdE5hdmlnYWJsZU1hcC9OYXZpZ2FibGVLZXlTZXQiLDExNDYpO2Z1bmN0aW9uIFljZShlKXt0aGlzLnZhbCRlbnRyeUl0ZXJhdG9yMj1lfXAoMTE0NywxLHN0LFljZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHE1KHRoaXMudmFsJGVudHJ5SXRlcmF0b3IyLml0ZXIpfSxsLm5leHRfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPUpfZSh0aGlzLnZhbCRlbnRyeUl0ZXJhdG9yMiksbi5nZXRLZXkoKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtaX2UodGhpcy52YWwkZW50cnlJdGVyYXRvcjIpfSxnKCJqYXZhLnV0aWwiLCJBYnN0cmFjdE5hdmlnYWJsZU1hcC9OYXZpZ2FibGVLZXlTZXQvMSIsMTE0NykscCgyMTAzLDMxLEdkKSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiB4aChFeSh0aGlzLG4pLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKSwhMH0sbC5hZGRBbGw9ZnVuY3Rpb24obil7cmV0dXJuIFZlKG4pLEhDKG4hPXRoaXMsIkNhbid0IGFkZCBhIHF1ZXVlIHRvIGl0c2VsZiIpLGZ0KHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe2Zvcig7ZGsodGhpcykhPW51bGw7KTt9LGcoImphdmEudXRpbCIsIkFic3RyYWN0UXVldWUiLDIxMDMpO2Z1bmN0aW9uIEkwKGUsbil7VmUobiksZS5oZWFkPWUuaGVhZC0xJmUuYXJyYXkubGVuZ3RoLTEsVHIoZS5hcnJheSxlLmhlYWQsbiksSmNlKGUpfWZ1bmN0aW9uIExCKGUsbil7VmUobiksVHIoZS5hcnJheSxlLnRhaWwsbiksZS50YWlsPWUudGFpbCsxJmUuYXJyYXkubGVuZ3RoLTEsSmNlKGUpfWZ1bmN0aW9uIGtCKGUpe2UuaGVhZCE9ZS50YWlsJiYoZS5hcnJheT1CKFFyLE1lLDEsOCw1LDEpLGUuaGVhZD0wLGUudGFpbD0wKX1mdW5jdGlvbiBLY2UoZSxuKXtpZihuPT1udWxsKXJldHVybiExO2Zvcig7ZS5jdXJyZW50SW5kZXghPWUuZmVuY2U7KWlmKFluKG4sSkkoZSkpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIFhjZShlLG4scil7dmFyIHQsbyxpO2ZvcihpPWUuYXJyYXkubGVuZ3RoLTEsbz1lLmhlYWQsdD0wO3Q8cjtvPW8rMSZpLCsrdClUcihuLHQsZS5hcnJheVtvXSl9ZnVuY3Rpb24gSmNlKGUpe3ZhciBuLHIsdDtlLmhlYWQ9PWUudGFpbCYmKHQ9ZS5hcnJheS5sZW5ndGgscj1YJChTLk1hdGgubWF4KDgsdCkpPDwxLGUuaGVhZCE9MD8obj1EbChlLmFycmF5LHIpLFhjZShlLG4sdCksZS5hcnJheT1uLGUuaGVhZD0wKTpfZihlLmFycmF5LHIpLGUudGFpbD10KX1mdW5jdGlvbiBZMihlKXtyZXR1cm4gZS5oZWFkPT1lLnRhaWx9ZnVuY3Rpb24gSzIoZSl7dmFyIG47cmV0dXJuIG49ZS5hcnJheVtlLmhlYWRdLG49PW51bGw/bnVsbDooVHIoZS5hcnJheSxlLmhlYWQsbnVsbCksZS5oZWFkPWUuaGVhZCsxJmUuYXJyYXkubGVuZ3RoLTEsbil9ZnVuY3Rpb24gQlplKGUpe3ZhciBuO3JldHVybiBuPWUuYXJyYXlbZS50YWlsLTEmZS5hcnJheS5sZW5ndGgtMV0sbj09bnVsbD9udWxsOihlLnRhaWw9ZS50YWlsLTEmZS5hcnJheS5sZW5ndGgtMSxUcihlLmFycmF5LGUudGFpbCxudWxsKSxuKX1mdW5jdGlvbiBHWmUoZSxuKXtyZXR1cm4gS2NlKGUsbik/KGUwZShlKSwhMCk6ITF9ZnVuY3Rpb24gSFplKGUsbil7dmFyIHIsdCxvLGk7cmV0dXJuIHQ9ZS5hcnJheS5sZW5ndGgtMSxyPW4tZS5oZWFkJnQsaT1lLnRhaWwtbiZ0LG89ZS50YWlsLWUuaGVhZCZ0LFFjZShyPG8pLHI+PWk/KFdaZShlLG4pLC0xKTooalplKGUsbiksMSl9ZnVuY3Rpb24gbWgoZSl7dmFyIG47cmV0dXJuIG49SzIoZSkscm4obiE9bnVsbCksbn1mdW5jdGlvbiBVWmUoZSl7dmFyIG47cmV0dXJuIG49QlplKGUpLHJuKG4hPW51bGwpLG59ZnVuY3Rpb24gV1plKGUsbil7dmFyIHIsdDtmb3Iocj1lLmFycmF5Lmxlbmd0aC0xLGUudGFpbD1lLnRhaWwtMSZyO24hPWUudGFpbDspdD1uKzEmcixUcihlLmFycmF5LG4sZS5hcnJheVt0XSksbj10O1RyKGUuYXJyYXksZS50YWlsLG51bGwpfWZ1bmN0aW9uIGpaZShlLG4pe3ZhciByLHQ7Zm9yKHI9ZS5hcnJheS5sZW5ndGgtMTtuIT1lLmhlYWQ7KXQ9bi0xJnIsVHIoZS5hcnJheSxuLGUuYXJyYXlbdF0pLG49dDtUcihlLmFycmF5LGUuaGVhZCxudWxsKSxlLmhlYWQ9ZS5oZWFkKzEmcn1mdW5jdGlvbiBBcCgpe3RoaXMuYXJyYXk9QihRcixNZSwxLDgsNSwxKX1mdW5jdGlvbiBaY2UoZSl7dGhpcy5hcnJheT1CKFFyLE1lLDEsWCQoUy5NYXRoLm1heCg4LGUpKTw8MSw1LDEpfWZ1bmN0aW9uIFFjZShlKXtpZighZSl0aHJvdyBiKG5ldyBYYSl9cCgzMTAsMzEsezQ6MSwyMDoxLDMxOjEsMTY6MX0sQXAsWmNlKSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiBMQih0aGlzLG4pLCEwfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXtrQih0aGlzKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gS2NlKG5ldyBYMih0aGlzKSxuKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIFkyKHRoaXMpfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFgyKHRoaXMpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBHWmUobmV3IFgyKHRoaXMpLG4pfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMuYXJyYXkubGVuZ3RoLTF9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywyNzIpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj10aGlzLnRhaWwtdGhpcy5oZWFkJnRoaXMuYXJyYXkubGVuZ3RoLTEsbi5sZW5ndGg8ciYmKG49U3gobmV3IEFycmF5KHIpLG4pKSxYY2UodGhpcyxuLHIpLG4ubGVuZ3RoPnImJlRyKG4scixudWxsKSxufSxsLmhlYWQ9MCxsLnRhaWw9MCxnKCJqYXZhLnV0aWwiLCJBcnJheURlcXVlIiwzMTApO2Z1bmN0aW9uIEpJKGUpe3ZhciBuO3JldHVybiBybihlLmN1cnJlbnRJbmRleCE9ZS5mZW5jZSksbj1lLnRoaXMkMDEuYXJyYXlbZS5jdXJyZW50SW5kZXhdLFFjZShlLmZlbmNlPT1lLnRoaXMkMDEudGFpbCYmbiE9bnVsbCksZS5sYXN0SW5kZXg9ZS5jdXJyZW50SW5kZXgsZS5jdXJyZW50SW5kZXg9ZS5jdXJyZW50SW5kZXgrMSZlLnRoaXMkMDEuYXJyYXkubGVuZ3RoLTEsbn1mdW5jdGlvbiBlMGUoZSl7ZmYoZS5sYXN0SW5kZXg+PTApLEhaZShlLnRoaXMkMDEsZS5sYXN0SW5kZXgpPDAmJihlLmN1cnJlbnRJbmRleD1lLmN1cnJlbnRJbmRleC0xJmUudGhpcyQwMS5hcnJheS5sZW5ndGgtMSxlLmZlbmNlPWUudGhpcyQwMS50YWlsKSxlLmxhc3RJbmRleD0tMX1mdW5jdGlvbiBYMihlKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmN1cnJlbnRJbmRleD10aGlzLnRoaXMkMDEuaGVhZCx0aGlzLmZlbmNlPXRoaXMudGhpcyQwMS50YWlsfXAoNDU5LDEsc3QsWDIpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJlbnRJbmRleCE9dGhpcy5mZW5jZX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gSkkodGhpcyl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7ZTBlKHRoaXMpfSxsLmN1cnJlbnRJbmRleD0wLGwuZmVuY2U9MCxsLmxhc3RJbmRleD0tMSxnKCJqYXZhLnV0aWwiLCJBcnJheURlcXVlL0l0ZXJhdG9ySW1wbCIsNDU5KTtmdW5jdGlvbiBLNShlKXtlLmFycmF5PUIoUXIsTWUsMSwwLDUsMSl9ZnVuY3Rpb24gQTEoZSxuLHIpe2RmKG4sZS5hcnJheS5sZW5ndGgpLG9FKGUuYXJyYXksbixyKX1mdW5jdGlvbiBlZShlLG4pe3JldHVybiBSZShlLmFycmF5LG4pLCEwfWZ1bmN0aW9uIE9CKGUsbixyKXt2YXIgdCxvO3JldHVybiBkZihuLGUuYXJyYXkubGVuZ3RoKSx0PXIudG9BcnJheSgpLG89dC5sZW5ndGgsbz09MD8hMTooWUcoZS5hcnJheSxuLHQpLCEwKX1mdW5jdGlvbiBxcihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9bi50b0FycmF5KCksdD1yLmxlbmd0aCx0PT0wPyExOihZRyhlLmFycmF5LGUuYXJyYXkubGVuZ3RoLHIpLCEwKX1mdW5jdGlvbiB3aShlLG4pe3ZhciByLHQsbyxpO2ZvcihWZShuKSx0PWUuYXJyYXksbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sbi5hY2NlcHQocil9ZnVuY3Rpb24gbGUoZSxuKXtyZXR1cm4gQWUobixlLmFycmF5Lmxlbmd0aCksZS5hcnJheVtuXX1mdW5jdGlvbiBmbyhlLG4scil7Zm9yKDtyPGUuYXJyYXkubGVuZ3RoOysrcilpZihVbyhuLGUuYXJyYXlbcl0pKXJldHVybiByO3JldHVybi0xfWZ1bmN0aW9uIE1jKGUsbil7dmFyIHI7cmV0dXJuIHI9KEFlKG4sZS5hcnJheS5sZW5ndGgpLGUuYXJyYXlbbl0pLEtHKGUuYXJyYXksbiwxKSxyfWZ1bmN0aW9uIFBpKGUsbil7dmFyIHI7cmV0dXJuIHI9Zm8oZSxuLDApLHI9PS0xPyExOihNYyhlLHIpLCEwKX1mdW5jdGlvbiBuMGUoZSxuLHIpe3ZhciB0O1NkZShuLHIsZS5hcnJheS5sZW5ndGgpLHQ9ci1uLEtHKGUuYXJyYXksbix0KX1mdW5jdGlvbiBLYShlLG4scil7dmFyIHQ7cmV0dXJuIHQ9KEFlKG4sZS5hcnJheS5sZW5ndGgpLGUuYXJyYXlbbl0pLGUuYXJyYXlbbl09cix0fWZ1bmN0aW9uIERyKGUsbil7WDUoZS5hcnJheSxlLmFycmF5Lmxlbmd0aCxuKX1mdW5jdGlvbiBJcyhlLG4pe3ZhciByLHQ7Zm9yKHQ9ZS5hcnJheS5sZW5ndGgsbi5sZW5ndGg8dCYmKG49U3gobmV3IEFycmF5KHQpLG4pKSxyPTA7cjx0OysrcilUcihuLHIsZS5hcnJheVtyXSk7cmV0dXJuIG4ubGVuZ3RoPnQmJlRyKG4sdCxudWxsKSxufWZ1bmN0aW9uIFEoKXtLNSh0aGlzKX1mdW5jdGlvbiBfaShlKXtLNSh0aGlzKSxIQyhlPj0wLCJJbml0aWFsIGNhcGFjaXR5IG11c3Qgbm90IGJlIG5lZ2F0aXZlIil9ZnVuY3Rpb24gUWkoZSl7SzUodGhpcyksWUcodGhpcy5hcnJheSwwLGUudG9BcnJheSgpKX1wKDEzLDU2LGxpZSxRLF9pLFFpKSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7QTEodGhpcyxuLHIpfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiBlZSh0aGlzLG4pfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7cmV0dXJuIE9CKHRoaXMsbixyKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7cmV0dXJuIHFyKHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe19mKHRoaXMuYXJyYXksMCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIGZvKHRoaXMsbiwwKSE9LTF9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3dpKHRoaXMsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGxlKHRoaXMsbil9LGwuaW5kZXhPZl8wPWZ1bmN0aW9uKG4pe3JldHVybiBmbyh0aGlzLG4sMCl9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aD09MH0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUKHRoaXMpfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiBNYyh0aGlzLG4pfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBQaSh0aGlzLG4pfSxsLnJlbW92ZVJhbmdlPWZ1bmN0aW9uKG4scil7bjBlKHRoaXMsbixyKX0sbC5zZXRfMj1mdW5jdGlvbihuLHIpe3JldHVybiBLYSh0aGlzLG4scil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RofSxsLnNvcnRfMD1mdW5jdGlvbihuKXtEcih0aGlzLG4pfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdngodGhpcy5hcnJheSl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiBJcyh0aGlzLG4pfTt2YXIgVlplPWcoImphdmEudXRpbCIsIkFycmF5TGlzdCIsMTMpO2Z1bmN0aW9uIHhvKGUpe3JldHVybiBlLmk8ZS50aGlzJDAxLmFycmF5Lmxlbmd0aH1mdW5jdGlvbiBDKGUpe3JldHVybiBybihlLmk8ZS50aGlzJDAxLmFycmF5Lmxlbmd0aCksZS5sYXN0PWUuaSsrLGUudGhpcyQwMS5hcnJheVtlLmxhc3RdfWZ1bmN0aW9uIEoyKGUpe2ZmKGUubGFzdCE9LTEpLE1jKGUudGhpcyQwMSxlLmk9ZS5sYXN0KSxlLmxhc3Q9LTF9ZnVuY3Rpb24gVChlKXt0aGlzLnRoaXMkMDE9ZX1wKDcsMSxzdCxUKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4geG8odGhpcyl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIEModGhpcyl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7SjIodGhpcyl9LGwuaT0wLGwubGFzdD0tMSxnKCJqYXZhLnV0aWwiLCJBcnJheUxpc3QvMSIsNyk7ZnVuY3Rpb24gWkkoZSxuKXtyZXR1cm4gdmRlKG4pLFlaZShlLEIoaG4sa24sMjgsbiwxNSwxKSxuKX1mdW5jdGlvbiBxWmUoZSxuKXt2YXIgcjtyZXR1cm4gdmRlKG4pLHI9ZS5zbGljZSgwLG4pLHIubGVuZ3RoPW4sQzUocixlKX1mdW5jdGlvbiBZWmUoZSxuLHIpe3ZhciB0LG87cmV0dXJuIG89ZS5sZW5ndGgsdD1TLk1hdGgubWluKHIsbykscUcoZSwwLG4sMCx0LCEwKSxufWZ1bmN0aW9uIHIwZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihlPT1udWxsKXJldHVybiJudWxsIjtpZihjPW4ubWFwXzAucHV0KGUsbiksYyE9bnVsbClyZXR1cm4iWy4uLl0iO2ZvcihyPW5ldyBPXygiLCAiLCJbIiwiXSIpLG89ZSxpPTAscz1vLmxlbmd0aDtpPHM7KytpKXQ9b1tpXSx0IT1udWxsJiZ3YSh0KS5tb2RpZmllcnMmND9BcnJheS5pc0FycmF5KHQpJiYoZD1nQyh0KSwhKGQ+PTE0JiZkPD0xNikpP24ubWFwXzAuY29udGFpbnNLZXkodCk/KHIuYnVpbGRlcj9PbihyLmJ1aWxkZXIsci5kZWxpbWl0ZXIpOnIuYnVpbGRlcj1uZXcgTGEoci5wcmVmaXgpLEcyKHIuYnVpbGRlciwiWy4uLl0iKSk6KHU9bV8odCksXz1uZXcgbkUobiksb2MocixyMGUodSxfKSkpOkwodCwxODMpP29jKHIsc1FlKGEodCwxODMpKSk6TCh0LDE5NSk/b2MocixuUWUoYSh0LDE5NSkpKTpMKHQsMjAxKT9vYyhyLHJRZShhKHQsMjAxKSkpOkwodCwyMTExKT9vYyhyLGxRZShhKHQsMjExMSkpKTpMKHQsNTMpP29jKHIsaVFlKGEodCw1MykpKTpMKHQsMzc2KT9vYyhyLGFRZShhKHQsMzc2KSkpOkwodCw4NDYpP29jKHIsb1FlKGEodCw4NDYpKSk6TCh0LDEwOSkmJm9jKHIsdFFlKGEodCwxMDkpKSk6b2Mocix0PT1udWxsPyJudWxsIjp2byh0KSk7cmV0dXJuIHIuYnVpbGRlcj9yLnN1ZmZpeC5sZW5ndGg9PTA/ci5idWlsZGVyLnN0cmluZzpyLmJ1aWxkZXIuc3RyaW5nKygiIityLnN1ZmZpeCk6ci5lbXB0eVZhbHVlfWZ1bmN0aW9uIEtaZShlLG4pe3ZhciByLHQsbztpZihEKGUpPT09RChuKSlyZXR1cm4hMDtpZihlPT1udWxsfHxuPT1udWxsfHxlLmxlbmd0aCE9bi5sZW5ndGgpcmV0dXJuITE7Zm9yKHI9MDtyPGUubGVuZ3RoOysrcilpZih0PWVbcl0sbz1uW3JdLCEoRCh0KT09PUQobyl8fHQhPW51bGwmJlluKHQsbykpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHooZSxuLHIsdCl7RWRlKG4scixlLmxlbmd0aCksWFplKGUsbixyLHQpfWZ1bmN0aW9uIE1CKGUsbil7dDBlKGUsZS5sZW5ndGgsbil9ZnVuY3Rpb24gTEMoZSxuKXtvMGUoZSxlLmxlbmd0aCxuKX1mdW5jdGlvbiBaMihlKXtSQihlLGUubGVuZ3RoKX1mdW5jdGlvbiBYWmUoZSxuLHIsdCl7dmFyIG87Zm9yKG89bjtvPHI7KytvKWVbb109dH1mdW5jdGlvbiB0MGUoZSxuLHIpe3ZhciB0O2Zvcih0PTA7dDxuOysrdCllW3RdPXJ9ZnVuY3Rpb24gSlplKGUsbil7dmFyIHI7Zm9yKHI9MDtyPG47KytyKWVbcl09LTF9ZnVuY3Rpb24gbzBlKGUsbixyKXt2YXIgdDtmb3IodD0wO3Q8bjsrK3QpVHIoZSx0LHIpfWZ1bmN0aW9uIFJCKGUsbil7dmFyIHI7Zm9yKHI9MDtyPG47KytyKWVbcl09ITF9ZnVuY3Rpb24ga0MoZSl7dmFyIG4scix0LG8saTtmb3IoaT0xLHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSxpPTMxKmkrKG4hPW51bGw/dXIobik6MCksaT1pfDA7cmV0dXJuIGl9ZnVuY3Rpb24gWlplKGUsbixyLHQpe3ZhciBvLGkscztmb3Iobz1uKzE7bzxyOysrbylmb3IoaT1vO2k+biYmdC5jb21wYXJlXzEoZVtpLTFdLGVbaV0pPjA7LS1pKXM9ZVtpXSxUcihlLGksZVtpLTFdKSxUcihlLGktMSxzKX1mdW5jdGlvbiBRWmUoZSxuLHIsdCxvLGkscyx1KXt2YXIgYztmb3IoYz1yO2k8czspYz49dHx8bjxyJiZ1LmNvbXBhcmVfMShlW25dLGVbY10pPD0wP1RyKG8saSsrLGVbbisrXSk6VHIobyxpKyssZVtjKytdKX1mdW5jdGlvbiBfeShlLG4scix0KXt2YXIgbzt0PShMMSgpLHR8fHFCKSxvPWUuc2xpY2UobixyKSxEQihvLGUsbixyLC1uLHQpfWZ1bmN0aW9uIERCKGUsbixyLHQsbyxpKXt2YXIgcyx1LGMsXztpZihzPXQtcixzPDcpe1paZShuLHIsdCxpKTtyZXR1cm59aWYoYz1yK28sdT10K28sXz1jKyh1LWM+PjEpLERCKG4sZSxjLF8sLW8saSksREIobixlLF8sdSwtbyxpKSxpLmNvbXBhcmVfMShlW18tMV0sZVtfXSk8PTApe2Zvcig7cjx0OylUcihuLHIrKyxlW2MrK10pO3JldHVybn1RWmUoZSxjLF8sdSxuLHIsdCxpKX1mdW5jdGlvbiBYNShlLG4scil7RWRlKDAsbixlLmxlbmd0aCksX3koZSwwLG4scil9ZnVuY3Rpb24gRkIoZSxuKXtfeShlLDAsZS5sZW5ndGgsbil9ZnVuY3Rpb24gZVFlKGUsbil7cmV0dXJuIE1RZShuLGUubGVuZ3RoKSxuZXcgT19lKGUsbil9ZnVuY3Rpb24gekIoZSl7cmV0dXJuIG5ldyBTZShudWxsLGVRZShlLGUubGVuZ3RoKSl9ZnVuY3Rpb24gblFlKGUpe3ZhciBuLHIsdCxvLGk7aWYoZT09bnVsbClyZXR1cm4ibnVsbCI7Zm9yKGk9bmV3IE9fKCIsICIsIlsiLCJdIikscj1lLHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLG9jKGksIiIrbik7cmV0dXJuIGkuYnVpbGRlcj9pLnN1ZmZpeC5sZW5ndGg9PTA/aS5idWlsZGVyLnN0cmluZzppLmJ1aWxkZXIuc3RyaW5nKygiIitpLnN1ZmZpeCk6aS5lbXB0eVZhbHVlfWZ1bmN0aW9uIHJRZShlKXt2YXIgbixyLHQsbyxpO2lmKGU9PW51bGwpcmV0dXJuIm51bGwiO2ZvcihpPW5ldyBPXygiLCAiLCJbIiwiXSIpLHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSxvYyhpLFN0cmluZy5mcm9tQ2hhckNvZGUobikpO3JldHVybiBpLmJ1aWxkZXI/aS5zdWZmaXgubGVuZ3RoPT0wP2kuYnVpbGRlci5zdHJpbmc6aS5idWlsZGVyLnN0cmluZysoIiIraS5zdWZmaXgpOmkuZW1wdHlWYWx1ZX1mdW5jdGlvbiB0UWUoZSl7dmFyIG4scix0LG8saTtpZihlPT1udWxsKXJldHVybiJudWxsIjtmb3IoaT1uZXcgT18oIiwgIiwiWyIsIl0iKSxyPWUsdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0saS5idWlsZGVyP09uKGkuYnVpbGRlcixpLmRlbGltaXRlcik6aS5idWlsZGVyPW5ldyBMYShpLnByZWZpeCksRzIoaS5idWlsZGVyLCIiK24pO3JldHVybiBpLmJ1aWxkZXI/aS5zdWZmaXgubGVuZ3RoPT0wP2kuYnVpbGRlci5zdHJpbmc6aS5idWlsZGVyLnN0cmluZysoIiIraS5zdWZmaXgpOmkuZW1wdHlWYWx1ZX1mdW5jdGlvbiBvUWUoZSl7dmFyIG4scix0LG8saTtpZihlPT1udWxsKXJldHVybiJudWxsIjtmb3IoaT1uZXcgT18oIiwgIiwiWyIsIl0iKSxyPWUsdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0saS5idWlsZGVyP09uKGkuYnVpbGRlcixpLmRlbGltaXRlcik6aS5idWlsZGVyPW5ldyBMYShpLnByZWZpeCksRzIoaS5idWlsZGVyLCIiK24pO3JldHVybiBpLmJ1aWxkZXI/aS5zdWZmaXgubGVuZ3RoPT0wP2kuYnVpbGRlci5zdHJpbmc6aS5idWlsZGVyLnN0cmluZysoIiIraS5zdWZmaXgpOmkuZW1wdHlWYWx1ZX1mdW5jdGlvbiBpUWUoZSl7dmFyIG4scix0LG8saTtpZihlPT1udWxsKXJldHVybiJudWxsIjtmb3IoaT1uZXcgT18oIiwgIiwiWyIsIl0iKSxyPWUsdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0saS5idWlsZGVyP09uKGkuYnVpbGRlcixpLmRlbGltaXRlcik6aS5idWlsZGVyPW5ldyBMYShpLnByZWZpeCksRzIoaS5idWlsZGVyLCIiK24pO3JldHVybiBpLmJ1aWxkZXI/aS5zdWZmaXgubGVuZ3RoPT0wP2kuYnVpbGRlci5zdHJpbmc6aS5idWlsZGVyLnN0cmluZysoIiIraS5zdWZmaXgpOmkuZW1wdHlWYWx1ZX1mdW5jdGlvbiBhUWUoZSl7dmFyIG4scix0LG8saTtpZihlPT1udWxsKXJldHVybiJudWxsIjtmb3IoaT1uZXcgT18oIiwgIiwiWyIsIl0iKSxyPWUsdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0saS5idWlsZGVyP09uKGkuYnVpbGRlcixpLmRlbGltaXRlcik6aS5idWlsZGVyPW5ldyBMYShpLnByZWZpeCksRzIoaS5idWlsZGVyLCIiK0QyKG4pKTtyZXR1cm4gaS5idWlsZGVyP2kuc3VmZml4Lmxlbmd0aD09MD9pLmJ1aWxkZXIuc3RyaW5nOmkuYnVpbGRlci5zdHJpbmcrKCIiK2kuc3VmZml4KTppLmVtcHR5VmFsdWV9ZnVuY3Rpb24gbFFlKGUpe3ZhciBuLHIsdCxvLGk7aWYoZT09bnVsbClyZXR1cm4ibnVsbCI7Zm9yKGk9bmV3IE9fKCIsICIsIlsiLCJdIikscj1lLHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLG9jKGksIiIrbik7cmV0dXJuIGkuYnVpbGRlcj9pLnN1ZmZpeC5sZW5ndGg9PTA/aS5idWlsZGVyLnN0cmluZzppLmJ1aWxkZXIuc3RyaW5nKygiIitpLnN1ZmZpeCk6aS5lbXB0eVZhbHVlfWZ1bmN0aW9uIHNRZShlKXt2YXIgbixyLHQsbyxpO2lmKGU9PW51bGwpcmV0dXJuIm51bGwiO2ZvcihpPW5ldyBPXygiLCAiLCJbIiwiXSIpLHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSxpLmJ1aWxkZXI/T24oaS5idWlsZGVyLGkuZGVsaW1pdGVyKTppLmJ1aWxkZXI9bmV3IExhKGkucHJlZml4KSxHMihpLmJ1aWxkZXIsIiIrbik7cmV0dXJuIGkuYnVpbGRlcj9pLnN1ZmZpeC5sZW5ndGg9PTA/aS5idWlsZGVyLnN0cmluZzppLmJ1aWxkZXIuc3RyaW5nKygiIitpLnN1ZmZpeCk6aS5lbXB0eVZhbHVlfWZ1bmN0aW9uIFFJKCl7fXAoMjExMixTLkZ1bmN0aW9uLHt9LFFJKSxsLmNvbXBhcmVfMD1mdW5jdGlvbihuLHIpe3JldHVybiBpcihuLHIpfTtmdW5jdGlvbiBpMGUoZSxuKXtyZXR1cm4gQWUobixlLmFycmF5Lmxlbmd0aCksZS5hcnJheVtuXX1mdW5jdGlvbiBhMGUoZSxuKXt2YXIgcix0O2Zvcih0PWUuYXJyYXkubGVuZ3RoLG4ubGVuZ3RoPHQmJihuPVN4KG5ldyBBcnJheSh0KSxuKSkscj0wO3I8dDsrK3IpVHIobixyLGUuYXJyYXlbcl0pO3JldHVybiBuLmxlbmd0aD50JiZUcihuLHQsbnVsbCksbn1mdW5jdGlvbiBlYShlKXtWZShlKSx0aGlzLmFycmF5PWV9cCgxNTEsNTYsc2llLGVhKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBfc2UodGhpcyxuKSE9LTF9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpO2ZvcihWZShuKSx0PXRoaXMuYXJyYXksbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sbi5hY2NlcHQocil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGkwZSh0aGlzLG4pfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7dmFyIHQ7cmV0dXJuIHQ9KEFlKG4sdGhpcy5hcnJheS5sZW5ndGgpLHRoaXMuYXJyYXlbbl0pLFRyKHRoaXMuYXJyYXksbixyKSx0fSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Lmxlbmd0aH0sbC5zb3J0XzA9ZnVuY3Rpb24obil7WDUodGhpcy5hcnJheSx0aGlzLmFycmF5Lmxlbmd0aCxuKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIGEwZSh0aGlzLEIoUXIsTWUsMSx0aGlzLmFycmF5Lmxlbmd0aCw1LDEpKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEwZSh0aGlzLG4pfSxnKCJqYXZhLnV0aWwiLCJBcnJheXMvQXJyYXlMaXN0IiwxNTEpO2Z1bmN0aW9uIE5lKCl7TmU9RixPdD1uZXcgczBlLGt1PW5ldyBjMGUsZXg9bmV3IF8wZX1mdW5jdGlvbiAkQihlLG4pe05lKCk7dmFyIHIsdCxvLGkscztmb3Iocz0hMSx0PW4sbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10scz1zfGUuYWRkXzIocik7cmV0dXJuIHN9ZnVuY3Rpb24gbDBlKGUsbil7TmUoKTt2YXIgcix0LG8saTtmb3Iocj1lLGk9bixMKGUsMjEpJiYhTChuLDIxKSYmKHI9bixpPWUpLG89ci5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspaWYodD1vLm5leHRfMSgpLGkuY29udGFpbnModCkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gQkIoZSl7TmUoKTt2YXIgbixyLHQ7Zm9yKHQ9MCxyPWUuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49ci5uZXh0XzEoKSx0PXQrKG4hPW51bGw/dXIobik6MCksdD10fDA7cmV0dXJuIHR9ZnVuY3Rpb24gR0IoZSl7TmUoKTt2YXIgbixyLHQ7Zm9yKHQ9MSxyPWUuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49ci5uZXh0XzEoKSx0PTMxKnQrKG4hPW51bGw/dXIobik6MCksdD10fDA7cmV0dXJuIHR9ZnVuY3Rpb24gdVFlKGUsbil7TmUoKTt2YXIgcix0O2Zvcih0PW5ldyBRLHI9MDtyPGU7KytyKVJlKHQuYXJyYXksbik7cmV0dXJuIG5ldyBlayh0KX1mdW5jdGlvbiBPQyhlKXt2YXIgbjtOZSgpO3ZhciByLHQsbyxpLHMsdTtpZihMKGUsNTkpKWZvcihpPTAsbz1lLnNpemVfMSgpLTE7aTxvOysraSwtLW8pbj1lLmdldF8wKGkpLGUuc2V0XzIoaSxlLmdldF8wKG8pKSxlLnNldF8yKG8sbik7ZWxzZSBmb3Iocj1lLmxpc3RJdGVyYXRvcl8wKCkscz1lLmxpc3RJdGVyYXRvcl8xKGUuc2l6ZV8xKCkpO3IubmV4dEluZGV4XzAoKTxzLnByZXZpb3VzSW5kZXgoKTspdD1yLm5leHRfMSgpLHU9cy5wcmV2aW91c18wKCksci5zZXRfMSh1KSxzLnNldF8xKHQpfWZ1bmN0aW9uIEhCKGUpe3JldHVybiBOZSgpLGU/ZS5yZXZlcnNlZCgpOihMMSgpLEwxKCksWUIpfWZ1bmN0aW9uIGNRZShlLG4pe05lKCk7dmFyIHI7cmV0dXJuIHI9bmV3IEVoKDEpLHV0KGUpP3RvKHIsZSxuKTpkaShyLmhhc2hDb2RlTWFwLGUsbiksbmV3IFE1KHIpfWZ1bmN0aW9uIEo1KGUpe3JldHVybiBOZSgpLEwoZSw1OSk/bmV3IGVrKGUpOm5ldyBueChlKX12YXIgT3Qsa3UsZXg7ZnVuY3Rpb24gVUIoZSl7cmV0dXJuIEFlKGUsMCksbnVsbH1mdW5jdGlvbiBzMGUoKXt9cCg5NTMsNTYsc2llLHMwZSksbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4hMX0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gVUIobil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBOZSgpLGR5KCksZnl9LGwubGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxkeSgpLGZ5fSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiAwfSxnKCJqYXZhLnV0aWwiLCJDb2xsZWN0aW9ucy9FbXB0eUxpc3QiLDk1Myk7ZnVuY3Rpb24gZHkoKXtkeT1GLGZ5PW5ldyB1MGV9ZnVuY3Rpb24gdTBlKCl7fXAoOTU0LDEsQ3UsdTBlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5hZGRfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbyl9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG8pfSxsLnByZXZpb3VzSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4tMX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyB6aSl9LGwuc2V0XzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgemkpfTt2YXIgZnk7ZygiamF2YS51dGlsIiwiQ29sbGVjdGlvbnMvRW1wdHlMaXN0SXRlcmF0b3IiLDk1NCk7ZnVuY3Rpb24gYzBlKCl7fXAoOTU2LDIwNjUsR20sYzBlKSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiExfSxsLmNvbnRhaW5zVmFsdWU9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwuZW50cnlTZXRfMD1mdW5jdGlvbigpe3JldHVybiBOZSgpLGV4fSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksZXh9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwudmFsdWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxPdH0sZygiamF2YS51dGlsIiwiQ29sbGVjdGlvbnMvRW1wdHlNYXAiLDk1Nik7ZnVuY3Rpb24gXzBlKCl7fXAoOTU1LFNzLFFnLF8wZSksbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4hMX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksZHkoKSxmeX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZygiamF2YS51dGlsIiwiQ29sbGVjdGlvbnMvRW1wdHlTZXQiLDk1NSk7ZnVuY3Rpb24gWjUoZSl7dGhpcy5lbGVtZW50PWV9cCg2MDgsNTYsezM6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjF9LFo1KSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBVbyh0aGlzLmVsZW1lbnQsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEFlKG4sMSksdGhpcy5lbGVtZW50fSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiAxfSxnKCJqYXZhLnV0aWwiLCJDb2xsZWN0aW9ucy9TaW5nbGV0b25MaXN0Iiw2MDgpO2Z1bmN0aW9uIGQwZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBmMGUoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gcDBlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIE1DKGUsbil7cmV0dXJuIGUuY29sbC5jb250YWlucyhuKX1mdW5jdGlvbiBnMGUoZSxuKXtyZXR1cm4gZS5jb2xsLmNvbnRhaW5zQWxsKG4pfWZ1bmN0aW9uIGgwZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBtMGUoZSxuKXtyZXR1cm4gZS5jb2xsLnRvQXJyYXlfMChuKX1mdW5jdGlvbiBweShlKXt0aGlzLmNvbGw9ZX1wKDM4NCwxLG5pZSxweSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5wYXJhbGxlbFN0cmVhbT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2UobnVsbCx0aGlzLnNwbGl0ZXJhdG9yXzAoKSl9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywwKX0sbC5zdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNlKG51bGwsdGhpcy5zcGxpdGVyYXRvcl8wKCkpfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiBkMGUoKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7cmV0dXJuIGYwZSgpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXtwMGUoKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gTUModGhpcyxuKX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gZzBlKHRoaXMsbil9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbGwuaXNFbXB0eSgpfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGd5KHRoaXMuY29sbC5pdGVyYXRvcl8wKCkpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBoMGUoKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb2xsLnNpemVfMSgpfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb2xsLnRvQXJyYXkoKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG0wZSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdm8odGhpcy5jb2xsKX0sZygiamF2YS51dGlsIiwiQ29sbGVjdGlvbnMvVW5tb2RpZmlhYmxlQ29sbGVjdGlvbiIsMzg0KTtmdW5jdGlvbiB5MGUoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gZ3koZSl7dGhpcy5pdD1lfXAoMzgzLDEsc3QsZ3kpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLml0Lmhhc05leHRfMCgpfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLml0Lm5leHRfMSgpfSxsLnJlbW92ZT1mdW5jdGlvbigpe3kwZSgpfSxnKCJqYXZhLnV0aWwiLCJDb2xsZWN0aW9ucy9Vbm1vZGlmaWFibGVDb2xsZWN0aW9uSXRlcmF0b3IiLDM4Myk7ZnVuY3Rpb24gbngoZSl7cHkuY2FsbCh0aGlzLGUpLHRoaXMubGlzdD1lfXAoNTQwLDM4NCx1aWUsbngpLGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuYWRkXzM9ZnVuY3Rpb24obixyKXt0aHJvdyBiKG5ldyBUbil9LGwuYWRkQWxsXzA9ZnVuY3Rpb24obixyKXt0aHJvdyBiKG5ldyBUbil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIFluKHRoaXMubGlzdCxuKX0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5saXN0LmdldF8wKG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdXIodGhpcy5saXN0KX0sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubGlzdC5pbmRleE9mXzAobil9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3QuaXNFbXB0eSgpfSxsLmxpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBXQih0aGlzLmxpc3QubGlzdEl0ZXJhdG9yXzEoMCkpfSxsLmxpc3RJdGVyYXRvcl8xPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgV0IodGhpcy5saXN0Lmxpc3RJdGVyYXRvcl8xKG4pKX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXt0aHJvdyBiKG5ldyBUbil9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5zdWJMaXN0PWZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBueCh0aGlzLmxpc3Quc3ViTGlzdChuLHIpKX0sZygiamF2YS51dGlsIiwiQ29sbGVjdGlvbnMvVW5tb2RpZmlhYmxlTGlzdCIsNTQwKTtmdW5jdGlvbiBXQihlKXtneS5jYWxsKHRoaXMsZSksdGhpcy5saXQ9ZX1wKDcwNSwzODMsQ3UsV0IpLGwucmVtb3ZlPWZ1bmN0aW9uKCl7eTBlKCl9LGwuYWRkXzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmhhc1ByZXZpb3VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl0Lmhhc1ByZXZpb3VzKCl9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saXQubmV4dEluZGV4XzAoKX0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl0LnByZXZpb3VzXzAoKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGl0LnByZXZpb3VzSW5kZXgoKX0sbC5zZXRfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZUxpc3RJdGVyYXRvciIsNzA1KTtmdW5jdGlvbiB3MGUoZSxuKXtyZXR1cm4gZS5tYXBfMC5jb250YWluc1ZhbHVlKG4pfWZ1bmN0aW9uIGh5KGUpe3JldHVybiFlLmVudHJ5U2V0JiYoZS5lbnRyeVNldD1uZXcgSTBlKGUubWFwXzAuZW50cnlTZXRfMCgpKSksZS5lbnRyeVNldH1mdW5jdGlvbiBFMGUoZSxuKXtyZXR1cm4gWW4oZS5tYXBfMCxuKX1mdW5jdGlvbiB2MGUoZSl7cmV0dXJuIWUua2V5U2V0JiYoZS5rZXlTZXQ9bmV3IG15KGUubWFwXzAua2V5U2V0XzAoKSkpLGUua2V5U2V0fWZ1bmN0aW9uIFMwZShlKXtyZXR1cm4hZS52YWx1ZXMmJihlLnZhbHVlcz1uZXcgcHkoZS5tYXBfMC52YWx1ZXNfMCgpKSksZS52YWx1ZXN9ZnVuY3Rpb24gUTUoZSl7dGhpcy5tYXBfMD1lfXAoNjA5LDEsaDEsUTUpLGwuZm9yRWFjaD1mdW5jdGlvbihuKXtUMih0aGlzLG4pfSxsLm1lcmdlPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gTDYodGhpcyxuLHIsdCl9LGwuY2xlYXJfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5jb250YWluc0tleT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXBfMC5jb250YWluc0tleShuKX0sbC5jb250YWluc1ZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiB3MGUodGhpcyxuKX0sbC5lbnRyeVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIGh5KHRoaXMpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiBFMGUodGhpcyxuKX0sbC5nZXRfMz1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXBfMC5nZXRfMyhuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMubWFwXzApfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5pc0VtcHR5KCl9LGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdjBlKHRoaXMpfSxsLnB1dD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwXzAuc2l6ZV8xKCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB2byh0aGlzLm1hcF8wKX0sbC52YWx1ZXNfMD1mdW5jdGlvbigpe3JldHVybiBTMGUodGhpcyl9LGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZU1hcCIsNjA5KTtmdW5jdGlvbiBteShlKXtweS5jYWxsKHRoaXMsZSl9cCgzOTYsMzg0LG82LG15KSxsLnNwbGl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHhlKHRoaXMsMSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIFluKHRoaXMuY29sbCxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHVyKHRoaXMuY29sbCl9LGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZVNldCIsMzk2KTtmdW5jdGlvbiBDMGUoZSxuKXtyZXR1cm4gZS5jb2xsLmNvbnRhaW5zKG4pfWZ1bmN0aW9uIFQwZShlLG4pe3ZhciByO3JldHVybiByPWUuY29sbC50b0FycmF5XzAobiksYjBlKHIsZS5jb2xsLnNpemVfMSgpKSxyfWZ1bmN0aW9uIGIwZShlLG4pe3ZhciByO2ZvcihyPTA7cjxuOysrcilUcihlLHIsbmV3IGpCKGEoZVtyXSw0NCkpKX1mdW5jdGlvbiBJMGUoZSl7bXkuY2FsbCh0aGlzLGUpfXAoOTU3LDM5NixvNixJMGUpLGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIEMwZSh0aGlzLG4pfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNvbGwuY29udGFpbnNBbGwobil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuY29sbC5pdGVyYXRvcl8wKCksbmV3IHgwZShuKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dGhpcy5jb2xsLnRvQXJyYXkoKSxiMGUobixuLmxlbmd0aCksbn0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIFQwZSh0aGlzLG4pfSxnKCJqYXZhLnV0aWwiLCJDb2xsZWN0aW9ucy9Vbm1vZGlmaWFibGVNYXAvVW5tb2RpZmlhYmxlRW50cnlTZXQiLDk1Nyk7ZnVuY3Rpb24geDBlKGUpe3RoaXMudmFsJGl0Mj1lfXAoOTU4LDEsc3QseDBlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGpCKGEodGhpcy52YWwkaXQyLm5leHRfMSgpLDQ0KSl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGl0Mi5oYXNOZXh0XzAoKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZU1hcC9Vbm1vZGlmaWFibGVFbnRyeVNldC8xIiw5NTgpO2Z1bmN0aW9uIGpCKGUpe3RoaXMuZW50cnk9ZX1wKDcwMywxLHM2LGpCKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmVudHJ5LmVxdWFsc18wKG4pfSxsLmdldEtleT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJ5LmdldEtleSgpfSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cnkuZ2V0VmFsdWUoKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cnkuaGFzaENvZGVfMSgpfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHZvKHRoaXMuZW50cnkpfSxnKCJqYXZhLnV0aWwiLCJDb2xsZWN0aW9ucy9Vbm1vZGlmaWFibGVNYXAvVW5tb2RpZmlhYmxlRW50cnlTZXQvVW5tb2RpZmlhYmxlRW50cnkiLDcwMyk7ZnVuY3Rpb24gZWsoZSl7bnguY2FsbCh0aGlzLGUpfXAoNjEwLDU0MCx7MjA6MSwxNjoxLDE1OjEsNTk6MX0sZWspLGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZVJhbmRvbUFjY2Vzc0xpc3QiLDYxMCk7ZnVuY3Rpb24gVkIoZSl7bXkuY2FsbCh0aGlzLGUpLHRoaXMuc29ydGVkU2V0PWV9cCg3MDQsMzk2LHJpZSxWQiksbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBseCh0aGlzKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gWW4odGhpcy5zb3J0ZWRTZXQsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiB1cih0aGlzLnNvcnRlZFNldCl9LGcoImphdmEudXRpbCIsIkNvbGxlY3Rpb25zL1VubW9kaWZpYWJsZVNvcnRlZFNldCIsNzA0KTtmdW5jdGlvbiBQMGUoKXt9cCg4NTgsMSx1NixQMGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7dmFyIHQ7cmV0dXJuIHQ9T1NlKGEobiwxMiksYShyLDEyKSksdCE9MD90Ok1TZShhKG4sMTIpLGEociwxMikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoImphdmEudXRpbCIsIkNvbXBhcmF0b3IvbGFtYmRhJDAkVHlwZSIsODU4KTtmdW5jdGlvbiBMMSgpe0wxPUYscUI9bmV3IEtCLG5rPW5ldyBLQixZQj1uZXcgTjBlfXZhciBxQixuayxZQjtmdW5jdGlvbiBfUWUoZSxuKXtyZXR1cm4gVmUoZSksd0MoZSwoVmUobiksbikpfWZ1bmN0aW9uIEtCKCl7fXAoNzY5LDEsdTYsS0IpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIF9RZShhKG4sMzQpLGEociwzNCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBMMSgpLFlCfSxnKCJqYXZhLnV0aWwiLCJDb21wYXJhdG9ycy9OYXR1cmFsT3JkZXJDb21wYXJhdG9yIiw3NjkpO2Z1bmN0aW9uIGRRZShlLG4pe3JldHVybiBWZShuKSx3QyhuLChWZShlKSxlKSl9ZnVuY3Rpb24gTjBlKCl7fXAoMTIyNiwxLHU2LE4wZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gZFFlKGEobiwzNCksYShyLDM0KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIEwxKCksbmt9LGcoImphdmEudXRpbCIsIkNvbXBhcmF0b3JzL1JldmVyc2VOYXR1cmFsT3JkZXJDb21wYXJhdG9yIiwxMjI2KTtmdW5jdGlvbiBDbihlKXt0aGlzLmNvbXBhcmF0b3I9ZX1wKDUyLDEsdTYsQ24pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmNvbXBhcmF0b3IuY29tcGFyZV8xKHIsbil9LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wYXJhdG9yfSxnKCJqYXZhLnV0aWwiLCJDb21wYXJhdG9ycy9SZXZlcnNlZENvbXBhcmF0b3IiLDUyKTtmdW5jdGlvbiBYYSgpe0NfLmNhbGwodGhpcyl9cCgxNzUsNjMsS3UsWGEpLGcoImphdmEudXRpbCIsIkNvbmN1cnJlbnRNb2RpZmljYXRpb25FeGNlcHRpb24iLDE3NSk7ZnVuY3Rpb24gQTBlKCl7QTBlPUYsTDBlPVAoSShzZSwxKSxYLDIsNixbIlN1biIsIk1vbiIsIlR1ZSIsIldlZCIsIlRodSIsIkZyaSIsIlNhdCJdKSxrMGU9UChJKHNlLDEpLFgsMiw2LFsiSmFuIiwiRmViIiwiTWFyIiwiQXByIiwiTWF5IiwiSnVuIiwiSnVsIiwiQXVnIiwiU2VwIiwiT2N0IiwiTm92IiwiRGVjIl0pfXZhciBMMGUsazBlO2Z1bmN0aW9uIE8wZShlLG4pe3ZhciByLHQ7ZS5jb3VudD1OdChlLmNvdW50LDEpLGUubWluXzA9Uy5NYXRoLm1pbihlLm1pbl8wLG4pLGUubWF4XzA9Uy5NYXRoLm1heChlLm1heF8wLG4pLGUubmFpdmVTdW0rPW4scj1uLWUuc3VtRXJyb3IsdD1lLnN1bStyLGUuc3VtRXJyb3I9dC1lLnN1bS1yLGUuc3VtPXR9ZnVuY3Rpb24gWEIoZSl7dmFyIG47cmV0dXJuIG49ZS5zdW0rZS5zdW1FcnJvcixpc05hTihuKSYmVUkoZS5uYWl2ZVN1bSk/ZS5uYWl2ZVN1bTpufWZ1bmN0aW9uIE0wZSgpe31wKDE5NDgsMSxYUyxNMGUpLGwuYWNjZXB0XzI9ZnVuY3Rpb24obil7TzBlKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJEb3VibGVTdW1tYXJ5U3RhdGlzdGljc1tjb3VudCA9ICIrRDIodGhpcy5jb3VudCkrIiwgYXZnID0gIisoSTUodGhpcy5jb3VudCwwKT9YQih0aGlzKS9JXyh0aGlzLmNvdW50KTowKSsiLCBtaW4gPSAiK3RoaXMubWluXzArIiwgbWF4ID0gIit0aGlzLm1heF8wKyIsIHN1bSA9ICIrWEIodGhpcykrIl0ifSxsLmNvdW50PTAsbC5tYXhfMD1WcixsLm1pbl8wPWhyLGwubmFpdmVTdW09MCxsLnN1bT0wLGwuc3VtRXJyb3I9MCxnKCJqYXZhLnV0aWwiLCJEb3VibGVTdW1tYXJ5U3RhdGlzdGljcyIsMTk0OCk7ZnVuY3Rpb24gUjBlKCl7Q18uY2FsbCh0aGlzKX1wKDE4NjgsNjMsS3UsUjBlKSxnKCJqYXZhLnV0aWwiLCJFbXB0eVN0YWNrRXhjZXB0aW9uIiwxODY4KTtmdW5jdGlvbiBEMGUoZSl7bXooZS5rZXlTZXQpLGUudmFsdWVzPUIoUXIsTWUsMSxlLnZhbHVlcy5sZW5ndGgsNSwxKX1mdW5jdGlvbiBGMGUoZSxuKXtyZXR1cm4gcmsoZS5rZXlTZXQsbil9ZnVuY3Rpb24gWnQoZSxuKXtyZXR1cm4gcmsoZS5rZXlTZXQsbik/ZS52YWx1ZXNbYShuLDIyKS5vcmRpbmFsXTpudWxsfWZ1bmN0aW9uIHloKGUsbixyKXtyZXR1cm4gTWwoZS5rZXlTZXQsbiksWEcoZS52YWx1ZXMsbi5vcmRpbmFsLHIpfWZ1bmN0aW9uIEpCKGUsbixyKXtyZXR1cm4geWgoZSxhKG4sMjIpLHIpfWZ1bmN0aW9uIFpCKGUsbil7cmV0dXJuIFUwZShlLmtleVNldCxuKT9YRyhlLnZhbHVlcyxhKG4sMjIpLm9yZGluYWwsbnVsbCk6bnVsbH1mdW5jdGlvbiBRMihlKXt2YXIgbjt0aGlzLmtleVNldD0obj1hKGUuZW51bUNvbnN0YW50c0Z1bmMmJmUuZW51bUNvbnN0YW50c0Z1bmMoKSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKSx0aGlzLnZhbHVlcz1CKFFyLE1lLDEsdGhpcy5rZXlTZXQuYWxsLmxlbmd0aCw1LDEpfXAoNDYxLDIwNjUsaDEsUTIpLGwucHV0PWZ1bmN0aW9uKG4scil7cmV0dXJuIEpCKHRoaXMsbixyKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7RDBlKHRoaXMpfSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiBGMGUodGhpcyxuKX0sbC5jb250YWluc1ZhbHVlPWZ1bmN0aW9uKG4pe3ZhciByLHQ7Zm9yKHQ9bmV3IHdoKHRoaXMua2V5U2V0KTt0Lmk8dC50aGlzJDExLmFsbC5sZW5ndGg7KWlmKHI9ZUUodCksVW8obix0aGlzLnZhbHVlc1tyLm9yZGluYWxdKSlyZXR1cm4hMDtyZXR1cm4hMX0sbC5lbnRyeVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyAkMGUodGhpcyl9LGwuZ2V0XzM9ZnVuY3Rpb24obil7cmV0dXJuIFp0KHRoaXMsbil9LGwucmVtb3ZlXzA9ZnVuY3Rpb24obil7cmV0dXJuIFpCKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5U2V0LnNpemVfMH0sZygiamF2YS51dGlsIiwiRW51bU1hcCIsNDYxKTtmdW5jdGlvbiB6MGUoZSxuKXtyZXR1cm4gTChuLDQ0KT9rNihlLnRoaXMkMDEsYShuLDQ0KSk6ITF9ZnVuY3Rpb24gJDBlKGUpe3RoaXMudGhpcyQwMT1lfXAoMTM0MCxTcyxEaSwkMGUpLGwuY2xlYXJfMD1mdW5jdGlvbigpe0QwZSh0aGlzLnRoaXMkMDEpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB6MGUodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCMGUodGhpcy50aGlzJDAxKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gejBlKHRoaXMsbik/KHI9YShuLDQ0KS5nZXRLZXkoKSxaQih0aGlzLnRoaXMkMDEsciksITApOiExfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEua2V5U2V0LnNpemVfMH0sZygiamF2YS51dGlsIiwiRW51bU1hcC9FbnRyeVNldCIsMTM0MCk7ZnVuY3Rpb24gQjBlKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMuaXQ9bmV3IHdoKHRoaXMudGhpcyQwMS5rZXlTZXQpfXAoMTM0MSwxLHN0LEIwZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5PWVFKHRoaXMuaXQpLG5ldyBHMGUodGhpcy50aGlzJDAxLHRoaXMua2V5KX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gUUIodGhpcy5pdCl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7ZmYoISF0aGlzLmtleSksWkIodGhpcy50aGlzJDAxLHRoaXMua2V5KSx0aGlzLmtleT1udWxsfSxnKCJqYXZhLnV0aWwiLCJFbnVtTWFwL0VudHJ5U2V0SXRlcmF0b3IiLDEzNDEpO2Z1bmN0aW9uIEcwZShlLG4pe3RoaXMudGhpcyQwMT1lLHRoaXMua2V5PW59cCgxMzQyLDIwODIsczYsRzBlKSxsLmdldEtleT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmtleX0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEudmFsdWVzW3RoaXMua2V5Lm9yZGluYWxdfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiBYRyh0aGlzLnRoaXMkMDEudmFsdWVzLHRoaXMua2V5Lm9yZGluYWwsbil9LGcoImphdmEudXRpbCIsIkVudW1NYXAvTWFwRW50cnkiLDEzNDIpO2Z1bmN0aW9uIGZRZShlKXt2YXIgbixyLHQ7cmV0dXJuIG49YShlLmVudW1Db25zdGFudHNGdW5jJiZlLmVudW1Db25zdGFudHNGdW5jKCksOSksdD0ocj1uLnNsaWNlKCksYShDNShyLG4pLDkpKSxuZXcgSmEobix0LG4ubGVuZ3RoKX1mdW5jdGlvbiBFZShlKXt2YXIgbixyLHQsbztyZXR1cm4gcj0obj1hKGlzKCh0PWUuX19fY2xhenosbz10LmVudW1TdXBlcmNsYXNzLG89PWduP3Q6bykpLDkpLG5ldyBKYShuLGEoRGwobixuLmxlbmd0aCksOSksMCkpLE1sKHIsZSkscn1mdW5jdGlvbiBjcihlLG4pe3ZhciByO3JldHVybiByPUVlKGUpLCRCKHIsbikscn1wKDE4MSxTcyx7MjA6MSwzMToxLDE2OjEsMTgxOjEsMjE6MX0pO3ZhciBIMGU9ZygiamF2YS51dGlsIiwiRW51bVNldCIsMTgxKTtmdW5jdGlvbiBNbChlLG4pe3ZhciByO3JldHVybiBWZShuKSxyPW4ub3JkaW5hbCxlLnNldF8wW3JdPyExOihUcihlLnNldF8wLHIsbiksKytlLnNpemVfMCwhMCl9ZnVuY3Rpb24gcFFlKGUpe3ZhciBuO3JldHVybiBuPWEodngoZS5zZXRfMCksOSksbmV3IEphKGUuYWxsLG4sZS5zaXplXzApfWZ1bmN0aW9uIHJrKGUsbil7cmV0dXJuIEwobiwyMikmJiRpKGUsYShuLDIyKSl9ZnVuY3Rpb24gJGkoZSxuKXtyZXR1cm4hIW4mJmUuc2V0XzBbbi5vcmRpbmFsXT09bn1mdW5jdGlvbiBVMGUoZSxuKXtyZXR1cm4gTChuLDIyKSYmZ1FlKGUsYShuLDIyKSl9ZnVuY3Rpb24gZ1FlKGUsbil7cmV0dXJuIG4mJmUuc2V0XzBbbi5vcmRpbmFsXT09bj8oVHIoZS5zZXRfMCxuLm9yZGluYWwsbnVsbCksLS1lLnNpemVfMCwhMCk6ITF9ZnVuY3Rpb24gSmEoZSxuLHIpe3RoaXMuYWxsPWUsdGhpcy5zZXRfMD1uLHRoaXMuc2l6ZV8wPXJ9cCgxNjIsMTgxLHsyMDoxLDMxOjEsMTY6MSwxODE6MSwxNjI6MSwyMToxfSxKYSksbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gTWwodGhpcyxhKG4sMjIpKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gcmsodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB3aCh0aGlzKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gVTBlKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wfSxsLnNpemVfMD0wLGcoImphdmEudXRpbCIsIkVudW1TZXQvRW51bVNldEltcGwiLDE2Mik7ZnVuY3Rpb24gVzBlKGUpe3ZhciBuO2ZvcigrK2UuaSxuPWUudGhpcyQxMS5hbGwubGVuZ3RoO2UuaTxuOysrZS5pKWlmKGUudGhpcyQxMS5zZXRfMFtlLmldKXJldHVybn1mdW5jdGlvbiBRQihlKXtyZXR1cm4gZS5pPGUudGhpcyQxMS5hbGwubGVuZ3RofWZ1bmN0aW9uIGVFKGUpe3JldHVybiBybihlLmk8ZS50aGlzJDExLmFsbC5sZW5ndGgpLGUubGFzdD1lLmksVzBlKGUpLGUudGhpcyQxMS5zZXRfMFtlLmxhc3RdfWZ1bmN0aW9uIHdoKGUpe3RoaXMudGhpcyQxMT1lLFcwZSh0aGlzKX1wKDM1NiwxLHN0LHdoKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gZUUodGhpcyl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIFFCKHRoaXMpfSxsLnJlbW92ZT1mdW5jdGlvbigpe2ZmKHRoaXMubGFzdCE9LTEpLFRyKHRoaXMudGhpcyQxMS5zZXRfMCx0aGlzLmxhc3QsbnVsbCksLS10aGlzLnRoaXMkMTEuc2l6ZV8wLHRoaXMubGFzdD0tMX0sbC5pPS0xLGwubGFzdD0tMSxnKCJqYXZhLnV0aWwiLCJFbnVtU2V0L0VudW1TZXRJbXBsL0l0ZXJhdG9ySW1wbCIsMzU2KTtmdW5jdGlvbiBzbigpe1ppKHRoaXMpfWZ1bmN0aW9uIEVoKGUpe0hjZS5jYWxsKHRoaXMsZSwwKX1mdW5jdGlvbiBqMGUoZSl7WmkodGhpcyksYjIodGhpcyxlKX1wKDQ1LDQ5OCxocCxzbixFaCxqMGUpLGwuZXF1YWxzXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gRChuKT09PUQocil8fG4hPW51bGwmJlluKG4scil9LGwuZ2V0SGFzaENvZGU9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIG49PW51bGw/MDoocj11cihuKSxyfDApfSxnKCJqYXZhLnV0aWwiLCJIYXNoTWFwIiw0NSk7ZnVuY3Rpb24gWXIoZSxuKXt2YXIgcjtyZXR1cm4gcj1lLm1hcF8wLnB1dChuLGUpLHI9PW51bGx9ZnVuY3Rpb24gc3MoZSxuKXtyZXR1cm4gZS5tYXBfMC5jb250YWluc0tleShuKX1mdW5jdGlvbiBlRyhlLG4pe3JldHVybiBlLm1hcF8wLnJlbW92ZV8wKG4pIT1udWxsfWZ1bmN0aW9uIEJyKCl7dGhpcy5tYXBfMD1uZXcgc259ZnVuY3Rpb24gcngoZSl7dGhpcy5tYXBfMD1uZXcgRWgoZSl9ZnVuY3Rpb24gbkUoZSl7dGhpcy5tYXBfMD1uZXcgRWgoZS5zaXplXzEoKSksZnQodGhpcyxlKX1mdW5jdGlvbiBuRyhlKXt0aGlzLm1hcF8wPWV9cCg0OSxTcyxHRixCcixyeCxuRSksbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gWXIodGhpcyxuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5tYXBfMC5jbGVhcl8wKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHNzKHRoaXMsbil9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLnNpemVfMSgpPT0wfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gZUcodGhpcyxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXBfMC5zaXplXzEoKX07dmFyIGhRZT1nKCJqYXZhLnV0aWwiLCJIYXNoU2V0Iiw0OSk7ZnVuY3Rpb24gVjBlKGUsbil7ZS5jb3VudD1OdChlLmNvdW50LDEpLGUubWluXzA9Uy5NYXRoLm1pbihlLm1pbl8wLG4pLGUubWF4XzA9Uy5NYXRoLm1heChlLm1heF8wLG4pLGUuc3VtPU50KGUuc3VtLG4pfWZ1bmN0aW9uIHEwZSgpe31wKDE4OTcsMSxXUyxxMGUpLGwuYWNjZXB0XzA9ZnVuY3Rpb24obil7VjBlKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJJbnRTdW1tYXJ5U3RhdGlzdGljc1tjb3VudCA9ICIrRDIodGhpcy5jb3VudCkrIiwgYXZnID0gIisoSTUodGhpcy5jb3VudCwwKT9JXyh0aGlzLnN1bSkvSV8odGhpcy5jb3VudCk6MCkrIiwgbWluID0gIit0aGlzLm1pbl8wKyIsIG1heCA9ICIrdGhpcy5tYXhfMCsiLCBzdW0gPSAiK0QyKHRoaXMuc3VtKSsiXSJ9LGwuY291bnQ9MCxsLm1heF8wPWJ0LGwubWluXzA9cW4sbC5zdW09MCxnKCJqYXZhLnV0aWwiLCJJbnRTdW1tYXJ5U3RhdGlzdGljcyIsMTg5Nyk7ZnVuY3Rpb24gWTBlKGUsbixyKXt2YXIgdCxvLGkscztmb3Iobz1yLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpaWYodD1vW2ldLGUuaG9zdC5lcXVhbHNfMShuLHQuZ2V0S2V5KCkpKXJldHVybiB0O3JldHVybiBudWxsfWZ1bmN0aW9uIG1RZShlLG4pe3ZhciByO3JldHVybiByPWUuYmFja2luZ01hcC5nZXQobikscj8/QihRcixNZSwxLDAsNSwxKX1mdW5jdGlvbiBqdChlLG4pe3JldHVybiBZMGUoZSxuLG1RZShlLGUuaG9zdC5nZXRIYXNoQ29kZShuKSkpfWZ1bmN0aW9uIGRpKGUsbixyKXt2YXIgdCxvLGkscztpZihzPWUuaG9zdC5nZXRIYXNoQ29kZShuKSxvPSh0PWUuYmFja2luZ01hcC5nZXQocyksdD8/QihRcixNZSwxLDAsNSwxKSksby5sZW5ndGg9PTApZS5iYWNraW5nTWFwLnNldChzLG8pO2Vsc2UgaWYoaT1ZMGUoZSxuLG8pLGkpcmV0dXJuIGkuc2V0VmFsdWUocik7cmV0dXJuIFRyKG8sby5sZW5ndGgsbmV3IFhJKG4scikpLCsrZS5zaXplXzAsKytlLmhvc3QubW9kQ291bnQsbnVsbH1mdW5jdGlvbiByRyhlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKGk9ZS5ob3N0LmdldEhhc2hDb2RlKG4pLHQ9KHI9ZS5iYWNraW5nTWFwLmdldChpKSxyPz9CKFFyLE1lLDEsMCw1LDEpKSxzPTA7czx0Lmxlbmd0aDtzKyspaWYobz10W3NdLGUuaG9zdC5lcXVhbHNfMShuLG8uZ2V0S2V5KCkpKXJldHVybiB0Lmxlbmd0aD09MT8odC5sZW5ndGg9MCx5UWUoZS5iYWNraW5nTWFwLGkpKTp0LnNwbGljZShzLDEpLC0tZS5zaXplXzAsKytlLmhvc3QubW9kQ291bnQsby5nZXRWYWx1ZSgpO3JldHVybiBudWxsfWZ1bmN0aW9uIEswZShlKXt0aGlzLmJhY2tpbmdNYXA9SjBlKCksdGhpcy5ob3N0PWV9cCgxMDYyLDEsVHUsSzBlKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHRHKHRoaXMpfSxsLnNpemVfMD0wLGcoImphdmEudXRpbCIsIkludGVybmFsSGFzaENvZGVNYXAiLDEwNjIpO2Z1bmN0aW9uIHRHKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMuY2hhaW5zPXRoaXMudGhpcyQwMS5iYWNraW5nTWFwLmVudHJpZXMoKSx0aGlzLmNoYWluPUIoUXIsTWUsMSwwLDUsMSl9cCg3MjYsMSxzdCx0RyksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFzdEVudHJ5PXRoaXMuY2hhaW5bdGhpcy5pdGVtSW5kZXgrK10sdGhpcy5sYXN0RW50cnl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuaXRlbUluZGV4PHRoaXMuY2hhaW4ubGVuZ3RoPyEwOihuPXRoaXMuY2hhaW5zLm5leHQoKSxuLmRvbmU/ITE6KHRoaXMuY2hhaW49bi52YWx1ZVsxXSx0aGlzLml0ZW1JbmRleD0wLCEwKSl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7ckcodGhpcy50aGlzJDAxLHRoaXMubGFzdEVudHJ5LmdldEtleSgpKSx0aGlzLml0ZW1JbmRleCE9MCYmLS10aGlzLml0ZW1JbmRleH0sbC5pdGVtSW5kZXg9MCxsLmxhc3RFbnRyeT1udWxsLGcoImphdmEudXRpbCIsIkludGVybmFsSGFzaENvZGVNYXAvMSIsNzI2KTtmdW5jdGlvbiB5UWUoZSxuKXt2YXIgcjtyPWUuZGVsZXRlLHIuY2FsbChlLG4pfWZ1bmN0aW9uIHdRZShlLG4pe3ZhciByO3I9ZS5kZWxldGUsci5jYWxsKGUsbil9ZnVuY3Rpb24gWDBlKCl7WDBlPUYsWjBlPXZRZSgpfWZ1bmN0aW9uIEVRZSgpe2lmKCFPYmplY3QuY3JlYXRlfHwhT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpcmV0dXJuITE7dmFyIGU9Il9fcHJvdG9fXyIsbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG5bZV0hPT12b2lkIDApcmV0dXJuITE7dmFyIHI9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobik7cmV0dXJuIShyLmxlbmd0aCE9MHx8KG5bZV09NDIsbltlXSE9PTQyKXx8T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobikubGVuZ3RoPT0wKX1mdW5jdGlvbiB2UWUoKXtmdW5jdGlvbiBlKCl7dHJ5e3JldHVybiBuZXcgTWFwKCkuZW50cmllcygpLm5leHQoKS5kb25lfWNhdGNoe3JldHVybiExfX1yZXR1cm4gdHlwZW9mIE1hcD09ImZ1bmN0aW9uIiYmTWFwLnByb3RvdHlwZS5lbnRyaWVzJiZlKCk/TWFwOlNRZSgpfWZ1bmN0aW9uIFNRZSgpe2Z1bmN0aW9uIGUoKXt0aGlzLm9iaj10aGlzLmNyZWF0ZU9iamVjdCgpfXJldHVybiBlLnByb3RvdHlwZS5jcmVhdGVPYmplY3Q9ZnVuY3Rpb24obil7cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCl9LGUucHJvdG90eXBlLmdldD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5vYmpbbl19LGUucHJvdG90eXBlLnNldD1mdW5jdGlvbihuLHIpe3RoaXMub2JqW25dPXJ9LGUucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbihuKXtkZWxldGUgdGhpcy5vYmpbbl19LGUucHJvdG90eXBlLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5vYmopfSxlLnByb3RvdHlwZS5lbnRyaWVzPWZ1bmN0aW9uKCl7dmFyIG49dGhpcy5rZXlzKCkscj10aGlzLHQ9MDtyZXR1cm57bmV4dDpmdW5jdGlvbigpe2lmKHQ+PW4ubGVuZ3RoKXJldHVybntkb25lOiEwfTt2YXIgbz1uW3QrK107cmV0dXJue3ZhbHVlOltvLHIuZ2V0KG8pXSxkb25lOiExfX19fSxFUWUoKXx8KGUucHJvdG90eXBlLmNyZWF0ZU9iamVjdD1mdW5jdGlvbigpe3JldHVybnt9fSxlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMub2JqWyI6IituXX0sZS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKG4scil7dGhpcy5vYmpbIjoiK25dPXJ9LGUucHJvdG90eXBlLmRlbGV0ZT1mdW5jdGlvbihuKXtkZWxldGUgdGhpcy5vYmpbIjoiK25dfSxlLnByb3RvdHlwZS5rZXlzPWZ1bmN0aW9uKCl7dmFyIG49W107Zm9yKHZhciByIGluIHRoaXMub2JqKXIuY2hhckNvZGVBdCgwKT09NTgmJm4ucHVzaChyLnN1YnN0cmluZygxKSk7cmV0dXJuIG59KSxlfWZ1bmN0aW9uIEowZSgpe3JldHVybiBYMGUoKSxuZXcgWjBlfXZhciBaMGU7ZnVuY3Rpb24gQ1FlKGUsbil7cmV0dXJuIGUuYmFja2luZ01hcC5nZXQobikhPT12b2lkIDB9ZnVuY3Rpb24gckUoZSxuKXtyZXR1cm4gZS5iYWNraW5nTWFwLmdldChuKX1mdW5jdGlvbiBrMShlLG4scil7dmFyIHQ7cmV0dXJuIHQ9ZS5iYWNraW5nTWFwLmdldChuKSxlLmJhY2tpbmdNYXAuc2V0KG4scj09PXZvaWQgMD9udWxsOnIpLHQ9PT12b2lkIDA/KCsrZS5zaXplXzAsKytlLmhvc3QubW9kQ291bnQpOisrZS52YWx1ZU1vZCx0fWZ1bmN0aW9uIFEwZShlLG4pe3ZhciByO3JldHVybiByPWUuYmFja2luZ01hcC5nZXQobikscj09PXZvaWQgMD8rK2UudmFsdWVNb2Q6KHdRZShlLmJhY2tpbmdNYXAsbiksLS1lLnNpemVfMCwrK2UuaG9zdC5tb2RDb3VudCkscn1mdW5jdGlvbiBlX2UoZSl7dGhpcy5iYWNraW5nTWFwPUowZSgpLHRoaXMuaG9zdD1lfXAoMTA2MCwxLFR1LGVfZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBvRyh0aGlzKX0sbC5zaXplXzA9MCxsLnZhbHVlTW9kPTAsZygiamF2YS51dGlsIiwiSW50ZXJuYWxTdHJpbmdNYXAiLDEwNjApO2Z1bmN0aW9uIG9HKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMuZW50cmllc18wPXRoaXMudGhpcyQwMS5iYWNraW5nTWFwLmVudHJpZXMoKSx0aGlzLmN1cnJlbnQ9dGhpcy5lbnRyaWVzXzAubmV4dCgpfXAoNzI1LDEsc3Qsb0cpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxhc3Q9dGhpcy5jdXJyZW50LHRoaXMuY3VycmVudD10aGlzLmVudHJpZXNfMC5uZXh0KCksbmV3IG5fZSh0aGlzLnRoaXMkMDEsdGhpcy5sYXN0LHRoaXMudGhpcyQwMS52YWx1ZU1vZCl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuY3VycmVudC5kb25lfSxsLnJlbW92ZT1mdW5jdGlvbigpe1EwZSh0aGlzLnRoaXMkMDEsdGhpcy5sYXN0LnZhbHVlWzBdKX0sZygiamF2YS51dGlsIiwiSW50ZXJuYWxTdHJpbmdNYXAvMSIsNzI1KTtmdW5jdGlvbiBuX2UoZSxuLHIpe3RoaXMudGhpcyQwMT1lLHRoaXMudmFsJGVudHJ5Mj1uLHRoaXMudmFsJGxhc3RWYWx1ZU1vZDM9cn1wKDEwNjEsMjA4MixzNixuX2UpLGwuZ2V0S2V5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsJGVudHJ5Mi52YWx1ZVswXX0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEudmFsdWVNb2QhPXRoaXMudmFsJGxhc3RWYWx1ZU1vZDM/ckUodGhpcy50aGlzJDAxLHRoaXMudmFsJGVudHJ5Mi52YWx1ZVswXSk6dGhpcy52YWwkZW50cnkyLnZhbHVlWzFdfSxsLnNldFZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiBrMSh0aGlzLnRoaXMkMDEsdGhpcy52YWwkZW50cnkyLnZhbHVlWzBdLG4pfSxsLnZhbCRsYXN0VmFsdWVNb2QzPTAsZygiamF2YS51dGlsIiwiSW50ZXJuYWxTdHJpbmdNYXAvMiIsMTA2MSk7ZnVuY3Rpb24gcl9lKGUpe2UuaGVhZD1uZXcgc19lKGUpLGUubWFwXzA9bmV3IHNufWZ1bmN0aW9uIHRfZShlKXtaaShlLm1hcF8wKSxlLmhlYWQucHJldj1lLmhlYWQsZS5oZWFkLm5leHRfMD1lLmhlYWR9ZnVuY3Rpb24gb19lKGUsbil7cmV0dXJuIHlpKGUubWFwXzAsbil9ZnVuY3Rpb24geHMoZSxuKXt2YXIgcjtyZXR1cm4gcj1hKEtlKGUubWFwXzAsbiksNDAwKSxyPyhpX2UoZSxyKSxyLnZhbHVlXzApOm51bGx9ZnVuY3Rpb24gUmMoZSxuLHIpe3ZhciB0LG8saTtyZXR1cm4gbz1hKEtlKGUubWFwXzAsbiksNDAwKSxvPyhpPU5CKG8sciksaV9lKGUsbyksaSk6KHQ9bmV3IGxHKGUsbixyKSxCbihlLm1hcF8wLG4sdCksbF9lKHQpLG51bGwpfWZ1bmN0aW9uIGlfZShlLG4pe2UuYWNjZXNzT3JkZXImJihhRyhuKSxsX2UobikpfWZ1bmN0aW9uIGFfZShlLG4pe3ZhciByO3JldHVybiByPWEoaGgoZS5tYXBfMCxuKSw0MDApLHI/KGFHKHIpLHIudmFsdWVfMCk6bnVsbH1mdW5jdGlvbiBEYygpe3NuLmNhbGwodGhpcykscl9lKHRoaXMpLHRoaXMuaGVhZC5wcmV2PXRoaXMuaGVhZCx0aGlzLmhlYWQubmV4dF8wPXRoaXMuaGVhZH1mdW5jdGlvbiBpRyhlKXtIY2UuY2FsbCh0aGlzLGUsMCkscl9lKHRoaXMpLHRoaXMuaGVhZC5wcmV2PXRoaXMuaGVhZCx0aGlzLmhlYWQubmV4dF8wPXRoaXMuaGVhZH1wKDIxNSw0NSxocCxEYyxpRyksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dF9lKHRoaXMpfSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiBvX2UodGhpcyxuKX0sbC5jb250YWluc1ZhbHVlPWZ1bmN0aW9uKG4pe3ZhciByO2ZvcihyPXRoaXMuaGVhZC5uZXh0XzA7ciE9dGhpcy5oZWFkOyl7aWYoVW8oci52YWx1ZV8wLG4pKXJldHVybiEwO3I9ci5uZXh0XzB9cmV0dXJuITF9LGwuZW50cnlTZXRfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgc0codGhpcyl9LGwuZ2V0XzM9ZnVuY3Rpb24obil7cmV0dXJuIHhzKHRoaXMsbil9LGwucHV0PWZ1bmN0aW9uKG4scil7cmV0dXJuIFJjKHRoaXMsbixyKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXtyZXR1cm4gYV9lKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFYyKHRoaXMubWFwXzApfSxsLmFjY2Vzc09yZGVyPSExLGcoImphdmEudXRpbCIsIkxpbmtlZEhhc2hNYXAiLDIxNSk7ZnVuY3Rpb24gbF9lKGUpe3ZhciBuO249ZS50aGlzJDAxLmhlYWQucHJldixlLnByZXY9bixlLm5leHRfMD1lLnRoaXMkMDEuaGVhZCxuLm5leHRfMD1lLnRoaXMkMDEuaGVhZC5wcmV2PWV9ZnVuY3Rpb24gYUcoZSl7ZS5uZXh0XzAucHJldj1lLnByZXYsZS5wcmV2Lm5leHRfMD1lLm5leHRfMCxlLm5leHRfMD1lLnByZXY9bnVsbH1mdW5jdGlvbiBzX2UoZSl7bEcuY2FsbCh0aGlzLGUsbnVsbCxudWxsKX1mdW5jdGlvbiBsRyhlLG4scil7dGhpcy50aGlzJDAxPWUsWEkuY2FsbCh0aGlzLG4scil9cCg0MDAsMzk3LHs0OTQ6MSwzOTc6MSw0MDA6MSw0NDoxfSxzX2UsbEcpLGcoImphdmEudXRpbCIsIkxpbmtlZEhhc2hNYXAvQ2hhaW5FbnRyeSIsNDAwKTtmdW5jdGlvbiB1X2UoZSxuKXtyZXR1cm4gTChuLDQ0KT9rNihlLnRoaXMkMDEsYShuLDQ0KSk6ITF9ZnVuY3Rpb24gc0coZSl7dGhpcy50aGlzJDAxPWV9cCg3MTUsU3MsRGksc0cpLGwuY2xlYXJfMD1mdW5jdGlvbigpe3RfZSh0aGlzLnRoaXMkMDEpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB1X2UodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1Ryh0aGlzKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdV9lKHRoaXMsbik/KHI9YShuLDQ0KS5nZXRLZXkoKSxhX2UodGhpcy50aGlzJDAxLHIpLCEwKTohMX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gVjIodGhpcy50aGlzJDAxLm1hcF8wKX0sZygiamF2YS51dGlsIiwiTGlua2VkSGFzaE1hcC9FbnRyeVNldCIsNzE1KTtmdW5jdGlvbiBjX2UoZSl7cmV0dXJuIERrKGUudGhpcyQxMS50aGlzJDAxLm1hcF8wLm1vZENvdW50LGUubGFzdE1vZENvdW50KSxybihlLm5leHRfMCE9ZS50aGlzJDExLnRoaXMkMDEuaGVhZCksZS5sYXN0PWUubmV4dF8wLGUubmV4dF8wPWUubmV4dF8wLm5leHRfMCxlLmxhc3R9ZnVuY3Rpb24gdUcoZSl7dGhpcy50aGlzJDExPWUsdGhpcy5uZXh0XzA9ZS50aGlzJDAxLmhlYWQubmV4dF8wLHRoaXMubGFzdE1vZENvdW50PWUudGhpcyQwMS5tYXBfMC5tb2RDb3VudH1wKDcxNiwxLHN0LHVHKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gY19lKHRoaXMpfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHRfMCE9dGhpcy50aGlzJDExLnRoaXMkMDEuaGVhZH0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtmZighIXRoaXMubGFzdCksRGsodGhpcy50aGlzJDExLnRoaXMkMDEubWFwXzAubW9kQ291bnQsdGhpcy5sYXN0TW9kQ291bnQpLGFHKHRoaXMubGFzdCksaGgodGhpcy50aGlzJDExLnRoaXMkMDEubWFwXzAsdGhpcy5sYXN0LmtleSksdGhpcy5sYXN0TW9kQ291bnQ9dGhpcy50aGlzJDExLnRoaXMkMDEubWFwXzAubW9kQ291bnQsdGhpcy5sYXN0PW51bGx9LGwubGFzdE1vZENvdW50PTAsZygiamF2YS51dGlsIiwiTGlua2VkSGFzaE1hcC9FbnRyeVNldC9FbnRyeUl0ZXJhdG9yIiw3MTYpO2Z1bmN0aW9uIGx1KCl7bkcuY2FsbCh0aGlzLG5ldyBEYyl9ZnVuY3Rpb24gdGsoZSl7bkcuY2FsbCh0aGlzLG5ldyBpRyhlKSl9ZnVuY3Rpb24gY0coZSl7bkcuY2FsbCh0aGlzLG5ldyBEYyksZnQodGhpcyxlKX1wKDE3NCw0OSxHRixsdSx0ayxjRyk7dmFyIFRRZT1nKCJqYXZhLnV0aWwiLCJMaW5rZWRIYXNoU2V0IiwxNzQpO2Z1bmN0aW9uIF9fZShlKXtlLmhlYWRlcj1uZXcgbGssZS50YWlsPW5ldyBsa31mdW5jdGlvbiBMbihlLG4pe3JldHVybiBicihlLG4sZS50YWlsLnByZXYsZS50YWlsKSwhMH1mdW5jdGlvbiBMcChlLG4pe2JyKGUsbixlLmhlYWRlcixlLmhlYWRlci5uZXh0XzApfWZ1bmN0aW9uIE10KGUsbil7YnIoZSxuLGUudGFpbC5wcmV2LGUudGFpbCl9ZnVuY3Rpb24gYnIoZSxuLHIsdCl7dmFyIG87bz1uZXcgbGssby52YWx1ZV8wPW4sby5wcmV2PXIsby5uZXh0XzA9dCx0LnByZXY9ci5uZXh0XzA9bywrK2Uuc2l6ZV8wfWZ1bmN0aW9uIHl5KGUpe3JldHVybiBybihlLnNpemVfMCE9MCksZS5oZWFkZXIubmV4dF8wLnZhbHVlXzB9ZnVuY3Rpb24gUmwoZSl7cmV0dXJuIHJuKGUuc2l6ZV8wIT0wKSxlLnRhaWwucHJldi52YWx1ZV8wfWZ1bmN0aW9uIGRuKGUsbil7dmFyIHIsdDtpZihkZihuLGUuc2l6ZV8wKSxuPj1lLnNpemVfMD4+MSlmb3IodD1lLnRhaWwscj1lLnNpemVfMDtyPm47LS1yKXQ9dC5wcmV2O2Vsc2UgZm9yKHQ9ZS5oZWFkZXIubmV4dF8wLHI9MDtyPG47KytyKXQ9dC5uZXh0XzA7cmV0dXJuIG5ldyBmX2UoZSxuLHQpfWZ1bmN0aW9uIGJRZShlKXtyZXR1cm4gZS5zaXplXzA9PTA/bnVsbDoocm4oZS5zaXplXzAhPTApLFphKGUsZS5oZWFkZXIubmV4dF8wKSl9ZnVuY3Rpb24gb2soZSl7cmV0dXJuIHJuKGUuc2l6ZV8wIT0wKSxaYShlLGUuaGVhZGVyLm5leHRfMCl9ZnVuY3Rpb24gSVFlKGUpe3JldHVybiBybihlLnNpemVfMCE9MCksWmEoZSxlLnRhaWwucHJldil9ZnVuY3Rpb24gWmEoZSxuKXt2YXIgcjtyZXR1cm4gcj1uLnZhbHVlXzAsbi5uZXh0XzAucHJldj1uLnByZXYsbi5wcmV2Lm5leHRfMD1uLm5leHRfMCxuLm5leHRfMD1uLnByZXY9bnVsbCxuLnZhbHVlXzA9bnVsbCwtLWUuc2l6ZV8wLHJ9ZnVuY3Rpb24ga2EoZSl7ZS5oZWFkZXIubmV4dF8wPWUudGFpbCxlLnRhaWwucHJldj1lLmhlYWRlcixlLmhlYWRlci5wcmV2PWUudGFpbC5uZXh0XzA9bnVsbCxlLnNpemVfMD0wfWZ1bmN0aW9uIHByKCl7X19lKHRoaXMpLGthKHRoaXMpfWZ1bmN0aW9uIGlrKGUpe19fZSh0aGlzKSxrYSh0aGlzKSxmdCh0aGlzLGUpfXAoNjcsMjA2Mix7MzoxLDQ6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDY3OjEsMTU6MX0scHIsaWspLGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIExuKHRoaXMsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe2thKHRoaXMpfSxsLmxpc3RJdGVyYXRvcl8xPWZ1bmN0aW9uKG4pe3JldHVybiBkbih0aGlzLG4pfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVfMH0sbC5zaXplXzA9MDt2YXIgeFFlPWcoImphdmEudXRpbCIsIkxpbmtlZExpc3QiLDY3KTtmdW5jdGlvbiBSQyhlLG4pe2JyKGUudGhpcyQwMSxuLGUuY3VycmVudE5vZGUucHJldixlLmN1cnJlbnROb2RlKSwrK2UuY3VycmVudEluZGV4LGUubGFzdE5vZGU9bnVsbH1mdW5jdGlvbiBEQyhlKXtyZXR1cm4gZS5jdXJyZW50Tm9kZSE9ZS50aGlzJDAxLnRhaWx9ZnVuY3Rpb24gdW4oZSl7cmV0dXJuIHJuKGUuY3VycmVudE5vZGUhPWUudGhpcyQwMS50YWlsKSxlLmxhc3ROb2RlPWUuY3VycmVudE5vZGUsZS5jdXJyZW50Tm9kZT1lLmN1cnJlbnROb2RlLm5leHRfMCwrK2UuY3VycmVudEluZGV4LGUubGFzdE5vZGUudmFsdWVfMH1mdW5jdGlvbiBkX2UoZSl7cmV0dXJuIHJuKGUuY3VycmVudE5vZGUucHJldiE9ZS50aGlzJDAxLmhlYWRlciksZS5sYXN0Tm9kZT1lLmN1cnJlbnROb2RlPWUuY3VycmVudE5vZGUucHJldiwtLWUuY3VycmVudEluZGV4LGUubGFzdE5vZGUudmFsdWVfMH1mdW5jdGlvbiBhayhlKXt2YXIgbjtmZighIWUubGFzdE5vZGUpLG49ZS5sYXN0Tm9kZS5uZXh0XzAsWmEoZS50aGlzJDAxLGUubGFzdE5vZGUpLGUuY3VycmVudE5vZGU9PWUubGFzdE5vZGU/ZS5jdXJyZW50Tm9kZT1uOi0tZS5jdXJyZW50SW5kZXgsZS5sYXN0Tm9kZT1udWxsfWZ1bmN0aW9uIGZfZShlLG4scil7dGhpcy50aGlzJDAxPWUsdGhpcy5jdXJyZW50Tm9kZT1yLHRoaXMuY3VycmVudEluZGV4PW59cCg5ODEsMSxDdSxmX2UpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmFkZF8xPWZ1bmN0aW9uKG4pe1JDKHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIERDKHRoaXMpfSxsLmhhc1ByZXZpb3VzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycmVudE5vZGUucHJldiE9dGhpcy50aGlzJDAxLmhlYWRlcn0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gdW4odGhpcyl9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJyZW50SW5kZXh9LGwucHJldmlvdXNfMD1mdW5jdGlvbigpe3JldHVybiBkX2UodGhpcyl9LGwucHJldmlvdXNJbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnJlbnRJbmRleC0xfSxsLnJlbW92ZT1mdW5jdGlvbigpe2FrKHRoaXMpfSxsLnNldF8xPWZ1bmN0aW9uKG4pe2ZmKCEhdGhpcy5sYXN0Tm9kZSksdGhpcy5sYXN0Tm9kZS52YWx1ZV8wPW59LGwuY3VycmVudEluZGV4PTAsbC5sYXN0Tm9kZT1udWxsLGcoImphdmEudXRpbCIsIkxpbmtlZExpc3QvTGlzdEl0ZXJhdG9ySW1wbCIsOTgxKTtmdW5jdGlvbiBsaygpe31wKDYxNywxLHt9LGxrKSxnKCJqYXZhLnV0aWwiLCJMaW5rZWRMaXN0L05vZGUiLDYxNyk7ZnVuY3Rpb24gc2soKXtzaz1GLF9HPW5ldyBnX2UscF9lPW5ldyBoX2V9cCgyMDU3LDEse30pO3ZhciBfRyxwX2U7ZygiamF2YS51dGlsIiwiTG9jYWxlIiwyMDU3KTtmdW5jdGlvbiBnX2UoKXt9cCg4NzMsMjA1Nyx7fSxnX2UpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiIifSxnKCJqYXZhLnV0aWwiLCJMb2NhbGUvMSIsODczKTtmdW5jdGlvbiBoX2UoKXt9cCg4NzQsMjA1Nyx7fSxoX2UpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJ1bmtub3duIn0sZygiamF2YS51dGlsIiwiTG9jYWxlLzQiLDg3NCk7ZnVuY3Rpb24gUG8oKXtDXy5jYWxsKHRoaXMpfWZ1bmN0aW9uIG1fZSgpe0lvLmNhbGwodGhpcywiVGhlcmUgaXMgbm8gbW9yZSBlbGVtZW50LiIpfXAoMTEyLDYzLHszOjEsMTAzOjEsNjM6MSw4MjoxLDExMjoxfSxQbyxtX2UpLGcoImphdmEudXRpbCIsIk5vU3VjaEVsZW1lbnRFeGNlcHRpb24iLDExMik7ZnVuY3Rpb24gVW8oZSxuKXtyZXR1cm4gRChlKT09PUQobil8fGUhPW51bGwmJlluKGUsbil9ZnVuY3Rpb24ga3AoZSl7cmV0dXJuIGUhPW51bGw/dXIoZSk6MH1mdW5jdGlvbiB3bChlKXtpZihlPT1udWxsKXRocm93IGIobmV3IF9oKTtyZXR1cm4gZX1mdW5jdGlvbiBGQyhlLG4pe2lmKGU9PW51bGwpdGhyb3cgYihuZXcgZGgobikpO3JldHVybiBlfWZ1bmN0aW9uIHd5KCl7d3k9RixkRz1uZXcgdWsobnVsbCl9ZnVuY3Rpb24gdmEoZSl7cmV0dXJuIHJuKGUucmVmIT1udWxsKSxlLnJlZn1mdW5jdGlvbiBQUWUoZSxuKXtlLnJlZiE9bnVsbCYmakFlKG4sZS5yZWYpfWZ1bmN0aW9uIE5RZShlKXtyZXR1cm4gZS5yZWYhPW51bGw/ZS5yZWY6bnVsbH1mdW5jdGlvbiB1ayhlKXt3eSgpLHRoaXMucmVmPWV9cCg0NzUsMSx7NDc1OjF9LHVrKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBuPT09dGhpcz8hMDpMKG4sNDc1KT8ocj1hKG4sNDc1KSxVbyh0aGlzLnJlZixyLnJlZikpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4ga3AodGhpcy5yZWYpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWYhPW51bGw/Ik9wdGlvbmFsLm9mKCIrejIodGhpcy5yZWYpKyIpIjoiT3B0aW9uYWwuZW1wdHkoKSJ9O3ZhciBkRztnKCJqYXZhLnV0aWwiLCJPcHRpb25hbCIsNDc1KTtmdW5jdGlvbiBvZigpe29mPUYsX2s9bmV3IEVfZX1mdW5jdGlvbiB6QyhlKXtyZXR1cm4gcm4oZS5wcmVzZW50KSxlLnJlZn1mdW5jdGlvbiB5X2UoZSl7cmV0dXJuIGUucHJlc2VudD9lLnJlZjowfWZ1bmN0aW9uIHdfZShlLG4pe3JldHVybiBlLnByZXNlbnQ/ZS5yZWY6bi5nZXRBc0RvdWJsZSgpfWZ1bmN0aW9uIEVfZSgpe3RoaXMucmVmPTAsdGhpcy5wcmVzZW50PSExfWZ1bmN0aW9uIGNrKGUpe29mKCksdGhpcy5yZWY9ZSx0aGlzLnByZXNlbnQ9ITB9cCg0MTQsMSx7NDE0OjF9LEVfZSxjayksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gbj09PXRoaXM/ITA6TChuLDQxNCk/KHI9YShuLDQxNCksdGhpcy5wcmVzZW50PT1yLnByZXNlbnQmJmlyKHRoaXMucmVmLHIucmVmKT09MCk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXNlbnQ/S3IodGhpcy5yZWYpOjB9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXNlbnQ/Ik9wdGlvbmFsRG91YmxlLm9mKCIrKCIiK3RoaXMucmVmKSsiKSI6Ik9wdGlvbmFsRG91YmxlLmVtcHR5KCkifSxsLnByZXNlbnQ9ITEsbC5yZWY9MDt2YXIgX2s7ZygiamF2YS51dGlsIiwiT3B0aW9uYWxEb3VibGUiLDQxNCk7ZnVuY3Rpb24gdHgoKXt0eD1GLENfZT1uZXcgdl9lfWZ1bmN0aW9uIEFRZShlKXtyZXR1cm4gZS5wcmVzZW50P2UucmVmOjB9ZnVuY3Rpb24gdl9lKCl7dGhpcy5yZWY9MCx0aGlzLnByZXNlbnQ9ITF9ZnVuY3Rpb24gU19lKGUpe3R4KCksdGhpcy5yZWY9ZSx0aGlzLnByZXNlbnQ9ITB9cCg1MjQsMSx7NTI0OjF9LHZfZSxTX2UpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIG49PT10aGlzPyEwOkwobiw1MjQpPyhyPWEobiw1MjQpLHRoaXMucHJlc2VudD09ci5wcmVzZW50JiZxbyh0aGlzLnJlZixyLnJlZik9PTApOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVzZW50P3RoaXMucmVmOjB9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXNlbnQ/Ik9wdGlvbmFsSW50Lm9mKCIrKCIiK3RoaXMucmVmKSsiKSI6Ik9wdGlvbmFsSW50LmVtcHR5KCkifSxsLnByZXNlbnQ9ITEsbC5yZWY9MDt2YXIgQ19lO2coImphdmEudXRpbCIsIk9wdGlvbmFsSW50Iiw1MjQpO2Z1bmN0aW9uIGZHKGUsbil7dmFyIHIsdCxvO2ZvcihWZShuKSxRRyhuIT1lKSxvPWUuaGVhcC5hcnJheS5sZW5ndGgsdD1uLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPXQubmV4dF8xKCksZWUoZS5oZWFwLFZlKHIpKTtyZXR1cm4gbyE9ZS5oZWFwLmFycmF5Lmxlbmd0aD8ocEcoZSwwKSwhMCk6ITF9ZnVuY3Rpb24gcEcoZSxuKXt2YXIgcjtuKjIrMT49ZS5oZWFwLmFycmF5Lmxlbmd0aHx8KHBHKGUsMipuKzEpLHI9MipuKzIscjxlLmhlYXAuYXJyYXkubGVuZ3RoJiZwRyhlLHIpLFRfZShlLG4pKX1mdW5jdGlvbiBUX2UoZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKHI9ZS5oZWFwLmFycmF5Lmxlbmd0aCxvPWxlKGUuaGVhcCxuKTtuKjIrMTxyJiYodD0oaT0yKm4rMSxzPWkrMSx1PWksczxyJiZlLmNtcC5jb21wYXJlXzEobGUoZS5oZWFwLHMpLGxlKGUuaGVhcCxpKSk8MCYmKHU9cyksdSksIShlLmNtcC5jb21wYXJlXzEobyxsZShlLmhlYXAsdCkpPDApKTspS2EoZS5oZWFwLG4sbGUoZS5oZWFwLHQpKSxuPXQ7S2EoZS5oZWFwLG4sbyl9ZnVuY3Rpb24gRXkoZSxuKXt2YXIgcix0O2ZvcihWZShuKSx0PWUuaGVhcC5hcnJheS5sZW5ndGgsZWUoZS5oZWFwLG4pO3Q+MDspe2lmKHI9dCx0PSh0LTEpLzJ8MCxlLmNtcC5jb21wYXJlXzEobGUoZS5oZWFwLHQpLG4pPD0wKXJldHVybiBLYShlLmhlYXAscixuKSwhMDtLYShlLmhlYXAscixsZShlLmhlYXAsdCkpfXJldHVybiBLYShlLmhlYXAsdCxuKSwhMH1mdW5jdGlvbiBkayhlKXt2YXIgbjtyZXR1cm4gbj1lLmhlYXAuYXJyYXkubGVuZ3RoPT0wP251bGw6bGUoZS5oZWFwLDApLG4hPW51bGwmJmZrKGUsMCksbn1mdW5jdGlvbiBiX2UoZSxuKXt2YXIgcjtyZXR1cm4gcj1uPT1udWxsPy0xOmZvKGUuaGVhcCxuLDApLHI8MD8hMTooZmsoZSxyKSwhMCl9ZnVuY3Rpb24gZmsoZSxuKXt2YXIgcjtyPU1jKGUuaGVhcCxlLmhlYXAuYXJyYXkubGVuZ3RoLTEpLG48ZS5oZWFwLmFycmF5Lmxlbmd0aCYmKEthKGUuaGVhcCxuLHIpLFRfZShlLG4pKX1mdW5jdGlvbiBveChlKXt0aGlzLmhlYXA9bmV3IF9pKDExKSx0aGlzLmNtcD0oTDEoKSxlKX1wKDUxMCwyMTAzLEdkLG94KSxsLmFkZEFsbD1mdW5jdGlvbihuKXtyZXR1cm4gZkcodGhpcyxuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7X2YodGhpcy5oZWFwLmFycmF5LDApfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybihuPT1udWxsPy0xOmZvKHRoaXMuaGVhcCxuLDApKSE9LTF9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgSV9lKHRoaXMpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBiX2UodGhpcyxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWFwLmFycmF5Lmxlbmd0aH0sbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB4ZSh0aGlzLDI1Nil9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB2eCh0aGlzLmhlYXAuYXJyYXkpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gSXModGhpcy5oZWFwLG4pfSxnKCJqYXZhLnV0aWwiLCJQcmlvcml0eVF1ZXVlIiw1MTApO2Z1bmN0aW9uIElfZShlKXt0aGlzLnRoaXMkMDE9ZX1wKDEyOTYsMSxzdCxJX2UpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmk8dGhpcy50aGlzJDAxLmhlYXAuYXJyYXkubGVuZ3RofSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBybih0aGlzLmk8dGhpcy50aGlzJDAxLmhlYXAuYXJyYXkubGVuZ3RoKSx0aGlzLmxhc3Q9dGhpcy5pKyssbGUodGhpcy50aGlzJDAxLmhlYXAsdGhpcy5sYXN0KX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtmZih0aGlzLmxhc3QhPS0xKSxmayh0aGlzLnRoaXMkMDEsdGhpcy5pPXRoaXMubGFzdCksdGhpcy5sYXN0PS0xfSxsLmk9MCxsLmxhc3Q9LTEsZygiamF2YS51dGlsIiwiUHJpb3JpdHlRdWV1ZS8xIiwxMjk2KTtmdW5jdGlvbiBnRygpe2dHPUY7dmFyIGUsbixyLHQ7Zm9yKG1HPUIoY3QsWHQsMjgsMjUsMTUsMSkseUc9QihjdCxYdCwyOCwzMywxNSwxKSx0PTE1MjU4Nzg5MDYyNWUtMTYsbj0zMjtuPj0wO24tLSl5R1tuXT10LHQqPS41O2ZvcihyPTEsZT0yNDtlPj0wO2UtLSltR1tlXT1yLHIqPS41fWZ1bmN0aW9uIGhHKGUpe3JldHVybiBmYShlLDI2KSp3MitmYShlLDI3KSpFMn1mdW5jdGlvbiBpeChlLG4pe3ZhciByLHQ7aWYoUUcobj4wKSwobiYtbik9PW4pcmV0dXJuIEtyKG4qZmEoZSwzMSkqNDY1NjYxMjg3MzA3NzM5M2UtMjUpO2RvIHI9ZmEoZSwzMSksdD1yJW47d2hpbGUoci10KyhuLTEpPDApO3JldHVybiBLcih0KX1mdW5jdGlvbiBmYShlLG4pe3ZhciByLHQsbyxpLHMsdTtyZXR1cm4gaT1lLnNlZWRoaSpjNitlLnNlZWRsbyoxNTAyLHU9ZS5zZWVkbG8qYzYrMTEscj1TLk1hdGguZmxvb3IodSpKUyksaSs9cix1LT1yKkhGLGklPUhGLGUuc2VlZGhpPWksZS5zZWVkbG89dSxuPD0yND9TLk1hdGguZmxvb3IoZS5zZWVkaGkqbUdbbl0pOihvPWUuc2VlZGhpKigxPDxuLTI0KSxzPVMuTWF0aC5mbG9vcihlLnNlZWRsbyp5R1tuXSksdD1vK3MsdD49MjE0NzQ4MzY0OCYmKHQtPTQyOTQ5NjcyOTYpLHQpfWZ1bmN0aW9uIExRZShlKXtyZXR1cm4gTnQoT2woSG8oZmEoZSwzMikpLDMyKSxIbyhmYShlLDMyKSkpfWZ1bmN0aW9uIHhfZShlLG4scil7ZS5zZWVkaGk9bl4xNTAyLGUuc2VlZGxvPXJeYzZ9ZnVuY3Rpb24ga1FlKGUsbil7eF9lKGUsU24oZXQoYjEobiwyNCksamIpKSxTbihldChuLGpiKSkpfWZ1bmN0aW9uIHBrKCl7Z0coKTt2YXIgZSxuLHI7cj1PUWUrKytEYXRlLm5vdygpLGU9S3IoUy5NYXRoLmZsb29yKHIqSlMpKSZqYixuPUtyKHItZSpIRiksdGhpcy5zZWVkaGk9ZV4xNTAyLHRoaXMuc2VlZGxvPW5eYzZ9ZnVuY3Rpb24gYXgoZSl7Z0coKSx4X2UodGhpcyxTbihldChiMShlLDI0KSxqYikpLFNuKGV0KGUsamIpKSl9cCgyMzQsMSx7MjM0OjF9LHBrLGF4KSxsLnNlZWRoaT0wLGwuc2VlZGxvPTA7dmFyIG1HLHlHLE9RZT0wO2coImphdmEudXRpbCIsIlJhbmRvbSIsMjM0KTtmdW5jdGlvbiB3RyhlKXtlLml0fHwoZS5pdD1lLmNvbGxlY3Rpb24uaXRlcmF0b3JfMCgpLGUuZXN0aW1hdGVTaXplPWUuY29sbGVjdGlvbi5zaXplXzEoKSl9ZnVuY3Rpb24gUF9lKGUsbil7cmV0dXJuIFZlKG4pLHdHKGUpLGUuaXQuaGFzTmV4dF8wKCk/KG4uYWNjZXB0KGUuaXQubmV4dF8xKCkpLCEwKTohMX1mdW5jdGlvbiB4ZShlLG4pe3RoaXMuY29sbGVjdGlvbj0oVmUoZSksZSksdGhpcy5jaGFyYWN0ZXJpc3RpY3M9biZIZD9uOm58NjR8S3N9ZnVuY3Rpb24gTzEoZSl7dGhpcy5pdD0oVmUoZSksZSksdGhpcy5jaGFyYWN0ZXJpc3RpY3M9MCx0aGlzLmVzdGltYXRlU2l6ZT1qU31mdW5jdGlvbiBOX2UoZSxuKXt0aGlzLml0PShWZShlKSxlKSx0aGlzLmNoYXJhY3RlcmlzdGljcz0xNjQ0OSx0aGlzLmVzdGltYXRlU2l6ZT1ufXAoMjUsMSxJYSx4ZSxPMSxOX2UpLGwuaGFzQ2hhcmFjdGVyaXN0aWNzPWZ1bmN0aW9uKG4pe3JldHVybih0aGlzLmNoYXJhY3RlcmlzdGljcyZuKSE9MH0sbC5jaGFyYWN0ZXJpc3RpY3NfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYXJhY3RlcmlzdGljc30sbC5lc3RpbWF0ZVNpemVfMD1mdW5jdGlvbigpe3JldHVybiB3Ryh0aGlzKSx0aGlzLmVzdGltYXRlU2l6ZX0sbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3dHKHRoaXMpLHRoaXMuaXQuZm9yRWFjaFJlbWFpbmluZyhuKX0sbC50cnlBZHZhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBQX2UodGhpcyxuKX0sbC5jaGFyYWN0ZXJpc3RpY3M9MCxsLmVzdGltYXRlU2l6ZT0wLGcoImphdmEudXRpbCIsIlNwbGl0ZXJhdG9ycy9JdGVyYXRvclNwbGl0ZXJhdG9yIiwyNSk7ZnVuY3Rpb24gbHgoZSl7eGUuY2FsbCh0aGlzLGUsMjEpfXAoNDk1LDI1LElhLGx4KSxnKCJqYXZhLnV0aWwiLCJTb3J0ZWRTZXQvMSIsNDk1KTtmdW5jdGlvbiBPcChlLG4pe2Zvcig7ZS50cnlBZHZhbmNlXzAobik7KTt9ZnVuY3Rpb24gRUcoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDYxMSwxLFhTLEVHKSxsLmFjY2VwdF8yPWZ1bmN0aW9uKG4pe3RoaXMuJCRvdXRlcl8wLmFjY2VwdChuKX0sZygiamF2YS51dGlsIiwiU3BsaXRlcmF0b3IvT2ZEb3VibGUvMG1ldGhvZHJlZiRhY2NlcHQkVHlwZSIsNjExKTtmdW5jdGlvbiB2RyhlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoNjEyLDEsWFMsdkcpLGwuYWNjZXB0XzI9ZnVuY3Rpb24obil7dGhpcy4kJG91dGVyXzAuYWNjZXB0KG4pfSxnKCJqYXZhLnV0aWwiLCJTcGxpdGVyYXRvci9PZkRvdWJsZS8xbWV0aG9kcmVmJGFjY2VwdCRUeXBlIiw2MTIpO2Z1bmN0aW9uIFNHKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCg2MTMsMSxXUyxTRyksbC5hY2NlcHRfMD1mdW5jdGlvbihuKXt0aGlzLiQkb3V0ZXJfMC5hY2NlcHQoSihuKSl9LGcoImphdmEudXRpbCIsIlNwbGl0ZXJhdG9yL09mSW50LzJtZXRob2RyZWYkYWNjZXB0JFR5cGUiLDYxMyk7ZnVuY3Rpb24gQ0coZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDYxNCwxLFdTLENHKSxsLmFjY2VwdF8wPWZ1bmN0aW9uKG4pe3RoaXMuJCRvdXRlcl8wLmFjY2VwdChKKG4pKX0sZygiamF2YS51dGlsIiwiU3BsaXRlcmF0b3IvT2ZJbnQvM21ldGhvZHJlZiRhY2NlcHQkVHlwZSIsNjE0KTtmdW5jdGlvbiBNUWUoZSxuKXtpZigwPmV8fGU+bil0aHJvdyBiKG5ldyB6JCgiZnJvbUluZGV4OiAwLCB0b0luZGV4OiAiK2UrIiwgbGVuZ3RoOiAiK24pKX1mdW5jdGlvbiBURyhlLG4pe3RoaXMuc2l6ZUVzdGltYXRlPWUsdGhpcy5jaGFyYWN0ZXJpc3RpY3M9biY2ND9ufEtzOm59cCg2MjUsMSxJYSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe016KHRoaXMsbil9LGwuaGFzQ2hhcmFjdGVyaXN0aWNzPWZ1bmN0aW9uKG4pe3JldHVybih0aGlzLmNoYXJhY3RlcmlzdGljcyZuKSE9MH0sbC5jaGFyYWN0ZXJpc3RpY3NfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYXJhY3RlcmlzdGljc30sbC5lc3RpbWF0ZVNpemVfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVFc3RpbWF0ZX0sbC5jaGFyYWN0ZXJpc3RpY3M9MCxsLnNpemVFc3RpbWF0ZT0wLGcoImphdmEudXRpbCIsIlNwbGl0ZXJhdG9ycy9CYXNlU3BsaXRlcmF0b3IiLDYyNSk7ZnVuY3Rpb24gQV9lKGUsbil7VEcuY2FsbCh0aGlzLGUsbil9cCg3MzYsNjI1LElhKSxsLmZvckVhY2hSZW1haW5pbmdfMD1mdW5jdGlvbihuKXtPcCh0aGlzLG4pfSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7TChuLDE4OSk/T3AodGhpcyxhKG4sMTg5KSk6T3AodGhpcyxuZXcgdkcobikpfSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxODkpP3RoaXMudHJ5QWR2YW5jZV8wKGEobiwxODkpKTp0aGlzLnRyeUFkdmFuY2VfMChuZXcgRUcobikpfSxnKCJqYXZhLnV0aWwiLCJTcGxpdGVyYXRvcnMvQWJzdHJhY3REb3VibGVTcGxpdGVyYXRvciIsNzM2KTtmdW5jdGlvbiBMX2UoZSxuKXtURy5jYWxsKHRoaXMsZSxuKX1wKDczNSw2MjUsSWEpLGwuZm9yRWFjaFJlbWFpbmluZ18wPWZ1bmN0aW9uKG4pe09wKHRoaXMsbil9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXtMKG4sMjAyKT9PcCh0aGlzLGEobiwyMDIpKTpPcCh0aGlzLG5ldyBDRyhuKSl9LGwudHJ5QWR2YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDIwMik/dGhpcy50cnlBZHZhbmNlXzAoYShuLDIwMikpOnRoaXMudHJ5QWR2YW5jZV8wKG5ldyBTRyhuKSl9LGcoImphdmEudXRpbCIsIlNwbGl0ZXJhdG9ycy9BYnN0cmFjdEludFNwbGl0ZXJhdG9yIiw3MzUpO2Z1bmN0aW9uIHN4KGUsbil7VEcuY2FsbCh0aGlzLGUsbil9cCg1MDAsNjI1LElhKSxnKCJqYXZhLnV0aWwiLCJTcGxpdGVyYXRvcnMvQWJzdHJhY3RTcGxpdGVyYXRvciIsNTAwKTtmdW5jdGlvbiBnayhlLG4pe2ZvcihWZShuKTtlLmluZGV4XzA8ZS5saW1pdDspZS5jb25zdW1lKG4sZS5pbmRleF8wKyspfWZ1bmN0aW9uIHV4KGUsbil7cmV0dXJuIFZlKG4pLGUuaW5kZXhfMDxlLmxpbWl0PyhlLmNvbnN1bWUobixlLmluZGV4XzArKyksITApOiExfWZ1bmN0aW9uIGtfZShlLG4pe3RoaXMuaW5kZXhfMD0wLHRoaXMubGltaXQ9ZSx0aGlzLmNoYXJhY3RlcmlzdGljcz1ufDY0fEtzfXAoNzA2LDEsSWEpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXtNeih0aGlzLG4pfSxsLmhhc0NoYXJhY3RlcmlzdGljcz1mdW5jdGlvbihuKXtyZXR1cm4odGhpcy5jaGFyYWN0ZXJpc3RpY3MmbikhPTB9LGwuY2hhcmFjdGVyaXN0aWNzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFyYWN0ZXJpc3RpY3N9LGwuZXN0aW1hdGVTaXplXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW1pdC10aGlzLmluZGV4XzB9LGwuY2hhcmFjdGVyaXN0aWNzPTAsbC5pbmRleF8wPTAsbC5saW1pdD0wLGcoImphdmEudXRpbCIsIlNwbGl0ZXJhdG9ycy9CYXNlQXJyYXlTcGxpdGVyYXRvciIsNzA2KTtmdW5jdGlvbiBSUWUoZSxuLHIpe24uYWNjZXB0KGUuYXJyYXlbcl0pfWZ1bmN0aW9uIE9fZShlLG4pe2tfZS5jYWxsKHRoaXMsbiwxMDQwKSx0aGlzLmFycmF5PWV9cCg5NjAsNzA2LElhLE9fZSksbC5jb25zdW1lPWZ1bmN0aW9uKG4scil7UlFlKHRoaXMsYShuLDQxKSxyKX0sbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe2drKHRoaXMsbil9LGwudHJ5QWR2YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXgodGhpcyxuKX0sZygiamF2YS51dGlsIiwiU3BsaXRlcmF0b3JzL0FycmF5U3BsaXRlcmF0b3IiLDk2MCk7ZnVuY3Rpb24gRFFlKGUsbixyKXtuLmFjY2VwdF8yKGUuYXJyYXlbcl0pfWZ1bmN0aW9uIE1fZShlLG4pe0ZRZS5jYWxsKHRoaXMsZSxlLmxlbmd0aCxuKX1mdW5jdGlvbiBGUWUoZSxuLHIpe2tfZS5jYWxsKHRoaXMsbixyKSx0aGlzLmFycmF5PWV9cCg3MDcsNzA2LElhLE1fZSksbC5jb25zdW1lPWZ1bmN0aW9uKG4scil7RFFlKHRoaXMsYShuLDE4OSkscil9LGwuZm9yRWFjaFJlbWFpbmluZ18wPWZ1bmN0aW9uKG4pe2drKHRoaXMsbil9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXtMKG4sMTg5KT9nayh0aGlzLGEobiwxODkpKTpnayh0aGlzLG5ldyB2RyhuKSl9LGwudHJ5QWR2YW5jZV8wPWZ1bmN0aW9uKG4pe3JldHVybiB1eCh0aGlzLG4pfSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxODkpP3V4KHRoaXMsYShuLDE4OSkpOnV4KHRoaXMsbmV3IEVHKG4pKX0sZygiamF2YS51dGlsIiwiU3BsaXRlcmF0b3JzL0RvdWJsZUFycmF5U3BsaXRlcmF0b3IiLDcwNyk7ZnVuY3Rpb24gYkcoKXtiRz1GLGJHKCksUl9lPW5ldyBEX2V9cCgyMDY2LDEsSWEpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXtNeih0aGlzLG4pfSxsLmhhc0NoYXJhY3RlcmlzdGljcz1mdW5jdGlvbihuKXtyZXR1cm4oMTY0NDgmbikhPTB9LGwuY2hhcmFjdGVyaXN0aWNzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gMTY0NDh9LGwuZXN0aW1hdGVTaXplXzA9ZnVuY3Rpb24oKXtyZXR1cm4gMH07dmFyIFJfZTtnKCJqYXZhLnV0aWwiLCJTcGxpdGVyYXRvcnMvRW1wdHlTcGxpdGVyYXRvciIsMjA2Nik7ZnVuY3Rpb24gSUcoZSl7VmUoZSl9ZnVuY3Rpb24geEcoZSl7cmV0dXJuIFZlKGUpLCExfWZ1bmN0aW9uIERfZSgpe31wKDk1OSwyMDY2LElhLERfZSksbC5mb3JFYWNoUmVtYWluaW5nXzA9ZnVuY3Rpb24obil7SUcobil9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXtMKG4sMjAyKT9JRyhhKG4sMjAyKSk6SUcobmV3IENHKG4pKX0sbC50cnlBZHZhbmNlXzA9ZnVuY3Rpb24obil7cmV0dXJuIHhHKG4pfSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyMDIpP3hHKGEobiwyMDIpKTp4RyhuZXcgU0cobikpfSxnKCJqYXZhLnV0aWwiLCJTcGxpdGVyYXRvcnMvRW1wdHlTcGxpdGVyYXRvci9PZkludCIsOTU5KTtmdW5jdGlvbiBjeChlLG4pe2VlKGUuYXJyYXlMaXN0LG4pfWZ1bmN0aW9uIE0xKGUsbil7cmV0dXJuIHZ5KG4sZS5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKSxsZShlLmFycmF5TGlzdCxuKX1mdW5jdGlvbiB6UWUoZSxuLHIpe3Z5KHIsZS5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKSxLYShlLmFycmF5TGlzdCxyLG4pfWZ1bmN0aW9uIF94KCl7dGhpcy5hcnJheUxpc3Q9bmV3IFF9ZnVuY3Rpb24gdnkoZSxuKXtpZihlPDB8fGU+PW4pdGhyb3cgYihuZXcgRiQpfXAoNTg4LDU2LGNpZSxfeCksbC5hZGRfMz1mdW5jdGlvbihuLHIpe3Z5KG4sdGhpcy5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKzEpLEExKHRoaXMuYXJyYXlMaXN0LG4scil9LGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIGVlKHRoaXMuYXJyYXlMaXN0LG4pfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7cmV0dXJuIHZ5KG4sdGhpcy5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKzEpLE9CKHRoaXMuYXJyYXlMaXN0LG4scil9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBxcih0aGlzLmFycmF5TGlzdCxuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7X2YodGhpcy5hcnJheUxpc3QuYXJyYXksMCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIGZvKHRoaXMuYXJyYXlMaXN0LG4sMCkhPS0xfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiByQyh0aGlzLmFycmF5TGlzdCxuKX0sbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7d2kodGhpcy5hcnJheUxpc3Qsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHZ5KG4sdGhpcy5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKSxsZSh0aGlzLmFycmF5TGlzdCxuKX0sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIGZvKHRoaXMuYXJyYXlMaXN0LG4sMCl9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5TGlzdC5hcnJheS5sZW5ndGg9PTB9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgVCh0aGlzLmFycmF5TGlzdCl9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7cmV0dXJuIHZ5KG4sdGhpcy5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKSxNYyh0aGlzLmFycmF5TGlzdCxuKX0sbC5yZW1vdmVSYW5nZT1mdW5jdGlvbihuLHIpe24wZSh0aGlzLmFycmF5TGlzdCxuLHIpfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7cmV0dXJuIHZ5KG4sdGhpcy5hcnJheUxpc3QuYXJyYXkubGVuZ3RoKSxLYSh0aGlzLmFycmF5TGlzdCxuLHIpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5TGlzdC5hcnJheS5sZW5ndGh9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe0RyKHRoaXMuYXJyYXlMaXN0LG4pfSxsLnN1Ykxpc3Q9ZnVuY3Rpb24obixyKXtyZXR1cm4gbmV3IE9jKHRoaXMuYXJyYXlMaXN0LG4scil9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB2eCh0aGlzLmFycmF5TGlzdC5hcnJheSl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiBJcyh0aGlzLmFycmF5TGlzdCxuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIG0wKHRoaXMuYXJyYXlMaXN0KX0sZygiamF2YS51dGlsIiwiVmVjdG9yIiw1ODgpO2Z1bmN0aW9uIEZfZShlKXt2YXIgbjtpZihuPWUuYXJyYXlMaXN0LmFycmF5Lmxlbmd0aCxuPjApcmV0dXJuIHZ5KG4tMSxlLmFycmF5TGlzdC5hcnJheS5sZW5ndGgpLE1jKGUuYXJyYXlMaXN0LG4tMSk7dGhyb3cgYihuZXcgUjBlKX1mdW5jdGlvbiAkUWUoZSxuKXtyZXR1cm4gZWUoZS5hcnJheUxpc3Qsbiksbn1mdW5jdGlvbiBQRygpe194LmNhbGwodGhpcyl9cCg4MjQsNTg4LGNpZSxQRyksZygiamF2YS51dGlsIiwiU3RhY2siLDgyNCk7ZnVuY3Rpb24gb2MoZSxuKXtyZXR1cm4gZS5idWlsZGVyP09uKGUuYnVpbGRlcixlLmRlbGltaXRlcik6ZS5idWlsZGVyPW5ldyBMYShlLnByZWZpeCksRzIoZS5idWlsZGVyLG4pLGV9ZnVuY3Rpb24gQlFlKGUsbil7dmFyIHI7cmV0dXJuIG4uYnVpbGRlciYmKHI9bi5idWlsZGVyLnN0cmluZy5sZW5ndGgsZS5idWlsZGVyP09uKGUuYnVpbGRlcixlLmRlbGltaXRlcik6ZS5idWlsZGVyPW5ldyBMYShlLnByZWZpeCkseWNlKGUuYnVpbGRlcixuLmJ1aWxkZXIsbi5wcmVmaXgubGVuZ3RoLHIpKSxlfWZ1bmN0aW9uIHpfZShlKXtyZXR1cm4gZS5idWlsZGVyP2Uuc3VmZml4Lmxlbmd0aD09MD9lLmJ1aWxkZXIuc3RyaW5nOmUuYnVpbGRlci5zdHJpbmcrKCIiK2Uuc3VmZml4KTplLmVtcHR5VmFsdWV9ZnVuY3Rpb24gT18oZSxuLHIpe3RoaXMuZGVsaW1pdGVyPShWZShlKSxlKSx0aGlzLnByZWZpeD0oVmUobiksbiksdGhpcy5zdWZmaXg9KFZlKHIpLHIpLHRoaXMuZW1wdHlWYWx1ZT10aGlzLnByZWZpeCsoIiIrdGhpcy5zdWZmaXgpfXAoMjEzLDEsezIxMzoxfSxPXyksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHpfZSh0aGlzKX0sZygiamF2YS51dGlsIiwiU3RyaW5nSm9pbmVyIiwyMTMpO2Z1bmN0aW9uICRfZShlKXtlLnJvb3Q9bnVsbCxlLnNpemVfMD0wfWZ1bmN0aW9uIEJfZShlLG4pe3ZhciByLHQsbztmb3Iobz1lLnJvb3Q7bzspe2lmKHI9ZS5jbXAuY29tcGFyZV8xKG4sby5rZXkpLHI9PTApcmV0dXJuIG87dD1yPDA/MDoxLG89by5jaGlsZFt0XX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBORyhlKXt2YXIgbixyO2lmKCFlLnJvb3QpcmV0dXJuIG51bGw7Zm9yKHI9ZS5yb290O249ci5jaGlsZFswXTspcj1uO3JldHVybiByfWZ1bmN0aW9uIEdfZShlKXt2YXIgbixyO2lmKCFlLnJvb3QpcmV0dXJuIG51bGw7Zm9yKHI9ZS5yb290O249ci5jaGlsZFsxXTspcj1uO3JldHVybiByfWZ1bmN0aW9uIFN5KGUsbixyKXt2YXIgdCxvLGk7Zm9yKG89bnVsbCxpPWUucm9vdDtpOyl7aWYodD1lLmNtcC5jb21wYXJlXzEobixpLmtleSksciYmdD09MClyZXR1cm4gaTt0Pj0wP2k9aS5jaGlsZFsxXToobz1pLGk9aS5jaGlsZFswXSl9cmV0dXJuIG99ZnVuY3Rpb24gJEMoZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1udWxsLGk9ZS5yb290O2k7KXtpZih0PWUuY21wLmNvbXBhcmVfMShuLGkua2V5KSxyJiZ0PT0wKXJldHVybiBpO3Q8PTA/aT1pLmNoaWxkWzBdOihvPWksaT1pLmNoaWxkWzFdKX1yZXR1cm4gb31mdW5jdGlvbiBIX2UoZSxuLHIpe3JldHVybiBuZXcgdmsoZSwoQ3koKSxDayksbnVsbCwhMSxuLHIpfWZ1bmN0aW9uIEFHKGUsbixyLHQsbyxpLHMsdSl7dmFyIGMsXzt0JiYoYz10LmNoaWxkWzBdLGMmJkFHKGUsbixyLGMsbyxpLHMsdSksaGsoZSxyLHQua2V5LG8saSxzLHUpJiZuLmFkZF8yKHQpLF89dC5jaGlsZFsxXSxfJiZBRyhlLG4scixfLG8saSxzLHUpKX1mdW5jdGlvbiBoayhlLG4scix0LG8saSxzKXt2YXIgdSxjO3JldHVybiEobi5mcm9tS2V5VmFsaWQoKSYmKGM9ZS5jbXAuY29tcGFyZV8xKHIsdCksYzwwfHwhbyYmYz09MCl8fG4udG9LZXlWYWxpZCgpJiYodT1lLmNtcC5jb21wYXJlXzEocixpKSx1PjB8fCFzJiZ1PT0wKSl9ZnVuY3Rpb24gVV9lKGUsbixyLHQpe3ZhciBvLGk7aWYobil7aWYobz1lLmNtcC5jb21wYXJlXzEoci5rZXksbi5rZXkpLG89PTApcmV0dXJuIHQudmFsdWVfMD1OQihuLHIudmFsdWVfMCksdC5mb3VuZD0hMCxuO2k9bzwwPzA6MSxuLmNoaWxkW2ldPVVfZShlLG4uY2hpbGRbaV0scix0KSxhZihuLmNoaWxkW2ldKSYmKGFmKG4uY2hpbGRbMS1pXSk/KG4uaXNSZWQ9ITAsbi5jaGlsZFswXS5pc1JlZD0hMSxuLmNoaWxkWzFdLmlzUmVkPSExKTphZihuLmNoaWxkW2ldLmNoaWxkW2ldKT9uPWR4KG4sMS1pKTphZihuLmNoaWxkW2ldLmNoaWxkWzEtaV0pJiYobj1xX2UobiwxLWkpKSl9ZWxzZSByZXR1cm4gcjtyZXR1cm4gbn1mdW5jdGlvbiBhZihlKXtyZXR1cm4hIWUmJmUuaXNSZWR9ZnVuY3Rpb24gV19lKGUsbixyKXt2YXIgdCxvO3JldHVybiB0PW5ldyB3ayhuLHIpLG89bmV3IEVrLGUucm9vdD1VX2UoZSxlLnJvb3QsdCxvKSxvLmZvdW5kfHwrK2Uuc2l6ZV8wLGUucm9vdC5pc1JlZD0hMSxvLnZhbHVlXzB9ZnVuY3Rpb24gal9lKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1uLHQ9bmV3IEVrLFZfZShlLHIsdCksdC52YWx1ZV8wfWZ1bmN0aW9uIExHKGUsbil7dmFyIHI7cmV0dXJuIHI9bmV3IEVrLHIubWF0Y2hWYWx1ZT0hMCxyLnZhbHVlXzA9bi5nZXRWYWx1ZSgpLFZfZShlLG4uZ2V0S2V5KCkscil9ZnVuY3Rpb24gVl9lKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKCFlLnJvb3QpcmV0dXJuITE7Zm9yKHM9bnVsbCxoPW51bGwsYz1uZXcgd2sobnVsbCxudWxsKSxvPTEsYy5jaGlsZFsxXT1lLnJvb3QsZj1jO2YuY2hpbGRbb107KV89byx1PWgsaD1mLGY9Zi5jaGlsZFtvXSx0PWUuY21wLmNvbXBhcmVfMShuLGYua2V5KSxvPXQ8MD8wOjEsdD09MCYmKCFyLm1hdGNoVmFsdWV8fFVvKGYudmFsdWVfMCxyLnZhbHVlXzApKSYmKHM9ZiksIShmJiZmLmlzUmVkKSYmIWFmKGYuY2hpbGRbb10pJiYoYWYoZi5jaGlsZFsxLW9dKT9oPWguY2hpbGRbX109ZHgoZixvKTphZihmLmNoaWxkWzEtb10pfHwobT1oLmNoaWxkWzEtX10sbSYmKCFhZihtLmNoaWxkWzEtX10pJiYhYWYobS5jaGlsZFtfXSk/KGguaXNSZWQ9ITEsbS5pc1JlZD0hMCxmLmlzUmVkPSEwKTooaT11LmNoaWxkWzFdPT1oPzE6MCxhZihtLmNoaWxkW19dKT91LmNoaWxkW2ldPXFfZShoLF8pOmFmKG0uY2hpbGRbMS1fXSkmJih1LmNoaWxkW2ldPWR4KGgsXykpLGYuaXNSZWQ9dS5jaGlsZFtpXS5pc1JlZD0hMCx1LmNoaWxkW2ldLmNoaWxkWzBdLmlzUmVkPSExLHUuY2hpbGRbaV0uY2hpbGRbMV0uaXNSZWQ9ITEpKSkpO3JldHVybiBzJiYoci5mb3VuZD0hMCxyLnZhbHVlXzA9cy52YWx1ZV8wLGYhPXMmJihkPW5ldyB3ayhmLmtleSxmLnZhbHVlXzApLEdRZShlLGMscyxkKSxoPT1zJiYoaD1kKSksaC5jaGlsZFtoLmNoaWxkWzFdPT1mPzE6MF09Zi5jaGlsZFtmLmNoaWxkWzBdPzA6MV0sLS1lLnNpemVfMCksZS5yb290PWMuY2hpbGRbMV0sZS5yb290JiYoZS5yb290LmlzUmVkPSExKSxyLmZvdW5kfWZ1bmN0aW9uIEdRZShlLG4scix0KXt2YXIgbyxpO2ZvcihpPW4sbz1pLmtleT09bnVsbHx8ZS5jbXAuY29tcGFyZV8xKHIua2V5LGkua2V5KT4wPzE6MDtpLmNoaWxkW29dIT1yOylpPWkuY2hpbGRbb10sbz1lLmNtcC5jb21wYXJlXzEoci5rZXksaS5rZXkpPjA/MTowO2kuY2hpbGRbb109dCx0LmlzUmVkPXIuaXNSZWQsdC5jaGlsZFswXT1yLmNoaWxkWzBdLHQuY2hpbGRbMV09ci5jaGlsZFsxXSxyLmNoaWxkWzBdPW51bGwsci5jaGlsZFsxXT1udWxsfWZ1bmN0aW9uIHFfZShlLG4pe3ZhciByO3JldHVybiByPTEtbixlLmNoaWxkW3JdPWR4KGUuY2hpbGRbcl0sciksZHgoZSxuKX1mdW5jdGlvbiBkeChlLG4pe3ZhciByLHQ7cmV0dXJuIHI9MS1uLHQ9ZS5jaGlsZFtyXSxlLmNoaWxkW3JdPXQuY2hpbGRbbl0sdC5jaGlsZFtuXT1lLGUuaXNSZWQ9ITAsdC5pc1JlZD0hMSx0fWZ1bmN0aW9uIFlfZShlLG4scix0LG8pe3JldHVybiBuZXcgdmsoZSwoQ3koKSxUayksbixyLHQsbyl9ZnVuY3Rpb24gS19lKGUsbixyKXtyZXR1cm4gbmV3IHZrKGUsKEN5KCksYmspLG4scixudWxsLCExKX1mdW5jdGlvbiBYX2UoKXttay5jYWxsKHRoaXMsbnVsbCl9ZnVuY3Rpb24gbWsoZSl7dGhpcy5yb290PW51bGwsdGhpcy5jbXA9KEwxKCksZXx8cUIpfXAoNTUzLDIwOTAsezM6MSw4NToxLDEzOToxLDEzMzoxfSxYX2UsbWspLGwuY2xlYXJfMD1mdW5jdGlvbigpeyRfZSh0aGlzKX0sbC5lbnRyeUl0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFFfZSh0aGlzKX0sbC5lbnRyeVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBlMWUodGhpcyl9LGwuZ2V0Q2VpbGluZ0VudHJ5PWZ1bmN0aW9uKG4pe3JldHVybiBTeSh0aGlzLG4sITApfSxsLmdldEVudHJ5PWZ1bmN0aW9uKG4pe3JldHVybiBCX2UodGhpcyxuKX0sbC5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuIE5HKHRoaXMpfSxsLmdldEZsb29yRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuICRDKHRoaXMsbiwhMCl9LGwuZ2V0SGlnaGVyRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuIFN5KHRoaXMsbiwhMSl9LGwuZ2V0TGFzdEVudHJ5PWZ1bmN0aW9uKCl7cmV0dXJuIEdfZSh0aGlzKX0sbC5nZXRMb3dlckVudHJ5PWZ1bmN0aW9uKG4pe3JldHVybiAkQyh0aGlzLG4sITEpfSxsLmhlYWRNYXA9ZnVuY3Rpb24obixyKXtyZXR1cm4gSF9lKHRoaXMsbixyKX0sbC5wdXQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gV19lKHRoaXMsbixyKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXtyZXR1cm4gal9lKHRoaXMsbil9LGwucmVtb3ZlRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuIExHKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wfSxsLnRhaWxNYXA9ZnVuY3Rpb24obixyKXtyZXR1cm4gS19lKHRoaXMsbixyKX0sbC5zaXplXzA9MCxnKCJqYXZhLnV0aWwiLCJUcmVlTWFwIiw1NTMpO2Z1bmN0aW9uIEpfZShlKXtyZXR1cm4gZS5sYXN0PWEoUEIoZS5pdGVyKSw0NCl9ZnVuY3Rpb24gWl9lKGUpe0VhKGUuaXRlciksTEcoZS50aGlzJDAxLGUubGFzdCksZS5sYXN0PW51bGx9ZnVuY3Rpb24gUV9lKGUpe3lrLmNhbGwodGhpcyxlLChDeSgpLFNrKSxudWxsLCExLG51bGwsITEpfWZ1bmN0aW9uIHlrKGUsbixyLHQsbyxpKXt2YXIgczt0aGlzLnRoaXMkMDE9ZSxzPW5ldyBRLEFHKGUscyxuLGUucm9vdCxyLHQsbyxpKSx0aGlzLml0ZXI9bmV3IHB0KHMsMCl9cCg1NTQsMSxzdCxRX2UseWspLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBKX2UodGhpcyl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHE1KHRoaXMuaXRlcil9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7Wl9lKHRoaXMpfSxnKCJqYXZhLnV0aWwiLCJUcmVlTWFwL0VudHJ5SXRlcmF0b3IiLDU1NCk7ZnVuY3Rpb24gZTFlKGUpe3RoaXMudGhpcyQwMT1lLFk1LmNhbGwodGhpcyxlKX1wKDExNDIsNjI5LERpLGUxZSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7JF9lKHRoaXMudGhpcyQwMSl9LGcoImphdmEudXRpbCIsIlRyZWVNYXAvRW50cnlTZXQiLDExNDIpO2Z1bmN0aW9uIHdrKGUsbil7WEkuY2FsbCh0aGlzLGUsbiksdGhpcy5jaGlsZD1CKEhRZSxIYiw0NDcsMiwwLDEpLHRoaXMuaXNSZWQ9ITB9cCg0NDcsMzk3LHs0OTQ6MSwzOTc6MSw0NDoxLDQ0NzoxfSx3ayksbC5pc1JlZD0hMTt2YXIgSFFlPWcoImphdmEudXRpbCIsIlRyZWVNYXAvTm9kZSIsNDQ3KTtmdW5jdGlvbiBFaygpe31wKDYzMCwxLHt9LEVrKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iU3RhdGU6IG12PSIrdGhpcy5tYXRjaFZhbHVlKyIgdmFsdWU9Iit0aGlzLnZhbHVlXzArIiBkb25lPSIrdGhpcy5kb25lXzArIiBmb3VuZD0iK3RoaXMuZm91bmR9LGwuZG9uZV8wPSExLGwuZm91bmQ9ITEsbC5tYXRjaFZhbHVlPSExLGcoImphdmEudXRpbCIsIlRyZWVNYXAvU3RhdGUiLDYzMCk7ZnVuY3Rpb24gZngoZSxuKXtyZXR1cm4gbiYmcHgoZSxuLmtleSk/bjpudWxsfWZ1bmN0aW9uIHB4KGUsbil7cmV0dXJuIGhrKGUudGhpcyQwMSxlLnR5cGVfMCxuLGUuZnJvbUtleSxlLmZyb21JbmNsdXNpdmUsZS50b0tleSxlLnRvSW5jbHVzaXZlKX1mdW5jdGlvbiB2ayhlLG4scix0LG8saSl7c3dpdGNoKHRoaXMudGhpcyQwMT1lLG4ub3JkaW5hbCl7Y2FzZSAyOmlmKGUuY21wLmNvbXBhcmVfMShvLHIpPDApdGhyb3cgYihuZXcgR2UoInN1Yk1hcDogIitvKyIgbGVzcyB0aGFuICIrcikpO2JyZWFrO2Nhc2UgMTplLmNtcC5jb21wYXJlXzEobyxvKTticmVhaztjYXNlIDM6ZS5jbXAuY29tcGFyZV8xKHIscil9dGhpcy50eXBlXzA9bix0aGlzLmZyb21LZXk9cix0aGlzLmZyb21JbmNsdXNpdmU9dCx0aGlzLnRvS2V5PW8sdGhpcy50b0luY2x1c2l2ZT1pfXAoNjMxLDIwOTAsekYsdmspLGwuZW50cnlJdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB5ayh0aGlzLnRoaXMkMDEsdGhpcy50eXBlXzAsdGhpcy5mcm9tS2V5LHRoaXMuZnJvbUluY2x1c2l2ZSx0aGlzLnRvS2V5LHRoaXMudG9JbmNsdXNpdmUpfSxsLmVudHJ5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFk1KHRoaXMpfSxsLmdldENlaWxpbmdFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gZngodGhpcyxTeSh0aGlzLnRoaXMkMDEsbiwhMCkpfSxsLmdldEVudHJ5PWZ1bmN0aW9uKG4pe3JldHVybiBmeCh0aGlzLEJfZSh0aGlzLnRoaXMkMDEsbikpfSxsLmdldEZpcnN0RW50cnk9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy50eXBlXzAuZnJvbUtleVZhbGlkKCk/dGhpcy5mcm9tSW5jbHVzaXZlP249U3kodGhpcy50aGlzJDAxLHRoaXMuZnJvbUtleSwhMCk6bj1TeSh0aGlzLnRoaXMkMDEsdGhpcy5mcm9tS2V5LCExKTpuPU5HKHRoaXMudGhpcyQwMSksbiYmcHgodGhpcyxuLmtleSk/bjpudWxsfSxsLmdldEZsb29yRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuIGZ4KHRoaXMsJEModGhpcy50aGlzJDAxLG4sITApKX0sbC5nZXRIaWdoZXJFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gZngodGhpcyxTeSh0aGlzLnRoaXMkMDEsbiwhMSkpfSxsLmdldExhc3RFbnRyeT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLnR5cGVfMC50b0tleVZhbGlkKCk/dGhpcy50b0luY2x1c2l2ZT9uPSRDKHRoaXMudGhpcyQwMSx0aGlzLnRvS2V5LCEwKTpuPSRDKHRoaXMudGhpcyQwMSx0aGlzLnRvS2V5LCExKTpuPUdfZSh0aGlzLnRoaXMkMDEpLG4mJnB4KHRoaXMsbi5rZXkpP246bnVsbH0sbC5nZXRMb3dlckVudHJ5PWZ1bmN0aW9uKG4pe3JldHVybiBmeCh0aGlzLCRDKHRoaXMudGhpcyQwMSxuLCExKSl9LGwuaGVhZE1hcD1mdW5jdGlvbihuLHIpe2lmKHRoaXMudHlwZV8wLnRvS2V5VmFsaWQoKSYmdGhpcy50aGlzJDAxLmNtcC5jb21wYXJlXzEobix0aGlzLnRvS2V5KT4wKXRocm93IGIobmV3IEdlKCJzdWJNYXA6ICIrbisiIGdyZWF0ZXIgdGhhbiAiK3RoaXMudG9LZXkpKTtyZXR1cm4gdGhpcy50eXBlXzAuZnJvbUtleVZhbGlkKCk/WV9lKHRoaXMudGhpcyQwMSx0aGlzLmZyb21LZXksdGhpcy5mcm9tSW5jbHVzaXZlLG4scik6SF9lKHRoaXMudGhpcyQwMSxuLHIpfSxsLnB1dD1mdW5jdGlvbihuLHIpe2lmKCFoayh0aGlzLnRoaXMkMDEsdGhpcy50eXBlXzAsbix0aGlzLmZyb21LZXksdGhpcy5mcm9tSW5jbHVzaXZlLHRoaXMudG9LZXksdGhpcy50b0luY2x1c2l2ZSkpdGhyb3cgYihuZXcgR2UobisiIG91dHNpZGUgdGhlIHJhbmdlICIrdGhpcy5mcm9tS2V5KyIgdG8gIit0aGlzLnRvS2V5KSk7cmV0dXJuIFdfZSh0aGlzLnRoaXMkMDEsbixyKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1uLGhrKHRoaXMudGhpcyQwMSx0aGlzLnR5cGVfMCxyLHRoaXMuZnJvbUtleSx0aGlzLmZyb21JbmNsdXNpdmUsdGhpcy50b0tleSx0aGlzLnRvSW5jbHVzaXZlKT9qX2UodGhpcy50aGlzJDAxLHIpOm51bGx9LGwucmVtb3ZlRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuIHB4KHRoaXMsbi5nZXRLZXkoKSkmJkxHKHRoaXMudGhpcyQwMSxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7aWYodGhpcy50eXBlXzAuZnJvbUtleVZhbGlkKCk/dGhpcy5mcm9tSW5jbHVzaXZlP3I9U3kodGhpcy50aGlzJDAxLHRoaXMuZnJvbUtleSwhMCk6cj1TeSh0aGlzLnRoaXMkMDEsdGhpcy5mcm9tS2V5LCExKTpyPU5HKHRoaXMudGhpcyQwMSksIShyJiZweCh0aGlzLHIua2V5KSYmcikpcmV0dXJuIDA7Zm9yKG49MCx0PW5ldyB5ayh0aGlzLnRoaXMkMDEsdGhpcy50eXBlXzAsdGhpcy5mcm9tS2V5LHRoaXMuZnJvbUluY2x1c2l2ZSx0aGlzLnRvS2V5LHRoaXMudG9JbmNsdXNpdmUpO3E1KHQuaXRlcik7dC5sYXN0PWEoUEIodC5pdGVyKSw0NCkpKytuO3JldHVybiBufSxsLnRhaWxNYXA9ZnVuY3Rpb24obixyKXtpZih0aGlzLnR5cGVfMC5mcm9tS2V5VmFsaWQoKSYmdGhpcy50aGlzJDAxLmNtcC5jb21wYXJlXzEobix0aGlzLmZyb21LZXkpPDApdGhyb3cgYihuZXcgR2UoInN1Yk1hcDogIituKyIgbGVzcyB0aGFuICIrdGhpcy5mcm9tS2V5KSk7cmV0dXJuIHRoaXMudHlwZV8wLnRvS2V5VmFsaWQoKT9ZX2UodGhpcy50aGlzJDAxLG4scix0aGlzLnRvS2V5LHRoaXMudG9JbmNsdXNpdmUpOktfZSh0aGlzLnRoaXMkMDEsbixyKX0sbC5mcm9tSW5jbHVzaXZlPSExLGwudG9JbmNsdXNpdmU9ITEsZygiamF2YS51dGlsIiwiVHJlZU1hcC9TdWJNYXAiLDYzMSk7ZnVuY3Rpb24gQ3koKXtDeT1GLFNrPW5ldyBneCgiQWxsIiwwKSxDaz1uZXcgbjFlLFRrPW5ldyByMWUsYms9bmV3IHQxZX1mdW5jdGlvbiBneChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFVRZShlKXtyZXR1cm4gQ3koKSx3bigobzFlKCksaTFlKSxlKX1mdW5jdGlvbiBXUWUoKXtyZXR1cm4gQ3koKSxQKEkoaHgsMSksVywzMDQsMCxbU2ssQ2ssVGssYmtdKX1wKDMwNCwyMixfNixneCksbC5mcm9tS2V5VmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC50b0tleVZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuITF9O3ZhciBTayxDayxUayxiayxoeD1jbigiamF2YS51dGlsIiwiVHJlZU1hcC9TdWJNYXBUeXBlIiwzMDQsZ24sV1FlLFVRZSk7ZnVuY3Rpb24gbjFlKCl7Z3guY2FsbCh0aGlzLCJIZWFkIiwxKX1wKDExNDMsMzA0LF82LG4xZSksbC50b0tleVZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGNuKCJqYXZhLnV0aWwiLCJUcmVlTWFwL1N1Yk1hcFR5cGUvMSIsMTE0MyxoeCxudWxsLG51bGwpO2Z1bmN0aW9uIHIxZSgpe2d4LmNhbGwodGhpcywiUmFuZ2UiLDIpfXAoMTE0NCwzMDQsXzYscjFlKSxsLmZyb21LZXlWYWxpZD1mdW5jdGlvbigpe3JldHVybiEwfSxsLnRvS2V5VmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sY24oImphdmEudXRpbCIsIlRyZWVNYXAvU3ViTWFwVHlwZS8yIiwxMTQ0LGh4LG51bGwsbnVsbCk7ZnVuY3Rpb24gdDFlKCl7Z3guY2FsbCh0aGlzLCJUYWlsIiwzKX1wKDExNDUsMzA0LF82LHQxZSksbC5mcm9tS2V5VmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sY24oImphdmEudXRpbCIsIlRyZWVNYXAvU3ViTWFwVHlwZS8zIiwxMTQ1LGh4LG51bGwsbnVsbCk7ZnVuY3Rpb24gbzFlKCl7bzFlPUYsaTFlPXluKChDeSgpLFAoSShoeCwxKSxXLDMwNCwwLFtTayxDayxUayxia10pKSl9dmFyIGkxZTtmdW5jdGlvbiBCQyhlLG4pe3JldHVybiBlLm1hcF8wLnB1dChuLCh6ZSgpLFMwKSk9PW51bGx9ZnVuY3Rpb24galFlKGUsbil7cmV0dXJuIGUubWFwXzAuY2VpbGluZ0tleShuKX1mdW5jdGlvbiBWUWUoZSxuKXtyZXR1cm4gZS5tYXBfMC5mbG9vcktleShuKX1mdW5jdGlvbiBJayhlLG4pe3JldHVybiBlLm1hcF8wLmhpZ2hlcktleShuKX1mdW5jdGlvbiB4ayhlLG4pe3JldHVybiBlLm1hcF8wLmxvd2VyS2V5KG4pfWZ1bmN0aW9uIFBrKGUsbil7cmV0dXJuIGUubWFwXzAucmVtb3ZlXzAobikhPW51bGx9ZnVuY3Rpb24ga0coKXt0aGlzLm1hcF8wPW5ldyBYX2V9ZnVuY3Rpb24gRmMoZSl7dGhpcy5tYXBfMD1uZXcgbWsoZSl9ZnVuY3Rpb24gVHkoZSl7dGhpcy5tYXBfMD1lfXAoMTU3LFNzLHszOjEsMjA6MSwzMToxLDE2OjEsMjc3OjEsMjE6MSw4NzoxLDE1NzoxfSxrRyxGYyxUeSksbC5zcGxpdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBseCh0aGlzKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gQkModGhpcyxuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy5tYXBfMC5jbGVhcl8wKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMubWFwXzAuY29udGFpbnNLZXkobil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBQayh0aGlzLG4pfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8wLnNpemVfMSgpfTt2YXIgcVFlPWcoImphdmEudXRpbCIsIlRyZWVTZXQiLDE1Nyk7ZnVuY3Rpb24gWVFlKGUsbixyKXtyZXR1cm4gZS5jb21wYXJlXzEobixyKTw9MD9yOm59ZnVuY3Rpb24gS1FlKGUsbixyKXtyZXR1cm4gZS5jb21wYXJlXzEobixyKTw9MD9uOnJ9ZnVuY3Rpb24gYTFlKGUpe3RoaXMuY29tcGFyYXRvcl8wPWV9cCgxMDgyLDEse30sYTFlKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gWVFlKHRoaXMuY29tcGFyYXRvcl8wLG4scil9LGcoImphdmEudXRpbC5mdW5jdGlvbiIsIkJpbmFyeU9wZXJhdG9yL2xhbWJkYSQwJFR5cGUiLDEwODIpO2Z1bmN0aW9uIGwxZShlKXt0aGlzLmNvbXBhcmF0b3JfMD1lfXAoMTA4MywxLHt9LGwxZSksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIEtRZSh0aGlzLmNvbXBhcmF0b3JfMCxuLHIpfSxnKCJqYXZhLnV0aWwuZnVuY3Rpb24iLCJCaW5hcnlPcGVyYXRvci9sYW1iZGEkMSRUeXBlIiwxMDgzKTtmdW5jdGlvbiBzMWUoKXt9cCg5NTIsMSx7fSxzMWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbn0sZygiamF2YS51dGlsLmZ1bmN0aW9uIiwiRnVuY3Rpb24vbGFtYmRhJDAkVHlwZSIsOTUyKTtmdW5jdGlvbiBieShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMzk1LDEsSW4sYnkpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiF0aGlzLiQkb3V0ZXJfMC50ZXN0XzAobil9LGcoImphdmEudXRpbC5mdW5jdGlvbiIsIlByZWRpY2F0ZS9sYW1iZGEkMiRUeXBlIiwzOTUpLHAoNTgxLDEsezU4MToxfSk7dmFyIHUxZT1nKCJqYXZhLnV0aWwubG9nZ2luZyIsIkhhbmRsZXIiLDU4MSk7ZnVuY3Rpb24gSXkoKXtJeT1GLE9HPW5ldyBjMWV9cCgyMTA3LDEsVVMpLGwuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiJEVU1NWSJ9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE5hbWUoKX07dmFyIE9HO2coImphdmEudXRpbC5sb2dnaW5nIiwiTGV2ZWwiLDIxMDcpO2Z1bmN0aW9uIGMxZSgpe31wKDE3MDYsMjEwNyxVUyxjMWUpLGwuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiJJTkZPIn0sZygiamF2YS51dGlsLmxvZ2dpbmciLCJMZXZlbC9MZXZlbEluZm8iLDE3MDYpO2Z1bmN0aW9uIFhRZShlLG4peyhteCgpLFBzP251bGw6bi5uYW1lXzApLmxlbmd0aD09MCYmcDFlKG4sbmV3IE1HKSx0byhlLmxvZ2dlck1hcCxQcz9udWxsOm4ubmFtZV8wLG4pfWZ1bmN0aW9uIF8xZShlLG4pe3ZhciByLHQsbyxpO3JldHVybiByPWEobmkoZS5sb2dnZXJNYXAsbiksNTI1KSxyfHwodD1uZXcgQWsobiksbz0obXgoKSxQcz9udWxsOnQubmFtZV8wKSxpPVlhKG8sMCxTLk1hdGgubWF4KDAsakkobyx4aSg0NikpKSkscmVuKHQsXzFlKGUsaSkpLChQcz9udWxsOnQubmFtZV8wKS5sZW5ndGg9PTAmJnAxZSh0LG5ldyBNRyksdG8oZS5sb2dnZXJNYXAsUHM/bnVsbDp0Lm5hbWVfMCx0KSx0KX1mdW5jdGlvbiBkMWUoKXt0aGlzLmxvZ2dlck1hcD1uZXcgc259ZnVuY3Rpb24gSlFlKCl7dmFyIGU7cmV0dXJuIE5rfHwoTms9bmV3IGQxZSxlPW5ldyBBaygiIiksbmVuKGUsKEl5KCksT0cpKSxYUWUoTmssZSkpLE5rfXAoMTg0MywxLHt9LGQxZSk7dmFyIE5rO2coImphdmEudXRpbC5sb2dnaW5nIiwiTG9nTWFuYWdlciIsMTg0Myk7ZnVuY3Rpb24gZjFlKGUpe3RoaXMubXNnPWUsbmMoKSxIbyhEYXRlLm5vdygpKX1wKDE4OTYsMSxVUyxmMWUpLGwudGhyb3duPW51bGwsZygiamF2YS51dGlsLmxvZ2dpbmciLCJMb2dSZWNvcmQiLDE4OTYpO2Z1bmN0aW9uIG14KCl7bXg9RixQcz0hMCxoMWU9ITEsbTFlPSExLHcxZT0hMSx5MWU9ITF9ZnVuY3Rpb24gWlFlKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKHQ9ZzFlKGUpLGk9MCx1PXQubGVuZ3RoO2k8dTsrK2kpRTFlKG4pO2ZvcihjPSFQcyYmZS51c2VQYXJlbnRIYW5kbGVycz9Qcz9udWxsOmUucGFyZW50XzA6bnVsbDtjOyl7Zm9yKHI9ZzFlKGMpLG89MCxzPXIubGVuZ3RoO288czsrK28pRTFlKG4pO2M9IVBzJiZjLnVzZVBhcmVudEhhbmRsZXJzP1BzP251bGw6Yy5wYXJlbnRfMDpudWxsfX1mdW5jdGlvbiBwMWUoZSxuKXtQc3x8ZWUoZS5oYW5kbGVycyxuKX1mdW5jdGlvbiBRUWUoZSl7dmFyIG4scjtpZihlLmxldmVsKXJldHVybiBlLmxldmVsO2ZvcihyPVBzP251bGw6ZS5wYXJlbnRfMDtyOyl7aWYobj1Qcz9udWxsOnIubGV2ZWwsbilyZXR1cm4gbjtyPVBzP251bGw6ci5wYXJlbnRfMH1yZXR1cm4gSXkoKSxPR31mdW5jdGlvbiBnMWUoZSl7cmV0dXJuIFBzP0IodTFlLF9pZSw1ODEsMCwwLDEpOmEoSXMoZS5oYW5kbGVycyxCKHUxZSxfaWUsNTgxLGUuaGFuZGxlcnMuYXJyYXkubGVuZ3RoLDAsMSkpLDg1Nil9ZnVuY3Rpb24gZWVuKGUsbixyKXt2YXIgdDsoaDFlPyhRUWUoZSksITApOm0xZXx8dzFlPyhJeSgpLCEwKTp5MWUmJihJeSgpLCExKSkmJih0PW5ldyBmMWUobiksdC50aHJvd249cixaUWUoZSx0KSl9ZnVuY3Rpb24gbmVuKGUsbil7UHN8fChlLmxldmVsPW4pfWZ1bmN0aW9uIHJlbihlLG4pe1BzfHxuJiYoZS5wYXJlbnRfMD1uKX1mdW5jdGlvbiBBayhlKXtteCgpLCFQcyYmKHRoaXMubmFtZV8wPWUsdGhpcy51c2VQYXJlbnRIYW5kbGVycz0hMCx0aGlzLmhhbmRsZXJzPW5ldyBRKX1mdW5jdGlvbiB0ZW4oKXtyZXR1cm4gbXgoKSxQcz9uZXcgQWsobnVsbCk6XzFlKEpRZSgpLCJjb20uZ29vZ2xlLmNvbW1vbi5iYXNlLlN0cmluZ3MiKX1wKDUyNSwxLHs1MjU6MX0sQWspLGwudXNlUGFyZW50SGFuZGxlcnM9ITE7dmFyIGgxZT0hMSxtMWU9ITEsUHM9ITEseTFlPSExLHcxZT0hMTtnKCJqYXZhLnV0aWwubG9nZ2luZyIsIkxvZ2dlciIsNTI1KTtmdW5jdGlvbiBFMWUoZSl7dmFyIG4scix0O249VGUodHlwZW9mIG4sInVuZGVmaW5lZCIpP251bGw6bmV3IHdkZSxuJiYoSXkoKSxyPSh0PTkwMCx0Pj1iYz8iZXJyb3IiOnQ+PTkwMD8id2FybiI6dD49ODAwPyJpbmZvIjoibG9nIikseWRlKHIsZS5tc2cpLGUudGhyb3duJiZKRyhuLHIsZS50aHJvd24sIkV4Y2VwdGlvbjogIiwhMCkpfWZ1bmN0aW9uIE1HKCl7fXAoODM1LDU4MSx7NTgxOjF9LE1HKSxnKCJqYXZhLnV0aWwubG9nZ2luZyIsIlNpbXBsZUNvbnNvbGVMb2dIYW5kbGVyIiw4MzUpO2Z1bmN0aW9uIGxmKGUsbixyLHQsbyl7cmV0dXJuIFZlKGUpLFZlKG4pLFZlKHIpLFZlKHQpLFZlKG8pLG5ldyBERyhlLG4sdCl9ZnVuY3Rpb24gbmEoZSxuLHIsdCl7cmV0dXJuIFZlKGUpLFZlKG4pLFZlKHIpLFZlKHQpLG5ldyBERyhlLG4sbmV3IHMxZSl9ZnVuY3Rpb24gcmEoKXtyYT1GLFJHPW5ldyBMaygiQ09OQ1VSUkVOVCIsMCksQ289bmV3IExrKCJJREVOVElUWV9GSU5JU0giLDEpLHNmPW5ldyBMaygiVU5PUkRFUkVEIiwyKX1mdW5jdGlvbiBMayhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIG9lbihlKXtyZXR1cm4gcmEoKSx3bigodjFlKCksUzFlKSxlKX1mdW5jdGlvbiBpZW4oKXtyZXR1cm4gcmEoKSxQKEkob28sMSksVywxMDgsMCxbUkcsQ28sc2ZdKX1wKDEwOCwyMix7MzoxLDM0OjEsMjI6MSwxMDg6MX0sTGspO3ZhciBSRyxDbyxzZixvbz1jbigiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3Rvci9DaGFyYWN0ZXJpc3RpY3MiLDEwOCxnbixpZW4sb2VuKTtmdW5jdGlvbiB2MWUoKXt2MWU9RixTMWU9eW4oKHJhKCksUChJKG9vLDEpLFcsMTA4LDAsW1JHLENvLHNmXSkpKX12YXIgUzFlO2Z1bmN0aW9uIERHKGUsbixyKXt0aGlzLnN1cHBsaWVyPWUsdGhpcy5hY2N1bXVsYXRvcj1uLE5lKCksdGhpcy5maW5pc2hlcj1yfXAoNzU4LDEse30sREcpLGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JJbXBsIiw3NTgpO2Z1bmN0aW9uIEMxZShlLG4pe3JldHVybiBlLmFkZEFsbChuKSxlfWZ1bmN0aW9uIGFlbihlLG4scil7cmV0dXJuIGxmKGUsbmV3IEYxZShuKSxuZXcgejFlLG5ldyAkMWUociksUChJKG9vLDEpLFcsMTA4LDAsW10pKX1mdW5jdGlvbiBsZW4oZSxuKXtyZXR1cm4gVHIobiwwLEZHKG5bMF0sZWMoMSkpKX1mdW5jdGlvbiBzZW4oZSxuLHIpe3JldHVybiBUcihuLDAsRkcoblswXSxyWzBdKSksbn1mdW5jdGlvbiB1ZW4oZSxuKXtyZXR1cm4gZWMoTnQoZWMoZS52YWx1ZV8wKS52YWx1ZV8wLG4udmFsdWVfMCkpfWZ1bmN0aW9uIGNlbihlLG4pe3JldHVybiBlLmFkZEFsbChuKSxlfWZ1bmN0aW9uIF9lbihlLG4pe3JldHVybiBmdChlLG4pLGV9ZnVuY3Rpb24gZGVuKGUsbixyKXt2YXIgdCxvO3Q9KHplKCksISFDVShyKSksbz1hKG4uZ2V0XzModCksMTUpLG98fChvPW5ldyBRLG4ucHV0KHQsbykpLG8uYWRkXzIocil9ZnVuY3Rpb24gZmVuKGUsbil7dmFyIHIsdCxvO2ZvcihvPW5ldyBzbix0PW4uZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSw0NCksQm4obyxyLmdldEtleSgpLGdlbihlLGEoci5nZXRWYWx1ZSgpLDE1KSkpO3JldHVybiBvfWZ1bmN0aW9uIHBlbihlLG4scil7dmFyIHQsbztmb3Iobz1uLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksNDQpLGUubWVyZ2UodC5nZXRLZXkoKSx0LmdldFZhbHVlKCkscik7cmV0dXJuIGV9ZnVuY3Rpb24gVDFlKGUsbil7cmV0dXJuIGFlbihuZXcgazFlLG5ldyBQMWUoZSksbil9ZnVuY3Rpb24gYjFlKGUsbil7cmV0dXJuIGxmKG5ldyBPMWUoZSksbmV3IE0xZShuKSxuZXcgUjFlKG4pLG5ldyBEMWUsUChJKG9vLDEpLFcsMTA4LDAsW10pKX1mdW5jdGlvbiBnZW4oZSxuKXt2YXIgcix0LG87Zm9yKHI9ZS5zdXBwbGllci5nZXRfNSgpLG89bi5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1vLm5leHRfMSgpLGUuYWNjdW11bGF0b3IuYWNjZXB0XzEocix0KTtyZXR1cm4gZS5maW5pc2hlci5hcHBseV8wKHIpfWZ1bmN0aW9uIEkxZSgpe31wKDEwNzQsMSx7fSxJMWUpLGwuYXBwbHlfMz1mdW5jdGlvbihuLHIpe3JldHVybiBCUWUoYShuLDIxMyksYShyLDIxMykpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiQ29sbGVjdG9ycy8xMG1ldGhvZHJlZiRtZXJnZSRUeXBlIiwxMDc0KTtmdW5jdGlvbiB4MWUoKXt9cCgxMDc1LDEse30seDFlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHpfZShhKG4sMjEzKSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzExbWV0aG9kcmVmJHRvU3RyaW5nJFR5cGUiLDEwNzUpO2Z1bmN0aW9uIFAxZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTA3NiwxLHt9LFAxZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiB6ZSgpLCEhQ1Uobil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzEybWV0aG9kcmVmJHRlc3QkVHlwZSIsMTA3Nik7ZnVuY3Rpb24gQmkoKXt9cCgxNDQsMSx7fSxCaSksbC5hY2NlcHRfMT1mdW5jdGlvbihuLHIpe2EobiwxNikuYWRkXzIocil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzIwbWV0aG9kcmVmJGFkZCRUeXBlIiwxNDQpO2Z1bmN0aW9uIEdpKCl7fXAoMTQ2LDEse30sR2kpLGwuZ2V0XzU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFF9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzIxbWV0aG9kcmVmJGN0b3IkVHlwZSIsMTQ2KTtmdW5jdGlvbiB2aCgpe31wKDM1OSwxLHt9LHZoKSxsLmdldF81PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBCcn0sZygiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3RvcnMvMjNtZXRob2RyZWYkY3RvciRUeXBlIiwzNTkpO2Z1bmN0aW9uIFNoKCl7fXAoMzYwLDEse30sU2gpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXtZcihhKG4sNDkpLHIpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiQ29sbGVjdG9ycy8yNG1ldGhvZHJlZiRhZGQkVHlwZSIsMzYwKTtmdW5jdGlvbiBOMWUoKXt9cCgxMDY5LDEse30sTjFlKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gQzFlKGEobiwxNSksYShyLDE2KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzRtZXRob2RyZWYkYWRkQWxsJFR5cGUiLDEwNjkpO2Z1bmN0aW9uIEExZSgpe31wKDEwNzMsMSx7fSxBMWUpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXtvYyhhKG4sMjEzKSxhKHIsNDg0KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzLzltZXRob2RyZWYkYWRkJFR5cGUiLDEwNzMpO2Z1bmN0aW9uIEwxZSgpe3RoaXMuZGVsaW1pdGVyXzA9IjssOyIsdGhpcy5wcmVmaXhfMT0iIix0aGlzLnN1ZmZpeF8yPSIifXAoMTA3MiwxLHt9LEwxZSksbC5nZXRfNT1mdW5jdGlvbigpe3JldHVybiBuZXcgT18odGhpcy5kZWxpbWl0ZXJfMCx0aGlzLnByZWZpeF8xLHRoaXMuc3VmZml4XzIpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiQ29sbGVjdG9ycy9sYW1iZGEkMTUkVHlwZSIsMTA3Mik7ZnVuY3Rpb24gazFlKCl7fXAoMTA3NywxLHt9LGsxZSksbC5nZXRfNT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPW5ldyBEYyxSYyhuLCh6ZSgpLCExKSxuZXcgUSksUmMobiwhMCxuZXcgUSksbn0sZygiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3RvcnMvbGFtYmRhJDIyJFR5cGUiLDEwNzcpO2Z1bmN0aW9uIE8xZShlKXt0aGlzLmlkZW50aXR5XzA9ZX1wKDEwNzgsMSx7fSxPMWUpLGwuZ2V0XzU9ZnVuY3Rpb24oKXtyZXR1cm4gUChJKFFyLDEpLE1lLDEsNSxbdGhpcy5pZGVudGl0eV8wXSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQyNSRUeXBlIiwxMDc4KTtmdW5jdGlvbiBNMWUoZSl7dGhpcy5vcF8wPWV9cCgxMDc5LDEse30sTTFlKSxsLmFjY2VwdF8xPWZ1bmN0aW9uKG4scil7bGVuKHRoaXMub3BfMCxtXyhuKSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQyNiRUeXBlIiwxMDc5KTtmdW5jdGlvbiBSMWUoZSl7dGhpcy5vcF8wPWV9cCgxMDgwLDEse30sUjFlKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gc2VuKHRoaXMub3BfMCxtXyhuKSxtXyhyKSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQyNyRUeXBlIiwxMDgwKTtmdW5jdGlvbiBEMWUoKXt9cCgxMDgxLDEse30sRDFlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG1fKG4pWzBdfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiQ29sbGVjdG9ycy9sYW1iZGEkMjgkVHlwZSIsMTA4MSk7ZnVuY3Rpb24gRkcoZSxuKXtyZXR1cm4gdWVuKGEoZSwxNjgpLGEobiwxNjgpKX1mdW5jdGlvbiB6Rygpe31wKDcyOCwxLHt9LHpHKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gRkcobixyKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3RvcnMvbGFtYmRhJDQkVHlwZSIsNzI4KTtmdW5jdGlvbiBIaSgpe31wKDE0NSwxLHt9LEhpKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gY2VuKGEobiwxNiksYShyLDE2KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQ0MiRUeXBlIiwxNDUpO2Z1bmN0aW9uIENoKCl7fXAoMzYxLDEse30sQ2gpLGwuYXBwbHlfMz1mdW5jdGlvbihuLHIpe3JldHVybiBfZW4oYShuLDQ5KSxhKHIsNDkpKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3RvcnMvbGFtYmRhJDUwJFR5cGUiLDM2MSk7ZnVuY3Rpb24gVGgoKXt9cCgzNjIsMSx7fSxUaCksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNDkpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiQ29sbGVjdG9ycy9sYW1iZGEkNTEkVHlwZSIsMzYyKTtmdW5jdGlvbiBGMWUoZSl7dGhpcy5jbGFzc2lmaWVyXzA9ZX1wKDEwNjgsMSx7fSxGMWUpLGwuYWNjZXB0XzE9ZnVuY3Rpb24obixyKXtkZW4odGhpcy5jbGFzc2lmaWVyXzAsYShuLDg1KSxyKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIkNvbGxlY3RvcnMvbGFtYmRhJDckVHlwZSIsMTA2OCk7ZnVuY3Rpb24gejFlKCl7fXAoMTA3MCwxLHt9LHoxZSksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIHBlbihhKG4sODUpLGEociw4NSksbmV3IE4xZSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQ4JFR5cGUiLDEwNzApO2Z1bmN0aW9uICQxZShlKXt0aGlzLmRvd25zdHJlYW1fMT1lfXAoMTA3MSwxLHt9LCQxZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBmZW4odGhpcy5kb3duc3RyZWFtXzEsYShuLDg1KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJDb2xsZWN0b3JzL2xhbWJkYSQ5JFR5cGUiLDEwNzEpO2Z1bmN0aW9uIHRFKGUpe2Uucm9vdD9lLnJvb3QuY2xvc2VfMCgpOihlLnRlcm1pbmF0ZWQ9ITAsaGVuKGUpKX1mdW5jdGlvbiBCMWUoZSxuKXtyZXR1cm4gZS5yb290P0IxZShlLnJvb3Qsbik6ZWUoZS5vbkNsb3NlLG4pLGV9ZnVuY3Rpb24gaGVuKGUpe3ZhciBuLHIsdCxvLGk7aWYoaT1uZXcgUSx3aShlLm9uQ2xvc2UsbmV3IGhkZShpKSksZS5vbkNsb3NlLmFycmF5Lmxlbmd0aD0wLGkuYXJyYXkubGVuZ3RoIT0wKXtmb3Iobj0oQWUoMCxpLmFycmF5Lmxlbmd0aCksYShpLmFycmF5WzBdLDgyKSkscj0xLHQ9aS5hcnJheS5sZW5ndGg7cjx0OysrcilvPShBZShyLGkuYXJyYXkubGVuZ3RoKSxhKGkuYXJyYXlbcl0sODIpKSxvIT1uJiZDWGUobixvKTtpZihMKG4sNjMpKXRocm93IGIoYShuLDYzKSk7aWYoTChuLDI5NikpdGhyb3cgYihhKG4sMjk2KSl9fWZ1bmN0aW9uIHgwKGUpe2Uucm9vdD94MChlLnJvb3QpOihQMChlKSxlLnRlcm1pbmF0ZWQ9ITApfWZ1bmN0aW9uIFAwKGUpe2lmKGUucm9vdClQMChlLnJvb3QpO2Vsc2UgaWYoZS50ZXJtaW5hdGVkKXRocm93IGIobmV3IHJvKCJTdHJlYW0gYWxyZWFkeSB0ZXJtaW5hdGVkLCBjYW4ndCBiZSBtb2RpZmllZCBvciB1c2VkIikpfWZ1bmN0aW9uIGtrKGUpe2U/KHRoaXMucm9vdD1lLHRoaXMub25DbG9zZT1udWxsKToodGhpcy5yb290PW51bGwsdGhpcy5vbkNsb3NlPW5ldyBRKX1mdW5jdGlvbiBtZW4oZSxuKXt2YXIgcjt0cnl7bi5ydW4oKX1jYXRjaCh0KXtpZih0PXdyKHQpLEwodCw4Mikpcj10LFJlKGUuYXJyYXkscik7ZWxzZSB0aHJvdyBiKHQpfX1wKDU1MCwxLHt9KSxsLmNsb3NlXzA9ZnVuY3Rpb24oKXt0RSh0aGlzKX0sbC50ZXJtaW5hdGVkPSExLGcoImphdmEudXRpbC5zdHJlYW0iLCJUZXJtaW5hdGFibGVTdHJlYW0iLDU1MCk7ZnVuY3Rpb24gRzFlKGUpe3ZhciBuO3JldHVybiBuPSRHKGUpLFQxKG4uY291bnQsMCk/KG9mKCksb2YoKSxfayk6KG9mKCksbmV3IGNrKEk1KG4uY291bnQsMCk/WEIobikvSV8obi5jb3VudCk6MCkpfWZ1bmN0aW9uICRHKGUpe3ZhciBuO3JldHVybiB4MChlKSxuPW5ldyBNMGUsT3AoZS5zcGxpdGVyYXRvcixuZXcgajFlKG4pKSxufWZ1bmN0aW9uIE9rKGUpe3ZhciBuO3JldHVybiBuPSRHKGUpLFQxKG4uY291bnQsMCk/KG9mKCksb2YoKSxfayk6KG9mKCksbmV3IGNrKG4ubWF4XzApKX1mdW5jdGlvbiBNayhlKXt2YXIgbjtyZXR1cm4gbj0kRyhlKSxUMShuLmNvdW50LDApPyhvZigpLG9mKCksX2spOihvZigpLG5ldyBjayhuLm1pbl8wKSl9ZnVuY3Rpb24geWVuKGUpe3ZhciBuO3JldHVybiBQMChlKSxuPW5ldyBIMWUoZSxlLnNwbGl0ZXJhdG9yLnNpemVFc3RpbWF0ZSxlLnNwbGl0ZXJhdG9yLmNoYXJhY3RlcmlzdGljc3w0KSxuZXcgQkcoZSxuKX1mdW5jdGlvbiB3ZW4oZSl7dmFyIG47cmV0dXJuIHgwKGUpLG49QihjdCxYdCwyOCwwLDE1LDEpLE9wKGUuc3BsaXRlcmF0b3IsbmV3IFcxZShuKSksbn1mdW5jdGlvbiBCRyhlLG4pe2trLmNhbGwodGhpcyxlKSx0aGlzLnNwbGl0ZXJhdG9yPW59ZnVuY3Rpb24gRWVuKGUsbil7cmV0dXJuIGVbZS5sZW5ndGhdPW59cCg4MjcsNTUwLFVGLEJHKSxsLmNsb3NlXzA9ZnVuY3Rpb24oKXt0RSh0aGlzKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIkRvdWJsZVN0cmVhbUltcGwiLDgyNyk7ZnVuY3Rpb24gdmVuKGUsbil7dmFyIHI7cmV0dXJuIGUub3JkZXJlZHx8KHI9QihjdCxYdCwyOCwwLDE1LDEpLE9wKGUudGhpcyQwMS5zcGxpdGVyYXRvcixuZXcgVTFlKHIpKSxtZGUocixEaWUoUUkucHJvdG90eXBlLmNvbXBhcmVfMCxRSSxbXSkpLGUub3JkZXJlZD1uZXcgTV9lKHIsZS5jaGFyYWN0ZXJpc3RpY3MpKSx1eChlLm9yZGVyZWQsbil9ZnVuY3Rpb24gSDFlKGUsbixyKXt0aGlzLnRoaXMkMDE9ZSxBX2UuY2FsbCh0aGlzLG4scil9ZnVuY3Rpb24gU2VuKGUsbil7cmV0dXJuIGVbZS5sZW5ndGhdPW59cCgxODQ3LDczNixJYSxIMWUpLGwudHJ5QWR2YW5jZV8wPWZ1bmN0aW9uKG4pe3JldHVybiB2ZW4odGhpcyxhKG4sMTg5KSl9LGwub3JkZXJlZD1udWxsLGcoImphdmEudXRpbC5zdHJlYW0iLCJEb3VibGVTdHJlYW1JbXBsLzIiLDE4NDcpO2Z1bmN0aW9uIFUxZShlKXt0aGlzLmxpc3RfMD1lfXAoMTg0OCwxLFhTLFUxZSksbC5hY2NlcHRfMj1mdW5jdGlvbihuKXtTZW4odGhpcy5saXN0XzAsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJEb3VibGVTdHJlYW1JbXBsLzIvbGFtYmRhJDAkVHlwZSIsMTg0OCk7ZnVuY3Rpb24gVzFlKGUpe3RoaXMuZW50cmllc18wPWV9cCgxODQ1LDEsWFMsVzFlKSxsLmFjY2VwdF8yPWZ1bmN0aW9uKG4pe0Vlbih0aGlzLmVudHJpZXNfMCxuKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIkRvdWJsZVN0cmVhbUltcGwvbGFtYmRhJDAkVHlwZSIsMTg0NSk7ZnVuY3Rpb24gajFlKGUpe3RoaXMuYWNjXzE9ZX1wKDE4NDYsMSxYUyxqMWUpLGwuYWNjZXB0XzI9ZnVuY3Rpb24obil7TzBlKHRoaXMuYWNjXzEsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJEb3VibGVTdHJlYW1JbXBsL2xhbWJkYSQyJFR5cGUiLDE4NDYpO2Z1bmN0aW9uIENlbihlKXtyZXR1cm4gMD49ZT9uZXcgSEc6VGVuKGUtMSl9ZnVuY3Rpb24gVGVuKGUpe3ZhciBuLHI7cmV0dXJuIDA+ZT9uZXcgSEc6KG49ZSsxLHI9bmV3IFYxZShuLGUpLG5ldyBHRyhudWxsLHIpKX1mdW5jdGlvbiBiZW4oZSxuKXtyZXR1cm4gZS5uZXh0XzA8PWUudmFsJGVuZEluY2x1c2l2ZTU/KG4uYWNjZXB0XzAoZS5uZXh0XzArKyksITApOiExfWZ1bmN0aW9uIFYxZShlLG4pe3RoaXMudmFsJHN0YXJ0SW5jbHVzaXZlND0wLHRoaXMudmFsJGVuZEluY2x1c2l2ZTU9bixMX2UuY2FsbCh0aGlzLGUsMTc0OTMpLHRoaXMubmV4dF8wPXRoaXMudmFsJHN0YXJ0SW5jbHVzaXZlNH1wKDEzOTcsNzM1LElhLFYxZSksbC50cnlBZHZhbmNlXzA9ZnVuY3Rpb24obil7cmV0dXJuIGJlbih0aGlzLGEobiwyMDIpKX0sbC5uZXh0XzA9MCxsLnZhbCRlbmRJbmNsdXNpdmU1PTAsbC52YWwkc3RhcnRJbmNsdXNpdmU0PTAsZygiamF2YS51dGlsLnN0cmVhbSIsIkludFN0cmVhbS81IiwxMzk3KTtmdW5jdGlvbiB5eChlKXt2YXIgbjtyZXR1cm4geDAoZSksbj1uZXcgcTBlLE9wKGUuc3BsaXRlcmF0b3IsbmV3IHExZShuKSksbn1mdW5jdGlvbiBJZW4oZSl7dmFyIG47cmV0dXJuIG49eXgoZSksVDEobi5jb3VudCwwKT8odHgoKSx0eCgpLENfZSk6KHR4KCksbmV3IFNfZShuLm1heF8wKSl9ZnVuY3Rpb24gR0coZSxuKXtray5jYWxsKHRoaXMsZSksdGhpcy5zcGxpdGVyYXRvcj1ufXAoODA2LDU1MCxVRixHRyksbC5jbG9zZV8wPWZ1bmN0aW9uKCl7dEUodGhpcyl9LGwuc3BsaXRlcmF0b3JfMT1mdW5jdGlvbigpe3JldHVybiB4MCh0aGlzKSx0aGlzLnNwbGl0ZXJhdG9yfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiSW50U3RyZWFtSW1wbCIsODA2KTtmdW5jdGlvbiBIRygpe2trLmNhbGwodGhpcyxudWxsKX1wKDgwNyw1NTAsVUYsSEcpLGwuY2xvc2VfMD1mdW5jdGlvbigpe3RFKHRoaXMpfSxsLnNwbGl0ZXJhdG9yXzE9ZnVuY3Rpb24oKXtyZXR1cm4geDAodGhpcyksYkcoKSxSX2V9LGcoImphdmEudXRpbC5zdHJlYW0iLCJJbnRTdHJlYW1JbXBsL0VtcHR5Iiw4MDcpO2Z1bmN0aW9uIHExZShlKXt0aGlzLmFjY18xPWV9cCgxNjg3LDEsV1MscTFlKSxsLmFjY2VwdF8wPWZ1bmN0aW9uKG4pe1YwZSh0aGlzLmFjY18xLG4pfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiSW50U3RyZWFtSW1wbC9sYW1iZGEkNCRUeXBlIiwxNjg3KTt2YXIgeGVuPUNyKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtIik7ZnVuY3Rpb24gTV8oKXtNXz1GLEloPW5ldyBkZGV9ZnVuY3Rpb24gTXAoZSxuKXtyZXR1cm4oUDAoZSksUHkobmV3IFNlKGUsbmV3IGpHKG4sZS5zcGxpdGVyYXRvcikpKSkudHJ5QWR2YW5jZShJaCl9ZnVuY3Rpb24gVG8oZSxuKXt2YXIgcjtyZXR1cm4gbi5maW5pc2hlci5hcHBseV8wKEsxZShlLG4uc3VwcGxpZXIuZ2V0XzUoKSwocj1uZXcgcGRlKG4pLHIpKSl9ZnVuY3Rpb24gWTFlKGUpe3ZhciBuO2Zvcih4MChlKSxuPTA7ZS5zcGxpdGVyYXRvci50cnlBZHZhbmNlKG5ldyBmZGUpOyluPU50KG4sMSk7cmV0dXJuIG59ZnVuY3Rpb24gVUcoZSl7dmFyIG47cmV0dXJuIFAwKGUpLG49bmV3IEJyLEpuKGUsbmV3IFExZShuKSl9ZnVuY3Rpb24gSm4oZSxuKXtyZXR1cm4gUDAoZSksbmV3IFNlKGUsbmV3IGpHKG4sZS5zcGxpdGVyYXRvcikpfWZ1bmN0aW9uIHh5KGUpe3ZhciBuO3JldHVybiB4MChlKSxuPW5ldyBSayxlLnNwbGl0ZXJhdG9yLnRyeUFkdmFuY2Uobik/KHd5KCksbmV3IHVrKFZlKG4udmFsdWVfMCkpKTood3koKSx3eSgpLGRHKX1mdW5jdGlvbiBObyhlLG4pe3ZhciByLHQ7cmV0dXJuIFAwKGUpLHQ9bmV3IFZHKG4sZS5zcGxpdGVyYXRvcikscj1uZXcgSjFlKHQpLG5ldyBTZShlLHIpfWZ1bmN0aW9uIExyKGUsbil7eDAoZSksZS5zcGxpdGVyYXRvci5mb3JFYWNoUmVtYWluaW5nKG4pfWZ1bmN0aW9uIHBvKGUsbil7cmV0dXJuIFAwKGUpLG5ldyBTZShlLG5ldyBWRyhuLGUuc3BsaXRlcmF0b3IpKX1mdW5jdGlvbiB1ZihlLG4pe3JldHVybiBQMChlKSxuZXcgQkcoZSxuZXcgdGRlKG4sZS5zcGxpdGVyYXRvcikpfWZ1bmN0aW9uIHd4KGUsbil7cmV0dXJuIFAwKGUpLG5ldyBHRyhlLG5ldyBpZGUobixlLnNwbGl0ZXJhdG9yKSl9ZnVuY3Rpb24gY2YoZSxuKXtyZXR1cm4gR0MoZSwoVmUobiksbmV3IGExZShuKSkpfWZ1bmN0aW9uIGJoKGUsbil7cmV0dXJuIEdDKGUsKFZlKG4pLG5ldyBsMWUobikpKX1mdW5jdGlvbiBLMWUoZSxuLHIpe3ZhciB0O3JldHVybiB4MChlKSx0PW5ldyBSayx0LnZhbHVlXzA9bixlLnNwbGl0ZXJhdG9yLmZvckVhY2hSZW1haW5pbmcobmV3IGdkZSh0LHIpKSx0LnZhbHVlXzB9ZnVuY3Rpb24gR0MoZSxuKXt2YXIgcjtyZXR1cm4gcj1uZXcgUmssZS5zcGxpdGVyYXRvci50cnlBZHZhbmNlKHIpPyh3eSgpLG5ldyB1ayhWZShLMWUoZSxyLnZhbHVlXzAsbikpKSk6KHgwKGUpLHd5KCksd3koKSxkRyl9ZnVuY3Rpb24gWDFlKGUpe3JldHVybiBQMChlKSx4aCghMCwibiBtYXkgbm90IGJlIG5lZ2F0aXZlIiksbmV3IFNlKGUsbmV3IHVkZShlLnNwbGl0ZXJhdG9yKSl9ZnVuY3Rpb24gV0coZSl7dmFyIG47cmV0dXJuIFAwKGUpLG49KEwxKCksTDEoKSxuayksRXgoZSxuKX1mdW5jdGlvbiBFeChlLG4pe3ZhciByO3JldHVybiBQMChlKSxyPW5ldyBlZGUoZSxlLnNwbGl0ZXJhdG9yLmVzdGltYXRlU2l6ZV8wKCksZS5zcGxpdGVyYXRvci5jaGFyYWN0ZXJpc3RpY3NfMCgpfDQsbiksbmV3IFNlKGUscil9ZnVuY3Rpb24gUHkoZSl7cmV0dXJuIHgwKGUpLGUuc3BsaXRlcmF0b3J9ZnVuY3Rpb24gUGVuKGUsbil7dmFyIHI7cmV0dXJuIHI9YShUbyhlLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxDbyldKSkpLDE1KSxyLnRvQXJyYXlfMCgkOGUoci5zaXplXzEoKSkpfWZ1bmN0aW9uIFNlKGUsbil7TV8oKSxray5jYWxsKHRoaXMsZSksdGhpcy5zcGxpdGVyYXRvcj1ufWZ1bmN0aW9uIE5lbihlLG4scil7cmV0dXJuIE1fKCksZS5hY2N1bXVsYXRvci5hY2NlcHRfMShuLHIpLG59ZnVuY3Rpb24gQWVuKGUsbixyKXtNXygpLF9kZShlLG4uYXBwbHlfMyhlLnZhbHVlXzAscikpfXAoMjYsNTUwLHs1MzM6MSw2ODc6MSw4NDg6MX0sU2UpLGwuY2xvc2VfMD1mdW5jdGlvbigpe3RFKHRoaXMpfTt2YXIgSWg7ZygiamF2YS51dGlsLnN0cmVhbSIsIlN0cmVhbUltcGwiLDI2KTtmdW5jdGlvbiBMZW4oZSl7Zm9yKDshZS5uZXh0XzA7KWlmKCFsZGUoZS52YWwkc3BsaXRlcmF0b3JPZlN0cmVhbXM1LG5ldyBaMWUoZSkpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGtlbihlLG4pe24mJihlLm5leHRTdHJlYW09bixlLm5leHRfMD0oeDAobiksbi5zcGxpdGVyYXRvcikpfWZ1bmN0aW9uIEoxZShlKXt0aGlzLnZhbCRzcGxpdGVyYXRvck9mU3RyZWFtczU9ZSxzeC5jYWxsKHRoaXMsalMsMCl9cCgxMTAyLDUwMCxJYSxKMWUpLGwudHJ5QWR2YW5jZT1mdW5jdGlvbihuKXtmb3IoO0xlbih0aGlzKTspe2lmKHRoaXMubmV4dF8wLnRyeUFkdmFuY2UobikpcmV0dXJuITA7dEUodGhpcy5uZXh0U3RyZWFtKSx0aGlzLm5leHRTdHJlYW09bnVsbCx0aGlzLm5leHRfMD1udWxsfXJldHVybiExfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC8xIiwxMTAyKTtmdW5jdGlvbiBaMWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDExMDMsMSxKZSxaMWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2tlbih0aGlzLiQkb3V0ZXJfMCxhKG4sODQ4KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsLzEvbGFtYmRhJDAkVHlwZSIsMTEwMyk7ZnVuY3Rpb24gUTFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxMTA0LDEsSW4sUTFlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gWXIodGhpcy4kJG91dGVyXzAsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsLzFtZXRob2RyZWYkYWRkJFR5cGUiLDExMDQpO2Z1bmN0aW9uIGVkZShlLG4scix0KXt0aGlzLnRoaXMkMDE9ZSx0aGlzLnZhbCRjb21wYXJhdG9yNT10LHN4LmNhbGwodGhpcyxuLHIpfXAoMTEwNSw1MDAsSWEsZWRlKSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHRoaXMub3JkZXJlZHx8KHI9bmV3IFEsdGhpcy50aGlzJDAxLnNwbGl0ZXJhdG9yLmZvckVhY2hSZW1haW5pbmcobmV3IG5kZShyKSksTmUoKSxEcihyLHRoaXMudmFsJGNvbXBhcmF0b3I1KSx0aGlzLm9yZGVyZWQ9bmV3IHhlKHIsMTYpKSxQX2UodGhpcy5vcmRlcmVkLG4pfSxsLm9yZGVyZWQ9bnVsbCxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC81IiwxMTA1KTtmdW5jdGlvbiBuZGUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDExMDYsMSxKZSxuZGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2VlKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC81LzJtZXRob2RyZWYkYWRkJFR5cGUiLDExMDYpO2Z1bmN0aW9uIE9lbihlLG4scil7ZS5maWx0ZXIudGVzdF8wKHIpJiYoZS5mb3VuZD0hMCxuLmFjY2VwdChyKSl9ZnVuY3Rpb24gakcoZSxuKXtzeC5jYWxsKHRoaXMsbi5lc3RpbWF0ZVNpemVfMCgpLG4uY2hhcmFjdGVyaXN0aWNzXzAoKSYtMTY0NDkpLFZlKGUpLHRoaXMuZmlsdGVyPWUsdGhpcy5vcmlnaW5hbD1ufXAoNzM3LDUwMCxJYSxqRyksbC50cnlBZHZhbmNlPWZ1bmN0aW9uKG4pe2Zvcih0aGlzLmZvdW5kPSExOyF0aGlzLmZvdW5kJiZ0aGlzLm9yaWdpbmFsLnRyeUFkdmFuY2UobmV3IHJkZSh0aGlzLG4pKTspO3JldHVybiB0aGlzLmZvdW5kfSxsLmZvdW5kPSExLGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL0ZpbHRlclNwbGl0ZXJhdG9yIiw3MzcpO2Z1bmN0aW9uIHJkZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5hY3Rpb25fMT1ufXAoMTA5NiwxLEplLHJkZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7T2VuKHRoaXMuJCRvdXRlcl8wLHRoaXMuYWN0aW9uXzEsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL0ZpbHRlclNwbGl0ZXJhdG9yL2xhbWJkYSQwJFR5cGUiLDEwOTYpO2Z1bmN0aW9uIE1lbihlLG4scil7bi5hY2NlcHRfMihlLm1hcF8wLmFwcGx5QXNEb3VibGUocikpfWZ1bmN0aW9uIFJlbihlLG4pe3JldHVybiBlLm9yaWdpbmFsLnRyeUFkdmFuY2UobmV3IG9kZShlLG4pKX1mdW5jdGlvbiB0ZGUoZSxuKXtBX2UuY2FsbCh0aGlzLG4uZXN0aW1hdGVTaXplXzAoKSxuLmNoYXJhY3RlcmlzdGljc18wKCkmLTYpLFZlKGUpLHRoaXMubWFwXzA9ZSx0aGlzLm9yaWdpbmFsPW59cCgxMDkxLDczNixJYSx0ZGUpLGwudHJ5QWR2YW5jZV8wPWZ1bmN0aW9uKG4pe3JldHVybiBSZW4odGhpcyxhKG4sMTg5KSl9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL01hcFRvRG91YmxlU3BsaXRlcmF0b3IiLDEwOTEpO2Z1bmN0aW9uIG9kZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5hY3Rpb25fMT1ufXAoMTA5NSwxLEplLG9kZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7TWVuKHRoaXMuJCRvdXRlcl8wLHRoaXMuYWN0aW9uXzEsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL01hcFRvRG91YmxlU3BsaXRlcmF0b3IvbGFtYmRhJDAkVHlwZSIsMTA5NSk7ZnVuY3Rpb24gRGVuKGUsbixyKXtuLmFjY2VwdF8wKGUubWFwXzAuYXBwbHlBc0ludChyKSl9ZnVuY3Rpb24gRmVuKGUsbil7cmV0dXJuIGUub3JpZ2luYWwudHJ5QWR2YW5jZShuZXcgYWRlKGUsbikpfWZ1bmN0aW9uIGlkZShlLG4pe0xfZS5jYWxsKHRoaXMsbi5lc3RpbWF0ZVNpemVfMCgpLG4uY2hhcmFjdGVyaXN0aWNzXzAoKSYtNiksVmUoZSksdGhpcy5tYXBfMD1lLHRoaXMub3JpZ2luYWw9bn1wKDEwOTAsNzM1LElhLGlkZSksbC50cnlBZHZhbmNlXzA9ZnVuY3Rpb24obil7cmV0dXJuIEZlbih0aGlzLGEobiwyMDIpKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIlN0cmVhbUltcGwvTWFwVG9JbnRTcGxpdGVyYXRvciIsMTA5MCk7ZnVuY3Rpb24gYWRlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLmFjdGlvbl8xPW59cCgxMDk0LDEsSmUsYWRlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtEZW4odGhpcy4kJG91dGVyXzAsdGhpcy5hY3Rpb25fMSxuKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIlN0cmVhbUltcGwvTWFwVG9JbnRTcGxpdGVyYXRvci9sYW1iZGEkMCRUeXBlIiwxMDk0KTtmdW5jdGlvbiB6ZW4oZSxuLHIpe24uYWNjZXB0KGUubWFwXzAuYXBwbHlfMChyKSl9ZnVuY3Rpb24gbGRlKGUsbil7cmV0dXJuIGUub3JpZ2luYWwudHJ5QWR2YW5jZShuZXcgc2RlKGUsbikpfWZ1bmN0aW9uIFZHKGUsbil7c3guY2FsbCh0aGlzLG4uZXN0aW1hdGVTaXplXzAoKSxuLmNoYXJhY3RlcmlzdGljc18wKCkmLTYpLFZlKGUpLHRoaXMubWFwXzA9ZSx0aGlzLm9yaWdpbmFsPW59cCg3MzQsNTAwLElhLFZHKSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIGxkZSh0aGlzLG4pfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC9NYXBUb09ialNwbGl0ZXJhdG9yIiw3MzQpO2Z1bmN0aW9uIHNkZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5hY3Rpb25fMT1ufXAoMTA5MywxLEplLHNkZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7emVuKHRoaXMuJCRvdXRlcl8wLHRoaXMuYWN0aW9uXzEsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL01hcFRvT2JqU3BsaXRlcmF0b3IvbGFtYmRhJDAkVHlwZSIsMTA5Myk7ZnVuY3Rpb24gdWRlKGUpe3N4LmNhbGwodGhpcyxlLmhhc0NoYXJhY3RlcmlzdGljcyg2NCk/bkIoMCxobChlLmVzdGltYXRlU2l6ZV8wKCksMSkpOmpTLGUuY2hhcmFjdGVyaXN0aWNzXzAoKSksdGhpcy5za2lwPTEsdGhpcy5vcmlnaW5hbD1lfXAoMTA5Miw1MDAsSWEsdWRlKSxsLnRyeUFkdmFuY2U9ZnVuY3Rpb24obil7Zm9yKDtJNSh0aGlzLnNraXAsMCk7KXtpZighdGhpcy5vcmlnaW5hbC50cnlBZHZhbmNlKG5ldyBjZGUpKXJldHVybiExO3RoaXMuc2tpcD1obCh0aGlzLnNraXAsMSl9cmV0dXJuIHRoaXMub3JpZ2luYWwudHJ5QWR2YW5jZShuKX0sbC5za2lwPTAsZygiamF2YS51dGlsLnN0cmVhbSIsIlN0cmVhbUltcGwvU2tpcFNwbGl0ZXJhdG9yIiwxMDkyKTtmdW5jdGlvbiBjZGUoKXt9cCgxMDk3LDEsSmUsY2RlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL1NraXBTcGxpdGVyYXRvci9sYW1iZGEkMCRUeXBlIiwxMDk3KTtmdW5jdGlvbiBfZGUoZSxuKXtlLnZhbHVlXzA9bn1mdW5jdGlvbiBSaygpe31wKDYyNiwxLEplLFJrKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtfZGUodGhpcyxuKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIlN0cmVhbUltcGwvVmFsdWVDb25zdW1lciIsNjI2KTtmdW5jdGlvbiBkZGUoKXt9cCgxMDk4LDEsSmUsZGRlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtNXygpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC9sYW1iZGEkMCRUeXBlIiwxMDk4KTtmdW5jdGlvbiBmZGUoKXt9cCgxMDk5LDEsSmUsZmRlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtNXygpfSxnKCJqYXZhLnV0aWwuc3RyZWFtIiwiU3RyZWFtSW1wbC9sYW1iZGEkMSRUeXBlIiwxMDk5KTtmdW5jdGlvbiBwZGUoZSl7dGhpcy5jb2xsZWN0b3JfMD1lfXAoMTEwMCwxLHt9LHBkZSksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIE5lbih0aGlzLmNvbGxlY3Rvcl8wLG4scil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL2xhbWJkYSQ0JFR5cGUiLDExMDApO2Z1bmN0aW9uIGdkZShlLG4pe3RoaXMuY29uc3VtZXJfMD1lLHRoaXMuYWNjdW11bGF0b3JfMT1ufXAoMTEwMSwxLEplLGdkZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7QWVuKHRoaXMuY29uc3VtZXJfMCx0aGlzLmFjY3VtdWxhdG9yXzEsbil9LGcoImphdmEudXRpbC5zdHJlYW0iLCJTdHJlYW1JbXBsL2xhbWJkYSQ1JFR5cGUiLDExMDEpO2Z1bmN0aW9uIGhkZShlKXt0aGlzLnRocm93YWJsZXNfMD1lfXAoMTEwNywxLEplLGhkZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7bWVuKHRoaXMudGhyb3dhYmxlc18wLGEobiwzODApKX0sZygiamF2YS51dGlsLnN0cmVhbSIsIlRlcm1pbmF0YWJsZVN0cmVhbS9sYW1iZGEkMCRUeXBlIiwxMTA3KTtmdW5jdGlvbiB2eChlKXt2YXIgbjtyZXR1cm4gbj1lLnNsaWNlKCksQzUobixlKX1mdW5jdGlvbiBxRyhlLG4scix0LG8saSl7dmFyIHMsdSxjLF8sZDtpZihvIT0wKWZvcihEKGUpPT09RChyKSYmKGU9ZS5zbGljZShuLG4rbyksbj0wKSxjPXIsdT1uLF89bitvO3U8Xzspcz1TLk1hdGgubWluKHUrMWU0LF8pLG89cy11LGQ9ZS5zbGljZSh1LHMpLGQuc3BsaWNlKDAsMCx0LGk/bzowKSxBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGMsZCksdT1zLHQrPW99ZnVuY3Rpb24gRGwoZSxuKXtyZXR1cm4gU3gobmV3IEFycmF5KG4pLGUpfWZ1bmN0aW9uIG9FKGUsbixyKXtlLnNwbGljZShuLDAscil9ZnVuY3Rpb24gWUcoZSxuLHIpe3FHKHIsMCxlLG4sci5sZW5ndGgsITEpfWZ1bmN0aW9uIFJlKGUsbil7ZS5wdXNoKG4pfWZ1bmN0aW9uIEtHKGUsbixyKXtlLnNwbGljZShuLHIpfWZ1bmN0aW9uIFhHKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1lW25dLGVbbl09cix0fWZ1bmN0aW9uIF9mKGUsbil7ZS5sZW5ndGg9bn1mdW5jdGlvbiBtZGUoZSxuKXtlLnNvcnQobil9cCgyMTQyLDEse30pO2Z1bmN0aW9uIFN4KGUsbil7cmV0dXJuIEM1KGUsbil9ZnVuY3Rpb24gJGVuKGUsbil7KCFuJiZjb25zb2xlLmdyb3VwQ29sbGFwc2VkIT1udWxsP2NvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ6Y29uc29sZS5ncm91cD8/Y29uc29sZS5sb2cpLmNhbGwoY29uc29sZSxlKX1mdW5jdGlvbiB5ZGUoZSxuKXt2YXIgcjtyPWNvbnNvbGVbZV0sci5jYWxsKGNvbnNvbGUsbil9ZnVuY3Rpb24gSkcoZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfO2ZvcigkZW4odCtQSShyLHIuZ2V0TWVzc2FnZSgpKSxvKSx5ZGUobixCZW4ocikpLGk9ci5jYXVzZV8wLGkmJkpHKGUsbixpLCJDYXVzZWQgYnk6ICIsITEpLHU9KHIuc3VwcHJlc3NlZEV4Y2VwdGlvbnM9PW51bGwmJihyLnN1cHByZXNzZWRFeGNlcHRpb25zPUIoZzUsWCw4MiwwLDAsMSkpLHIuc3VwcHJlc3NlZEV4Y2VwdGlvbnMpLGM9MCxfPXUubGVuZ3RoO2M8XzsrK2Mpcz11W2NdLEpHKGUsbixzLCJTdXBwcmVzc2VkOiAiLCExKTtjb25zb2xlLmdyb3VwRW5kIT1udWxsJiZjb25zb2xlLmdyb3VwRW5kLmNhbGwoY29uc29sZSl9ZnVuY3Rpb24gd2RlKCl7fWZ1bmN0aW9uIEJlbihlKXt2YXIgbj1lLmJhY2tpbmdKc09iamVjdDtmdW5jdGlvbiByKHQpe3JldHVybiF0fHx0Lmxlbmd0aD09MD8iIjoiCSIrdC5qb2luKGAKCWApfXJldHVybiBuJiYobi5zdGFja3x8cihlLmZuU3RhY2spKX1wKDIwMTQsMSx7fSx3ZGUpLGcoImphdmFlbXVsLmludGVybmFsIiwiQ29uc29sZUxvZ2dlciIsMjAxNCk7ZnVuY3Rpb24gWkcoZSl7c3dpdGNoKHR5cGVvZiBlKXtjYXNlInN0cmluZyI6cmV0dXJuIE5jKGUpO2Nhc2UibnVtYmVyIjpyZXR1cm4gY2goZSk7Y2FzZSJib29sZWFuIjpyZXR1cm4gWHVlKGUpO2RlZmF1bHQ6cmV0dXJuIGU9PW51bGw/MDpSMShlKX19ZnVuY3Rpb24gUjEoZSl7cmV0dXJuIGUuJEh8fChlLiRIPSsrR2VuKX12YXIgR2VuPTA7ZnVuY3Rpb24gUUcoZSl7aWYoIWUpdGhyb3cgYihuZXcgVEMpfWZ1bmN0aW9uIEhDKGUsbil7aWYoIWUpdGhyb3cgYihuZXcgR2UobikpfWZ1bmN0aW9uIEVkZShlLG4scil7aWYoZT5uKXRocm93IGIobmV3IEdlKCJmcm9tSW5kZXg6ICIrZSsiID4gdG9JbmRleDogIituKSk7aWYoZTwwfHxuPnIpdGhyb3cgYihuZXcgeiQoImZyb21JbmRleDogIitlKyIsIHRvSW5kZXg6ICIrbisiLCBsZW5ndGg6ICIrcikpfWZ1bmN0aW9uIHZkZShlKXtpZihlPDApdGhyb3cgYihuZXcgY2NlKCJOZWdhdGl2ZSBhcnJheSBzaXplOiAiK2UpKX1mdW5jdGlvbiBIZW4oZSl7aWYoIWUpdGhyb3cgYihuZXcgTDUpfWZ1bmN0aW9uIGVIKGUsbil7aWYoIWUpdGhyb3cgYihuZXcgS3VlKG4pKX1mdW5jdGlvbiBEayhlLG4pe2lmKGUhPW4pdGhyb3cgYihuZXcgWGEpfWZ1bmN0aW9uIHJuKGUpe2lmKCFlKXRocm93IGIobmV3IFBvKX1mdW5jdGlvbiBBZShlLG4pe2lmKGU8MHx8ZT49bil0aHJvdyBiKG5ldyBubygiSW5kZXg6ICIrZSsiLCBTaXplOiAiK24pKX1mdW5jdGlvbiBWZShlKXtpZihlPT1udWxsKXRocm93IGIobmV3IF9oKTtyZXR1cm4gZX1mdW5jdGlvbiBuSChlLG4pe2lmKGU9PW51bGwpdGhyb3cgYihuZXcgZGgobikpfWZ1bmN0aW9uIGRmKGUsbil7aWYoZTwwfHxlPm4pdGhyb3cgYihuZXcgbm8oIkluZGV4OiAiK2UrIiwgU2l6ZTogIituKSl9ZnVuY3Rpb24gU2RlKGUsbixyKXtpZihlPDB8fG4+cil0aHJvdyBiKG5ldyBubygiZnJvbUluZGV4OiAiK2UrIiwgdG9JbmRleDogIituKyIsIHNpemU6ICIrcikpO2lmKGU+bil0aHJvdyBiKG5ldyBHZSgiZnJvbUluZGV4OiAiK2UrIiA+IHRvSW5kZXg6ICIrbikpfWZ1bmN0aW9uIGZmKGUpe2lmKCFlKXRocm93IGIobmV3IHppKX1mdW5jdGlvbiB4aChlLG4pe2lmKCFlKXRocm93IGIobmV3IHJvKG4pKX1mdW5jdGlvbiBndChlLG4scil7aWYoZTwwfHxuPnJ8fG48ZSl0aHJvdyBiKG5ldyBmQigiZnJvbUluZGV4OiAiK2UrIiwgdG9JbmRleDogIituKyIsIGxlbmd0aDogIityKSl9ZnVuY3Rpb24gSGUoZSxuKXtpZihlPDB8fGU+PW4pdGhyb3cgYihuZXcgZkIoIkluZGV4OiAiK2UrIiwgU2l6ZTogIituKSl9ZnVuY3Rpb24gaUUoZSl7aWYoIWUpdGhyb3cgYihuZXcgaXkobnVsbCkpfXAoMjEzNCwxLHt9KTtmdW5jdGlvbiBDZGUoZSxuKXt2YXIgcix0O3JldHVybiB0PWV0KGUsVXQpLHI9T2wobiwzMiksbHMocix0KX1mdW5jdGlvbiBUZGUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGU7Zm9yKEE9bmV3IFkoaHIsaHIpLG49bmV3IFkoVnIsVnIpLHZlPW5ldyBUKGUpO3ZlLmk8dmUudGhpcyQwMS5hcnJheS5sZW5ndGg7KW5lPWEoQyh2ZSksOCksQS54XzA9Uy5NYXRoLm1pbihBLnhfMCxuZS54XzApLEEueV8wPVMuTWF0aC5taW4oQS55XzAsbmUueV8wKSxuLnhfMD1TLk1hdGgubWF4KG4ueF8wLG5lLnhfMCksbi55XzA9Uy5NYXRoLm1heChuLnlfMCxuZS55XzApO2ZvcihoPW5ldyBZKG4ueF8wLUEueF8wLG4ueV8wLUEueV8wKSxfPW5ldyBZKEEueF8wLTUwLEEueV8wLWgueF8wLTUwKSxkPW5ldyBZKEEueF8wLTUwLG4ueV8wK2gueF8wKzUwKSxmPW5ldyBZKG4ueF8wK2gueV8wLzIrNTAsQS55XzAraC55XzAvMiksbT1uZXcgckgoXyxkLGYpLHE9bmV3IEJyLGk9bmV3IFEscj1uZXcgUSxxLm1hcF8wLnB1dChtLHEpLERlPW5ldyBUKGUpO0RlLmk8RGUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iod2U9YShDKERlKSw4KSxpLmFycmF5Lmxlbmd0aD0wLEg9cS5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtILmhhc05leHRfMCgpOylrPWEoSC5uZXh0XzEoKSwzMTcpLHQ9ay5jaXJjdW1jZW50ZXIsVTAodCxrLmEpLFMxKFUwKGsuY2lyY3VtY2VudGVyLHdlKSxVMChrLmNpcmN1bWNlbnRlcixrLmEpKTwwJiZSZShpLmFycmF5LGspO2ZvcihyLmFycmF5Lmxlbmd0aD0wLE09bmV3IFQoaSk7TS5pPE0udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihrPWEoQyhNKSwzMTcpLHY9bmV3IFQoay50RWRnZXMpO3YuaTx2LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHk9YShDKHYpLDE3Nykscz0hMCxjPW5ldyBUKGkpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwzMTcpLHUhPWsmJihVbyh5LGxlKHUudEVkZ2VzLDApKXx8VW8oeSxsZSh1LnRFZGdlcywxKSl8fFVvKHksbGUodS50RWRnZXMsMikpKSYmKHM9ITEpO3MmJlJlKHIuYXJyYXkseSl9Zm9yKHBhZShxLGkpLEV0KHEsbmV3IGJkZSksRT1uZXcgVChyKTtFLmk8RS50aGlzJDAxLmFycmF5Lmxlbmd0aDspeT1hKEMoRSksMTc3KSxZcihxLG5ldyBySCh3ZSx5LnUseS52KSl9Zm9yKHg9bmV3IEJyLEV0KHEsbmV3IElkZSh4KSksbz14Lm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXk9YShvLm5leHRfMSgpLDE3NyksKEN4KG0seS51KXx8Q3gobSx5LnYpKSYmby5yZW1vdmUoKTtyZXR1cm4gRXQoeCxuZXcgeGRlKSx4fWZ1bmN0aW9uIGJkZSgpe31wKDE4MzAsMSxKZSxiZGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2EobiwzMTcpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbiIsIkJvd3llcldhdHNvblRyaWFuZ3VsYXRpb24vbGFtYmRhJDAkVHlwZSIsMTgzMCk7ZnVuY3Rpb24gSWRlKGUpe3RoaXMudEVkZ2VzXzA9ZX1wKDE4MzEsMSxKZSxJZGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Z0KHRoaXMudEVkZ2VzXzAsYShuLDMxNykudEVkZ2VzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24iLCJCb3d5ZXJXYXRzb25Ucmlhbmd1bGF0aW9uL2xhbWJkYSQxJFR5cGUiLDE4MzEpO2Z1bmN0aW9uIHhkZSgpe31wKDE4MzIsMSxKZSx4ZGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2EobiwxNzcpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbiIsIkJvd3llcldhdHNvblRyaWFuZ3VsYXRpb24vbGFtYmRhJDIkVHlwZSIsMTgzMik7ZnVuY3Rpb24gRmsoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3IoeT1uZXcgc24saT1lLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KXQ9YShpLm5leHRfMSgpLDE3NyksQm4oeSx0LHIuY29zdCh0KSk7Zm9yKHM9KHZuKGUpLGU/bmV3IFFpKGUpOlFtKGUubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCkpKSxEcihzLG5ldyBQZGUoeSkpLHU9VEkocyksYz1uZXcgVHgobiksbT1uZXcgc24sZGkobS5oYXNoQ29kZU1hcCxuLGMpO3UubWFwXzAuc2l6ZV8xKCkhPTA7KXtmb3IoXz1udWxsLGQ9bnVsbCxmPW51bGwsbz11Lm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KWlmKHQ9YShvLm5leHRfMSgpLDE3NyksUigkKF9vKGp0KHkuaGFzaENvZGVNYXAsdCkpKSk8PWhyKXtpZih5aShtLHQudSkmJiF5aShtLHQudikpe2Q9dC52LGY9dC51LF89dDticmVha31pZih5aShtLHQudikmJiF5aShtLHQudSkpe2Q9dC51LGY9dC52LF89dDticmVha319aWYoIV8pYnJlYWs7aD1uZXcgVHgoZCksZWUoYShfbyhqdChtLmhhc2hDb2RlTWFwLGYpKSwyMjUpLmNoaWxkcmVuLGgpLGRpKG0uaGFzaENvZGVNYXAsZCxoKSx1Lm1hcF8wLnJlbW92ZV8wKF8pIT1udWxsfXJldHVybiBjfWZ1bmN0aW9uIFVlbihlLG4scil7cmV0dXJuIE81KCQoX28oanQoZS5oYXNoQ29kZU1hcCxuKSkpLCQoX28oanQoZS5oYXNoQ29kZU1hcCxyKSkpKX1mdW5jdGlvbiBQZGUoZSl7dGhpcy53ZWlnaHRfMD1lfXAoMTgyNywxLE5uLFBkZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gVWVuKHRoaXMud2VpZ2h0XzAsYShuLDE3NyksYShyLDE3NykpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uIiwiTmFpdmVNaW5TVC9sYW1iZGEkMCRUeXBlIiwxODI3KTtmdW5jdGlvbiBVQyhlKXt2YXIgbjtJbm4oZS5hZGFwdGVyKSxUZmUoZS5hZGFwdGVyKSxuPW5ldyBPeChlLmFkYXB0ZXIpLEJIKG4pfWZ1bmN0aW9uIGFFKGUpe3RoaXMuYWRhcHRlcj1lfXAoNDQ5LDEse30sYUUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uIiwiTm9kZU1pY3JvTGF5b3V0Iiw0NDkpO2Z1bmN0aW9uIFBoKGUsbil7dGhpcy51PWUsdGhpcy52PW59cCgxNzcsMSx7MTc3OjF9LFBoKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sMTc3KT8ocj1hKG4sMTc3KSxVbyh0aGlzLnUsci51KSYmVW8odGhpcy52LHIudil8fFVvKHRoaXMudSxyLnYpJiZVbyh0aGlzLnYsci51KSk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBrcCh0aGlzLnUpK2twKHRoaXMudil9O3ZhciBXZW49Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24iLCJURWRnZSIsMTc3KTtmdW5jdGlvbiBDeChlLG4pe3JldHVybiBVbyhuLGxlKGUudmVydGljZXMsMCkpfHxVbyhuLGxlKGUudmVydGljZXMsMSkpfHxVbyhuLGxlKGUudmVydGljZXMsMikpfWZ1bmN0aW9uIHJIKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkO3RoaXMuYT1lLHRoaXMuYj1uLHRoaXMuYz1yLHRoaXMudEVkZ2VzPVRzKFAoSShXZW4sMSksTWUsMTc3LDAsW25ldyBQaChlLG4pLG5ldyBQaChuLHIpLG5ldyBQaChyLGUpXSkpLHRoaXMudmVydGljZXM9VHMoUChJKG90LDEpLFgsOCwwLFtlLG4scl0pKSx0aGlzLmNpcmN1bWNlbnRlcj0odD1ydChDdCh0aGlzLmIpLHRoaXMuYSksbz1ydChDdCh0aGlzLmMpLHRoaXMuYSksaT1ydChDdCh0aGlzLmMpLHRoaXMuYikscz10LnhfMCoodGhpcy5hLnhfMCt0aGlzLmIueF8wKSt0LnlfMCoodGhpcy5hLnlfMCt0aGlzLmIueV8wKSx1PW8ueF8wKih0aGlzLmEueF8wK3RoaXMuYy54XzApK28ueV8wKih0aGlzLmEueV8wK3RoaXMuYy55XzApLGM9MioodC54XzAqaS55XzAtdC55XzAqaS54XzApLF89KG8ueV8wKnMtdC55XzAqdSkvYyxkPSh0LnhfMCp1LW8ueF8wKnMpL2MsbmV3IFkoXyxkKSl9cCgzMTcsMSx7MzE3OjF9LHJIKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBMKG4sMzE3KT8ocj1hKG4sMzE3KSxDeCh0aGlzLHIuYSkmJkN4KHRoaXMsci5iKSYmQ3godGhpcyxyLmMpKTohMX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIGtwKHRoaXMuYSkra3AodGhpcy5iKStrcCh0aGlzLmMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbiIsIlRUcmlhbmdsZSIsMzE3KTtmdW5jdGlvbiBUeChlKXt0aGlzLm5vZGU9ZSx0aGlzLmNoaWxkcmVuPW5ldyBRfXAoMjI1LDEsezIyNToxfSxUeCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24iLCJUcmVlIiwyMjUpO2Z1bmN0aW9uIGplbihlKXt2YXIgbixyLHQsbztmb3IoTmUoKSxEcihlLnBvaW50cyxlLmNvbXBhcmF0b3IpLG89bmV3IFQoZS5wb2ludHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1DKG8pLHI9bmV3IFQoZS5ldmVudEhhbmRsZXJzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksNjkzKSxuLmhhbmRsZSh0KX1mdW5jdGlvbiBOZGUoZSxuLHIpe3RoaXMuY29tcGFyYXRvcj1uLHRoaXMucG9pbnRzPWUsdGhpcy5ldmVudEhhbmRsZXJzPSh2bihyKSxuZXcgUWkocikpfWZ1bmN0aW9uIEFkZShlLG4scil7dmFyIHQ7dD0odm4oZSksbmV3IFFpKGUpKSxqZW4obmV3IE5kZSh0LG4scikpfXAoMTIxOCwxLHt9LE5kZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbiIsIlNjYW5saW5lIiwxMjE4KTt2YXIgTGRlPUNyKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uIiwiU2NhbmxpbmUvRXZlbnRIYW5kbGVyIik7ZnVuY3Rpb24gVmVuKGUsbil7cmV0dXJuICRpKGUuc3VwcG9ydGVkRGlyZWN0aW9ucyxuKX1mdW5jdGlvbiBrZGUoZSl7dGhpcy5jTm9kZXM9bmV3IFEsdGhpcy5jR3JvdXBzPW5ldyBRLHRoaXMucHJlZGVmaW5lZEhvcml6b250YWxDb25zdHJhaW50cz1uZXcgUSx0aGlzLnByZWRlZmluZWRWZXJ0aWNhbENvbnN0cmFpbnRzPW5ldyBRLHRoaXMuc3VwcG9ydGVkRGlyZWN0aW9ucz1lfXAoMTc1OCwxLHt9LGtkZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbi5vbmVkIiwiQ0dyYXBoIiwxNzU4KTtmdW5jdGlvbiBPZGUoZSxuKXtpZihuLmNHcm91cCl0aHJvdyBiKG5ldyBJbygiQ05vZGUgYmVsb25ncyB0byBhbm90aGVyIENHcm91cC4iKSk7WXIoZS5jTm9kZXMsbiksbi5jR3JvdXA9ZSwhZS5yZWZlcmVuY2UmJihlLnJlZmVyZW5jZT1uKX1mdW5jdGlvbiBNZGUoKXt0aGlzLmNOb2Rlcz1uZXcgbHUsdGhpcy5pbmNvbWluZ0NvbnN0cmFpbnRzPW5ldyBCcix0aGlzLm91dERlZ3JlZT0wLHRoaXMub3V0RGVncmVlUmVhbD0wfXAoMzE2LDEsezMxNjoxfSxNZGUpLGwuZGVsdGE9MCxsLmRlbHRhTm9ybWFsaXplZD0wLGwuaWRfMD0wLGwub3V0RGVncmVlPTAsbC5vdXREZWdyZWVSZWFsPTAsbC5zdGFydFBvcz1WcixnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9uZWQiLCJDR3JvdXAiLDMxNik7ZnVuY3Rpb24gUmRlKGUsbil7cmV0dXJuIGVlKG4uY0dyb3VwcyxlLmdyb3VwXzApLGUuZ3JvdXBfMH1mdW5jdGlvbiBxZW4oZSxuKXtyZXR1cm4gZS5ncm91cF8wLm1hc3Rlcj1uLGV9ZnVuY3Rpb24gRGRlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKHQ9bixvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxPZGUoZS5ncm91cF8wLHIpO3JldHVybiBlfWZ1bmN0aW9uIHRIKCl7dGhpcy5ncm91cF8wPW5ldyBNZGV9cCg4MzAsMSx7fSx0SCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbi5vbmVkIiwiQ0dyb3VwL0NHcm91cEJ1aWxkZXIiLDgzMCk7ZnVuY3Rpb24gRmRlKCl7dGhpcy5jR3JvdXBPZmZzZXQ9bmV3IG10LHRoaXMuY29uc3RyYWludHM9bmV3IFF9cCg2MCwxLHs2MDoxfSxGZGUpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLnRvU3RyaW5nRGVsZWdhdGU/eG4odGhpcy50b1N0cmluZ0RlbGVnYXRlLmFwcGx5XzAodGhpcykpOihKdShieCksYngudHlwZU5hbWUrIkAiKyhuPVIxKHRoaXMpPj4+MCxuLnRvU3RyaW5nKDE2KSkpfSxsLmlkXzA9MCxsLnN0YXJ0UG9zPVZyO3ZhciBieD1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9uZWQiLCJDTm9kZSIsNjApO2Z1bmN0aW9uIHpkZShlLG4pe3JldHVybiBlZShuLmNOb2RlcyxlLm5vZGUpLGUubm9kZX1mdW5jdGlvbiAkZGUoZSxuKXtyZXR1cm4gZS5ub2RlLmhpdGJveD1uLGV9ZnVuY3Rpb24gQmRlKGUsbil7cmV0dXJuIGUubm9kZS5vcmlnaW5fMD1uLGV9ZnVuY3Rpb24gR2RlKGUsbil7cmV0dXJuIGUubm9kZS50b1N0cmluZ0RlbGVnYXRlPW4sZX1mdW5jdGlvbiBvSCgpe3RoaXMubm9kZT1uZXcgRmRlfXAoODI5LDEse30sb0gpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIkNOb2RlL0NOb2RlQnVpbGRlciIsODI5KTtmdW5jdGlvbiBpSChlLG4pe3JldHVybiBicygpLGtsKGcwKSxTLk1hdGguYWJzKGUtbik8PWcwfHxlPT1ufHxpc05hTihlKSYmaXNOYU4obil9ZnVuY3Rpb24gWWVuKGUsbil7cmV0dXJuIGJzKCksYnMoKSxrbChnMCksKFMuTWF0aC5hYnMoZS1uKTw9ZzB8fGU9PW58fGlzTmFOKGUpJiZpc05hTihuKT8wOmU8bj8tMTplPm4/MTpDMShpc05hTihlKSxpc05hTihuKSkpPjB9ZnVuY3Rpb24gSGRlKGUsbil7cmV0dXJuIGJzKCksYnMoKSxrbChnMCksKFMuTWF0aC5hYnMoZS1uKTw9ZzB8fGU9PW58fGlzTmFOKGUpJiZpc05hTihuKT8wOmU8bj8tMTplPm4/MTpDMShpc05hTihlKSxpc05hTihuKSkpPD0wfWZ1bmN0aW9uIGFIKGUsbil7cmV0dXJuIGJzKCksYnMoKSxrbChnMCksKFMuTWF0aC5hYnMoZS1uKTw9ZzB8fGU9PW58fGlzTmFOKGUpJiZpc05hTihuKT8wOmU8bj8tMTplPm4/MTpDMShpc05hTihlKSxpc05hTihuKSkpPDB9ZnVuY3Rpb24gVWRlKCl7VWRlPUYsV2RlPW5ldyBqZGV9dmFyIFdkZTtmdW5jdGlvbiBqZGUoKXt9cCgxNTkwLDEse30samRlKSxsLmdldEhvcml6b250YWxTcGFjaW5nPWZ1bmN0aW9uKG4scil7cmV0dXJuIDB9LGwuZ2V0VmVydGljYWxTcGFjaW5nPWZ1bmN0aW9uKG4scil7cmV0dXJuIDB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIklTcGFjaW5nc0hhbmRsZXIvMSIsMTU5MCk7ZnVuY3Rpb24gVmRlKCl7fXAoMTg1MywxLHt9LFZkZSksbC5jb21wYWN0PWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtmb3IoZD1ocixvPW5ldyBUKG4uY0dyYXBoLmNOb2Rlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKG8pLDYwKSxkPVMuTWF0aC5taW4oZCxyLmNHcm91cC5yZWZlcmVuY2UuaGl0Ym94LnhfMCtyLmNHcm91cE9mZnNldC54XzApO2Zvcih5PW5ldyBwcix1PW5ldyBUKG4uY0dyYXBoLmNHcm91cHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwzMTYpLHMuc3RhcnRQb3M9ZCxzLm91dERlZ3JlZT09MCYmYnIoeSxzLHkudGFpbC5wcmV2LHkudGFpbCk7Zm9yKDt5LnNpemVfMCE9MDspe2ZvcihzPWEoeS5zaXplXzA9PTA/bnVsbDoocm4oeS5zaXplXzAhPTApLFphKHkseS5oZWFkZXIubmV4dF8wKSksMzE2KSxpPXMucmVmZXJlbmNlLmhpdGJveC54XzAsbT1zLmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTttLmhhc05leHRfMCgpOylmPWEobS5uZXh0XzEoKSw2MCksdj1zLnN0YXJ0UG9zK2YuY0dyb3VwT2Zmc2V0LnhfMCwhS2VuKG4scyxuLmRpcmVjdGlvbil8fGYuaGl0Ym94LnhfMDx2P2Yuc3RhcnRQb3M9djpmLnN0YXJ0UG9zPWYuaGl0Ym94LnhfMDtmb3IoaS09cy5yZWZlcmVuY2Uuc3RhcnRQb3Mscy5kZWx0YSs9aSxuLmRpcmVjdGlvbj09KFdyKCksbW8pfHxuLmRpcmVjdGlvbj09JHM/cy5kZWx0YU5vcm1hbGl6ZWQrPWk6cy5kZWx0YU5vcm1hbGl6ZWQtPWksaD1zLmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylmb3IoZj1hKGgubmV4dF8xKCksNjApLF89Zi5jb25zdHJhaW50cy5pdGVyYXRvcl8wKCk7Xy5oYXNOZXh0XzAoKTspYz1hKF8ubmV4dF8xKCksNjApLGRjKG4uZGlyZWN0aW9uKT9FPW4uc3BhY2luZ3NIYW5kbGVyLmdldEhvcml6b250YWxTcGFjaW5nKGYsYyk6RT1uLnNwYWNpbmdzSGFuZGxlci5nZXRWZXJ0aWNhbFNwYWNpbmcoZixjKSxjLmNHcm91cC5zdGFydFBvcz1TLk1hdGgubWF4KGMuY0dyb3VwLnN0YXJ0UG9zLGYuc3RhcnRQb3MrZi5oaXRib3gud2lkdGhfMCtFLWMuY0dyb3VwT2Zmc2V0LnhfMCksWWRlKG4sYyxuLmRpcmVjdGlvbikmJihjLmNHcm91cC5zdGFydFBvcz1TLk1hdGgubWF4KGMuY0dyb3VwLnN0YXJ0UG9zLGMuaGl0Ym94LnhfMC1jLmNHcm91cE9mZnNldC54XzApKSwtLWMuY0dyb3VwLm91dERlZ3JlZSxjLmNHcm91cC5vdXREZWdyZWU9PTAmJkxuKHksYy5jR3JvdXApfWZvcih0PW5ldyBUKG4uY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDYwKSxyLmhpdGJveC54XzA9ci5zdGFydFBvc30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbi5vbmVkIiwiTG9uZ2VzdFBhdGhDb21wYWN0aW9uIiwxODUzKTtmdW5jdGlvbiBsSCgpe2xIPUYsWmRlPW5ldyBWZGUsZWZlPW5ldyB1SCxRZGU9bmV3IHJmZX1mdW5jdGlvbiBEMShlKXt2YXIgbixyLHQ7Zm9yKHI9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksNjApLG4uY29uc3RyYWludHMuY2xlYXJfMCgpO2RjKGUuZGlyZWN0aW9uKT90PWUuY0dyYXBoLnByZWRlZmluZWRIb3Jpem9udGFsQ29uc3RyYWludHM6dD1lLmNHcmFwaC5wcmVkZWZpbmVkVmVydGljYWxDb25zdHJhaW50cyx3aSh0LG5ldyBuZmUoZSkpLGUuY29uc3RyYWludEFsZ29yaXRobS5jYWxjdWxhdGVDb25zdHJhaW50cyhlKSxxZGUoZSl9ZnVuY3Rpb24gcWRlKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihpPW5ldyBUKGUuY0dyYXBoLmNHcm91cHMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhpKSwzMTYpLHQub3V0RGVncmVlPTAsdC5vdXREZWdyZWVSZWFsPTAsdC5pbmNvbWluZ0NvbnN0cmFpbnRzLm1hcF8wLmNsZWFyXzAoKTtmb3Iobz1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9YShDKG8pLDMxNikscj10LmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtyLmhhc05leHRfMCgpOylmb3Iobj1hKHIubmV4dF8xKCksNjApLHU9bi5jb25zdHJhaW50cy5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksNjApLHMuY0dyb3VwIT10JiYoWXIodC5pbmNvbWluZ0NvbnN0cmFpbnRzLHMpLCsrcy5jR3JvdXAub3V0RGVncmVlLCsrcy5jR3JvdXAub3V0RGVncmVlUmVhbCl9ZnVuY3Rpb24gc0goZSl7dmFyIG4scix0LG8saTtmb3Iocj1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihuPWEoQyhyKSwzMTYpLG4ucmVmZXJlbmNlPW51bGwsaT1uLmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOyl0PWEoaS5uZXh0XzEoKSw2MCksbXModC5jR3JvdXBPZmZzZXQpLCghbi5yZWZlcmVuY2V8fHQuaGl0Ym94LnhfMDxuLnJlZmVyZW5jZS5oaXRib3gueF8wKSYmKG4ucmVmZXJlbmNlPXQpO2ZvcihvPW4uY05vZGVzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDYwKSx0LmNHcm91cE9mZnNldC54XzA9dC5oaXRib3gueF8wLW4ucmVmZXJlbmNlLmhpdGJveC54XzAsdC5jR3JvdXBPZmZzZXQueV8wPXQuaGl0Ym94LnlfMC1uLnJlZmVyZW5jZS5oaXRib3gueV8wfXJldHVybiBlfWZ1bmN0aW9uIEl4KGUsbil7dmFyIHI7aWYoZS5maW5pc2hlZCl0aHJvdyBiKG5ldyBybygoSnUoJGspLCJUaGUgIiskay5zaW1wbGVOYW1lKyIgaW5zdGFuY2UgaGFzIGJlZW4gZmluaXNoZWQgYWxyZWFkeS4iKSkpO2lmKCFWZW4oZS5jR3JhcGgsbikpdGhyb3cgYihuZXcgSW8oIlRoZSBkaXJlY3Rpb24gIituKyIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgQ0dyYXBoIGluc3RhbmNlLiIpKTtpZihuPT1lLmRpcmVjdGlvbilyZXR1cm4gZTtzd2l0Y2gocj1lLmRpcmVjdGlvbixlLmRpcmVjdGlvbj1uLHIub3JkaW5hbCl7Y2FzZSAwOnN3aXRjaChuLm9yZGluYWwpe2Nhc2UgMjpEMShlKTticmVhaztjYXNlIDE6TjAoZSksRDEoZSk7YnJlYWs7Y2FzZSA0OlJwKGUpLEQxKGUpO2JyZWFrO2Nhc2UgMzpScChlKSxOMChlKSxEMShlKX1icmVhaztjYXNlIDI6c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAxOk4wKGUpLHprKGUpO2JyZWFrO2Nhc2UgNDpScChlKSxEMShlKTticmVhaztjYXNlIDM6UnAoZSksTjAoZSksRDEoZSl9YnJlYWs7Y2FzZSAxOnN3aXRjaChuLm9yZGluYWwpe2Nhc2UgMjpOMChlKSx6ayhlKTticmVhaztjYXNlIDQ6TjAoZSksUnAoZSksRDEoZSk7YnJlYWs7Y2FzZSAzOk4wKGUpLFJwKGUpLE4wKGUpLEQxKGUpfWJyZWFrO2Nhc2UgNDpzd2l0Y2gobi5vcmRpbmFsKXtjYXNlIDI6UnAoZSksRDEoZSk7YnJlYWs7Y2FzZSAxOlJwKGUpLE4wKGUpLEQxKGUpO2JyZWFrO2Nhc2UgMzpOMChlKSx6ayhlKX1icmVhaztjYXNlIDM6c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAyOk4wKGUpLFJwKGUpLEQxKGUpO2JyZWFrO2Nhc2UgMTpOMChlKSxScChlKSxOMChlKSxEMShlKTticmVhaztjYXNlIDQ6TjAoZSksemsoZSl9fXJldHVybiBlfWZ1bmN0aW9uIGxFKGUpe3ZhciBuLHIsdCxvO2lmKGUuZmluaXNoZWQpdGhyb3cgYihuZXcgcm8oKEp1KCRrKSwiVGhlICIrJGsuc2ltcGxlTmFtZSsiIGluc3RhbmNlIGhhcyBiZWVuIGZpbmlzaGVkIGFscmVhZHkuIikpKTtmb3IoZS5kaXJlY3Rpb249PShXcigpLEJzKSYmSXgoZSxhbykscj1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMzE2KSxuLm91dERlZ3JlZT1uLm91dERlZ3JlZVJlYWw7Zm9yKG89bmV3IFQoZS5jR3JhcGguY05vZGVzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksNjApLHQuc3RhcnRQb3M9VnI7cmV0dXJuIGUuY29tcGFjdGlvbkFsZ29yaXRobS5jb21wYWN0KGUpLGV9ZnVuY3Rpb24gS2VuKGUsbixyKXt2YXIgdCxvO2ZvcihvPW4uY05vZGVzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KWlmKHQ9YShvLm5leHRfMSgpLDYwKSxZZGUoZSx0LHIpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIFlkZShlLG4scil7cmV0dXJuIGUubG9ja0Z1bj9lLmxvY2tGdW4uaXNMb2NrZWQobixyKTohMX1mdW5jdGlvbiBYZW4oZSxuKXtlLmRpcmVjdGlvbj09KFdyKCksYW8pfHxlLmRpcmVjdGlvbj09b2w/YShuLmZpcnN0LDYwKS5jb25zdHJhaW50cy5hZGRfMihhKG4uc2Vjb25kLDYwKSk6YShuLnNlY29uZCw2MCkuY29uc3RyYWludHMuYWRkXzIoYShuLmZpcnN0LDYwKSl9ZnVuY3Rpb24gTjAoZSl7dmFyIG4scjtmb3Iocj1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw2MCksbi5oaXRib3gueF8wPS1uLmhpdGJveC54XzAtbi5oaXRib3gud2lkdGhfMDtzSChlKX1mdW5jdGlvbiB6ayhlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3IodT1uZXcgc24sdD1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyh0KSw2MCksQm4odSxuLG5ldyBRKTtmb3Iobz1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobj1hKEMobyksNjApLG4uc3RhcnRQb3M9VnIscz1uLmNvbnN0cmFpbnRzLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylpPWEocy5uZXh0XzEoKSw2MCksYShfbyhqdCh1Lmhhc2hDb2RlTWFwLGkpKSwxNSkuYWRkXzIobik7Zm9yKHI9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksNjApLG4uY29uc3RyYWludHMuY2xlYXJfMCgpLG4uY29uc3RyYWludHM9YShfbyhqdCh1Lmhhc2hDb2RlTWFwLG4pKSwxNSk7cWRlKGUpfWZ1bmN0aW9uIEplbihlLG4pe3JldHVybiBlLmNvbXBhY3Rpb25BbGdvcml0aG09bixlfWZ1bmN0aW9uIEtkZShlLG4pe3JldHVybiBlLmNvbnN0cmFpbnRBbGdvcml0aG09bixlfWZ1bmN0aW9uIFhkZShlLG4pe3JldHVybiBlLmxvY2tGdW49bixlfWZ1bmN0aW9uIFplbihlLG4pe3JldHVybiBlLnNwYWNpbmdzSGFuZGxlcj1uLGV9ZnVuY3Rpb24gUnAoZSl7dmFyIG4scix0O2ZvcihyPW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDYwKSx0PW4uaGl0Ym94LnhfMCxuLmhpdGJveC54XzA9bi5oaXRib3gueV8wLG4uaGl0Ym94LnlfMD10LHQ9bi5oaXRib3gud2lkdGhfMCxuLmhpdGJveC53aWR0aF8wPW4uaGl0Ym94LmhlaWdodCxuLmhpdGJveC5oZWlnaHQ9dCx0PW4uY0dyb3VwT2Zmc2V0LnhfMCxuLmNHcm91cE9mZnNldC54XzA9bi5jR3JvdXBPZmZzZXQueV8wLG4uY0dyb3VwT2Zmc2V0LnlfMD10O3NIKGUpfWZ1bmN0aW9uIEpkZShlKXtsSCgpO3ZhciBuLHI7Zm9yKHRoaXMuY29tcGFjdGlvbkFsZ29yaXRobT1aZGUsdGhpcy5jb25zdHJhaW50QWxnb3JpdGhtPWVmZSx0aGlzLnNwYWNpbmdzSGFuZGxlcj0oVWRlKCksV2RlKSx0aGlzLmRpcmVjdGlvbj0oV3IoKSxCcyksdGhpcy5jR3JhcGg9ZSxzSCh0aGlzKSxyPW5ldyBUKGUuY05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksNjApLCFuLmNHcm91cCYmUmRlKERkZShuZXcgdEgsUChJKGJ4LDEpLE1lLDYwLDAsW25dKSksZSksbi5oaXRib3hQcmVDb21wYWN0aW9uPW5ldyBZTihuLmhpdGJveCl9cCgxNzU2LDEse30sSmRlKSxsLmZpbmlzaGVkPSExO3ZhciBaZGUsUWRlLGVmZSwkaz1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9uZWQiLCJPbmVEaW1lbnNpb25hbENvbXBhY3RvciIsMTc1Nik7ZnVuY3Rpb24gbmZlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNzU3LDEsSmUsbmZlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtYZW4odGhpcy4kJG91dGVyXzAsYShuLDQyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIk9uZURpbWVuc2lvbmFsQ29tcGFjdG9yL2xhbWJkYSQwJFR5cGUiLDE3NTcpO2Z1bmN0aW9uIHJmZSgpe31wKDE4NTQsMSx7fSxyZmUpLGwuY2FsY3VsYXRlQ29uc3RyYWludHM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKHQ9bmV3IFQobi5jR3JhcGguY05vZGVzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksNjApLHIuY29uc3RyYWludHMuY2xlYXJfMCgpO2ZvcihpPW5ldyBUKG4uY0dyYXBoLmNOb2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSw2MCksdT1uZXcgVChuLmNHcmFwaC5jTm9kZXMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSw2MCksbyE9cyYmKG8uY0dyb3VwJiZvLmNHcm91cD09cy5jR3JvdXB8fChkYyhuLmRpcmVjdGlvbik/Yz1uLnNwYWNpbmdzSGFuZGxlci5nZXRWZXJ0aWNhbFNwYWNpbmcobyxzKTpjPW4uc3BhY2luZ3NIYW5kbGVyLmdldEhvcml6b250YWxTcGFjaW5nKG8scyksKHMuaGl0Ym94LnhfMD5vLmhpdGJveC54XzB8fG8uaGl0Ym94LnhfMD09cy5oaXRib3gueF8wJiZvLmhpdGJveC53aWR0aF8wPHMuaGl0Ym94LndpZHRoXzApJiZZZW4ocy5oaXRib3gueV8wK3MuaGl0Ym94LmhlaWdodCtjLG8uaGl0Ym94LnlfMCkmJmFIKHMuaGl0Ym94LnlfMCxvLmhpdGJveC55XzArby5oaXRib3guaGVpZ2h0K2MpJiZvLmNvbnN0cmFpbnRzLmFkZF8yKHMpKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIlF1YWRyYXRpY0NvbnN0cmFpbnRDYWxjdWxhdGlvbiIsMTg1NCk7ZnVuY3Rpb24gUWVuKGUsbil7ZS5sZWZ0PWUubGVmdHxuLmxlZnQsZS5yaWdodD1lLnJpZ2h0fG4ucmlnaHQsZS51cD1lLnVwfG4udXAsZS5kb3duPWUuZG93bnxuLmRvd259ZnVuY3Rpb24gZW5uKGUsbil7c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAyOnJldHVybiBlLmxlZnQ7Y2FzZSAxOnJldHVybiBlLnJpZ2h0O2Nhc2UgNDpyZXR1cm4gZS51cDtjYXNlIDM6cmV0dXJuIGUuZG93bjtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBXQyhlLG4scil7c3dpdGNoKHIub3JkaW5hbCl7Y2FzZSAyOmUubGVmdD1uO2JyZWFrO2Nhc2UgMTplLnJpZ2h0PW47YnJlYWs7Y2FzZSA0OmUudXA9bjticmVhaztjYXNlIDM6ZS5kb3duPW59fWZ1bmN0aW9uIHRmZShlKXtlLmxlZnQ9ITEsZS5yaWdodD0hMSxlLnVwPSExLGUuZG93bj0hMX1mdW5jdGlvbiBCaygpe3RmZSh0aGlzKX1wKDUyOSwxLHs1Mjk6MX0sQmspLGwuZG93bj0hMSxsLmxlZnQ9ITEsbC5yaWdodD0hMSxsLnVwPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIlF1YWRydXBsZXQiLDUyOSk7ZnVuY3Rpb24gb2ZlKGUsbil7cmV0dXJuIWV8fCFufHxlPT1uPyExOkhkZShlLmhpdGJveC54XzAsbi5oaXRib3gueF8wK24uaGl0Ym94LndpZHRoXzApJiZIZGUobi5oaXRib3gueF8wLGUuaGl0Ym94LnhfMCtlLmhpdGJveC53aWR0aF8wKX1mdW5jdGlvbiBqQyhlLG4pe3ZhciByLHQsbztmb3Iobz1uZXcgUSx0PW5ldyBUKGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw2MCksbi5hcHBseV8xKHIpJiYoZWUobyxuZXcgY0gociwhMCkpLGVlKG8sbmV3IGNIKHIsITEpKSk7b25uKGUuY29uc3RyYWludHNTY2FubGluZUhhbmRsZXIpLEFkZShvLGUuY29uc3RyYWludHNTY2FubGluZUNvbXBhcmF0b3IsbmV3IGVhKFAoSShMZGUsMSksTWUsNjkzLDAsW2UuY29uc3RyYWludHNTY2FubGluZUhhbmRsZXJdKSkpfWZ1bmN0aW9uIHVIKCl7dGhpcy5jb25zdHJhaW50c1NjYW5saW5lQ29tcGFyYXRvcj1uZXcgbGZlLHRoaXMuY29uc3RyYWludHNTY2FubGluZUhhbmRsZXI9bmV3IGlmZSh0aGlzKX1mdW5jdGlvbiBubm4oZSxuKXt2YXIgcix0LG87aWYodD1lLm5vZGUuaGl0Ym94LnlfMCxlLmxvd3x8KHQrPWUubm9kZS5oaXRib3guaGVpZ2h0KSxvPW4ubm9kZS5oaXRib3gueV8wLG4ubG93fHwobys9bi5ub2RlLmhpdGJveC5oZWlnaHQpLHI9aXIodCxvKSxyPT0wKXtpZighZS5sb3cmJm4ubG93KXJldHVybi0xO2lmKCFuLmxvdyYmZS5sb3cpcmV0dXJuIDF9cmV0dXJuIHJ9cCg4MTcsMSx7fSx1SCksbC5jYWxjdWxhdGVDb25zdHJhaW50cz1mdW5jdGlvbihuKXt0aGlzLmNvbXBhY3Rvcj1uLGpDKHRoaXMsbmV3IHNmZSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIlNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0b3IiLDgxNyk7ZnVuY3Rpb24gcm5uKGUsbil7dmFyIHIsdDtuLmxvdz90bm4oZSxuKToocj1hKHhrKGUuaW50ZXJ2YWxzLG4ubm9kZSksNjApLHImJnI9PWUuY2FuZFtuLm5vZGUuaWRfMF0mJnIuY0dyb3VwJiZyLmNHcm91cCE9bi5ub2RlLmNHcm91cCYmci5jb25zdHJhaW50cy5hZGRfMihuLm5vZGUpLHQ9YShJayhlLmludGVydmFscyxuLm5vZGUpLDYwKSx0JiZlLmNhbmRbdC5pZF8wXT09bi5ub2RlJiZ0LmNHcm91cCYmdC5jR3JvdXAhPW4ubm9kZS5jR3JvdXAmJm4ubm9kZS5jb25zdHJhaW50cy5hZGRfMih0KSxQayhlLmludGVydmFscyxuLm5vZGUpKX1mdW5jdGlvbiB0bm4oZSxuKXt2YXIgcix0O2lmKHQ9QkMoZS5pbnRlcnZhbHMsbi5ub2RlKSwhdCl0aHJvdyBiKG5ldyBybygiSW52YWxpZCBoaXRib3hlcyBmb3Igc2NhbmxpbmUgY29uc3RyYWludCBjYWxjdWxhdGlvbi4iKSk7KG9mZShuLm5vZGUsYShWUWUoZS5pbnRlcnZhbHMsbi5ub2RlKSw2MCkpfHxvZmUobi5ub2RlLGEoalFlKGUuaW50ZXJ2YWxzLG4ubm9kZSksNjApKSkmJm5jKCksZS5jYW5kW24ubm9kZS5pZF8wXT1hKHhrKGUuaW50ZXJ2YWxzLG4ubm9kZSksNjApLHI9YShJayhlLmludGVydmFscyxuLm5vZGUpLDYwKSxyJiYoZS5jYW5kW3IuaWRfMF09bi5ub2RlKX1mdW5jdGlvbiBvbm4oZSl7dmFyIG4scix0O2ZvcihlLmludGVydmFscy5tYXBfMC5jbGVhcl8wKCksZS5jYW5kPUIoYngsTWUsNjAsZS50aGlzJDAxLmNvbXBhY3Rvci5jR3JhcGguY05vZGVzLmFycmF5Lmxlbmd0aCwwLDEpLG49MCx0PW5ldyBUKGUudGhpcyQwMS5jb21wYWN0b3IuY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDYwKSxyLmlkXzA9bisrfWZ1bmN0aW9uIGlmZShlKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmludGVydmFscz1uZXcgRmMoYSh2bihuZXcgYWZlKSw1MCkpfWZ1bmN0aW9uIGlubihlLG4pe3JldHVybiBpcihlLmhpdGJveC54XzArZS5oaXRib3gud2lkdGhfMC8yLG4uaGl0Ym94LnhfMCtuLmhpdGJveC53aWR0aF8wLzIpfXAoMTc4NCwxLHs2OTM6MX0saWZlKSxsLmhhbmRsZT1mdW5jdGlvbihuKXtybm4odGhpcyxhKG4sNDczKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIlNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0b3IvQ29uc3RyYWludHNTY2FubGluZUhhbmRsZXIiLDE3ODQpO2Z1bmN0aW9uIGFmZSgpe31wKDE3ODUsMSxObixhZmUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIGlubihhKG4sNjApLGEociw2MCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub25lZCIsIlNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0b3IvQ29uc3RyYWludHNTY2FubGluZUhhbmRsZXIvbGFtYmRhJDAkVHlwZSIsMTc4NSk7ZnVuY3Rpb24gY0goZSxuKXt0aGlzLm5vZGU9ZSx0aGlzLmxvdz1ufXAoNDczLDEsezQ3MzoxfSxjSCksbC5sb3c9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbi5vbmVkIiwiU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRvci9UaW1lc3RhbXAiLDQ3Myk7ZnVuY3Rpb24gbGZlKCl7fXAoMTc4NiwxLE5uLGxmZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gbm5uKGEobiw0NzMpLGEociw0NzMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9uZWQiLCJTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdG9yL2xhbWJkYSQwJFR5cGUiLDE3ODYpO2Z1bmN0aW9uIHNmZSgpe31wKDE3ODcsMSxKcyxzZmUpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDYwKSwhMH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNjApLCEwfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9uZWQiLCJTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdG9yL2xhbWJkYSQxJFR5cGUiLDE3ODcpO2Z1bmN0aW9uIHh4KCl7eHg9RixHaz1uZXcgX0goIk5VTV9PRl9FWFRFUk5BTF9TSURFU19USEFOX05VTV9PRl9FWFRFTlNJT05TX0xBU1QiLDApLGRIPW5ldyBfSCgiQ09STkVSX0NBU0VTX1RIQU5fU0lOR0xFX1NJREVfTEFTVCIsMSl9ZnVuY3Rpb24gX0goZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBhbm4oZSl7cmV0dXJuIHh4KCksd24oKHVmZSgpLGNmZSksZSl9ZnVuY3Rpb24gbG5uKCl7cmV0dXJuIHh4KCksUChJKGZILDEpLFcsNDM2LDAsW0drLGRIXSl9cCg0MzYsMjIsezM6MSwzNDoxLDIyOjEsNDM2OjF9LF9IKTt2YXIgZEgsR2ssZkg9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLmNvbXBhY3Rpb24ub3B0aW9ucyIsIkhpZ2hMZXZlbFNvcnRpbmdDcml0ZXJpb24iLDQzNixnbixsbm4sYW5uKTtmdW5jdGlvbiB1ZmUoKXt1ZmU9RixjZmU9eW4oKHh4KCksUChJKGZILDEpLFcsNDM2LDAsW0drLGRIXSkpKX12YXIgY2ZlO2Z1bmN0aW9uIFB4KCl7UHg9RixnSD1uZXcgcEgoIkJZX1NJWkUiLDApLEhrPW5ldyBwSCgiQllfU0laRV9BTkRfU0hBUEUiLDEpfWZ1bmN0aW9uIHBIKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gc25uKGUpe3JldHVybiBQeCgpLHduKChfZmUoKSxkZmUpLGUpfWZ1bmN0aW9uIHVubigpe3JldHVybiBQeCgpLFAoSShoSCwxKSxXLDQzNSwwLFtnSCxIa10pfXAoNDM1LDIyLHszOjEsMzQ6MSwyMjoxLDQzNToxfSxwSCk7dmFyIGdILEhrLGhIPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9wdGlvbnMiLCJMb3dMZXZlbFNvcnRpbmdDcml0ZXJpb24iLDQzNSxnbix1bm4sc25uKTtmdW5jdGlvbiBfZmUoKXtfZmU9RixkZmU9eW4oKFB4KCksUChJKGhILDEpLFcsNDM1LDAsW2dILEhrXSkpKX12YXIgZGZlLERwPUNyKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiSUxheW91dE1ldGFEYXRhUHJvdmlkZXIiKTtmdW5jdGlvbiBOeCgpe054PUYsQ0g9KEF4KCksVWspLFNIPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby50cmF2ZXJzYWxTdHJhdGVneSIsQ0gpLHZIPShQeCgpLEhrKSxFSD1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wb2x5b21pbm8ubG93TGV2ZWxTb3J0Iix2SCksd0g9KHh4KCksR2spLHlIPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby5oaWdoTGV2ZWxTb3J0Iix3SCksbUg9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucG9seW9taW5vLmZpbGwiLCh6ZSgpLCEwKSl9ZnVuY3Rpb24gZmZlKCl7TngoKX1wKDg2NCwxLHBsLGZmZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe19lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby50cmF2ZXJzYWxTdHJhdGVneSIpLCJwb2x5b21pbm8iKSwiUG9seW9taW5vIFRyYXZlcnNhbCBTdHJhdGVneSIpLCJUcmF2ZXJzYWwgc3RyYXRlZ3kgZm9yIHRyeWluZyBkaWZmZXJlbnQgY2FuZGlkYXRlIHBvc2l0aW9ucyBmb3IgcG9seW9taW5vZXMuIiksQ0gpLChKYygpLG1yKSksa0gpLEVlKChocygpLE9lKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9seW9taW5vLmxvd0xldmVsU29ydCIpLCJwb2x5b21pbm8iKSwiUG9seW9taW5vIFNlY29uZGFyeSBTb3J0aW5nIENyaXRlcmlvbiIpLCJQb3NzaWJsZSBzZWNvbmRhcnkgc29ydGluZyBjcml0ZXJpYSBmb3IgdGhlIHByb2Nlc3Npbmcgb3JkZXIgb2YgcG9seW9taW5vZXMuIFRoZXkgYXJlIHVzZWQgd2hlbiBwb2x5b21pbm9lcyBhcmUgZXF1YWwgYWNjb3JkaW5nIHRvIHRoZSBwcmltYXJ5IHNvcnRpbmcgY3JpdGVyaW9uIEhpZ2hMZXZlbFNvcnRpbmdDcml0ZXJpb24uIiksdkgpLG1yKSxoSCksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby5oaWdoTGV2ZWxTb3J0IiksInBvbHlvbWlubyIpLCJQb2x5b21pbm8gUHJpbWFyeSBTb3J0aW5nIENyaXRlcmlvbiIpLCJQb3NzaWJsZSBwcmltYXJ5IHNvcnRpbmcgY3JpdGVyaWEgZm9yIHRoZSBwcm9jZXNzaW5nIG9yZGVyIG9mIHBvbHlvbWlub2VzLiIpLHdIKSxtciksZkgpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5wb2x5b21pbm8uZmlsbCIpLCJwb2x5b21pbm8iKSwiRmlsbCBQb2x5b21pbm9lcyIpLCJVc2UgdGhlIFByb2ZpbGUgRmlsbCBhbGdvcml0aG0gdG8gZmlsbCBwb2x5b21pbm9lcyB0byBwcmV2ZW50IHNtYWxsIHBvbHlvbWlub2VzIGZyb20gYmVpbmcgcGxhY2VkIGluc2lkZSBvZiBiaWcgcG9seW9taW5vZXMgd2l0aCBsYXJnZSBob2xlcy4gTWlnaHQgaW5jcmVhc2UgcGFja2luZyBhcmVhLiIpLCh6ZSgpLCEwKSksbnQpLEFyKSxFZShPZSkpKSl9O3ZhciBtSCx5SCx3SCxFSCx2SCxTSCxDSDtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5jb21wYWN0aW9uLm9wdGlvbnMiLCJQb2x5b21pbm9PcHRpb25zIiw4NjQpO2Z1bmN0aW9uIEF4KCl7QXg9RixMSD1uZXcgRnAoIlNQSVJBTCIsMCkseEg9bmV3IEZwKCJMSU5FX0JZX0xJTkUiLDEpLFBIPW5ldyBGcCgiTUFOSEFUVEFOIiwyKSxJSD1uZXcgRnAoIkpJVFRFUiIsMyksVWs9bmV3IEZwKCJRVUFEUkFOVFNfTElORV9CWV9MSU5FIiw0KSxBSD1uZXcgRnAoIlFVQURSQU5UU19NQU5IQVRUQU4iLDUpLE5IPW5ldyBGcCgiUVVBRFJBTlRTX0pJVFRFUiIsNiksYkg9bmV3IEZwKCJDT01CSU5FX0xJTkVfQllfTElORV9NQU5IQVRUQU4iLDcpLFRIPW5ldyBGcCgiQ09NQklORV9KSVRURVJfTUFOSEFUVEFOIiw4KX1mdW5jdGlvbiBGcChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGNubihlKXtyZXR1cm4gQXgoKSx3bigocGZlKCksZ2ZlKSxlKX1mdW5jdGlvbiBfbm4oKXtyZXR1cm4gQXgoKSxQKEkoa0gsMSksVywyNTcsMCxbTEgseEgsUEgsSUgsVWssQUgsTkgsYkgsVEhdKX1wKDI1NywyMix7MzoxLDM0OjEsMjI6MSwyNTc6MX0sRnApO3ZhciBUSCxiSCxJSCx4SCxQSCxOSCxVayxBSCxMSCxrSD1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uY29tcGFjdGlvbi5vcHRpb25zIiwiVHJhdmVyc2FsU3RyYXRlZ3kiLDI1Nyxnbixfbm4sY25uKTtmdW5jdGlvbiBwZmUoKXtwZmU9RixnZmU9eW4oKEF4KCksUChJKGtILDEpLFcsMjU3LDAsW0xILHhILFBILElILFVrLEFILE5ILGJILFRIXSkpKX12YXIgZ2ZlO2Z1bmN0aW9uIEx4KGUsbil7aWYobj09ZS5zb3VyY2UpcmV0dXJuIGUudGFyZ2V0O2lmKG49PWUudGFyZ2V0KXJldHVybiBlLnNvdXJjZTt0aHJvdyBiKG5ldyBHZSgiTm9kZSAiK24rIiBub3QgcGFydCBvZiBlZGdlICIrZSkpfWZ1bmN0aW9uIGhmZSgpe31wKDIxOCwxLHsyMTg6MX0saGZlKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iTkVkZ2VbaWQ9Iit0aGlzLmlkXzArIiB3PSIrdGhpcy53ZWlnaHQrIiBkPSIrdGhpcy5kZWx0YSsiXSJ9LGwuZGVsdGE9MSxsLmlkXzA9MCxsLmludGVybmFsSWQ9MCxsLnRyZWVFZGdlPSExLGwud2VpZ2h0PTA7dmFyIG1mZT1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5uZXR3b3Jrc2ltcGxleCIsIk5FZGdlIiwyMTgpO2Z1bmN0aW9uIEZsKGUpe2lmKCFlLmVkZ2Uuc291cmNlfHwhZS5lZGdlLnRhcmdldCl0aHJvdyBiKG5ldyBybygoSnUobWZlKSxtZmUuc2ltcGxlTmFtZSsiIG11c3QgaGF2ZSBhIHNvdXJjZSBhbmQgdGFyZ2V0ICIrKEp1KE9IKSxPSC5zaW1wbGVOYW1lKSsiIHNwZWNpZmllZC4iKSkpO2lmKGUuZWRnZS5zb3VyY2U9PWUuZWRnZS50YXJnZXQpdGhyb3cgYihuZXcgcm8oIk5ldHdvcmsgc2ltcGxleCBkb2VzIG5vdCBzdXBwb3J0IHNlbGYtbG9vcHM6ICIrZS5lZGdlKyIgIitlLmVkZ2Uuc291cmNlKyIgIitlLmVkZ2UudGFyZ2V0KSk7cmV0dXJuIGt4KGUuZWRnZS5zb3VyY2Uub3V0Z29pbmdFZGdlcyxlLmVkZ2UpLGt4KGUuZWRnZS50YXJnZXQuaW5jb21pbmdFZGdlcyxlLmVkZ2UpLGUuZWRnZX1mdW5jdGlvbiB6bChlLG4pe3JldHVybiBlLmVkZ2UuZGVsdGE9bixlfWZ1bmN0aW9uICRsKGUsbil7cmV0dXJuIGUuZWRnZS5zb3VyY2U9bixlfWZ1bmN0aW9uIEJsKGUsbil7cmV0dXJuIGUuZWRnZS50YXJnZXQ9bixlfWZ1bmN0aW9uIEdsKGUsbil7cmV0dXJuIGUuZWRnZS53ZWlnaHQ9bixlfWZ1bmN0aW9uIEVsKCl7dGhpcy5lZGdlPW5ldyBoZmV9cCgxODIsMSx7fSxFbCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubmV0d29ya3NpbXBsZXgiLCJORWRnZS9ORWRnZUJ1aWxkZXIiLDE4Mik7ZnVuY3Rpb24gZG5uKGUsbil7dmFyIHIsdCxvO2ZvcihyPUYxKG5ldyBSXyxlKSxvPW5ldyBUKG4pO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMjUpLEZsKEJsKCRsKEdsKHpsKG5ldyBFbCwwKSwwKSxyKSx0KSk7cmV0dXJuIHJ9ZnVuY3Rpb24geWZlKGUsbixyKXt2YXIgdCxvLGk7aWYoIXJbbi5pbnRlcm5hbElkXSlmb3IocltuLmludGVybmFsSWRdPSEwLG89bmV3IFQoenAobikpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwyMTgpLGk9THgodCxuKSx5ZmUoZSxpLHIpfWZ1bmN0aW9uIGZubihlKXt2YXIgbixyLHQsbztmb3Iobj1uZXcgUSxyPUIoeWEseHUsMjgsZS5ub2Rlcy5hcnJheS5sZW5ndGgsMTYsMSksUkIocixyLmxlbmd0aCksbz1uZXcgVChlLm5vZGVzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTI1KSxyW3QuaW50ZXJuYWxJZF18fChSZShuLmFycmF5LHQpLHlmZShlLHQscikpO3JldHVybiBufWZ1bmN0aW9uIHBubihlKXt2YXIgbixyLHQsbyxpO2ZvcihyPTAsbz1uZXcgVChlLm5vZGVzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTI1KSx0LmludGVybmFsSWQ9cisrO3JldHVybiBuPWZubihlKSxpPW51bGwsbi5hcnJheS5sZW5ndGg+MSYmKGk9ZG5uKGUsbikpLGl9ZnVuY3Rpb24gV2soKXt0aGlzLm5vZGVzPW5ldyBRfXAoNjYyLDEse30sV2spLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5ldHdvcmtzaW1wbGV4IiwiTkdyYXBoIiw2NjIpO2Z1bmN0aW9uIHpwKGUpe3JldHVybihlLmluY29taW5nRWRnZXNNb2RDbnQhPWUuaW5jb21pbmdFZGdlcy5tb2RDb3VudHx8ZS5vdXRnb2luZ0VkZ2VzTW9kQ250IT1lLm91dGdvaW5nRWRnZXMubW9kQ291bnQpJiYoX2YoZS5hbGxFZGdlcy5hcnJheSwwKSxxcihlLmFsbEVkZ2VzLGUuaW5jb21pbmdFZGdlcykscXIoZS5hbGxFZGdlcyxlLm91dGdvaW5nRWRnZXMpLGUuaW5jb21pbmdFZGdlc01vZENudD1lLmluY29taW5nRWRnZXMubW9kQ291bnQsZS5vdXRnb2luZ0VkZ2VzTW9kQ250PWUub3V0Z29pbmdFZGdlcy5tb2RDb3VudCksZS5hbGxFZGdlc31mdW5jdGlvbiB3ZmUoKXt0aGlzLm91dGdvaW5nRWRnZXM9bmV3IFJILHRoaXMuaW5jb21pbmdFZGdlcz1uZXcgUkgsdGhpcy5hbGxFZGdlcz1uZXcgUSx0aGlzLnVua25vd25DdXR2YWx1ZXM9bmV3IFF9cCgxMjUsMSx7MTI1OjF9LHdmZSksbC5pbmNvbWluZ0VkZ2VzTW9kQ250PS0xLGwuaW50ZXJuYWxJZD0wLGwubGF5ZXI9MCxsLm91dGdvaW5nRWRnZXNNb2RDbnQ9LTEsbC50cmVlTm9kZT0hMTt2YXIgT0g9Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubmV0d29ya3NpbXBsZXgiLCJOTm9kZSIsMTI1KTtmdW5jdGlvbiBreChlLG4pe3JldHVybisrZS5tb2RDb3VudCxlZShlLmxpc3Qsbil9ZnVuY3Rpb24gTUgoZSxuKXtyZXR1cm4rK2UubW9kQ291bnQsUGkoZS5saXN0LG4pfWZ1bmN0aW9uIFJIKCl7dGhpcy5saXN0PW5ldyBRfXAoODA4LDEsdWllLFJIKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLnBhcmFsbGVsU3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLDE2KSl9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3dfKHRoaXMsbil9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLDE2KSl9LGwuYWRkXzM9ZnVuY3Rpb24obixyKXsrK3RoaXMubW9kQ291bnQsQTEodGhpcy5saXN0LG4scil9LGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIGt4KHRoaXMsbil9LGwuYWRkQWxsXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4rK3RoaXMubW9kQ291bnQsT0IodGhpcy5saXN0LG4scil9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybisrdGhpcy5tb2RDb3VudCxxcih0aGlzLmxpc3Qsbil9LGwuY2xlYXJfMD1mdW5jdGlvbigpeysrdGhpcy5tb2RDb3VudCxfZih0aGlzLmxpc3QuYXJyYXksMCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIGZvKHRoaXMubGlzdCxuLDApIT0tMX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gckModGhpcy5saXN0LG4pfSxsLmdldF8wPWZ1bmN0aW9uKG4pe3JldHVybiBsZSh0aGlzLmxpc3Qsbil9LGwuaW5kZXhPZl8wPWZ1bmN0aW9uKG4pe3JldHVybiBmbyh0aGlzLmxpc3QsbiwwKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGlzdC5hcnJheS5sZW5ndGg9PTB9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBhaChuZXcgVCh0aGlzLmxpc3QpKX0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7cmV0dXJuKyt0aGlzLm1vZENvdW50LE1jKHRoaXMubGlzdCxuKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gTUgodGhpcyxuKX0sbC5zZXRfMj1mdW5jdGlvbihuLHIpe3JldHVybisrdGhpcy5tb2RDb3VudCxLYSh0aGlzLmxpc3QsbixyKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saXN0LmFycmF5Lmxlbmd0aH0sbC5zdWJMaXN0PWZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBPYyh0aGlzLmxpc3QsbixyKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHZ4KHRoaXMubGlzdC5hcnJheSl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiBJcyh0aGlzLmxpc3Qsbil9LGwubW9kQ291bnQ9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5uZXR3b3Jrc2ltcGxleCIsIk5Ob2RlL0NoYW5nZUF3YXJlQXJyYXlMaXN0Iiw4MDgpO2Z1bmN0aW9uIEYxKGUsbil7cmV0dXJuIGVlKG4ubm9kZXMsZS5ub2RlKSxlLm5vZGV9ZnVuY3Rpb24gVkMoZSxuKXtyZXR1cm4gZS5ub2RlLm9yaWdpbl8wPW4sZX1mdW5jdGlvbiBSXygpe3RoaXMubm9kZT1uZXcgd2ZlfXAoMjc1LDEse30sUl8pLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5ldHdvcmtzaW1wbGV4IiwiTk5vZGUvTk5vZGVCdWlsZGVyIiwyNzUpO2Z1bmN0aW9uIGdubihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHM9bnVsbCxpPW5ldyBUKGUuZ3JhcGhfMC5ub2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG89YShDKGkpLDEyNSksby5pbmNvbWluZ0VkZ2VzLmxpc3QuYXJyYXkubGVuZ3RoPT1vLm91dGdvaW5nRWRnZXMubGlzdC5hcnJheS5sZW5ndGgpe2Zvcih0PW8ubGF5ZXIscz1Tbm4obykscj1vLmxheWVyLWEocy5maXJzdCwxNykudmFsdWVfMCsxO3I8by5sYXllcithKHMuc2Vjb25kLDE3KS52YWx1ZV8wO3IrKyluW3JdPG5bdF0mJih0PXIpO25bdF08bltvLmxheWVyXSYmKC0tbltvLmxheWVyXSwrK25bdF0sby5sYXllcj10KX19ZnVuY3Rpb24gRWZlKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkO2Zvcih0PW5ldyBRLHM9bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihvPWEoQyhzKSwxMjUpLGQ9MCxvLnVua25vd25DdXR2YWx1ZXMuYXJyYXkubGVuZ3RoPTAscj1uZXcgVCh6cChvKSk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDIxOCksbi50cmVlRWRnZSYmKGVlKG8udW5rbm93bkN1dHZhbHVlcyxuKSwrK2QpO2Q9PTEmJlJlKHQuYXJyYXksbyl9Zm9yKGk9bmV3IFQodCk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwxMjUpO28udW5rbm93bkN1dHZhbHVlcy5hcnJheS5sZW5ndGg9PTE7KXtmb3IoXz1hKEMobmV3IFQoby51bmtub3duQ3V0dmFsdWVzKSksMjE4KSxlLmN1dHZhbHVlW18uaW50ZXJuYWxJZF09Xy53ZWlnaHQsdT1fLnNvdXJjZSxjPV8udGFyZ2V0LHI9bmV3IFQoenAobykpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwyMTgpLFluKG4sXyl8fChuLnRyZWVFZGdlP3U9PW4uc291cmNlfHxjPT1uLnRhcmdldD9lLmN1dHZhbHVlW18uaW50ZXJuYWxJZF0tPWUuY3V0dmFsdWVbbi5pbnRlcm5hbElkXS1uLndlaWdodDplLmN1dHZhbHVlW18uaW50ZXJuYWxJZF0rPWUuY3V0dmFsdWVbbi5pbnRlcm5hbElkXS1uLndlaWdodDpvPT11P24uc291cmNlPT1vP2UuY3V0dmFsdWVbXy5pbnRlcm5hbElkXSs9bi53ZWlnaHQ6ZS5jdXR2YWx1ZVtfLmludGVybmFsSWRdLT1uLndlaWdodDpuLnNvdXJjZT09bz9lLmN1dHZhbHVlW18uaW50ZXJuYWxJZF0tPW4ud2VpZ2h0OmUuY3V0dmFsdWVbXy5pbnRlcm5hbElkXSs9bi53ZWlnaHQpO1BpKHUudW5rbm93bkN1dHZhbHVlcyxfKSxQaShjLnVua25vd25DdXR2YWx1ZXMsXyksdT09bz9vPV8udGFyZ2V0Om89Xy5zb3VyY2V9fWZ1bmN0aW9uIGhubihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2lmKCFuLnRyZWVFZGdlKXRocm93IGIobmV3IEdlKCJUaGUgaW5wdXQgZWRnZSBpcyBub3QgYSB0cmVlIGVkZ2UuIikpO2ZvcihpPW51bGwsbz1xbix0PW5ldyBUKGUuZWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwyMTgpLHU9ci5zb3VyY2UsYz1yLnRhcmdldCxWayhlLHUsbikmJiFWayhlLGMsbikmJihzPWMubGF5ZXItdS5sYXllci1yLmRlbHRhLHM8byYmKG89cyxpPXIpKTtyZXR1cm4gaX1mdW5jdGlvbiBtbm4oZSxuLHIpe3ZhciB0LG8saTtpZighbi50cmVlRWRnZSl0aHJvdyBiKG5ldyBHZSgiR2l2ZW4gbGVhdmUgZWRnZSBpcyBubyB0cmVlIGVkZ2UuIikpO2lmKHIudHJlZUVkZ2UpdGhyb3cgYihuZXcgR2UoIkdpdmVuIGVudGVyIGVkZ2UgaXMgYSB0cmVlIGVkZ2UgYWxyZWFkeS4iKSk7Zm9yKG4udHJlZUVkZ2U9ITEsZUcoZS50cmVlRWRnZXMsbiksci50cmVlRWRnZT0hMCxZcihlLnRyZWVFZGdlcyxyKSx0PXIudGFyZ2V0LmxheWVyLXIuc291cmNlLmxheWVyLXIuZGVsdGEsVmsoZSxyLnRhcmdldCxuKXx8KHQ9LXQpLGk9bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTI1KSxWayhlLG8sbil8fChvLmxheWVyKz10KTtlLnBvc3RPcmRlcj0xLFoyKGUuZWRnZVZpc2l0ZWQpLERIKGUsYShDKG5ldyBUKGUuZ3JhcGhfMC5ub2RlcykpLDEyNSkpLEVmZShlKX1mdW5jdGlvbiBqayhlLG4pe3ZhciByLHQsbyxpLHM7aWYobi5iZWdpbigiTmV0d29yayBzaW1wbGV4IiwxKSxlLmdyYXBoXzAubm9kZXMuYXJyYXkubGVuZ3RoPDEpe24uZG9uZV8xKCk7cmV0dXJufWZvcihpPW5ldyBUKGUuZ3JhcGhfMC5ub2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEyNSksby5sYXllcj0wO2ZvcihzPWUuZ3JhcGhfMC5ub2Rlcy5hcnJheS5sZW5ndGg+PTQwLHMmJlRubihlKSx3bm4oZSkseW5uKGUpLHI9dmZlKGUpLHQ9MDtyJiZ0PGUuaXRlcmF0aW9uTGltaXQ7KW1ubihlLHIsaG5uKGUscikpLHI9dmZlKGUpLCsrdDtzJiZDbm4oZSksZS5iYWxhbmNlP2dubihlLFNmZShlKSk6U2ZlKGUpLGUuY3V0dmFsdWU9bnVsbCxlLmVkZ2VzPW51bGwsZS50cmVlRWRnZXM9bnVsbCxlLmVkZ2VWaXNpdGVkPW51bGwsZS5sb3dlc3RQb0lEPW51bGwsZS5wb0lEPW51bGwsZS5zb3VyY2VzPW51bGwsZS5zdWJ0cmVlTm9kZXNTdGFjaz1udWxsLG4uZG9uZV8xKCl9ZnVuY3Rpb24geW5uKGUpe3ZhciBuLHIsdCxvO2lmKEVubihlLGUuc291cmNlcyksZS5lZGdlcy5hcnJheS5sZW5ndGg+MCl7Zm9yKFoyKGUuZWRnZVZpc2l0ZWQpO0ZIKGUsYShDKG5ldyBUKGUuZ3JhcGhfMC5ub2RlcykpLDEyNSkpPGUuZ3JhcGhfMC5ub2Rlcy5hcnJheS5sZW5ndGg7KXtmb3Iobj12bm4oZSksbz1uLnRhcmdldC5sYXllci1uLnNvdXJjZS5sYXllci1uLmRlbHRhLG4udGFyZ2V0LnRyZWVOb2RlJiYobz0tbyksdD1uZXcgVChlLmdyYXBoXzAubm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxMjUpLHIudHJlZU5vZGUmJihyLmxheWVyKz1vKTtaMihlLmVkZ2VWaXNpdGVkKX1aMihlLmVkZ2VWaXNpdGVkKSxESChlLGEoQyhuZXcgVChlLmdyYXBoXzAubm9kZXMpKSwxMjUpKSxFZmUoZSl9fWZ1bmN0aW9uIHdubihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihkPWUuZ3JhcGhfMC5ub2Rlcy5hcnJheS5sZW5ndGgscz1uZXcgVChlLmdyYXBoXzAubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMjUpLGkudHJlZU5vZGU9ITE7Zm9yKGUucG9JRD1CKGhuLGtuLDI4LGQsMTUsMSksZS5sb3dlc3RQb0lEPUIoaG4sa24sMjgsZCwxNSwxKSxlLnNvdXJjZXM9bmV3IFEsbz0wLGY9bmV3IFEsYz1uZXcgVChlLmdyYXBoXzAubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxMjUpLHUuaW50ZXJuYWxJZD1vKyssdS5pbmNvbWluZ0VkZ2VzLmxpc3QuYXJyYXkubGVuZ3RoPT0wJiZlZShlLnNvdXJjZXMsdSkscXIoZix1Lm91dGdvaW5nRWRnZXMpO2ZvcihuPTAsdD1uZXcgVChmKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMjE4KSxyLmludGVybmFsSWQ9bisrLHIudHJlZUVkZ2U9ITE7Xz1mLmFycmF5Lmxlbmd0aCxlLmN1dHZhbHVlPT1udWxsfHxlLmN1dHZhbHVlLmxlbmd0aDxfPyhlLmN1dHZhbHVlPUIoY3QsWHQsMjgsXywxNSwxKSxlLmVkZ2VWaXNpdGVkPUIoeWEseHUsMjgsXywxNiwxKSk6WjIoZS5lZGdlVmlzaXRlZCksZS5lZGdlcz1mLGUudHJlZUVkZ2VzPW5ldyB0ayhLZChlLmVkZ2VzLmFycmF5Lmxlbmd0aCkpLGUucG9zdE9yZGVyPTF9ZnVuY3Rpb24gVmsoZSxuLHIpe3ZhciB0LG87cmV0dXJuIHQ9ci5zb3VyY2Usbz1yLnRhcmdldCxlLmxvd2VzdFBvSURbdC5pbnRlcm5hbElkXTw9ZS5wb0lEW24uaW50ZXJuYWxJZF0mJmUucG9JRFtuLmludGVybmFsSWRdPD1lLnBvSURbdC5pbnRlcm5hbElkXSYmZS5sb3dlc3RQb0lEW28uaW50ZXJuYWxJZF08PWUucG9JRFtuLmludGVybmFsSWRdJiZlLnBvSURbbi5pbnRlcm5hbElkXTw9ZS5wb0lEW28uaW50ZXJuYWxJZF0/IShlLnBvSURbdC5pbnRlcm5hbElkXTxlLnBvSURbby5pbnRlcm5hbElkXSk6ZS5wb0lEW3QuaW50ZXJuYWxJZF08ZS5wb0lEW28uaW50ZXJuYWxJZF19ZnVuY3Rpb24gRW5uKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKG89QihobixrbiwyOCxlLmdyYXBoXzAubm9kZXMuYXJyYXkubGVuZ3RoLDE1LDEpLHM9bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTI1KSxvW2kuaW50ZXJuYWxJZF0rPWkuaW5jb21pbmdFZGdlcy5saXN0LmFycmF5Lmxlbmd0aDtmb3IodT1jQyhuKTt1LnNpemVfMCE9MDspZm9yKGk9YSh1LnNpemVfMD09MD9udWxsOihybih1LnNpemVfMCE9MCksWmEodSx1LmhlYWRlci5uZXh0XzApKSwxMjUpLHQ9YWgobmV3IFQoaS5vdXRnb2luZ0VkZ2VzLmxpc3QpKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwyMTgpLGM9ci50YXJnZXQsYy5sYXllcj1TLk1hdGgubWF4KGMubGF5ZXIsaS5sYXllcityLmRlbHRhKSwtLW9bYy5pbnRlcm5hbElkXSxvW2MuaW50ZXJuYWxJZF09PTAmJmJyKHUsYyx1LnRhaWwucHJldix1LnRhaWwpfWZ1bmN0aW9uIHZmZShlKXt2YXIgbixyO2ZvcihyPWUudHJlZUVkZ2VzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KWlmKG49YShyLm5leHRfMSgpLDIxOCksbi50cmVlRWRnZSYmZS5jdXR2YWx1ZVtuLmludGVybmFsSWRdPC0xZS0xMClyZXR1cm4gbjtyZXR1cm4gbnVsbH1mdW5jdGlvbiB2bm4oZSl7dmFyIG4scix0LG8saTtmb3Iobz1xbixpPW51bGwsdD1uZXcgVChlLmVkZ2VzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMjE4KSxyLnNvdXJjZS50cmVlTm9kZV5yLnRhcmdldC50cmVlTm9kZSYmKG49ci50YXJnZXQubGF5ZXItci5zb3VyY2UubGF5ZXItci5kZWx0YSxuPG8mJihvPW4saT1yKSk7cmV0dXJuIGl9ZnVuY3Rpb24gU25uKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKGk9cW4sbz1xbix0PW5ldyBUKHpwKGUpKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMjE4KSxuPXIudGFyZ2V0LmxheWVyLXIuc291cmNlLmxheWVyLHIudGFyZ2V0PT1lJiZuPG8/bz1uOm48aSYmKGk9bik7cmV0dXJuIG89PXFuJiYobz0tMSksaT09cW4mJihpPS0xKSxuZXcgWnIoSihvKSxKKGkpKX1mdW5jdGlvbiBTZmUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZjtmb3Iocj1idCxvPXFuLHU9bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEModSksMTI1KSxvPVMuTWF0aC5taW4obyxpLmxheWVyKSxyPVMuTWF0aC5tYXgocixpLmxheWVyKTtmb3Iobj1CKGhuLGtuLDI4LHItbysxLDE1LDEpLHM9bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTI1KSxpLmxheWVyLT1vLCsrbltpLmxheWVyXTtpZih0PTAsZS5wcmV2aW91c0xheWVyaW5nTm9kZUNvdW50cyE9bnVsbClmb3IoXz1lLnByZXZpb3VzTGF5ZXJpbmdOb2RlQ291bnRzLGQ9MCxmPV8ubGVuZ3RoO2Q8ZiYmKGM9X1tkXSxuW3QrK10rPWMsbi5sZW5ndGghPXQpOysrZCk7cmV0dXJuIG59ZnVuY3Rpb24gREgoZSxuKXt2YXIgcix0LG87Zm9yKG89cW4sdD1uZXcgVCh6cChuKSk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDIxOCksci50cmVlRWRnZSYmIWUuZWRnZVZpc2l0ZWRbci5pbnRlcm5hbElkXSYmKGUuZWRnZVZpc2l0ZWRbci5pbnRlcm5hbElkXT0hMCxvPVMuTWF0aC5taW4obyxESChlLEx4KHIsbikpKSk7cmV0dXJuIGUucG9JRFtuLmludGVybmFsSWRdPWUucG9zdE9yZGVyLGUubG93ZXN0UG9JRFtuLmludGVybmFsSWRdPVMuTWF0aC5taW4obyxlLnBvc3RPcmRlcisrKSxlLmxvd2VzdFBvSURbbi5pbnRlcm5hbElkXX1mdW5jdGlvbiBDbm4oZSl7Zm9yKHZhciBuLHIsdCxvOyFZMihlLnN1YnRyZWVOb2Rlc1N0YWNrKTspcj1hKG1oKGUuc3VidHJlZU5vZGVzU3RhY2spLDQyKSx0PWEoci5maXJzdCwxMjUpLG49YShyLnNlY29uZCwyMTgpLG89THgobix0KSxuLnRhcmdldD09dD8oa3goby5vdXRnb2luZ0VkZ2VzLG4pLHQubGF5ZXI9by5sYXllcituLmRlbHRhKTooa3goby5pbmNvbWluZ0VkZ2VzLG4pLHQubGF5ZXI9by5sYXllci1uLmRlbHRhKSxlZShlLmdyYXBoXzAubm9kZXMsdCl9ZnVuY3Rpb24gVG5uKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihlLnN1YnRyZWVOb2Rlc1N0YWNrPW5ldyBBcCx0PW5ldyBwcixzPW5ldyBUKGUuZ3JhcGhfMC5ub2Rlcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDEyNSksenAoaSkuYXJyYXkubGVuZ3RoPT0xJiZicih0LGksdC50YWlsLnByZXYsdC50YWlsKTtmb3IoO3Quc2l6ZV8wIT0wOylpPWEodC5zaXplXzA9PTA/bnVsbDoocm4odC5zaXplXzAhPTApLFphKHQsdC5oZWFkZXIubmV4dF8wKSksMTI1KSx6cChpKS5hcnJheS5sZW5ndGghPTAmJihuPWEobGUoenAoaSksMCksMjE4KSxyPWkub3V0Z29pbmdFZGdlcy5saXN0LmFycmF5Lmxlbmd0aD4wLHU9THgobixpKSxNSChyP3UuaW5jb21pbmdFZGdlczp1Lm91dGdvaW5nRWRnZXMsbiksenAodSkuYXJyYXkubGVuZ3RoPT0xJiZicih0LHUsdC50YWlsLnByZXYsdC50YWlsKSxvPW5ldyBacihpLG4pLEkwKGUuc3VidHJlZU5vZGVzU3RhY2ssbyksUGkoZS5ncmFwaF8wLm5vZGVzLGkpKX1mdW5jdGlvbiBGSChlLG4pe3ZhciByLHQsbyxpO2ZvcihvPTEsbi50cmVlTm9kZT0hMCxpPW51bGwsdD1uZXcgVCh6cChuKSk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDIxOCksZS5lZGdlVmlzaXRlZFtyLmludGVybmFsSWRdfHwoZS5lZGdlVmlzaXRlZFtyLmludGVybmFsSWRdPSEwLGk9THgocixuKSxyLnRyZWVFZGdlP28rPUZIKGUsaSk6IWkudHJlZU5vZGUmJnIuZGVsdGE9PXIudGFyZ2V0LmxheWVyLXIuc291cmNlLmxheWVyJiYoci50cmVlRWRnZT0hMCxZcihlLnRyZWVFZGdlcyxyKSxvKz1GSChlLGkpKSk7cmV0dXJuIG99ZnVuY3Rpb24gekgoZSxuKXtyZXR1cm4gZS5iYWxhbmNlPW4sZX1mdW5jdGlvbiAkSChlLG4pe3JldHVybiBlLml0ZXJhdGlvbkxpbWl0PW4sZX1mdW5jdGlvbiBibm4oZSxuKXtyZXR1cm4gZS5wcmV2aW91c0xheWVyaW5nTm9kZUNvdW50cz1uLGV9ZnVuY3Rpb24gQ2ZlKCl7fWZ1bmN0aW9uIHFrKGUpe3ZhciBuO3JldHVybiBuPW5ldyBDZmUsbi5ncmFwaF8wPWUsbn1wKDE2OTUsMSx7fSxDZmUpLGwuYmFsYW5jZT0hMSxsLml0ZXJhdGlvbkxpbWl0PXFuLGwucG9zdE9yZGVyPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubmV0d29ya3NpbXBsZXgiLCJOZXR3b3JrU2ltcGxleCIsMTY5NSk7ZnVuY3Rpb24gVGZlKGUpe3dpKGUuZ2V0Tm9kZXMoKSxuZXcgSWZlKGUpKX1mdW5jdGlvbiBJbm4oZSl7dmFyIG4scjtmb3Iocj1uZXcgVChRemUoZSkpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw2OTUpLG4uc29ydFBvcnRMaXN0KCl9ZnVuY3Rpb24geG5uKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2ZvcihmPW5ldyBYSChlKSxvcm4oZiwhKG49PShXcigpLG9sKXx8bj09JHMpKSxkPWYuaW5zaWRlTm9kZUxhYmVsQ29udGFpbmVyLGg9bmV3IE9oLG89KHVzKCksUChJKHBmLDEpLFcsMjM3LDAsW01vLGZpLFJvXSkpLHM9MCxjPW8ubGVuZ3RoO3M8YzsrK3Mpcj1vW3NdLF89WGsoZCxNbyxyKSxfJiYoaC50b3BfMD1TLk1hdGgubWF4KGgudG9wXzAsXy5nZXRNaW5pbXVtSGVpZ2h0KCkpKTtmb3IodD1QKEkocGYsMSksVywyMzcsMCxbTW8sZmksUm9dKSxpPTAsdT10Lmxlbmd0aDtpPHU7KytpKXI9dFtpXSxfPVhrKGQsUm8sciksXyYmKGguYm90dG9tPVMuTWF0aC5tYXgoaC5ib3R0b20sXy5nZXRNaW5pbXVtSGVpZ2h0KCkpKTtmb3IoRT1QKEkocGYsMSksVywyMzcsMCxbTW8sZmksUm9dKSx4PTAsaz1FLmxlbmd0aDt4PGs7Kyt4KW09RVt4XSxfPVhrKGQsbSxNbyksXyYmKGgubGVmdD1TLk1hdGgubWF4KGgubGVmdCxfLmdldE1pbmltdW1XaWR0aCgpKSk7Zm9yKHk9UChJKHBmLDEpLFcsMjM3LDAsW01vLGZpLFJvXSksdj0wLEE9eS5sZW5ndGg7djxBOysrdiltPXlbdl0sXz1YayhkLG0sUm8pLF8mJihoLnJpZ2h0PVMuTWF0aC5tYXgoaC5yaWdodCxfLmdldE1pbmltdW1XaWR0aCgpKSk7cmV0dXJuIGgudG9wXzA+MCYmKGgudG9wXzArPWQucGFkZGluZy50b3BfMCxoLnRvcF8wKz1kLmdhcCksaC5ib3R0b20+MCYmKGguYm90dG9tKz1kLnBhZGRpbmcuYm90dG9tLGguYm90dG9tKz1kLmdhcCksaC5sZWZ0PjAmJihoLmxlZnQrPWQucGFkZGluZy5sZWZ0LGgubGVmdCs9ZC5nYXApLGgucmlnaHQ+MCYmKGgucmlnaHQrPWQucGFkZGluZy5yaWdodCxoLnJpZ2h0Kz1kLmdhcCksaH1mdW5jdGlvbiBiZmUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYztyZXR1cm4gdT1uZXcgWEgobiksX3JuKHUsdCksbz0hMCxlJiZlLmhhc1Byb3BlcnR5KChGbigpLG4xKSkmJihpPWEoZS5nZXRQcm9wZXJ0eSgoRm4oKSxuMSkpLDg4KSxvPWk9PShXcigpLEJzKXx8aT09YW98fGk9PW1vKSxxcGUodSwhMSksd2kodS5ub2RlLmdldExhYmVscygpLG5ldyBRSCh1LCExLG8pKSxsOCh1LHUubm9kZUNvbnRhaW5lciwodXMoKSxNbyksKHJlKCksVWUpKSxsOCh1LHUubm9kZUNvbnRhaW5lcixSbyxsbiksbDgodSx1Lm5vZGVDb250YWluZXJNaWRkbGVSb3csTW8samUpLGw4KHUsdS5ub2RlQ29udGFpbmVyTWlkZGxlUm93LFJvLHFlKSx6cGUodSxVZSksenBlKHUsbG4pLEZwZSh1LHFlKSxGcGUodSxqZSksZ2YoKSxzPXUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKChTYSgpLFlmKSkmJnUuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksalQpKT9XcGUodSk6bnVsbCxzJiZPbm4odS5pbnNpZGVOb2RlTGFiZWxDb250YWluZXIscyksdHJuKHUpLFlubih1KSx3cm4odSksVm5uKHUpLHVybih1KSxtcm4odSksczgodSxVZSksczgodSxsbikscW5uKHUpLHNybih1KSxyJiYobnJuKHUpLHlybih1KSxzOCh1LHFlKSxzOCh1LGplKSxjPXUuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksb1MpKSwkcGUodSxjLFVlKSwkcGUodSxjLGxuKSxCcGUodSxjLHFlKSxCcGUodSxjLGplKSxMcihuZXcgU2UobnVsbCxuZXcgeGUobmV3IHRjKHUubm9kZUxhYmVsQ2VsbHMpLDApKSxuZXcgR3BlKSxMcihKbihuZXcgU2UobnVsbCxBeih1LnBvcnRDb250ZXh0cykudGhpcyQwMS52YWx1ZVNwbGl0ZXJhdG9yKCkpLG5ldyBIcGUpLG5ldyBVcGUpLHJybih1KSx1Lm5vZGUuc2V0U2l6ZSh1Lm5vZGVTaXplKSxMcihuZXcgU2UobnVsbCxBeih1LnBvcnRDb250ZXh0cykudGhpcyQwMS52YWx1ZVNwbGl0ZXJhdG9yKCkpLG5ldyBWcGUpKSx1Lm5vZGVTaXplfWZ1bmN0aW9uIElmZShlKXt0aGlzLmdyYXBoXzA9ZX1wKDEzMTQsMSxKZSxJZmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2JmZSh0aGlzLmdyYXBoXzAsYShuLDY5NSksITAsITEpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZyIsIk5vZGVMYWJlbEFuZFNpemVDYWxjdWxhdG9yL2xhbWJkYSQwJFR5cGUiLDEzMTQpO2Z1bmN0aW9uIHhmZShlLG4scix0LG8saSxzKXtpZihlLnhfMD10LmdldFBvc2l0aW9uKCkueF8wLGUueV8wPXQuZ2V0UG9zaXRpb24oKS55XzAsbyYmKGUueF8wKz1vLmdldFBvc2l0aW9uKCkueF8wLGUueV8wKz1vLmdldFBvc2l0aW9uKCkueV8wKSxlLndpZHRoXzA9bi5nZXRTaXplKCkueF8wLGUuaGVpZ2h0PW4uZ2V0U2l6ZSgpLnlfMCwhbylyP2UueF8wLT1zK24uZ2V0U2l6ZSgpLnhfMDplLnhfMCs9dC5nZXRTaXplKCkueF8wK3M7ZWxzZSBzd2l0Y2goby5nZXRTaWRlKCkub3JkaW5hbCl7Y2FzZSAwOmNhc2UgMjplLnhfMCs9by5nZXRTaXplKCkueF8wK3MraS54XzArczticmVhaztjYXNlIDQ6ZS54XzAtPXMraS54XzArcytuLmdldFNpemUoKS54XzA7YnJlYWs7Y2FzZSAxOmUueF8wKz1vLmdldFNpemUoKS54XzArcyxlLnlfMC09cytpLnlfMCtzK24uZ2V0U2l6ZSgpLnlfMDticmVhaztjYXNlIDM6ZS54XzArPW8uZ2V0U2l6ZSgpLnhfMCtzLGUueV8wKz1vLmdldFNpemUoKS55XzArcytpLnlfMCtzfX1mdW5jdGlvbiBQbm4oZSl7cmV0dXJuIGUuaW5jbHVkZUVkZ2VIZWFkVGFpbExhYmVscz0hMSxlfWZ1bmN0aW9uIEJIKGUpe3ZhciBuLHIsdDtmb3IodD1SKCQoZS5hZGFwdGVyLmdldFByb3BlcnR5KChGbigpLHRBKSkpKSxyPW5ldyBUKGUuYWRhcHRlci5nZXROb2RlcygpKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksNjk1KSxOZmUoZSxuLHQpfWZ1bmN0aW9uIFBmZShlLG4scix0LG8saSxzKXt2YXIgdSxjLF8sZCxmLGg7Zm9yKGg9bmV3IGltLF89bi5pdGVyYXRvcl8wKCk7Xy5oYXNOZXh0XzAoKTspZm9yKHU9YShfLm5leHRfMSgpLDg1MyksZj1uZXcgVCh1LmdldExhYmVscygpKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspZD1hKEMoZiksMTg3KSxEKGQuZ2V0UHJvcGVydHkoKEZuKCksb1IpKSk9PT1EKChHcygpLFB3KSkmJih4ZmUoaCxkLCExLHQsbyxpLHMpLFJ2KGUsaCkpO2ZvcihjPXIuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KWZvcih1PWEoYy5uZXh0XzEoKSw4NTMpLGY9bmV3IFQodS5nZXRMYWJlbHMoKSk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KWQ9YShDKGYpLDE4NyksRChkLmdldFByb3BlcnR5KChGbigpLG9SKSkpPT09RCgoR3MoKSxWZikpJiYoeGZlKGgsZCwhMCx0LG8saSxzKSxSdihlLGgpKX1mdW5jdGlvbiBObm4oZSxuKXt2YXIgcjtyPVIoJChlLmFkYXB0ZXIuZ2V0UHJvcGVydHkoKEZuKCksdEEpKSkpLE5mZShlLG4scil9ZnVuY3Rpb24gTmZlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaDtpZih0PW5ldyB0bChuLmdldFBvc2l0aW9uKCkueF8wLG4uZ2V0UG9zaXRpb24oKS55XzAsbi5nZXRTaXplKCkueF8wLG4uZ2V0U2l6ZSgpLnlfMCksbz1uZXcgaW0sZS5pbmNsdWRlTGFiZWxzKWZvcihzPW5ldyBUKG4uZ2V0TGFiZWxzKCkpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxODcpLG8ueF8wPWkuZ2V0UG9zaXRpb24oKS54XzArbi5nZXRQb3NpdGlvbigpLnhfMCxvLnlfMD1pLmdldFBvc2l0aW9uKCkueV8wK24uZ2V0UG9zaXRpb24oKS55XzAsby53aWR0aF8wPWkuZ2V0U2l6ZSgpLnhfMCxvLmhlaWdodD1pLmdldFNpemUoKS55XzAsUnYodCxvKTtmb3IoXz1uZXcgVChuLmdldFBvcnRzKCkpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoYz1hKEMoXyksODUyKSxkPWMuZ2V0UG9zaXRpb24oKS54XzArbi5nZXRQb3NpdGlvbigpLnhfMCxmPWMuZ2V0UG9zaXRpb24oKS55XzArbi5nZXRQb3NpdGlvbigpLnlfMCxlLmluY2x1ZGVQb3J0cyYmKG8ueF8wPWQsby55XzA9ZixvLndpZHRoXzA9Yy5nZXRTaXplKCkueF8wLG8uaGVpZ2h0PWMuZ2V0U2l6ZSgpLnlfMCxSdih0LG8pKSxlLmluY2x1ZGVQb3J0TGFiZWxzKWZvcihzPW5ldyBUKGMuZ2V0TGFiZWxzKCkpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxODcpLG8ueF8wPWkuZ2V0UG9zaXRpb24oKS54XzArZCxvLnlfMD1pLmdldFBvc2l0aW9uKCkueV8wK2Ysby53aWR0aF8wPWkuZ2V0U2l6ZSgpLnhfMCxvLmhlaWdodD1pLmdldFNpemUoKS55XzAsUnYodCxvKTtpZihlLmluY2x1ZGVFZGdlSGVhZFRhaWxMYWJlbHMpe2lmKGg9bmV3IFkoLXIsLXIpLGEobi5nZXRQcm9wZXJ0eSgoRm4oKSxqZikpLDE4MSkuY29udGFpbnMoKGFhKCksWTApKSlmb3Iocz1uZXcgVChjLmdldExhYmVscygpKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTg3KSxoLnhfMCs9aS5nZXRTaXplKCkueF8wK3IsaC55XzArPWkuZ2V0U2l6ZSgpLnlfMCtyO2gueF8wPVMuTWF0aC5tYXgoaC54XzAsMCksaC55XzA9Uy5NYXRoLm1heChoLnlfMCwwKSxQZmUodCxjLmdldE91dGdvaW5nRWRnZXMoKSxjLmdldEluY29taW5nRWRnZXMoKSxuLGMsaCxyKX19ZS5pbmNsdWRlRWRnZUhlYWRUYWlsTGFiZWxzJiZQZmUodCxuLmdldE91dGdvaW5nRWRnZXMoKSxuLmdldEluY29taW5nRWRnZXMoKSxuLG51bGwsbnVsbCxyKSx1PW5ldyB0OShuLmdldE1hcmdpbigpKSx1LnRvcF8wPVMuTWF0aC5tYXgoMCxuLmdldFBvc2l0aW9uKCkueV8wLXQueV8wKSx1LmJvdHRvbT1TLk1hdGgubWF4KDAsdC55XzArdC5oZWlnaHQtKG4uZ2V0UG9zaXRpb24oKS55XzArbi5nZXRTaXplKCkueV8wKSksdS5sZWZ0PVMuTWF0aC5tYXgoMCxuLmdldFBvc2l0aW9uKCkueF8wLXQueF8wKSx1LnJpZ2h0PVMuTWF0aC5tYXgoMCx0LnhfMCt0LndpZHRoXzAtKG4uZ2V0UG9zaXRpb24oKS54XzArbi5nZXRTaXplKCkueF8wKSksbi5zZXRNYXJnaW4odSl9ZnVuY3Rpb24gT3goZSl7dGhpcy5hZGFwdGVyPWV9cCg1NjUsMSx7fSxPeCksbC5pbmNsdWRlRWRnZUhlYWRUYWlsTGFiZWxzPSEwLGwuaW5jbHVkZUxhYmVscz0hMCxsLmluY2x1ZGVQb3J0TGFiZWxzPSEwLGwuaW5jbHVkZVBvcnRzPSEwLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nIiwiTm9kZU1hcmdpbkNhbGN1bGF0b3IiLDU2NSk7ZnVuY3Rpb24gR0goZSxuKXtlLmNvbnRyaWJ1dGVzVG9NaW5pbXVtSGVpZ2h0PW59ZnVuY3Rpb24gTXgoKXt0aGlzLnBhZGRpbmc9bmV3IE9oLHRoaXMuY2VsbFJlY3RhbmdsZT1uZXcgaW19cCgyMTcsMSx7MjE3OjF9KSxsLmNvbnRyaWJ1dGVzVG9NaW5pbXVtSGVpZ2h0PSExLGwuY29udHJpYnV0ZXNUb01pbmltdW1XaWR0aD0hMTt2YXIgQWZlPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmNlbGxzeXN0ZW0iLCJDZWxsIiwyMTcpO2Z1bmN0aW9uIFJ4KGUpe3ZhciBuO3JldHVybiBuPWUucGFkZGluZyxlLm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wK24udG9wXzArbi5ib3R0b219ZnVuY3Rpb24gTGZlKCl7TXguY2FsbCh0aGlzKSx0aGlzLm1pbmltdW1Db250ZW50QXJlYVNpemU9bmV3IG10fXAoMTI3LDIxNyx7MTI3OjEsMjE3OjF9LExmZSksbC5nZXRNaW5pbXVtSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIFJ4KHRoaXMpfSxsLmdldE1pbmltdW1XaWR0aD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMucGFkZGluZyx0aGlzLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wK24ubGVmdCtuLnJpZ2h0fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5jZWxsc3lzdGVtIiwiQXRvbWljQ2VsbCIsMTI3KTtmdW5jdGlvbiB1cygpe3VzPUYsTW89bmV3IFlrKCJCRUdJTiIsMCksZmk9bmV3IFlrKCJDRU5URVIiLDEpLFJvPW5ldyBZaygiRU5EIiwyKX1mdW5jdGlvbiBZayhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEFubihlKXtyZXR1cm4gdXMoKSx3bigoa2ZlKCksT2ZlKSxlKX1mdW5jdGlvbiBMbm4oKXtyZXR1cm4gdXMoKSxQKEkocGYsMSksVywyMzcsMCxbTW8sZmksUm9dKX1wKDIzNywyMix7MzoxLDM0OjEsMjI6MSwyMzc6MX0sWWspO3ZhciBNbyxmaSxSbyxwZj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIkNvbnRhaW5lckFyZWEiLDIzNyxnbixMbm4sQW5uKTtmdW5jdGlvbiBrZmUoKXtrZmU9RixPZmU9eW4oKHVzKCksUChJKHBmLDEpLFcsMjM3LDAsW01vLGZpLFJvXSkpKX12YXIgT2ZlO2Z1bmN0aW9uIER4KGUsbixyKXt2YXIgdDtlJiYodD1lLmNlbGxSZWN0YW5nbGUsdC54XzA9bix0LndpZHRoXzA9cil9ZnVuY3Rpb24gRngoZSxuLHIpe3ZhciB0O2UmJih0PWUuY2VsbFJlY3RhbmdsZSx0LnlfMD1uLHQuaGVpZ2h0PXIpfWZ1bmN0aW9uIE1mZSgpe014LmNhbGwodGhpcyl9ZnVuY3Rpb24gS2soZSxuKXtyZXR1cm4hZXx8biYmIWUuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHR8fEwoZSwxMjcpJiZhKGUsMTI3KS5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMD09MD8wOmUuZ2V0TWluaW11bUhlaWdodCgpfWZ1bmN0aW9uIHp4KGUsbil7cmV0dXJuIWV8fG4mJiFlLmNvbnRyaWJ1dGVzVG9NaW5pbXVtV2lkdGh8fEwoZSwxMjcpJiZhKGUsMTI3KS5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMD09MD8wOmUuZ2V0TWluaW11bVdpZHRoKCl9cCgzMzYsMjE3LGRpZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIkNvbnRhaW5lckNlbGwiLDMzNik7ZnVuY3Rpb24gUmZlKCl7UmZlPUYsJHg9KHVzKCksUChJKHBmLDEpLFcsMjM3LDAsW01vLGZpLFJvXSkpLmxlbmd0aCxaaz0keH1mdW5jdGlvbiBISChlLG4scix0KXt2YXIgbztmb3Iobz0wO288Wms7bysrKUZ4KGUuY2VsbHNfMFtuLm9yZGluYWxdW29dLHIsdFtuLm9yZGluYWxdKX1mdW5jdGlvbiBVSChlLG4scix0KXt2YXIgbztmb3Iobz0wO288JHg7bysrKUR4KGUuY2VsbHNfMFtvXVtuLm9yZGluYWxdLHIsdFtuLm9yZGluYWxdKX1mdW5jdGlvbiBEZmUoZSxuLHIpe3ZhciB0LG8saSxzO289ZS5jZWxsUmVjdGFuZ2xlLHQ9ZS5wYWRkaW5nLFVIKGUsKHVzKCksTW8pLG8ueF8wK3QubGVmdCxyKSxVSChlLFJvLG8ueF8wK28ud2lkdGhfMC10LnJpZ2h0LXJbMl0scikscz1vLndpZHRoXzAtdC5sZWZ0LXQucmlnaHQsclswXT4wJiYoclswXSs9ZS5nYXAscy09clswXSksclsyXT4wJiYoclsyXSs9ZS5nYXAscy09clsyXSksaT1TLk1hdGgubWF4KDAscyksclsxXT1TLk1hdGgubWF4KHJbMV0scyksVUgoZSxmaSxvLnhfMCt0LmxlZnQrclswXS0oclsxXS1zKS8yLHIpLG49PWZpJiYoZS5jZW50ZXJDZWxsUmVjdC53aWR0aF8wPWksZS5jZW50ZXJDZWxsUmVjdC54XzA9by54XzArdC5sZWZ0KyhpLXMpLzIpfWZ1bmN0aW9uIFhrKGUsbixyKXtyZXR1cm4gZS5jZWxsc18wW24ub3JkaW5hbF1bci5vcmRpbmFsXX1mdW5jdGlvbiBKayhlLG4scil7dmFyIHQ7cmV0dXJuIHQ9UChJKGN0LDEpLFh0LDI4LDE1LFtqSChlLCh1cygpLE1vKSxuLHIpLGpIKGUsZmksbixyKSxqSChlLFJvLG4scildKSxlLnN5bW1ldHJpY2FsJiYodFswXT1TLk1hdGgubWF4KHRbMF0sdFsyXSksdFsyXT10WzBdKSx0fWZ1bmN0aW9uIFdIKGUsbixyKXt2YXIgdCxvO2ZvcihvPTAsdD0wO3Q8Wms7dCsrKW89Uy5NYXRoLm1heChvLEtrKGUuY2VsbHNfMFtuLm9yZGluYWxdW3RdLHIpKTtyZXR1cm4gbj09KHVzKCksZmkpJiZlLmNlbnRlckNlbGxNaW5pbXVtU2l6ZSYmKG89Uy5NYXRoLm1heChvLGUuY2VudGVyQ2VsbE1pbmltdW1TaXplLnlfMCkpLG99ZnVuY3Rpb24gRmZlKGUsbil7dmFyIHI7cmV0dXJuIHI9UChJKGN0LDEpLFh0LDI4LDE1LFtXSChlLCh1cygpLE1vKSxuKSxXSChlLGZpLG4pLFdIKGUsUm8sbildKSxlLnN5bW1ldHJpY2FsJiYoclswXT1TLk1hdGgubWF4KHJbMF0sclsyXSksclsyXT1yWzBdKSxyfWZ1bmN0aW9uIGpIKGUsbixyLHQpe3ZhciBvLGk7aWYobz0wLHIpbz16eChlLmNlbGxzXzBbci5vcmRpbmFsXVtuLm9yZGluYWxdLHQpO2Vsc2UgZm9yKGk9MDtpPCR4O2krKylvPVMuTWF0aC5tYXgobyx6eChlLmNlbGxzXzBbaV1bbi5vcmRpbmFsXSx0KSk7cmV0dXJuIG49PSh1cygpLGZpKSYmZS5jZW50ZXJDZWxsTWluaW11bVNpemUmJihvPVMuTWF0aC5tYXgobyxlLmNlbnRlckNlbGxNaW5pbXVtU2l6ZS54XzApKSxvfWZ1bmN0aW9uIGtubihlLG4scix0KXtUcihlLmNlbGxzXzBbbi5vcmRpbmFsXSxyLm9yZGluYWwsdCl9ZnVuY3Rpb24gT25uKGUsbil7ZS5jZW50ZXJDZWxsTWluaW11bVNpemU9bmV3IFJ0KG4pfWZ1bmN0aW9uIFZIKGUsbil7dmFyIHIsdCxvLGkscyx1O2Zvcih0PTAscj0wLGk9bixzPTAsdT1pLmxlbmd0aDtzPHU7KytzKW89aVtzXSxvPjAmJih0Kz1vLCsrcik7cmV0dXJuIHI+MSYmKHQrPWUuZ2FwKihyLTEpKSx0fWZ1bmN0aW9uIHpmZShlLG4scil7UmZlKCksTWZlLmNhbGwodGhpcyksdGhpcy5jZWxsc18wPWJfKEFmZSxbWCxXRl0sWzYwMywyMTddLDAsWyR4LFprXSwyKSx0aGlzLmNlbnRlckNlbGxSZWN0PW5ldyBpbSx0aGlzLnRhYnVsYXI9ZSx0aGlzLnN5bW1ldHJpY2FsPW4sdGhpcy5nYXA9cn1wKDE1MzgsMzM2LGRpZSx6ZmUpLGwuZ2V0TWluaW11bUhlaWdodD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPTAsdGhpcy5vbmx5Q2VudGVyQ2VsbENvbnRyaWJ1dGVzVG9NaW5pbXVtU2l6ZT90aGlzLmNlbnRlckNlbGxNaW5pbXVtU2l6ZT9uPXRoaXMuY2VudGVyQ2VsbE1pbmltdW1TaXplLnlfMDp0aGlzLmNlbGxzXzBbMV1bMV0mJihuPXRoaXMuY2VsbHNfMFsxXVsxXS5nZXRNaW5pbXVtSGVpZ2h0KCkpOm49VkgodGhpcyxGZmUodGhpcywhMCkpLG4+MD9uK3RoaXMucGFkZGluZy50b3BfMCt0aGlzLnBhZGRpbmcuYm90dG9tOjB9LGwuZ2V0TWluaW11bVdpZHRoPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtpZihpPTAsdGhpcy5vbmx5Q2VudGVyQ2VsbENvbnRyaWJ1dGVzVG9NaW5pbXVtU2l6ZSl0aGlzLmNlbnRlckNlbGxNaW5pbXVtU2l6ZT9pPXRoaXMuY2VudGVyQ2VsbE1pbmltdW1TaXplLnhfMDp0aGlzLmNlbGxzXzBbMV1bMV0mJihpPXRoaXMuY2VsbHNfMFsxXVsxXS5nZXRNaW5pbXVtV2lkdGgoKSk7ZWxzZSBpZih0aGlzLnRhYnVsYXIpaT1WSCh0aGlzLEprKHRoaXMsbnVsbCwhMCkpO2Vsc2UgZm9yKHI9KHVzKCksUChJKHBmLDEpLFcsMjM3LDAsW01vLGZpLFJvXSkpLHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLGk9Uy5NYXRoLm1heChpLFZIKHRoaXMsSmsodGhpcyxuLCEwKSkpO3JldHVybiBpPjA/aSt0aGlzLnBhZGRpbmcubGVmdCt0aGlzLnBhZGRpbmcucmlnaHQ6MH0sbC5sYXlvdXRDaGlsZHJlbkhvcml6b250YWxseT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGk7aWYodGhpcy50YWJ1bGFyKWZvcihuPUprKHRoaXMsbnVsbCwhMSksdD0odXMoKSxQKEkocGYsMSksVywyMzcsMCxbTW8sZmksUm9dKSksbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sRGZlKHRoaXMscixuKTtlbHNlIGZvcih0PSh1cygpLFAoSShwZiwxKSxXLDIzNywwLFtNbyxmaSxSb10pKSxvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxuPUprKHRoaXMsciwhMSksRGZlKHRoaXMscixuKX0sbC5sYXlvdXRDaGlsZHJlblZlcnRpY2FsbHk9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbztyPXRoaXMuY2VsbFJlY3RhbmdsZSxuPXRoaXMucGFkZGluZyxvPUZmZSh0aGlzLCExKSxISCh0aGlzLCh1cygpLE1vKSxyLnlfMCtuLnRvcF8wLG8pLEhIKHRoaXMsUm8sci55XzArci5oZWlnaHQtbi5ib3R0b20tb1syXSxvKSx0PXIuaGVpZ2h0LW4udG9wXzAtbi5ib3R0b20sb1swXT4wJiYob1swXSs9dGhpcy5nYXAsdC09b1swXSksb1syXT4wJiYob1syXSs9dGhpcy5nYXAsdC09b1syXSksdGhpcy5jZW50ZXJDZWxsUmVjdC5oZWlnaHQ9Uy5NYXRoLm1heCgwLHQpLHRoaXMuY2VudGVyQ2VsbFJlY3QueV8wPXIueV8wK24udG9wXzArKHRoaXMuY2VudGVyQ2VsbFJlY3QuaGVpZ2h0LXQpLzIsb1sxXT1TLk1hdGgubWF4KG9bMV0sdCksSEgodGhpcyxmaSxyLnlfMCtuLnRvcF8wK29bMF0tKG9bMV0tdCkvMixvKX0sbC5jZW50ZXJDZWxsTWluaW11bVNpemU9bnVsbCxsLmdhcD0wLGwub25seUNlbnRlckNlbGxDb250cmlidXRlc1RvTWluaW11bVNpemU9ITEsbC5zeW1tZXRyaWNhbD0hMSxsLnRhYnVsYXI9ITE7dmFyIFprPTAsJHg9MDtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5jZWxsc3lzdGVtIiwiR3JpZENvbnRhaW5lckNlbGwiLDE1MzgpO2Z1bmN0aW9uIHRhKCl7dGE9RixzdT1uZXcgUWsoIkxFRlQiLDApLEEwPW5ldyBRaygiQ0VOVEVSIiwxKSxIbD1uZXcgUWsoIlJJR0hUIiwyKX1mdW5jdGlvbiBRayhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIE1ubihlKXtyZXR1cm4gdGEoKSx3bigoQmZlKCksR2ZlKSxlKX1mdW5jdGlvbiBSbm4oKXtyZXR1cm4gdGEoKSxQKEkoJGZlLDEpLFcsNDcxLDAsW3N1LEEwLEhsXSl9cCg0NzEsMjIsezM6MSwzNDoxLDIyOjEsNDcxOjF9LFFrKTt2YXIgQTAsc3UsSGwsJGZlPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5jZWxsc3lzdGVtIiwiSG9yaXpvbnRhbExhYmVsQWxpZ25tZW50Iiw0NzEsZ24sUm5uLE1ubik7ZnVuY3Rpb24gQmZlKCl7QmZlPUYsR2ZlPXluKCh0YSgpLFAoSSgkZmUsMSksVyw0NzEsMCxbc3UsQTAsSGxdKSkpfXZhciBHZmU7ZnVuY3Rpb24gcUgoZSl7ZS5ob3Jpem9udGFsQWxpZ25tZW50PSh0YSgpLEEwKSxlLnZlcnRpY2FsQWxpZ25tZW50PShOaSgpLEwwKSxlLmxhYmVscz0oUGEoMiwiaW5pdGlhbEFycmF5U2l6ZSIpLG5ldyBfaSgyKSksZS5taW5pbXVtQ29udGVudEFyZWFTaXplPW5ldyBtdH1mdW5jdGlvbiBZSChlLG4pe3ZhciByO2VlKGUubGFiZWxzLG4pLHI9bi5nZXRTaXplKCksZS5ob3Jpem9udGFsTGF5b3V0TW9kZT8oZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMD1TLk1hdGgubWF4KGUubWluaW11bUNvbnRlbnRBcmVhU2l6ZS54XzAsci54XzApLGUubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzArPXIueV8wLGUubGFiZWxzLmFycmF5Lmxlbmd0aD4xJiYoZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMCs9ZS5nYXApKTooZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMCs9ci54XzAsZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMD1TLk1hdGgubWF4KGUubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzAsci55XzApLGUubGFiZWxzLmFycmF5Lmxlbmd0aD4xJiYoZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMCs9ZS5nYXApKX1mdW5jdGlvbiBIZmUoZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKHI9ZS5jZWxsUmVjdGFuZ2xlLG49ZS5wYWRkaW5nLHU9ci55XzAsZS52ZXJ0aWNhbEFsaWdubWVudD09KE5pKCksTDApP3UrPShyLmhlaWdodC1lLm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wKS8yOmUudmVydGljYWxBbGlnbm1lbnQ9PVVsJiYodSs9ci5oZWlnaHQtZS5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMCksbz1uZXcgVChlLmxhYmVscyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtzd2l0Y2godD1hKEMobyksMTg3KSxzPXQuZ2V0U2l6ZSgpLGk9bmV3IG10LGkueV8wPXUsdSs9cy55XzArZS5nYXAsZS5ob3Jpem9udGFsQWxpZ25tZW50Lm9yZGluYWwpe2Nhc2UgMDppLnhfMD1yLnhfMCtuLmxlZnQ7YnJlYWs7Y2FzZSAxOmkueF8wPXIueF8wK24ubGVmdCsoci53aWR0aF8wLXMueF8wKS8yO2JyZWFrO2Nhc2UgMjppLnhfMD1yLnhfMCtyLndpZHRoXzAtbi5yaWdodC1zLnhfMH10LnNldFBvc2l0aW9uKGkpfX1mdW5jdGlvbiBVZmUoZSl7ZS5ob3Jpem9udGFsTGF5b3V0TW9kZT9IZmUoZSk6V2ZlKGUpfWZ1bmN0aW9uIFdmZShlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3Iocj1lLmNlbGxSZWN0YW5nbGUsbj1lLnBhZGRpbmcsdT1yLnhfMCxlLmhvcml6b250YWxBbGlnbm1lbnQ9PSh0YSgpLEEwKT91Kz0oci53aWR0aF8wLWUubWluaW11bUNvbnRlbnRBcmVhU2l6ZS54XzApLzI6ZS5ob3Jpem9udGFsQWxpZ25tZW50PT1IbCYmKHUrPXIud2lkdGhfMC1lLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wKSxvPW5ldyBUKGUubGFiZWxzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspe3N3aXRjaCh0PWEoQyhvKSwxODcpLHM9dC5nZXRTaXplKCksaT1uZXcgbXQsaS54XzA9dSx1Kz1zLnhfMCtlLmdhcCxlLnZlcnRpY2FsQWxpZ25tZW50Lm9yZGluYWwpe2Nhc2UgMDppLnlfMD1yLnlfMCtuLnRvcF8wO2JyZWFrO2Nhc2UgMTppLnlfMD1yLnlfMCtuLnRvcF8wKyhyLmhlaWdodC1zLnlfMCkvMjticmVhaztjYXNlIDI6aS55XzA9ci55XzArci5oZWlnaHQtbi5ib3R0b20tcy55XzB9dC5zZXRQb3NpdGlvbihpKX19ZnVuY3Rpb24gamZlKGUpe3ZhciBuO3JldHVybiBuPWUucGFkZGluZyxlLm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wK24udG9wXzArbi5ib3R0b219ZnVuY3Rpb24gS0goZSl7dmFyIG47cmV0dXJuIG49ZS5wYWRkaW5nLGUubWluaW11bUNvbnRlbnRBcmVhU2l6ZS54XzArbi5sZWZ0K24ucmlnaHR9ZnVuY3Rpb24gY3MoZSxuKXtyZXR1cm4gRkMobiwiSG9yaXpvbnRhbCBhbGlnbm1lbnQgY2Fubm90IGJlIG51bGwiKSxlLmhvcml6b250YWxBbGlnbm1lbnQ9bixlfWZ1bmN0aW9uIHV1KGUsbil7cmV0dXJuIEZDKG4sIlZlcnRpY2FsIGFsaWdubWVudCBjYW5ub3QgYmUgbnVsbCIpLGUudmVydGljYWxBbGlnbm1lbnQ9bixlfWZ1bmN0aW9uIFZmZShlKXtNeC5jYWxsKHRoaXMpLHFIKHRoaXMpLHRoaXMuZ2FwPWUsdGhpcy5ob3Jpem9udGFsTGF5b3V0TW9kZT0hMH1mdW5jdGlvbiBxZmUoZSxuLHIpe014LmNhbGwodGhpcykscUgodGhpcyksdGhpcy5nYXA9ZSx0aGlzLmhvcml6b250YWxMYXlvdXRNb2RlPXIsdGhpcy5ob3Jpem9udGFsQWxpZ25tZW50PW4uaG9yaXpvbnRhbEFsaWdubWVudCx0aGlzLnZlcnRpY2FsQWxpZ25tZW50PW4udmVydGljYWxBbGlnbm1lbnR9ZnVuY3Rpb24gWWZlKGUsbil7TXguY2FsbCh0aGlzKSxxSCh0aGlzKSx0aGlzLmdhcD1lLHRoaXMuaG9yaXpvbnRhbExheW91dE1vZGU9bn1wKDMxNCwyMTcsezIxNzoxLDMxNDoxfSxWZmUscWZlLFlmZSksbC5nZXRNaW5pbXVtSGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIGpmZSh0aGlzKX0sbC5nZXRNaW5pbXVtV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gS0godGhpcyl9LGwuZ2FwPTAsbC5ob3Jpem9udGFsTGF5b3V0TW9kZT0hMTt2YXIgRG5uPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmNlbGxzeXN0ZW0iLCJMYWJlbENlbGwiLDMxNCk7ZnVuY3Rpb24gc0UoZSl7dmFyIG4scix0LG8saSxzLHU7aWYodT0wLGUuY29udGFpbmVyTW9kZT09MCl7Zm9yKHM9S2ZlKGUsITApLG49MCx0PXMsbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10scj4wJiYodSs9ciwrK24pO24+MSYmKHUrPWUuZ2FwKihuLTEpKX1lbHNlIHU9eV9lKE9rKHVmKEpuKHpCKGUuY2VsbHNfMCksbmV3IFFmZSksbmV3IGVwZSkpKTtyZXR1cm4gdT4wP3UrZS5wYWRkaW5nLnRvcF8wK2UucGFkZGluZy5ib3R0b206MH1mdW5jdGlvbiB1RShlKXt2YXIgbixyLHQsbyxpLHMsdTtpZih1PTAsZS5jb250YWluZXJNb2RlPT0wKXU9eV9lKE9rKHVmKEpuKHpCKGUuY2VsbHNfMCksbmV3IEpmZSksbmV3IFpmZSkpKTtlbHNle2ZvcihzPVhmZShlLCEwKSxuPTAsdD1zLG89MCxpPXQubGVuZ3RoO288aTsrK28pcj10W29dLHI+MCYmKHUrPXIsKytuKTtuPjEmJih1Kz1lLmdhcCoobi0xKSl9cmV0dXJuIHU+MD91K2UucGFkZGluZy5sZWZ0K2UucGFkZGluZy5yaWdodDowfWZ1bmN0aW9uIGU4KGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKHI9ZS5jZWxsUmVjdGFuZ2xlLG49ZS5wYWRkaW5nLGUuY29udGFpbmVyTW9kZT09MClmb3IobT1yLnhfMCtuLmxlZnQsaD1yLndpZHRoXzAtbi5sZWZ0LW4ucmlnaHQscz1lLmNlbGxzXzAsYz0wLGQ9cy5sZW5ndGg7YzxkOysrYylvPXNbY10sRHgobyxtLGgpO2Vsc2UgdD1YZmUoZSwhMSksRHgoZS5jZWxsc18wWzBdLHIueF8wK24ubGVmdCx0WzBdKSxEeChlLmNlbGxzXzBbMl0sci54XzArci53aWR0aF8wLW4ucmlnaHQtdFsyXSx0WzJdKSxmPXIud2lkdGhfMC1uLmxlZnQtbi5yaWdodCx0WzBdPjAmJihmLT10WzBdK2UuZ2FwLHRbMF0rPWUuZ2FwKSx0WzJdPjAmJihmLT10WzJdK2UuZ2FwKSx0WzFdPVMuTWF0aC5tYXgodFsxXSxmKSxEeChlLmNlbGxzXzBbMV0sci54XzArbi5sZWZ0K3RbMF0tKHRbMV0tZikvMix0WzFdKTtmb3IoaT1lLmNlbGxzXzAsdT0wLF89aS5sZW5ndGg7dTxfOysrdSlvPWlbdV0sTChvLDMzNikmJmEobywzMzYpLmxheW91dENoaWxkcmVuSG9yaXpvbnRhbGx5KCl9ZnVuY3Rpb24gbjgoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seTtpZih0PWUuY2VsbFJlY3RhbmdsZSxyPWUucGFkZGluZyxlLmNvbnRhaW5lck1vZGU9PTApbj1LZmUoZSwhMSksRngoZS5jZWxsc18wWzBdLHQueV8wK3IudG9wXzAsblswXSksRngoZS5jZWxsc18wWzJdLHQueV8wK3QuaGVpZ2h0LXIuYm90dG9tLW5bMl0sblsyXSksaD10LmhlaWdodC1yLnRvcF8wLXIuYm90dG9tLGY9aCxuWzBdPjAmJihuWzBdKz1lLmdhcCxmLT1uWzBdKSxuWzJdPjAmJihmLT1uWzJdK2UuZ2FwKSxuWzFdPVMuTWF0aC5tYXgoblsxXSxmKSxGeChlLmNlbGxzXzBbMV0sdC55XzArci50b3BfMCtuWzBdLShuWzFdLWYpLzIsblsxXSk7ZWxzZSBmb3IoeT10LnlfMCtyLnRvcF8wLG09dC5oZWlnaHQtci50b3BfMC1yLmJvdHRvbSxzPWUuY2VsbHNfMCxjPTAsZD1zLmxlbmd0aDtjPGQ7KytjKW89c1tjXSxGeChvLHksbSk7Zm9yKGk9ZS5jZWxsc18wLHU9MCxfPWkubGVuZ3RoO3U8XzsrK3Upbz1pW3VdLEwobywzMzYpJiZhKG8sMzM2KS5sYXlvdXRDaGlsZHJlblZlcnRpY2FsbHkoKX1mdW5jdGlvbiBLZmUoZSxuKXt2YXIgcjtyZXR1cm4gcj1QKEkoY3QsMSksWHQsMjgsMTUsW0trKGUuY2VsbHNfMFswXSxuKSxLayhlLmNlbGxzXzBbMV0sbiksS2soZS5jZWxsc18wWzJdLG4pXSksZS5zeW1tZXRyaWNhbCYmKHJbMF09Uy5NYXRoLm1heChyWzBdLHJbMl0pLHJbMl09clswXSkscn1mdW5jdGlvbiBYZmUoZSxuKXt2YXIgcjtyZXR1cm4gcj1QKEkoY3QsMSksWHQsMjgsMTUsW3p4KGUuY2VsbHNfMFswXSxuKSx6eChlLmNlbGxzXzBbMV0sbiksengoZS5jZWxsc18wWzJdLG4pXSksZS5zeW1tZXRyaWNhbCYmKHJbMF09Uy5NYXRoLm1heChyWzBdLHJbMl0pLHJbMl09clswXSkscn1mdW5jdGlvbiByOChlLG4scil7ZS5jZWxsc18wW24ub3JkaW5hbF09cn1mdW5jdGlvbiBjRShlLG4scil7TWZlLmNhbGwodGhpcyksdGhpcy5jZWxsc18wPUIoQWZlLFdGLDIxNywodXMoKSxQKEkocGYsMSksVywyMzcsMCxbTW8sZmksUm9dKSkubGVuZ3RoLDAsMSksdGhpcy5jb250YWluZXJNb2RlPWUsdGhpcy5zeW1tZXRyaWNhbD1uLHRoaXMuZ2FwPXJ9ZnVuY3Rpb24gRm5uKGUpe3JldHVybiEhZSYmZS5jb250cmlidXRlc1RvTWluaW11bVdpZHRofWZ1bmN0aW9uIHpubihlKXtyZXR1cm4hIWUmJmUuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHR9cCgyNTIsMzM2LHsyMTc6MSwzMzY6MSwyNTI6MX0sY0UpLGwuZ2V0TWluaW11bUhlaWdodD1mdW5jdGlvbigpe3JldHVybiBzRSh0aGlzKX0sbC5nZXRNaW5pbXVtV2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdUUodGhpcyl9LGwubGF5b3V0Q2hpbGRyZW5Ib3Jpem9udGFsbHk9ZnVuY3Rpb24oKXtlOCh0aGlzKX0sbC5sYXlvdXRDaGlsZHJlblZlcnRpY2FsbHk9ZnVuY3Rpb24oKXtuOCh0aGlzKX0sbC5jb250YWluZXJNb2RlPTAsbC5nYXA9MCxsLnN5bW1ldHJpY2FsPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmNlbGxzeXN0ZW0iLCJTdHJpcENvbnRhaW5lckNlbGwiLDI1Mik7ZnVuY3Rpb24gSmZlKCl7fXAoMTY5MSwxLEluLEpmZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEZubihhKG4sMjE3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmNlbGxzeXN0ZW0iLCJTdHJpcENvbnRhaW5lckNlbGwvbGFtYmRhJDAkVHlwZSIsMTY5MSk7ZnVuY3Rpb24gWmZlKCl7fXAoMTY5MiwxLHt9LFpmZSksbC5hcHBseUFzRG91YmxlPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMjE3KS5nZXRNaW5pbXVtV2lkdGgoKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIlN0cmlwQ29udGFpbmVyQ2VsbC9sYW1iZGEkMSRUeXBlIiwxNjkyKTtmdW5jdGlvbiBRZmUoKXt9cCgxNjkzLDEsSW4sUWZlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gem5uKGEobiwyMTcpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIlN0cmlwQ29udGFpbmVyQ2VsbC9sYW1iZGEkMiRUeXBlIiwxNjkzKTtmdW5jdGlvbiBlcGUoKXt9cCgxNjk0LDEse30sZXBlKSxsLmFwcGx5QXNEb3VibGU9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyMTcpLmdldE1pbmltdW1IZWlnaHQoKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIlN0cmlwQ29udGFpbmVyQ2VsbC9sYW1iZGEkMyRUeXBlIiwxNjk0KTtmdW5jdGlvbiBOaSgpe05pPUYsX3M9bmV3IHQ4KCJUT1AiLDApLEwwPW5ldyB0OCgiQ0VOVEVSIiwxKSxVbD1uZXcgdDgoIkJPVFRPTSIsMil9ZnVuY3Rpb24gdDgoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiAkbm4oZSl7cmV0dXJuIE5pKCksd24oKHJwZSgpLHRwZSksZSl9ZnVuY3Rpb24gQm5uKCl7cmV0dXJuIE5pKCksUChJKG5wZSwxKSxXLDQ3MiwwLFtfcyxMMCxVbF0pfXAoNDcyLDIyLHszOjEsMzQ6MSwyMjoxLDQ3MjoxfSx0OCk7dmFyIFVsLEwwLF9zLG5wZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuY2VsbHN5c3RlbSIsIlZlcnRpY2FsTGFiZWxBbGlnbm1lbnQiLDQ3MixnbixCbm4sJG5uKTtmdW5jdGlvbiBycGUoKXtycGU9Rix0cGU9eW4oKE5pKCksUChJKG5wZSwxKSxXLDQ3MiwwLFtfcyxMMCxVbF0pKSl9dmFyIHRwZTtmdW5jdGlvbiBvOChlLG4pe3ZhciByO3N3aXRjaChyPW51bGwsbi5vcmRpbmFsKXtjYXNlIDE6ZS5ub2RlLmhhc1Byb3BlcnR5KChGbigpLHNSKSkmJihyPWEoZS5ub2RlLmdldFByb3BlcnR5KHNSKSwyNTYpKTticmVhaztjYXNlIDM6ZS5ub2RlLmhhc1Byb3BlcnR5KChGbigpLHVSKSkmJihyPWEoZS5ub2RlLmdldFByb3BlcnR5KHVSKSwyNTYpKTticmVhaztjYXNlIDI6ZS5ub2RlLmhhc1Byb3BlcnR5KChGbigpLGxSKSkmJihyPWEoZS5ub2RlLmdldFByb3BlcnR5KGxSKSwyNTYpKTticmVhaztjYXNlIDQ6ZS5ub2RlLmhhc1Byb3BlcnR5KChGbigpLGNSKSkmJihyPWEoZS5ub2RlLmdldFByb3BlcnR5KGNSKSwyNTYpKX1yZXR1cm4hciYmKHI9YShlLm5vZGUuZ2V0UHJvcGVydHkoKEZuKCksa1EpKSwyNTYpKSxyfWZ1bmN0aW9uIFhIKGUpe3ZhciBuO2lmKHRoaXMucG9ydENvbnRleHRzPXZYZShuZXcgaXBlLG5ldyBhcGUpLHRoaXMuaW5zaWRlUG9ydExhYmVsQ2VsbHM9bmV3IFEyKGEodm4oJHQpLDI5NykpLHRoaXMub3V0c2lkZU5vZGVMYWJlbENvbnRhaW5lcnM9bmV3IFEyKGEodm4oJHQpLDI5NykpLHRoaXMubm9kZUxhYmVsQ2VsbHM9bmV3IFEyKGEodm4oUHBlKSwyOTcpKSx0aGlzLm5vZGU9ZSx0aGlzLm5vZGVTaXplPW5ldyBSdChlLmdldFNpemUoKSksdGhpcy50b3Bkb3duTGF5b3V0PWFlKGllKGUuZ2V0UHJvcGVydHkoKEZuKCksSXcpKSkpLHRoaXMudHJlYXRBc0NvbXBvdW5kTm9kZT1lLmlzQ29tcG91bmROb2RlKCl8fGFlKGllKGUuZ2V0UHJvcGVydHkoUFQpKSksdGhpcy5zaXplQ29uc3RyYWludHM9YShlLmdldFByb3BlcnR5KHIxKSwyMSksdGhpcy5zaXplT3B0aW9ucz1hKGUuZ2V0UHJvcGVydHkoVzApLDIxKSx0aGlzLnBvcnRDb25zdHJhaW50cz1hKGUuZ2V0UHJvcGVydHkoanYpLDEwMSksdGhpcy5wb3J0TGFiZWxzUGxhY2VtZW50PWEoZS5nZXRQcm9wZXJ0eShqZiksMjEpLCFnRW4odGhpcy5wb3J0TGFiZWxzUGxhY2VtZW50KSl0aHJvdyBiKG5ldyBLYygiSW52YWxpZCBwb3J0IGxhYmVsIHBsYWNlbWVudDogIit0aGlzLnBvcnRMYWJlbHNQbGFjZW1lbnQpKTtpZih0aGlzLnBvcnRMYWJlbHNUcmVhdEFzR3JvdXA9YWUoaWUoZS5nZXRQcm9wZXJ0eShGUSkpKSx0aGlzLm5vZGVMYWJlbFBsYWNlbWVudD1hKGUuZ2V0UHJvcGVydHkoSWcpLDIxKSwhc0VuKHRoaXMubm9kZUxhYmVsUGxhY2VtZW50KSl0aHJvdyBiKG5ldyBLYygiSW52YWxpZCBub2RlIGxhYmVsIHBsYWNlbWVudDogIit0aGlzLm5vZGVMYWJlbFBsYWNlbWVudCkpO3RoaXMubm9kZUxhYmVsc1BhZGRpbmc9YShpUyhlLFRRKSwxMDcpLHRoaXMubm9kZUxhYmVsU3BhY2luZz1SKCQoaVMoZSx0QSkpKSx0aGlzLmxhYmVsTGFiZWxTcGFjaW5nPVIoJChpUyhlLEhRKSkpLHRoaXMucG9ydFBvcnRTcGFjaW5nPVIoJChpUyhlLHFRKSkpLHRoaXMucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWw9UigkKGlTKGUsVVEpKSksdGhpcy5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWw9UigkKGlTKGUsV1EpKSksdGhpcy5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zPWEoaVMoZSxqUSksMTQwKSx0aGlzLmxhYmVsQ2VsbFNwYWNpbmc9Mip0aGlzLmxhYmVsTGFiZWxTcGFjaW5nLG49IXRoaXMuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksV1QpKSx0aGlzLm5vZGVDb250YWluZXI9bmV3IGNFKDAsbiwwKSx0aGlzLm5vZGVDb250YWluZXJNaWRkbGVSb3c9bmV3IGNFKDEsbiwwKSxyOCh0aGlzLm5vZGVDb250YWluZXIsKHVzKCksZmkpLHRoaXMubm9kZUNvbnRhaW5lck1pZGRsZVJvdyl9ZnVuY3Rpb24gR25uKGUsbil7dmFyIHI7aWYocj1vcGUoZS5wb3J0LmdldFNpZGUoKSxuLnBvcnQuZ2V0U2lkZSgpKSxyIT0wKXJldHVybiByO3N3aXRjaChlLnBvcnQuZ2V0U2lkZSgpLm9yZGluYWwpe2Nhc2UgMTpjYXNlIDI6cmV0dXJuIHFvKGUucG9ydC5nZXRWb2xhdGlsZUlkKCksbi5wb3J0LmdldFZvbGF0aWxlSWQoKSk7Y2FzZSAzOmNhc2UgNDpyZXR1cm4gcW8obi5wb3J0LmdldFZvbGF0aWxlSWQoKSxlLnBvcnQuZ2V0Vm9sYXRpbGVJZCgpKX1yZXR1cm4gMH1mdW5jdGlvbiBvcGUoZSxuKXtyZXR1cm4gcW8oZS5vcmRpbmFsLG4ub3JkaW5hbCl9cCg4MDAsMSx7fSxYSCksbC5sYWJlbENlbGxTcGFjaW5nPTAsbC5sYWJlbExhYmVsU3BhY2luZz0wLGwubm9kZUxhYmVsU3BhY2luZz0wLGwucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWw9MCxsLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbD0wLGwucG9ydExhYmVsc1RyZWF0QXNHcm91cD0hMSxsLnBvcnRQb3J0U3BhY2luZz0wLGwudG9wZG93bkxheW91dD0hMSxsLnRyZWF0QXNDb21wb3VuZE5vZGU9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuaW50ZXJuYWwiLCJOb2RlQ29udGV4dCIsODAwKTtmdW5jdGlvbiBpcGUoKXt9cCgxNTM2LDEsTm4saXBlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBvcGUoYShuLDY0KSxhKHIsNjQpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5pbnRlcm5hbCIsIk5vZGVDb250ZXh0LzBtZXRob2RyZWYkY29tcGFyZVBvcnRTaWRlcyRUeXBlIiwxNTM2KTtmdW5jdGlvbiBhcGUoKXt9cCgxNTM3LDEsTm4sYXBlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBHbm4oYShuLDExNyksYShyLDExNykpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmludGVybmFsIiwiTm9kZUNvbnRleHQvMW1ldGhvZHJlZiRjb21wYXJlUG9ydENvbnRleHRzJFR5cGUiLDE1MzcpO2Z1bmN0aW9uIEJ4KCl7Qng9RixJcGU9bmV3IFFhKCJPVVRfVF9MIiwwLCh0YSgpLHN1KSwoTmkoKSxVbCksKHVzKCksTW8pLE1vLFAoSShnbCwxKSxNZSwyMSwwLFtjcigocWYoKSxKbCksUChJKFl0LDEpLFcsOTUsMCxbWmwsS2xdKSldKSksYnBlPW5ldyBRYSgiT1VUX1RfQyIsMSxBMCxVbCxNbyxmaSxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbWmwsZ2NdKSksY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbWmwsZ2MsQ2xdKSldKSkseHBlPW5ldyBRYSgiT1VUX1RfUiIsMixIbCxVbCxNbyxSbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbWmwsWGxdKSldKSksbXBlPW5ldyBRYSgiT1VUX0JfTCIsMyxzdSxfcyxSbyxNbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbVGwsS2xdKSldKSksaHBlPW5ldyBRYSgiT1VUX0JfQyIsNCxBMCxfcyxSbyxmaSxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbVGwsZ2NdKSksY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbVGwsZ2MsQ2xdKSldKSkseXBlPW5ldyBRYSgiT1VUX0JfUiIsNSxIbCxfcyxSbyxSbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbVGwsWGxdKSldKSksdnBlPW5ldyBRYSgiT1VUX0xfVCIsNixIbCxfcyxNbyxNbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbS2wsWmwsQ2xdKSldKSksRXBlPW5ldyBRYSgiT1VUX0xfQyIsNyxIbCxMMCxmaSxNbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbS2wsR3VdKSksY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbS2wsR3UsQ2xdKSldKSksd3BlPW5ldyBRYSgiT1VUX0xfQiIsOCxIbCxVbCxSbyxNbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbS2wsVGwsQ2xdKSldKSksVHBlPW5ldyBRYSgiT1VUX1JfVCIsOSxzdSxfcyxNbyxSbyxQKEkoZ2wsMSksTWUsMjEsMCxbY3IoSmwsUChJKFl0LDEpLFcsOTUsMCxbWGwsWmwsQ2xdKSldKSksQ3BlPW5ldyBRYSgiT1VUX1JfQyIsMTAsc3UsTDAsZmksUm8sUChJKGdsLDEpLE1lLDIxLDAsW2NyKEpsLFAoSShZdCwxKSxXLDk1LDAsW1hsLEd1XSkpLGNyKEpsLFAoSShZdCwxKSxXLDk1LDAsW1hsLEd1LENsXSkpXSkpLFNwZT1uZXcgUWEoIk9VVF9SX0IiLDExLHN1LFVsLFJvLFJvLFAoSShnbCwxKSxNZSwyMSwwLFtjcihKbCxQKEkoWXQsMSksVyw5NSwwLFtYbCxUbCxDbF0pKV0pKSxwcGU9bmV3IFFhKCJJTl9UX0wiLDEyLHN1LF9zLE1vLE1vLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxLbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxLbCxDbF0pKV0pKSxmcGU9bmV3IFFhKCJJTl9UX0MiLDEzLEEwLF9zLE1vLGZpLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxnY10pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxnYyxDbF0pKV0pKSxncGU9bmV3IFFhKCJJTl9UX1IiLDE0LEhsLF9zLE1vLFJvLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxYbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtabCxYbCxDbF0pKV0pKSxfcGU9bmV3IFFhKCJJTl9DX0wiLDE1LHN1LEwwLGZpLE1vLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxLbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxLbCxDbF0pKV0pKSxjcGU9bmV3IFFhKCJJTl9DX0MiLDE2LEEwLEwwLGZpLGZpLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxnY10pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxnYyxDbF0pKV0pKSxkcGU9bmV3IFFhKCJJTl9DX1IiLDE3LEhsLEwwLGZpLFJvLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxYbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtHdSxYbCxDbF0pKV0pKSxzcGU9bmV3IFFhKCJJTl9CX0wiLDE4LHN1LFVsLFJvLE1vLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxLbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxLbCxDbF0pKV0pKSxscGU9bmV3IFFhKCJJTl9CX0MiLDE5LEEwLFVsLFJvLGZpLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxnY10pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxnYyxDbF0pKV0pKSx1cGU9bmV3IFFhKCJJTl9CX1IiLDIwLEhsLFVsLFJvLFJvLFAoSShnbCwxKSxNZSwyMSwwLFtjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxYbF0pKSxjcihGYSxQKEkoWXQsMSksVyw5NSwwLFtUbCxYbCxDbF0pKV0pKSxhOD1uZXcgUWEoIlVOREVGSU5FRCIsMjEsbnVsbCxudWxsLG51bGwsbnVsbCxQKEkoZ2wsMSksTWUsMjEsMCxbXSkpfWZ1bmN0aW9uIEhubihlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpyZXR1cm4gcmUoKSxVZTtjYXNlIDM6Y2FzZSA0OmNhc2UgNTpyZXR1cm4gcmUoKSxsbjtjYXNlIDY6Y2FzZSA3OmNhc2UgODpyZXR1cm4gcmUoKSxqZTtjYXNlIDk6Y2FzZSAxMDpjYXNlIDExOnJldHVybiByZSgpLHFlO2RlZmF1bHQ6cmV0dXJuIHJlKCksT299fWZ1bmN0aW9uIEpIKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMTI6Y2FzZSAxMzpjYXNlIDE0OmNhc2UgMTU6Y2FzZSAxNjpjYXNlIDE3OmNhc2UgMTg6Y2FzZSAxOTpjYXNlIDIwOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIFFhKGUsbixyLHQsbyxpLHMpe21uLmNhbGwodGhpcyxlLG4pLHRoaXMuaG9yaXpvbnRhbEFsaWdubWVudD1yLHRoaXMudmVydGljYWxBbGlnbm1lbnQ9dCx0aGlzLmNvbnRhaW5lclJvdz1vLHRoaXMuY29udGFpbmVyQ29sdW1uPWksdGhpcy5hc3NpZ25lZFBsYWNlbWVudHM9VHMocyl9ZnVuY3Rpb24gVW5uKGUpe0J4KCk7dmFyIG4scix0LG87Zm9yKHI9aTgoKSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KWlmKG49clt0XSxmbyhuLmFzc2lnbmVkUGxhY2VtZW50cyxlLDApIT0tMSlyZXR1cm4gbjtyZXR1cm4gYTh9ZnVuY3Rpb24gV25uKGUpe3JldHVybiBCeCgpLHduKChOcGUoKSxBcGUpLGUpfWZ1bmN0aW9uIGk4KCl7cmV0dXJuIEJ4KCksUChJKFBwZSwxKSxXLDE2NCwwLFtJcGUsYnBlLHhwZSxtcGUsaHBlLHlwZSx2cGUsRXBlLHdwZSxUcGUsQ3BlLFNwZSxwcGUsZnBlLGdwZSxfcGUsY3BlLGRwZSxzcGUsbHBlLHVwZSxhOF0pfXAoMTY0LDIyLHszOjEsMzQ6MSwyMjoxLDE2NDoxfSxRYSk7dmFyIGxwZSxzcGUsdXBlLGNwZSxfcGUsZHBlLGZwZSxwcGUsZ3BlLGhwZSxtcGUseXBlLHdwZSxFcGUsdnBlLFNwZSxDcGUsVHBlLGJwZSxJcGUseHBlLGE4LFBwZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuaW50ZXJuYWwiLCJOb2RlTGFiZWxMb2NhdGlvbiIsMTY0LGduLGk4LFdubik7ZnVuY3Rpb24gTnBlKCl7TnBlPUYsQXBlPXluKGk4KCkpfXZhciBBcGU7ZnVuY3Rpb24gam5uKGUpe2UucG9ydC5zZXRQb3NpdGlvbihlLnBvcnRQb3NpdGlvbil9ZnVuY3Rpb24gTHBlKGUsbil7dmFyIHI7dGhpcy5wb3J0TWFyZ2luPW5ldyB2RSx0aGlzLnBvcnQ9bix0aGlzLnBvcnRQb3NpdGlvbj1uZXcgUnQobi5nZXRQb3NpdGlvbigpKSxyPWUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucygoYWEoKSwkVCkpLGUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucyhoYyk/ZS50cmVhdEFzQ29tcG91bmROb2RlP3RoaXMubGFiZWxzTmV4dFRvUG9ydD1yJiYhbi5oYXNDb21wb3VuZENvbm5lY3Rpb25zKCk6dGhpcy5sYWJlbHNOZXh0VG9Qb3J0PSEwOmUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucyhZMCk/cj90aGlzLmxhYmVsc05leHRUb1BvcnQ9IShuLmdldEluY29taW5nRWRnZXMoKS5pdGVyYXRvcl8wKCkuaGFzTmV4dF8wKCl8fG4uZ2V0T3V0Z29pbmdFZGdlcygpLml0ZXJhdG9yXzAoKS5oYXNOZXh0XzAoKSk6dGhpcy5sYWJlbHNOZXh0VG9Qb3J0PSExOnRoaXMubGFiZWxzTmV4dFRvUG9ydD0hMX1wKDExNywxLHsxMTc6MX0sTHBlKSxsLmxhYmVsc05leHRUb1BvcnQ9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuaW50ZXJuYWwiLCJQb3J0Q29udGV4dCIsMTE3KTtmdW5jdGlvbiBWbm4oZSl7dmFyIG4scix0LG8saSxzLHU7aWYoIWUuc2l6ZUNvbnN0cmFpbnRzLmlzRW1wdHkoKSl7aWYoZS5zaXplQ29uc3RyYWludHMuY29udGFpbnMoKFNhKCksVVQpKSYmKGEoWnQoZS5pbnNpZGVQb3J0TGFiZWxDZWxscywocmUoKSxVZSkpLDEyNykuY29udHJpYnV0ZXNUb01pbmltdW1XaWR0aD0hMCxhKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbG4pLDEyNykuY29udHJpYnV0ZXNUb01pbmltdW1XaWR0aD0hMCxuPWUucG9ydENvbnN0cmFpbnRzIT0oZHQoKSxIdSkmJmUucG9ydENvbnN0cmFpbnRzIT1haSxHSChhKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMscWUpLDEyNyksbiksR0goYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLGplKSwxMjcpLG4pLEdIKGUubm9kZUNvbnRhaW5lck1pZGRsZVJvdyxuKSxlLnNpemVDb25zdHJhaW50cy5jb250YWlucyhpMSkmJihhKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsVWUpLDEyNykuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHQ9ITAsYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLGxuKSwxMjcpLmNvbnRyaWJ1dGVzVG9NaW5pbXVtSGVpZ2h0PSEwLGEoWnQoZS5pbnNpZGVQb3J0TGFiZWxDZWxscyxxZSksMTI3KS5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwLGEoWnQoZS5pbnNpZGVQb3J0TGFiZWxDZWxscyxqZSksMTI3KS5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwLGUubm9kZUNvbnRhaW5lck1pZGRsZVJvdy5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwKSksZS5zaXplQ29uc3RyYWludHMuY29udGFpbnMoSFQpKWZvcihlLmluc2lkZU5vZGVMYWJlbENvbnRhaW5lci5jb250cmlidXRlc1RvTWluaW11bUhlaWdodD0hMCxlLmluc2lkZU5vZGVMYWJlbENvbnRhaW5lci5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwLGUubm9kZUNvbnRhaW5lck1pZGRsZVJvdy5jb250cmlidXRlc1RvTWluaW11bUhlaWdodD0hMCxlLm5vZGVDb250YWluZXJNaWRkbGVSb3cuY29udHJpYnV0ZXNUb01pbmltdW1XaWR0aD0hMCx1PWUuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksb1MpKSxvPWk4KCksaT0wLHM9by5sZW5ndGg7aTxzOysraSl0PW9baV0scj1hKFp0KGUubm9kZUxhYmVsQ2VsbHMsdCksMzE0KSxyJiYoSkgodCk/KHIuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHQ9ITAsci5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwKTooci5jb250cmlidXRlc1RvTWluaW11bUhlaWdodD0hdSxyLmNvbnRyaWJ1dGVzVG9NaW5pbXVtV2lkdGg9IXUpKTtlLnNpemVDb25zdHJhaW50cy5jb250YWlucyhZZikmJmUuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksalQpKSYmKGUubm9kZUNvbnRhaW5lck1pZGRsZVJvdy5jb250cmlidXRlc1RvTWluaW11bUhlaWdodD0hMCxlLm5vZGVDb250YWluZXJNaWRkbGVSb3cuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHQ9ITAsZS5pbnNpZGVOb2RlTGFiZWxDb250YWluZXIuY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHR8fChlLmluc2lkZU5vZGVMYWJlbENvbnRhaW5lci5jb250cmlidXRlc1RvTWluaW11bUhlaWdodD0hMCxlLmluc2lkZU5vZGVMYWJlbENvbnRhaW5lci5jb250cmlidXRlc1RvTWluaW11bVdpZHRoPSEwLGUuaW5zaWRlTm9kZUxhYmVsQ29udGFpbmVyLm9ubHlDZW50ZXJDZWxsQ29udHJpYnV0ZXNUb01pbmltdW1TaXplPSEwKSl9fWZ1bmN0aW9uIHFubihlKXt2YXIgbixyLHQsbyxpLHM7ZS5wb3J0Q29uc3RyYWludHM9PShkdCgpLEh1KXx8ZS5wb3J0Q29uc3RyYWludHM9PWFpfHwobz1lLm5vZGVDb250YWluZXIucGFkZGluZy50b3BfMCtSeChhKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsKHJlKCksVWUpKSwxMjcpKStlLmxhYmVsQ2VsbFNwYWNpbmcsbj1lLm5vZGVDb250YWluZXIucGFkZGluZy5ib3R0b20rUngoYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLGxuKSwxMjcpKStlLmxhYmVsQ2VsbFNwYWNpbmcsdD1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMscWUpLDEyNykscz1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsamUpLDEyNyksaT1TLk1hdGgubWF4KDAsdC5wYWRkaW5nLnRvcF8wLW8pLGk9Uy5NYXRoLm1heChpLHMucGFkZGluZy50b3BfMC1vKSxyPVMuTWF0aC5tYXgoMCx0LnBhZGRpbmcuYm90dG9tLW4pLHI9Uy5NYXRoLm1heChyLHMucGFkZGluZy5ib3R0b20tbiksdC5wYWRkaW5nLnRvcF8wPWkscy5wYWRkaW5nLnRvcF8wPWksdC5wYWRkaW5nLmJvdHRvbT1yLHMucGFkZGluZy5ib3R0b209cil9ZnVuY3Rpb24ga3BlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKGk9MCxvPWEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSwxMTcpLGk9Uy5NYXRoLm1heChpLHQucG9ydFBvc2l0aW9uLnhfMCt0LnBvcnQuZ2V0U2l6ZSgpLnhfMCk7cj1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbiksMTI3KSxyLnBhZGRpbmcubGVmdD0wLHIubWluaW11bUNvbnRlbnRBcmVhU2l6ZS54XzA9aX1mdW5jdGlvbiBPcGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG07aWYocj1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbiksMTI3KSxjPWEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLGMuaXNFbXB0eSgpKXtyLnBhZGRpbmcubGVmdD0wLHIucGFkZGluZy5yaWdodD0wO3JldHVybn1mb3IoXz1lLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoKGFhKCksaGMpKSxzPTAsdT1jLml0ZXJhdG9yXzAoKSxkPW51bGwsZj0wLGg9MDt1Lmhhc05leHRfMCgpOyl0PWEodS5uZXh0XzEoKSwxMTcpLG89UigkKHQucG9ydC5nZXRQcm9wZXJ0eSgoR3goKSxIeCkpKSksaT10LnBvcnQuZ2V0U2l6ZSgpLnhfMCxlLnNpemVDb25zdHJhaW50cy5jb250YWlucygoU2EoKSxpMSkpJiZEcGUoZSxuKSxkPyhtPWgrZC5wb3J0TWFyZ2luLnJpZ2h0K2UucG9ydFBvcnRTcGFjaW5nK3QucG9ydE1hcmdpbi5sZWZ0LHM9Uy5NYXRoLm1heChzLChicygpLGtsKENzKSxTLk1hdGguYWJzKGYtbyk8PUNzfHxmPT1vfHxpc05hTihmKSYmaXNOYU4obyk/MDptLyhvLWYpKSkpOmUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucyYmZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zLmxlZnQ+MCYmKHM9Uy5NYXRoLm1heChzLFJwZShlLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMubGVmdCt0LnBvcnRNYXJnaW4ubGVmdCxvKSkpLGQ9dCxmPW8saD1pO2Uuc3Vycm91bmRpbmdQb3J0TWFyZ2lucyYmZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zLnJpZ2h0PjAmJihtPWgrZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zLnJpZ2h0LF8mJihtKz1kLnBvcnRNYXJnaW4ucmlnaHQpLHM9Uy5NYXRoLm1heChzLChicygpLGtsKENzKSxTLk1hdGguYWJzKGYtMSk8PUNzfHxmPT0xfHxpc05hTihmKSYmaXNOYU4oMSk/MDptLygxLWYpKSkpLHIucGFkZGluZy5sZWZ0PTAsci5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMD1zfWZ1bmN0aW9uIE1wZShlLG4pe3ZhciByLHQ7aWYocj1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbiksMTI3KSxhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pc0VtcHR5KCkpe3IucGFkZGluZy5sZWZ0PTAsci5wYWRkaW5nLnJpZ2h0PTA7cmV0dXJufXIucGFkZGluZy5sZWZ0PWUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucy5sZWZ0LHIucGFkZGluZy5yaWdodD1lLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMucmlnaHQsZS5zaXplQ29uc3RyYWludHMuY29udGFpbnMoKFNhKCksaTEpKSYmRHBlKGUsbiksdD1Ybm4oZSxuKSxvOChlLG4pPT0oa2coKSxWMCkmJih0Kz0yKmUucG9ydFBvcnRTcGFjaW5nKSxyLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wPXR9ZnVuY3Rpb24gWW5uKGUpe3N3aXRjaChlLnBvcnRDb25zdHJhaW50cy5vcmRpbmFsKXtjYXNlIDU6a3BlKGUsKHJlKCksVWUpKSxrcGUoZSxsbik7YnJlYWs7Y2FzZSA0Ok9wZShlLChyZSgpLFVlKSksT3BlKGUsbG4pO2JyZWFrO2RlZmF1bHQ6TXBlKGUsKHJlKCksVWUpKSxNcGUoZSxsbil9fWZ1bmN0aW9uIEtubihlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3Iocz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksMTE3KSxyPWkucG9ydExhYmVsQ2VsbD9LSChpLnBvcnRMYWJlbENlbGwpOjAscj4wP2kubGFiZWxzTmV4dFRvUG9ydD8odT1pLnBvcnQuZ2V0U2l6ZSgpLnhfMCxyPnUmJihvPShyLXUpLzIsaS5wb3J0TWFyZ2luLmxlZnQ9byxpLnBvcnRNYXJnaW4ucmlnaHQ9bykpOmkucG9ydE1hcmdpbi5yaWdodD1lLnBvcnRMYWJlbFNwYWNpbmdIb3Jpem9udGFsK3I6ZVMoZS5wb3J0TGFiZWxzUGxhY2VtZW50KSYmKHQ9QWVlKGkucG9ydCksdC54XzA8MCYmKGkucG9ydE1hcmdpbi5sZWZ0PS10LnhfMCksdC54XzArdC53aWR0aF8wPmkucG9ydC5nZXRTaXplKCkueF8wJiYoaS5wb3J0TWFyZ2luLnJpZ2h0PXQueF8wK3Qud2lkdGhfMC1pLnBvcnQuZ2V0U2l6ZSgpLnhfMCkpfWZ1bmN0aW9uIFJwZShlLG4pe3JldHVybiBicygpLGtsKENzKSxTLk1hdGguYWJzKDAtbik8PUNzfHxuPT0wfHxpc05hTigwKSYmaXNOYU4obik/MDplL259ZnVuY3Rpb24gWG5uKGUsbil7dmFyIHIsdCxvO2ZvcihvPTAsdD1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMTE3KSxvKz1yLnBvcnRNYXJnaW4ubGVmdCtyLnBvcnQuZ2V0U2l6ZSgpLnhfMCtyLnBvcnRNYXJnaW4ucmlnaHQsdC5oYXNOZXh0XzAoKSYmKG8rPWUucG9ydFBvcnRTcGFjaW5nKTtyZXR1cm4gb31mdW5jdGlvbiBEcGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZihzPWEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLHU9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKChhYSgpLFkwKSkscj1lLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoclMpLHQ9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKG5TKSxfPWUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucyhkbSksZj1lLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLG1BKSksZD0hciYmIXQmJihffHxzLnNpemVfMSgpPT0yKSxLbm4oZSxuKSxvPW51bGwsYz1udWxsLHUpe2ZvcihpPXMuaXRlcmF0b3JfMCgpLG89YShpLm5leHRfMSgpLDExNyksYz1vO2kuaGFzTmV4dF8wKCk7KWM9YShpLm5leHRfMSgpLDExNyk7by5wb3J0TWFyZ2luLmxlZnQ9MCxjLnBvcnRNYXJnaW4ucmlnaHQ9MCxkJiYhby5sYWJlbHNOZXh0VG9Qb3J0JiYoby5wb3J0TWFyZ2luLnJpZ2h0PTApfWYmJihKbm4ocyksdSYmKG8ucG9ydE1hcmdpbi5sZWZ0PTAsYy5wb3J0TWFyZ2luLnJpZ2h0PTApKX1mdW5jdGlvbiBKbm4oZSl7dmFyIG4scix0LG8saTtmb3Iobj0wLHI9MCxpPWUuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KXQ9YShpLm5leHRfMSgpLDExNyksbj1TLk1hdGgubWF4KG4sdC5wb3J0TWFyZ2luLmxlZnQpLHI9Uy5NYXRoLm1heChyLHQucG9ydE1hcmdpbi5yaWdodCk7Zm9yKG89ZS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTE3KSx0LnBvcnRNYXJnaW4ubGVmdD1uLHQucG9ydE1hcmdpbi5yaWdodD1yfWZ1bmN0aW9uIFpubihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPWEoWnQoZS5pbnNpZGVQb3J0TGFiZWxDZWxscyxuKSwxMjcpLHI9aS5taW5pbXVtQ29udGVudEFyZWFTaXplLG89YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDExNyksdC5wb3J0TGFiZWxDZWxsJiYoci54XzA9Uy5NYXRoLm1heChyLnhfMCxLSCh0LnBvcnRMYWJlbENlbGwpKSk7aWYoci54XzA+MClzd2l0Y2gobi5vcmRpbmFsKXtjYXNlIDI6aS5wYWRkaW5nLnJpZ2h0PWUucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWw7YnJlYWs7Y2FzZSA0OmkucGFkZGluZy5sZWZ0PWUucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWx9fWZ1bmN0aW9uIGw4KGUsbixyLHQpe3ZhciBvO289bmV3IExmZSxuLmNlbGxzXzBbci5vcmRpbmFsXT1vLHloKGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsdCxvKX1mdW5jdGlvbiBGcGUoZSxuKXtlLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoKGFhKCksaGMpKSYmWm5uKGUsbiksUW5uKGUsbil9ZnVuY3Rpb24genBlKGUsbil7dmFyIHI7c3dpdGNoKHI9YShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNykucGFkZGluZyxuLm9yZGluYWwpe2Nhc2UgMTplLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbD49MCYmKHIudG9wXzA9ZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWwpO2JyZWFrO2Nhc2UgMzplLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbD49MCYmKHIuYm90dG9tPWUucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsKX1lLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMmJihyLmxlZnQ9ZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zLmxlZnQsci5yaWdodD1lLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMucmlnaHQpfWZ1bmN0aW9uIFFubihlLG4pe3ZhciByO2Uuc3Vycm91bmRpbmdQb3J0TWFyZ2lucyYmKHI9YShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNykucGFkZGluZyxyLnRvcF8wPWUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucy50b3BfMCxyLmJvdHRvbT1lLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMuYm90dG9tKX1mdW5jdGlvbiAkcGUoZSxuLHIpe3ZhciB0LG8saTtzd2l0Y2goaT1lLm5vZGVTaXplLHQ9YShadChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLHIpLDI1Miksbz10LmNlbGxSZWN0YW5nbGUsby53aWR0aF8wPXVFKHQpLG8uaGVpZ2h0PXNFKHQpLG8ud2lkdGhfMD1TLk1hdGgubWF4KG8ud2lkdGhfMCxpLnhfMCksby53aWR0aF8wPmkueF8wJiYhbiYmKG8ud2lkdGhfMD1pLnhfMCksby54XzA9LShvLndpZHRoXzAtaS54XzApLzIsci5vcmRpbmFsKXtjYXNlIDE6by55XzA9LW8uaGVpZ2h0O2JyZWFrO2Nhc2UgMzpvLnlfMD1pLnlfMH1lOCh0KSxuOCh0KX1mdW5jdGlvbiBCcGUoZSxuLHIpe3ZhciB0LG8saTtzd2l0Y2goaT1lLm5vZGVTaXplLHQ9YShadChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLHIpLDI1Miksbz10LmNlbGxSZWN0YW5nbGUsby53aWR0aF8wPXVFKHQpLG8uaGVpZ2h0PXNFKHQpLG8uaGVpZ2h0PVMuTWF0aC5tYXgoby5oZWlnaHQsaS55XzApLG8uaGVpZ2h0PmkueV8wJiYhbiYmKG8uaGVpZ2h0PWkueV8wKSxvLnlfMD0tKG8uaGVpZ2h0LWkueV8wKS8yLHIub3JkaW5hbCl7Y2FzZSA0Om8ueF8wPS1vLndpZHRoXzA7YnJlYWs7Y2FzZSAyOm8ueF8wPWkueF8wfWU4KHQpLG44KHQpfWZ1bmN0aW9uIEdwZSgpe31wKDE1NDEsMSxKZSxHcGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1VmZShhKG4sMzE0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmludGVybmFsLmFsZ29yaXRobSIsIkxhYmVsUGxhY2VyL2xhbWJkYSQwJFR5cGUiLDE1NDEpO2Z1bmN0aW9uIEhwZSgpe31wKDE1NDIsMSxJbixIcGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiEhYShuLDExNykucG9ydExhYmVsQ2VsbH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ubm9kZXNwYWNpbmcuaW50ZXJuYWwuYWxnb3JpdGhtIiwiTGFiZWxQbGFjZXIvbGFtYmRhJDEkVHlwZSIsMTU0Mik7ZnVuY3Rpb24gVXBlKCl7fXAoMTU0MywxLEplLFVwZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7VWZlKGEobiwxMTcpLnBvcnRMYWJlbENlbGwpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5pbnRlcm5hbC5hbGdvcml0aG0iLCJMYWJlbFBsYWNlci9sYW1iZGEkMiRUeXBlIiwxNTQzKTtmdW5jdGlvbiBnZigpe2dmPUYsWkg9RWUoKFNhKCksaTEpKX1mdW5jdGlvbiBXcGUoZSl7Z2YoKTt2YXIgbjtyZXR1cm4gbj1uZXcgUnQoYShlLm5vZGUuZ2V0UHJvcGVydHkoKEZuKCkseGcpKSw4KSksZS5zaXplT3B0aW9ucy5jb250YWlucygoZ2EoKSxMdykpJiYobi54XzA8PTAmJihuLnhfMD0yMCksbi55XzA8PTAmJihuLnlfMD0yMCkpLG59ZnVuY3Rpb24ganBlKGUpe3JldHVybiBnZigpLGUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKChTYSgpLFlmKSkmJiFlLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLGpUKSk/V3BlKGUpOm51bGx9ZnVuY3Rpb24gZXJuKGUsbil7Z2YoKTt2YXIgcix0LG8saTtyZXR1cm4gbz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KSxvLnNpemVfMSgpPj0yPyh0PWEoby5pdGVyYXRvcl8wKCkubmV4dF8xKCksMTE3KSxyPWUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucygoYWEoKSxyUykpLGk9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKGRtKSwhdC5sYWJlbHNOZXh0VG9Qb3J0JiYhciYmKG8uc2l6ZV8xKCk9PTJ8fGkpKTohMX1mdW5jdGlvbiBucm4oZSl7Z2YoKTt2YXIgbixyLHQsbztmb3Iobj1lLm5vZGVTaXplLnlfMCx0PWEoYShabihlLnBvcnRDb250ZXh0cywocmUoKSxsbikpLDIxKSw4NykuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9YSh0Lm5leHRfMSgpLDExNyksbz1yLnBvcnRQb3NpdGlvbixvLnlfMCs9bn1mdW5jdGlvbiBycm4oZSl7Z2YoKTt2YXIgbixyLHQ7ZS5zaXplT3B0aW9ucy5jb250YWlucygoZ2EoKSxwQSkpJiYodD1lLm5vZGVDb250YWluZXIuY2VsbFJlY3RhbmdsZSxuPW5ldyBZTihlLmluc2lkZU5vZGVMYWJlbENvbnRhaW5lci5jZW50ZXJDZWxsUmVjdCkscj1uZXcgT2gsci5sZWZ0PW4ueF8wLXQueF8wLHIudG9wXzA9bi55XzAtdC55XzAsci5yaWdodD10LnhfMCt0LndpZHRoXzAtKG4ueF8wK24ud2lkdGhfMCksci5ib3R0b209dC55XzArdC5oZWlnaHQtKG4ueV8wK24uaGVpZ2h0KSxlLm5vZGUuc2V0UGFkZGluZyhyKSl9ZnVuY3Rpb24gdHJuKGUpe2dmKCk7dmFyIG4scix0LG8saSxzLHU7Zm9yKHQ9ZS5ub2RlQ29udGFpbmVyLnBhZGRpbmcscz1BeihlLnBvcnRDb250ZXh0cykudGhpcyQwMS52YWx1ZUl0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOyl7aWYoaT1hKHMubmV4dF8xKCksMTE3KSxvPTAsaS5wb3J0Lmhhc1Byb3BlcnR5KChGbigpLHBhKSkmJihvPVIoJChpLnBvcnQuZ2V0UHJvcGVydHkocGEpKSksbzwwKSlzd2l0Y2goaS5wb3J0LmdldFNpZGUoKS5vcmRpbmFsKXtjYXNlIDE6dC50b3BfMD1TLk1hdGgubWF4KHQudG9wXzAsLW8pO2JyZWFrO2Nhc2UgMzp0LmJvdHRvbT1TLk1hdGgubWF4KHQuYm90dG9tLC1vKTticmVhaztjYXNlIDI6dC5yaWdodD1TLk1hdGgubWF4KHQucmlnaHQsLW8pO2JyZWFrO2Nhc2UgNDp0LmxlZnQ9Uy5NYXRoLm1heCh0LmxlZnQsLW8pfWlmKGVTKGUucG9ydExhYmVsc1BsYWNlbWVudCkpc3dpdGNoKG49akVuKGkucG9ydCxvKSx1PSFhKGUubm9kZS5nZXRQcm9wZXJ0eShXMCksMTgxKS5jb250YWlucygoZ2EoKSxXVCkpLHI9ITEsaS5wb3J0LmdldFNpZGUoKS5vcmRpbmFsKXtjYXNlIDE6cj1uPnQudG9wXzAsdC50b3BfMD1TLk1hdGgubWF4KHQudG9wXzAsbiksdSYmciYmKHQudG9wXzA9Uy5NYXRoLm1heCh0LnRvcF8wLHQuYm90dG9tKSx0LmJvdHRvbT10LnRvcF8wK28pO2JyZWFrO2Nhc2UgMzpyPW4+dC5ib3R0b20sdC5ib3R0b209Uy5NYXRoLm1heCh0LmJvdHRvbSxuKSx1JiZyJiYodC5ib3R0b209Uy5NYXRoLm1heCh0LmJvdHRvbSx0LnRvcF8wKSx0LnRvcF8wPXQuYm90dG9tK28pO2JyZWFrO2Nhc2UgMjpyPW4+dC5yaWdodCx0LnJpZ2h0PVMuTWF0aC5tYXgodC5yaWdodCxuKSx1JiZyJiYodC5yaWdodD1TLk1hdGgubWF4KHQubGVmdCx0LnJpZ2h0KSx0LmxlZnQ9dC5yaWdodCtvKTticmVhaztjYXNlIDQ6cj1uPnQubGVmdCx0LmxlZnQ9Uy5NYXRoLm1heCh0LmxlZnQsbiksdSYmciYmKHQubGVmdD1TLk1hdGgubWF4KHQubGVmdCx0LnJpZ2h0KSx0LnJpZ2h0PXQubGVmdCtvKX19fXZhciBaSDtmdW5jdGlvbiBWcGUoKXt9cCgxNTQwLDEsSmUsVnBlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtnZigpLGpubihhKG4sMTE3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmludGVybmFsLmFsZ29yaXRobSIsIk5vZGVMYWJlbEFuZFNpemVVdGlsaXRpZXMvbGFtYmRhJDAkVHlwZSIsMTU0MCk7ZnVuY3Rpb24gcXBlKGUsbil7dmFyIHIsdCxvLGkscyx1O2k9IWUuc2l6ZU9wdGlvbnMuY29udGFpbnMoKGdhKCksV1QpKSxzPWUuc2l6ZU9wdGlvbnMuY29udGFpbnMoRVIpLGUuaW5zaWRlTm9kZUxhYmVsQ29udGFpbmVyPW5ldyB6ZmUocyxpLGUubGFiZWxDZWxsU3BhY2luZyksZS5ub2RlTGFiZWxzUGFkZGluZyYmT1coZS5pbnNpZGVOb2RlTGFiZWxDb250YWluZXIucGFkZGluZyxlLm5vZGVMYWJlbHNQYWRkaW5nKSxyOChlLm5vZGVDb250YWluZXJNaWRkbGVSb3csKHVzKCksZmkpLGUuaW5zaWRlTm9kZUxhYmVsQ29udGFpbmVyKSxufHwodD1uZXcgY0UoMSxpLGUubGFiZWxDZWxsU3BhY2luZyksdC5wYWRkaW5nLmJvdHRvbT1lLm5vZGVMYWJlbFNwYWNpbmcseWgoZS5vdXRzaWRlTm9kZUxhYmVsQ29udGFpbmVycywocmUoKSxVZSksdCksbz1uZXcgY0UoMSxpLGUubGFiZWxDZWxsU3BhY2luZyksby5wYWRkaW5nLnRvcF8wPWUubm9kZUxhYmVsU3BhY2luZyx5aChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLGxuLG8pLHU9bmV3IGNFKDAsaSxlLmxhYmVsQ2VsbFNwYWNpbmcpLHUucGFkZGluZy5yaWdodD1lLm5vZGVMYWJlbFNwYWNpbmcseWgoZS5vdXRzaWRlTm9kZUxhYmVsQ29udGFpbmVycyxqZSx1KSxyPW5ldyBjRSgwLGksZS5sYWJlbENlbGxTcGFjaW5nKSxyLnBhZGRpbmcubGVmdD1lLm5vZGVMYWJlbFNwYWNpbmcseWgoZS5vdXRzaWRlTm9kZUxhYmVsQ29udGFpbmVycyxxZSxyKSl9ZnVuY3Rpb24gb3JuKGUsbil7cXBlKGUsITApLHdpKGUubm9kZS5nZXRMYWJlbHMoKSxuZXcgUUgoZSwhMCxuKSl9ZnVuY3Rpb24gaXJuKGUsbixyLHQpe3ZhciBvLGk7aT1uLmhhc1Byb3BlcnR5KChGbigpLElnKSk/YShuLmdldFByb3BlcnR5KElnKSwyMSk6ZS5ub2RlTGFiZWxQbGFjZW1lbnQsbz1Vbm4oaSksbyE9KEJ4KCksYTgpJiYociYmIUpIKG8pfHxZSChscm4oZSxvLHQpLG4pKX1mdW5jdGlvbiBhcm4oZSxuLHIsdCl7aXJuKGUsdCxuLHIpfWZ1bmN0aW9uIGxybihlLG4scil7dmFyIHQsbyxpO2lmKG89YShadChlLm5vZGVMYWJlbENlbGxzLG4pLDMxNCksIW8paWYobz1uZXcgcWZlKGUubGFiZWxMYWJlbFNwYWNpbmcsbixyKSx5aChlLm5vZGVMYWJlbENlbGxzLG4sbyksSkgobikpa25uKGUuaW5zaWRlTm9kZUxhYmVsQ29udGFpbmVyLG4uY29udGFpbmVyUm93LG4uY29udGFpbmVyQ29sdW1uLG8pO2Vsc2Ugc3dpdGNoKGk9SG5uKG4pLHQ9YShadChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLGkpLDI1MiksaS5vcmRpbmFsKXtjYXNlIDE6Y2FzZSAzOm8uY29udHJpYnV0ZXNUb01pbmltdW1IZWlnaHQ9ITAscjgodCxuLmNvbnRhaW5lckNvbHVtbixvKTticmVhaztjYXNlIDQ6Y2FzZSAyOm8uY29udHJpYnV0ZXNUb01pbmltdW1XaWR0aD0hMCxyOCh0LG4uY29udGFpbmVyUm93LG8pfXJldHVybiBvfWZ1bmN0aW9uIFFIKGUsbixyKXt0aGlzLm5vZGVDb250ZXh0XzA9ZSx0aGlzLm9ubHlJbnNpZGVfMT1uLHRoaXMuaG9yaXpvbnRhbExheW91dE1vZGVfMj1yfXAoODAxLDEsSmUsUUgpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Fybih0aGlzLm5vZGVDb250ZXh0XzAsdGhpcy5vbmx5SW5zaWRlXzEsdGhpcy5ob3Jpem9udGFsTGF5b3V0TW9kZV8yLGEobiwxODcpKX0sbC5ob3Jpem9udGFsTGF5b3V0TW9kZV8yPSExLGwub25seUluc2lkZV8xPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm5vZGVzcGFjaW5nLmludGVybmFsLmFsZ29yaXRobSIsIk5vZGVMYWJlbENlbGxDcmVhdG9yL2xhbWJkYSQwJFR5cGUiLDgwMSk7ZnVuY3Rpb24gc3JuKGUpe3ZhciBuLHIsdCxvO289ZS5ub2RlU2l6ZSxnZigpLGUuc2l6ZUNvbnN0cmFpbnRzLmlzRW1wdHkoKXx8WW4oZS5zaXplQ29uc3RyYWludHMsWkgpP249by55XzA6KGUudG9wZG93bkxheW91dD9uPVMuTWF0aC5tYXgoby55XzAsc0UoZS5ub2RlQ29udGFpbmVyKSk6bj1zRShlLm5vZGVDb250YWluZXIpLGUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKChTYSgpLEhUKSkmJiFlLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLG9TKSkmJihuPVMuTWF0aC5tYXgobixzRShhKFp0KGUub3V0c2lkZU5vZGVMYWJlbENvbnRhaW5lcnMsKHJlKCkscWUpKSwyNTIpKSksbj1TLk1hdGgubWF4KG4sc0UoYShadChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLGplKSwyNTIpKSkpLHI9anBlKGUpLHImJihuPVMuTWF0aC5tYXgobixyLnlfMCkpLGUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKFVUKSYmKGUucG9ydENvbnN0cmFpbnRzPT0oZHQoKSxIdSl8fGUucG9ydENvbnN0cmFpbnRzPT1haSkmJihuPVMuTWF0aC5tYXgobixSeChhKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsKHJlKCkscWUpKSwxMjcpKSksbj1TLk1hdGgubWF4KG4sUngoYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLGplKSwxMjcpKSkpKSxhZShpZShlLm5vZGUuZ2V0R3JhcGgoKS5nZXRQcm9wZXJ0eSgoRm4oKSxXZikpKSk/by55XzA9Uy5NYXRoLm1heChvLnlfMCxuKTpvLnlfMD1uLHQ9ZS5ub2RlQ29udGFpbmVyLmNlbGxSZWN0YW5nbGUsdC55XzA9MCx0LmhlaWdodD1uLG44KGUubm9kZUNvbnRhaW5lcil9ZnVuY3Rpb24gdXJuKGUpe3ZhciBuLHIsdCxvO3Q9ZS5ub2RlU2l6ZSxnZigpLGUuc2l6ZUNvbnN0cmFpbnRzLmlzRW1wdHkoKXx8WW4oZS5zaXplQ29uc3RyYWludHMsWkgpP289dC54XzA6KGUudG9wZG93bkxheW91dD9vPVMuTWF0aC5tYXgodC54XzAsdUUoZS5ub2RlQ29udGFpbmVyKSk6bz11RShlLm5vZGVDb250YWluZXIpLGUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKChTYSgpLEhUKSkmJiFlLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLG9TKSkmJihvPVMuTWF0aC5tYXgobyx1RShhKFp0KGUub3V0c2lkZU5vZGVMYWJlbENvbnRhaW5lcnMsKHJlKCksVWUpKSwyNTIpKSksbz1TLk1hdGgubWF4KG8sdUUoYShadChlLm91dHNpZGVOb2RlTGFiZWxDb250YWluZXJzLGxuKSwyNTIpKSkpLG49anBlKGUpLG4mJihvPVMuTWF0aC5tYXgobyxuLnhfMCkpKSxhZShpZShlLm5vZGUuZ2V0R3JhcGgoKS5nZXRQcm9wZXJ0eSgoRm4oKSxXZikpKSk/dC54XzA9Uy5NYXRoLm1heCh0LnhfMCxvKTp0LnhfMD1vLHI9ZS5ub2RlQ29udGFpbmVyLmNlbGxSZWN0YW5nbGUsci54XzA9MCxyLndpZHRoXzA9byxlOChlLm5vZGVDb250YWluZXIpfWZ1bmN0aW9uIGNybihlLG4scil7dmFyIHQ7dD1uZXcgTHBlKGUsbiksYmUoZS5wb3J0Q29udGV4dHMsbi5nZXRTaWRlKCksdCksciYmIWVTKGUucG9ydExhYmVsc1BsYWNlbWVudCkmJih0LnBvcnRMYWJlbENlbGw9bmV3IFZmZShlLmxhYmVsTGFiZWxTcGFjaW5nKSx3aShuLmdldExhYmVscygpLG5ldyBZcGUodCkpKX1mdW5jdGlvbiBfcm4oZSxuKXt2YXIgcix0LG8saTtmb3Iocj0hbnx8IWUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucygoYWEoKSxoYykpLGk9MCxvPW5ldyBUKGUubm9kZS5nZXRQb3J0cygpKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2lmKHQ9YShDKG8pLDg1MiksdC5nZXRTaWRlKCk9PShyZSgpLE9vKSl0aHJvdyBiKG5ldyBHZSgiTGFiZWwgYW5kIG5vZGUgc2l6ZSBjYWxjdWxhdG9yIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBwb3J0cyB0aGF0IGhhdmUgcG9ydCBzaWRlcyBhc3NpZ25lZC4iKSk7dC5zZXRWb2xhdGlsZUlkKGkrKyksY3JuKGUsdCxyKX19ZnVuY3Rpb24gZHJuKGUsbil7WUgoZS5wb3J0TGFiZWxDZWxsLG4pfWZ1bmN0aW9uIFlwZShlKXt0aGlzLnBvcnRDb250ZXh0XzA9ZX1wKDE1MzksMSxKZSxZcGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Rybih0aGlzLnBvcnRDb250ZXh0XzAsYShuLDE4NykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5ub2Rlc3BhY2luZy5pbnRlcm5hbC5hbGdvcml0aG0iLCJQb3J0Q29udGV4dENyZWF0b3IvbGFtYmRhJDAkVHlwZSIsMTUzOSk7ZnVuY3Rpb24gZnJuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxO2lmKGg9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4Nyksbj09KHJlKCkscWUpfHxuPT1qZSl7S3BlKGUsbik7cmV0dXJufWZvcihpPW49PVVlPyh6MSgpLHFDKTooejEoKSxZQyksTT1uPT1VZT8oTmkoKSxfcyk6KE5pKCksVWwpLHI9YShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNyksdD1yLmNlbGxSZWN0YW5nbGUsbz10LnhfMCt2ZyhQKEkoY3QsMSksWHQsMjgsMTUsW3IucGFkZGluZy5sZWZ0LGUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucy5sZWZ0LGUubm9kZUxhYmVsU3BhY2luZ10pKSx4PXQueF8wK3Qud2lkdGhfMC12ZyhQKEkoY3QsMSksWHQsMjgsMTUsW3IucGFkZGluZy5yaWdodCxlLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMucmlnaHQsZS5ub2RlTGFiZWxTcGFjaW5nXSkpLHM9clUodFUoaSksZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWwpLEE9bj09VWU/VnI6aHIsZj1oLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOylfPWEoZi5uZXh0XzEoKSwxMTcpLCEoIV8ucG9ydExhYmVsQ2VsbHx8Xy5wb3J0TGFiZWxDZWxsLmxhYmVscy5hcnJheS5sZW5ndGg8PTApJiYodj1fLnBvcnQuZ2V0U2l6ZSgpLEU9Xy5wb3J0UG9zaXRpb24sbT1fLnBvcnRMYWJlbENlbGwseT1tLmNlbGxSZWN0YW5nbGUseS53aWR0aF8wPShjPW0ucGFkZGluZyxtLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wK2MubGVmdCtjLnJpZ2h0KSx5LmhlaWdodD0odT1tLnBhZGRpbmcsbS5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMCt1LnRvcF8wK3UuYm90dG9tKSxGQyhNLCJWZXJ0aWNhbCBhbGlnbm1lbnQgY2Fubm90IGJlIG51bGwiKSxtLnZlcnRpY2FsQWxpZ25tZW50PU0sY3MobSwodGEoKSxIbCkpLHkueF8wPUUueF8wLSh5LndpZHRoXzAtdi54XzApLzIsSD1TLk1hdGgubWluKG8sRS54XzApLHE9Uy5NYXRoLm1heCh4LEUueF8wK3YueF8wKSx5LnhfMDxIP3kueF8wPUg6eS54XzAreS53aWR0aF8wPnEmJih5LnhfMD1xLXkud2lkdGhfMCksZWUocy5yZWN0YW5nbGVOb2RlcyxuZXcgXzgoeSxlVShzLHkpKSksQT1uPT1VZT9TLk1hdGgubWF4KEEsRS55XzArXy5wb3J0LmdldFNpemUoKS55XzApOlMuTWF0aC5taW4oQSxFLnlfMCkpO2ZvcihBKz1uPT1VZT9lLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbDotZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWwsaz1uVSgocy5zdGFydENvb3JkaW5hdGU9QSxzKSksaz4wJiYoYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNykubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzA9ayksZD1oLml0ZXJhdG9yXzAoKTtkLmhhc05leHRfMCgpOylfPWEoZC5uZXh0XzEoKSwxMTcpLCEoIV8ucG9ydExhYmVsQ2VsbHx8Xy5wb3J0TGFiZWxDZWxsLmxhYmVscy5hcnJheS5sZW5ndGg8PTApJiYoeT1fLnBvcnRMYWJlbENlbGwuY2VsbFJlY3RhbmdsZSx5LnhfMC09Xy5wb3J0UG9zaXRpb24ueF8wLHkueV8wLT1fLnBvcnRQb3NpdGlvbi55XzApfWZ1bmN0aW9uIHBybihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4O2lmKGQ9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NyksZC5zaXplXzEoKTw9Mnx8bj09KHJlKCkscWUpfHxuPT0ocmUoKSxqZSkpe1hwZShlLG4pO3JldHVybn1mb3IoRT1lLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoKGFhKCksZG0pKSxyPW49PShyZSgpLFVlKT8oejEoKSxZQyk6KHoxKCkscUMpLHg9bj09VWU/KE5pKCksVWwpOihOaSgpLF9zKSx0PXJVKHRVKHIpLGUucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWwpLHY9bj09VWU/aHI6VnIsXz1kLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOyl1PWEoXy5uZXh0XzEoKSwxMTcpLCEoIXUucG9ydExhYmVsQ2VsbHx8dS5wb3J0TGFiZWxDZWxsLmxhYmVscy5hcnJheS5sZW5ndGg8PTApJiYoeT11LnBvcnQuZ2V0U2l6ZSgpLG09dS5wb3J0UG9zaXRpb24sZj11LnBvcnRMYWJlbENlbGwsaD1mLmNlbGxSZWN0YW5nbGUsaC53aWR0aF8wPShpPWYucGFkZGluZyxmLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wK2kubGVmdCtpLnJpZ2h0KSxoLmhlaWdodD0ocz1mLnBhZGRpbmcsZi5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMCtzLnRvcF8wK3MuYm90dG9tKSxFPyhoLnhfMD1tLnhfMC0obz1mLnBhZGRpbmcsZi5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMCtvLmxlZnQrby5yaWdodCktZS5wb3J0TGFiZWxTcGFjaW5nSG9yaXpvbnRhbCxFPSExKTpoLnhfMD1tLnhfMCt5LnhfMCtlLnBvcnRMYWJlbFNwYWNpbmdIb3Jpem9udGFsLEZDKHgsIlZlcnRpY2FsIGFsaWdubWVudCBjYW5ub3QgYmUgbnVsbCIpLGYudmVydGljYWxBbGlnbm1lbnQ9eCxjcyhmLCh0YSgpLEhsKSksZWUodC5yZWN0YW5nbGVOb2RlcyxuZXcgXzgoaCxlVSh0LGgpKSksdj1uPT1VZT9TLk1hdGgubWluKHYsbS55XzApOlMuTWF0aC5tYXgodixtLnlfMCt1LnBvcnQuZ2V0U2l6ZSgpLnlfMCkpO2Zvcih2Kz1uPT1VZT8tZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWw6ZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWwsblUoKHQuc3RhcnRDb29yZGluYXRlPXYsdCkpLGM9ZC5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMTE3KSwhKCF1LnBvcnRMYWJlbENlbGx8fHUucG9ydExhYmVsQ2VsbC5sYWJlbHMuYXJyYXkubGVuZ3RoPD0wKSYmKGg9dS5wb3J0TGFiZWxDZWxsLmNlbGxSZWN0YW5nbGUsaC54XzAtPXUucG9ydFBvc2l0aW9uLnhfMCxoLnlfMC09dS5wb3J0UG9zaXRpb24ueV8wKX1mdW5jdGlvbiBzOChlLG4pe3ZhciByO3I9IWUuc2l6ZUNvbnN0cmFpbnRzLmNvbnRhaW5zKChTYSgpLGkxKSl8fGUucG9ydENvbnN0cmFpbnRzPT0oZHQoKSxhaSksZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKChhYSgpLGhjKSk/cj9mcm4oZSxuKTpLcGUoZSxuKTplLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoWTApJiYocj9wcm4oZSxuKTpYcGUoZSxuKSl9ZnVuY3Rpb24gZ3JuKGUsbil7c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBlLm5vZGVDb250YWluZXIucGFkZGluZy50b3BfMCtlLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbDtjYXNlIDM6cmV0dXJuIGUubm9kZUNvbnRhaW5lci5wYWRkaW5nLmJvdHRvbStlLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbDtjYXNlIDI6cmV0dXJuIGUubm9kZUNvbnRhaW5lci5wYWRkaW5nLnJpZ2h0K2UucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWw7Y2FzZSA0OnJldHVybiBlLm5vZGVDb250YWluZXIucGFkZGluZy5sZWZ0K2UucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWw7ZGVmYXVsdDpyZXR1cm4gMH19ZnVuY3Rpb24gS3BlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7Zm9yKHI9MCx0PWdybihlLG4pLGg9ZS5wb3J0TGFiZWxTcGFjaW5nSG9yaXpvbnRhbCxtPWUucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsLF89YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO18uaGFzTmV4dF8wKCk7KWlmKGM9YShfLm5leHRfMSgpLDExNyksISghYy5wb3J0TGFiZWxDZWxsfHxjLnBvcnRMYWJlbENlbGwubGFiZWxzLmFycmF5Lmxlbmd0aDw9MCkpe3N3aXRjaCh5PWMucG9ydC5nZXRTaXplKCksdT1jLnBvcnQuaGFzUHJvcGVydHkoKEZuKCkscGEpKT9SKCQoYy5wb3J0LmdldFByb3BlcnR5KHBhKSkpOjAsZD1jLnBvcnRMYWJlbENlbGwsZj1kLmNlbGxSZWN0YW5nbGUsZi53aWR0aF8wPShzPWQucGFkZGluZyxkLm1pbmltdW1Db250ZW50QXJlYVNpemUueF8wK3MubGVmdCtzLnJpZ2h0KSxmLmhlaWdodD0oaT1kLnBhZGRpbmcsZC5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMCtpLnRvcF8wK2kuYm90dG9tKSxuLm9yZGluYWwpe2Nhc2UgMTpmLnhfMD1jLmxhYmVsc05leHRUb1BvcnQ/KHkueF8wLWYud2lkdGhfMCkvMjp5LnhfMCtoLGYueV8wPXkueV8wK3UrdCxjcyhkLCh0YSgpLEEwKSksdXUoZCwoTmkoKSxfcykpO2JyZWFrO2Nhc2UgMzpmLnhfMD1jLmxhYmVsc05leHRUb1BvcnQ/KHkueF8wLWYud2lkdGhfMCkvMjp5LnhfMCtoLGYueV8wPS11LXQtZi5oZWlnaHQsY3MoZCwodGEoKSxBMCkpLHV1KGQsKE5pKCksVWwpKTticmVhaztjYXNlIDI6Zi54XzA9LXUtdC1mLndpZHRoXzAsYy5sYWJlbHNOZXh0VG9Qb3J0PyhvPWUucG9ydExhYmVsc1RyZWF0QXNHcm91cD9mLmhlaWdodDphKGxlKGQubGFiZWxzLDApLDE4NykuZ2V0U2l6ZSgpLnlfMCxmLnlfMD0oeS55XzAtbykvMik6Zi55XzA9eS55XzArbSxjcyhkLCh0YSgpLEhsKSksdXUoZCwoTmkoKSxMMCkpO2JyZWFrO2Nhc2UgNDpmLnhfMD15LnhfMCt1K3QsYy5sYWJlbHNOZXh0VG9Qb3J0PyhvPWUucG9ydExhYmVsc1RyZWF0QXNHcm91cD9mLmhlaWdodDphKGxlKGQubGFiZWxzLDApLDE4NykuZ2V0U2l6ZSgpLnlfMCxmLnlfMD0oeS55XzAtbykvMik6Zi55XzA9eS55XzArbSxjcyhkLCh0YSgpLHN1KSksdXUoZCwoTmkoKSxMMCkpfShuPT0ocmUoKSxVZSl8fG49PWxuKSYmKHI9Uy5NYXRoLm1heChyLGYuaGVpZ2h0KSl9cj4wJiYoYShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNykubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzA9cil9ZnVuY3Rpb24gWHBlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IoXz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KSxzPWVybihlLG4pLHI9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKChhYSgpLG5TKSksYz1fLml0ZXJhdG9yXzAoKTtjLmhhc05leHRfMCgpOylpZih1PWEoYy5uZXh0XzEoKSwxMTcpLCEoIXUucG9ydExhYmVsQ2VsbHx8dS5wb3J0TGFiZWxDZWxsLmxhYmVscy5hcnJheS5sZW5ndGg8PTApKXtzd2l0Y2goaD11LnBvcnQuZ2V0U2l6ZSgpLGQ9dS5wb3J0TGFiZWxDZWxsLGY9ZC5jZWxsUmVjdGFuZ2xlLGYud2lkdGhfMD0oaT1kLnBhZGRpbmcsZC5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMCtpLmxlZnQraS5yaWdodCksZi5oZWlnaHQ9KG89ZC5wYWRkaW5nLGQubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzArby50b3BfMCtvLmJvdHRvbSksbi5vcmRpbmFsKXtjYXNlIDE6dS5sYWJlbHNOZXh0VG9Qb3J0PyhmLnhfMD0oaC54XzAtZi53aWR0aF8wKS8yLGNzKGQsKHRhKCksQTApKSk6c3x8cj8oZi54XzA9LWYud2lkdGhfMC1lLnBvcnRMYWJlbFNwYWNpbmdIb3Jpem9udGFsLGNzKGQsKHRhKCksSGwpKSk6KGYueF8wPWgueF8wK2UucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWwsY3MoZCwodGEoKSxzdSkpKSxmLnlfMD0tZi5oZWlnaHQtZS5wb3J0TGFiZWxTcGFjaW5nVmVydGljYWwsdXUoZCwoTmkoKSxVbCkpO2JyZWFrO2Nhc2UgMzp1LmxhYmVsc05leHRUb1BvcnQ/KGYueF8wPShoLnhfMC1mLndpZHRoXzApLzIsY3MoZCwodGEoKSxBMCkpKTpzfHxyPyhmLnhfMD0tZi53aWR0aF8wLWUucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWwsY3MoZCwodGEoKSxIbCkpKTooZi54XzA9aC54XzArZS5wb3J0TGFiZWxTcGFjaW5nSG9yaXpvbnRhbCxjcyhkLCh0YSgpLHN1KSkpLGYueV8wPWgueV8wK2UucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsLHV1KGQsKE5pKCksX3MpKTticmVhaztjYXNlIDI6dS5sYWJlbHNOZXh0VG9Qb3J0Pyh0PWUucG9ydExhYmVsc1RyZWF0QXNHcm91cD9mLmhlaWdodDphKGxlKGQubGFiZWxzLDApLDE4NykuZ2V0U2l6ZSgpLnlfMCxmLnlfMD0oaC55XzAtdCkvMix1dShkLChOaSgpLEwwKSkpOnN8fHI/KGYueV8wPS1mLmhlaWdodC1lLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbCx1dShkLChOaSgpLFVsKSkpOihmLnlfMD1oLnlfMCtlLnBvcnRMYWJlbFNwYWNpbmdWZXJ0aWNhbCx1dShkLChOaSgpLF9zKSkpLGYueF8wPWgueF8wK2UucG9ydExhYmVsU3BhY2luZ0hvcml6b250YWwsY3MoZCwodGEoKSxzdSkpO2JyZWFrO2Nhc2UgNDp1LmxhYmVsc05leHRUb1BvcnQ/KHQ9ZS5wb3J0TGFiZWxzVHJlYXRBc0dyb3VwP2YuaGVpZ2h0OmEobGUoZC5sYWJlbHMsMCksMTg3KS5nZXRTaXplKCkueV8wLGYueV8wPShoLnlfMC10KS8yLHV1KGQsKE5pKCksTDApKSk6c3x8cj8oZi55XzA9LWYuaGVpZ2h0LWUucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsLHV1KGQsKE5pKCksVWwpKSk6KGYueV8wPWgueV8wK2UucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsLHV1KGQsKE5pKCksX3MpKSksZi54XzA9LWYud2lkdGhfMC1lLnBvcnRMYWJlbFNwYWNpbmdIb3Jpem9udGFsLGNzKGQsKHRhKCksSGwpKX1zPSExfX1mdW5jdGlvbiBHeCgpe0d4PUYsSHg9bmV3IHZyKCJwb3J0UmF0aW9PclBvc2l0aW9uIiwwKX1mdW5jdGlvbiBocm4oZSxuKXt2YXIgcjtyZXR1cm4gcj1lLnBvcnQsci5oYXNQcm9wZXJ0eSgoRm4oKSxwYSkpP3IuZ2V0U2lkZSgpPT0ocmUoKSxqZSk/LXIuZ2V0U2l6ZSgpLnhfMC1SKCQoci5nZXRQcm9wZXJ0eShwYSkpKTpuK1IoJChyLmdldFByb3BlcnR5KHBhKSkpOnIuZ2V0U2lkZSgpPT0ocmUoKSxqZSk/LXIuZ2V0U2l6ZSgpLnhfMDpufWZ1bmN0aW9uIEpwZShlLG4pe3ZhciByLHQsbztmb3Iobz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTE3KSx0LnBvcnRQb3NpdGlvbi55XzA9KHI9dC5wb3J0LHIuaGFzUHJvcGVydHkoKEZuKCkscGEpKT9yLmdldFNpZGUoKT09KHJlKCksVWUpPy1yLmdldFNpemUoKS55XzAtUigkKHIuZ2V0UHJvcGVydHkocGEpKSk6UigkKHIuZ2V0UHJvcGVydHkocGEpKSk6ci5nZXRTaWRlKCk9PShyZSgpLFVlKT8tci5nZXRTaXplKCkueV8wOjApfWZ1bmN0aW9uIFpwZShlLG4pe3ZhciByLHQsbyxpO2ZvcihyPWUubm9kZVNpemUueF8wLGk9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDExNyksby5wb3J0UG9zaXRpb24ueF8wPXIqUigkKG8ucG9ydC5nZXRQcm9wZXJ0eShIeCkpKSxvLnBvcnRQb3NpdGlvbi55XzA9KHQ9by5wb3J0LHQuaGFzUHJvcGVydHkoKEZuKCkscGEpKT90LmdldFNpZGUoKT09KHJlKCksVWUpPy10LmdldFNpemUoKS55XzAtUigkKHQuZ2V0UHJvcGVydHkocGEpKSk6UigkKHQuZ2V0UHJvcGVydHkocGEpKSk6dC5nZXRTaWRlKCk9PShyZSgpLFVlKT8tdC5nZXRTaXplKCkueV8wOjApfWZ1bmN0aW9uIFFwZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtpZighYShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXNFbXB0eSgpKXtpZihzPWEoWnQoZS5pbnNpZGVQb3J0TGFiZWxDZWxscyxuKSwxMjcpLGM9cy5jZWxsUmVjdGFuZ2xlLHU9cy5wYWRkaW5nLGQ9bzgoZSxuKSx0PWMud2lkdGhfMC11LmxlZnQtdS5yaWdodCxvPXMubWluaW11bUNvbnRlbnRBcmVhU2l6ZS54XzAsaT1jLnhfMCt1LmxlZnQsbT1lLnBvcnRQb3J0U3BhY2luZywoZD09KGtnKCksVjApfHxkPT16VCkmJmEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLnNpemVfMSgpPT0xJiYobz1kPT1WMD9vLTIqZS5wb3J0UG9ydFNwYWNpbmc6byxkPVh2KSx0PG8mJiFlLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLGdBKSkpZD09VjA/KG0rPSh0LW8pLyhhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5zaXplXzEoKSsxKSxpKz1tKTptKz0odC1vKS8oYShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4Nykuc2l6ZV8xKCktMSk7ZWxzZSBzd2l0Y2godDxvJiYobz1kPT1WMD9vLTIqZS5wb3J0UG9ydFNwYWNpbmc6byxkPVh2KSxkLm9yZGluYWwpe2Nhc2UgMzppKz0odC1vKS8yO2JyZWFrO2Nhc2UgNDppKz10LW87YnJlYWs7Y2FzZSAwOnI9KHQtbykvKGEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLnNpemVfMSgpKzEpLG0rPVMuTWF0aC5tYXgoMCxyKSxpKz1tO2JyZWFrO2Nhc2UgMTpyPSh0LW8pLyhhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5zaXplXzEoKS0xKSxtKz1TLk1hdGgubWF4KDAscil9Zm9yKGg9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO2guaGFzTmV4dF8wKCk7KWY9YShoLm5leHRfMSgpLDExNyksZi5wb3J0UG9zaXRpb24ueF8wPWkrZi5wb3J0TWFyZ2luLmxlZnQsZi5wb3J0UG9zaXRpb24ueV8wPShfPWYucG9ydCxfLmhhc1Byb3BlcnR5KChGbigpLHBhKSk/Xy5nZXRTaWRlKCk9PShyZSgpLFVlKT8tXy5nZXRTaXplKCkueV8wLVIoJChfLmdldFByb3BlcnR5KHBhKSkpOlIoJChfLmdldFByb3BlcnR5KHBhKSkpOl8uZ2V0U2lkZSgpPT0ocmUoKSxVZSk/LV8uZ2V0U2l6ZSgpLnlfMDowKSxpKz1mLnBvcnRNYXJnaW4ubGVmdCtmLnBvcnQuZ2V0U2l6ZSgpLnhfMCtmLnBvcnRNYXJnaW4ucmlnaHQrbX19ZnVuY3Rpb24gbXJuKGUpe3N3aXRjaChHeCgpLGUucG9ydENvbnN0cmFpbnRzLm9yZGluYWwpe2Nhc2UgNTpKcGUoZSwocmUoKSxVZSkpLEpwZShlLGxuKTticmVhaztjYXNlIDQ6WnBlKGUsKHJlKCksVWUpKSxacGUoZSxsbik7YnJlYWs7ZGVmYXVsdDpRcGUoZSwocmUoKSxVZSkpLFFwZShlLGxuKX19ZnVuY3Rpb24gZWdlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKHI9ZS5ub2RlU2l6ZS54XzAsaT1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspbz1hKGkubmV4dF8xKCksMTE3KSxvLnBvcnRQb3NpdGlvbi54XzA9KHQ9by5wb3J0LHQuaGFzUHJvcGVydHkoKEZuKCkscGEpKT90LmdldFNpZGUoKT09KHJlKCksamUpPy10LmdldFNpemUoKS54XzAtUigkKHQuZ2V0UHJvcGVydHkocGEpKSk6citSKCQodC5nZXRQcm9wZXJ0eShwYSkpKTp0LmdldFNpZGUoKT09KHJlKCksamUpPy10LmdldFNpemUoKS54XzA6cil9ZnVuY3Rpb24gbmdlKGUsbil7dmFyIHIsdCxvO2ZvcihyPWUubm9kZVNpemUsbz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTE3KSx0LnBvcnRQb3NpdGlvbi54XzA9aHJuKHQsci54XzApLHQucG9ydFBvc2l0aW9uLnlfMD1yLnlfMCpSKCQodC5wb3J0LmdldFByb3BlcnR5KEh4KSkpfWZ1bmN0aW9uIHJnZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKCFhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pc0VtcHR5KCkpe2lmKHM9YShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNyksYz1zLmNlbGxSZWN0YW5nbGUsdT1zLnBhZGRpbmcsZj1vOChlLG4pLHQ9Yy5oZWlnaHQtdS50b3BfMC11LmJvdHRvbSxvPXMubWluaW11bUNvbnRlbnRBcmVhU2l6ZS55XzAsaT1jLnlfMCt1LnRvcF8wLHk9ZS5wb3J0UG9ydFNwYWNpbmcsXz1lLm5vZGVTaXplLnhfMCwoZj09KGtnKCksVjApfHxmPT16VCkmJmEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLnNpemVfMSgpPT0xJiYobz1mPT1WMD9vLTIqZS5wb3J0UG9ydFNwYWNpbmc6byxmPVh2KSx0PG8mJiFlLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLGdBKSkpZj09VjA/KHkrPSh0LW8pLyhhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5zaXplXzEoKSsxKSxpKz15KTp5Kz0odC1vKS8oYShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4Nykuc2l6ZV8xKCktMSk7ZWxzZSBzd2l0Y2godDxvJiYobz1mPT1WMD9vLTIqZS5wb3J0UG9ydFNwYWNpbmc6byxmPVh2KSxmLm9yZGluYWwpe2Nhc2UgMzppKz0odC1vKS8yO2JyZWFrO2Nhc2UgNDppKz10LW87YnJlYWs7Y2FzZSAwOnI9KHQtbykvKGEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLnNpemVfMSgpKzEpLHkrPVMuTWF0aC5tYXgoMCxyKSxpKz15O2JyZWFrO2Nhc2UgMTpyPSh0LW8pLyhhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5zaXplXzEoKS0xKSx5Kz1TLk1hdGgubWF4KDAscil9Zm9yKG09YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO20uaGFzTmV4dF8wKCk7KWg9YShtLm5leHRfMSgpLDExNyksaC5wb3J0UG9zaXRpb24ueF8wPShkPWgucG9ydCxkLmhhc1Byb3BlcnR5KChGbigpLHBhKSk/ZC5nZXRTaWRlKCk9PShyZSgpLGplKT8tZC5nZXRTaXplKCkueF8wLVIoJChkLmdldFByb3BlcnR5KHBhKSkpOl8rUigkKGQuZ2V0UHJvcGVydHkocGEpKSk6ZC5nZXRTaWRlKCk9PShyZSgpLGplKT8tZC5nZXRTaXplKCkueF8wOl8pLGgucG9ydFBvc2l0aW9uLnlfMD1pK2gucG9ydE1hcmdpbi50b3BfMCxpKz1oLnBvcnRNYXJnaW4udG9wXzAraC5wb3J0LmdldFNpemUoKS55XzAraC5wb3J0TWFyZ2luLmJvdHRvbSt5fX1mdW5jdGlvbiB5cm4oZSl7c3dpdGNoKEd4KCksZS5wb3J0Q29uc3RyYWludHMub3JkaW5hbCl7Y2FzZSA1OmVnZShlLChyZSgpLHFlKSksZWdlKGUsamUpO2JyZWFrO2Nhc2UgNDpuZ2UoZSwocmUoKSxxZSkpLG5nZShlLGplKTticmVhaztkZWZhdWx0OnJnZShlLChyZSgpLHFlKSkscmdlKGUsamUpfX12YXIgSHg7ZnVuY3Rpb24gdGdlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKHI9MCxpPWEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSwxMTcpLHI9Uy5NYXRoLm1heChyLG8ucG9ydFBvc2l0aW9uLnlfMCtvLnBvcnQuZ2V0U2l6ZSgpLnlfMCk7dD1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbiksMTI3KSx0LnBhZGRpbmcudG9wXzA9MCx0Lm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wPXJ9ZnVuY3Rpb24gb2dlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKHI9YShadChlLmluc2lkZVBvcnRMYWJlbENlbGxzLG4pLDEyNyksYz1hKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KSxjLmlzRW1wdHkoKSl7ci5wYWRkaW5nLnRvcF8wPTAsci5wYWRkaW5nLmJvdHRvbT0wO3JldHVybn1mb3IoXz1lLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoKGFhKCksaGMpKSxzPTAsZS5zaXplQ29uc3RyYWludHMuY29udGFpbnMoKFNhKCksaTEpKSYmYWdlKGUsbiksdT1jLml0ZXJhdG9yXzAoKSxkPW51bGwsaD0wLGY9MDt1Lmhhc05leHRfMCgpOyl0PWEodS5uZXh0XzEoKSwxMTcpLGk9UigkKHQucG9ydC5nZXRQcm9wZXJ0eSgoR3goKSxIeCkpKSksbz10LnBvcnQuZ2V0U2l6ZSgpLnlfMCxkPyhtPWYrZC5wb3J0TWFyZ2luLmJvdHRvbStlLnBvcnRQb3J0U3BhY2luZyt0LnBvcnRNYXJnaW4udG9wXzAscz1TLk1hdGgubWF4KHMsKGJzKCksa2woQ3MpLFMuTWF0aC5hYnMoaC1pKTw9Q3N8fGg9PWl8fGlzTmFOKGgpJiZpc05hTihpKT8wOm0vKGktaCkpKSk6ZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zJiZlLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMudG9wXzA+MCYmKHM9Uy5NYXRoLm1heChzLFJwZShlLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMudG9wXzArdC5wb3J0TWFyZ2luLnRvcF8wLGkpKSksZD10LGg9aSxmPW87ZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zJiZlLnN1cnJvdW5kaW5nUG9ydE1hcmdpbnMuYm90dG9tPjAmJihtPWYrZS5zdXJyb3VuZGluZ1BvcnRNYXJnaW5zLmJvdHRvbSxfJiYobSs9ZC5wb3J0TWFyZ2luLmJvdHRvbSkscz1TLk1hdGgubWF4KHMsKGJzKCksa2woQ3MpLFMuTWF0aC5hYnMoaC0xKTw9Q3N8fGg9PTF8fGlzTmFOKGgpJiZpc05hTigxKT8wOm0vKDEtaCkpKSksci5wYWRkaW5nLnRvcF8wPTAsci5taW5pbXVtQ29udGVudEFyZWFTaXplLnlfMD1zfWZ1bmN0aW9uIGlnZShlLG4pe3ZhciByLHQ7aWYocj1hKFp0KGUuaW5zaWRlUG9ydExhYmVsQ2VsbHMsbiksMTI3KSxhKGEoWm4oZS5wb3J0Q29udGV4dHMsbiksMjEpLDg3KS5pc0VtcHR5KCkpe3IucGFkZGluZy50b3BfMD0wLHIucGFkZGluZy5ib3R0b209MDtyZXR1cm59ci5wYWRkaW5nLnRvcF8wPWUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucy50b3BfMCxyLnBhZGRpbmcuYm90dG9tPWUuc3Vycm91bmRpbmdQb3J0TWFyZ2lucy5ib3R0b20sZS5zaXplQ29uc3RyYWludHMuY29udGFpbnMoKFNhKCksaTEpKSYmYWdlKGUsbiksdD12cm4oZSxuKSxvOChlLG4pPT0oa2coKSxWMCkmJih0Kz0yKmUucG9ydFBvcnRTcGFjaW5nKSxyLm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wPXR9ZnVuY3Rpb24gd3JuKGUpe3N3aXRjaChlLnBvcnRDb25zdHJhaW50cy5vcmRpbmFsKXtjYXNlIDU6dGdlKGUsKHJlKCkscWUpKSx0Z2UoZSxqZSk7YnJlYWs7Y2FzZSA0Om9nZShlLChyZSgpLHFlKSksb2dlKGUsamUpO2JyZWFrO2RlZmF1bHQ6aWdlKGUsKHJlKCkscWUpKSxpZ2UoZSxqZSl9fWZ1bmN0aW9uIEVybihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKGM9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDExNyksbz11LnBvcnRMYWJlbENlbGw/amZlKHUucG9ydExhYmVsQ2VsbCk6MCxvPjA/dS5sYWJlbHNOZXh0VG9Qb3J0PyhfPXUucG9ydC5nZXRTaXplKCkueV8wLG8+XyYmKGUucG9ydExhYmVsc1RyZWF0QXNHcm91cHx8dS5wb3J0TGFiZWxDZWxsLmxhYmVscy5hcnJheS5sZW5ndGg9PTE/KHM9KG8tXykvMix1LnBvcnRNYXJnaW4udG9wXzA9cyx1LnBvcnRNYXJnaW4uYm90dG9tPXMpOihyPWEobGUodS5wb3J0TGFiZWxDZWxsLmxhYmVscywwKSwxODcpLmdldFNpemUoKS55XzAsdD0oci1fKS8yLHUucG9ydE1hcmdpbi50b3BfMD1TLk1hdGgubWF4KDAsdCksdS5wb3J0TWFyZ2luLmJvdHRvbT1vLXQtXykpKTp1LnBvcnRNYXJnaW4uYm90dG9tPWUucG9ydExhYmVsU3BhY2luZ1ZlcnRpY2FsK286ZVMoZS5wb3J0TGFiZWxzUGxhY2VtZW50KSYmKGk9QWVlKHUucG9ydCksaS55XzA8MCYmKHUucG9ydE1hcmdpbi50b3BfMD0taS55XzApLGkueV8wK2kuaGVpZ2h0PnUucG9ydC5nZXRTaXplKCkueV8wJiYodS5wb3J0TWFyZ2luLmJvdHRvbT1pLnlfMCtpLmhlaWdodC11LnBvcnQuZ2V0U2l6ZSgpLnlfMCkpfWZ1bmN0aW9uIHZybihlLG4pe3ZhciByLHQsbztmb3Iobz0wLHQ9YShhKFpuKGUucG9ydENvbnRleHRzLG4pLDIxKSw4NykuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9YSh0Lm5leHRfMSgpLDExNyksbys9ci5wb3J0TWFyZ2luLnRvcF8wK3IucG9ydC5nZXRTaXplKCkueV8wK3IucG9ydE1hcmdpbi5ib3R0b20sdC5oYXNOZXh0XzAoKSYmKG8rPWUucG9ydFBvcnRTcGFjaW5nKTtyZXR1cm4gb31mdW5jdGlvbiBhZ2UoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZihzPWEoYShabihlLnBvcnRDb250ZXh0cyxuKSwyMSksODcpLHU9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKChhYSgpLFkwKSkscj1lLnBvcnRMYWJlbHNQbGFjZW1lbnQuY29udGFpbnMoclMpLHQ9ZS5wb3J0TGFiZWxzUGxhY2VtZW50LmNvbnRhaW5zKG5TKSxjPWUucG9ydExhYmVsc1BsYWNlbWVudC5jb250YWlucyhkbSksZj1lLnNpemVPcHRpb25zLmNvbnRhaW5zKChnYSgpLG1BKSksXz0hciYmIXQmJihjfHxzLnNpemVfMSgpPT0yKSxFcm4oZSxuKSxkPW51bGwsbz1udWxsLHUpe2ZvcihpPXMuaXRlcmF0b3JfMCgpLGQ9YShpLm5leHRfMSgpLDExNyksbz1kO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDExNyk7ZC5wb3J0TWFyZ2luLnRvcF8wPTAsby5wb3J0TWFyZ2luLmJvdHRvbT0wLF8mJiFkLmxhYmVsc05leHRUb1BvcnQmJihkLnBvcnRNYXJnaW4uYm90dG9tPTApfWYmJihTcm4ocyksdSYmKGQucG9ydE1hcmdpbi50b3BfMD0wLG8ucG9ydE1hcmdpbi5ib3R0b209MCkpfWZ1bmN0aW9uIFNybihlKXt2YXIgbixyLHQsbyxpO2ZvcihyPTAsbj0wLGk9ZS5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspdD1hKGkubmV4dF8xKCksMTE3KSxyPVMuTWF0aC5tYXgocix0LnBvcnRNYXJnaW4udG9wXzApLG49Uy5NYXRoLm1heChuLHQucG9ydE1hcmdpbi5ib3R0b20pO2ZvcihvPWUuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDExNyksdC5wb3J0TWFyZ2luLnRvcF8wPXIsdC5wb3J0TWFyZ2luLmJvdHRvbT1ufWZ1bmN0aW9uIENybihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZDtmb3IoXz1lLmdhcFZlcnRpY2FsLG49bmV3IEJyLGM9MCx0PW5ldyBUKGUucmVjdGFuZ2xlTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHI9YShDKHQpLDIyNiksZD0wLHdfKHIub3ZlcmxhcHBpbmdOb2RlcyxuZXcgc2dlKSxzPWRuKHIub3ZlcmxhcHBpbmdOb2RlcywwKTtzLmN1cnJlbnROb2RlIT1zLnRoaXMkMDEudGFpbDspaT1hKHVuKHMpLDIyNiksbi5tYXBfMC5jb250YWluc0tleShpKSYmKG89ci5yZWN0YW5nbGUsdT1pLnJlY3RhbmdsZSxkPHUueV8wK3UuaGVpZ2h0K18mJmQrby5oZWlnaHQrXz51LnlfMCYmKGQ9dS55XzArdS5oZWlnaHQrXykpO3IucmVjdGFuZ2xlLnlfMD1kLG4ubWFwXzAucHV0KHIsbiksYz1TLk1hdGgubWF4KGMsci5yZWN0YW5nbGUueV8wK3IucmVjdGFuZ2xlLmhlaWdodCl9cmV0dXJuIGN9ZnVuY3Rpb24gbGdlKCl7fWZ1bmN0aW9uIFRybihlLG4pe3JldHVybiBpcihlLnJlY3RhbmdsZS55XzAsbi5yZWN0YW5nbGUueV8wKX1wKDE5MDIsMSx7fSxsZ2UpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm92ZXJsYXBzIiwiR3JlZWR5UmVjdGFuZ2xlU3RyaXBPdmVybGFwUmVtb3ZlciIsMTkwMik7ZnVuY3Rpb24gc2dlKCl7fXAoMTkwMywxLE5uLHNnZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gVHJuKGEobiwyMjYpLGEociwyMjYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5vdmVybGFwcyIsIkdyZWVkeVJlY3RhbmdsZVN0cmlwT3ZlcmxhcFJlbW92ZXIvMG1ldGhvZHJlZiRjb21wYXJlQnlZQ29vcmRpbmF0ZSRUeXBlIiwxOTAzKTtmdW5jdGlvbiBicm4oZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKGk9bmV3IEZjKGEodm4obmV3IF9nZSksNTApKSx1PVZyLHI9bmV3IFQoZS5yZWN0YW5nbGVOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iobj1hKEMociksMjI2KSx1PW4ucmVjdGFuZ2xlLnhfMDtpLm1hcF8wLnNpemVfMSgpIT0wJiYocz1hKGkubWFwXzAuZmlyc3RLZXkoKSwyMjYpLHMucmVjdGFuZ2xlLnhfMCtzLnJlY3RhbmdsZS53aWR0aF8wPHUpOylpLm1hcF8wLnJlbW92ZV8wKHMpIT1udWxsO2ZvcihvPWkubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMjI2KSxMbih0Lm92ZXJsYXBwaW5nTm9kZXMsbiksTG4obi5vdmVybGFwcGluZ05vZGVzLHQpO2kubWFwXzAucHV0KG4sKHplKCksUzApKT09bnVsbH19ZnVuY3Rpb24gSXJuKGUsbil7dmFyIHIsdDtzd2l0Y2godD1uLnJlY3RhbmdsZSxyPW4ub3JpZ2luYWxSZWN0YW5nbGUsZS5vdmVybGFwUmVtb3ZhbERpcmVjdGlvbi5vcmRpbmFsKXtjYXNlIDA6ci55XzA9ZS5zdGFydENvb3JkaW5hdGUtdC5oZWlnaHQtdC55XzA7YnJlYWs7Y2FzZSAxOnIueV8wKz1lLnN0YXJ0Q29vcmRpbmF0ZTticmVhaztjYXNlIDI6ci54XzA9ZS5zdGFydENvb3JkaW5hdGUtdC5oZWlnaHQtdC55XzA7YnJlYWs7Y2FzZSAzOnIueF8wPWUuc3RhcnRDb29yZGluYXRlK3QueV8wfX1mdW5jdGlvbiBlVShlLG4pe3N3aXRjaChlLm92ZXJsYXBSZW1vdmFsRGlyZWN0aW9uLm9yZGluYWwpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIG47Y2FzZSAyOmNhc2UgMzpyZXR1cm4gbmV3IHRsKG4ueV8wLDAsbi5oZWlnaHQsbi53aWR0aF8wKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBuVShlKXt2YXIgbjtyZXR1cm4hZS5vdmVybGFwUmVtb3ZhbFN0cmF0ZWd5JiYoZS5vdmVybGFwUmVtb3ZhbFN0cmF0ZWd5PW5ldyBsZ2UpLERyKGUucmVjdGFuZ2xlTm9kZXMsbmV3IGNnZSksYnJuKGUpLG49Q3JuKGUpLExyKG5ldyBTZShudWxsLG5ldyB4ZShlLnJlY3RhbmdsZU5vZGVzLDE2KSksbmV3IGdnZShlKSksbn1mdW5jdGlvbiByVShlLG4pe3JldHVybiBlLmdhcFZlcnRpY2FsPW4sZX1mdW5jdGlvbiB4cm4oZSxuKXtyZXR1cm4gZS5zdGFydENvb3JkaW5hdGU9bixlfWZ1bmN0aW9uIHVnZSgpe3RoaXMucmVjdGFuZ2xlTm9kZXM9bmV3IFF9ZnVuY3Rpb24gUHJuKGUsbil7cmV0dXJuIGlyKGUucmVjdGFuZ2xlLnhfMCxuLnJlY3RhbmdsZS54XzApfWZ1bmN0aW9uIE5ybihlLG4pe3JldHVybiBpcihlLnJlY3RhbmdsZS54XzArZS5yZWN0YW5nbGUud2lkdGhfMCxuLnJlY3RhbmdsZS54XzArbi5yZWN0YW5nbGUud2lkdGhfMCl9ZnVuY3Rpb24gdFUoZSl7dmFyIG47cmV0dXJuIG49bmV3IHVnZSxuLm92ZXJsYXBSZW1vdmFsRGlyZWN0aW9uPWUsbn1wKDE4NDksMSx7fSx1Z2UpLGwuZ2FwVmVydGljYWw9NSxsLnN0YXJ0Q29vcmRpbmF0ZT0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLm92ZXJsYXBzIiwiUmVjdGFuZ2xlU3RyaXBPdmVybGFwUmVtb3ZlciIsMTg0OSk7ZnVuY3Rpb24gY2dlKCl7fXAoMTg1MCwxLE5uLGNnZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gUHJuKGEobiwyMjYpLGEociwyMjYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5vdmVybGFwcyIsIlJlY3RhbmdsZVN0cmlwT3ZlcmxhcFJlbW92ZXIvMG1ldGhvZHJlZiRjb21wYXJlTGVmdFJlY3RhbmdsZUJvcmRlcnMkVHlwZSIsMTg1MCk7ZnVuY3Rpb24gX2dlKCl7fXAoMTg1MiwxLE5uLF9nZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gTnJuKGEobiwyMjYpLGEociwyMjYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5vdmVybGFwcyIsIlJlY3RhbmdsZVN0cmlwT3ZlcmxhcFJlbW92ZXIvMW1ldGhvZHJlZiRjb21wYXJlUmlnaHRSZWN0YW5nbGVCb3JkZXJzJFR5cGUiLDE4NTIpO2Z1bmN0aW9uIHoxKCl7ejE9RixZQz1uZXcgVXgoIlVQIiwwKSxxQz1uZXcgVXgoIkRPV04iLDEpLHU4PW5ldyBVeCgiTEVGVCIsMiksYzg9bmV3IFV4KCJSSUdIVCIsMyl9ZnVuY3Rpb24gVXgoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBBcm4oZSl7cmV0dXJuIHoxKCksd24oKGZnZSgpLHBnZSksZSl9ZnVuY3Rpb24gTHJuKCl7cmV0dXJuIHoxKCksUChJKGRnZSwxKSxXLDQxNywwLFtZQyxxQyx1OCxjOF0pfXAoNDE3LDIyLHszOjEsMzQ6MSwyMjoxLDQxNzoxfSxVeCk7dmFyIHFDLHU4LGM4LFlDLGRnZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ub3ZlcmxhcHMiLCJSZWN0YW5nbGVTdHJpcE92ZXJsYXBSZW1vdmVyL092ZXJsYXBSZW1vdmFsRGlyZWN0aW9uIiw0MTcsZ24sTHJuLEFybik7ZnVuY3Rpb24gZmdlKCl7ZmdlPUYscGdlPXluKCh6MSgpLFAoSShkZ2UsMSksVyw0MTcsMCxbWUMscUMsdTgsYzhdKSkpfXZhciBwZ2U7ZnVuY3Rpb24gXzgoZSxuKXt0aGlzLm92ZXJsYXBwaW5nTm9kZXM9bmV3IHByLHRoaXMub3JpZ2luYWxSZWN0YW5nbGU9ZSx0aGlzLnJlY3RhbmdsZT1ufXAoMjI2LDEsezIyNjoxfSxfOCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ub3ZlcmxhcHMiLCJSZWN0YW5nbGVTdHJpcE92ZXJsYXBSZW1vdmVyL1JlY3RhbmdsZU5vZGUiLDIyNik7ZnVuY3Rpb24gZ2dlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxODUxLDEsSmUsZ2dlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtJcm4odGhpcy4kJG91dGVyXzAsYShuLDIyNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5vdmVybGFwcyIsIlJlY3RhbmdsZVN0cmlwT3ZlcmxhcFJlbW92ZXIvbGFtYmRhJDEkVHlwZSIsMTg1MSk7ZnVuY3Rpb24ga3JuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7c3dpdGNoKHU9ZS5wb2x5cyxuPWUuZ3JpZCxhKHcoZSwoTngoKSxFSCkpLDQzNSkub3JkaW5hbCl7Y2FzZSAwOkRyKHUsbmV3IENuKG5ldyBTZ2UpKTticmVhaztjYXNlIDE6ZGVmYXVsdDpEcih1LG5ldyBDbihuZXcgQ2dlKSl9c3dpdGNoKGEodyhlLHlIKSw0MzYpLm9yZGluYWwpe2Nhc2UgMTpEcih1LG5ldyBvVSksRHIodSxuZXcgVGdlKSxEcih1LG5ldyBoZ2UpO2JyZWFrO2Nhc2UgMDpkZWZhdWx0OkRyKHUsbmV3IG9VKSxEcih1LG5ldyBFZ2UpfXN3aXRjaChhKHcoZSxTSCksMjU3KS5vcmRpbmFsKXtjYXNlIDA6Yz1uZXcgSWdlO2JyZWFrO2Nhc2UgMTpjPW5ldyBmODticmVhaztjYXNlIDI6Yz1uZXcgV3g7YnJlYWs7Y2FzZSAzOmM9bmV3IGQ4O2JyZWFrO2Nhc2UgNTpjPW5ldyBOeShuZXcgV3gpO2JyZWFrO2Nhc2UgNDpjPW5ldyBOeShuZXcgZjgpO2JyZWFrO2Nhc2UgNzpjPW5ldyBpVShuZXcgTnkobmV3IGY4KSxuZXcgTnkobmV3IFd4KSk7YnJlYWs7Y2FzZSA4OmM9bmV3IGlVKG5ldyBOeShuZXcgZDgpLG5ldyBOeShuZXcgV3gpKTticmVhaztjYXNlIDY6ZGVmYXVsdDpjPW5ldyBOeShuZXcgZDgpfWZvcihzPW5ldyBUKHUpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGk9YShDKHMpLDE3NiksdD0wLG89MCxyPW5ldyBacihKKHQpLEoobykpO0pybihuLGksdCxvKTspcj1hKGMuYXBwbHlfMyhyLGkpLDQyKSx0PWEoci5maXJzdCwxNykudmFsdWVfMCxvPWEoci5zZWNvbmQsMTcpLnZhbHVlXzA7WXJuKG4saSx0LG8pfX1mdW5jdGlvbiBPcm4oZSxuKXt2YXIgcix0LG8saTtyZXR1cm4gcj1uZXcgbWdlLHQ9YShUbyhwbyhuZXcgU2UobnVsbCxuZXcgeGUoZS5wb2x5b21pbm9FeHRlbnNpb25zLDE2KSksciksbGYobmV3IHZoLG5ldyBTaCxuZXcgQ2gsbmV3IFRoLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxzZiksQ29dKSkpLDIxKSxvPXQuc2l6ZV8xKCksbz1vPT0yPzE6MCxvPT0xJiZUMShtQyhhKFRvKEpuKHQucGFyYWxsZWxTdHJlYW0oKSxuZXcgeWdlKSxiMWUoZWMoMCksbmV3IHpHKSksMTY4KS52YWx1ZV8wLDIpLDApJiYobz0wKSx0PWEoVG8ocG8obmV3IFNlKG51bGwsbmV3IHhlKG4ucG9seW9taW5vRXh0ZW5zaW9ucywxNikpLHIpLGxmKG5ldyB2aCxuZXcgU2gsbmV3IENoLG5ldyBUaCxQKEkob28sMSksVywxMDgsMCxbc2YsQ29dKSkpLDIxKSxpPXQuc2l6ZV8xKCksaT1pPT0yPzE6MCxpPT0xJiZUMShtQyhhKFRvKEpuKHQucGFyYWxsZWxTdHJlYW0oKSxuZXcgd2dlKSxiMWUoZWMoMCksbmV3IHpHKSksMTY4KS52YWx1ZV8wLDIpLDApJiYoaT0wKSxvPGk/LTE6bz09aT8wOjF9ZnVuY3Rpb24gaGdlKCl7fXAoMTMyMywxLE5uLGhnZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gT3JuKGEobiwxNzYpLGEociwxNzYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJQb2x5b21pbm9Db21wYWN0b3IvQ29ybmVyQ2FzZXNHcmVhdGVyVGhhblJlc3RDb21wYXJhdG9yIiwxMzIzKTtmdW5jdGlvbiBtZ2UoKXt9cCgxMzI2LDEse30sbWdlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwzMzQpLmZpcnN0fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJQb2x5b21pbm9Db21wYWN0b3IvQ29ybmVyQ2FzZXNHcmVhdGVyVGhhblJlc3RDb21wYXJhdG9yL2xhbWJkYSQwJFR5cGUiLDEzMjYpO2Z1bmN0aW9uIHlnZSgpe31wKDEzMjcsMSxJbix5Z2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzMyKS5ob3Jpem9udGFsfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJQb2x5b21pbm9Db21wYWN0b3IvQ29ybmVyQ2FzZXNHcmVhdGVyVGhhblJlc3RDb21wYXJhdG9yL2xhbWJkYSQxJFR5cGUiLDEzMjcpO2Z1bmN0aW9uIHdnZSgpe31wKDEzMjgsMSxJbix3Z2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzMyKS5ob3Jpem9udGFsfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJQb2x5b21pbm9Db21wYWN0b3IvQ29ybmVyQ2FzZXNHcmVhdGVyVGhhblJlc3RDb21wYXJhdG9yL2xhbWJkYSQyJFR5cGUiLDEzMjgpO2Z1bmN0aW9uIE1ybihlLG4pe3ZhciByLHQsbyxpO3JldHVybiByPW5ldyB2Z2UsdD1hKFRvKHBvKG5ldyBTZShudWxsLG5ldyB4ZShlLnBvbHlvbWlub0V4dGVuc2lvbnMsMTYpKSxyKSxsZihuZXcgdmgsbmV3IFNoLG5ldyBDaCxuZXcgVGgsUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLHNmKSxDb10pKSksMjEpLG89dC5zaXplXzEoKSx0PWEoVG8ocG8obmV3IFNlKG51bGwsbmV3IHhlKG4ucG9seW9taW5vRXh0ZW5zaW9ucywxNikpLHIpLGxmKG5ldyB2aCxuZXcgU2gsbmV3IENoLG5ldyBUaCxQKEkob28sMSksVywxMDgsMCxbc2YsQ29dKSkpLDIxKSxpPXQuc2l6ZV8xKCksbzxpPy0xOm89PWk/MDoxfWZ1bmN0aW9uIEVnZSgpe31wKDEzMjEsMSxObixFZ2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIE1ybihhKG4sMTc2KSxhKHIsMTc2KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vIiwiUG9seW9taW5vQ29tcGFjdG9yL01pbk51bU9mRXh0ZW5zaW9uRGlyZWN0aW9uc0NvbXBhcmF0b3IiLDEzMjEpO2Z1bmN0aW9uIHZnZSgpe31wKDEzMjQsMSx7fSx2Z2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDMzNCkuZmlyc3R9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlBvbHlvbWlub0NvbXBhY3Rvci9NaW5OdW1PZkV4dGVuc2lvbkRpcmVjdGlvbnNDb21wYXJhdG9yL2xhbWJkYSQwJFR5cGUiLDEzMjQpO2Z1bmN0aW9uIFJybihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9ZS5wb2x5b21pbm9FeHRlbnNpb25zLmFycmF5Lmxlbmd0aCx0PW4ucG9seW9taW5vRXh0ZW5zaW9ucy5hcnJheS5sZW5ndGgscjx0Py0xOnI9PXQ/MDoxfWZ1bmN0aW9uIG9VKCl7fXAoNzgxLDEsTm4sb1UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIFJybihhKG4sMTc2KSxhKHIsMTc2KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vIiwiUG9seW9taW5vQ29tcGFjdG9yL01pbk51bU9mRXh0ZW5zaW9uc0NvbXBhcmF0b3IiLDc4MSk7ZnVuY3Rpb24gRHJuKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1lLnhTaXplK2UueVNpemUsdD1uLnhTaXplK24ueVNpemUscjx0Py0xOnI9PXQ/MDoxfWZ1bmN0aW9uIFNnZSgpe31wKDEzMTksMSxObixTZ2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIERybihhKG4sMzMwKSxhKHIsMzMwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vIiwiUG9seW9taW5vQ29tcGFjdG9yL01pblBlcmltZXRlckNvbXBhcmF0b3IiLDEzMTkpO2Z1bmN0aW9uIEZybihlLG4pe3ZhciByLHQsbyxpO3JldHVybiBpPWUueFNpemUscj1lLnlTaXplLGk8cj9pKj1pOnIqPXIsdD1pK3IsaT1uLnhTaXplLHI9bi55U2l6ZSxpPHI/aSo9aTpyKj1yLG89aStyLHQ8bz8tMTp0PT1vPzA6MX1mdW5jdGlvbiBDZ2UoKXt9cCgxMzIwLDEsTm4sQ2dlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBGcm4oYShuLDMzMCksYShyLDMzMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlBvbHlvbWlub0NvbXBhY3Rvci9NaW5QZXJpbWV0ZXJDb21wYXJhdG9yV2l0aFNoYXBlIiwxMzIwKTtmdW5jdGlvbiB6cm4oZSxuKXt2YXIgcix0LG8saTtyZXR1cm4gcj1uZXcgYmdlLHQ9YShUbyhwbyhuZXcgU2UobnVsbCxuZXcgeGUoZS5wb2x5b21pbm9FeHRlbnNpb25zLDE2KSksciksbGYobmV3IHZoLG5ldyBTaCxuZXcgQ2gsbmV3IFRoLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxzZiksQ29dKSkpLDIxKSxvPXQuc2l6ZV8xKCksdD1hKFRvKHBvKG5ldyBTZShudWxsLG5ldyB4ZShuLnBvbHlvbWlub0V4dGVuc2lvbnMsMTYpKSxyKSxsZihuZXcgdmgsbmV3IFNoLG5ldyBDaCxuZXcgVGgsUChJKG9vLDEpLFcsMTA4LDAsW3NmLENvXSkpKSwyMSksaT10LnNpemVfMSgpLG89bz09MT8xOjAsaT1pPT0xPzE6MCxvPGk/LTE6bz09aT8wOjF9ZnVuY3Rpb24gVGdlKCl7fXAoMTMyMiwxLE5uLFRnZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4genJuKGEobiwxNzYpLGEociwxNzYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJQb2x5b21pbm9Db21wYWN0b3IvU2luZ2xlRXh0ZW5zaW9uU2lkZUdyZWF0ZXJUaGFuUmVzdENvbXBhcmF0b3IiLDEzMjIpO2Z1bmN0aW9uIGJnZSgpe31wKDEzMjUsMSx7fSxiZ2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDMzNCkuZmlyc3R9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlBvbHlvbWlub0NvbXBhY3Rvci9TaW5nbGVFeHRlbnNpb25TaWRlR3JlYXRlclRoYW5SZXN0Q29tcGFyYXRvci9sYW1iZGEkMCRUeXBlIiwxMzI1KTtmdW5jdGlvbiAkcm4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3Iocz1lLnhTaXplLHQ9QihobixrbiwyOCxzLDE1LDEpLG89QihobixrbiwyOCxzLDE1LDEpLHI9ZS55U2l6ZSxuPUIoaG4sa24sMjgsciwxNSwxKSxpPUIoaG4sa24sMjgsciwxNSwxKSxfPTA7XzxzO18rKyl7Zm9yKGY9MDtmPHImJiEkcChlLF8sZik7KSsrZjt0W19dPWZ9Zm9yKGQ9MDtkPHM7ZCsrKXtmb3IoZj1yLTE7Zj49MCYmISRwKGUsZCxmKTspLS1mO29bZF09Zn1mb3IobT0wO208cjttKyspe2Zvcih1PTA7dTxzJiYhJHAoZSx1LG0pOykrK3U7blttXT11fWZvcih5PTA7eTxyO3krKyl7Zm9yKHU9cy0xO3U+PTAmJiEkcChlLHUseSk7KS0tdTtpW3ldPXV9Zm9yKGM9MDtjPHM7YysrKWZvcihoPTA7aDxyO2grKyljPGlbaF0mJmM+bltoXSYmaDxvW2NdJiZoPnRbY10mJlZ4KGUsYyxoLCExLCEwKX1mdW5jdGlvbiBCcm4oZSxuLHIpe3JldHVybiByLnBvbHlvbWlub0V4dGVuc2lvbnMuYXJyYXkubGVuZ3RoPjA/YVUoZS5leHRlcm5hbEZ1bixuLHIpOmFVKGUubm9ybWFsRnVuLG4scil9ZnVuY3Rpb24gaVUoZSxuKXt0aGlzLm5vcm1hbEZ1bj1lLHRoaXMuZXh0ZXJuYWxGdW49bn1wKDc4MiwxLHt9LGlVKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gQnJuKHRoaXMsYShuLDQyKSxhKHIsMTc2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlN1Y2Nlc3NvckNvbWJpbmF0aW9uIiw3ODIpO2Z1bmN0aW9uIEdybihlKXt2YXIgbixyLHQsbyxpO3JldHVybiBvPWEoZS5maXJzdCwxNykudmFsdWVfMCxpPWEoZS5zZWNvbmQsMTcpLnZhbHVlXzAscj1vLHQ9aSxuPVMuTWF0aC5tYXgoUy5NYXRoLmFicyhvKSxTLk1hdGguYWJzKGkpKSxvPD0wJiZvPT1pPyhyPTAsdD1pLTEpOm89PS1uJiZpIT1uPyhyPWksdD1vLGk+PTAmJisrcik6KHI9LWksdD1vKSxuZXcgWnIoSihyKSxKKHQpKX1mdW5jdGlvbiBkOCgpe31wKDY0OSwxLHt9LGQ4KSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXt2YXIgdDtyZXR1cm4gR3JuKCh0PWEobiw0MiksYShyLDE3NiksdCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJTdWNjZXNzb3JKaXR0ZXIiLDY0OSk7ZnVuY3Rpb24gSHJuKGUpe3ZhciBuLHI7aWYobj1hKGUuZmlyc3QsMTcpLnZhbHVlXzAscj1hKGUuc2Vjb25kLDE3KS52YWx1ZV8wLG4+PTApe2lmKG49PXIpcmV0dXJuIG5ldyBacihKKC1uLTEpLEooLW4tMSkpO2lmKG49PS1yKXJldHVybiBuZXcgWnIoSigtbiksSihyKzEpKX1yZXR1cm4gUy5NYXRoLmFicyhuKT5TLk1hdGguYWJzKHIpP248MD9uZXcgWnIoSigtbiksSihyKSk6bmV3IFpyKEooLW4pLEoocisxKSk6bmV3IFpyKEoobisxKSxKKHIpKX1mdW5jdGlvbiBmOCgpe31wKDY0OCwxLHt9LGY4KSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXt2YXIgdDtyZXR1cm4gSHJuKCh0PWEobiw0MiksYShyLDE3NiksdCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8iLCJTdWNjZXNzb3JMaW5lQnlMaW5lIiw2NDgpO2Z1bmN0aW9uIFVybihlKXt2YXIgbixyLHQsbztyZXR1cm4gdD1hKGUuZmlyc3QsMTcpLnZhbHVlXzAsbz1hKGUuc2Vjb25kLDE3KS52YWx1ZV8wLG49dCxyPW8sdD09MCYmbz09MD9yLT0xOnQ9PS0xJiZvPD0wPyhuPTAsci09Mik6dDw9MCYmbz4wPyhuLT0xLHItPTEpOnQ+PTAmJm88MD8obis9MSxyKz0xKTp0PjAmJm8+PTA/KG4tPTEscis9MSk6KG4rPTEsci09MSksbmV3IFpyKEoobiksSihyKSl9ZnVuY3Rpb24gV3goKXt9cCg1NzMsMSx7fSxXeCksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7dmFyIHQ7cmV0dXJuIFVybigodD1hKG4sNDIpLGEociwxNzYpLHQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vIiwiU3VjY2Vzc29yTWFuaGF0dGFuIiw1NzMpO2Z1bmN0aW9uIFdybihlKXt2YXIgbixyLHQ7cmV0dXJuIHI9YShlLmZpcnN0LDE3KS52YWx1ZV8wLHQ9YShlLnNlY29uZCwxNykudmFsdWVfMCxuPVMuTWF0aC5tYXgoUy5NYXRoLmFicyhyKSxTLk1hdGguYWJzKHQpKSxyPG4mJnQ9PS1uP25ldyBacihKKHIrMSksSih0KSk6cj09biYmdDxuP25ldyBacihKKHIpLEoodCsxKSk6cj49LW4mJnQ9PW4/bmV3IFpyKEooci0xKSxKKHQpKTpuZXcgWnIoSihyKSxKKHQtMSkpfWZ1bmN0aW9uIElnZSgpe31wKDEzNDQsMSx7fSxJZ2UpLGwuYXBwbHlfMz1mdW5jdGlvbihuLHIpe3ZhciB0O3JldHVybiBXcm4oKHQ9YShuLDQyKSxhKHIsMTc2KSx0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlN1Y2Nlc3Nvck1heE5vcm1XaW5kaW5nSW5NYXRoUG9zU2Vuc2UiLDEzNDQpO2Z1bmN0aW9uIGFVKGUsbixyKXtyZXR1cm4geGdlKGUsYShuLDQyKSxhKHIsMTc2KSl9ZnVuY3Rpb24geGdlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkO3JldHVybiBZbihyLGUubGFzdFBvbHkpfHwoZS5sYXN0UG9seT1yLGk9bmV3IFBnZSxzPWEoVG8ocG8obmV3IFNlKG51bGwsbmV3IHhlKHIucG9seW9taW5vRXh0ZW5zaW9ucywxNikpLGkpLGxmKG5ldyB2aCxuZXcgU2gsbmV3IENoLG5ldyBUaCxQKEkob28sMSksVywxMDgsMCxbKHJhKCksc2YpLENvXSkpKSwyMSksZS5wb3NYPSEwLGUucG9zWT0hMCxlLm5lZ1g9ITAsZS5uZWdZPSEwLG89cy5jb250YWlucygoTmgoKSxYQykpLHQ9cy5jb250YWlucyhKQyksbyYmIXQmJihlLnBvc1k9ITEpLCFvJiZ0JiYoZS5uZWdZPSExKSxvPXMuY29udGFpbnMoS0MpLHQ9cy5jb250YWlucyhaQyksbyYmIXQmJihlLm5lZ1g9ITEpLCFvJiZ0JiYoZS5wb3NYPSExKSksZD1hKGUuY29zdEZ1bi5hcHBseV8zKG4sciksNDIpLGM9YShkLmZpcnN0LDE3KS52YWx1ZV8wLF89YShkLnNlY29uZCwxNykudmFsdWVfMCx1PSExLGM8MD9lLm5lZ1h8fCh1PSEwKTplLnBvc1h8fCh1PSEwKSxfPDA/ZS5uZWdZfHwodT0hMCk6ZS5wb3NZfHwodT0hMCksdT94Z2UoZSxkLHIpOmR9ZnVuY3Rpb24gTnkoZSl7dGhpcy5jb3N0RnVuPWV9cCg0MDksMSx7fSxOeSksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIGFVKHRoaXMsbixyKX0sbC5uZWdYPSExLGwubmVnWT0hMSxsLnBvc1g9ITEsbC5wb3NZPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWlubyIsIlN1Y2Nlc3NvclF1YWRyYW50c0dlbmVyaWMiLDQwOSk7ZnVuY3Rpb24gUGdlKCl7fXAoMTM0NSwxLHt9LFBnZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzM0KS5maXJzdH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vIiwiU3VjY2Vzc29yUXVhZHJhbnRzR2VuZXJpYy9sYW1iZGEkMCRUeXBlIiwxMzQ1KTtmdW5jdGlvbiBOaCgpe05oPUYsWEM9bmV3IGp4KCJOT1JUSCIsMCksS0M9bmV3IGp4KCJFQVNUIiwxKSxKQz1uZXcgangoIlNPVVRIIiwyKSxaQz1uZXcgangoIldFU1QiLDMpLFhDLmhvcml6b250YWw9ITEsS0MuaG9yaXpvbnRhbD0hMCxKQy5ob3Jpem9udGFsPSExLFpDLmhvcml6b250YWw9ITB9ZnVuY3Rpb24gangoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBqcm4oZSl7cmV0dXJuIE5oKCksd24oKEFnZSgpLExnZSksZSl9ZnVuY3Rpb24gVnJuKCl7cmV0dXJuIE5oKCksUChJKE5nZSwxKSxXLDMzMiwwLFtYQyxLQyxKQyxaQ10pfXAoMzMyLDIyLHszOjEsMzQ6MSwyMjoxLDMzMjoxfSxqeCksbC5ob3Jpem9udGFsPSExO3ZhciBLQyxYQyxKQyxaQyxOZ2U9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWluby5zdHJ1Y3R1cmVzIiwiRGlyZWN0aW9uIiwzMzIsZ24sVnJuLGpybik7ZnVuY3Rpb24gQWdlKCl7QWdlPUYsTGdlPXluKChOaCgpLFAoSShOZ2UsMSksVywzMzIsMCxbWEMsS0MsSkMsWkNdKSkpfXZhciBMZ2U7ZnVuY3Rpb24ga2dlKGUpe3JldHVybiBlPjg/MDplKzF9ZnVuY3Rpb24gJHAoZSxuLHIpe3RyeXtyZXR1cm4gVDEocDgoZSxuLHIpLDEpfWNhdGNoKHQpe3Rocm93IHQ9d3IodCksTCh0LDMzMyk/YihuZXcgbm8oIkdyaWQgaXMgb25seSBvZiBzaXplICIrZS54U2l6ZSsiKiIrZS55U2l6ZSsiLiBSZXF1ZXN0ZWQgcG9pbnQgKCIrbisiLCAiK3IrIikgaXMgb3V0IG9mIGJvdW5kcy4iKSk6Yih0KX19ZnVuY3Rpb24gT2dlKGUsbixyKXt0cnl7cmV0dXJuIFQxKHA4KGUsbixyKSwwKX1jYXRjaCh0KXt0aHJvdyB0PXdyKHQpLEwodCwzMzMpP2IobmV3IG5vKCJHcmlkIGlzIG9ubHkgb2Ygc2l6ZSAiK2UueFNpemUrIioiK2UueVNpemUrIi4gUmVxdWVzdGVkIHBvaW50ICgiK24rIiwgIityKyIpIGlzIG91dCBvZiBib3VuZHMuIikpOmIodCl9fWZ1bmN0aW9uIE1nZShlLG4scil7dHJ5e3JldHVybiBUMShwOChlLG4sciksMil9Y2F0Y2godCl7dGhyb3cgdD13cih0KSxMKHQsMzMzKT9iKG5ldyBubygiR3JpZCBpcyBvbmx5IG9mIHNpemUgIitlLnhTaXplKyIqIitlLnlTaXplKyIuIFJlcXVlc3RlZCBwb2ludCAoIituKyIsICIrcisiKSBpcyBvdXQgb2YgYm91bmRzLiIpKTpiKHQpfX1mdW5jdGlvbiBwOChlLG4scil7dmFyIHQsbyxpO3JldHVybiBpPW4+PjUsbz1uJjMxLHQ9ZXQodjAoZS5ncmlkW3JdW2ldLFNuKE9sKG8sMSkpKSwzKSx0fWZ1bmN0aW9uIFZ4KGUsbixyLHQsbyl7dmFyIGkscyx1O3RyeXtpZihuPj1lLnhTaXplKXRocm93IGIobmV3IEYkKTt1PW4+PjUscz1uJjMxLGk9T2woMSxTbihPbChzLDEpKSksbz9lLmdyaWRbcl1bdV09bHMoZS5ncmlkW3JdW3VdLGkpOmUuZ3JpZFtyXVt1XT1ldChlLmdyaWRbcl1bdV0sUiQoaSkpLGk9T2woaSwxKSx0P2UuZ3JpZFtyXVt1XT1scyhlLmdyaWRbcl1bdV0saSk6ZS5ncmlkW3JdW3VdPWV0KGUuZ3JpZFtyXVt1XSxSJChpKSl9Y2F0Y2goYyl7dGhyb3cgYz13cihjKSxMKGMsMzMzKT9iKG5ldyBubygiR3JpZCBpcyBvbmx5IG9mIHNpemUgIitlLnhTaXplKyIqIitlLnlTaXplKyIuIFJlcXVlc3RlZCBwb2ludCAoIituKyIsICIrcisiKSBpcyBvdXQgb2YgYm91bmRzLiIpKTpiKGMpfX1wKDEzMTcsMSx7fSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saSxzO2Zvcih0PSIgIixuPUooMCksaT0wO2k8dGhpcy54U2l6ZTtpKyspdCs9IiIrbi52YWx1ZV8wLG49SihrZ2Uobi52YWx1ZV8wKSk7Zm9yKHQrPWAKYCxuPUooMCkscz0wO3M8dGhpcy55U2l6ZTtzKyspe2Zvcih0Kz0iIituLnZhbHVlXzAsbj1KKGtnZShuLnZhbHVlXzApKSxvPTA7bzx0aGlzLnhTaXplO28rKylyPXA4KHRoaXMsbyxzKSxWbyhyLDApPT0wP3QrPSJfIjpWbyhyLDEpPT0wP3QrPSJYIjp0Kz0iMCI7dCs9YApgfXJldHVybiBZYSh0LDAsdC5sZW5ndGgtMSl9LGwueFNpemU9MCxsLnlTaXplPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vLnN0cnVjdHVyZXMiLCJUd29CaXRHcmlkIiwxMzE3KTtmdW5jdGlvbiBxcm4oZSxuLHIsdCl7dmFyIG8saSxzLHU7Zm9yKG89MDtvPG4ueFNpemU7bysrKWZvcihpPW8tbi54Q2VudGVyK3Iscz0wO3M8bi55U2l6ZTtzKyspdT1zLW4ueUNlbnRlcit0LCRwKG4sbyxzKT9Rcm4oZSxpLHUpfHxudG4oZSxpLHUpOk1nZShuLG8scykmJihSZ2UoZSxpLHUpfHxydG4oZSxpLHUpKX1mdW5jdGlvbiBZcm4oZSxuLHIsdCl7dmFyIG8saTtmb3IocXJuKGUsbixyLHQpLHR0bihuLGUueENlbnRlci1uLnhDZW50ZXIrciksb3RuKG4sZS55Q2VudGVyLW4ueUNlbnRlcit0KSxpPW5ldyBUKG4ucG9seW9taW5vRXh0ZW5zaW9ucyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXN3aXRjaChvPWEoQyhpKSwzMzQpLG8uZmlyc3Qub3JkaW5hbCl7Y2FzZSAwOkF5KGUsbi54XzArby5zZWNvbmQudmFsdWVfMCwwLG4ueF8wK28udGhpcmQudmFsdWVfMCxuLnlfMC0xKTticmVhaztjYXNlIDE6QXkoZSxuLnhfMCtuLnhTaXplLG4ueV8wK28uc2Vjb25kLnZhbHVlXzAsZS54U2l6ZS0xLG4ueV8wK28udGhpcmQudmFsdWVfMCk7YnJlYWs7Y2FzZSAyOkF5KGUsbi54XzArby5zZWNvbmQudmFsdWVfMCxuLnlfMCtuLnlTaXplLG4ueF8wK28udGhpcmQudmFsdWVfMCxlLnlTaXplLTEpO2JyZWFrO2RlZmF1bHQ6QXkoZSwwLG4ueV8wK28uc2Vjb25kLnZhbHVlXzAsbi54XzAtMSxuLnlfMCtvLnRoaXJkLnZhbHVlXzApfX1mdW5jdGlvbiBLcm4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQ7Zm9yKHI9ZS54U2l6ZSxuPWUueVNpemUscz1xbixvPWJ0LHU9cW4saT1idCxfPTA7XzxyOysrXylmb3IoZD0wO2Q8bjsrK2QpJHAoZSxfLGQpJiYocz1TLk1hdGgubWluKHMsXyksbz1TLk1hdGgubWF4KG8sXyksdT1TLk1hdGgubWluKHUsZCksaT1TLk1hdGgubWF4KGksZCkpO3JldHVybiBjPW8tcysxLHQ9aS11KzEsbmV3IEt6ZShKKHMpLEoodSksSihjKSxKKHQpKX1mdW5jdGlvbiBYcm4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2ZvcihvPTA7bzxuLnhTaXplO28rKylmb3IoaT1vLW4ueENlbnRlcityLHM9MDtzPG4ueVNpemU7cysrKWlmKHU9cy1uLnlDZW50ZXIrdCxjPWksXz11LGMrPWUueENlbnRlcixfKz1lLnlDZW50ZXIsYz49MCYmXz49MCYmYzxlLnhTaXplJiZfPGUueVNpemUmJighT2dlKG4sbyxzKSYmUmdlKGUsaSx1KXx8JHAobixvLHMpJiYhWnJuKGUsaSx1KSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gSnJuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkO2lmKFhybihlLG4scix0KSlyZXR1cm4hMDtmb3Iocz1uZXcgVChuLnBvbHlvbWlub0V4dGVuc2lvbnMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7c3dpdGNoKGk9YShDKHMpLDMzNCksdT0hMSxjPWUueENlbnRlci1uLnhDZW50ZXIrcixfPWMrbi54U2l6ZSxkPWUueUNlbnRlci1uLnlDZW50ZXIrdCxvPWQrbi55U2l6ZSxpLmZpcnN0Lm9yZGluYWwpe2Nhc2UgMDp1PWc4KGUsYytpLnNlY29uZC52YWx1ZV8wLDAsYytpLnRoaXJkLnZhbHVlXzAsZC0xKTticmVhaztjYXNlIDE6dT1nOChlLF8sZCtpLnNlY29uZC52YWx1ZV8wLGUueFNpemUtMSxkK2kudGhpcmQudmFsdWVfMCk7YnJlYWs7Y2FzZSAyOnU9ZzgoZSxjK2kuc2Vjb25kLnZhbHVlXzAsbyxjK2kudGhpcmQudmFsdWVfMCxlLnlTaXplLTEpO2JyZWFrO2RlZmF1bHQ6dT1nOChlLDAsZCtpLnNlY29uZC52YWx1ZV8wLGMtMSxkK2kudGhpcmQudmFsdWVfMCl9aWYodSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBSZ2UoZSxuLHIpe3ZhciB0O3RyeXtyZXR1cm4gJHAoZSxuK2UueENlbnRlcixyK2UueUNlbnRlcil9Y2F0Y2gobyl7dGhyb3cgbz13cihvKSxMKG8sNzcpPyh0PW8sYihuZXcgbm8odC5kZXRhaWxNZXNzYWdlKyIgR2l2ZW4gY2VudGVyIGJhc2VkIGNvb3JkaW5hdGVzIHdlcmUgKCIrbisiLCAiK3IrIikuIikpKTpiKG8pfX1mdW5jdGlvbiBacm4oZSxuLHIpe3ZhciB0O3RyeXtyZXR1cm4gT2dlKGUsbitlLnhDZW50ZXIscitlLnlDZW50ZXIpfWNhdGNoKG8pe3Rocm93IG89d3IobyksTChvLDc3KT8odD1vLGIobmV3IG5vKHQuZGV0YWlsTWVzc2FnZSsiIEdpdmVuIGNlbnRlciBiYXNlZCBjb29yZGluYXRlcyB3ZXJlICgiK24rIiwgIityKyIpLiIpKSk6YihvKX19ZnVuY3Rpb24gUXJuKGUsbixyKXt2YXIgdDt0cnl7cmV0dXJuIE1nZShlLG4rZS54Q2VudGVyLHIrZS55Q2VudGVyKX1jYXRjaChvKXt0aHJvdyBvPXdyKG8pLEwobyw3Nyk/KHQ9byxiKG5ldyBubyh0LmRldGFpbE1lc3NhZ2UrIiBHaXZlbiBjZW50ZXIgYmFzZWQgY29vcmRpbmF0ZXMgd2VyZSAoIituKyIsICIrcisiKS4iKSkpOmIobyl9fWZ1bmN0aW9uIGV0bihlLG4scil7ZS5ncmlkPWJfKF9fLFtYLGE2XSxbMzc2LDI4XSwxNCxbcixLcihTLk1hdGguY2VpbChuLzMyKSldLDIpLGUueFNpemU9bixlLnlTaXplPXIsZS54Q2VudGVyPW4tMT4+MSxlLnlDZW50ZXI9ci0xPj4xfWZ1bmN0aW9uIG50bihlLG4scil7dmFyIHQ7dHJ5e1Z4KGUsbitlLnhDZW50ZXIscitlLnlDZW50ZXIsITEsITApfWNhdGNoKG8pe3Rocm93IG89d3IobyksTChvLDc3KT8odD1vLGIobmV3IG5vKHQuZGV0YWlsTWVzc2FnZSsiIEdpdmVuIGNlbnRlciBiYXNlZCBjb29yZGluYXRlcyB3ZXJlICgiK24rIiwgIityKyIpLiIpKSk6YihvKX19ZnVuY3Rpb24gcnRuKGUsbixyKXt2YXIgdDt0cnl7VngoZSxuK2UueENlbnRlcixyK2UueUNlbnRlciwhMCwhMSl9Y2F0Y2gobyl7dGhyb3cgbz13cihvKSxMKG8sNzcpPyh0PW8sYihuZXcgbm8odC5kZXRhaWxNZXNzYWdlKyIgR2l2ZW4gY2VudGVyIGJhc2VkIGNvb3JkaW5hdGVzIHdlcmUgKCIrbisiLCAiK3IrIikuIikpKTpiKG8pfX1mdW5jdGlvbiBBeShlLG4scix0LG8pe3ZhciBpLHM7Zm9yKHM9cjtzPD1vO3MrKylmb3IoaT1uO2k8PXQ7aSsrKSRwKGUsaSxzKXx8VngoZSxpLHMsITAsITEpfWZ1bmN0aW9uIGc4KGUsbixyLHQsbyl7dmFyIGkscztmb3Iocz1yO3M8PW87cysrKWZvcihpPW47aTw9dDtpKyspaWYoJHAoZSxpLHMpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGxVKGUsbil7dGhpcy5ncmlkPWJfKF9fLFtYLGE2XSxbMzc2LDI4XSwxNCxbbixLcihTLk1hdGguY2VpbChlLzMyKSldLDIpLHRoaXMueFNpemU9ZSx0aGlzLnlTaXplPW4sdGhpcy54Q2VudGVyPWUtMT4+MSx0aGlzLnlDZW50ZXI9bi0xPj4xfXAoMzMwLDEzMTcsezMzMDoxfSxsVSksbC54Q2VudGVyPTAsbC55Q2VudGVyPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24ucG9seW9taW5vLnN0cnVjdHVyZXMiLCJQbGFuYXJHcmlkIiwzMzApO2Z1bmN0aW9uIHR0bihlLG4pe2UueF8wPW59ZnVuY3Rpb24gb3RuKGUsbil7ZS55XzA9bn1mdW5jdGlvbiBpdG4oZSl7bFUuY2FsbCh0aGlzLDAsMCksdGhpcy5wb2x5b21pbm9FeHRlbnNpb25zPWV9cCgxNzYsMzMwLHszMzA6MSwxNzY6MX0pLGwueF8wPTAsbC55XzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5wb2x5b21pbm8uc3RydWN0dXJlcyIsIlBvbHlvbWlubyIsMTc2KTt2YXIgYXRuPUNyKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgucHJvcGVydGllcyIsIklQcm9wZXJ0eUhvbGRlciIpO2Z1bmN0aW9uIGdvKGUsbil7dmFyIHI7cmV0dXJuIG4mJihyPW4uZ2V0QWxsUHJvcGVydGllcygpLHIuaXNFbXB0eSgpfHwoZS5wcm9wZXJ0eU1hcD9iMihlLnByb3BlcnR5TWFwLHIpOmUucHJvcGVydHlNYXA9bmV3IGowZShyKSkpLGV9ZnVuY3Rpb24gRGdlKGUpe3JldHVybiBlLnByb3BlcnR5TWFwP2UucHJvcGVydHlNYXA6KE5lKCksTmUoKSxrdSl9ZnVuY3Rpb24gdyhlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9KCFlLnByb3BlcnR5TWFwJiYoZS5wcm9wZXJ0eU1hcD1uZXcgc24pLEtlKGUucHJvcGVydHlNYXAsbikpLHQ/PyhyPW4uZ2V0RGVmYXVsdCgpLEwociw0KSYmKHI9PW51bGw/KCFlLnByb3BlcnR5TWFwJiYoZS5wcm9wZXJ0eU1hcD1uZXcgc24pLGhoKGUucHJvcGVydHlNYXAsbikpOighZS5wcm9wZXJ0eU1hcCYmKGUucHJvcGVydHlNYXA9bmV3IHNuKSxCbihlLnByb3BlcnR5TWFwLG4scikpKSxyKX1mdW5jdGlvbiBfcihlLG4pe3JldHVybiEhZS5wcm9wZXJ0eU1hcCYmeWkoZS5wcm9wZXJ0eU1hcCxuKX1mdW5jdGlvbiBRQyhlLG4scil7cmV0dXJuIHI9PW51bGw/KCFlLnByb3BlcnR5TWFwJiYoZS5wcm9wZXJ0eU1hcD1uZXcgc24pLGhoKGUucHJvcGVydHlNYXAsbikpOighZS5wcm9wZXJ0eU1hcCYmKGUucHJvcGVydHlNYXA9bmV3IHNuKSxCbihlLnByb3BlcnR5TWFwLG4scikpLGV9ZnVuY3Rpb24gaihlLG4scil7cmV0dXJuIHI9PW51bGw/KCFlLnByb3BlcnR5TWFwJiYoZS5wcm9wZXJ0eU1hcD1uZXcgc24pLGhoKGUucHJvcGVydHlNYXAsbikpOighZS5wcm9wZXJ0eU1hcCYmKGUucHJvcGVydHlNYXA9bmV3IHNuKSxCbihlLnByb3BlcnR5TWFwLG4scikpLGV9ZnVuY3Rpb24gaDgoKXt9cCgxMzcsMSxqRixoOCksbC5zZXRQcm9wZXJ0eT1mdW5jdGlvbihuLHIpe3JldHVybiBRQyh0aGlzLG4scil9LGwuZ2V0QWxsUHJvcGVydGllcz1mdW5jdGlvbigpe3JldHVybiBEZ2UodGhpcyl9LGwuZ2V0UHJvcGVydHk9ZnVuY3Rpb24obil7cmV0dXJuIHcodGhpcyxuKX0sbC5oYXNQcm9wZXJ0eT1mdW5jdGlvbihuKXtyZXR1cm4gX3IodGhpcyxuKX0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLnByb3BlcnRpZXMiLCJNYXBQcm9wZXJ0eUhvbGRlciIsMTM3KTtmdW5jdGlvbiBGZ2UoZSxuLHIpe3ZhciB0LG8saSxzO2Zvcih0aGlzLnBvbHlzPW5ldyBRLG89MCx0PTAscz1uZXcgVChlKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTc2KSxyJiYkcm4oaSksZWUodGhpcy5wb2x5cyxpKSxvKz1pLnhTaXplLHQrPWkueVNpemU7dGhpcy5wb2x5cy5hcnJheS5sZW5ndGg+MCYmKGk9YShsZSh0aGlzLnBvbHlzLDApLDE3Niksbys9aS54U2l6ZSx0Kz1pLnlTaXplKSxvKj0yLHQqPTIsbj4xP289S3IoUy5NYXRoLmNlaWwobypuKSk6dD1LcihTLk1hdGguY2VpbCh0L24pKSx0aGlzLmdyaWQ9bmV3IGxVKG8sdCl9cCgxMzE4LDEzNyxqRixGZ2UpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnBvbHlvbWluby5zdHJ1Y3R1cmVzIiwiUG9seW9taW5vZXMiLDEzMTgpO2Z1bmN0aW9uIHpnZShlLG4pe3VVPW5ldyBxeCxIZ2U9bixfRT1lLGEoX0Uubm9kZSw2OCksc1UoX0UsdVUsbnVsbCksJGdlKF9FKX1mdW5jdGlvbiAkZ2UoZSl7dmFyIG4scix0LG8saSxzO2Zvcih3aShlLmNoaWxkcmVuLG5ldyBVZ2UpLHI9bmV3IFQoZS5jaGlsZHJlbik7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDIyNSksdD1ydChDdChhKGUubm9kZSw2OCkudmVydGV4KSxhKG4ubm9kZSw2OCkudmVydGV4KSxIZ2U/KHM9YShlLm5vZGUsNjgpLnJlY3QsaT1hKG4ubm9kZSw2OCkucmVjdCxTLk1hdGguYWJzKHQueF8wKT49Uy5NYXRoLmFicyh0LnlfMCk/KHQueV8wPTAsaS55XzAraS5oZWlnaHQ+cy55XzAmJmkueV8wPHMueV8wK3MuaGVpZ2h0JiZYTih0LFMuTWF0aC5tYXgocy54XzAtKGkueF8wK2kud2lkdGhfMCksaS54XzAtKHMueF8wK3Mud2lkdGhfMCkpKSk6KHQueF8wPTAsaS54XzAraS53aWR0aF8wPnMueF8wJiZpLnhfMDxzLnhfMCtzLndpZHRoXzAmJlhOKHQsUy5NYXRoLm1heChzLnlfMC0oaS55XzAraS5oZWlnaHQpLGkueV8wLShzLnlfMCtzLmhlaWdodCkpKSkpOlhOKHQsVmdlKGEoZS5ub2RlLDY4KSxhKG4ubm9kZSw2OCkpKSxvPVMuTWF0aC5zcXJ0KHQueF8wKnQueF8wK3QueV8wKnQueV8wKSxvPUJnZShfRSxuLG8sdCksWE4odCxvKSxtOChhKG4ubm9kZSw2OCksdCksd2kobi5jaGlsZHJlbixuZXcgY1UodCkpLGEoX0Uubm9kZSw2OCksc1UoX0UsdVUsbil9ZnVuY3Rpb24gc1UoZSxuLHIpe2EoZS5ub2RlLDY4KSxhKGUubm9kZSw2OCksYShlLm5vZGUsNjgpLHdpKGUuY2hpbGRyZW4sbmV3IFdnZShyLG4sZSkpfWZ1bmN0aW9uIEJnZShlLG4scix0KXt2YXIgbyxpLHM7Zm9yKHM9Uy5NYXRoLm1pbihyLEdnZShhKGUubm9kZSw2OCksbixyLHQpKSxpPW5ldyBUKGUuY2hpbGRyZW4pO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwyMjUpLG8hPW4mJihzPVMuTWF0aC5taW4ocyxCZ2UobyxuLHMsdCkpKTtyZXR1cm4gc31mdW5jdGlvbiBsdG4oZSxuKXttOChhKG4ubm9kZSw2OCksZSksd2kobi5jaGlsZHJlbixuZXcgY1UoZSkpfWZ1bmN0aW9uIHN0bihlLG4scix0KXt0PT1lLGEoci5ub2RlLDY4KSxhKHIubm9kZSw2OCksYSh0Lm5vZGUsNjgpLGEodC5ub2RlLDY4KS52ZXJ0ZXgueV8wLHNVKHQsbixlKX1mdW5jdGlvbiBHZ2UoZSxuLHIsdCl7dmFyIG8saSxzLHU7Zm9yKHU9cixzPW5ldyBUKG4uY2hpbGRyZW4pO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoaT1hKEMocyksMjI1KSxvPWEoaS5ub2RlLDY4KSxTMShlLnJlY3QueF8wLG8ucmVjdC54XzArby5yZWN0LndpZHRoXzApPD0wJiZTMShvLnJlY3QueF8wLGUucmVjdC54XzArZS5yZWN0LndpZHRoXzApPD0wJiZTMShlLnJlY3QueV8wLG8ucmVjdC55XzArby5yZWN0LmhlaWdodCk8PTAmJlMxKG8ucmVjdC55XzAsZS5yZWN0LnlfMCtlLnJlY3QuaGVpZ2h0KTw9MCl7aWYoUzEoby5yZWN0LnhfMCxlLnJlY3QueF8wK2UucmVjdC53aWR0aF8wKT09MCYmdC54XzA8MHx8UzEoby5yZWN0LnhfMCtvLnJlY3Qud2lkdGhfMCxlLnJlY3QueF8wKT09MCYmdC54XzA+MHx8UzEoby5yZWN0LnlfMCxlLnJlY3QueV8wK2UucmVjdC5oZWlnaHQpPT0wJiZ0LnlfMDwwfHxTMShvLnJlY3QueV8wK28ucmVjdC5oZWlnaHQsZS5yZWN0LnlfMCk9PTAmJnQueV8wPjApe3U9MDticmVha319ZWxzZSB1PVMuTWF0aC5taW4odSxqZ2UoZSxvLHQpKTt1PVMuTWF0aC5taW4odSxHZ2UoZSxpLHUsdCkpfXJldHVybiB1fXZhciBIZ2U9ITEsX0UsdVU7ZnVuY3Rpb24gVWdlKCl7fXAoMTgyOCwxLEplLFVnZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7JGdlKGEobiwyMjUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uc3BvcmUiLCJEZXB0aEZpcnN0Q29tcGFjdGlvbi8wbWV0aG9kcmVmJGNvbXBhY3RUcmVlJFR5cGUiLDE4MjgpO2Z1bmN0aW9uIGNVKGUpe3RoaXMuY29tcGFjdGlvblZlY3Rvcl8wPWV9cCg4MjUsMSxKZSxjVSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7bHRuKHRoaXMuY29tcGFjdGlvblZlY3Rvcl8wLGEobiwyMjUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uc3BvcmUiLCJEZXB0aEZpcnN0Q29tcGFjdGlvbi9sYW1iZGEkMSRUeXBlIiw4MjUpO2Z1bmN0aW9uIFdnZShlLG4scil7dGhpcy5tYXJrXzA9ZSx0aGlzLnN2Z0ltYWdlXzE9bix0aGlzLnRfMj1yfXAoMTgyOSwxLEplLFdnZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7c3RuKHRoaXMubWFya18wLHRoaXMuc3ZnSW1hZ2VfMSx0aGlzLnRfMixhKG4sMjI1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnNwb3JlIiwiRGVwdGhGaXJzdENvbXBhY3Rpb24vbGFtYmRhJDIkVHlwZSIsMTgyOSk7ZnVuY3Rpb24gTHkoKXtMeT1GLGRFPW5ldyB2cigiZGVidWdTVkciLCh6ZSgpLCExKSksX1U9bmV3IHZyKCJvdmVybGFwc0V4aXN0ZWQiLCEwKX12YXIgZEUsX1U7ZnVuY3Rpb24gamdlKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7Zm9yKGM9aHIsaT1uZXcgVChaZ2UoZS5yZWN0KSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwxNzcpLHU9bmV3IFQoWmdlKG4ucmVjdCkpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxNzcpLHQ9UjJuKG8udSxvLnYscy51LHMudixyKSxjPVMuTWF0aC5taW4oYyx0KTtyZXR1cm4gY31mdW5jdGlvbiB1dG4oZSxuKXttOChlLHJ0KG5ldyBZKG4ueF8wLG4ueV8wKSxlLnZlcnRleCkpfWZ1bmN0aW9uIG04KGUsbil7S24oZS52ZXJ0ZXgsbiksZS5yZWN0LnhfMCs9bi54XzAsZS5yZWN0LnlfMCs9bi55XzB9ZnVuY3Rpb24gVmdlKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7cmV0dXJuIHQ9Uy5NYXRoLmFicyhxTihlLnJlY3QpLnhfMC1xTihuLnJlY3QpLnhfMCksdT1TLk1hdGguYWJzKHFOKGUucmVjdCkueV8wLXFOKG4ucmVjdCkueV8wKSxvPTAsYz0wLHI9MSxzPTEsdD5lLnJlY3Qud2lkdGhfMC8yK24ucmVjdC53aWR0aF8wLzImJihvPVMuTWF0aC5taW4oUy5NYXRoLmFicyhlLnJlY3QueF8wLShuLnJlY3QueF8wK24ucmVjdC53aWR0aF8wKSksUy5NYXRoLmFicyhlLnJlY3QueF8wK2UucmVjdC53aWR0aF8wLW4ucmVjdC54XzApKSxyPTEtby90KSx1PmUucmVjdC5oZWlnaHQvMituLnJlY3QuaGVpZ2h0LzImJihjPVMuTWF0aC5taW4oUy5NYXRoLmFicyhlLnJlY3QueV8wLShuLnJlY3QueV8wK24ucmVjdC5oZWlnaHQpKSxTLk1hdGguYWJzKGUucmVjdC55XzArZS5yZWN0LmhlaWdodC1uLnJlY3QueV8wKSkscz0xLWMvdSksaT1TLk1hdGgubWluKHIscyksKDEtaSkqUy5NYXRoLnNxcnQodCp0K3UqdSl9ZnVuY3Rpb24gcWdlKGUsbil7dGhpcy5vcmlnaW5hbFZlcnRleD1lLHRoaXMudmVydGV4PUN0KHRoaXMub3JpZ2luYWxWZXJ0ZXgpLHRoaXMucmVjdD1uZXcgWU4obil9cCg2OCwxLHs2ODoxfSxxZ2UpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnNwb3JlIiwiTm9kZSIsNjgpO2Z1bmN0aW9uIGN0bihlLG4pe3JldHVybiFlfHwhbnx8ZT09bj8hMTpTMShlLnJlY3QueF8wLG4ucmVjdC54XzArbi5yZWN0LndpZHRoXzApPDAmJlMxKG4ucmVjdC54XzAsZS5yZWN0LnhfMCtlLnJlY3Qud2lkdGhfMCk8MH1mdW5jdGlvbiBfdG4oZSxuKXt2YXIgcix0LG8saTtmb3IoaT1uZXcgUSx0PW5ldyBUKG4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw2OCksZWUoaSxuZXcgZFUociwhMCkpLGVlKGksbmV3IGRVKHIsITEpKTtvPW5ldyBLZ2UoZSksby5pbnRlcnZhbHNTb3J0TGVmdC5tYXBfMC5jbGVhcl8wKCksQWRlKGksZS5vdmVybGFwc1NjYW5saW5lQ29tcGFyYXRvcixuZXcgZWEoUChJKExkZSwxKSxNZSw2OTMsMCxbb10pKSl9ZnVuY3Rpb24gWWdlKGUpe3RoaXMub3ZlcmxhcHNTY2FubGluZUNvbXBhcmF0b3I9bmV3IEpnZSx0aGlzLm92ZXJsYXBIYW5kbGVyPWV9ZnVuY3Rpb24gZHRuKGUsbil7dmFyIHIsdCxvO2lmKHQ9ZS5ub2RlLnJlY3QueV8wLGUubG93fHwodCs9ZS5ub2RlLnJlY3QuaGVpZ2h0KSxvPW4ubm9kZS5yZWN0LnlfMCxuLmxvd3x8KG8rPW4ubm9kZS5yZWN0LmhlaWdodCkscj1pcih0LG8pLHI9PTApe2lmKCFlLmxvdyYmbi5sb3cpcmV0dXJuLTE7aWYoIW4ubG93JiZlLmxvdylyZXR1cm4gMX1yZXR1cm4gcn1wKDEyMTQsMSx7fSxZZ2UpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnNwb3JlIiwiU2NhbmxpbmVPdmVybGFwQ2hlY2siLDEyMTQpO2Z1bmN0aW9uIGZ0bihlLG4pe24ubG93P3B0bihlLG4pOlBrKGUuaW50ZXJ2YWxzU29ydExlZnQsbi5ub2RlKX1mdW5jdGlvbiBwdG4oZSxuKXt2YXIgcix0LG8saTtpZihpPUJDKGUuaW50ZXJ2YWxzU29ydExlZnQsbi5ub2RlKSwhaSl0aHJvdyBiKG5ldyBybygiSW52YWxpZCBoaXRib3hlcyBmb3Igc2NhbmxpbmUgb3ZlcmxhcCBjYWxjdWxhdGlvbi4iKSk7Zm9yKG89ITEsdD1lLmludGVydmFsc1NvcnRMZWZ0Lm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9YSh0Lm5leHRfMSgpLDY4KSxjdG4obi5ub2RlLHIpKVB3bihlLnRoaXMkMDEub3ZlcmxhcEhhbmRsZXIsbi5ub2RlLHIpLG89ITA7ZWxzZSBpZihvKWJyZWFrfWZ1bmN0aW9uIEtnZShlKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmludGVydmFsc1NvcnRMZWZ0PW5ldyBGYyhhKHZuKG5ldyBYZ2UpLDUwKSl9ZnVuY3Rpb24gZ3RuKGUsbil7dmFyIHI7cmV0dXJuIHI9aXIoZS5yZWN0LnhfMCxuLnJlY3QueF8wKSxyIT0wfHwocj1pcihlLm9yaWdpbmFsVmVydGV4LnhfMCxuLm9yaWdpbmFsVmVydGV4LnhfMCksciE9MCk/cjppcihlLm9yaWdpbmFsVmVydGV4LnlfMCxuLm9yaWdpbmFsVmVydGV4LnlfMCl9cCgxMjE1LDEsezY5MzoxfSxLZ2UpLGwuaGFuZGxlPWZ1bmN0aW9uKG4pe2Z0bih0aGlzLGEobiw0NTEpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uc3BvcmUiLCJTY2FubGluZU92ZXJsYXBDaGVjay9PdmVybGFwc1NjYW5saW5lSGFuZGxlciIsMTIxNSk7ZnVuY3Rpb24gWGdlKCl7fXAoMTIxNiwxLE5uLFhnZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gZ3RuKGEobiw2OCksYShyLDY4KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24uc3BvcmUiLCJTY2FubGluZU92ZXJsYXBDaGVjay9PdmVybGFwc1NjYW5saW5lSGFuZGxlci9sYW1iZGEkMCRUeXBlIiwxMjE2KTtmdW5jdGlvbiBkVShlLG4pe3RoaXMubm9kZT1lLHRoaXMubG93PW59cCg0NTEsMSx7NDUxOjF9LGRVKSxsLmxvdz0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi5zcG9yZSIsIlNjYW5saW5lT3ZlcmxhcENoZWNrL1RpbWVzdGFtcCIsNDUxKTtmdW5jdGlvbiBKZ2UoKXt9cCgxMjE3LDEsTm4sSmdlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBkdG4oYShuLDQ1MSksYShyLDQ1MSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuY29tbW9uLnNwb3JlIiwiU2NhbmxpbmVPdmVybGFwQ2hlY2svbGFtYmRhJDAkVHlwZSIsMTIxNyk7ZnVuY3Rpb24gcXgoKXt9cCg1NTcsMSx7fSxxeCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5jb21tb24udXRpbHMiLCJTVkdJbWFnZSIsNTU3KTtmdW5jdGlvbiBmVShlLG4scil7dGhpcy5maXJzdD1lLHRoaXMuc2Vjb25kPW4sdGhpcy50aGlyZD1yfXAoMzM0LDEsezMzNDoxfSxmVSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIigiK3RoaXMuZmlyc3QrIiwgIit0aGlzLnNlY29uZCsiLCAiK3RoaXMudGhpcmQrIikifSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmNvbW1vbi51dGlscyIsIlVuaXF1ZVRyaXBsZSIsMzM0KTtmdW5jdGlvbiBaZ2UoZSl7dmFyIG47cmV0dXJuIG49bmV3IFEsZWUobixuZXcgUGgobmV3IFkoZS54XzAsZS55XzApLG5ldyBZKGUueF8wK2Uud2lkdGhfMCxlLnlfMCkpKSxlZShuLG5ldyBQaChuZXcgWShlLnhfMCxlLnlfMCksbmV3IFkoZS54XzAsZS55XzArZS5oZWlnaHQpKSksZWUobixuZXcgUGgobmV3IFkoZS54XzArZS53aWR0aF8wLGUueV8wK2UuaGVpZ2h0KSxuZXcgWShlLnhfMCtlLndpZHRoXzAsZS55XzApKSksZWUobixuZXcgUGgobmV3IFkoZS54XzArZS53aWR0aF8wLGUueV8wK2UuaGVpZ2h0KSxuZXcgWShlLnhfMCxlLnlfMCtlLmhlaWdodCkpKSxufWZ1bmN0aW9uIFFnZShlLG4pe3ZhciByLHQsbyxpO3JldHVybiB0PVMuTWF0aC5taW4oUy5NYXRoLmFicyhlLnhfMC0obi54XzArbi53aWR0aF8wKSksUy5NYXRoLmFicyhlLnhfMCtlLndpZHRoXzAtbi54XzApKSxpPVMuTWF0aC5taW4oUy5NYXRoLmFicyhlLnlfMC0obi55XzArbi5oZWlnaHQpKSxTLk1hdGguYWJzKGUueV8wK2UuaGVpZ2h0LW4ueV8wKSkscj1TLk1hdGguYWJzKGUueF8wK2Uud2lkdGhfMC8yLShuLnhfMCtuLndpZHRoXzAvMikpLHI+ZS53aWR0aF8wLzIrbi53aWR0aF8wLzJ8fChvPVMuTWF0aC5hYnMoZS55XzArZS5oZWlnaHQvMi0obi55XzArbi5oZWlnaHQvMikpLG8+ZS5oZWlnaHQvMituLmhlaWdodC8yKT8xOnI9PTAmJm89PTA/MDpyPT0wP2kvbysxOm89PTA/dC9yKzE6Uy5NYXRoLm1pbih0L3IsaS9vKSsxfXAoMjA1LDEsZ18pLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlIiwiQWJzdHJhY3RMYXlvdXRQcm92aWRlciIsMjA1KTtmdW5jdGlvbiBlaGUoKXt9cCgxMTE0LDIwNSxnXyxlaGUpLGwubGF5b3V0PWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHM7c3dpdGNoKHIuYmVnaW4oIkNvbm5lY3RlZCBDb21wb25lbnRzIENvbXBhY3Rpb24iLDEpLHRoaXMuY29tcG9uZW50U3BhY2luZz1SKCQoVihuLChwRSgpLFNVKSkpKSxXcyhuLFM4KSYmKGk9eG4oVihuLFM4KSksdD1XTSh2dygpLGkpLHQmJihvPWEoWVQodC5wcm92aWRlclBvb2wpLDIwNSksby5sYXlvdXQobixyLnN1YlRhc2soMSkpKSkscz1uZXcgQmhlKHRoaXMuY29tcG9uZW50U3BhY2luZyksdGhpcy5yZXN1bHQ9VXRuKHMsbiksYShWKG4sKHY4KCkseVUpKSw0ODkpLm9yZGluYWwpe2Nhc2UgMDptdG4obmV3IG5oZSx0aGlzLnJlc3VsdCksbnIobixaeCx3KHRoaXMucmVzdWx0LFp4KSk7YnJlYWs7ZGVmYXVsdDpuYygpfUJ0bihzKSxucihuLEVVLHRoaXMucmVzdWx0KSxyLmRvbmVfMSgpfSxsLmNvbXBvbmVudFNwYWNpbmc9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvIiwiRGlzQ29MYXlvdXRQcm92aWRlciIsMTExNCk7ZnVuY3Rpb24gaHRuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3Iobz1Lcm4oZS5ncmlkKSxzPWEodyhlLmNtcEdyYXBoLChwRSgpLHZVKSksMTA3KSx1PXMubGVmdCtzLnJpZ2h0LGM9cy50b3BfMCtzLmJvdHRvbSxkPW8udGhpcmQudmFsdWVfMCplLmdyaWRDZWxsU2l6ZVgrdSxfPW8uZm91cnRoLnZhbHVlXzAqZS5ncmlkQ2VsbFNpemVZK2MseHRuKGUuY21wR3JhcGgsbmV3IFkoZCxfKSksaD1uZXcgVChlLnBvbHlzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksNTY4KSxuPWYueF8wLW8uZmlyc3QudmFsdWVfMCxyPWYueV8wLW8uc2Vjb25kLnZhbHVlXzAsdD1LbihVMm4obmV3IFkobixyKSxmLmNlbGxTaXplWCxmLmNlbGxTaXplWSkseXUoRnYoQ3QocFUoZi5yZXByZXNlbnRlZSkpLGYucFdpZHRoKmYuY2VsbFNpemVYLGYucEhlaWdodCpmLmNlbGxTaXplWSksLS41KSksaT1nVShmLnJlcHJlc2VudGVlKSxDdG4oZi5yZXByZXNlbnRlZSxydCh0LGkpKX1mdW5jdGlvbiBtdG4oZSxuKXt2YXIgcjtlLmNtcEdyYXBoPW4sZS5wb2x5cz1uZXcgUSxyPXl0bihlLmNtcEdyYXBoKSxlLmdyaWRDZWxsU2l6ZVg9cixlLmdyaWRDZWxsU2l6ZVk9cixlLmZpbGw9YWUoaWUodyhlLmNtcEdyYXBoLChOeCgpLG1IKSkpKSxlLmFzcGVjdFJhdGlvPSQodyhlLmNtcEdyYXBoLChGbigpLFNnKSkpLGUuYXNwZWN0UmF0aW89PW51bGwmJihlLmFzcGVjdFJhdGlvPTEpLFIoZS5hc3BlY3RSYXRpbyk+MT9lLmdyaWRDZWxsU2l6ZVgqPVIoZS5hc3BlY3RSYXRpbyk6ZS5ncmlkQ2VsbFNpemVZLz1SKGUuYXNwZWN0UmF0aW8pLHd0bihlKSxFdG4oZSksaHRuKGUpLGooZS5jbXBHcmFwaCwocEUoKSxaeCksZS5wb2x5cyl9ZnVuY3Rpb24geXRuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGQ9MCxfPTAsbz1lLmNvbXBvbmVudHMsdT1vLm1hcF8wLnNpemVfMSgpLHQ9by5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSw1NjcpLG49KHIuY2hhbmdlZCYmeTgociksci5ib3VuZHMpLGY9bi54XzAscz1uLnlfMCxkKz1mK3MsXys9ZipzO3JldHVybiBjPVMuTWF0aC5zcXJ0KDQwMCp1Kl8tNCpfK2QqZCkrZCxpPTIqKDEwMCp1LTEpLGk9PTA/YzpjL2l9ZnVuY3Rpb24gd3RuKGUpe3ZhciBuLHIsdCxvO2Zvcih0PWUuY21wR3JhcGguY29tcG9uZW50cyxyPXQubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspbj1hKHIubmV4dF8xKCksNTY3KSxvPW5ldyBUaGUobixlLmdyaWRDZWxsU2l6ZVgsZS5ncmlkQ2VsbFNpemVZKSxlZShlLnBvbHlzLG8pfWZ1bmN0aW9uIEV0bihlKXt2YXIgbixyO2ZvcihuPW5ldyBUKGUucG9seXMpO24uaTxuLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylhKEMobiksNTY4KTtyPW5ldyBGZ2UoZS5wb2x5cyxSKGUuYXNwZWN0UmF0aW8pLGUuZmlsbCksa3JuKHIpLGUucG9seXM9ci5wb2x5cyxlLmdyaWQ9ci5ncmlkfWZ1bmN0aW9uIG5oZSgpe31wKDEyMDgsMSx7fSxuaGUpLGwuZmlsbD0hMSxsLmdyaWRDZWxsU2l6ZVg9MCxsLmdyaWRDZWxsU2l6ZVk9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvIiwiRGlzQ29Qb2x5b21pbm9Db21wYWN0b3IiLDEyMDgpO2Z1bmN0aW9uIHZ0bihlLG4pe3ZhciByLHQ7Zm9yKHQ9bi5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMjcyKSxlLmNoYW5nZWQ9ITAsWXIoZS5zaGFwZXMsciksci5jcD1lfWZ1bmN0aW9uIHBVKGUpe3JldHVybiBlLmNoYW5nZWQmJnk4KGUpLGUuYm91bmRzfWZ1bmN0aW9uIGdVKGUpe3JldHVybiBlLmNoYW5nZWQmJnk4KGUpLGUubWluQ29ybmVyT2ZCb3VuZGluZ1JlY3RhbmdsZX1mdW5jdGlvbiBTdG4oZSxuKXt2YXIgcix0O2Zvcih0PWUuc2hhcGVzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9YSh0Lm5leHRfMSgpLDI3MiksRjJuKG4sci5zaGFwZV8wKXx8TTJuKG4sci5zaGFwZV8wKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBDdG4oZSxuKXtlLmNoYW5nZWQ9ITAsZS5vZmZzZXQ9bn1mdW5jdGlvbiB5OChlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKGUuY2hhbmdlZD0hMSxmPWhyLGM9VnIsaD1ocixfPVZyLHQ9ZS5zaGFwZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspZm9yKHI9YSh0Lm5leHRfMSgpLDI3Miksbz1yLmJvdW5kcyxmPVMuTWF0aC5taW4oZixvLnhfMCksYz1TLk1hdGgubWF4KGMsby54XzArby53aWR0aF8wKSxoPVMuTWF0aC5taW4oaCxvLnlfMCksXz1TLk1hdGgubWF4KF8sby55XzArby5oZWlnaHQpLHM9bmV3IFQoci5leHRlbnNpb25zKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksNDA3KSxuPWkuZGlyZWN0aW9uLG4uaG9yaXpvbnRhbD8oZD1vLnlfMCtpLm9mZnNldC55XzAsdT1kK2kud2lkdGhfMCxoPVMuTWF0aC5taW4oaCxkKSxfPVMuTWF0aC5tYXgoXyx1KSk6KGQ9by54XzAraS5vZmZzZXQueF8wLHU9ZCtpLndpZHRoXzAsZj1TLk1hdGgubWluKGYsZCksYz1TLk1hdGgubWF4KGMsdSkpO2UuYm91bmRzPW5ldyBZKGMtZixfLWgpLGUubWluQ29ybmVyT2ZCb3VuZGluZ1JlY3RhbmdsZT1uZXcgWShmK2Uub2Zmc2V0LnhfMCxoK2Uub2Zmc2V0LnlfMCl9ZnVuY3Rpb24gcmhlKCl7dGhpcy5vZmZzZXQ9bmV3IFkoMCwwKSx0aGlzLnNoYXBlcz1uZXcgQnJ9cCg1NjcsMSx7NTY3OjF9LHJoZSksbC5jaGFuZ2VkPSEwLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28uZ3JhcGgiLCJEQ0NvbXBvbmVudCIsNTY3KTtmdW5jdGlvbiBmRSgpe2ZFPUYsZTM9bmV3IFl4KCJOT1JUSCIsMCksS3g9bmV3IFl4KCJFQVNUIiwxKSxYeD1uZXcgWXgoIlNPVVRIIiwyKSxuMz1uZXcgWXgoIldFU1QiLDMpLGUzLmhvcml6b250YWw9ITEsS3guaG9yaXpvbnRhbD0hMCxYeC5ob3Jpem9udGFsPSExLG4zLmhvcml6b250YWw9ITB9ZnVuY3Rpb24gWXgoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBUdG4oZSl7cmV0dXJuIGZFKCksd24oKG9oZSgpLGloZSksZSl9ZnVuY3Rpb24gYnRuKCl7cmV0dXJuIGZFKCksUChJKHRoZSwxKSxXLDQwNiwwLFtlMyxLeCxYeCxuM10pfXAoNDA2LDIyLHszOjEsMzQ6MSwyMjoxLDQwNjoxfSxZeCksbC5ob3Jpem9udGFsPSExO3ZhciBLeCxlMyxYeCxuMyx0aGU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28uZ3JhcGgiLCJEQ0RpcmVjdGlvbiIsNDA2LGduLGJ0bixUdG4pO2Z1bmN0aW9uIG9oZSgpe29oZT1GLGloZT15bigoZkUoKSxQKEkodGhlLDEpLFcsNDA2LDAsW2UzLEt4LFh4LG4zXSkpKX12YXIgaWhlO2Z1bmN0aW9uIHc4KGUpe3ZhciBuLHIsdCxvLGkscztmb3IodGhpcy5leHRlbnNpb25zPW5ldyBRLHRoaXMuc2hhcGVfMD1lLHQ9aHIsbz1ocixuPVZyLHI9VnIscz1kbihlLDApO3MuY3VycmVudE5vZGUhPXMudGhpcyQwMS50YWlsOylpPWEodW4ocyksOCksdD1TLk1hdGgubWluKHQsaS54XzApLG89Uy5NYXRoLm1pbihvLGkueV8wKSxuPVMuTWF0aC5tYXgobixpLnhfMCkscj1TLk1hdGgubWF4KHIsaS55XzApO3RoaXMuYm91bmRzPW5ldyB0bCh0LG8sbi10LHItbyl9cCgyNzIsMTM3LHszOjEsMjcyOjEsOTY6MSwxMzc6MX0sdzgpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28uZ3JhcGgiLCJEQ0VsZW1lbnQiLDI3Mik7ZnVuY3Rpb24gSXRuKGUsbil7ZS5vZmZzZXQ9bn1mdW5jdGlvbiBoVShlLG4scix0KXt2YXIgbyxpO3RoaXMuZGlyZWN0aW9uPW4sdGhpcy53aWR0aF8wPXQsbz1lLmJvdW5kcyxJdG4odGhpcyxuZXcgWSgtby54XzAsLW8ueV8wKSksS24odGhpcy5vZmZzZXQsciksaT10LzIsbi5ob3Jpem9udGFsP0Z2KHRoaXMub2Zmc2V0LDAsaSk6RnYodGhpcy5vZmZzZXQsaSwwKSxlZShlLmV4dGVuc2lvbnMsdGhpcyl9cCg0MDcsMSx7NDA3OjF9LGhVKSxsLndpZHRoXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLmdyYXBoIiwiRENFeHRlbnNpb24iLDQwNyk7ZnVuY3Rpb24geHRuKGUsbil7ZS5kaW1lbnNpb25zPW59ZnVuY3Rpb24gUHRuKGUpe3ZhciBuLHIsdDtmb3IodGhpcy5jb21wb25lbnRzPW5ldyBsdSx0PW5ldyBUKGUpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxNiksbj1uZXcgcmhlLHZ0bihuLHIpLFlyKHRoaXMuY29tcG9uZW50cyxuKX1mdW5jdGlvbiBhaGUoZSl7UHRuLmNhbGwodGhpcyxlKX1wKDc2MiwxMzcsakYsYWhlKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLmdyYXBoIiwiRENHcmFwaCIsNzYyKTtmdW5jdGlvbiBKeCgpe0p4PUYsRTg9bmV3IGxoZX1mdW5jdGlvbiBsaGUoKXttbi5jYWxsKHRoaXMsIlBPTFlPTUlOTyIsMCl9ZnVuY3Rpb24gTnRuKGUpe3JldHVybiBKeCgpLHduKChzaGUoKSx1aGUpLGUpfWZ1bmN0aW9uIEF0bigpe3JldHVybiBKeCgpLFAoSShtVSwxKSxXLDQ4OSwwLFtFOF0pfXAoNDg5LDIyLHszOjEsMzQ6MSwyMjoxLDQ4OToxfSxsaGUpO3ZhciBFOCxtVT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5kaXNjby5vcHRpb25zIiwiQ29tcGFjdGlvblN0cmF0ZWd5Iiw0ODksZ24sQXRuLE50bik7ZnVuY3Rpb24gc2hlKCl7c2hlPUYsdWhlPXluKChKeCgpLFAoSShtVSwxKSxXLDQ4OSwwLFtFOF0pKSl9dmFyIHVoZTtmdW5jdGlvbiB2OCgpe3Y4PUYsd1U9KEp4KCksRTgpLHlVPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmRpc2NvLmNvbXBvbmVudENvbXBhY3Rpb24uc3RyYXRlZ3kiLHdVKSxfaGU9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsuZGlzY28uY29tcG9uZW50Q29tcGFjdGlvbi5jb21wb25lbnRMYXlvdXRBbGdvcml0aG0iKSxkaGU9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsuZGlzY28uZGVidWcuZGlzY29HcmFwaCIpLGZoZT1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5kaXNjby5kZWJ1Zy5kaXNjb1BvbHlzIil9ZnVuY3Rpb24gY2hlKCl7djgoKX1wKDg2NSwxLHBsLGNoZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe19lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvLmNvbXBvbmVudENvbXBhY3Rpb24uc3RyYXRlZ3kiKSwiY29tcG9uZW50Q29tcGFjdGlvbiIpLCJDb25uZWN0ZWQgQ29tcG9uZW50cyBDb21wYWN0aW9uIFN0cmF0ZWd5IiksIlN0cmF0ZWd5IGZvciBwYWNraW5nIGRpZmZlcmVudCBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiBvcmRlciB0byBzYXZlIHNwYWNlIGFuZCBlbmhhbmNlIHJlYWRhYmlsaXR5IG9mIGEgZ3JhcGguIiksd1UpLChKYygpLG1yKSksbVUpLEVlKChocygpLE9lKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZGlzY28uY29tcG9uZW50Q29tcGFjdGlvbi5jb21wb25lbnRMYXlvdXRBbGdvcml0aG0iKSwiY29tcG9uZW50Q29tcGFjdGlvbiIpLCJDb25uZWN0ZWQgQ29tcG9uZW50cyBMYXlvdXQgQWxnb3JpdGhtIiksIkEgbGF5b3V0IGFsZ29yaXRobSB0aGF0IGlzIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBjb25uZWN0ZWQgY29tcG9uZW50IGJlZm9yZSB0aGUgY29tcG9uZW50cyB0aGVtc2VsdmVzIGFyZSBjb21wYWN0ZWQuIElmIHVuc3BlY2lmaWVkLCB0aGUgcG9zaXRpb25zIG9mIHRoZSBjb21wb25lbnRzJyBub2RlcyBhcmUgbm90IGFsdGVyZWQuIiksd2cpLHNlKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZGlzY28uZGVidWcuZGlzY29HcmFwaCIpLCJkZWJ1ZyIpLCJEQ0dyYXBoIiksIkFjY2VzcyB0byB0aGUgRENHcmFwaCBpcyBpbnRlbmRlZCBmb3IgdGhlIGRlYnVnIHZpZXcsIiksenMpLFFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZGlzY28uZGVidWcuZGlzY29Qb2x5cyIpLCJkZWJ1ZyIpLCJMaXN0IG9mIFBvbHlvbWlub2VzIiksIkFjY2VzcyB0byB0aGUgcG9seW9taW5vZXMgaXMgaW50ZW5kZWQgZm9yIHRoZSBkZWJ1ZyB2aWV3LCIpLHpzKSxRciksRWUoT2UpKSkpLHBoZSgobmV3IGdoZSxuKSl9O3ZhciBfaGUseVUsd1UsZGhlLGZoZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLm9wdGlvbnMiLCJEaXNDb01ldGFEYXRhUHJvdmlkZXIiLDg2NSk7ZnVuY3Rpb24gcEUoKXtwRT1GLFNVPShGbigpLCRRKSxDOD13USxoaGU9U2csdlU9WmMsRWhlPShOeCgpLEVIKSx3aGU9eUgsdmhlPVNILHloZT1tSCxtaGU9KHY4KCkseVUpLFM4PV9oZSxFVT1kaGUsWng9ZmhlfWZ1bmN0aW9uIHBoZShlKXtoZChlLG5ldyBKXyhnZChkZChwZChmZChuZXcgWl8sIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIpLCJFTEsgRGlzQ28iKSwiTGF5b3V0ZXIgZm9yIGFycmFuZ2luZyB1bmNvbm5lY3RlZCBzdWJncmFwaHMuIFRoZSBzdWJncmFwaHMgdGhlbXNlbHZlcyBhcmUsIGJ5IGRlZmF1bHQsIG5vdCBsYWlkIG91dC4iKSxuZXcgU2hlKSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuY29tcG9uZW50Q29tcG9uZW50Iix0ZShTVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLmVkZ2UudGhpY2tuZXNzIix0ZShDOCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLmFzcGVjdFJhdGlvIix0ZShoaGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIsIm9yZy5lY2xpcHNlLmVsay5wYWRkaW5nIix0ZSh2VSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby5sb3dMZXZlbFNvcnQiLHRlKEVoZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby5oaWdoTGV2ZWxTb3J0Iix0ZSh3aGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIsIm9yZy5lY2xpcHNlLmVsay5wb2x5b21pbm8udHJhdmVyc2FsU3RyYXRlZ3kiLHRlKHZoZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLnBvbHlvbWluby5maWxsIix0ZSh5aGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIsIm9yZy5lY2xpcHNlLmVsay5kaXNjby5jb21wb25lbnRDb21wYWN0aW9uLnN0cmF0ZWd5Iix0ZShtaGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIsIm9yZy5lY2xpcHNlLmVsay5kaXNjby5jb21wb25lbnRDb21wYWN0aW9uLmNvbXBvbmVudExheW91dEFsZ29yaXRobSIsdGUoUzgpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5kaXNjbyIsIm9yZy5lY2xpcHNlLmVsay5kaXNjby5kZWJ1Zy5kaXNjb0dyYXBoIix0ZShFVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmRpc2NvIiwib3JnLmVjbGlwc2UuZWxrLmRpc2NvLmRlYnVnLmRpc2NvUG9seXMiLHRlKFp4KSl9ZnVuY3Rpb24gZ2hlKCl7cEUoKX1wKDEwMTAsMSxwbCxnaGUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtwaGUobil9O3ZhciBoaGUsUzgsbWhlLEVVLFp4LEM4LHZVLHloZSx3aGUsRWhlLHZoZSxTVTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLm9wdGlvbnMiLCJEaXNDb09wdGlvbnMiLDEwMTApO2Z1bmN0aW9uIFNoZSgpe31wKDEwMTEsMSx7fSxTaGUpLGwuY3JlYXRlXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgZWhlLG59LGwuZGVzdHJveT1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28ub3B0aW9ucyIsIkRpc0NvT3B0aW9ucy9EaXNjb0ZhY3RvcnkiLDEwMTEpO2Z1bmN0aW9uIEx0bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEE7Zm9yKF89bi5leHRlbnNpb25zLG89Z1UoZS5yZXByZXNlbnRlZSksZj15dShGdihDdChwVShlLnJlcHJlc2VudGVlKSksZS5wV2lkdGgqZS5jZWxsU2l6ZVgsZS5wSGVpZ2h0KmUuY2VsbFNpemVZKSwtLjUpLHI9by54XzAtZi54XzAsdD1vLnlfMC1mLnlfMCxzPW4uYm91bmRzLHI9cy54XzAtcix0PXMueV8wLXQsYz1uZXcgVChfKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe3N3aXRjaCh1PWEoQyhjKSw0MDcpLGg9dS5vZmZzZXQsbT1yK2gueF8wLHY9dCtoLnlfMCx5PUtyKG0vZS5jZWxsU2l6ZVgpLHg9S3Iodi9lLmNlbGxTaXplWSksaT11LmRpcmVjdGlvbixpLm9yZGluYWwpe2Nhc2UgMDpkPShOaCgpLFhDKTticmVhaztjYXNlIDE6ZD0oTmgoKSxLQyk7YnJlYWs7Y2FzZSAyOmQ9KE5oKCksSkMpO2JyZWFrO2RlZmF1bHQ6ZD0oTmgoKSxaQyl9aS5ob3Jpem9udGFsPyhBPUtyKCh2K3Uud2lkdGhfMCkvZS5jZWxsU2l6ZVkpLGVlKGUucG9seW9taW5vRXh0ZW5zaW9ucyxuZXcgZlUoZCxKKHgpLEooQSkpKSxpPT0oZkUoKSxuMyk/QXkoZSwwLHgseSxBKTpBeShlLHkseCxlLnBXaWR0aC0xLEEpKTooRT1LcigobSt1LndpZHRoXzApL2UuY2VsbFNpemVYKSxlZShlLnBvbHlvbWlub0V4dGVuc2lvbnMsbmV3IGZVKGQsSih5KSxKKEUpKSksaT09KGZFKCksZTMpP0F5KGUseSwwLEUseCk6QXkoZSx5LHgsRSxlLnBIZWlnaHQtMSkpfX1mdW5jdGlvbiBDaGUoZSxuKXt2YXIgcix0O3JldHVybiByPWUvbix0PUtyKHIpLHI+dCYmKyt0LHR9ZnVuY3Rpb24ga3RuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihyPWdVKGUucmVwcmVzZW50ZWUpLGk9eXUoRnYoQ3QocFUoZS5yZXByZXNlbnRlZSkpLGUucFdpZHRoKmUuY2VsbFNpemVYLGUucEhlaWdodCplLmNlbGxTaXplWSksLS41KSxuPXIueF8wLWkueF8wLG89ci55XzAtaS55XzAsdT0wO3U8ZS5wSGVpZ2h0O3UrKyl7Zm9yKHQ9bixzPTA7czxlLnBXaWR0aDtzKyspU3RuKGUucmVwcmVzZW50ZWUsbmV3IHRsKHQsbyxlLmNlbGxTaXplWCxlLmNlbGxTaXplWSkpJiZWeChlLHMsdSwhMSwhMCksdCs9ZS5jZWxsU2l6ZVg7bys9ZS5jZWxsU2l6ZVl9fWZ1bmN0aW9uIFRoZShlLG4scil7dmFyIHQsbyxpO2ZvcihpdG4uY2FsbCh0aGlzLG5ldyBRKSx0aGlzLmNlbGxTaXplWD1uLHRoaXMuY2VsbFNpemVZPXIsdGhpcy5yZXByZXNlbnRlZT1lLHQ9KGUuY2hhbmdlZCYmeTgoZSksZS5ib3VuZHMpLHRoaXMucFdpZHRoPUNoZSh0LnhfMCx0aGlzLmNlbGxTaXplWCksdGhpcy5wSGVpZ2h0PUNoZSh0LnlfMCx0aGlzLmNlbGxTaXplWSksZXRuKHRoaXMsdGhpcy5wV2lkdGgsdGhpcy5wSGVpZ2h0KSxrdG4odGhpcyksaT10aGlzLnJlcHJlc2VudGVlLnNoYXBlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSwyNzIpLG8uZXh0ZW5zaW9ucy5hcnJheS5sZW5ndGg+MCYmTHRuKHRoaXMsbyl9cCg1NjgsMTc2LHszMzA6MSwxNzY6MSw1Njg6MX0sVGhlKSxsLmNlbGxTaXplWD0wLGwuY2VsbFNpemVZPTAsbC5wSGVpZ2h0PTAsbC5wV2lkdGg9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLnN0cnVjdHVyZXMiLCJEQ1BvbHlvbWlubyIsNTY4KTtmdW5jdGlvbiBBaCgpe0FoPUYsUXg9bmV3IFEsYjg9bmV3IHNuLFQ4PW5ldyBRfWZ1bmN0aW9uIGJoZShlLG4scil7dmFyIHQsbztmb3Iobz1uLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSw3NCksWXIoZSxhKHIuYXBwbHlfMCh0KSwyNykpfWZ1bmN0aW9uIE90bihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtmb3Iobj1uZXcgc24sYz1uZXcgWWUoZSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl7Zm9yKHU9YShlbihjKSwyNykscj1uZXcgQnIsQm4oYjgsdSxyKSxtPW5ldyBQaGUsbz1hKFRvKG5ldyBTZShudWxsLG5ldyBPMShuZXcgWGUoUWUob2IodSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSksVDFlKG0sbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSkpLDg1KSxiaGUocixhKG8uZ2V0XzMoKHplKCksITApKSwxNiksbmV3IE5oZSksdD1hKFRvKEpuKGEoby5nZXRfMyghMSksMTUpLnBhcmFsbGVsU3RyZWFtKCksbmV3IEFoZSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsW0NvXSkpKSwxNSkscz10Lml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylpPWEocy5uZXh0XzEoKSw3NCksaD1HQmUoaSksaCYmKF89YShfbyhqdChuLmhhc2hDb2RlTWFwLGgpKSwyMSksX3x8KF89eGhlKGgpLGRpKG4uaGFzaENvZGVNYXAsaCxfKSksZnQocixfKSk7Zm9yKG89YShUbyhuZXcgU2UobnVsbCxuZXcgTzEobmV3IFhlKFFlKEVjKHUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpLFQxZShtLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFtDb10pKSkpLDg1KSxiaGUocixhKG8uZ2V0XzMoITApLDE2KSxuZXcgTGhlKSx0PWEoVG8oSm4oYShvLmdldF8zKCExKSwxNSkucGFyYWxsZWxTdHJlYW0oKSxuZXcga2hlKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbQ29dKSkpLDE1KSxmPXQuaXRlcmF0b3JfMCgpO2YuaGFzTmV4dF8wKCk7KWQ9YShmLm5leHRfMSgpLDc0KSxoPUhCZShkKSxoJiYoXz1hKF9vKGp0KG4uaGFzaENvZGVNYXAsaCkpLDIxKSxffHwoXz14aGUoaCksZGkobi5oYXNoQ29kZU1hcCxoLF8pKSxmdChyLF8pKX19ZnVuY3Rpb24gSWhlKGUsbil7dmFyIHIsdCxvO2lmKGVlKFF4LGUpLG4uYWRkXzIoZSkscj1hKEtlKGI4LGUpLDIxKSxyKWZvcihvPXIuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDI3KSxmbyhReCx0LDApIT0tMXx8SWhlKHQsbil9ZnVuY3Rpb24geGhlKGUpe3ZhciBuLHIsdCxvO3JldHVybiBvPWpzKGUpLHI9bmV3IE9oZShvKSx0PW5ldyBNaGUobyksbj1uZXcgUSxxcihuLCghZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGUuaW5jb21pbmdFZGdlcykpLHFyKG4sKCFlLm91dGdvaW5nRWRnZXMmJihlLm91dGdvaW5nRWRnZXM9bmV3IExlKE1yLGUsNyw0KSksZS5vdXRnb2luZ0VkZ2VzKSksYShUbyhwbyhKbihuZXcgU2UobnVsbCxuZXcgeGUobiwxNikpLHIpLHQpLGxmKG5ldyB2aCxuZXcgU2gsbmV3IENoLG5ldyBUaCxQKEkob28sMSksVywxMDgsMCxbKHJhKCksc2YpLENvXSkpKSwyMSl9ZnVuY3Rpb24gTXRuKGUpe3JldHVybiBBaCgpLHlyKFd1KGUpKT09eXIoWjAoZSkpfWZ1bmN0aW9uIFJ0bihlKXtyZXR1cm4gQWgoKSxXdShlKT09eXIoWjAoZSkpfWZ1bmN0aW9uIER0bihlKXtyZXR1cm4gQWgoKSxaMChlKT09eXIoV3UoZSkpfWZ1bmN0aW9uIEZ0bihlLG4pe3JldHVybiBBaCgpLGU9PXlyKFd1KG4pKXx8ZT09eXIoWjAobikpfWZ1bmN0aW9uIHp0bihlLG4pe3JldHVybiBBaCgpLGU9PVd1KG4pP1owKG4pOld1KG4pfWZ1bmN0aW9uICR0bihlKXtBaCgpO3ZhciBuLHIsdCxvO2ZvcihReD1uZXcgUSxiOD1uZXcgc24sVDg9bmV3IFEsbj0oIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSxPdG4obiksbz1uZXcgWWUobik7by5jdXJzb3IhPW8udGhpcyQwMV8yLnNpemVfMSgpOyl0PWEoZW4obyksMjcpLGZvKFF4LHQsMCk9PS0xJiYocj1uZXcgUSxlZShUOCxyKSxJaGUodCxyKSk7cmV0dXJuIFQ4fXZhciBUOCxiOCxReDtmdW5jdGlvbiBDVShlKXtyZXR1cm4gTXRuKGEoZSw3NCkpfWZ1bmN0aW9uIFBoZSgpe31wKDEyODYsMSxJbixQaGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBDVShuKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5kaXNjby50cmFuc2Zvcm0iLCJFbGtHcmFwaENvbXBvbmVudHNQcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTI4Nik7ZnVuY3Rpb24gTmhlKCl7fXAoMTI4NywxLHt9LE5oZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBBaCgpLFd1KGEobiw3NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLnRyYW5zZm9ybSIsIkVsa0dyYXBoQ29tcG9uZW50c1Byb2Nlc3Nvci9sYW1iZGEkMSRUeXBlIiwxMjg3KTtmdW5jdGlvbiBBaGUoKXt9cCgxMjg4LDEsSW4sQWhlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gUnRuKGEobiw3NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLnRyYW5zZm9ybSIsIkVsa0dyYXBoQ29tcG9uZW50c1Byb2Nlc3Nvci9sYW1iZGEkMiRUeXBlIiwxMjg4KTtmdW5jdGlvbiBMaGUoKXt9cCgxMjg5LDEse30sTGhlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEFoKCksWjAoYShuLDc0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28udHJhbnNmb3JtIiwiRWxrR3JhcGhDb21wb25lbnRzUHJvY2Vzc29yL2xhbWJkYSQzJFR5cGUiLDEyODkpO2Z1bmN0aW9uIGtoZSgpe31wKDEyOTAsMSxJbixraGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBEdG4oYShuLDc0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZGlzY28udHJhbnNmb3JtIiwiRWxrR3JhcGhDb21wb25lbnRzUHJvY2Vzc29yL2xhbWJkYSQ0JFR5cGUiLDEyOTApO2Z1bmN0aW9uIE9oZShlKXt0aGlzLnBvcnRQYXJlbnRfMD1lfXAoMTI5MSwxLEluLE9oZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEZ0bih0aGlzLnBvcnRQYXJlbnRfMCxhKG4sNzQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5kaXNjby50cmFuc2Zvcm0iLCJFbGtHcmFwaENvbXBvbmVudHNQcm9jZXNzb3IvbGFtYmRhJDUkVHlwZSIsMTI5MSk7ZnVuY3Rpb24gTWhlKGUpe3RoaXMucG9ydFBhcmVudF8wPWV9cCgxMjkyLDEse30sTWhlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHp0bih0aGlzLnBvcnRQYXJlbnRfMCxhKG4sNzQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5kaXNjby50cmFuc2Zvcm0iLCJFbGtHcmFwaENvbXBvbmVudHNQcm9jZXNzb3IvbGFtYmRhJDYkVHlwZSIsMTI5Mik7ZnVuY3Rpb24gUmhlKGUsbixyKXt2YXIgdCxvO3N3aXRjaCh0PShybihuLnNpemVfMCE9MCksYShaYShuLG4uaGVhZGVyLm5leHRfMCksOCkpLHIub3JkaW5hbCl7Y2FzZSAwOnQueV8wPTA7YnJlYWs7Y2FzZSAyOnQueV8wPWUuaGVpZ2h0O2JyZWFrO2Nhc2UgMzp0LnhfMD0wO2JyZWFrO2RlZmF1bHQ6dC54XzA9ZS53aWR0aF8wfXJldHVybiBvPWRuKG4sMCksUkMobyx0KSxufWZ1bmN0aW9uIERoZShlLG4scil7ci5ob3Jpem9udGFsP1RpKGUsbi55XzAtZS5oZWlnaHQvMik6Q2koZSxuLnhfMC1lLndpZHRoXzAvMil9ZnVuY3Rpb24gQnRuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lO2ZvcihpPWUudHJhbnNmb3JtZWRHcmFwaC5kaW1lbnNpb25zLGg9aS54XzAsZD1pLnlfMCx5PWUucGFyZW50XzAud2lkdGhfMCxtPWUucGFyZW50XzAuaGVpZ2h0LFJnKGUucGFyZW50XzAsaS54XzAsaS55XzApLHE9aC95LG5lPWQvbSxfPW5ldyBZZShNQShlLnBhcmVudF8wKSk7Xy5jdXJzb3IhPV8udGhpcyQwMV8yLnNpemVfMSgpOyljPWEoZW4oXyksMTM1KSxDaShjLGMueF8wKnEpLFRpKGMsYy55XzAqbmUpO2ZvcihBPW5ldyBZZShyRChlLnBhcmVudF8wKSk7QS5jdXJzb3IhPUEudGhpcyQwMV8yLnNpemVfMSgpOyl4PWEoZW4oQSksMTIzKSxNPXgueF8wLEg9eC55XzAsTT4wJiZDaSh4LE0qcSksSD4wJiZUaSh4LEgqbmUpO2ZvcihUMihlLmVsZW1lbnRNYXBwaW5nLG5ldyBHaGUpLG49bmV3IFEsdT1uZXcgTF8obmV3IEFfKGUuaW5jb21pbmdFeHRlbnNpb25zTWFwcGluZykudGhpcyQwMSk7dS5oYXNOZXh0OylzPU4xKHUpLHQ9YShzLmdldEtleSgpLDc0KSxyPWEocy5nZXRWYWx1ZSgpLDQwNykuZGlyZWN0aW9uLG89RmcodCwhMSwhMSksZj1SaGUoV3UodCkscVQobyksciksVlQoZixvKSxrPUdCZSh0KSxrJiZmbyhuLGssMCk9PS0xJiYoUmUobi5hcnJheSxrKSxEaGUoaywocm4oZi5zaXplXzAhPTApLGEoZi5oZWFkZXIubmV4dF8wLnZhbHVlXzAsOCkpLHIpKTtmb3Iodj1uZXcgTF8obmV3IEFfKGUub3V0Z29pbmdFeHRlbnNpb25zTWFwcGluZykudGhpcyQwMSk7di5oYXNOZXh0OylFPU4xKHYpLHQ9YShFLmdldEtleSgpLDc0KSxyPWEoRS5nZXRWYWx1ZSgpLDQwNykuZGlyZWN0aW9uLG89RmcodCwhMSwhMSksZj1SaGUoWjAodCksQ1QocVQobykpLHIpLGY9Q1QoZiksVlQoZixvKSxrPUhCZSh0KSxrJiZmbyhuLGssMCk9PS0xJiYoUmUobi5hcnJheSxrKSxEaGUoaywocm4oZi5zaXplXzAhPTApLGEoZi50YWlsLnByZXYudmFsdWVfMCw4KSkscikpfWZ1bmN0aW9uIEZoZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtyZXR1cm4gYz1lLnhfMCxtPWUueV8wLF89bi54XzAseT1uLnlfMCxkPXIueF8wLEU9ci55XzAsZj10LnhfMCx2PXQueV8wLGk9Yyp5LW0qXyxzPWQqdi1FKmYsbz0oYy1fKSooRS12KS0obS15KSooZC1mKSx1PShpKihkLWYpLXMqKGMtXykpL28saD0oaSooRS12KS1zKihtLXkpKS9vLG5ldyBZKHUsaCl9ZnVuY3Rpb24gemhlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7Zm9yKHQ9bmV3IFEsdT1uZXcgUSx2PW4vMixtPWUuc2l6ZV8xKCksbz1hKGUuZ2V0XzAoMCksOCkseD1hKGUuZ2V0XzAoMSksOCkseT1JOChvLnhfMCxvLnlfMCx4LnhfMCx4LnlfMCx2KSxlZSh0LChBZSgwLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMF0sOCkpKSxlZSh1LChBZSgxLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMV0sOCkpKSxfPTI7XzxtO18rKylFPW8sbz14LHg9YShlLmdldF8wKF8pLDgpLHk9STgoby54XzAsby55XzAsRS54XzAsRS55XzAsdiksZWUodCwoQWUoMSx5LmFycmF5Lmxlbmd0aCksYSh5LmFycmF5WzFdLDgpKSksZWUodSwoQWUoMCx5LmFycmF5Lmxlbmd0aCksYSh5LmFycmF5WzBdLDgpKSkseT1JOChvLnhfMCxvLnlfMCx4LnhfMCx4LnlfMCx2KSxlZSh0LChBZSgwLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMF0sOCkpKSxlZSh1LChBZSgxLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMV0sOCkpKTtmb3IoeT1JOCh4LnhfMCx4LnlfMCxvLnhfMCxvLnlfMCx2KSxlZSh0LChBZSgxLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMV0sOCkpKSxlZSh1LChBZSgwLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMF0sOCkpKSxyPW5ldyBqaSxzPW5ldyBRLExuKHIsKEFlKDAsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVswXSw4KSkpLGQ9MTtkPHQuYXJyYXkubGVuZ3RoLTI7ZCs9MilpPShBZShkLHQuYXJyYXkubGVuZ3RoKSxhKHQuYXJyYXlbZF0sOCkpLGg9RmhlKChBZShkLTEsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtkLTFdLDgpKSxpLChBZShkKzEsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtkKzFdLDgpKSwoQWUoZCsyLHQuYXJyYXkubGVuZ3RoKSxhKHQuYXJyYXlbZCsyXSw4KSkpLCFpc0Zpbml0ZShoLnhfMCl8fCFpc0Zpbml0ZShoLnlfMCk/YnIocixpLHIudGFpbC5wcmV2LHIudGFpbCk6YnIocixoLHIudGFpbC5wcmV2LHIudGFpbCk7Zm9yKExuKHIsYShsZSh0LHQuYXJyYXkubGVuZ3RoLTEpLDgpKSxlZShzLChBZSgwLHUuYXJyYXkubGVuZ3RoKSxhKHUuYXJyYXlbMF0sOCkpKSxmPTE7Zjx1LmFycmF5Lmxlbmd0aC0yO2YrPTIpaT0oQWUoZix1LmFycmF5Lmxlbmd0aCksYSh1LmFycmF5W2ZdLDgpKSxoPUZoZSgoQWUoZi0xLHUuYXJyYXkubGVuZ3RoKSxhKHUuYXJyYXlbZi0xXSw4KSksaSwoQWUoZisxLHUuYXJyYXkubGVuZ3RoKSxhKHUuYXJyYXlbZisxXSw4KSksKEFlKGYrMix1LmFycmF5Lmxlbmd0aCksYSh1LmFycmF5W2YrMl0sOCkpKSwhaXNGaW5pdGUoaC54XzApfHwhaXNGaW5pdGUoaC55XzApP1JlKHMuYXJyYXksaSk6UmUocy5hcnJheSxoKTtmb3IoZWUocyxhKGxlKHUsdS5hcnJheS5sZW5ndGgtMSksOCkpLGM9cy5hcnJheS5sZW5ndGgtMTtjPj0wO2MtLSlMbihyLChBZShjLHMuYXJyYXkubGVuZ3RoKSxhKHMuYXJyYXlbY10sOCkpKTtyZXR1cm4gcn1mdW5jdGlvbiBJOChlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbTtyZXR1cm4gcz1yLWUsdT10LW4saT1TLk1hdGguYXRhbjIocyx1KSxjPWkrZDYsXz1pLWQ2LGQ9bypTLk1hdGguc2luKGMpK2UsaD1vKlMuTWF0aC5jb3MoYykrbixmPW8qUy5NYXRoLnNpbihfKStlLG09bypTLk1hdGguY29zKF8pK24sVHMoUChJKG90LDEpLFgsOCwwLFtuZXcgWShkLGgpLG5ldyBZKGYsbSldKSl9ZnVuY3Rpb24gR3RuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGk9RmcobiwhMSwhMSksXz1xVChpKSxmPVIoJChWKG4sKHBFKCksQzgpKSkpLG89emhlKF8sZitlLmNvbXBvbmVudFNwYWNpbmcpLGQ9bmV3IHc4KG8pLGdvKGQsbiksQm4oZS5lbGVtZW50TWFwcGluZyxuLGQpLFJlKHIuYXJyYXksZCksYz0oIW4ubGFiZWxzJiYobi5sYWJlbHM9bmV3IFUoUXQsbiwxLDcpKSxuLmxhYmVscyksdT1uZXcgWWUoYyk7dS5jdXJzb3IhPXUudGhpcyQwMV8yLnNpemVfMSgpOylzPWEoZW4odSksMTM1KSx0PXIzKGUscywhMCwwLDApLFJlKHIuYXJyYXksdCk7cmV0dXJuIGR9ZnVuY3Rpb24gSHRuKGUsbixyKXt2YXIgdCxvLGk7Zm9yKGk9bi5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSw3NCksdD1hKEtlKGUuZWxlbWVudE1hcHBpbmcsbyksMjcyKSwhdCYmKHlyKFd1KG8pKT09eXIoWjAobykpP0d0bihlLG8scik6V3Uobyk9PXlyKFowKG8pKT9LZShlLmluY29taW5nRXh0ZW5zaW9uc01hcHBpbmcsbyk9PW51bGwmJktlKGUuZWxlbWVudE1hcHBpbmcsWjAobykpIT1udWxsJiYkaGUoZSxvLHIsITEpOktlKGUub3V0Z29pbmdFeHRlbnNpb25zTWFwcGluZyxvKT09bnVsbCYmS2UoZS5lbGVtZW50TWFwcGluZyxXdShvKSkhPW51bGwmJiRoZShlLG8sciwhMCkpfWZ1bmN0aW9uIHIzKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGY7aWYoIShMKG4sMjA3KXx8TChuLDM2Nil8fEwobiwxOTMpKSl0aHJvdyBiKG5ldyBHZSgiTWV0aG9kIG9ubHkgd29ya3MgZm9yIEVsa05vZGUtLCBFbGtMYWJlbCBhbmQgRWxrUG9ydC1vYmplY3RzLiIpKTtyZXR1cm4gcz1lLmNvbXBvbmVudFNwYWNpbmcvMixjPW4ueF8wK3QtcyxkPW4ueV8wK28tcyxfPWMrbi53aWR0aF8wK2UuY29tcG9uZW50U3BhY2luZyxmPWQrbi5oZWlnaHQrZS5jb21wb25lbnRTcGFjaW5nLGk9bmV3IGppLExuKGksbmV3IFkoYyxkKSksTG4oaSxuZXcgWShjLGYpKSxMbihpLG5ldyBZKF8sZikpLExuKGksbmV3IFkoXyxkKSksdT1uZXcgdzgoaSksZ28odSxuKSxyJiZCbihlLmVsZW1lbnRNYXBwaW5nLG4sdSksdX1mdW5jdGlvbiAkaGUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKHU9RmcobiwhMSwhMSkseD1xVCh1KSx0JiYoeD1DVCh4KSksaz1SKCQoVihuLChwRSgpLEM4KSkpKSx2PShybih4LnNpemVfMCE9MCksYSh4LmhlYWRlci5uZXh0XzAudmFsdWVfMCw4KSksZj1hKFZhKHgsMSksOCkseC5zaXplXzA+Mj8oZD1uZXcgUSxxcihkLG5ldyBPYyh4LDEseC5zaXplXzApKSxpPXpoZShkLGsrZS5jb21wb25lbnRTcGFjaW5nKSxBPW5ldyB3OChpKSxnbyhBLG4pLFJlKHIuYXJyYXksQSkpOnQ/QT1hKEtlKGUuZWxlbWVudE1hcHBpbmcsV3UobikpLDI3Mik6QT1hKEtlKGUuZWxlbWVudE1hcHBpbmcsWjAobikpLDI3MiksYz1XdShuKSx0JiYoYz1aMChuKSkscz1XdG4odixjKSxfPWsrZS5jb21wb25lbnRTcGFjaW5nLHMuaG9yaXpvbnRhbD8oXys9Uy5NYXRoLmFicyh2LnlfMC1mLnlfMCksRT1uZXcgWShmLnhfMCwoZi55XzArdi55XzApLzIpKTooXys9Uy5NYXRoLmFicyh2LnhfMC1mLnhfMCksRT1uZXcgWSgoZi54XzArdi54XzApLzIsZi55XzApKSx0P0JuKGUub3V0Z29pbmdFeHRlbnNpb25zTWFwcGluZyxuLG5ldyBoVShBLHMsRSxfKSk6Qm4oZS5pbmNvbWluZ0V4dGVuc2lvbnNNYXBwaW5nLG4sbmV3IGhVKEEscyxFLF8pKSxCbihlLmVsZW1lbnRNYXBwaW5nLG4sQSkseT0oIW4ubGFiZWxzJiYobi5sYWJlbHM9bmV3IFUoUXQsbiwxLDcpKSxuLmxhYmVscyksbT1uZXcgWWUoeSk7bS5jdXJzb3IhPW0udGhpcyQwMV8yLnNpemVfMSgpOyloPWEoZW4obSksMTM1KSxvPXIzKGUsaCwhMCwwLDApLFJlKHIuYXJyYXksbyl9ZnVuY3Rpb24gVXRuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lO2ZvcihlLnBhcmVudF8wPW4sdT0kdG4obikscT1uZXcgUSx0PW5ldyBUKHUpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHI9YShDKHQpLDE1KSxuZT1uZXcgUSxSZShxLmFycmF5LG5lKSxjPW5ldyBCcix5PXIuaXRlcmF0b3JfMCgpO3kuaGFzTmV4dF8wKCk7KXtmb3IobT1hKHkubmV4dF8xKCksMjcpLGk9cjMoZSxtLCEwLDAsMCksUmUobmUuYXJyYXksaSksRT1tLnhfMCx2PW0ueV8wLGg9KCFtLmxhYmVscyYmKG0ubGFiZWxzPW5ldyBVKFF0LG0sMSw3KSksbS5sYWJlbHMpLGY9bmV3IFllKGgpO2YuY3Vyc29yIT1mLnRoaXMkMDFfMi5zaXplXzEoKTspXz1hKGVuKGYpLDEzNSksbz1yMyhlLF8sITEsRSx2KSxSZShuZS5hcnJheSxvKTtmb3IoSD0oIW0ucG9ydHMmJihtLnBvcnRzPW5ldyBVKHVhLG0sOSw5KSksbS5wb3J0cyksQT1uZXcgWWUoSCk7QS5jdXJzb3IhPUEudGhpcyQwMV8yLnNpemVfMSgpOylmb3IoeD1hKGVuKEEpLDEyMykscz1yMyhlLHgsITEsRSx2KSxSZShuZS5hcnJheSxzKSxrPXgueF8wK0UsTT14LnlfMCt2LGg9KCF4LmxhYmVscyYmKHgubGFiZWxzPW5ldyBVKFF0LHgsMSw3KSkseC5sYWJlbHMpLGQ9bmV3IFllKGgpO2QuY3Vyc29yIT1kLnRoaXMkMDFfMi5zaXplXzEoKTspXz1hKGVuKGQpLDEzNSksbz1yMyhlLF8sITEsayxNKSxSZShuZS5hcnJheSxvKTtmdChjLENJKE5hKFAoSSh4YSwxKSxNZSwyMCwwLFtFYyhtKSxvYihtKV0pKSkpfUh0bihlLGMsbmUpfXJldHVybiBlLnRyYW5zZm9ybWVkR3JhcGg9bmV3IGFoZShxKSxnbyhlLnRyYW5zZm9ybWVkR3JhcGgsbiksZS50cmFuc2Zvcm1lZEdyYXBofWZ1bmN0aW9uIFd0bihlLG4pe3ZhciByLHQsbztyZXR1cm4gbz1tcCx0PShmRSgpLGUzKSxvPVMuTWF0aC5hYnMoZS55XzApLHI9Uy5NYXRoLmFicyhuLmhlaWdodC1lLnlfMCkscjxvJiYobz1yLHQ9WHgpLHI9Uy5NYXRoLmFicyhlLnhfMCkscjxvJiYobz1yLHQ9bjMpLHI9Uy5NYXRoLmFicyhuLndpZHRoXzAtZS54XzApLHI8byYmKG89cix0PUt4KSx0fWZ1bmN0aW9uIEJoZShlKXt0aGlzLmVsZW1lbnRNYXBwaW5nPW5ldyBzbix0aGlzLmluY29taW5nRXh0ZW5zaW9uc01hcHBpbmc9bmV3IHNuLHRoaXMub3V0Z29pbmdFeHRlbnNpb25zTWFwcGluZz1uZXcgc24sdGhpcy5jb21wb25lbnRTcGFjaW5nPWV9cCgxMjA1LDEse30sQmhlKSxsLmNvbXBvbmVudFNwYWNpbmc9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLnRyYW5zZm9ybSIsIkVsa0dyYXBoVHJhbnNmb3JtZXIiLDEyMDUpO2Z1bmN0aW9uIGp0bihlLG4scil7dmFyIHQsbyxpLHM7ZS5vZmZzZXQ9ci5jcC5vZmZzZXQsTChuLDMyNik/KG89RmcoYShuLDc0KSwhMSwhMSksaT1xVChvKSx0PW5ldyBIaGUoZSksRXQoaSx0KSxWVChpLG8pLG4uZ2V0UHJvcGVydHkoKEZuKCkseWQpKSE9bnVsbCYmRXQoYShuLmdldFByb3BlcnR5KHlkKSw3NSksdCkpOihzPWEobiw0MjIpLHMuc2V0WChzLmdldFgoKStlLm9mZnNldC54XzApLHMuc2V0WShzLmdldFkoKStlLm9mZnNldC55XzApKX1mdW5jdGlvbiBHaGUoKXt9cCgxMjA2LDEse30sR2hlKSxsLmFjY2VwdF8xPWZ1bmN0aW9uKG4scil7anRuKHRoaXMsYShuLDE2NyksYShyLDI3MikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmRpc2NvLnRyYW5zZm9ybSIsIkVsa0dyYXBoVHJhbnNmb3JtZXIvT2Zmc2V0QXBwbGllciIsMTIwNik7ZnVuY3Rpb24gVnRuKGUsbil7bWQobixlLnRoaXMkMTEub2Zmc2V0LnhfMCxlLnRoaXMkMTEub2Zmc2V0LnlfMCl9ZnVuY3Rpb24gSGhlKGUpe3RoaXMudGhpcyQxMT1lfXAoMTIwNywxLEplLEhoZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7VnRuKHRoaXMsYShuLDgpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5kaXNjby50cmFuc2Zvcm0iLCJFbGtHcmFwaFRyYW5zZm9ybWVyL09mZnNldEFwcGxpZXIvT2ZmU2V0VG9DaGFpbkFwcGxpZXIiLDEyMDcpO2Z1bmN0aW9uIHF0bihlKXt2YXIgbixyLHQsbyxpLHM7Zm9yKG89ZS5ub2Rlcy5hcnJheS5sZW5ndGgsdD1CKGphLFVkLDE1LG8sMCwxKSxzPW5ldyBUKGUubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxNTMpLHRbaS5pZF8wXT1uZXcgcHI7Zm9yKHI9bmV3IFQoZS5lZGdlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDI5MCksdFtuLnNvdXJjZS5pZF8wXS5hZGRfMihuKSx0W24udGFyZ2V0LmlkXzBdLmFkZF8yKG4pO3JldHVybiB0fWZ1bmN0aW9uIFRVKGUsbixyLHQsbyxpKXt2YXIgcyx1LGM7aWYoIW9bbi5pZF8wXSl7Zm9yKG9bbi5pZF8wXT0hMCxzPXQsIXMmJihzPW5ldyBlNCksZWUocy5ub2RlcyxuKSxjPWlbbi5pZF8wXS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMjkwKSwhKHUudGFyZ2V0PT1yfHx1LnNvdXJjZT09cikmJih1LnNvdXJjZSE9biYmVFUoZSx1LnNvdXJjZSxuLHMsbyxpKSx1LnRhcmdldCE9biYmVFUoZSx1LnRhcmdldCxuLHMsbyxpKSxlZShzLmVkZ2VzLHUpLHFyKHMubGFiZWxzLHUubGFiZWxzKSk7cmV0dXJuIHN9cmV0dXJuIG51bGx9ZnVuY3Rpb24gWXRuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaDtmb3IoYz1uZXcgWShyLHQpLHJ0KGMsYSh3KG4sKGswKCksZ0UpKSw4KSksaD1uZXcgVChuLm5vZGVzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksMTUzKSxLbihmLnBvc2l0aW9uLGMpLGVlKGUubm9kZXMsZik7Zm9yKHU9bmV3IFQobi5lZGdlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iocz1hKEModSksMjkwKSxpPW5ldyBUKHMuYmVuZHBvaW50cyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDI1MCksS24oby5wb3NpdGlvbixjKTtlZShlLmVkZ2VzLHMpfWZvcihkPW5ldyBUKG4ubGFiZWxzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspXz1hKEMoZCksNDU0KSxLbihfLnBvc2l0aW9uLGMpLGVlKGUubGFiZWxzLF8pfWZ1bmN0aW9uIFVoZShlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO2lmKGUuc2l6ZV8xKCk9PTEpcmV0dXJuIGEoZS5nZXRfMCgwKSwyMzUpO2lmKGUuc2l6ZV8xKCk8PTApcmV0dXJuIG5ldyBlNDtmb3Iobz1lLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl7Zm9yKHI9YShvLm5leHRfMSgpLDIzNSkseT0wLGQ9cW4sZj1xbixjPWJ0LF89YnQsbT1uZXcgVChyLm5vZGVzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaD1hKEMobSksMTUzKSx5Kz1hKHcoaCwoV2woKSxMaCkpLDE3KS52YWx1ZV8wLGQ9Uy5NYXRoLm1pbihkLGgucG9zaXRpb24ueF8wLWguc2l6ZV8wLnhfMC8yKSxmPVMuTWF0aC5taW4oZixoLnBvc2l0aW9uLnlfMC1oLnNpemVfMC55XzAvMiksYz1TLk1hdGgubWF4KGMsaC5wb3NpdGlvbi54XzAraC5zaXplXzAueF8wLzIpLF89Uy5NYXRoLm1heChfLGgucG9zaXRpb24ueV8wK2guc2l6ZV8wLnlfMC8yKTtqKHIsKFdsKCksTGgpLEooeSkpLGoociwoazAoKSxnRSksbmV3IFkoZCxmKSksaihyLHQzLG5ldyBZKGMsXykpfWZvcihOZSgpLGUuc29ydF8wKG5ldyBqaGUpLEU9bmV3IGU0LGdvKEUsYShlLmdldF8wKDApLDk2KSksdT0wLEE9MCxpPWUuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KXI9YShpLm5leHRfMSgpLDIzNSksdj1ydChDdChhKHcociwoazAoKSx0MykpLDgpKSxhKHcocixnRSksOCkpLHU9Uy5NYXRoLm1heCh1LHYueF8wKSxBKz12LnhfMCp2LnlfMDtmb3IodT1TLk1hdGgubWF4KHUsUy5NYXRoLnNxcnQoQSkqUigkKHcoRSwoV2woKSx5bWUpKSkpKSx4PVIoJCh3KEUsbzQpKSksaz0wLE09MCxzPTAsbj14LHQ9ZS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMjM1KSx2PXJ0KEN0KGEodyhyLChrMCgpLHQzKSksOCkpLGEodyhyLGdFKSw4KSksayt2LnhfMD51JiYoaz0wLE0rPXMreCxzPTApLFl0bihFLHIsayxNKSxuPVMuTWF0aC5tYXgobixrK3YueF8wKSxzPVMuTWF0aC5tYXgocyx2LnlfMCksays9di54XzAreDtyZXR1cm4gRX1mdW5jdGlvbiBXaGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZihkPWllKHcobiwoV2woKSx4bWUpKSksZD09bnVsbHx8KFZlKGQpLGQpKXtmb3IoZj1CKHlhLHh1LDI4LG4ubm9kZXMuYXJyYXkubGVuZ3RoLDE2LDEpLHM9cXRuKG4pLG89bmV3IHByLF89bmV3IFQobi5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKF8pLDE1Mykscj1UVShlLHUsbnVsbCxudWxsLGYscyksciYmKGdvKHIsbiksYnIobyxyLG8udGFpbC5wcmV2LG8udGFpbCkpO2lmKG8uc2l6ZV8wPjEpZm9yKHQ9ZG4obywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspZm9yKHI9YSh1bih0KSwyMzUpLGk9MCxjPW5ldyBUKHIubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxNTMpLHUuaWRfMD1pKys7cmV0dXJuIG99cmV0dXJuIFRzKFAoSShvb24sMSksZmllLDIzNSwwLFtuXSkpfWZ1bmN0aW9uIGJVKCl7fXAoNzYwLDEse30sYlUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UiLCJDb21wb25lbnRzUHJvY2Vzc29yIiw3NjApO2Z1bmN0aW9uIEt0bihlLG4pe3ZhciByLHQsbztyZXR1cm4gcj1hKHcobiwoV2woKSxMaCkpLDE3KS52YWx1ZV8wLWEodyhlLExoKSwxNykudmFsdWVfMCxyPT0wPyh0PXJ0KEN0KGEodyhlLChrMCgpLHQzKSksOCkpLGEodyhlLGdFKSw4KSksbz1ydChDdChhKHcobix0MyksOCkpLGEodyhuLGdFKSw4KSksaXIodC54XzAqdC55XzAsby54XzAqby55XzApKTpyfWZ1bmN0aW9uIGpoZSgpe31wKDExOTUsMSxObixqaGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEt0bihhKG4sMjM1KSxhKHIsMjM1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZSIsIkNvbXBvbmVudHNQcm9jZXNzb3IvMSIsMTE5NSk7ZnVuY3Rpb24gVmhlKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyO2ZvcihtPWEodyhlLChrMCgpLGtoKSksMjcpLGs9cW4sTT1xbix4PWJ0LEE9YnQscT1uZXcgVChlLm5vZGVzKTtxLmk8cS50aGlzJDAxLmFycmF5Lmxlbmd0aDspSD1hKEMocSksMTUzKSxGZT1ILnBvc2l0aW9uLG5uPUguc2l6ZV8wLGs9Uy5NYXRoLm1pbihrLEZlLnhfMC1ubi54XzAvMiksTT1TLk1hdGgubWluKE0sRmUueV8wLW5uLnlfMC8yKSx4PVMuTWF0aC5tYXgoeCxGZS54XzArbm4ueF8wLzIpLEE9Uy5NYXRoLm1heChBLEZlLnlfMCtubi55XzAvMik7Zm9yKHI9bmV3IFQoZS5iZW5kUG9pbnRzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMjUwKSxGZT1uLnBvc2l0aW9uLG5uPW4uc2l6ZV8wLGs9Uy5NYXRoLm1pbihrLEZlLnhfMC1ubi54XzAvMiksTT1TLk1hdGgubWluKE0sRmUueV8wLW5uLnlfMC8yKSx4PVMuTWF0aC5tYXgoeCxGZS54XzArbm4ueF8wLzIpLEE9Uy5NYXRoLm1heChBLEZlLnlfMCtubi55XzAvMik7Zm9yKERlPWEoVihtLChXbCgpLFRtZSkpLDEwNyksd2U9bmV3IFkoRGUubGVmdC1rLERlLnRvcF8wLU0pLF89bmV3IFQoZS5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDE1MyksdmU9dyhjLGtoKSxMKHZlLDIwNykmJihFPWEodmUsMjcpLG5lPUtuKG5ldyBSdChjLnBvc2l0aW9uKSx3ZSksX2woRSxuZS54XzAtRS53aWR0aF8wLzIsbmUueV8wLUUuaGVpZ2h0LzIpKTtmb3IoaT1uZXcgVChlLmVkZ2VzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMjkwKSxmPWEodyhvLGtoKSw3NCksaD1GZyhmLCEwLCEwKSxqbj1uZXcgUnQoUFUobykpLEtuKGpuLHdlKSxuYihoLGpuLnhfMCxqbi55XzApLHdpKG8uYmVuZHBvaW50cyxuZXcgWWhlKHdlLGgpKSx0PW5ldyBSdChOVShvKSksS24odCx3ZSksZWIoaCx0LnhfMCx0LnlfMCk7Zm9yKHU9bmV3IFQoZS5sYWJlbHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSw0NTQpLHk9YSh3KHMsa2gpLDEzNSksdj1LbihuZXcgUnQocy5wb3NpdGlvbiksd2UpLF9sKHksdi54XzAsdi55XzApO1NyPXgtaysoRGUubGVmdCtEZS5yaWdodCksZD1BLU0rKERlLnRvcF8wK0RlLmJvdHRvbSksYWUoaWUoVihtLChGbigpLFdmKSkpKXx8d2QobSxTcixkLCExLCEwKSxucihtLFRnLFNyLShEZS5sZWZ0K0RlLnJpZ2h0KSksbnIobSxDZyxkLShEZS50b3BfMCtEZS5ib3R0b20pKX1mdW5jdGlvbiBxaGUoZSl7dmFyIG4scjtyZXR1cm4gcj1uZXcgZTQsZ28ocixlKSxqKHIsKGswKCksa2gpLGUpLG49bmV3IHNuLEp0bihlLHIsbiksWHRuKGUscixuKSxyfWZ1bmN0aW9uIFh0bihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IoYz1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO2MuY3Vyc29yIT1jLnRoaXMkMDFfMi5zaXplXzEoKTspZm9yKHU9YShlbihjKSwyNyksbz1uZXcgWGUoUWUoRWModSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKG8pOyl7aWYodD1hKHRuKG8pLDc0KSwhdC5zb3VyY2VzJiYodC5zb3VyY2VzPW5ldyBMZShhbix0LDQsNykpLCEodC5zb3VyY2VzLnNpemVfMDw9MSYmKCF0LnRhcmdldHMmJih0LnRhcmdldHM9bmV3IExlKGFuLHQsNSw4KSksdC50YXJnZXRzLnNpemVfMDw9MSkpKXRocm93IGIobmV3IGVtKCJHcmFwaCBtdXN0IG5vdCBjb250YWluIGh5cGVyZWRnZXMuIikpO2lmKCFsUyh0KSYmdSE9eW8oYShPKCghdC50YXJnZXRzJiYodC50YXJnZXRzPW5ldyBMZShhbix0LDUsOCkpLHQudGFyZ2V0cyksMCksODQpKSlmb3IoXz1uZXcgWmhlLGdvKF8sdCksaihfLChrMCgpLGtoKSx0KSxub24oXyxhKF9vKGp0KHIuaGFzaENvZGVNYXAsdSkpLDE1MykpLHJvbihfLGEoS2Uocix5byhhKE8oKCF0LnRhcmdldHMmJih0LnRhcmdldHM9bmV3IExlKGFuLHQsNSw4KSksdC50YXJnZXRzKSwwKSw4NCkpKSwxNTMpKSxlZShuLmVkZ2VzLF8pLHM9bmV3IFllKCghdC5sYWJlbHMmJih0LmxhYmVscz1uZXcgVShRdCx0LDEsNykpLHQubGFiZWxzKSk7cy5jdXJzb3IhPXMudGhpcyQwMV8yLnNpemVfMSgpOylpPWEoZW4ocyksMTM1KSxkPW5ldyBlbWUoXyxpLnRleHRfMCksZ28oZCxpKSxqKGQsa2gsaSksZC5zaXplXzAueF8wPVMuTWF0aC5tYXgoaS53aWR0aF8wLDEpLGQuc2l6ZV8wLnlfMD1TLk1hdGgubWF4KGkuaGVpZ2h0LDEpLEFVKGQpLGVlKG4ubGFiZWxzLGQpfX1mdW5jdGlvbiBKdG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3IodD0wLGk9bmV3IFllKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pKTtpLmN1cnNvciE9aS50aGlzJDAxXzIuc2l6ZV8xKCk7KW89YShlbihpKSwyNykscz0iIiwoIW8ubGFiZWxzJiYoby5sYWJlbHM9bmV3IFUoUXQsbywxLDcpKSxvLmxhYmVscykuc2l6ZV8wPT0wfHwocz1hKE8oKCFvLmxhYmVscyYmKG8ubGFiZWxzPW5ldyBVKFF0LG8sMSw3KSksby5sYWJlbHMpLDApLDEzNSkudGV4dF8wKSx1PW5ldyBubWUocyksZ28odSxvKSxqKHUsKGswKCksa2gpLG8pLHUuaWRfMD10KyssdS5wb3NpdGlvbi54XzA9by54XzArby53aWR0aF8wLzIsdS5wb3NpdGlvbi55XzA9by55XzArby5oZWlnaHQvMix1LnNpemVfMC54XzA9Uy5NYXRoLm1heChvLndpZHRoXzAsMSksdS5zaXplXzAueV8wPVMuTWF0aC5tYXgoby5oZWlnaHQsMSksZWUobi5ub2Rlcyx1KSxkaShyLmhhc2hDb2RlTWFwLG8sdSksYz1hKFYobywoV2woKSxHVSkpLDEwMSksYz09KGR0KCkscTApJiYoYz1Icyl9ZnVuY3Rpb24gWnRuKGUsbixyKXt2YXIgdDt0PW5ldyBSdChyLnBvc2l0aW9uKSxLbih0LGUpLFVuZShuLHQueF8wLHQueV8wKX1mdW5jdGlvbiBZaGUoZSxuKXt0aGlzLm9mZnNldF8wPWUsdGhpcy5rZWRnZVNlY3Rpb25fMT1ufXAoMTE5NiwxLEplLFloZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7WnRuKHRoaXMub2Zmc2V0XzAsdGhpcy5rZWRnZVNlY3Rpb25fMSxhKG4sMjUwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UiLCJFbGtHcmFwaEltcG9ydGVyL2xhbWJkYSQwJFR5cGUiLDExOTYpO2Z1bmN0aW9uIEtoZShlLG4scil7dmFyIHQsbyxpLHMsdTtmb3Ioci5iZWdpbigiRUxLIEZvcmNlIiwxKSxhZShpZShWKG4sKFdsKCksJFUpKSkpfHxVQygodD1uZXcgYUUoKEVkKCksbmV3IHZkKG4pKSksdCkpLHU9cWhlKG4pLFF0bih1KSxlb24oZSxhKHcodSx6VSksNDMyKSkscz1XaGUoZS5jb21wb25lbnRzUHJvY2Vzc29yLHUpLGk9cy5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspbz1hKGkubmV4dF8xKCksMjM1KSxpb24oZS5mb3JjZU1vZGVsLG8sci5zdWJUYXNrKDEvcy5zaXplXzEoKSkpO3U9VWhlKHMpLFZoZSh1KSxyLmRvbmVfMSgpfWZ1bmN0aW9uIFF0bihlKXt2YXIgbixyO249YSh3KGUsKFdsKCksSW1lKSksMTcpLG4/KHI9bi52YWx1ZV8wLHI9PTA/aihlLChrMCgpLGk0KSxuZXcgcGspOmooZSwoazAoKSxpNCksbmV3IGF4KHIpKSk6aihlLChrMCgpLGk0KSxuZXcgYXgoMSkpfWZ1bmN0aW9uIGVvbihlLG4pe3N3aXRjaChuLm9yZGluYWwpe2Nhc2UgMDpMKGUuZm9yY2VNb2RlbCw2NDEpfHwoZS5mb3JjZU1vZGVsPW5ldyBvbWUpO2JyZWFrO2Nhc2UgMTpMKGUuZm9yY2VNb2RlbCw2NDIpfHwoZS5mb3JjZU1vZGVsPW5ldyBpbWUpfX1mdW5jdGlvbiBJVSgpe3RoaXMuY29tcG9uZW50c1Byb2Nlc3Nvcj1uZXcgYlV9cCg3MzgsMjA1LGdfLElVKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe0toZSh0aGlzLG4scil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UiLCJGb3JjZUxheW91dFByb3ZpZGVyIiw3MzgpO2Z1bmN0aW9uIHhVKCl7dGhpcy5kaXNwbGFjZW1lbnQ9bmV3IG10LHRoaXMucG9zaXRpb249bmV3IG10LHRoaXMuc2l6ZV8wPW5ldyBtdH1wKDMwOSwxMzcsezM6MSwzMDk6MSw5NjoxLDEzNzoxfSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5ncmFwaCIsIkZQYXJ0aWNsZSIsMzA5KTtmdW5jdGlvbiBYaGUoZSl7eFUuY2FsbCh0aGlzKSx0aGlzLmVkZ2U9ZSxlZShlLmJlbmRwb2ludHMsdGhpcyl9cCgyNTAsMzA5LHszOjEsMjUwOjEsMzA5OjEsOTY6MSwxMzc6MX0sWGhlKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lZGdlPyhuPWZvKHRoaXMuZWRnZS5iZW5kcG9pbnRzLHRoaXMsMCksbj49MD8iYiIrbisiWyIreDgodGhpcy5lZGdlKSsiXSI6ImJbIit4OCh0aGlzLmVkZ2UpKyJdIik6ImJfIitSMSh0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5ncmFwaCIsIkZCZW5kcG9pbnQiLDI1MCk7ZnVuY3Rpb24gSmhlKGUpe3ZhciBuLHIsdCxvLGkscyx1O2lmKHQ9ZS5iZW5kcG9pbnRzLmFycmF5Lmxlbmd0aCx0PjApZm9yKHM9ZS5zb3VyY2UucG9zaXRpb24sdT1lLnRhcmdldC5wb3NpdGlvbixvPXl1KHJ0KG5ldyBZKHUueF8wLHUueV8wKSxzKSwxLyh0KzEpKSxpPW5ldyBZKHMueF8wLHMueV8wKSxyPW5ldyBUKGUuYmVuZHBvaW50cyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDI1MCksbi5wb3NpdGlvbi54XzA9aS54XzArby54XzAsbi5wb3NpdGlvbi55XzA9aS55XzArby55XzAsS24oaSxvKX1mdW5jdGlvbiBQVShlKXt2YXIgbjtyZXR1cm4gbj1ydChDdChlLnRhcmdldC5wb3NpdGlvbiksZS5zb3VyY2UucG9zaXRpb24pLFN3KG4sZS5zb3VyY2Uuc2l6ZV8wLnhfMCxlLnNvdXJjZS5zaXplXzAueV8wKSxLbihuLGUuc291cmNlLnBvc2l0aW9uKX1mdW5jdGlvbiBOVShlKXt2YXIgbjtyZXR1cm4gbj1ydChDdChlLnNvdXJjZS5wb3NpdGlvbiksZS50YXJnZXQucG9zaXRpb24pLFN3KG4sZS50YXJnZXQuc2l6ZV8wLnhfMCxlLnRhcmdldC5zaXplXzAueV8wKSxLbihuLGUudGFyZ2V0LnBvc2l0aW9uKX1mdW5jdGlvbiBub24oZSxuKXtlLnNvdXJjZT1ufWZ1bmN0aW9uIHJvbihlLG4pe2UudGFyZ2V0PW59ZnVuY3Rpb24geDgoZSl7cmV0dXJuIGUuc291cmNlJiZlLnRhcmdldD9MVShlLnNvdXJjZSkrIi0+IitMVShlLnRhcmdldCk6ImVfIitSMShlKX1mdW5jdGlvbiBaaGUoKXt0aGlzLmJlbmRwb2ludHM9bmV3IFEsdGhpcy5sYWJlbHM9bmV3IFF9cCgyOTAsMTM3LHszOjEsMjkwOjEsOTY6MSwxMzc6MX0sWmhlKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4geDgodGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UuZ3JhcGgiLCJGRWRnZSIsMjkwKTtmdW5jdGlvbiB0b24oZSl7dmFyIG4scix0O2Zvcih0PWUubm9kZXMuYXJyYXkubGVuZ3RoLGUuYWRqYWNlbmN5PWJfKGhuLFtYLGtuXSxbNTMsMjhdLDE1LFt0LHRdLDIpLHI9bmV3IFQoZS5lZGdlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDI5MCksZS5hZGphY2VuY3lbbi5zb3VyY2UuaWRfMF1bbi50YXJnZXQuaWRfMF0rPWEodyhuLChXbCgpLExoKSksMTcpLnZhbHVlXzB9ZnVuY3Rpb24gUWhlKGUsbixyKXt2YXIgdCxvLGkscztyZXR1cm4gTChuLDE1MykmJkwociwxNTMpPyhpPWEobiwxNTMpLHM9YShyLDE1MyksZS5hZGphY2VuY3lbaS5pZF8wXVtzLmlkXzBdK2UuYWRqYWNlbmN5W3MuaWRfMF1baS5pZF8wXSk6TChuLDI1MCkmJkwociwyNTApJiYodD1hKG4sMjUwKSxvPWEociwyNTApLHQuZWRnZT09by5lZGdlKT9hKHcoby5lZGdlLChXbCgpLExoKSksMTcpLnZhbHVlXzA6MH1mdW5jdGlvbiBlNCgpe3RoaXMubm9kZXM9bmV3IFEsdGhpcy5lZGdlcz1uZXcgUSx0aGlzLmxhYmVscz1uZXcgUSx0aGlzLmJlbmRQb2ludHM9bmV3IFF9cCgyMzUsMTM3LHszOjEsMjM1OjEsOTY6MSwxMzc6MX0sZTQpO3ZhciBvb249Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5ncmFwaCIsIkZHcmFwaCIsMjM1KTtmdW5jdGlvbiBBVShlKXt2YXIgbixyLHQsbyxpLHMsdSxjO3I9YWUoaWUodyhlLChXbCgpLHdtZSkpKSksaT1lLmVkZ2Uuc291cmNlLnBvc2l0aW9uLHU9ZS5lZGdlLnRhcmdldC5wb3NpdGlvbixyPyhzPXl1KHJ0KG5ldyBZKHUueF8wLHUueV8wKSxpKSwuNSksYz15dShDdChlLnNpemVfMCksLjUpLG49cnQoS24obmV3IFkoaS54XzAsaS55XzApLHMpLGMpLG5RKGUucG9zaXRpb24sbikpOihvPVIoJCh3KGUuZWRnZSxQbWUpKSksdD1lLnBvc2l0aW9uLGkueF8wPj11LnhfMD9pLnlfMD49dS55XzA/KHQueF8wPXUueF8wKyhpLnhfMC11LnhfMCkvMitvLHQueV8wPXUueV8wKyhpLnlfMC11LnlfMCkvMi1vLWUuc2l6ZV8wLnlfMCk6KHQueF8wPXUueF8wKyhpLnhfMC11LnhfMCkvMitvLHQueV8wPWkueV8wKyh1LnlfMC1pLnlfMCkvMitvKTppLnlfMD49dS55XzA/KHQueF8wPWkueF8wKyh1LnhfMC1pLnhfMCkvMitvLHQueV8wPXUueV8wKyhpLnlfMC11LnlfMCkvMitvKToodC54XzA9aS54XzArKHUueF8wLWkueF8wKS8yK28sdC55XzA9aS55XzArKHUueV8wLWkueV8wKS8yLW8tZS5zaXplXzAueV8wKSl9ZnVuY3Rpb24gZW1lKGUsbil7eFUuY2FsbCh0aGlzKSx0aGlzLmVkZ2U9ZSx0aGlzLnRleHRfMD1uLGVlKHRoaXMuZWRnZS5sYWJlbHMsdGhpcyl9cCg0NTQsMzA5LHszOjEsNDU0OjEsMzA5OjEsOTY6MSwxMzc6MX0sZW1lKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50ZXh0XzA9PW51bGx8fHRoaXMudGV4dF8wLmxlbmd0aD09MD8ibFsiK3g4KHRoaXMuZWRnZSkrIl0iOiJsXyIrdGhpcy50ZXh0XzB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UuZ3JhcGgiLCJGTGFiZWwiLDQ1NCk7ZnVuY3Rpb24gTFUoZSl7cmV0dXJuIGUubGFiZWxfMD09bnVsbHx8ZS5sYWJlbF8wLmxlbmd0aD09MD8ibl8iK2UuaWRfMDoibl8iK2UubGFiZWxfMH1mdW5jdGlvbiBubWUoZSl7eFUuY2FsbCh0aGlzKSx0aGlzLmxhYmVsXzA9ZX1wKDE1MywzMDksezM6MSwxNTM6MSwzMDk6MSw5NjoxLDEzNzoxfSxubWUpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBMVSh0aGlzKX0sbC5pZF8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5ncmFwaCIsIkZOb2RlIiwxNTMpO2Z1bmN0aW9uIGtVKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2lmKGUuZ3JhcGhfMD1uLGUucmFuZG9tXzA9YSh3KG4sKGswKCksaTQpKSwyMzQpLHRvbihuKSxlLmRpc3BCb3VuZD1TLk1hdGgubWF4KG4ubm9kZXMuYXJyYXkubGVuZ3RoKjE2K24uZWRnZXMuYXJyYXkubGVuZ3RoLDI1NiksIWFlKGllKHcobiwoV2woKSxGVSkpKSkpZm9yKGQ9ZS5ncmFwaF8wLm5vZGVzLmFycmF5Lmxlbmd0aCxjPW5ldyBUKG4ubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxNTMpLF89dS5wb3NpdGlvbixfLnhfMD1oRyhlLnJhbmRvbV8wKSpkLF8ueV8wPWhHKGUucmFuZG9tXzApKmQ7Zm9yKHI9bi5iZW5kUG9pbnRzLGk9bmV3IFQobi5lZGdlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG89YShDKGkpLDI5MCksdD1hKHcobyxIVSksMTcpLnZhbHVlXzAsdD4wKXtmb3Iocz0wO3M8dDtzKyspZWUocixuZXcgWGhlKG8pKTtKaGUobyl9fWZ1bmN0aW9uIHJtZShlKXt2YXIgbixyLHQsbztmb3Iocj1uZXcgVChlLmdyYXBoXzAuZWRnZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKG49YShDKHIpLDI5MCksbz1uZXcgVChuLmxhYmVscyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDQ1NCksQVUodCk7SmhlKG4pfX1mdW5jdGlvbiBpb24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7Zm9yKHIuYmVnaW4oIkNvbXBvbmVudCBMYXlvdXQiLDEpLGUuaW5pdGlhbGl6ZShuKSxpPTA7ZS5tb3JlSXRlcmF0aW9ucyhpKSYmIXIuaXNDYW5jZWxlZCgpOyl7Zm9yKGUuaXRlcmF0aW9uRG9uZSgpLGQ9UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsW24ubm9kZXMsbi5sYWJlbHMsbi5iZW5kUG9pbnRzXSkpKTtfbihkKTspZm9yKGM9YSh0bihkKSwzMDkpLHU9UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsW24ubm9kZXMsbi5sYWJlbHMsbi5iZW5kUG9pbnRzXSkpKTtfbih1KTspcz1hKHRuKHUpLDMwOSkscyE9YyYmKG89ZS5jYWxjRGlzcGxhY2VtZW50KHMsYyksbyYmS24oYy5kaXNwbGFjZW1lbnQsbykpO2ZvcihfPVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFtuLm5vZGVzLG4ubGFiZWxzLG4uYmVuZFBvaW50c10pKSk7X24oXyk7KWM9YSh0bihfKSwzMDkpLHQ9Yy5kaXNwbGFjZW1lbnQsSURlKHQsLWUuZGlzcEJvdW5kLC1lLmRpc3BCb3VuZCxlLmRpc3BCb3VuZCxlLmRpc3BCb3VuZCksS24oYy5wb3NpdGlvbix0KSx0LnhfMD0wLHQueV8wPTA7KytpfXIuZG9uZV8xKCl9ZnVuY3Rpb24gdG1lKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaDtmb3Iocz1uLnBvc2l0aW9uLHU9ci5wb3NpdGlvbjtzLnhfMC11LnhfMD09MCYmcy55XzAtdS55XzA9PTA7KWM9ITEsTChuLDI1MCkmJkwociwyNTApJiYhYz8oXz1hKG4sMjUwKS5lZGdlLGQ9cnQobmV3IFJ0KE5VKF8pKSxQVShfKSksdD0yLG89bmV3IFkoZC54XzAvUy5NYXRoLnNxcnQoZC54XzAqZC54XzArZC55XzAqZC55XzApKnQsLWQueV8wL1MuTWF0aC5zcXJ0KGQueF8wKmQueF8wK2QueV8wKmQueV8wKSp0KSxLbihzLG8pLGY9YShyLDI1MCkuZWRnZSxoPXJ0KG5ldyBSdChOVShmKSksUFUoZikpLHQ9ZD09aD8tMjoyLGk9bmV3IFkoaC54XzAvUy5NYXRoLnNxcnQoaC54XzAqaC54XzAraC55XzAqaC55XzApKnQsLShoLnlfMC9TLk1hdGguc3FydChoLnhfMCpoLnhfMCtoLnlfMCpoLnlfMCkpKnQpLEtuKHMsaSksYz0hMCk6KHMueF8wKz1mYShlLDI2KSp3MitmYShlLDI3KSpFMi0uNSxzLnlfMCs9ZmEoZSwyNikqdzIrZmEoZSwyNykqRTItLjUsdS54XzArPWZhKGUsMjYpKncyK2ZhKGUsMjcpKkUyLS41LHUueV8wKz1mYShlLDI2KSp3MitmYShlLDI3KSpFMi0uNSl9cCgyMTAwLDEse30pLGwuaW5pdGlhbGl6ZT1mdW5jdGlvbihuKXtrVSh0aGlzLG4pfSxsLml0ZXJhdGlvbkRvbmU9ZnVuY3Rpb24oKXtybWUodGhpcyl9LGwuZGlzcEJvdW5kPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5tb2RlbCIsIkFic3RyYWN0Rm9yY2VNb2RlbCIsMjEwMCk7ZnVuY3Rpb24gb21lKCl7dGhpcy5tYXhJdGVyYXRpb25zPWEodGUoKFdsKCksdDQpKSwxNykudmFsdWVfMCx0aGlzLnNwcmluZ0xlbmd0aD1SKCQodGUobzQpKSksdGhpcy5yZXB1bHNpb25GYWN0b3I9UigkKHRlKE44KSkpfWZ1bmN0aW9uIGFvbihlLG4pe3JldHVybiBlPjA/Uy5NYXRoLmxvZyhlL24pOi0xMDB9ZnVuY3Rpb24gbG9uKGUsbil7cmV0dXJuIGU+MD9uLyhlKmUpOm4qMTAwfXAoNjQxLDIxMDAsezY0MToxfSxvbWUpLGwuY2FsY0Rpc3BsYWNlbWVudD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7cmV0dXJuIHRtZSh0aGlzLnJhbmRvbV8wLG4sciksaT1ydChDdChyLnBvc2l0aW9uKSxuLnBvc2l0aW9uKSx1PVMuTWF0aC5zcXJ0KGkueF8wKmkueF8wK2kueV8wKmkueV8wKSxvPVMuTWF0aC5tYXgoMCx1LUR2KG4uc2l6ZV8wKS8yLUR2KHIuc2l6ZV8wKS8yKSx0PVFoZSh0aGlzLmdyYXBoXzAsbixyKSx0PjA/cz0tYW9uKG8sdGhpcy5zcHJpbmdMZW5ndGgpKnQ6cz1sb24obyx0aGlzLnJlcHVsc2lvbkZhY3RvcikqYSh3KG4sKFdsKCksTGgpKSwxNykudmFsdWVfMCx5dShpLHMvdSksaX0sbC5pbml0aWFsaXplPWZ1bmN0aW9uKG4pe2tVKHRoaXMsbiksdGhpcy5tYXhJdGVyYXRpb25zPWEodyhuLChXbCgpLHQ0KSksMTcpLnZhbHVlXzAsdGhpcy5zcHJpbmdMZW5ndGg9UigkKHcobixvNCkpKSx0aGlzLnJlcHVsc2lvbkZhY3Rvcj1SKCQodyhuLE44KSkpfSxsLm1vcmVJdGVyYXRpb25zPWZ1bmN0aW9uKG4pe3JldHVybiBuPHRoaXMubWF4SXRlcmF0aW9uc30sbC5tYXhJdGVyYXRpb25zPTAsbC5yZXB1bHNpb25GYWN0b3I9MCxsLnNwcmluZ0xlbmd0aD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2UubW9kZWwiLCJFYWRlc01vZGVsIiw2NDEpO2Z1bmN0aW9uIGltZSgpe3RoaXMudGVtcGVyYXR1cmU9UigkKHRlKChXbCgpLEE4KSkpKX1mdW5jdGlvbiBzb24oZSxuKXtyZXR1cm4gZSplL259ZnVuY3Rpb24gdW9uKGUsbil7cmV0dXJuIGU+MD9uKm4vZTpuKm4qMTAwfXAoNjQyLDIxMDAsezY0MjoxfSxpbWUpLGwuY2FsY0Rpc3BsYWNlbWVudD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7cmV0dXJuIHRtZSh0aGlzLnJhbmRvbV8wLG4sciksaT1ydChDdChyLnBvc2l0aW9uKSxuLnBvc2l0aW9uKSx1PVMuTWF0aC5zcXJ0KGkueF8wKmkueF8wK2kueV8wKmkueV8wKSxvPVMuTWF0aC5tYXgoMCx1LUR2KG4uc2l6ZV8wKS8yLUR2KHIuc2l6ZV8wKS8yKSxzPXVvbihvLHRoaXMuaykqYSh3KG4sKFdsKCksTGgpKSwxNykudmFsdWVfMCx0PVFoZSh0aGlzLmdyYXBoXzAsbixyKSx0PjAmJihzLT1zb24obyx0aGlzLmspKnQpLHl1KGkscyp0aGlzLnRlbXBlcmF0dXJlL3UpLGl9LGwuaW5pdGlhbGl6ZT1mdW5jdGlvbihuKXt2YXIgcix0LG8saSxzLHUsYztmb3Ioa1UodGhpcyxuKSx0aGlzLnRlbXBlcmF0dXJlPVIoJCh3KG4sKFdsKCksQTgpKSkpLHRoaXMudGhyZXNob2xkPXRoaXMudGVtcGVyYXR1cmUvYSh3KG4sdDQpLDE3KS52YWx1ZV8wLG89bi5ub2Rlcy5hcnJheS5sZW5ndGgscz0wLGk9MCxjPW5ldyBUKG4ubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxNTMpLHMrPXUuc2l6ZV8wLnhfMCxpKz11LnNpemVfMC55XzA7cj1zKmksdD1SKCQodyhuLG80KSkpKkNzLHRoaXMuaz1TLk1hdGguc3FydChyLygyKm8pKSp0fSxsLml0ZXJhdGlvbkRvbmU9ZnVuY3Rpb24oKXtybWUodGhpcyksdGhpcy50ZW1wZXJhdHVyZS09dGhpcy50aHJlc2hvbGR9LGwubW9yZUl0ZXJhdGlvbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGVtcGVyYXR1cmU+MH0sbC5rPTAsbC50ZW1wZXJhdHVyZT0wLGwudGhyZXNob2xkPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5tb2RlbCIsIkZydWNodGVybWFuUmVpbmdvbGRNb2RlbCIsNjQyKTtmdW5jdGlvbiBPVSgpe09VPUYsTVU9KG40KCkscjQpLHNtZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5mb3JjZS5tb2RlbCIsTVUpLEooMSksbG1lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmZvcmNlLml0ZXJhdGlvbnMiLEooMzAwKSksSigwKSxfbWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UucmVwdWxzaXZlUG93ZXIiLEooMCkpLGRtZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5mb3JjZS50ZW1wZXJhdHVyZSIsWnMpLHVtZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5mb3JjZS5yZXB1bHNpb24iLDUpLGZtZT1yNCxjbWU9UDh9ZnVuY3Rpb24gYW1lKCl7T1UoKX1wKDg2MCwxLHBsLGFtZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe19lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLm1vZGVsIiksIiIpLCJGb3JjZSBNb2RlbCIpLCJEZXRlcm1pbmVzIHRoZSBtb2RlbCBmb3IgZm9yY2UgY2FsY3VsYXRpb24uIiksTVUpLChKYygpLG1yKSksRFUpLEVlKChocygpLE9lKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UuaXRlcmF0aW9ucyIpLCIiKSwiSXRlcmF0aW9ucyIpLCJUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb24gdGhlIGZvcmNlIG1vZGVsLiIpLEooMzAwKSksYm8pLHZ0KSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UucmVwdWxzaXZlUG93ZXIiKSwiIiksIlJlcHVsc2l2ZSBQb3dlciIpLCJEZXRlcm1pbmVzIGhvdyBtYW55IGJlbmQgcG9pbnRzIGFyZSBhZGRlZCB0byB0aGUgZWRnZTsgc3VjaCBiZW5kIHBvaW50cyBhcmUgcmVnYXJkZWQgYXMgcmVwZWxsaW5nIHBhcnRpY2xlcyBpbiB0aGUgZm9yY2UgbW9kZWwiKSxKKDApKSxibyksdnQpLEVlKG11KSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5mb3JjZS50ZW1wZXJhdHVyZSIpLCIiKSwiRlIgVGVtcGVyYXR1cmUiKSwiVGhlIHRlbXBlcmF0dXJlIGlzIHVzZWQgYXMgYSBzY2FsaW5nIGZhY3RvciBmb3IgcGFydGljbGUgZGlzcGxhY2VtZW50cy4iKSxacyksUHQpLCRyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLnRlbXBlcmF0dXJlIiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLm1vZGVsIixmbWUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLnJlcHVsc2lvbiIpLCIiKSwiRWFkZXMgUmVwdWxzaW9uIiksIkZhY3RvciBmb3IgcmVwdWxzaXZlIGZvcmNlcyBpbiBFYWRlcycgbW9kZWwuIiksNSksUHQpLCRyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLnJlcHVsc2lvbiIsIm9yZy5lY2xpcHNlLmVsay5mb3JjZS5tb2RlbCIsY21lKSxobWUoKG5ldyBtbWUsbikpfTt2YXIgbG1lLHNtZSxNVSx1bWUsY21lLF9tZSxkbWUsZm1lO2coIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uub3B0aW9ucyIsIkZvcmNlTWV0YURhdGFQcm92aWRlciIsODYwKTtmdW5jdGlvbiBuNCgpe240PUYsUDg9bmV3IFJVKCJFQURFUyIsMCkscjQ9bmV3IFJVKCJGUlVDSFRFUk1BTl9SRUlOR09MRCIsMSl9ZnVuY3Rpb24gUlUoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBjb24oZSl7cmV0dXJuIG40KCksd24oKHBtZSgpLGdtZSksZSl9ZnVuY3Rpb24gX29uKCl7cmV0dXJuIG40KCksUChJKERVLDEpLFcsNDMyLDAsW1A4LHI0XSl9cCg0MzIsMjIsezM6MSwzNDoxLDIyOjEsNDMyOjF9LFJVKTt2YXIgUDgscjQsRFU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uub3B0aW9ucyIsIkZvcmNlTW9kZWxTdHJhdGVneSIsNDMyLGduLF9vbixjb24pO2Z1bmN0aW9uIHBtZSgpe3BtZT1GLGdtZT15bigobjQoKSxQKEkoRFUsMSksVyw0MzIsMCxbUDgscjRdKSkpfXZhciBnbWU7ZnVuY3Rpb24gV2woKXtXbD1GLExoPW5ldyB5dCgoRm4oKSxMVCksSigxKSksbzQ9bmV3IHl0KHQxLDgwKSxQbWU9bmV3IHl0KEJRLDUpLHltZT1uZXcgeXQoU2csVW0pLEltZT1uZXcgeXQoZlIsSigxKSkseG1lPW5ldyB5dChwUiwoemUoKSwhMCkpLEJVPW5ldyBXMSg1MCksVG1lPW5ldyB5dChaYyxCVSksRlU9TlQsR1U9anYsd21lPW5ldyB5dCh0UiwhMSksJFU9QVQsU21lPVdmLENtZT1XMCx2bWU9cjEsRW1lPUlnLGJtZT1qZix6VT0oT1UoKSxzbWUpLEE4PWRtZSx0ND1sbWUsTjg9dW1lLEhVPV9tZSxMbWU9SXcsa21lPWlBLEFtZT1rVCxObWU9b0EsVVU9KHBtKCksS2YpLG5ldyB5dCh1bSxVVSl9ZnVuY3Rpb24gaG1lKGUpe2hkKGUsbmV3IEpfKGpaKGpOKGdkKGRkKHBkKGZkKG5ldyBaXywib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiksIkVMSyBGb3JjZSIpLCJGb3JjZS1iYXNlZCBhbGdvcml0aG0gcHJvdmlkZWQgYnkgdGhlIEVjbGlwc2UgTGF5b3V0IEtlcm5lbC4gSW1wbGVtZW50cyBtZXRob2RzIHRoYXQgZm9sbG93IHBoeXNpY2FsIGFuYWxvZ2llcyBieSBzaW11bGF0aW5nIGZvcmNlcyB0aGF0IG1vdmUgdGhlIG5vZGVzIGludG8gYSBiYWxhbmNlZCBkaXN0cmlidXRpb24uIEN1cnJlbnRseSB0aGUgb3JpZ2luYWwgRWFkZXMgbW9kZWwgYW5kIHRoZSBGcnVjaHRlcm1hbiAtIFJlaW5nb2xkIG1vZGVsIGFyZSBzdXBwb3J0ZWQuIiksbmV3IE9tZSksIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIpLGNyKChIdygpLFhBKSxQKEkoSkEsMSksVywyNDUsMCxbWUFdKSkpKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsucHJpb3JpdHkiLEooMSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZU5vZGUiLDgwKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmVkZ2VMYWJlbCIsNSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsuYXNwZWN0UmF0aW8iLFVtKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay5yYW5kb21TZWVkIixKKDEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay5zZXBhcmF0ZUNvbm5lY3RlZENvbXBvbmVudHMiLCh6ZSgpLCEwKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsucGFkZGluZyIsQlUpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLmludGVyYWN0aXZlIix0ZShGVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRDb25zdHJhaW50cyIsdGUoR1UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay5lZGdlTGFiZWxzLmlubGluZSIsITEpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLm9taXROb2RlTWljcm9MYXlvdXQiLHRlKCRVKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuZml4ZWRHcmFwaFNpemUiLHRlKFNtZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm9wdGlvbnMiLHRlKENtZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmNvbnN0cmFpbnRzIix0ZSh2bWUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay5ub2RlTGFiZWxzLnBsYWNlbWVudCIsdGUoRW1lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsucG9ydExhYmVscy5wbGFjZW1lbnQiLHRlKGJtZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLm1vZGVsIix0ZSh6VSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLnRlbXBlcmF0dXJlIix0ZShBOCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLml0ZXJhdGlvbnMiLHRlKHQ0KSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UucmVwdWxzaW9uIix0ZShOOCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLmZvcmNlLnJlcHVsc2l2ZVBvd2VyIix0ZShIVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd25MYXlvdXQiLHRlKExtZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2NhbGVGYWN0b3IiLHRlKGttZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZvcmNlIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uaGllcmFyY2hpY2FsTm9kZVdpZHRoIix0ZShBbWUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5mb3JjZSIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVBc3BlY3RSYXRpbyIsdGUoTm1lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5ub2RlVHlwZSIsVVUpfWZ1bmN0aW9uIG1tZSgpe1dsKCl9cChiYywxLHBsLG1tZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe2htZShuKX07dmFyIHltZSx3bWUsRlUsdDQselUsRW1lLHZtZSxTbWUsQ21lLCRVLFRtZSxCVSxHVSxibWUsTGgsSW1lLE44LEhVLHhtZSxQbWUsbzQsQTgsTm1lLEFtZSxMbWUsVVUsa21lO2coIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uub3B0aW9ucyIsIkZvcmNlT3B0aW9ucyIsYmMpO2Z1bmN0aW9uIE9tZSgpe31wKDEwMDEsMSx7fSxPbWUpLGwuY3JlYXRlXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgSVUsbn0sbC5kZXN0cm95PWZ1bmN0aW9uKG4pe30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5vcHRpb25zIiwiRm9yY2VPcHRpb25zL0ZvcmNlRmFjdG9yeSIsMTAwMSk7ZnVuY3Rpb24gazAoKXtrMD1GLGtoPW5ldyB0cigib3JpZ2luIiksaTQ9bmV3IHRyKCJyYW5kb20iKSxnRT1uZXcgdHIoImJvdW5kaW5nQm94LnVwTGVmdCIpLHQzPW5ldyB0cigiYm91bmRpbmdCb3gubG93UmlnaHQiKX12YXIgdDMsZ0Usa2gsaTQ7ZnVuY3Rpb24gV1UoKXtXVT1GLHptZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MuZml4ZWQiLCh6ZSgpLCExKSksUm1lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnN0cmVzcy5kZXNpcmVkRWRnZUxlbmd0aCIsMTAwKSxqVT0oaEUoKSxPOCksRG1lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnN0cmVzcy5kaW1lbnNpb24iLGpVKSxGbWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLmVwc2lsb24iLFpzKSwkbWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLml0ZXJhdGlvbkxpbWl0IixKKHFuKSl9ZnVuY3Rpb24gTW1lKCl7V1UoKX1wKDg2MSwxLHBsLE1tZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe19lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcy5maXhlZCIpLCIiKSwiRml4ZWQgUG9zaXRpb24iKSwiUHJldmVudCB0aGF0IHRoZSBub2RlIGlzIG1vdmVkIGJ5IHRoZSBsYXlvdXQgYWxnb3JpdGhtLiIpLCh6ZSgpLCExKSksKEpjKCksbnQpKSxBciksRWUoKGhzKCksSnIpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MuZGVzaXJlZEVkZ2VMZW5ndGgiKSwiIiksIkRlc2lyZWQgRWRnZSBMZW5ndGgiKSwiRWl0aGVyIHNwZWNpZmllZCBmb3IgcGFyZW50IG5vZGVzIG9yIGZvciBpbmRpdmlkdWFsIGVkZ2VzLCB3aGVyZSB0aGUgbGF0dGVyIHRha2VzIGhpZ2hlciBwcmVjZWRlbmNlLiIpLDEwMCksUHQpLCRyKSxjcihPZSxQKEkoenUsMSksVywxNzAsMCxbbXVdKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLmRpbWVuc2lvbiIpLCIiKSwiTGF5b3V0IERpbWVuc2lvbiIpLCJEaW1lbnNpb25zIHRoYXQgYXJlIHBlcm1pdHRlZCB0byBiZSBhbHRlcmVkIGR1cmluZyBsYXlvdXQuIiksalUpLG1yKSxaVSksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcy5lcHNpbG9uIiksIiIpLCJTdHJlc3MgRXBzaWxvbiIpLCJUZXJtaW5hdGlvbiBjcml0ZXJpb24gZm9yIHRoZSBpdGVyYXRpdmUgcHJvY2Vzcy4iKSxacyksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLml0ZXJhdGlvbkxpbWl0IiksIiIpLCJJdGVyYXRpb24gTGltaXQiKSwiTWF4aW11bSBudW1iZXIgb2YgcGVyZm9ybWVkIGl0ZXJhdGlvbnMuIFRha2VzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gJ2Vwc2lsb24nLiIpLEoocW4pKSxibyksdnQpLEVlKE9lKSkpKSxCbWUoKG5ldyBHbWUsbikpfTt2YXIgUm1lLERtZSxqVSxGbWUsem1lLCRtZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmZvcmNlLm9wdGlvbnMiLCJTdHJlc3NNZXRhRGF0YVByb3ZpZGVyIiw4NjEpO2Z1bmN0aW9uIG8zKCl7bzM9RixLVT0oRm4oKSxOVCksbmV3IHl0KHRSLCh6ZSgpLCEwKSksVW1lPXIxLFdtZT14ZyxqbWU9VzAsSG1lPUlnLEpVPUFULFZtZT1qZixZVT0oV1UoKSx6bWUpLFZVPURtZSxxVT1GbWUsWFU9JG1lLGE0PVJtZX1mdW5jdGlvbiBCbWUoZSl7aGQoZSxuZXcgSl8oak4oZ2QoZGQocGQoZmQobmV3IFpfLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzIiksIkVMSyBTdHJlc3MiKSwiTWluaW1pemVzIHRoZSBzdHJlc3Mgd2l0aGluIGEgbGF5b3V0IHVzaW5nIHN0cmVzcyBtYWpvcml6YXRpb24uIFN0cmVzcyBleGlzdHMgaWYgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIGEgcGFpciBvZiBub2RlcyBkb2Vzbid0IG1hdGNoIHRoZWlyIGdyYXBoIHRoZW9yZXRpYyBkaXN0YW5jZSwgdGhhdCBpcywgdGhlIHNob3J0ZXN0IHBhdGggYmV0d2VlbiB0aGUgdHdvIG5vZGVzLiBUaGUgbWV0aG9kIGFsbG93cyB0byBzcGVjaWZ5IGluZGl2aWR1YWwgZWRnZSBsZW5ndGhzLiIpLG5ldyBxbWUpLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiKSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcyIsIm9yZy5lY2xpcHNlLmVsay5pbnRlcmFjdGl2ZSIsdGUoS1UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MiLCJvcmcuZWNsaXBzZS5lbGsuZWRnZUxhYmVscy5pbmxpbmUiLCh6ZSgpLCEwKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmNvbnN0cmFpbnRzIix0ZShVbWUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUubWluaW11bSIsdGUoV21lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm9wdGlvbnMiLHRlKGptZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcyIsIm9yZy5lY2xpcHNlLmVsay5ub2RlTGFiZWxzLnBsYWNlbWVudCIsdGUoSG1lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzIiwib3JnLmVjbGlwc2UuZWxrLm9taXROb2RlTWljcm9MYXlvdXQiLHRlKEpVKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMucGxhY2VtZW50Iix0ZShWbWUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MiLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLmZpeGVkIix0ZShZVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcyIsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MuZGltZW5zaW9uIix0ZShWVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcyIsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MuZXBzaWxvbiIsdGUocVUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MiLCJvcmcuZWNsaXBzZS5lbGsuc3RyZXNzLml0ZXJhdGlvbkxpbWl0Iix0ZShYVSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnN0cmVzcyIsIm9yZy5lY2xpcHNlLmVsay5zdHJlc3MuZGVzaXJlZEVkZ2VMZW5ndGgiLHRlKGE0KSl9ZnVuY3Rpb24gR21lKCl7bzMoKX1wKDEwMDQsMSxwbCxHbWUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtCbWUobil9O3ZhciBhNCxWVSxxVSxZVSxLVSxYVSxIbWUsVW1lLFdtZSxqbWUsSlUsVm1lO2coIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uub3B0aW9ucyIsIlN0cmVzc09wdGlvbnMiLDEwMDQpO2Z1bmN0aW9uIHFtZSgpe31wKDEwMDUsMSx7fSxxbWUpLGwuY3JlYXRlXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgWW1lLG59LGwuZGVzdHJveT1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uub3B0aW9ucyIsIlN0cmVzc09wdGlvbnMvU3RyZXNzRmFjdG9yeSIsMTAwNSk7ZnVuY3Rpb24gWW1lKCl7dGhpcy5jb21wb25lbnRzUHJvY2Vzc29yPW5ldyBiVSx0aGlzLnN0cmVzc01ham9yaXphdGlvbj1uZXcgSm1lfXAoMTExMCwyMDUsZ18sWW1lKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKHIuYmVnaW4oIkVMSyBTdHJlc3MiLDEpLGFlKGllKFYobiwobzMoKSxLVSkpKSk/YWUoaWUoVihuLEpVKSkpfHxVQygodD1uZXcgYUUoKEVkKCksbmV3IHZkKG4pKSksdCkpOktoZShuZXcgSVUsbixyLnN1YlRhc2soMSkpLGk9cWhlKG4pLG89V2hlKHRoaXMuY29tcG9uZW50c1Byb2Nlc3NvcixpKSx1PW8uaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDIzNSksIShzLm5vZGVzLmFycmF5Lmxlbmd0aDw9MSkmJihtb24odGhpcy5zdHJlc3NNYWpvcml6YXRpb24scyksZ29uKHRoaXMuc3RyZXNzTWFqb3JpemF0aW9uKSx3aShzLmxhYmVscyxuZXcgS21lKSk7aT1VaGUobyksVmhlKGkpLHIuZG9uZV8xKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuZm9yY2Uuc3RyZXNzIiwiU3RyZXNzTGF5b3V0UHJvdmlkZXIiLDExMTApO2Z1bmN0aW9uIEttZSgpe31wKDExMTEsMSxKZSxLbWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0FVKGEobiw0NTQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5zdHJlc3MiLCJTdHJlc3NMYXlvdXRQcm92aWRlci9sYW1iZGEkMCRUeXBlIiwxMTExKTtmdW5jdGlvbiBkb24oZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3IoaT0wLHU9MCxjPTAsbz1uZXcgVChlLmdyYXBoXzAubm9kZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxNTMpLG4hPXQmJihzPWUud1tuLmlkXzBdW3QuaWRfMF0saSs9cyxyPVUwKG4ucG9zaXRpb24sdC5wb3NpdGlvbikscj4wJiZlLmRpbSE9KGhFKCksTTgpJiYodSs9cyoodC5wb3NpdGlvbi54XzArZS5hcHNwW24uaWRfMF1bdC5pZF8wXSoobi5wb3NpdGlvbi54XzAtdC5wb3NpdGlvbi54XzApL3IpKSxyPjAmJmUuZGltIT0oaEUoKSxrOCkmJihjKz1zKih0LnBvc2l0aW9uLnlfMCtlLmFwc3Bbbi5pZF8wXVt0LmlkXzBdKihuLnBvc2l0aW9uLnlfMC10LnBvc2l0aW9uLnlfMCkvcikpKTtzd2l0Y2goZS5kaW0ub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBuZXcgWSh1L2ksbi5wb3NpdGlvbi55XzApO2Nhc2UgMjpyZXR1cm4gbmV3IFkobi5wb3NpdGlvbi54XzAsYy9pKTtkZWZhdWx0OnJldHVybiBuZXcgWSh1L2ksYy9pKX19ZnVuY3Rpb24gWG1lKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7Zm9yKHM9MCxpPWUuZ3JhcGhfMC5ub2Rlcyx0PTA7dDxpLmFycmF5Lmxlbmd0aDsrK3QpZm9yKHU9KEFlKHQsaS5hcnJheS5sZW5ndGgpLGEoaS5hcnJheVt0XSwxNTMpKSxvPXQrMTtvPGkuYXJyYXkubGVuZ3RoOysrbyljPShBZShvLGkuYXJyYXkubGVuZ3RoKSxhKGkuYXJyYXlbb10sMTUzKSkscj1VMCh1LnBvc2l0aW9uLGMucG9zaXRpb24pLG49ci1lLmFwc3BbdS5pZF8wXVtjLmlkXzBdLHMrPWUud1t1LmlkXzBdW2MuaWRfMF0qbipuO3JldHVybiBzfWZ1bmN0aW9uIGZvbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKGQ9bmV3IG94KG5ldyBleWUocikpLHU9Qih5YSx4dSwyOCxlLmdyYXBoXzAubm9kZXMuYXJyYXkubGVuZ3RoLDE2LDEpLFJCKHUsdS5sZW5ndGgpLHJbbi5pZF8wXT0wLF89bmV3IFQoZS5ncmFwaF8wLm5vZGVzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTUzKSxjLmlkXzAhPW4uaWRfMCYmKHJbYy5pZF8wXT1xbikseGgoRXkoZCxjKSwiVW5hYmxlIHRvIGFkZCBlbGVtZW50IHRvIHF1ZXVlIik7Zm9yKDtkLmhlYXAuYXJyYXkubGVuZ3RoIT0wOylmb3IoZj1hKGRrKGQpLDE1MyksdVtmLmlkXzBdPSEwLGk9ZnNlKG5ldyB1NShlLmNvbm5lY3RlZEVkZ2VzLGYpLDApO2kubmV4dF8wOylvPWEoWHooaSksMjkwKSxoPWhvbihvLGYpLCF1W2guaWRfMF0mJihfcihvLChvMygpLGE0KSk/cz1SKCQodyhvLGE0KSkpOnM9ZS5kZXNpcmVkRWRnZUxlbmd0aCx0PXJbZi5pZF8wXStzLHQ8cltoLmlkXzBdJiYocltoLmlkXzBdPXQsYl9lKGQsaCkseGgoRXkoZCxoKSwiVW5hYmxlIHRvIGFkZCBlbGVtZW50IHRvIHF1ZXVlIikpKX1mdW5jdGlvbiBwb24oZSxuLHIsdCl7cmV0dXJuIHI9PTB8fChyLXQpL3I8ZS5lcHNpbG9ufHxuPj1lLml0ZXJhdGlvbkxpbWl0fWZ1bmN0aW9uIGdvbihlKXt2YXIgbixyLHQsbyxpLHM7aWYoIShlLmdyYXBoXzAubm9kZXMuYXJyYXkubGVuZ3RoPD0xKSl7bj0wLG89WG1lKGUpLHI9aHI7ZG97Zm9yKG4+MCYmKG89cikscz1uZXcgVChlLmdyYXBoXzAubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxNTMpLCFhZShpZSh3KGksKG8zKCksWVUpKSkpJiYodD1kb24oZSxpKSxLbihtcyhpLnBvc2l0aW9uKSx0KSk7cj1YbWUoZSl9d2hpbGUoIXBvbihlLG4rKyxvLHIpKX19ZnVuY3Rpb24gaG9uKGUsbil7aWYoZS5zb3VyY2U9PW4pcmV0dXJuIGUudGFyZ2V0O2lmKGUudGFyZ2V0PT1uKXJldHVybiBlLnNvdXJjZTt0aHJvdyBiKG5ldyBHZSgiTm9kZSAnb25lJyBtdXN0IGJlIGVpdGhlciBzb3VyY2Ugb3IgdGFyZ2V0IG9mIGVkZ2UgJ2VkZ2UnLiIpKX1mdW5jdGlvbiBtb24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7aWYoIShuLm5vZGVzLmFycmF5Lmxlbmd0aDw9MSkpe2ZvcihlLmdyYXBoXzA9bixlLmRpbT1hKHcoZS5ncmFwaF8wLChvMygpLFZVKSksMzkxKSxlLml0ZXJhdGlvbkxpbWl0PWEodyhlLmdyYXBoXzAsWFUpLDE3KS52YWx1ZV8wLGUuZXBzaWxvbj1SKCQodyhlLmdyYXBoXzAscVUpKSksZS5kZXNpcmVkRWRnZUxlbmd0aD1SKCQodyhlLmdyYXBoXzAsYTQpKSksc3NlKGUuY29ubmVjdGVkRWRnZXMpLG89bmV3IFQoZS5ncmFwaF8wLmVkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMjkwKSxqeihlLmNvbm5lY3RlZEVkZ2VzLHQuc291cmNlLHQsbnVsbCksanooZS5jb25uZWN0ZWRFZGdlcyx0LnRhcmdldCx0LG51bGwpO2Zvcih1PWUuZ3JhcGhfMC5ub2Rlcy5hcnJheS5sZW5ndGgsZS5hcHNwPWJfKGN0LFtYLFh0XSxbMTA5LDI4XSwxNSxbdSx1XSwyKSxfPW5ldyBUKGUuZ3JhcGhfMC5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDE1MyksZm9uKGUsYyxlLmFwc3BbYy5pZF8wXSk7Zm9yKGUudz1iXyhjdCxbWCxYdF0sWzEwOSwyOF0sMTUsW3UsdV0sMiksaT0wO2k8dTsrK2kpZm9yKHM9MDtzPHU7KytzKXI9ZS5hcHNwW2ldW3NdLGQ9MS8ocipyKSxlLndbaV1bc109ZH19ZnVuY3Rpb24gSm1lKCl7dGhpcy5jb25uZWN0ZWRFZGdlcz1uZXcgY3NlfWZ1bmN0aW9uIHlvbihlLG4scil7cmV0dXJuIGlyKGVbbi5pZF8wXSxlW3IuaWRfMF0pfXAoMTAwMiwxLHt9LEptZSksbC5kZXNpcmVkRWRnZUxlbmd0aD0wLGwuZXBzaWxvbj0wLGwuaXRlcmF0aW9uTGltaXQ9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmZvcmNlLnN0cmVzcyIsIlN0cmVzc01ham9yaXphdGlvbiIsMTAwMik7ZnVuY3Rpb24gaEUoKXtoRT1GLE84PW5ldyBMOCgiWFkiLDApLGs4PW5ldyBMOCgiWCIsMSksTTg9bmV3IEw4KCJZIiwyKX1mdW5jdGlvbiBMOChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHdvbihlKXtyZXR1cm4gaEUoKSx3bigoWm1lKCksUW1lKSxlKX1mdW5jdGlvbiBFb24oKXtyZXR1cm4gaEUoKSxQKEkoWlUsMSksVywzOTEsMCxbTzgsazgsTThdKX1wKDM5MSwyMix7MzoxLDM0OjEsMjI6MSwzOTE6MX0sTDgpO3ZhciBrOCxPOCxNOCxaVT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5zdHJlc3MiLCJTdHJlc3NNYWpvcml6YXRpb24vRGltZW5zaW9uIiwzOTEsZ24sRW9uLHdvbik7ZnVuY3Rpb24gWm1lKCl7Wm1lPUYsUW1lPXluKChoRSgpLFAoSShaVSwxKSxXLDM5MSwwLFtPOCxrOCxNOF0pKSl9dmFyIFFtZTtmdW5jdGlvbiBleWUoZSl7dGhpcy5kaXN0XzA9ZX1wKDEwMDMsMSxObixleWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHlvbih0aGlzLmRpc3RfMCxhKG4sMTUzKSxhKHIsMTUzKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5mb3JjZS5zdHJlc3MiLCJTdHJlc3NNYWpvcml6YXRpb24vbGFtYmRhJDAkVHlwZSIsMTAwMyk7ZnVuY3Rpb24gdm9uKGUpe3ZhciBuLHIsdCxvLGkscztmb3Iobj1uZXcgQXAscj1uZXcgQXAsSTAobixlKSxJMChyLGUpO3IuaGVhZCE9ci50YWlsOylmb3Iobz1hKG1oKHIpLDM2KSxzPW5ldyBUKG8ubGF5ZXJsZXNzTm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMCksaS5uZXN0ZWRHcmFwaCYmKHQ9aS5uZXN0ZWRHcmFwaCxJMChuLHQpLEkwKHIsdCkpO3JldHVybiBufWZ1bmN0aW9uIFNvbihlLG4scil7dmFyIHQ7dD1yLCF0JiYodD1FZWUobmV3IGdtLDApKSx0LmJlZ2luKCJMYXllcmVkIGxheW91dCIsMiksTHdlKGUuY29tcG91bmRHcmFwaFByZXByb2Nlc3NvcixuLHQuc3ViVGFzaygxKSksVG9uKGUsbix0LnN1YlRhc2soMSkpLGtpbihuLHQuc3ViVGFzaygxKSksdC5kb25lXzEoKX1mdW5jdGlvbiBDb24oZSxuLHIpe3ZhciB0LG8saSxzLHU7aWYodT1yLCF1JiYodT1FZWUobmV3IGdtLDApKSx1LmJlZ2luKCJMYXllcmVkIGxheW91dCIsMSksYXllKGUuZ3JhcGhDb25maWd1cmF0b3Isbikscz1OaW4oZS5jb21wb25lbnRzUHJvY2Vzc29yLG4pLHMuc2l6ZV8xKCk9PTEpbnllKGEocy5nZXRfMCgwKSwzNiksdSk7ZWxzZSBmb3IoaT0xL3Muc2l6ZV8xKCksbz1zLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl7aWYodD1hKG8ubmV4dF8xKCksMzYpLHIuaXNDYW5jZWxlZCgpKXJldHVybjtueWUodCx1LnN1YlRhc2soaSkpfVBpbihlLmNvbXBvbmVudHNQcm9jZXNzb3IscyxuKSxib24obiksdS5kb25lXzEoKX1mdW5jdGlvbiBUb24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKF89dm9uKG4pLEU9YSh3KG4sKG9lKCkscUUpKSwzMjIpLEV0KF8sbmV3IHR5ZShFKSksdj1hKHcobixNMyksMjk5KSxFdChfLG5ldyBveWUodikpLHk9MCxkPW5ldyBRLGk9bmV3IFgyKF8pO2kuY3VycmVudEluZGV4IT1pLmZlbmNlOylvPWEoSkkoaSksMzYpLGF5ZShlLmdyYXBoQ29uZmlndXJhdG9yLG8pLGg9YSh3KG8sKEsoKSxmTykpLDE1KSx5Kz1oLnNpemVfMSgpLHQ9aC5pdGVyYXRvcl8wKCksZWUoZCxuZXcgWnIobyx0KSk7Zm9yKHIuYmVnaW4oIlJlY3Vyc2l2ZSBoaWVyYXJjaGljYWwgbGF5b3V0Iix5KSxtPWEoYShsZShkLGQuYXJyYXkubGVuZ3RoLTEpLDQyKS5zZWNvbmQsNTEpO20uaGFzTmV4dF8wKCk7KWZvcihjPW5ldyBUKGQpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodT1hKEMoYyksNDIpLGg9YSh1LnNlY29uZCw1MSkscz1hKHUuZmlyc3QsMzYpO2guaGFzTmV4dF8wKCk7KWlmKGY9YShoLm5leHRfMSgpLDQ3KSxMKGYsNTE0KSl7aWYocy5wYXJlbnROb2RlKWJyZWFrO2YucHJvY2VzcyhzLHIuc3ViVGFzaygxKSk7YnJlYWt9ZWxzZSBmLnByb2Nlc3MocyxyLnN1YlRhc2soMSkpO3IuZG9uZV8xKCl9ZnVuY3Rpb24gbnllKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKHU9bi5pc1J1bm5pbmcoKSx1fHxuLmJlZ2luKCJDb21wb25lbnQgTGF5b3V0IiwxKSxyPWEodyhlLChLKCksZk8pKSwxNSkscz0xL3Iuc2l6ZV8xKCksbi5pc0xvZ2dpbmdFbmFibGVkKCkpZm9yKG4ubG9nXzAoIkVMSyBMYXllcmVkIHVzZXMgdGhlIGZvbGxvd2luZyAiK3Iuc2l6ZV8xKCkrIiBtb2R1bGVzOiIpLG09MCxoPXIuaXRlcmF0b3JfMCgpO2guaGFzTmV4dF8wKCk7KWQ9YShoLm5leHRfMSgpLDQ3KSx0PShtPDEwPyIwIjoiIikrbSsrLG4ubG9nXzAoIiAgIFNsb3QgIit0KyI6ICIreV8od2EoZCkpKTtmb3IoZj1yLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOyl7aWYoZD1hKGYubmV4dF8xKCksNDcpLG4uaXNDYW5jZWxlZCgpKXJldHVybjtkLnByb2Nlc3MoZSxuLnN1YlRhc2socykpfWZvcihpPW5ldyBUKGUubGF5ZXJzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMzApLHFyKGUubGF5ZXJsZXNzTm9kZXMsby5ub2Rlcyksby5ub2Rlcy5hcnJheS5sZW5ndGg9MDtmb3IoXz1uZXcgVChlLmxheWVybGVzc05vZGVzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTApLGh0KGMsbnVsbCk7ZS5sYXllcnMuYXJyYXkubGVuZ3RoPTAsdXx8bi5kb25lXzEoKX1mdW5jdGlvbiBib24oZSl7dmFyIG4scix0LG8saTtvPWEodyhlLChvZSgpLGpfKSksMjEpLGk9YSh3KGUsUFApLDIxKSxyPW5ldyBZKGUuc2l6ZV8wLnhfMCtlLnBhZGRpbmcubGVmdCtlLnBhZGRpbmcucmlnaHQsZS5zaXplXzAueV8wK2UucGFkZGluZy50b3BfMCtlLnBhZGRpbmcuYm90dG9tKSxuPW5ldyBSdChyKSxvLmNvbnRhaW5zKChTYSgpLFlmKSkmJih0PWEodyhlLG93KSw4KSxpLmNvbnRhaW5zKChnYSgpLEx3KSkmJih0LnhfMDw9MCYmKHQueF8wPTIwKSx0LnlfMDw9MCYmKHQueV8wPTIwKSksbi54XzA9Uy5NYXRoLm1heChyLnhfMCx0LnhfMCksbi55XzA9Uy5NYXRoLm1heChyLnlfMCx0LnlfMCkpLGFlKGllKHcoZSxJTykpKXx8SW9uKGUscixuKX1mdW5jdGlvbiBJb24oZSxuLHIpe3ZhciB0LG8saSxzLHU7aWYodD1hKHcoZSwob2UoKSx5TykpLDIxKSxyLnhfMD5uLnhfMCYmKHQuY29udGFpbnMoKGUxKCksR3YpKT9lLm9mZnNldC54XzArPShyLnhfMC1uLnhfMCkvMjp0LmNvbnRhaW5zKEh2KSYmKGUub2Zmc2V0LnhfMCs9ci54XzAtbi54XzApKSxyLnlfMD5uLnlfMCYmKHQuY29udGFpbnMoKGUxKCksV3YpKT9lLm9mZnNldC55XzArPShyLnlfMC1uLnlfMCkvMjp0LmNvbnRhaW5zKFV2KSYmKGUub2Zmc2V0LnlfMCs9ci55XzAtbi55XzApKSxhKHcoZSwoSygpLGlpKSksMjEpLmNvbnRhaW5zKChWdCgpLG5sKSkmJihyLnhfMD5uLnhfMHx8ci55XzA+bi55XzApKWZvcih1PW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMCkscy50eXBlXzA9PShXZSgpLEZyKSYmKG89YSh3KHMsRG8pLDY0KSxvPT0ocmUoKSxxZSk/cy5wb3MueF8wKz1yLnhfMC1uLnhfMDpvPT1sbiYmKHMucG9zLnlfMCs9ci55XzAtbi55XzApKTtpPWUucGFkZGluZyxlLnNpemVfMC54XzA9ci54XzAtaS5sZWZ0LWkucmlnaHQsZS5zaXplXzAueV8wPXIueV8wLWkudG9wXzAtaS5ib3R0b219ZnVuY3Rpb24gcnllKCl7dGhpcy5ncmFwaENvbmZpZ3VyYXRvcj1uZXcgbHllLHRoaXMuY29tcG9uZW50c1Byb2Nlc3Nvcj1uZXcgd3dlLHRoaXMuY29tcG91bmRHcmFwaFByZXByb2Nlc3Nvcj1uZXcgT3dlLHh3ZSgpfWZ1bmN0aW9uIHhvbihlLG4pe3ZhciByO2lmKHI9YSh3KG4sKG9lKCkscUUpKSwzMjIpLHIhPWUpdGhyb3cgYihuZXcgZW0oIlRoZSBoaWVyYXJjaHkgYXdhcmUgcHJvY2Vzc29yICIrcisiIGluIGNoaWxkIG5vZGUgIituKyIgaXMgb25seSBhbGxvd2VkIGlmIHRoZSByb290IG5vZGUgc3BlY2lmaWVzIHRoZSBzYW1lIGhpZXJhcmNoaWNhbCBwcm9jZXNzb3IuIikpfWZ1bmN0aW9uIFBvbihlLG4pe3JldHVybiBqKG4sKG9lKCksTTMpLGUpfXAoMTE5MiwxLHt9LHJ5ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkIiwiRWxrTGF5ZXJlZCIsMTE5Mik7ZnVuY3Rpb24gdHllKGUpe3RoaXMucGFyZW50Q21zXzA9ZX1wKDExOTMsMSxKZSx0eWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3hvbih0aGlzLnBhcmVudENtc18wLGEobiwzNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQiLCJFbGtMYXllcmVkL2xhbWJkYSQwJFR5cGUiLDExOTMpO2Z1bmN0aW9uIG95ZShlKXt0aGlzLnJvb3RUeXBlXzA9ZX1wKDExOTQsMSxKZSxveWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1Bvbih0aGlzLnJvb3RUeXBlXzAsYShuLDM2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZCIsIkVsa0xheWVyZWQvbGFtYmRhJDEkVHlwZSIsMTE5NCk7ZnVuY3Rpb24gUVUoKXtRVT1GLHN5ZT1XaShNbihNbihNbihuZXcgSHIsKHh0KCkscmkpLChrdCgpLE1qKSkscmksUmopLGhvLERqKSxobyxDaiksY3llPU1uKE1uKG5ldyBIcixyaSxoaikscmksVGopLHV5ZT1XaShuZXcgSHIsaG8sSWopfWZ1bmN0aW9uIGl5ZShlLG4pe3ZhciByLHQ7dD1hKHcobiwob2UoKSx4cikpLDEwMSksaihuLChLKCksaXEpLHQpLHI9bi5uZXN0ZWRHcmFwaCxyJiYoTHIobmV3IFNlKG51bGwsbmV3IHhlKHIubGF5ZXJsZXNzTm9kZXMsMTYpKSxuZXcgZVcoZSkpLExyKE5vKG5ldyBTZShudWxsLG5ldyB4ZShyLmxheWVycywxNikpLG5ldyBuVyksbmV3IHJXKGUpKSl9ZnVuY3Rpb24gTm9uKGUpe3ZhciBuLHIsdCxvLGk7c3dpdGNoKHI9YSh3KGUsKEsoKSxpaSkpLDIxKSxuPVVOKHN5ZSksbz1hKHcoZSwob2UoKSxOZikpLDM0Niksbz09KHBjKCksUWMpJiZSYShuLHV5ZSksYWUoaWUodyhlLFRPKSkpP01uKG4sKHh0KCksamwpLChrdCgpLGY5KSk6TW4obiwoeHQoKSxKbyksKGt0KCksZjkpKSx3KGUsKFZOKCksTXYpKSE9bnVsbCYmUmEobixjeWUpLChhZShpZSh3KGUsWnEpKSl8fGFlKGllKHcoZSxZcSkpKSkmJldpKG4sKHh0KCksaG8pLChrdCgpLEVqKSksYSh3KGUsT2EpLDg4KS5vcmRpbmFsKXtjYXNlIDI6Y2FzZSAzOmNhc2UgNDpXaShNbihuLCh4dCgpLGpsKSwoa3QoKSxTaikpLGhvLHZqKX1zd2l0Y2goci5jb250YWlucygoVnQoKSxhUCkpJiZXaShNbihNbihuLCh4dCgpLGpsKSwoa3QoKSx3aikpLHJpLG1qKSxobyx5aiksRCh3KGUsejApKSE9PUQoKFNsKCksRlApKSYmTW4obiwoeHQoKSxKbyksKGt0KCksRmopKSxyLmNvbnRhaW5zKHNQKSYmKE1uKG4sKHh0KCksamwpLChrdCgpLEdqKSksTW4obixPdSwkaiksTW4obixKbyxCaikpLEQodyhlLG1QKSkhPT1EKChaeSgpLCRFKSkmJkQodyhlLHVjKSkhPT1EKChmYygpLE1UKSkmJldpKG4sKHh0KCksaG8pLChrdCgpLExqKSksYWUoaWUodyhlLFhxKSkpJiZNbihuLCh4dCgpLEpvKSwoa3QoKSxBaikpLGFlKGllKHcoZSxFTykpKSYmTW4obiwoeHQoKSxKbyksKGt0KCksSGopKSxBb24oZSkmJihEKHcoZSxOZikpPT09RChRYyk/dD1hKHcoZSxNMyksMjk5KTp0PWEodyhlLHdPKSwyOTkpLGk9dD09KHJ3KCksdE8pPyhrdCgpLHpqKTooa3QoKSxqaiksTW4obiwoeHQoKSxyaSksaSkpLGEodyhlLFRZKSwzODgpLm9yZGluYWwpe2Nhc2UgMTpNbihuLCh4dCgpLHJpKSwoa3QoKSxVaikpO2JyZWFrO2Nhc2UgMjpXaShNbihNbihuLCh4dCgpLEpvKSwoa3QoKSxmaikpLHJpLHBqKSxobyxnail9cmV0dXJuIEQodyhlLER1KSkhPT1EKChmdSgpLFZjKSkmJk1uKG4sKHh0KCksSm8pLChrdCgpLFdqKSksbn1mdW5jdGlvbiBheWUoZSxuKXt2YXIgcix0LG8saSxzO3I9UigkKHcobiwob2UoKSxxbCkpKSkscjwyJiZqKG4scWwsMiksdD1hKHcobixPYSksODgpLHQ9PShXcigpLEJzKSYmaihuLE9hLGc0KG4pKSxvPWEodyhuLFo0ZSksMTcpLG8udmFsdWVfMD09MD9qKG4sKEsoKSxWaCksbmV3IHBrKTpqKG4sKEsoKSxWaCksbmV3IGF4KG8udmFsdWVfMCkpLGk9aWUodyhuLFlFKSksaT09bnVsbCYmaihuLFlFLCh6ZSgpLEQodyhuLHVjKSk9PT1EKChmYygpLE53KSkpKSxMcihuZXcgU2UobnVsbCxuZXcgeGUobi5sYXllcmxlc3NOb2RlcywxNikpLG5ldyBlVyhlKSksTHIoTm8obmV3IFNlKG51bGwsbmV3IHhlKG4ubGF5ZXJzLDE2KSksbmV3IG5XKSxuZXcgclcoZSkpLHM9bmV3IFJQZShuKSxqKG4sKEsoKSxlZykscyksdlQoZS5hbGdvcml0aG1Bc3NlbWJsZXIpLGdzKGUuYWxnb3JpdGhtQXNzZW1ibGVyLCh4dCgpLGpsKSxhKHcobixIXyksMTg4KSksZ3MoZS5hbGdvcml0aG1Bc3NlbWJsZXIsT3UsYSh3KG4sV18pLDE4OCkpLGdzKGUuYWxnb3JpdGhtQXNzZW1ibGVyLEpvLGEodyhuLHFFKSwxODgpKSxncyhlLmFsZ29yaXRobUFzc2VtYmxlcixyaSxhKHcobix4UCksMTg4KSksZ3MoZS5hbGdvcml0aG1Bc3NlbWJsZXIsaG8sdWduKGEodyhuLHVjKSwyMjMpKSksR1ooZS5hbGdvcml0aG1Bc3NlbWJsZXIsTm9uKG4pKSxqKG4sZk8sRVQoZS5hbGdvcml0aG1Bc3NlbWJsZXIsbikpfWZ1bmN0aW9uIGx5ZSgpe1FVKCksdGhpcy5hbGdvcml0aG1Bc3NlbWJsZXI9bmV3IEF2KHRXKX1mdW5jdGlvbiBBb24oZSl7dmFyIG4scix0LG87cmV0dXJuIEQodyhlLChvZSgpLE5mKSkpPT09RCgocGMoKSxRYykpPyFlLnBhcmVudE5vZGUmJkQodyhlLE0zKSkhPT1EKChydygpLHgzKSk6KHQ9YSh3KGUsd08pLDI5OSksbz1hZShpZSh3KGUsRU8pKSl8fEQodyhlLHFFKSk9PT1EKChNRSgpLFMzKSksbj1hKHcoZSxCcSksMTcpLnZhbHVlXzAscj1lLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aCwhbyYmdCE9KHJ3KCkseDMpJiYobj09MHx8bj5yKSl9cCgxMjgxLDEse30sbHllKTt2YXIgc3llLHV5ZSxjeWU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkIiwiR3JhcGhDb25maWd1cmF0b3IiLDEyODEpO2Z1bmN0aW9uIGVXKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCg3NzAsMSxKZSxlVyksbC5hY2NlcHQ9ZnVuY3Rpb24obil7aXllKHRoaXMuJCRvdXRlcl8wLGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQiLCJHcmFwaENvbmZpZ3VyYXRvci9sYW1iZGEkMCRUeXBlIiw3NzApO2Z1bmN0aW9uIG5XKCl7fXAoNzcxLDEse30sblcpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gUVUoKSxuZXcgU2UobnVsbCxuZXcgeGUoYShuLDMwKS5ub2RlcywxNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQiLCJHcmFwaENvbmZpZ3VyYXRvci9sYW1iZGEkMSRUeXBlIiw3NzEpO2Z1bmN0aW9uIHJXKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCg3NzIsMSxKZSxyVyksbC5hY2NlcHQ9ZnVuY3Rpb24obil7aXllKHRoaXMuJCRvdXRlcl8wLGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQiLCJHcmFwaENvbmZpZ3VyYXRvci9sYW1iZGEkMiRUeXBlIiw3NzIpO2Z1bmN0aW9uIF95ZSgpe3RoaXMuZWxrTGF5ZXJlZD1uZXcgcnllfXAoMTEwOSwyMDUsZ18sX3llKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe3ZhciB0O3Q9bWFuKG5ldyB2MmUsbiksRChWKG4sKG9lKCksTmYpKSk9PT1EKChwYygpLFFjKSk/U29uKHRoaXMuZWxrTGF5ZXJlZCx0LHIpOkNvbih0aGlzLmVsa0xheWVyZWQsdCxyKSxyLmlzQ2FuY2VsZWQoKXx8TDJlKG5ldyBrMmUsdCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZCIsIkxheWVyZWRMYXlvdXRQcm92aWRlciIsMTEwOSk7ZnVuY3Rpb24geHQoKXt4dD1GLGpsPW5ldyBpMygiUDFfQ1lDTEVfQlJFQUtJTkciLDApLE91PW5ldyBpMygiUDJfTEFZRVJJTkciLDEpLEpvPW5ldyBpMygiUDNfTk9ERV9PUkRFUklORyIsMikscmk9bmV3IGkzKCJQNF9OT0RFX1BMQUNFTUVOVCIsMyksaG89bmV3IGkzKCJQNV9FREdFX1JPVVRJTkciLDQpfWZ1bmN0aW9uIGkzKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gTG9uKGUpe3JldHVybiB4dCgpLHduKChkeWUoKSxmeWUpLGUpfWZ1bmN0aW9uIGtvbigpe3JldHVybiB4dCgpLFAoSSh0VywxKSxXLDM2NywwLFtqbCxPdSxKbyxyaSxob10pfXAoMzY3LDIyLHszOjEsMzQ6MSwyMjoxLDM2NzoxfSxpMyk7dmFyIGpsLE91LEpvLHJpLGhvLHRXPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQiLCJMYXllcmVkUGhhc2VzIiwzNjcsZ24sa29uLExvbik7ZnVuY3Rpb24gZHllKCl7ZHllPUYsZnllPXluKCh4dCgpLFAoSSh0VywxKSxXLDM2NywwLFtqbCxPdSxKbyxyaSxob10pKSl9dmFyIGZ5ZTtmdW5jdGlvbiBvVygpe29XPUYsZ3llPW5ldyB5eWV9ZnVuY3Rpb24gT29uKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7Zm9yKGk9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksODYpLG8ucmVjdC54XzA9by5oaXRib3gueF8wLG8ucmVjdC55XzA9by5oaXRib3gueV8wO2ZvcihjPW5ldyBZKGhyLGhyKSxuPW5ldyBZKFZyLFZyKSx0PW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDg2KSxjLnhfMD1TLk1hdGgubWluKGMueF8wLHIuaGl0Ym94LnhfMCksYy55XzA9Uy5NYXRoLm1pbihjLnlfMCxyLmhpdGJveC55XzApLG4ueF8wPVMuTWF0aC5tYXgobi54XzAsci5oaXRib3gueF8wK3IuaGl0Ym94LndpZHRoXzApLG4ueV8wPVMuTWF0aC5tYXgobi55XzAsci5oaXRib3gueV8wK3IuaGl0Ym94LmhlaWdodCk7Zm9yKHU9b0koZS5leHRlcm5hbFBsYWNlaG9sZGVyKS50aGlzJDAxLnZhbHVlSXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDQyKSxyPWEocy5zZWNvbmQsODYpLGMueF8wPVMuTWF0aC5taW4oYy54XzAsci5oaXRib3gueF8wKSxjLnlfMD1TLk1hdGgubWluKGMueV8wLHIuaGl0Ym94LnlfMCksbi54XzA9Uy5NYXRoLm1heChuLnhfMCxyLmhpdGJveC54XzArci5oaXRib3gud2lkdGhfMCksbi55XzA9Uy5NYXRoLm1heChuLnlfMCxyLmhpdGJveC55XzArci5oaXRib3guaGVpZ2h0KTtlLmdsb2JhbE9mZnNldD1LTihuZXcgWShjLnhfMCxjLnlfMCkpLGUuZ3JhcGhTaXplPXJ0KG5ldyBZKG4ueF8wLG4ueV8wKSxjKSxlLmNHcmFwaC5jR3JvdXBzLmFycmF5Lmxlbmd0aD0wLGUuY0dyYXBoLmNOb2Rlcy5hcnJheS5sZW5ndGg9MH1mdW5jdGlvbiBNb24oZSxuKXt2YXIgcjtyZXR1cm4gcj1ydChDdChhKEtlKGUub2xkUG9zaXRpb24sbiksOCkpLGVRKGEoS2UoZS5vZmZzZXRzLG4pLDQ3MCkucmVjdCkpLHJ9ZnVuY3Rpb24gaVcoZSxuKXtuLmlzRW1wdHkoKSYmTXUoZS5sb2NrLCEwLCEwLCEwLCEwKSxZbihuLChyZSgpLFFsKSkmJk11KGUubG9jaywhMCwhMCwhMCwhMSksWW4obixpbCkmJk11KGUubG9jaywhMSwhMCwhMCwhMCksWW4obix6YSkmJk11KGUubG9jaywhMCwhMCwhMSwhMCksWW4obixibCkmJk11KGUubG9jaywhMCwhMSwhMCwhMCksWW4obixsYSkmJk11KGUubG9jaywhMSwhMCwhMCwhMSksWW4obixhbCkmJk11KGUubG9jaywhMSwhMCwhMSwhMCksWW4obiwkYSkmJk11KGUubG9jaywhMCwhMSwhMSwhMCksWW4obixlcykmJk11KGUubG9jaywhMCwhMSwhMCwhMSksWW4obixraSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obix2aSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obixraSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obixMaSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obixPaSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obixzYSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCksWW4obixsaSkmJk11KGUubG9jaywhMCwhMCwhMCwhMCl9ZnVuY3Rpb24gUm9uKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGUuY0dyYXBoPW5ldyB4eWUoZlFlKFZ2KSksdD1uZXcgVChuLmNvbXBvbmVudHMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHI9YShDKHQpLDg1NSksdT1uZXcgSDgoUChJKFI4LDEpLE1lLDg2LDAsW10pKSxlZShlLmNHcmFwaC5jR3JvdXBzLHUpLF89bmV3IFQoci5yZWN0aWxpbmVhckNvbnZleEh1bGwpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSwxMTYpLGQ9bmV3IGFXKGUsYyksaVcoZCxhKHcoci5ncmFwaF8wLChLKCksc2MpKSwyMSkpLHlpKGUub2xkUG9zaXRpb24scil8fChCbihlLm9sZFBvc2l0aW9uLHIsbmV3IFkoYy54XzAsYy55XzApKSxCbihlLm9mZnNldHMscixkKSksZWUoZS5jR3JhcGguY05vZGVzLGQpLEc4KHUsZCk7Zm9yKHM9bmV3IFQoci5leHRlcm5hbEV4dGVuc2lvbnMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSw2MDIpLGQ9bmV3IGFXKGUsaS5nZXRSZXByZXNlbnRvcigpKSxCbihlLmV4dGVybmFsRXh0ZW5zaW9ucyxpLG5ldyBacih1LGQpKSxpVyhkLGEodyhyLmdyYXBoXzAsKEsoKSxzYykpLDIxKSksaS5nZXRQbGFjZWhvbGRlcigpJiYoZj1uZXcgbFcoZSxpLmdldFBsYWNlaG9sZGVyKCksMSksaVcoZixhKHcoci5ncmFwaF8wLHNjKSwyMSkpLG89bmV3IEg4KFAoSShSOCwxKSxNZSw4NiwwLFtdKSksRzgobyxmKSxiZShlLmV4dGVybmFsUGxhY2Vob2xkZXIsaS5nZXREaXJlY3Rpb24oKSxuZXcgWnIodSxmKSkpfXJldHVybiBlLmNHcmFwaH1mdW5jdGlvbiBweWUoZSl7b1coKSx0aGlzLm9sZFBvc2l0aW9uPW5ldyBzbix0aGlzLm9mZnNldHM9bmV3IHNuLHRoaXMuZXh0ZXJuYWxFeHRlbnNpb25zPW5ldyBzbix0aGlzLmV4dGVybmFsUGxhY2Vob2xkZXI9bmV3IEUxLHRoaXMuc3BhY2luZz1lfXAoMTcxNywxLHt9LHB5ZSksbC5zcGFjaW5nPTA7dmFyIGd5ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5jb21wb25lbnRzIiwiQ29tcG9uZW50c1RvQ0dyYXBoVHJhbnNmb3JtZXIiLDE3MTcpO2Z1bmN0aW9uIGh5ZSgpe2h5ZT1GLG15ZT1uZXcgUHllfXZhciBteWU7ZnVuY3Rpb24geXllKCl7fXAoMTcxOCwxLHt9LHl5ZSksbC5nZXRIb3Jpem9udGFsU3BhY2luZ18wPWZ1bmN0aW9uKG4scil7cmV0dXJuIFMuTWF0aC5taW4obi5pbmRpdmlkdWFsU3BhY2luZyE9bnVsbD9SKG4uaW5kaXZpZHVhbFNwYWNpbmcpOm4udGhpcyQwMS5zcGFjaW5nLHIuaW5kaXZpZHVhbFNwYWNpbmchPW51bGw/UihyLmluZGl2aWR1YWxTcGFjaW5nKTpyLnRoaXMkMDEuc3BhY2luZyl9LGwuZ2V0VmVydGljYWxTcGFjaW5nXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gUy5NYXRoLm1pbihuLmluZGl2aWR1YWxTcGFjaW5nIT1udWxsP1Iobi5pbmRpdmlkdWFsU3BhY2luZyk6bi50aGlzJDAxLnNwYWNpbmcsci5pbmRpdmlkdWFsU3BhY2luZyE9bnVsbD9SKHIuaW5kaXZpZHVhbFNwYWNpbmcpOnIudGhpcyQwMS5zcGFjaW5nKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24uY29tcG9uZW50cyIsIkNvbXBvbmVudHNUb0NHcmFwaFRyYW5zZm9ybWVyLzEiLDE3MTgpLHAoODYsMSx7ODY6MX0pLGwuaWRfMD0wLGwucmVwb3NpdGlvbj0hMCxsLnN0YXJ0UG9zPVZyO3ZhciBSOD1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5vbmVkIiwiQ05vZGUiLDg2KTtmdW5jdGlvbiBhVyhlLG4pe2xXLmNhbGwodGhpcyxlLG4sbnVsbCl9ZnVuY3Rpb24gbFcoZSxuLHIpe3RoaXMudGhpcyQwMT1lLHRoaXMuY29uc3RyYWludHM9bmV3IFEsdGhpcy5jR3JvdXBPZmZzZXQ9bmV3IG10LHRoaXMubG9jaz1uZXcgX1csdGhpcy5zcGFjaW5nSWdub3JlPW5ldyBfVyx0aGlzLnJlY3Q9bix0aGlzLmhpdGJveD1uZXcgdGwobi54XzAsbi55XzAsbi53aWR0aF8wLG4uaGVpZ2h0KSx0aGlzLmluZGl2aWR1YWxTcGFjaW5nPXJ9cCg0NzAsODYsezQ3MDoxLDg2OjF9LGFXLGxXKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iIn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24uY29tcG9uZW50cyIsIkNvbXBvbmVudHNUb0NHcmFwaFRyYW5zZm9ybWVyL0NSZWN0Tm9kZSIsNDcwKTtmdW5jdGlvbiBEOCgpe0Q4PUYsJDg9WXNlKFAoSShWdiwxKSxXLDg4LDAsWyhXcigpLGFvKSxtb10pKSxCOD1Zc2UoUChJKFZ2LDEpLFcsODgsMCxbb2wsJHNdKSl9ZnVuY3Rpb24gRjgoZSxuKXt2YXIgcix0O2Zvcih0PW5ldyBUKG4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw0MiksZWUoZS5jb21wYWN0aW9uR3JhcGguY05vZGVzLGEoci5zZWNvbmQsODYpKSxHOChhKHIuZmlyc3QsMTk0KSxhKHIuc2Vjb25kLDg2KSl9ZnVuY3Rpb24gd3llKGUsbil7dmFyIHIsdCxvLGkscztmb3Iobz1uPT0xP0I4OiQ4LHQ9by5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylmb3Iocj1hKHQubmV4dF8xKCksODgpLHM9YShabihlLnRyYW5zZm9ybWVyLmV4dGVybmFsUGxhY2Vob2xkZXIsciksMjEpLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylpPWEocy5uZXh0XzEoKSw0MiksZWUoZS5jb21wYWN0aW9uR3JhcGguY05vZGVzLGEoaS5zZWNvbmQsODYpKSxlZShlLmNvbXBhY3Rpb25HcmFwaC5jR3JvdXBzLGEoaS5zZWNvbmQsODYpLmNHcm91cCl9ZnVuY3Rpb24gRXllKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihuPTAsaT1uZXcgVChlLmNvbXBhY3Rpb25HcmFwaC5jR3JvdXBzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMoaSksMTk0KSx0LmRlbHRhPTAsdC5kZWx0YU5vcm1hbGl6ZWQ9MDtmb3Iod3llKGUsMCksRjgoZSxlLnZlcnRpY2FsRXh0ZXJuYWxFeHRlbnNpb25zKSxsNChlLmNvbXBhY3RvciksdVcoZS5jb21wYWN0b3IpLHI9KFdyKCksYW8pLGEzKFU4KEJwKGEzKFU4KEJwKGEzKEJwKGUuY29tcGFjdG9yLHIpKSxhRmUocikpKSkscikpKSxCcChlLmNvbXBhY3RvcixhbyksejgoZSxlLnZlcnRpY2FsRXh0ZXJuYWxFeHRlbnNpb25zKSx2eWUoZSwwKSxTeWUoZSwwKSxDeWUoZSwxKSx3eWUoZSwxKSxGOChlLGUuaG9yaXpvbnRhbEV4dGVybmFsRXh0ZW5zaW9ucyksbDQoZS5jb21wYWN0b3IpLHM9bmV3IFQoZS5jb21wYWN0aW9uR3JhcGguY0dyb3Vwcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKHMpLDE5NCksbis9Uy5NYXRoLmFicyh0LmRlbHRhTm9ybWFsaXplZCk7Zm9yKHU9bmV3IFQoZS5jb21wYWN0aW9uR3JhcGguY0dyb3Vwcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKHUpLDE5NCksdC5kZWx0YT0wLHQuZGVsdGFOb3JtYWxpemVkPTA7Zm9yKHI9b2wsYTMoVTgoQnAoYTMoVTgoQnAoYTModVcoQnAoZS5jb21wYWN0b3IscikpKSxhRmUocikpKSkscikpKSxCcChlLmNvbXBhY3RvcixhbyksejgoZSxlLmhvcml6b250YWxFeHRlcm5hbEV4dGVuc2lvbnMpLHZ5ZShlLDEpLFN5ZShlLDEpLEN5ZShlLDApLHVXKGUuY29tcGFjdG9yKSxvPW5ldyBUKGUuY29tcGFjdGlvbkdyYXBoLmNHcm91cHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxOTQpLG4rPVMuTWF0aC5hYnModC5kZWx0YU5vcm1hbGl6ZWQpO3JldHVybiBufWZ1bmN0aW9uIERvbihlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3Iobj1uZXcgUSxlLnZlcnRpY2FsRXh0ZXJuYWxFeHRlbnNpb25zPW5ldyBRLGUuaG9yaXpvbnRhbEV4dGVybmFsRXh0ZW5zaW9ucz1uZXcgUSxzPW5ldyBMXyhuZXcgQV8oZS50cmFuc2Zvcm1lci5leHRlcm5hbEV4dGVuc2lvbnMpLnRoaXMkMDEpO3MuaGFzTmV4dDspaT1OMShzKSxlZShuLGEoYShpLmdldFZhbHVlKCksNDIpLnNlY29uZCw4NikpLGRjKGEoaS5nZXRLZXkoKSw2MDIpLmdldERpcmVjdGlvbigpKT9lZShlLmhvcml6b250YWxFeHRlcm5hbEV4dGVuc2lvbnMsYShpLmdldFZhbHVlKCksNDIpKTplZShlLnZlcnRpY2FsRXh0ZXJuYWxFeHRlbnNpb25zLGEoaS5nZXRWYWx1ZSgpLDQyKSk7Zm9yKEY4KGUsZS5ob3Jpem9udGFsRXh0ZXJuYWxFeHRlbnNpb25zKSxGOChlLGUudmVydGljYWxFeHRlcm5hbEV4dGVuc2lvbnMpLGUuY29tcGFjdG9yPW5ldyBBeWUoZS5jb21wYWN0aW9uR3JhcGgpLFdvbihlLmNvbXBhY3Rvciwob1coKSxneWUpKSx6OChlLGUuaG9yaXpvbnRhbEV4dGVybmFsRXh0ZW5zaW9ucyksejgoZSxlLnZlcnRpY2FsRXh0ZXJuYWxFeHRlbnNpb25zKSxxcihuLGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpLGUudG9wTGVmdD1uZXcgWShocixociksZS5ib3R0b21SaWdodD1uZXcgWShWcixWciksdD1uZXcgVChuKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksODYpLGUudG9wTGVmdC54XzA9Uy5NYXRoLm1pbihlLnRvcExlZnQueF8wLHIuaGl0Ym94LnhfMCksZS50b3BMZWZ0LnlfMD1TLk1hdGgubWluKGUudG9wTGVmdC55XzAsci5oaXRib3gueV8wKSxlLmJvdHRvbVJpZ2h0LnhfMD1TLk1hdGgubWF4KGUuYm90dG9tUmlnaHQueF8wLHIuaGl0Ym94LnhfMCtyLmhpdGJveC53aWR0aF8wKSxlLmJvdHRvbVJpZ2h0LnlfMD1TLk1hdGgubWF4KGUuYm90dG9tUmlnaHQueV8wLHIuaGl0Ym94LnlfMCtyLmhpdGJveC5oZWlnaHQpO2NXKGUuY29tcGFjdG9yLG5ldyBieWUpLHU9MDtkbyBvPUV5ZShlKSwrK3U7d2hpbGUoKHU8Mnx8bz5nMCkmJnU8MTApO2NXKGUuY29tcGFjdG9yLG5ldyBJeWUpLEV5ZShlKSxVb24oZS5jb21wYWN0b3IpLE9vbihlLnRyYW5zZm9ybWVyKX1mdW5jdGlvbiBGb24oZSxuKXt2YXIgcjtyZXR1cm4gcj1Nb24oZS50cmFuc2Zvcm1lcixuKSxLbihLTihyKSxlLnRyYW5zZm9ybWVyLmdsb2JhbE9mZnNldCl9ZnVuY3Rpb24gejgoZSxuKXt2YXIgcix0O2Zvcih0PW5ldyBUKG4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw0MiksUGkoZS5jb21wYWN0aW9uR3JhcGguY05vZGVzLHIuc2Vjb25kKSxHb24oYShyLmZpcnN0LDE5NCksYShyLnNlY29uZCw4NikpfWZ1bmN0aW9uIHZ5ZShlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKG89bj09MT9CODokOCx0PW8ubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspZm9yKHI9YSh0Lm5leHRfMSgpLDg4KSxzPWEoWm4oZS50cmFuc2Zvcm1lci5leHRlcm5hbFBsYWNlaG9sZGVyLHIpLDIxKS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksNDIpLFBpKGUuY29tcGFjdGlvbkdyYXBoLmNOb2RlcyxpLnNlY29uZCksUGkoZS5jb21wYWN0aW9uR3JhcGguY0dyb3VwcyxhKGkuc2Vjb25kLDg2KS5jR3JvdXApfWZ1bmN0aW9uIFN5ZShlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3Iocz1uZXcgTF8obmV3IEFfKGUudHJhbnNmb3JtZXIuZXh0ZXJuYWxFeHRlbnNpb25zKS50aGlzJDAxKTtzLmhhc05leHQ7KXtpZihpPU4xKHMpLG89YShpLmdldEtleSgpLDYwMiksbj09MSl7aWYoby5nZXREaXJlY3Rpb24oKSE9KFdyKCksb2wpJiZvLmdldERpcmVjdGlvbigpIT0kcyljb250aW51ZX1lbHNlIGlmKG8uZ2V0RGlyZWN0aW9uKCkhPShXcigpLGFvKSYmby5nZXREaXJlY3Rpb24oKSE9bW8pY29udGludWU7c3dpdGNoKHQ9YShhKGkuZ2V0VmFsdWUoKSw0Mikuc2Vjb25kLDg2KSx1PWEoYShpLmdldFZhbHVlKCksNDIpLmZpcnN0LDE5NCkscj11LmRlbHRhTm9ybWFsaXplZCxvLmdldERpcmVjdGlvbigpLm9yZGluYWwpe2Nhc2UgMjp0LmhpdGJveC54XzA9ZS50b3BMZWZ0LnhfMCx0LmhpdGJveC53aWR0aF8wPVMuTWF0aC5tYXgoMSx0LmhpdGJveC53aWR0aF8wK3IpO2JyZWFrO2Nhc2UgMTp0LmhpdGJveC54XzA9dC5oaXRib3gueF8wK3IsdC5oaXRib3gud2lkdGhfMD1TLk1hdGgubWF4KDEsdC5oaXRib3gud2lkdGhfMC1yKTticmVhaztjYXNlIDQ6dC5oaXRib3gueV8wPWUudG9wTGVmdC55XzAsdC5oaXRib3guaGVpZ2h0PVMuTWF0aC5tYXgoMSx0LmhpdGJveC5oZWlnaHQrcik7YnJlYWs7Y2FzZSAzOnQuaGl0Ym94LnlfMD10LmhpdGJveC55XzArcix0LmhpdGJveC5oZWlnaHQ9Uy5NYXRoLm1heCgxLHQuaGl0Ym94LmhlaWdodC1yKX19fWZ1bmN0aW9uIEN5ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKHM9bj09MT9CODokOCxpPXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspZm9yKG89YShpLm5leHRfMSgpLDg4KSxjPWEoWm4oZS50cmFuc2Zvcm1lci5leHRlcm5hbFBsYWNlaG9sZGVyLG8pLDIxKS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspc3dpdGNoKHU9YShjLm5leHRfMSgpLDQyKSx0PWEodS5zZWNvbmQsODYpLF89YSh1LmZpcnN0LDE5NCkscj1fLmRlbHRhTm9ybWFsaXplZCxvLm9yZGluYWwpe2Nhc2UgMjpjYXNlIDE6dC5oaXRib3gueV8wKz1yO2JyZWFrO2Nhc2UgNDpjYXNlIDM6dC5oaXRib3gueF8wKz1yfX1mdW5jdGlvbiBUeWUoKXt9ZnVuY3Rpb24gem9uKGUpe3JldHVybiBEOCgpLHplKCksYShlLmZpcnN0LDg2KS5jR3JvdXAub3V0RGVncmVlIT0wfWZ1bmN0aW9uICRvbihlKXtyZXR1cm4gRDgoKSx6ZSgpLCEhKE95ZShhKGUuZmlyc3QsODYpLmxvY2ssYShlLnNlY29uZCw4OCkpfHxhKGUuZmlyc3QsODYpLmNHcm91cC5vdXREZWdyZWUhPTAmJk95ZShhKGUuZmlyc3QsODYpLmxvY2ssYShlLnNlY29uZCw4OCkpKX1wKDE2ODgsMSx7fSxUeWUpO3ZhciAkOCxCODtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5jb21wb25lbnRzIiwiT25lRGltZW5zaW9uYWxDb21wb25lbnRzQ29tcGFjdGlvbiIsMTY4OCk7ZnVuY3Rpb24gYnllKCl7fXAoMTY4OSwxLHt9LGJ5ZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiB6b24oYShuLDQyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5jb21wb25lbnRzIiwiT25lRGltZW5zaW9uYWxDb21wb25lbnRzQ29tcGFjdGlvbi9sYW1iZGEkMCRUeXBlIiwxNjg5KTtmdW5jdGlvbiBJeWUoKXt9cCgxNjkwLDEse30sSXllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuICRvbihhKG4sNDIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLmNvbXBvbmVudHMiLCJPbmVEaW1lbnNpb25hbENvbXBvbmVudHNDb21wYWN0aW9uL2xhbWJkYSQxJFR5cGUiLDE2OTApO2Z1bmN0aW9uIEJvbihlLG4pe3JldHVybiAkaShlLnN1cHBvcnRlZERpcmVjdGlvbnMsbil9ZnVuY3Rpb24geHllKGUpe3RoaXMuY05vZGVzPW5ldyBRLHRoaXMuY0dyb3Vwcz1uZXcgUSx0aGlzLnN1cHBvcnRlZERpcmVjdGlvbnM9ZX1wKDE3MjAsMSx7fSx4eWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLm9uZWQiLCJDR3JhcGgiLDE3MjApO2Z1bmN0aW9uIEc4KGUsbil7aWYoWXIoZS5jTm9kZXMsbiksbi5jR3JvdXApdGhyb3cgYihuZXcgSW8oIkNOb2RlIGJlbG9uZ3MgdG8gYW5vdGhlciBDR3JvdXAuIikpO24uY0dyb3VwPWV9ZnVuY3Rpb24gR29uKGUsbil7dmFyIHI7cmV0dXJuIHI9ZUcoZS5jTm9kZXMsbiksciYmKG4uY0dyb3VwPW51bGwpLHJ9ZnVuY3Rpb24gSDgoZSl7dmFyIG4scix0LG87Zm9yKHRoaXMuY05vZGVzPW5ldyBsdSx0aGlzLmluY29taW5nQ29uc3RyYWludHM9bmV3IEJyLHRoaXMub3V0RGVncmVlPTAscj1lLHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLCF0aGlzLnJlZmVyZW5jZSYmKHRoaXMucmVmZXJlbmNlPW4pLEc4KHRoaXMsbil9cCgxOTQsMSx7MTk0OjF9LEg4KSxsLmRlbHRhPTAsbC5kZWx0YU5vcm1hbGl6ZWQ9MCxsLm91dERlZ3JlZT0wLGwucmVwb3NpdGlvbj0hMCxsLnN0YXJ0UG9zPVZyLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLm9uZWQiLCJDR3JvdXAiLDE5NCk7ZnVuY3Rpb24gUHllKCl7fXAoMTcxOSwxLHt9LFB5ZSksbC5nZXRIb3Jpem9udGFsU3BhY2luZ18wPWZ1bmN0aW9uKG4scil7cmV0dXJuIFMuTWF0aC5tYXgobi5pbmRpdmlkdWFsU3BhY2luZyE9bnVsbD9SKG4uaW5kaXZpZHVhbFNwYWNpbmcpOm4udGhpcyQwMS5zcGFjaW5nLHIuaW5kaXZpZHVhbFNwYWNpbmchPW51bGw/UihyLmluZGl2aWR1YWxTcGFjaW5nKTpyLnRoaXMkMDEuc3BhY2luZyl9LGwuZ2V0VmVydGljYWxTcGFjaW5nXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gUy5NYXRoLm1heChuLmluZGl2aWR1YWxTcGFjaW5nIT1udWxsP1Iobi5pbmRpdmlkdWFsU3BhY2luZyk6bi50aGlzJDAxLnNwYWNpbmcsci5pbmRpdmlkdWFsU3BhY2luZyE9bnVsbD9SKHIuaW5kaXZpZHVhbFNwYWNpbmcpOnIudGhpcyQwMS5zcGFjaW5nKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ub25lZCIsIklTcGFjaW5nc0hhbmRsZXIvMSIsMTcxOSk7ZnVuY3Rpb24gc1coKXtzVz1GLEx5ZT1uZXcgTXllfWZ1bmN0aW9uIFU4KGUpe3JldHVybiBIb24oZSxlLmRpcmVjdGlvbiksZX1mdW5jdGlvbiBIb24oZSxuKXt2YXIgcix0LG8saTtmb3IodD1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTk0KSxyLnJlcG9zaXRpb249ITA7Zm9yKGk9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksODYpLG8ucmVwb3NpdGlvbj1hZShpZShlLmxvY2tpbmdTdHJhdGVneS5hcHBseV8wKG5ldyBacihvLG4pKSkpLG8uY0dyb3VwLnJlcG9zaXRpb249by5jR3JvdXAucmVwb3NpdGlvbiZhZShpZShlLmxvY2tpbmdTdHJhdGVneS5hcHBseV8wKG5ldyBacihvLG4pKSkpO3JldHVybiBlfWZ1bmN0aW9uIERfKGUpe3ZhciBuLHI7Zm9yKHI9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksODYpLG4uY29uc3RyYWludHMuY2xlYXJfMCgpO3FvbihlLmNvbnN0cmFpbnRBbGdvcml0aG0sZSksTnllKGUpfWZ1bmN0aW9uIE55ZShlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3IoaT1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMoaSksMTk0KSx0Lm91dERlZ3JlZT0wLHQuaW5jb21pbmdDb25zdHJhaW50cy5tYXBfMC5jbGVhcl8wKCk7Zm9yKG89bmV3IFQoZS5jR3JhcGguY0dyb3Vwcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih0PWEoQyhvKSwxOTQpLHI9dC5jTm9kZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspZm9yKG49YShyLm5leHRfMSgpLDg2KSx1PW4uY29uc3RyYWludHMuaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDg2KSxzLmNHcm91cCE9dCYmKFlyKHQuaW5jb21pbmdDb25zdHJhaW50cyxzKSwrK3MuY0dyb3VwLm91dERlZ3JlZSl9ZnVuY3Rpb24gbDQoZSl7dmFyIG4scix0LG8saTtmb3Iocj1uZXcgVChlLmNHcmFwaC5jR3JvdXBzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihuPWEoQyhyKSwxOTQpLG4ucmVmZXJlbmNlPW51bGwsaT1uLmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOyl0PWEoaS5uZXh0XzEoKSw4NiksbXModC5jR3JvdXBPZmZzZXQpLCghbi5yZWZlcmVuY2V8fHQuaGl0Ym94LnhfMDxuLnJlZmVyZW5jZS5oaXRib3gueF8wKSYmKG4ucmVmZXJlbmNlPXQpO2ZvcihvPW4uY05vZGVzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDg2KSx0LmNHcm91cE9mZnNldC54XzA9dC5oaXRib3gueF8wLW4ucmVmZXJlbmNlLmhpdGJveC54XzAsdC5jR3JvdXBPZmZzZXQueV8wPXQuaGl0Ym94LnlfMC1uLnJlZmVyZW5jZS5oaXRib3gueV8wfXJldHVybiBlfWZ1bmN0aW9uIEJwKGUsbil7dmFyIHI7aWYoZS5maW5pc2hlZCl0aHJvdyBiKG5ldyBybygoSnUoajgpLCJUaGUgIitqOC5zaW1wbGVOYW1lKyIgaW5zdGFuY2UgaGFzIGJlZW4gZmluaXNoZWQgYWxyZWFkeS4iKSkpO2lmKCFCb24oZS5jR3JhcGgsbikpdGhyb3cgYihuZXcgSW8oIlRoZSBkaXJlY3Rpb24gIituKyIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgQ0dyYXBoIGluc3RhbmNlLiIpKTtpZihuPT1lLmRpcmVjdGlvbilyZXR1cm4gZTtzd2l0Y2gocj1lLmRpcmVjdGlvbixlLmRpcmVjdGlvbj1uLHIub3JkaW5hbCl7Y2FzZSAwOnN3aXRjaChuLm9yZGluYWwpe2Nhc2UgMjpEXyhlKTticmVhaztjYXNlIDE6TzAoZSksRF8oZSk7YnJlYWs7Y2FzZSA0OkdwKGUpLERfKGUpO2JyZWFrO2Nhc2UgMzpHcChlKSxPMChlKSxEXyhlKX1icmVhaztjYXNlIDI6c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAxOk8wKGUpLFc4KGUpO2JyZWFrO2Nhc2UgNDpHcChlKSxEXyhlKTticmVhaztjYXNlIDM6R3AoZSksTzAoZSksRF8oZSl9YnJlYWs7Y2FzZSAxOnN3aXRjaChuLm9yZGluYWwpe2Nhc2UgMjpPMChlKSxXOChlKTticmVhaztjYXNlIDQ6TzAoZSksR3AoZSksRF8oZSk7YnJlYWs7Y2FzZSAzOk8wKGUpLEdwKGUpLE8wKGUpLERfKGUpfWJyZWFrO2Nhc2UgNDpzd2l0Y2gobi5vcmRpbmFsKXtjYXNlIDI6R3AoZSksRF8oZSk7YnJlYWs7Y2FzZSAxOkdwKGUpLE8wKGUpLERfKGUpO2JyZWFrO2Nhc2UgMzpPMChlKSxXOChlKX1icmVhaztjYXNlIDM6c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAyOk8wKGUpLEdwKGUpLERfKGUpO2JyZWFrO2Nhc2UgMTpPMChlKSxHcChlKSxPMChlKSxEXyhlKTticmVhaztjYXNlIDQ6TzAoZSksVzgoZSl9fXJldHVybiBlfWZ1bmN0aW9uIGEzKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7aWYoZS5maW5pc2hlZCl0aHJvdyBiKG5ldyBybygoSnUoajgpLCJUaGUgIitqOC5zaW1wbGVOYW1lKyIgaW5zdGFuY2UgaGFzIGJlZW4gZmluaXNoZWQgYWxyZWFkeS4iKSkpO2ZvcihlLmRpcmVjdGlvbj09KFdyKCksQnMpJiZCcChlLGFvKSxyPW5ldyBUKGUuY0dyYXBoLmNHcm91cHMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwxOTQpLG4ub3V0RGVncmVlPTA7Zm9yKHM9bmV3IFQoZS5jR3JhcGguY05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGk9YShDKHMpLDg2KSxpLnN0YXJ0UG9zPVZyLG89aS5jb25zdHJhaW50cy5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksODYpLCsrdC5jR3JvdXAub3V0RGVncmVlO2Zvcihqb24oZSksYz1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSw4NiksdS5yZXBvc2l0aW9uPSEwO3JldHVybiBlfWZ1bmN0aW9uIFVvbihlKXtyZXR1cm4gQnAoZSwoV3IoKSxhbykpLGUuZmluaXNoZWQ9ITAsZX1mdW5jdGlvbiB1VyhlKXtyZXR1cm4gRF8oZSksZX1mdW5jdGlvbiBPMChlKXt2YXIgbixyO2ZvcihyPW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDg2KSxuLmhpdGJveC54XzA9LW4uaGl0Ym94LnhfMC1uLmhpdGJveC53aWR0aF8wO2w0KGUpfWZ1bmN0aW9uIFc4KGUpe3ZhciBuLHIsdCxvLGkscyx1O2Zvcih1PW5ldyBzbix0PW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHQpLDg2KSxCbih1LG4sbmV3IFEpO2ZvcihvPW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihuPWEoQyhvKSw4Niksbi5zdGFydFBvcz1WcixzPW4uY29uc3RyYWludHMuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDg2KSxhKF9vKGp0KHUuaGFzaENvZGVNYXAsaSkpLDE1KS5hZGRfMihuKTtmb3Iocj1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw4Niksbi5jb25zdHJhaW50cy5jbGVhcl8wKCksbi5jb25zdHJhaW50cz1hKF9vKGp0KHUuaGFzaENvZGVNYXAsbikpLDE1KTtOeWUoZSl9ZnVuY3Rpb24gY1coZSxuKXtyZXR1cm4gZS5sb2NraW5nU3RyYXRlZ3k9bixlfWZ1bmN0aW9uIFdvbihlLG4pe3JldHVybiBlLnNwYWNpbmdzSGFuZGxlcj1uLGV9ZnVuY3Rpb24gR3AoZSl7dmFyIG4scix0O2ZvcihyPW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDg2KSx0PW4uaGl0Ym94LnhfMCxuLmhpdGJveC54XzA9bi5oaXRib3gueV8wLG4uaGl0Ym94LnlfMD10LHQ9bi5oaXRib3gud2lkdGhfMCxuLmhpdGJveC53aWR0aF8wPW4uaGl0Ym94LmhlaWdodCxuLmhpdGJveC5oZWlnaHQ9dCx0PW4uY0dyb3VwT2Zmc2V0LnhfMCxuLmNHcm91cE9mZnNldC54XzA9bi5jR3JvdXBPZmZzZXQueV8wLG4uY0dyb3VwT2Zmc2V0LnlfMD10O2w0KGUpfWZ1bmN0aW9uIEF5ZShlKXtzVygpO3ZhciBuLHIsdDtmb3IodGhpcy5jb25zdHJhaW50QWxnb3JpdGhtPUx5ZSx0aGlzLmRpcmVjdGlvbj0oV3IoKSxCcyksdGhpcy5zcGFjaW5nc0hhbmRsZXI9KGh5ZSgpLG15ZSksdGhpcy5jR3JhcGg9ZSxjVyh0aGlzLG5ldyBreWUpLGw0KHRoaXMpLHQ9bmV3IFQoZS5jTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw4Niksci5jR3JvdXB8fChuPW5ldyBIOChQKEkoUjgsMSksTWUsODYsMCxbcl0pKSxlZShlLmNHcm91cHMsbikpfXAoMTcyMSwxLHt9LEF5ZSksbC5maW5pc2hlZD0hMTt2YXIgTHllLGo4PWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLm9uZWQiLCJPbmVEaW1lbnNpb25hbENvbXBhY3RvciIsMTcyMSk7ZnVuY3Rpb24ga3llKCl7fXAoMTcyMiwxLHt9LGt5ZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBzVygpLHplKCksYShhKG4sNDIpLmZpcnN0LDg2KS5jR3JvdXAub3V0RGVncmVlIT0wfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ub25lZCIsIk9uZURpbWVuc2lvbmFsQ29tcGFjdG9yL2xhbWJkYSQwJFR5cGUiLDE3MjIpO2Z1bmN0aW9uIE95ZShlLG4pe3N3aXRjaChuLm9yZGluYWwpe2Nhc2UgMjpyZXR1cm4gZS5sZWZ0O2Nhc2UgMTpyZXR1cm4gZS5yaWdodDtjYXNlIDQ6cmV0dXJuIGUudXA7Y2FzZSAzOnJldHVybiBlLmRvd247ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gTXUoZSxuLHIsdCxvKXtlLmxlZnQ9bixlLnJpZ2h0PXIsZS51cD10LGUuZG93bj1vfWZ1bmN0aW9uIF9XKCl7TXUodGhpcywhMSwhMSwhMSwhMSl9cCg4MzMsMSx7fSxfVyksbC5kb3duPSExLGwubGVmdD0hMSxsLnJpZ2h0PSExLGwudXA9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ub25lZCIsIlF1YWRydXBsZXQiLDgzMyk7ZnVuY3Rpb24gam9uKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3IoXz1ocix0PW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHQpLDg2KSxfPVMuTWF0aC5taW4oXyxuLmNHcm91cC5yZWZlcmVuY2UuaGl0Ym94LnhfMCtuLmNHcm91cE9mZnNldC54XzApO2ZvcihtPW5ldyBwcixzPW5ldyBUKGUuY0dyYXBoLmNHcm91cHMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxOTQpLGkuc3RhcnRQb3M9XyxpLm91dERlZ3JlZT09MCYmYnIobSxpLG0udGFpbC5wcmV2LG0udGFpbCk7Zm9yKDttLnNpemVfMCE9MDspe2ZvcihpPWEobS5zaXplXzA9PTA/bnVsbDoocm4obS5zaXplXzAhPTApLFphKG0sbS5oZWFkZXIubmV4dF8wKSksMTk0KSxvPWkucmVmZXJlbmNlLmhpdGJveC54XzAsaD1pLmNOb2Rlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylkPWEoaC5uZXh0XzEoKSw4NiksRT1pLnN0YXJ0UG9zK2QuY0dyb3VwT2Zmc2V0LnhfMCxkLmNHcm91cC5yZXBvc2l0aW9ufHxkLmhpdGJveC54XzA8RT9kLnN0YXJ0UG9zPUU6ZC5zdGFydFBvcz1kLmhpdGJveC54XzA7Zm9yKG8tPWkucmVmZXJlbmNlLnN0YXJ0UG9zLGkuZGVsdGErPW8sZS5kaXJlY3Rpb249PShXcigpLG1vKXx8ZS5kaXJlY3Rpb249PSRzP2kuZGVsdGFOb3JtYWxpemVkKz1vOmkuZGVsdGFOb3JtYWxpemVkLT1vLGY9aS5jTm9kZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7Zi5oYXNOZXh0XzAoKTspZm9yKGQ9YShmLm5leHRfMSgpLDg2KSxjPWQuY29uc3RyYWludHMuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDg2KSxkYyhlLmRpcmVjdGlvbik/eT1lLnNwYWNpbmdzSGFuZGxlci5nZXRIb3Jpem9udGFsU3BhY2luZ18wKGQsdSk6eT1lLnNwYWNpbmdzSGFuZGxlci5nZXRWZXJ0aWNhbFNwYWNpbmdfMChkLHUpLHUuY0dyb3VwLnN0YXJ0UG9zPVMuTWF0aC5tYXgodS5jR3JvdXAuc3RhcnRQb3MsZC5zdGFydFBvcytkLmhpdGJveC53aWR0aF8wK3ktdS5jR3JvdXBPZmZzZXQueF8wKSx1LnJlcG9zaXRpb258fCh1LmNHcm91cC5zdGFydFBvcz1TLk1hdGgubWF4KHUuY0dyb3VwLnN0YXJ0UG9zLHUuaGl0Ym94LnhfMC11LmNHcm91cE9mZnNldC54XzApKSwtLXUuY0dyb3VwLm91dERlZ3JlZSx1LmNHcm91cC5vdXREZWdyZWU9PTAmJkxuKG0sdS5jR3JvdXApfWZvcihyPW5ldyBUKGUuY0dyYXBoLmNOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDg2KSxuLmhpdGJveC54XzA9bi5zdGFydFBvc31mdW5jdGlvbiBWb24oZSl7dmFyIG4scix0O2ZvcihyPW5ldyBUKGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw4NiksdD0oVmUoMCksMCksdD4wJiYoIShkYyhlLmNvbXBhY3Rvci5kaXJlY3Rpb24pJiZuLnNwYWNpbmdJZ25vcmUudXApJiYhKEFnKGUuY29tcGFjdG9yLmRpcmVjdGlvbikmJm4uc3BhY2luZ0lnbm9yZS5sZWZ0KSYmKG4uaGl0Ym94LnlfMC09Uy5NYXRoLm1heCgwLHQvMi0uNSkpLCEoZGMoZS5jb21wYWN0b3IuZGlyZWN0aW9uKSYmbi5zcGFjaW5nSWdub3JlLmRvd24pJiYhKEFnKGUuY29tcGFjdG9yLmRpcmVjdGlvbikmJm4uc3BhY2luZ0lnbm9yZS5yaWdodCkmJihuLmhpdGJveC5oZWlnaHQrPVMuTWF0aC5tYXgoMCx0LTEpKSl9ZnVuY3Rpb24gcW9uKGUsbil7ZS5jb21wYWN0b3I9bixLb24oZSl9ZnVuY3Rpb24gWW9uKGUpe3ZhciBuLHIsdDtmb3Iocj1uZXcgVChlLmNvbXBhY3Rvci5jR3JhcGguY05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksODYpLHQ9KFZlKDApLDApLHQ+MCYmKCEoZGMoZS5jb21wYWN0b3IuZGlyZWN0aW9uKSYmbi5zcGFjaW5nSWdub3JlLnVwKSYmIShBZyhlLmNvbXBhY3Rvci5kaXJlY3Rpb24pJiZuLnNwYWNpbmdJZ25vcmUubGVmdCkmJihuLmhpdGJveC55XzArPVMuTWF0aC5tYXgoMCx0LzItLjUpKSwhKGRjKGUuY29tcGFjdG9yLmRpcmVjdGlvbikmJm4uc3BhY2luZ0lnbm9yZS5kb3duKSYmIShBZyhlLmNvbXBhY3Rvci5kaXJlY3Rpb24pJiZuLnNwYWNpbmdJZ25vcmUucmlnaHQpJiYobi5oaXRib3guaGVpZ2h0LT10LTEpKX1mdW5jdGlvbiBLb24oZSl7dmFyIG4scix0O2ZvcihWb24oZSksdD1uZXcgUSxyPW5ldyBUKGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw4NiksZWUodCxuZXcgZFcobiwhMCkpLGVlKHQsbmV3IGRXKG4sITEpKTtab24oZS5jb25zdHJhaW50c1NjYW5saW5lSGFuZGxlciksczModCxlLmNvbnN0cmFpbnRzU2NhbmxpbmVDb21wYXJhdG9yLG5ldyBlYShQKEkobDMsMSksTWUsMzgyLDAsW2UuY29uc3RyYWludHNTY2FubGluZUhhbmRsZXJdKSkpLFlvbihlKX1mdW5jdGlvbiBNeWUoKXt0aGlzLmNvbnN0cmFpbnRzU2NhbmxpbmVDb21wYXJhdG9yPW5ldyBGeWUsdGhpcy5jb25zdHJhaW50c1NjYW5saW5lSGFuZGxlcj1uZXcgUnllKHRoaXMpfWZ1bmN0aW9uIFhvbihlLG4pe3ZhciByLHQsbztpZih0PWUubm9kZS5oaXRib3gueV8wLGUubG93fHwodCs9ZS5ub2RlLmhpdGJveC5oZWlnaHQpLG89bi5ub2RlLmhpdGJveC55XzAsbi5sb3d8fChvKz1uLm5vZGUuaGl0Ym94LmhlaWdodCkscj1pcih0LG8pLHI9PTApe2lmKCFlLmxvdyYmbi5sb3cpcmV0dXJuLTE7aWYoIW4ubG93JiZlLmxvdylyZXR1cm4gMX1yZXR1cm4gcn1wKDE4OTgsMSx7fSxNeWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLm9uZWQuYWxncyIsIlNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0b3IiLDE4OTgpO3ZhciBsMz1Dcigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ucmVjdGh1bGwiLCJTY2FubGluZS9FdmVudEhhbmRsZXIiKTtmdW5jdGlvbiBKb24oZSxuKXt2YXIgcix0LG87bi5sb3c/KEJDKGUuaW50ZXJ2YWxzLG4ubm9kZSksZS5jYW5kW24ubm9kZS5pZF8wXT1hKHhrKGUuaW50ZXJ2YWxzLG4ubm9kZSksODYpLHI9YShJayhlLmludGVydmFscyxuLm5vZGUpLDg2KSxyJiYoZS5jYW5kW3IuaWRfMF09bi5ub2RlKSk6KHQ9YSh4ayhlLmludGVydmFscyxuLm5vZGUpLDg2KSx0JiZ0PT1lLmNhbmRbbi5ub2RlLmlkXzBdJiZ0LmNHcm91cCYmdC5jR3JvdXAhPW4ubm9kZS5jR3JvdXAmJnQuY29uc3RyYWludHMuYWRkXzIobi5ub2RlKSxvPWEoSWsoZS5pbnRlcnZhbHMsbi5ub2RlKSw4NiksbyYmZS5jYW5kW28uaWRfMF09PW4ubm9kZSYmby5jR3JvdXAmJm8uY0dyb3VwIT1uLm5vZGUuY0dyb3VwJiZuLm5vZGUuY29uc3RyYWludHMuYWRkXzIobyksUGsoZS5pbnRlcnZhbHMsbi5ub2RlKSl9ZnVuY3Rpb24gWm9uKGUpe3ZhciBuLHIsdDtmb3IoZS5pbnRlcnZhbHMubWFwXzAuY2xlYXJfMCgpLGUuY2FuZD1CKFI4LE1lLDg2LGUudGhpcyQwMS5jb21wYWN0b3IuY0dyYXBoLmNOb2Rlcy5hcnJheS5sZW5ndGgsMCwxKSxuPTAsdD1uZXcgVChlLnRoaXMkMDEuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw4Niksci5pZF8wPW4rK31mdW5jdGlvbiBSeWUoZSl7dGhpcy50aGlzJDAxPWUsdGhpcy5pbnRlcnZhbHM9bmV3IEZjKGEodm4obmV3IER5ZSksNTApKX1mdW5jdGlvbiBRb24oZSxuKXtyZXR1cm4gaXIoZS5oaXRib3gueF8wK2UuaGl0Ym94LndpZHRoXzAvMixuLmhpdGJveC54XzArbi5oaXRib3gud2lkdGhfMC8yKX1wKDE4OTksMSx7MzgyOjF9LFJ5ZSksbC5oYW5kbGU9ZnVuY3Rpb24obil7Sm9uKHRoaXMsYShuLDQ3NikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5vbmVkLmFsZ3MiLCJTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdG9yL0NvbnN0cmFpbnRzU2NhbmxpbmVIYW5kbGVyIiwxODk5KTtmdW5jdGlvbiBEeWUoKXt9cChoMCwxLE5uLER5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gUW9uKGEobiw4NiksYShyLDg2KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ub25lZC5hbGdzIiwiU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRvci9Db25zdHJhaW50c1NjYW5saW5lSGFuZGxlci9sYW1iZGEkMCRUeXBlIixoMCk7ZnVuY3Rpb24gZFcoZSxuKXt0aGlzLm5vZGU9ZSx0aGlzLmxvdz1ufXAoNDc2LDEsezQ3NjoxfSxkVyksbC5sb3c9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ub25lZC5hbGdzIiwiU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRvci9UaW1lc3RhbXAiLDQ3Nik7ZnVuY3Rpb24gRnllKCl7fXAoMTkwMSwxLE5uLEZ5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gWG9uKGEobiw0NzYpLGEociw0NzYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5vbmVkLmFsZ3MiLCJTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdG9yL2xhbWJkYSQwJFR5cGUiLDE5MDEpO2Z1bmN0aW9uIGt5KGUsbil7dGhpcy54XzA9ZSx0aGlzLnlfMD1ufWZ1bmN0aW9uIGZXKGUsbixyKXtreS5jYWxsKHRoaXMsZSxuKSx0aGlzLnF1YWRyYW50PXJ9cCgxNDgsMSx7MTQ4OjF9LGt5LGZXKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBuPT1udWxsfHxlaW4hPXdhKG4pPyExOihyPWEobiwxNDgpLFVvKHRoaXMueF8wLHIueF8wKSYmVW8odGhpcy55XzAsci55XzApKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIGtDKFAoSShRciwxKSxNZSwxLDUsW3RoaXMueF8wLHRoaXMueV8wXSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iKCIrdGhpcy54XzArIiwgIit0aGlzLnlfMCsodGhpcy5jb252ZXg/ImN4IjoiIikrdGhpcy5xdWFkcmFudCsiKSJ9LGwuY29udmV4PSEwLGwueF8wPTAsbC55XzA9MDt2YXIgZWluPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLnJlY3RodWxsIiwiUG9pbnQiLDE0OCk7ZnVuY3Rpb24gT3koKXtPeT1GLCQxPW5ldyBzNCgiUTEiLDApLG1mPW5ldyBzNCgiUTQiLDEpLGhmPW5ldyBzNCgiUTIiLDIpLEhwPW5ldyBzNCgiUTMiLDMpfWZ1bmN0aW9uIG5pbihlKXtyZXR1cm4gZT09JDF8fGU9PW1mfWZ1bmN0aW9uIHJpbihlKXtyZXR1cm4gZT09JDF8fGU9PWhmfWZ1bmN0aW9uIHM0KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gdGluKGUsbil7cmV0dXJuIE95KCksZT09JDEmJm49PW1mfHxlPT1tZiYmbj09JDF8fGU9PUhwJiZuPT1oZnx8ZT09aGYmJm49PUhwfWZ1bmN0aW9uIG9pbihlLG4pe3JldHVybiBPeSgpLGU9PSQxJiZuPT1oZnx8ZT09JDEmJm49PUhwfHxlPT1tZiYmbj09SHB8fGU9PW1mJiZuPT1oZn1mdW5jdGlvbiBpaW4oZSl7cmV0dXJuIE95KCksd24oKCR5ZSgpLEJ5ZSksZSl9ZnVuY3Rpb24gYWluKCl7cmV0dXJuIE95KCksUChJKHp5ZSwxKSxXLDQxNiwwLFskMSxtZixoZixIcF0pfXAoNDE2LDIyLHszOjEsMzQ6MSwyMjoxLDQxNjoxfSxzNCk7dmFyICQxLGhmLEhwLG1mLHp5ZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ucmVjdGh1bGwiLCJQb2ludC9RdWFkcmFudCIsNDE2LGduLGFpbixpaW4pO2Z1bmN0aW9uICR5ZSgpeyR5ZT1GLEJ5ZT15bigoT3koKSxQKEkoenllLDEpLFcsNDE2LDAsWyQxLG1mLGhmLEhwXSkpKX12YXIgQnllO2Z1bmN0aW9uIG1FKCl7bUU9RixXeWU9bmV3IEt5ZSxqeWU9bmV3IFh5ZSxIeWU9bmV3IEp5ZSxVeWU9bmV3IFp5ZSxWeWU9bmV3IFF5ZX1mdW5jdGlvbiBsaW4oZSl7dmFyIG47cmV0dXJuIG49bmV3IFl5ZShlKSxzMyhlLmh1bGwsVnllLG5ldyBlYShQKEkobDMsMSksTWUsMzgyLDAsW25dKSkpLG4ucXVldWVkJiZlZShuLnJlY3RzLG4ucXVldWVkKSxuLnJlY3RzfWZ1bmN0aW9uIEd5ZSgpe3RoaXMuaHVsbD1uZXcgUX1mdW5jdGlvbiBWOChlLG4pe3ZhciByLHQsbyxpO2ZvcihpPW5ldyBwdChlLDApLHI9KHJuKGkuaTxpLnRoaXMkMDFfMC5zaXplXzEoKSksYShpLnRoaXMkMDFfMC5nZXRfMChpLmxhc3Q9aS5pKyspLDE0OCkpO2kuaTxpLnRoaXMkMDFfMC5zaXplXzEoKTspdD0ocm4oaS5pPGkudGhpcyQwMV8wLnNpemVfMSgpKSxhKGkudGhpcyQwMV8wLmdldF8wKGkubGFzdD1pLmkrKyksMTQ4KSksbz1uZXcgZlcodC54XzAsci55XzAsbikscm4oaS5pPjApLGkudGhpcyQwMS5nZXRfMChpLmxhc3Q9LS1pLmkpLHJmKGksbykscm4oaS5pPGkudGhpcyQwMV8wLnNpemVfMSgpKSxpLnRoaXMkMDFfMC5nZXRfMChpLmxhc3Q9aS5pKyspLG8uY29udmV4PSExLHI9dH1mdW5jdGlvbiBzaW4oZSxuKXtyZXR1cm4gbUUoKSxlLnhfMD09bi54XzA/aXIobi55XzAsZS55XzApOmlyKGUueF8wLG4ueF8wKX1mdW5jdGlvbiB1aW4oZSxuKXtyZXR1cm4gbUUoKSxlLnhfMD09bi54XzA/aXIoZS55XzAsbi55XzApOmlyKGUueF8wLG4ueF8wKX1mdW5jdGlvbiBjaW4oZSxuKXtyZXR1cm4gbUUoKSxlLnhfMD09bi54XzA/aXIobi55XzAsZS55XzApOmlyKG4ueF8wLGUueF8wKX1mdW5jdGlvbiBfaW4oZSxuKXtyZXR1cm4gbUUoKSxlLnhfMD09bi54XzA/aXIoZS55XzAsbi55XzApOmlyKG4ueF8wLGUueF8wKX1mdW5jdGlvbiBkaW4oZSxuKXttRSgpO3ZhciByO2lmKGUueF8wPT1uLnhfMCl7aWYoZS5xdWFkcmFudD09bi5xdWFkcmFudHx8dGluKGUucXVhZHJhbnQsbi5xdWFkcmFudCkpe2lmKHI9bmluKGUucXVhZHJhbnQpPzE6LTEsZS5jb252ZXgmJiFuLmNvbnZleClyZXR1cm4gcjtpZighZS5jb252ZXgmJm4uY29udmV4KXJldHVybi1yfXJldHVybiBxbyhlLnF1YWRyYW50Lm9yZGluYWwsbi5xdWFkcmFudC5vcmRpbmFsKX1lbHNlIHJldHVybiBpcihlLnhfMCxuLnhfMCl9ZnVuY3Rpb24gZmluKGUpe21FKCk7dmFyIG4scix0LG8saSxzLHU7Zm9yKHU9bmV3IEd5ZSxyPW5ldyBUKGUpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwxNDgpLCghdS54TWF4MXx8bi54XzA+PXUueE1heDEueF8wKSYmKHUueE1heDE9biksKCF1LnhNaW4xfHxuLnhfMDw9dS54TWluMS54XzApJiYodS54TWluMj11LnhNaW4xLHUueE1pbjE9biksKCF1LnlNYXgxfHxuLnlfMD49dS55TWF4MS55XzApJiYodS55TWF4MT1uKSwoIXUueU1pbjF8fG4ueV8wPD11LnlNaW4xLnlfMCkmJih1LnlNaW4xPW4pO3JldHVybiB0PW5ldyB1NCgoT3koKSwkMSkpLHMzKGUsanllLG5ldyBlYShQKEkobDMsMSksTWUsMzgyLDAsW3RdKSkpLHM9bmV3IHU0KG1mKSxzMyhlLFd5ZSxuZXcgZWEoUChJKGwzLDEpLE1lLDM4MiwwLFtzXSkpKSxvPW5ldyB1NChoZiksczMoZSxVeWUsbmV3IGVhKFAoSShsMywxKSxNZSwzODIsMCxbb10pKSksaT1uZXcgdTQoSHApLHMzKGUsSHllLG5ldyBlYShQKEkobDMsMSksTWUsMzgyLDAsW2ldKSkpLFY4KHQucG9pbnRzLCQxKSxWOChvLnBvaW50cyxoZiksVjgoaS5wb2ludHMsSHApLFY4KHMucG9pbnRzLG1mKSx1Lmh1bGwuYXJyYXkubGVuZ3RoPTAscXIodS5odWxsLHQucG9pbnRzKSxxcih1Lmh1bGwscWEoby5wb2ludHMpKSxxcih1Lmh1bGwsaS5wb2ludHMpLHFyKHUuaHVsbCxxYShzLnBvaW50cykpLHV9cCgxNzA4LDEse30sR3llKSxsLnhNYXgxPW51bGwsbC54TWluMT1udWxsLGwueE1pbjI9bnVsbCxsLnlNYXgxPW51bGwsbC55TWluMT1udWxsO3ZhciBIeWUsVXllLFd5ZSxqeWUsVnllO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLnJlY3RodWxsIiwiUmVjdGlsaW5lYXJDb252ZXhIdWxsIiwxNzA4KTtmdW5jdGlvbiBwVygpe3BXPUYsZ1c9bmV3IHF5ZX1mdW5jdGlvbiBwaW4oZSxuKXtlLmNvbXBhcmUuY29tcGFyZV8xKG4ueV8wLGUubWF4aW1hbFkpPjAmJihlZShlLnBvaW50cyxuZXcgZlcobi54XzAsbi55XzAsZS5xdWFkcmFudCkpLGUubWF4aW1hbFk9bi55XzApfWZ1bmN0aW9uIHU0KGUpe3N3aXRjaChwVygpLHRoaXMucG9pbnRzPW5ldyBRLHRoaXMucXVhZHJhbnQ9ZSxlLm9yZGluYWwpe2Nhc2UgMDpjYXNlIDI6dGhpcy5jb21wYXJlPUhCKGdXKSx0aGlzLm1heGltYWxZPWhyO2JyZWFrO2Nhc2UgMzpjYXNlIDE6dGhpcy5jb21wYXJlPWdXLHRoaXMubWF4aW1hbFk9VnJ9fWZ1bmN0aW9uIGdpbihlLG4pe3JldHVybiBwVygpLGlyKChWZShlKSxlKSwoVmUobiksbikpfXAoNTgzLDEsezM4MjoxfSx1NCksbC5oYW5kbGU9ZnVuY3Rpb24obil7cGluKHRoaXMsYShuLDE0OCkpfSxsLm1heGltYWxZPTA7dmFyIGdXO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLnJlY3RodWxsIiwiUmVjdGlsaW5lYXJDb252ZXhIdWxsL01heGltYWxFbGVtZW50c0V2ZW50SGFuZGxlciIsNTgzKTtmdW5jdGlvbiBxeWUoKXt9cCgxNzEwLDEsTm4scXllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBnaW4oJChuKSwkKHIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5yZWN0aHVsbCIsIlJlY3RpbGluZWFyQ29udmV4SHVsbC9NYXhpbWFsRWxlbWVudHNFdmVudEhhbmRsZXIvbGFtYmRhJDAkVHlwZSIsMTcxMCk7ZnVuY3Rpb24gaGluKGUsbil7dmFyIHI7ZS5xdWV1ZWQmJihuLnhfMCE9ZS5xdWV1ZWRQbnQueF8wfHxvaW4oZS5xdWV1ZWRQbnQucXVhZHJhbnQsbi5xdWFkcmFudCkpJiYoZWUoZS5yZWN0cyxlLnF1ZXVlZCksZS5sYXN0WD1lLnF1ZXVlZC54XzArZS5xdWV1ZWQud2lkdGhfMCxlLnF1ZXVlZD1udWxsLGUucXVldWVkUG50PW51bGwpLHJpbihuLnF1YWRyYW50KT9lLm1pblk9bjplLm1heFk9biwobi5xdWFkcmFudD09KE95KCksJDEpJiYhbi5jb252ZXh8fG4ucXVhZHJhbnQ9PWhmJiZuLmNvbnZleHx8bi5xdWFkcmFudD09SHAmJm4uY29udmV4fHxuLnF1YWRyYW50PT1tZiYmIW4uY29udmV4KSYmZS5taW5ZJiZlLm1heFkmJihyPW5ldyB0bChlLmxhc3RYLGUubWluWS55XzAsbi54XzAtZS5sYXN0WCxlLm1heFkueV8wLWUubWluWS55XzApLGUucXVldWVkPXIsZS5xdWV1ZWRQbnQ9bil9ZnVuY3Rpb24gWXllKGUpe3RoaXMudGhpcyQwMT1lLHRoaXMucmVjdHM9bmV3IFEsdGhpcy5sYXN0WD1TLk1hdGgubWluKHRoaXMudGhpcyQwMS54TWluMS54XzAsdGhpcy50aGlzJDAxLnhNaW4yLnhfMCl9cCgxNzA5LDEsezM4MjoxfSxZeWUpLGwuaGFuZGxlPWZ1bmN0aW9uKG4pe2hpbih0aGlzLGEobiwxNDgpKX0sbC5sYXN0WD0wLGwubWF4WT1udWxsLGwubWluWT1udWxsLGwucXVldWVkPW51bGwsbC5xdWV1ZWRQbnQ9bnVsbCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5yZWN0aHVsbCIsIlJlY3RpbGluZWFyQ29udmV4SHVsbC9SZWN0YW5nbGVFdmVudEhhbmRsZXIiLDE3MDkpO2Z1bmN0aW9uIEt5ZSgpe31wKDE3MTEsMSxObixLeWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHNpbihhKG4sMTQ4KSxhKHIsMTQ4KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ucmVjdGh1bGwiLCJSZWN0aWxpbmVhckNvbnZleEh1bGwvbGFtYmRhJDAkVHlwZSIsMTcxMSk7ZnVuY3Rpb24gWHllKCl7fXAoMTcxMiwxLE5uLFh5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gdWluKGEobiwxNDgpLGEociwxNDgpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5yZWN0aHVsbCIsIlJlY3RpbGluZWFyQ29udmV4SHVsbC9sYW1iZGEkMSRUeXBlIiwxNzEyKTtmdW5jdGlvbiBKeWUoKXt9cCgxNzEzLDEsTm4sSnllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBjaW4oYShuLDE0OCksYShyLDE0OCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wYWN0aW9uLnJlY3RodWxsIiwiUmVjdGlsaW5lYXJDb252ZXhIdWxsL2xhbWJkYSQyJFR5cGUiLDE3MTMpO2Z1bmN0aW9uIFp5ZSgpe31wKDE3MTQsMSxObixaeWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIF9pbihhKG4sMTQ4KSxhKHIsMTQ4KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ucmVjdGh1bGwiLCJSZWN0aWxpbmVhckNvbnZleEh1bGwvbGFtYmRhJDMkVHlwZSIsMTcxNCk7ZnVuY3Rpb24gUXllKCl7fXAoMTcxNSwxLE5uLFF5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gZGluKGEobiwxNDgpLGEociwxNDgpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcGFjdGlvbi5yZWN0aHVsbCIsIlJlY3RpbGluZWFyQ29udmV4SHVsbC9sYW1iZGEkNCRUeXBlIiwxNzE1KTtmdW5jdGlvbiBtaW4oZSl7dmFyIG4scix0LG87Zm9yKE5lKCksRHIoZS5wb2ludHMsZS5jb21wYXJhdG9yKSxvPW5ldyBUKGUucG9pbnRzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9QyhvKSxyPW5ldyBUKGUuZXZlbnRIYW5kbGVycyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDM4Miksbi5oYW5kbGUodCl9ZnVuY3Rpb24gZXdlKGUsbixyKXt0aGlzLmNvbXBhcmF0b3I9bix0aGlzLnBvaW50cz1lLHRoaXMuZXZlbnRIYW5kbGVycz0odm4ociksbmV3IFFpKHIpKX1mdW5jdGlvbiBzMyhlLG4scil7dmFyIHQ7dD0odm4oZSksbmV3IFFpKGUpKSxtaW4obmV3IGV3ZSh0LG4scikpfXAoMTcxNiwxLHt9LGV3ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBhY3Rpb24ucmVjdGh1bGwiLCJTY2FubGluZSIsMTcxNik7ZnVuY3Rpb24gbndlKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtO2ZvcihzPW1kKG4ub2Zmc2V0LHIsdCksZj1uZXcgVChuLmxheWVybGVzc05vZGVzKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihkPWEoQyhmKSwxMCksS24oZC5wb3MscyksbT1uZXcgVChkLnBvcnRzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGg9YShDKG0pLDEyKSxpPW5ldyBUKGgub3V0Z29pbmdFZGdlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwxOCksVWYoby5iZW5kUG9pbnRzLHMpLHU9YSh3KG8sKG9lKCksaW8pKSw3NSksdSYmVWYodSxzKSxfPW5ldyBUKG8ubGFiZWxzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksNzIpLEtuKGMucG9zLHMpO2VlKGUubGF5ZXJsZXNzTm9kZXMsZCksZC5ncmFwaF8wPWV9fWZ1bmN0aW9uIGhXKGUsbil7dmFyIHIsdDtmb3IodD1uLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwzNiksbndlKGUsciwwLDApfWZ1bmN0aW9uIE15KGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IoaT1uZXcgWShuLHIpLGQ9bmV3IFQoZS5sYXllcmxlc3NOb2Rlcyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihfPWEoQyhkKSwxMCksS24oXy5wb3MsaSksaD1uZXcgVChfLnBvcnRzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGY9YShDKGgpLDEyKSxvPW5ldyBUKGYub3V0Z29pbmdFZGdlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih0PWEoQyhvKSwxOCksVWYodC5iZW5kUG9pbnRzLGkpLHM9YSh3KHQsKG9lKCksaW8pKSw3NSkscyYmVWYocyxpKSxjPW5ldyBUKHQubGFiZWxzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoYyksNzIpLEtuKHUucG9zLGkpfWZ1bmN0aW9uIHpjKGUsbixyKXt2YXIgdCxvO2ZvcihvPWUuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDM2KSxNeSh0LG4scil9cCgyMTA0LDEse30pLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiQWJzdHJhY3RHcmFwaFBsYWNlciIsMjEwNCk7ZnVuY3Rpb24gcTgoKXtxOD1GLGFyPW5ldyBFMSxiZShhciwocmUoKSxVcyksbGkpLGJlKGFyLGJsLGxpKSxiZShhcixibCxPaSksYmUoYXIsaWwsVmkpLGJlKGFyLGlsLGxpKSxiZShhcixRbCxsaSksYmUoYXIsUWwsc2EpLGJlKGFyLHphLExpKSxiZShhcix6YSxsaSksYmUoYXIsa2ksdmkpLGJlKGFyLGtpLGxpKSxiZShhcixraSxzYSksYmUoYXIsa2ksTGkpLGJlKGFyLHZpLGtpKSxiZShhcix2aSxPaSksYmUoYXIsdmksVmkpLGJlKGFyLHZpLGxpKSxiZShhcixlcyxlcyksYmUoYXIsZXMsc2EpLGJlKGFyLGVzLE9pKSxiZShhcixsYSxsYSksYmUoYXIsbGEsc2EpLGJlKGFyLGxhLFZpKSxiZShhciwkYSwkYSksYmUoYXIsJGEsTGkpLGJlKGFyLCRhLE9pKSxiZShhcixhbCxhbCksYmUoYXIsYWwsTGkpLGJlKGFyLGFsLFZpKSxiZShhcixzYSxRbCksYmUoYXIsc2Esa2kpLGJlKGFyLHNhLGVzKSxiZShhcixzYSxsYSksYmUoYXIsc2EsbGkpLGJlKGFyLHNhLHNhKSxiZShhcixzYSxPaSksYmUoYXIsc2EsVmkpLGJlKGFyLExpLHphKSxiZShhcixMaSxraSksYmUoYXIsTGksJGEpLGJlKGFyLExpLGFsKSxiZShhcixMaSxMaSksYmUoYXIsTGksT2kpLGJlKGFyLExpLFZpKSxiZShhcixMaSxsaSksYmUoYXIsT2ksYmwpLGJlKGFyLE9pLHZpKSxiZShhcixPaSxlcyksYmUoYXIsT2ksJGEpLGJlKGFyLE9pLHNhKSxiZShhcixPaSxMaSksYmUoYXIsT2ksT2kpLGJlKGFyLE9pLGxpKSxiZShhcixWaSxpbCksYmUoYXIsVmksdmkpLGJlKGFyLFZpLGxhKSxiZShhcixWaSxhbCksYmUoYXIsVmksc2EpLGJlKGFyLFZpLExpKSxiZShhcixWaSxWaSksYmUoYXIsVmksbGkpLGJlKGFyLGxpLFVzKSxiZShhcixsaSxibCksYmUoYXIsbGksaWwpLGJlKGFyLGxpLFFsKSxiZShhcixsaSx6YSksYmUoYXIsbGksa2kpLGJlKGFyLGxpLHZpKSxiZShhcixsaSxzYSksYmUoYXIsbGksTGkpLGJlKGFyLGxpLE9pKSxiZShhcixsaSxWaSksYmUoYXIsbGksbGkpfWZ1bmN0aW9uIHJ3ZShlKXtlLmNvbXBvbmVudHM9bmV3IFI2fWZ1bmN0aW9uIEFpKGUsbil7cmV0dXJuIGEoWm4oZS5jb21wb25lbnRzLG4pLDE1KX1mdW5jdGlvbiB0d2UoZSl7cTgoKSxyd2UodGhpcyksdGhpcy5hZGRfNChlKX1wKDMzNSwxLHszMzU6MX0sdHdlKSxsLmFkZF80PWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNhbkFkZChuKT8oYmUodGhpcy5jb21wb25lbnRzLGEodyhuLChLKCksc2MpKSwyMSksbiksITApOiExfSxsLmNhbkFkZD1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtmb3Iocj1hKHcobiwoSygpLHNjKSksMjEpLGk9YShabihhcixyKSwyMSksbz1pLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOylpZih0PWEoby5uZXh0XzEoKSwyMSksIWEoWm4odGhpcy5jb21wb25lbnRzLHQpLDE1KS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9O3ZhciBhcjtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudEdyb3VwIiwzMzUpO2Z1bmN0aW9uIG93ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZTtyZXR1cm4gZj15aW4oQWkoZSwocmUoKSxVcykpLG4pLHk9VXAoQWkoZSxRbCksbiksTT1VcChBaShlLHphKSxuKSx2ZT1jNChBaShlLGJsKSxuKSxoPWM0KEFpKGUsaWwpLG4pLEE9VXAoQWkoZSxlcyksbiksRT1VcChBaShlLGxhKSxuKSxxPVVwKEFpKGUsJGEpLG4pLEg9VXAoQWkoZSxhbCksbiksd2U9YzQoQWkoZSx2aSksbikseD1VcChBaShlLGtpKSxuKSxrPVVwKEFpKGUsc2EpLG4pLG5lPVVwKEFpKGUsTGkpLG4pLERlPWM0KEFpKGUsT2kpLG4pLG09YzQoQWkoZSxWaSksbiksdj1VcChBaShlLGxpKSxuKSxyPXZnKFAoSShjdCwxKSxYdCwyOCwxNSxbQS54XzAsdmUueF8wLHEueF8wLERlLnhfMF0pKSx0PXZnKFAoSShjdCwxKSxYdCwyOCwxNSxbeS54XzAsZi54XzAsTS54XzAsdi54XzBdKSksbz14LnhfMCxpPXZnKFAoSShjdCwxKSxYdCwyOCwxNSxbRS54XzAsaC54XzAsSC54XzAsbS54XzBdKSksXz12ZyhQKEkoY3QsMSksWHQsMjgsMTUsW0EueV8wLHkueV8wLEUueV8wLGsueV8wXSkpLGM9dmcoUChJKGN0LDEpLFh0LDI4LDE1LFt2ZS55XzAsZi55XzAsaC55XzAsdi55XzBdKSksZD13ZS55XzAsdT12ZyhQKEkoY3QsMSksWHQsMjgsMTUsW3EueV8wLE0ueV8wLEgueV8wLG5lLnlfMF0pKSx6YyhBaShlLFVzKSxyK28sXytkKSx6YyhBaShlLGxpKSxyK28sXytkKSx6YyhBaShlLFFsKSxyK28sMCksemMoQWkoZSx6YSkscitvLF8rZCtjKSx6YyhBaShlLGJsKSwwLF8rZCksemMoQWkoZSxpbCkscitvK3QsXytkKSx6YyhBaShlLGxhKSxyK28rdCwwKSx6YyhBaShlLCRhKSwwLF8rZCtjKSx6YyhBaShlLGFsKSxyK28rdCxfK2QrYyksemMoQWkoZSx2aSksMCxfKSx6YyhBaShlLGtpKSxyLDApLHpjKEFpKGUsTGkpLDAsXytkK2MpLHpjKEFpKGUsVmkpLHIrbyt0LDApLHM9bmV3IG10LHMueF8wPXZnKFAoSShjdCwxKSxYdCwyOCwxNSxbcit0K28raSx3ZS54XzAsay54XzAsbmUueF8wXSkpLHMueV8wPXZnKFAoSShjdCwxKSxYdCwyOCwxNSxbXytjK2QrdSx4LnlfMCxEZS55XzAsbS55XzBdKSksc31mdW5jdGlvbiBVcChlLG4pe3ZhciByLHQsbztmb3Iobz1uZXcgbXQsdD1lLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwzNiksTXkocixvLnhfMCwwKSxvLnhfMCs9ci5zaXplXzAueF8wK24sby55XzA9Uy5NYXRoLm1heChvLnlfMCxyLnNpemVfMC55XzApO3JldHVybiBvLnlfMD4wJiYoby55XzArPW4pLG99ZnVuY3Rpb24geWluKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKGUuaXNFbXB0eSgpKXJldHVybiBuZXcgbXQ7Zm9yKF89MCxmPTAsbz1lLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSwzNiksaT10LnNpemVfMCxfPVMuTWF0aC5tYXgoXyxpLnhfMCksZis9aS54XzAqaS55XzA7Zm9yKF89Uy5NYXRoLm1heChfLFMuTWF0aC5zcXJ0KGYpKlIoJCh3KGEoZS5pdGVyYXRvcl8wKCkubmV4dF8xKCksMzYpLChvZSgpLGdQKSkpKSksaD0wLG09MCxjPTAscj1uLHU9ZS5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMzYpLGQ9cy5zaXplXzAsaCtkLnhfMD5fJiYoaD0wLG0rPWMrbixjPTApLE15KHMsaCxtKSxyPVMuTWF0aC5tYXgocixoK2QueF8wKSxjPVMuTWF0aC5tYXgoYyxkLnlfMCksaCs9ZC54XzArbjtyZXR1cm4gbmV3IFkocituLG0rYytuKX1mdW5jdGlvbiBjNChlLG4pe3ZhciByLHQsbztmb3Iobz1uZXcgbXQsdD1lLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwzNiksTXkociwwLG8ueV8wKSxvLnlfMCs9ci5zaXplXzAueV8wK24sby54XzA9Uy5NYXRoLm1heChvLnhfMCxyLnNpemVfMC54XzApO3JldHVybiBvLnhfMD4wJiYoby54XzArPW4pLG99ZnVuY3Rpb24gbVcoKXt0aGlzLmNvbXBvbmVudEdyb3Vwcz1uZXcgUX1wKDc3OSwyMTA0LHt9LG1XKSxsLmFkZENvbXBvbmVudD1mdW5jdGlvbihuKXt2YXIgcix0O2Zvcih0PW5ldyBUKHRoaXMuY29tcG9uZW50R3JvdXBzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYocj1hKEModCksMzM1KSxyLmFkZF80KG4pKXJldHVybjtlZSh0aGlzLmNvbXBvbmVudEdyb3VwcyxuZXcgdHdlKG4pKX0sbC5jb21iaW5lPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEU7aWYodGhpcy5jb21wb25lbnRHcm91cHMuYXJyYXkubGVuZ3RoPTAsci5sYXllcmxlc3NOb2Rlcy5hcnJheS5sZW5ndGg9MCxuLmlzRW1wdHkoKSl7ci5zaXplXzAueF8wPTAsci5zaXplXzAueV8wPTA7cmV0dXJufWZvcih1PWEobi5nZXRfMCgwKSwzNiksZ28ocix1KSxpPW4uaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDM2KSx0aGlzLmFkZENvbXBvbmVudChvKTtmb3IoRT1uZXcgbXQscz1SKCQodyh1LChvZSgpLEQzKSkpKSxkPW5ldyBUKHRoaXMuY29tcG9uZW50R3JvdXBzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoZCksMzM1KSxmPW93ZShjLHMpLHpjKG9JKGMuY29tcG9uZW50cyksRS54XzAsRS55XzApLEUueF8wKz1mLnhfMCxFLnlfMCs9Zi55XzA7aWYoci5zaXplXzAueF8wPUUueF8wLXMsci5zaXplXzAueV8wPUUueV8wLXMsYWUoaWUodyh1LGhQKSkpJiZEKHcodSx1YykpPT09RCgoZmMoKSxOdykpKXtmb3IoeT1uLml0ZXJhdG9yXzAoKTt5Lmhhc05leHRfMCgpOyloPWEoeS5uZXh0XzEoKSwzNiksTXkoaCxoLm9mZnNldC54XzAsaC5vZmZzZXQueV8wKTtmb3IodD1uZXcgSjgsRVcodCxuLHMpLG09bi5pdGVyYXRvcl8wKCk7bS5oYXNOZXh0XzAoKTspaD1hKG0ubmV4dF8xKCksMzYpLEtuKG1zKGgub2Zmc2V0KSx0LnlldEFub3RoZXJPZmZzZXQpO0tuKG1zKHIuc2l6ZV8wKSx0LmNvbXBhY3RlZEdyYXBoU2l6ZSl9Zm9yKF89bmV3IFQodGhpcy5jb21wb25lbnRHcm91cHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSwzMzUpLGhXKHIsb0koYy5jb21wb25lbnRzKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiQ29tcG9uZW50R3JvdXBHcmFwaFBsYWNlciIsNzc5KTtmdW5jdGlvbiBpd2UoZSxuKXt2YXIgcjtlLmNvbXBvbmVudEdyb3Vwcy5hcnJheS5sZW5ndGg+MCYmKHI9YShsZShlLmNvbXBvbmVudEdyb3VwcyxlLmNvbXBvbmVudEdyb3Vwcy5hcnJheS5sZW5ndGgtMSksNTc5KSxTVyhyLG4pKXx8ZWUoZS5jb21wb25lbnRHcm91cHMsbmV3IEN3ZShuKSl9ZnVuY3Rpb24gYXdlKCl7bVcuY2FsbCh0aGlzKX1wKDEzMTIsNzc5LHt9LGF3ZSksbC5hZGRDb21wb25lbnQ9ZnVuY3Rpb24obil7aXdlKHRoaXMsbil9LGwuY29tYmluZT1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTTtpZih0aGlzLmNvbXBvbmVudEdyb3Vwcy5hcnJheS5sZW5ndGg9MCxyLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aD0wLG4uaXNFbXB0eSgpKXtyLnNpemVfMC54XzA9MCxyLnNpemVfMC55XzA9MDtyZXR1cm59Zm9yKHU9YShuLmdldF8wKDApLDM2KSxnbyhyLHUpLGk9bi5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspbz1hKGkubmV4dF8xKCksMzYpLGl3ZSh0aGlzLG8pO2ZvcihNPW5ldyBtdCxrPW5ldyBtdCx2PW5ldyBtdCxFPW5ldyBtdCxzPVIoJCh3KHUsKG9lKCksRDMpKSkpLGQ9bmV3IFQodGhpcy5jb21wb25lbnRHcm91cHMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoYz1hKEMoZCksMzM1KSxkYyhhKHcociwoRm4oKSxuMSkpLDg4KSkpe2Zvcih2LnhfMD1NLnhfMCxBPW5ldyBrMihDMihBNihjLmNvbXBvbmVudHMpLm11bHRpbWFwKS50aGlzJDAxLmVudHJ5SXRlcmF0b3IoKSk7QS5iYWNraW5nSXRlcmF0b3IuaGFzTmV4dF8wKCk7KWlmKHg9YShFSShBLmJhY2tpbmdJdGVyYXRvci5uZXh0XzEoKSksMjEpLHguY29udGFpbnMoKHJlKCksVWUpKSl7di54XzA9ay54XzA7YnJlYWt9fWVsc2UgaWYoQWcoYSh3KHIsbjEpLDg4KSkpe2Zvcih2LnlfMD1NLnlfMCxBPW5ldyBrMihDMihBNihjLmNvbXBvbmVudHMpLm11bHRpbWFwKS50aGlzJDAxLmVudHJ5SXRlcmF0b3IoKSk7QS5iYWNraW5nSXRlcmF0b3IuaGFzTmV4dF8wKCk7KWlmKHg9YShFSShBLmJhY2tpbmdJdGVyYXRvci5uZXh0XzEoKSksMjEpLHguY29udGFpbnMoKHJlKCksamUpKSl7di55XzA9ay55XzA7YnJlYWt9fWlmKGY9b3dlKGEoYyw1NzkpLHMpLHpjKG9JKGMuY29tcG9uZW50cyksdi54XzAsdi55XzApLGRjKGEodyhyLG4xKSw4OCkpKXtmb3Ioay54XzA9di54XzArZi54XzAsRS54XzA9Uy5NYXRoLm1heChFLnhfMCxrLnhfMCksQT1uZXcgazIoQzIoQTYoYy5jb21wb25lbnRzKS5tdWx0aW1hcCkudGhpcyQwMS5lbnRyeUl0ZXJhdG9yKCkpO0EuYmFja2luZ0l0ZXJhdG9yLmhhc05leHRfMCgpOylpZih4PWEoRUkoQS5iYWNraW5nSXRlcmF0b3IubmV4dF8xKCkpLDIxKSx4LmNvbnRhaW5zKChyZSgpLGxuKSkpe00ueF8wPXYueF8wK2YueF8wO2JyZWFrfWsueV8wPXYueV8wK2YueV8wLHYueV8wPWsueV8wLEUueV8wPVMuTWF0aC5tYXgoRS55XzAsdi55XzApfWVsc2UgaWYoQWcoYSh3KHIsbjEpLDg4KSkpe2ZvcihrLnlfMD12LnlfMCtmLnlfMCxFLnlfMD1TLk1hdGgubWF4KEUueV8wLGsueV8wKSxBPW5ldyBrMihDMihBNihjLmNvbXBvbmVudHMpLm11bHRpbWFwKS50aGlzJDAxLmVudHJ5SXRlcmF0b3IoKSk7QS5iYWNraW5nSXRlcmF0b3IuaGFzTmV4dF8wKCk7KWlmKHg9YShFSShBLmJhY2tpbmdJdGVyYXRvci5uZXh0XzEoKSksMjEpLHguY29udGFpbnMoKHJlKCkscWUpKSl7TS55XzA9di55XzArZi55XzA7YnJlYWt9ay54XzA9di54XzArZi54XzAsdi54XzA9ay54XzAsRS54XzA9Uy5NYXRoLm1heChFLnhfMCx2LnhfMCl9fWlmKHIuc2l6ZV8wLnhfMD1FLnhfMC1zLHIuc2l6ZV8wLnlfMD1FLnlfMC1zLGFlKGllKHcodSxoUCkpKSYmRCh3KHUsdWMpKT09PUQoKGZjKCksTncpKSl7Zm9yKHk9bi5pdGVyYXRvcl8wKCk7eS5oYXNOZXh0XzAoKTspaD1hKHkubmV4dF8xKCksMzYpLE15KGgsaC5vZmZzZXQueF8wLGgub2Zmc2V0LnlfMCk7Zm9yKHQ9bmV3IEo4LEVXKHQsbixzKSxtPW4uaXRlcmF0b3JfMCgpO20uaGFzTmV4dF8wKCk7KWg9YShtLm5leHRfMSgpLDM2KSxLbihtcyhoLm9mZnNldCksdC55ZXRBbm90aGVyT2Zmc2V0KTtLbihtcyhyLnNpemVfMCksdC5jb21wYWN0ZWRHcmFwaFNpemUpfWZvcihfPW5ldyBUKHRoaXMuY29tcG9uZW50R3JvdXBzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMzM1KSxoVyhyLG9JKGMuY29tcG9uZW50cykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudEdyb3VwTW9kZWxPcmRlckdyYXBoUGxhY2VyIiwxMzEyKTtmdW5jdGlvbiBGXygpe0ZfPUYseWY9bmV3IF80KCJOT05FIiwwKSx5Vz1uZXcgXzQoIklOU0lERV9QT1JUX1NJREVfR1JPVVBTIiwxKSxZOD1uZXcgXzQoIkdST1VQX01PREVMX09SREVSIiwyKSxLOD1uZXcgXzQoIk1PREVMX09SREVSIiwzKX1mdW5jdGlvbiBfNChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHdpbihlKXtyZXR1cm4gRl8oKSx3bigobHdlKCksc3dlKSxlKX1mdW5jdGlvbiBFaW4oKXtyZXR1cm4gRl8oKSxQKEkod1csMSksVywzODksMCxbeWYseVcsWTgsSzhdKX1wKDM4OSwyMix7MzoxLDM0OjEsMjI6MSwzODk6MX0sXzQpO3ZhciBZOCx5VyxLOCx5Zix3Vz1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvbmVudHMiLCJDb21wb25lbnRPcmRlcmluZ1N0cmF0ZWd5IiwzODksZ24sRWluLHdpbik7ZnVuY3Rpb24gbHdlKCl7bHdlPUYsc3dlPXluKChGXygpLFAoSSh3VywxKSxXLDM4OSwwLFt5Zix5VyxZOCxLOF0pKSl9dmFyIHN3ZTtmdW5jdGlvbiB2aW4oZSxuLHIpe3ZhciB0O3Q9bnVsbCxuJiYodD1uLm1hcmdpbikseUUoZSxuZXcga3kobi5wb3MueF8wLXQubGVmdCtyLnhfMCxuLnBvcy55XzAtdC50b3BfMCtyLnlfMCkpLHlFKGUsbmV3IGt5KG4ucG9zLnhfMC10LmxlZnQrci54XzAsbi5wb3MueV8wK24uc2l6ZV8wLnlfMCt0LmJvdHRvbStyLnlfMCkpLHlFKGUsbmV3IGt5KG4ucG9zLnhfMCtuLnNpemVfMC54XzArdC5yaWdodCtyLnhfMCxuLnBvcy55XzAtdC50b3BfMCtyLnlfMCkpLHlFKGUsbmV3IGt5KG4ucG9zLnhfMCtuLnNpemVfMC54XzArdC5yaWdodCtyLnhfMCxuLnBvcy55XzArbi5zaXplXzAueV8wK3QuYm90dG9tK3IueV8wKSl9ZnVuY3Rpb24gRVcoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmU7Zm9yKGUuZ3JhcGhUb3BMZWZ0PW5ldyBZKGhyLGhyKSxlLmdyYXBoQm90dG9tUmlnaHQ9bmV3IFkoVnIsVnIpLGg9bi5pdGVyYXRvcl8wKCk7aC5oYXNOZXh0XzAoKTspZm9yKGQ9YShoLm5leHRfMSgpLDM2KSxrPW5ldyBUKGQubGF5ZXJsZXNzTm9kZXMpO2suaTxrLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylBPWEoQyhrKSwxMCksZS5ncmFwaFRvcExlZnQueF8wPVMuTWF0aC5taW4oZS5ncmFwaFRvcExlZnQueF8wLEEucG9zLnhfMC1BLm1hcmdpbi5sZWZ0KSxlLmdyYXBoVG9wTGVmdC55XzA9Uy5NYXRoLm1pbihlLmdyYXBoVG9wTGVmdC55XzAsQS5wb3MueV8wLUEubWFyZ2luLnRvcF8wKSxlLmdyYXBoQm90dG9tUmlnaHQueF8wPVMuTWF0aC5tYXgoZS5ncmFwaEJvdHRvbVJpZ2h0LnhfMCxBLnBvcy54XzArQS5zaXplXzAueF8wK0EubWFyZ2luLnJpZ2h0KSxlLmdyYXBoQm90dG9tUmlnaHQueV8wPVMuTWF0aC5tYXgoZS5ncmFwaEJvdHRvbVJpZ2h0LnlfMCxBLnBvcy55XzArQS5zaXplXzAueV8wK0EubWFyZ2luLmJvdHRvbSk7Zm9yKHU9bmV3IGZ3ZSxmPW4uaXRlcmF0b3JfMCgpO2YuaGFzTmV4dF8wKCk7KWQ9YShmLm5leHRfMSgpLDM2KSx0PUlpbihlLGQpLGVlKHUuY29tcG9uZW50cyx0KSx0LmNvbnRhaW5zUmVndWxhck5vZGVzPXQuY29udGFpbnNSZWd1bGFyTm9kZXN8IWEodyh0LmdyYXBoXzAsKEsoKSxzYykpLDIxKS5pc0VtcHR5KCk7Zm9yKGUuY29tcGFjdG9yPShEOCgpLHZlPW5ldyBUeWUsdmUudHJhbnNmb3JtZXI9bmV3IHB5ZShyKSx2ZS5jb21wYWN0aW9uR3JhcGg9Um9uKHZlLnRyYW5zZm9ybWVyLHUpLHZlKSxEb24oKHk9ZS5jb21wYWN0b3IsbmV3IGdtLHkpKSxlLnlldEFub3RoZXJPZmZzZXQ9bmV3IG10LGUuY29tcGFjdGVkR3JhcGhTaXplPWUuY29tcGFjdG9yLnRyYW5zZm9ybWVyLmdyYXBoU2l6ZSxzPW5ldyBUKHUuY29tcG9uZW50cyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhzKSw4NTUpLE09Rm9uKGUuY29tcGFjdG9yLG8pLG9hbihvLmdyYXBoXzAsTS54XzAsTS55XzApLHY9bmV3IFQoby5ncmFwaF8wLmxheWVybGVzc05vZGVzKTt2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aDspRT1hKEModiksMTApLEUudHlwZV8wPT0oV2UoKSxGcikmJih4PXZXKGUsRS5wb3MsYSh3KEUsKEsoKSxEbykpLDY0KSksS24obXMoRS5wb3MpLHgpKTtmb3IoaT1uZXcgVCh1LmNvbXBvbmVudHMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksODU1KSxfPW5ldyBUKHhpbihvKSk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihjPWEoQyhfKSwxOCksbmU9bmV3IEpOKGMuYmVuZFBvaW50cyksWm0obmUsMCxBcyhjLnNvdXJjZSkpLExuKG5lLEFzKGMudGFyZ2V0KSksbT1udWxsLHE9ZG4obmUsMCk7cS5jdXJyZW50Tm9kZSE9cS50aGlzJDAxLnRhaWw7KXtpZihIPWEodW4ocSksOCksIW0pe209SDtjb250aW51ZX1jJChtLnhfMCxILnhfMCk/KGUueWV0QW5vdGhlck9mZnNldC54XzA9Uy5NYXRoLm1pbihlLnlldEFub3RoZXJPZmZzZXQueF8wLG0ueF8wKSxlLmNvbXBhY3RlZEdyYXBoU2l6ZS54XzA9Uy5NYXRoLm1heChlLmNvbXBhY3RlZEdyYXBoU2l6ZS54XzAsbS54XzApKTpjJChtLnlfMCxILnlfMCkmJihlLnlldEFub3RoZXJPZmZzZXQueV8wPVMuTWF0aC5taW4oZS55ZXRBbm90aGVyT2Zmc2V0LnlfMCxtLnlfMCksZS5jb21wYWN0ZWRHcmFwaFNpemUueV8wPVMuTWF0aC5tYXgoZS5jb21wYWN0ZWRHcmFwaFNpemUueV8wLG0ueV8wKSksbT1IfUtOKGUueWV0QW5vdGhlck9mZnNldCksS24oZS5jb21wYWN0ZWRHcmFwaFNpemUsZS55ZXRBbm90aGVyT2Zmc2V0KX1mdW5jdGlvbiBTaW4oZSl7dmFyIG4scix0LG8saSxzLHUsYztmb3IoYz1uZXcgX3dlLHU9bmV3IFQoZS5sYXllcmxlc3NOb2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHM9YShDKHUpLDEwKSxzLnR5cGVfMCE9KFdlKCksRnIpKXtmb3IodmluKGMscyxuZXcgbXQpLGk9bmV3IFhlKFFlKFJyKHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspaWYobz1hKHRuKGkpLDE4KSwhKG8uc291cmNlLm93bmVyLnR5cGVfMD09RnJ8fG8udGFyZ2V0Lm93bmVyLnR5cGVfMD09RnIpKWZvcih0PWRuKG8uYmVuZFBvaW50cywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDgpLG49cix5RShjLG5ldyBreShuLnhfMCxuLnlfMCkpfXJldHVybiBjfWZ1bmN0aW9uIENpbihlKXt2YXIgbixyLHQsbyxpO3N3aXRjaChvPWEobGUoZS5sYXllcmxlc3NOb2RlcywwKSwxMCksbj1uZXcgYWMoZSksZWUoZS5sYXllcmxlc3NOb2RlcyxuKSxuLnNpemVfMC54XzA9Uy5NYXRoLm1heCgxLG8uc2l6ZV8wLnhfMCksbi5zaXplXzAueV8wPVMuTWF0aC5tYXgoMSxvLnNpemVfMC55XzApLG4ucG9zLnhfMD1vLnBvcy54XzAsbi5wb3MueV8wPW8ucG9zLnlfMCxhKHcobywoSygpLERvKSksNjQpLm9yZGluYWwpe2Nhc2UgNDpuLnBvcy54XzArPTI7YnJlYWs7Y2FzZSAxOm4ucG9zLnlfMCs9MjticmVhaztjYXNlIDI6bi5wb3MueF8wLT0yO2JyZWFrO2Nhc2UgMzpuLnBvcy55XzAtPTJ9cmV0dXJuIHQ9bmV3IFpvLExvKHQsbikscj1uZXcgSDEsaT1hKGxlKG8ucG9ydHMsMCksMTIpLEx0KHIsaSksX3Qocix0KSxLbihtcyh0LnBvcyksaS5wb3MpLEtuKG1zKHQuYW5jaG9yKSxpLmFuY2hvciksbn1mdW5jdGlvbiBUaW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZjtmb3IodD1yLmV4dGVybmFsUG9ydCxvPXIuZXh0ZXJuYWxQb3J0U2lkZSx1PUFzKG4uc291cmNlKSxjPUFzKG4udGFyZ2V0KSx0PT1uLnNvdXJjZT8odT12VyhlLHUsbyksYz11d2Uobi50YXJnZXQpKToodT11d2Uobi5zb3VyY2UpLGM9dlcoZSxjLG8pKSxfPW5ldyBKTihuLmJlbmRQb2ludHMpLGJyKF8sdSxfLmhlYWRlcixfLmhlYWRlci5uZXh0XzApLGJyKF8sYyxfLnRhaWwucHJldixfLnRhaWwpLHM9bi5zb3VyY2U9PXQsZj1uZXcgbXdlLGk9MDtpPF8uc2l6ZV8wLTE7KytpKWQ9bmV3IFpyKGEoVmEoXyxpKSw4KSxhKFZhKF8saSsxKSw4KSkscyYmaT09MHx8IXMmJmk9PV8uc2l6ZV8wLTI/Zi5vdXRlclNlZ21lbnQ9ZDplZShmLmlubmVyU2VnbWVudHMsZCk7cmV0dXJuIGZ9ZnVuY3Rpb24gdlcoZSxuLHIpe3N3aXRjaChyLm9yZGluYWwpe2Nhc2UgMTpyZXR1cm4gbmV3IFkobi54XzAsUy5NYXRoLm1pbihlLmdyYXBoVG9wTGVmdC55XzAsbi55XzApKTtjYXNlIDI6cmV0dXJuIG5ldyBZKFMuTWF0aC5tYXgoZS5ncmFwaEJvdHRvbVJpZ2h0LnhfMCxuLnhfMCksbi55XzApO2Nhc2UgMzpyZXR1cm4gbmV3IFkobi54XzAsUy5NYXRoLm1heChlLmdyYXBoQm90dG9tUmlnaHQueV8wLG4ueV8wKSk7Y2FzZSA0OnJldHVybiBuZXcgWShTLk1hdGgubWluKG4ueF8wLGUuZ3JhcGhUb3BMZWZ0LnhfMCksbi55XzApfXJldHVybiBuZXcgWShuLnhfMCxuLnlfMCl9ZnVuY3Rpb24gdXdlKGUpe3ZhciBuLHI7c3dpdGNoKHI9Q3Qoa28oUChJKG90LDEpLFgsOCwwLFtlLm93bmVyLnBvcyxlLnBvcyxlLmFuY2hvcl0pKSksbj1lLm93bmVyLm1hcmdpbixlLnNpZGUub3JkaW5hbCl7Y2FzZSAxOnIueV8wLT1uLnRvcF8wO2JyZWFrO2Nhc2UgMjpyLnhfMCs9bi5yaWdodDticmVhaztjYXNlIDM6ci55XzArPW4uYm90dG9tO2JyZWFrO2Nhc2UgNDpyLnhfMC09bi5sZWZ0fXJldHVybiByfWZ1bmN0aW9uIFg4KGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMTpyZXR1cm4gV3IoKSxvbDtjYXNlIDQ6cmV0dXJuIFdyKCksYW87Y2FzZSAyOnJldHVybiBXcigpLG1vO2Nhc2UgMzpyZXR1cm4gV3IoKSwkc31yZXR1cm4gV3IoKSxCc31mdW5jdGlvbiBjd2UoZSxuLHIpe3JldHVybiBuZXcgdGwoUy5NYXRoLm1pbihlLnhfMCxuLnhfMCktci8yLFMuTWF0aC5taW4oZS55XzAsbi55XzApLXIvMixTLk1hdGguYWJzKGUueF8wLW4ueF8wKStyLFMuTWF0aC5hYnMoZS55XzAtbi55XzApK3IpfWZ1bmN0aW9uIGJpbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbTtmb3IoaT1uZXcgcHdlKG4pLGY9VGluKGUsbixpKSxtPVMuTWF0aC5tYXgoUigkKHcobiwob2UoKSxVYykpKSksMSksZD1uZXcgVChmLmlubmVyU2VnbWVudHMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhkKSw0MiksYz1jd2UoYShfLmZpcnN0LDgpLGEoXy5zZWNvbmQsOCksbSkscmV0dXJuVmFsPSEwLHJldHVyblZhbD1yZXR1cm5WYWwmQjEocixuZXcgWShjLnhfMCxjLnlfMCkpLHJldHVyblZhbD1yZXR1cm5WYWwmQjEocixtZChuZXcgWShjLnhfMCxjLnlfMCksYy53aWR0aF8wLDApKSxyZXR1cm5WYWw9cmV0dXJuVmFsJkIxKHIsbWQobmV3IFkoYy54XzAsYy55XzApLDAsYy5oZWlnaHQpKSxyZXR1cm5WYWwmQjEocixtZChuZXcgWShjLnhfMCxjLnlfMCksYy53aWR0aF8wLGMuaGVpZ2h0KSk7c3dpdGNoKGg9aS5leHRlcm5hbFBvcnRTaWRlLHU9Y3dlKGEoZi5vdXRlclNlZ21lbnQuZmlyc3QsOCksYShmLm91dGVyU2VnbWVudC5zZWNvbmQsOCksbSksaD09KHJlKCksamUpfHxoPT1xZT8odC5taW5fMFtoLm9yZGluYWxdPVMuTWF0aC5taW4odC5taW5fMFtoLm9yZGluYWxdLHUueV8wKSx0Lm1heF8wW2gub3JkaW5hbF09Uy5NYXRoLm1heCh0Lm1heF8wW2gub3JkaW5hbF0sdS55XzArdS5oZWlnaHQpKToodC5taW5fMFtoLm9yZGluYWxdPVMuTWF0aC5taW4odC5taW5fMFtoLm9yZGluYWxdLHUueF8wKSx0Lm1heF8wW2gub3JkaW5hbF09Uy5NYXRoLm1heCh0Lm1heF8wW2gub3JkaW5hbF0sdS54XzArdS53aWR0aF8wKSksbz1WcixzPWkuZXh0ZXJuYWxQb3J0Lm93bmVyLm1hcmdpbixoLm9yZGluYWwpe2Nhc2UgNDpvPXMucmlnaHQ7YnJlYWs7Y2FzZSAyOm89cy5sZWZ0O2JyZWFrO2Nhc2UgMTpvPXMuYm90dG9tO2JyZWFrO2Nhc2UgMzpvPXMudG9wXzB9cmV0dXJuIHQuZXh0ZW50W2gub3JkaW5hbF09Uy5NYXRoLm1heCh0LmV4dGVudFtoLm9yZGluYWxdLG8pLGl9ZnVuY3Rpb24gSWluKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2ZvcihyPW5ldyBkd2Uobiksci5jb250YWluc1JlZ3VsYXJOb2Rlc3x8Q2luKG4pLF89U2luKG4pLGM9bmV3IEUxLHY9bmV3IGh3ZSxFPW5ldyBUKG4ubGF5ZXJsZXNzTm9kZXMpO0UuaTxFLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoeT1hKEMoRSksMTApLG89bmV3IFhlKFFlKFJyKHkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihvKTspdD1hKHRuKG8pLDE4KSwodC5zb3VyY2Uub3duZXIudHlwZV8wPT0oV2UoKSxGcil8fHQudGFyZ2V0Lm93bmVyLnR5cGVfMD09RnIpJiYoZD1iaW4oZSx0LF8sdiksYmUoYyxYOChkLmV4dGVybmFsUG9ydFNpZGUpLGQuZWRnZSkpO2ZvcihzPW5ldyBRLGs9YSh3KHIuZ3JhcGhfMCwoSygpLHNjKSksMjEpLml0ZXJhdG9yXzAoKTtrLmhhc05leHRfMCgpOyl7c3dpdGNoKEE9YShrLm5leHRfMSgpLDY0KSxtPXYubWluXzBbQS5vcmRpbmFsXSxoPXYubWF4XzBbQS5vcmRpbmFsXSx1PXYuZXh0ZW50W0Eub3JkaW5hbF0saT1udWxsLHg9bnVsbCxBLm9yZGluYWwpe2Nhc2UgNDppPW5ldyB0bChlLmdyYXBoVG9wTGVmdC54XzAsbSxfLnRvcExlZnQueF8wLWUuZ3JhcGhUb3BMZWZ0LnhfMCxoLW0pLHg9bmV3IHRsKGUuZ3JhcGhUb3BMZWZ0LnhfMCxtLHUsaC1tKSxCMShfLG5ldyBZKGkueF8wK2kud2lkdGhfMCxpLnlfMCkpLEIxKF8sbmV3IFkoaS54XzAraS53aWR0aF8wLGkueV8wK2kuaGVpZ2h0KSk7YnJlYWs7Y2FzZSAyOmk9bmV3IHRsKF8uYm90dG9tUmlnaHQueF8wLG0sZS5ncmFwaEJvdHRvbVJpZ2h0LnhfMC1fLmJvdHRvbVJpZ2h0LnhfMCxoLW0pLHg9bmV3IHRsKGUuZ3JhcGhCb3R0b21SaWdodC54XzAtdSxtLHUsaC1tKSxCMShfLG5ldyBZKGkueF8wLGkueV8wKSksQjEoXyxuZXcgWShpLnhfMCxpLnlfMCtpLmhlaWdodCkpO2JyZWFrO2Nhc2UgMTppPW5ldyB0bChtLGUuZ3JhcGhUb3BMZWZ0LnlfMCxoLW0sXy50b3BMZWZ0LnlfMC1lLmdyYXBoVG9wTGVmdC55XzApLHg9bmV3IHRsKG0sZS5ncmFwaFRvcExlZnQueV8wLGgtbSx1KSxCMShfLG5ldyBZKGkueF8wLGkueV8wK2kuaGVpZ2h0KSksQjEoXyxuZXcgWShpLnhfMCtpLndpZHRoXzAsaS55XzAraS5oZWlnaHQpKTticmVhaztjYXNlIDM6aT1uZXcgdGwobSxfLmJvdHRvbVJpZ2h0LnlfMCxoLW0sZS5ncmFwaEJvdHRvbVJpZ2h0LnlfMC1fLmJvdHRvbVJpZ2h0LnlfMCkseD1uZXcgdGwobSxlLmdyYXBoQm90dG9tUmlnaHQueV8wLXUsaC1tLHUpLEIxKF8sbmV3IFkoaS54XzAsaS55XzApKSxCMShfLG5ldyBZKGkueF8wK2kud2lkdGhfMCxpLnlfMCkpfWkmJihmPW5ldyBnd2UsZi5zaWRlPUEsZi5leHRlbnNpb249aSxmLnBsYWNlaG9sZGVyPXgsZi5lZGdlcz1DSShhKFpuKGMsWDgoQSkpLDIxKSksUmUocy5hcnJheSxmKSl9cmV0dXJuIHFyKHIuZXh0ZXJuYWxFeHRlbnNpb25zLHMpLHIucmVjdGlsaW5lYXJDb252ZXhIdWxsPWxpbihmaW4oXykpLHJ9ZnVuY3Rpb24gSjgoKXt9cCg2NTksMSx7fSxKOCksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvbmVudHMiLCJDb21wb25lbnRzQ29tcGFjdG9yIiw2NTkpO2Z1bmN0aW9uIHlFKGUsbil7cmV0dXJuIGUudG9wTGVmdC54XzA9Uy5NYXRoLm1pbihlLnRvcExlZnQueF8wLG4ueF8wKSxlLnRvcExlZnQueV8wPVMuTWF0aC5taW4oZS50b3BMZWZ0LnlfMCxuLnlfMCksZS5ib3R0b21SaWdodC54XzA9Uy5NYXRoLm1heChlLmJvdHRvbVJpZ2h0LnhfMCxuLnhfMCksZS5ib3R0b21SaWdodC55XzA9Uy5NYXRoLm1heChlLmJvdHRvbVJpZ2h0LnlfMCxuLnlfMCksUmUoZS5hcnJheSxuKSwhMH1mdW5jdGlvbiBCMShlLG4pe3JldHVybiB5RShlLG5ldyBreShuLnhfMCxuLnlfMCkpfWZ1bmN0aW9uIF93ZSgpe0s1KHRoaXMpLHRoaXMudG9wTGVmdD1uZXcgWShocixociksdGhpcy5ib3R0b21SaWdodD1uZXcgWShWcixWcil9cCgxNTMzLDEzLGxpZSxfd2UpLGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIHlFKHRoaXMsYShuLDE0OCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudHNDb21wYWN0b3IvSHVsbHBvaW50cyIsMTUzMyk7ZnVuY3Rpb24geGluKGUpe3ZhciBuLHIsdDtmb3Iobj1uZXcgUSx0PW5ldyBUKGUuZXh0ZXJuYWxFeHRlbnNpb25zKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksNjAyKSxxcihuLGEoci5nZXRSZXByZXNlbnRhdGl2ZSgpLDE2KSk7cmV0dXJuIG59ZnVuY3Rpb24gZHdlKGUpe3ZhciBuLHI7Zm9yKHRoaXMuZXh0ZXJuYWxFeHRlbnNpb25zPW5ldyBRLHRoaXMuZ3JhcGhfMD1lLHRoaXMuY29udGFpbnNSZWd1bGFyTm9kZXM9ITEscj1uZXcgVChlLmxheWVybGVzc05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTApLHRoaXMuY29udGFpbnNSZWd1bGFyTm9kZXM9dGhpcy5jb250YWluc1JlZ3VsYXJOb2Rlc3xuLnR5cGVfMD09KFdlKCksa3IpfXAoMTUzMCwxLHs4NTU6MX0sZHdlKSxsLmNvbnRhaW5zUmVndWxhck5vZGVzPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiQ29tcG9uZW50c0NvbXBhY3Rvci9JbnRlcm5hbENvbXBvbmVudCIsMTUzMCk7ZnVuY3Rpb24gZndlKCl7dGhpcy5jb21wb25lbnRzPW5ldyBRfXAoMTUyOSwxLFR1LGZ3ZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUKHRoaXMuY29tcG9uZW50cyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiQ29tcG9uZW50c0NvbXBhY3Rvci9JbnRlcm5hbENvbm5lY3RlZENvbXBvbmVudHMiLDE1MjkpO2Z1bmN0aW9uIHB3ZShlKXtpZih0aGlzLmVkZ2U9ZSxlLnNvdXJjZS5vd25lci50eXBlXzA9PShXZSgpLEZyKSl0aGlzLmV4dGVybmFsUG9ydD1lLnNvdXJjZSx0aGlzLmV4dGVybmFsUG9ydFNpZGU9YSh3KGUuc291cmNlLm93bmVyLChLKCksRG8pKSw2NCk7ZWxzZSBpZihlLnRhcmdldC5vd25lci50eXBlXzA9PUZyKXRoaXMuZXh0ZXJuYWxQb3J0PWUudGFyZ2V0LHRoaXMuZXh0ZXJuYWxQb3J0U2lkZT1hKHcoZS50YXJnZXQub3duZXIsKEsoKSxEbykpLDY0KTtlbHNlIHRocm93IGIobmV3IEdlKCJFZGdlICIrZSsiIGlzIG5vdCBhbiBleHRlcm5hbCBlZGdlLiIpKX1wKDE1MzIsMSx7NjAyOjF9LHB3ZSksbC5nZXRQbGFjZWhvbGRlcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldFJlcHJlc2VudGF0aXZlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZX0sbC5nZXREaXJlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gWDgodGhpcy5leHRlcm5hbFBvcnRTaWRlKX0sbC5nZXRSZXByZXNlbnRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4dGVybmFsRXh0ZW5zaW9ufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudHNDb21wYWN0b3IvSW50ZXJuYWxFeHRlcm5hbEV4dGVuc2lvbiIsMTUzMik7ZnVuY3Rpb24gZ3dlKCl7dGhpcy5lZGdlcz1uZXcgQnJ9cCgxNTMxLDEsezYwMjoxfSxnd2UpLGwuZ2V0UmVwcmVzZW50YXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sbC5nZXREaXJlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4gWDgodGhpcy5zaWRlKX0sbC5nZXRQbGFjZWhvbGRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBsYWNlaG9sZGVyfSxsLmdldFJlcHJlc2VudG9yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXh0ZW5zaW9ufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudHNDb21wYWN0b3IvSW50ZXJuYWxVbmlvbkV4dGVybmFsRXh0ZW5zaW9uIiwxNTMxKTtmdW5jdGlvbiBod2UoKXt0aGlzLm1pbl8wPUIoY3QsWHQsMjgsKHJlKCksUChJKCR0LDEpLGpvLDY0LDAsW09vLFVlLHFlLGxuLGplXSkpLmxlbmd0aCwxNSwxKSx0aGlzLm1heF8wPUIoY3QsWHQsMjgsUChJKCR0LDEpLGpvLDY0LDAsW09vLFVlLHFlLGxuLGplXSkubGVuZ3RoLDE1LDEpLHRoaXMuZXh0ZW50PUIoY3QsWHQsMjgsUChJKCR0LDEpLGpvLDY0LDAsW09vLFVlLHFlLGxuLGplXSkubGVuZ3RoLDE1LDEpLE1CKHRoaXMubWluXzAsaHIpLE1CKHRoaXMubWF4XzAsVnIpLE1CKHRoaXMuZXh0ZW50LFZyKX1wKDE1MzUsMSx7fSxod2UpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiQ29tcG9uZW50c0NvbXBhY3Rvci9PdXRlclNlZ21lbnRzIiwxNTM1KTtmdW5jdGlvbiBtd2UoKXt0aGlzLmlubmVyU2VnbWVudHM9bmV3IFF9cCgxNTM0LDEse30sbXdlKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudHNDb21wYWN0b3IvU2VnbWVudHMiLDE1MzQpO2Z1bmN0aW9uIFBpbihlLG4scil7ZS5ncmFwaFBsYWNlci5jb21iaW5lKG4scil9ZnVuY3Rpb24geXdlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkO2lmKG4uaWRfMD09MCl7Zm9yKG4uaWRfMD0xLHM9cixzfHwobz1uZXcgUSxpPSh0PWEoaXMoJHQpLDkpLG5ldyBKYSh0LGEoRGwodCx0Lmxlbmd0aCksOSksMCkpLHM9bmV3IFpyKG8saSkpLGEocy5maXJzdCwxNSkuYWRkXzIobiksbi50eXBlXzA9PShXZSgpLEZyKSYmYShzLnNlY29uZCwyMSkuYWRkXzIoYSh3KG4sKEsoKSxEbykpLDY0KSksYz1uZXcgVChuLnBvcnRzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHU9YShDKGMpLDEyKSxkPVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFtuZXcgRHkodSksbmV3IE1oKHUpXSkpKTtfbihkKTspXz1hKHRuKGQpLDEyKSx5d2UoZSxfLm93bmVyLHMpO3JldHVybiBzfXJldHVybiBudWxsfWZ1bmN0aW9uIE5pbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKGUuZ3JhcGhQbGFjZXI9ZS5zaW1wbGVSb3dHcmFwaFBsYWNlcix5PWllKHcobiwob2UoKSxRNGUpKSksbT15PT1udWxsfHwoVmUoeSkseSksaT1hKHcobiwoSygpLGlpKSksMjEpLmNvbnRhaW5zKChWdCgpLG5sKSksbz1hKHcobix4ciksMTAxKSxyPSEobz09KGR0KCksbzEpfHxvPT1IdXx8bz09YWkpLG0mJihyfHwhaSkpe2ZvcihmPW5ldyBUKG4ubGF5ZXJsZXNzTm9kZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhmKSwxMCksXy5pZF8wPTA7Zm9yKGg9bmV3IFEsZD1uZXcgVChuLmxheWVybGVzc05vZGVzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoXz1hKEMoZCksMTApLHQ9eXdlKGUsXyxudWxsKSx0KXtmb3IoYz1uZXcgSVcsZ28oYyxuKSxqKGMsc2MsYSh0LnNlY29uZCwyMSkpLE9XKGMucGFkZGluZyxuLnBhZGRpbmcpLGooYyxvdyxudWxsKSx1PWEodC5maXJzdCwxNSkuaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDEwKSxlZShjLmxheWVybGVzc05vZGVzLHMpLHMuZ3JhcGhfMD1jO2guYWRkXzIoYyl9aSYmKEQodyhuLFBmKSk9PT1EKChGXygpLFk4KSk/ZS5ncmFwaFBsYWNlcj1lLmNvbXBvbmVudEdyb3VwTW9kZWxPcmRlckdyYXBoUGxhY2VyOkQodyhuLFBmKSk9PT1EKEs4KT9lLmdyYXBoUGxhY2VyPWUubW9kZWxPcmRlclJvd0dyYXBoUGxhY2VyOmUuZ3JhcGhQbGFjZXI9ZS5jb21wb25lbnRHcm91cEdyYXBoUGxhY2VyKX1lbHNlIGg9bmV3IGVhKFAoSSh6d2UsMSkscGllLDM2LDAsW25dKSk7cmV0dXJuIEQodyhuLFBmKSkhPT1EKChGXygpLHlmKSkmJihOZSgpLGguc29ydF8wKG5ldyBFd2UpKSxofWZ1bmN0aW9uIHd3ZSgpe3RoaXMuY29tcG9uZW50R3JvdXBHcmFwaFBsYWNlcj1uZXcgbVcsdGhpcy5jb21wb25lbnRHcm91cE1vZGVsT3JkZXJHcmFwaFBsYWNlcj1uZXcgYXdlLHRoaXMubW9kZWxPcmRlclJvd0dyYXBoUGxhY2VyPW5ldyBid2UsdGhpcy5zaW1wbGVSb3dHcmFwaFBsYWNlcj1uZXcgVHdlfWZ1bmN0aW9uIEFpbihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9andlKGUpLHQ9andlKG4pLHI8dD8tMTpyPnQ/MTowfXAoMTI4MiwxLHt9LHd3ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvbmVudHMiLCJDb21wb25lbnRzUHJvY2Vzc29yIiwxMjgyKTtmdW5jdGlvbiBFd2UoKXt9cCgxMjgzLDEsTm4sRXdlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBBaW4oYShuLDM2KSxhKHIsMzYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIkNvbXBvbmVudHNQcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTI4Myk7ZnVuY3Rpb24gdndlKCl7dndlPUYscTgoKSxSbj1uZXcgRTEsYmUoUm4sKHJlKCksUWwpLFVzKSxiZShSbixibCxVcyksYmUoUm4sbGEsVXMpLGJlKFJuLGVzLFVzKSxiZShSbixPaSxVcyksYmUoUm4sc2EsVXMpLGJlKFJuLGVzLFFsKSxiZShSbixVcyxpbCksYmUoUm4sUWwsaWwpLGJlKFJuLGJsLGlsKSxiZShSbixsYSxpbCksYmUoUm4sa2ksaWwpLGJlKFJuLGVzLGlsKSxiZShSbixPaSxpbCksYmUoUm4sc2EsaWwpLGJlKFJuLHZpLGlsKSxiZShSbixVcyx6YSksYmUoUm4sUWwsemEpLGJlKFJuLGlsLHphKSxiZShSbixibCx6YSksYmUoUm4sbGEsemEpLGJlKFJuLGtpLHphKSxiZShSbixlcyx6YSksYmUoUm4sdmksemEpLGJlKFJuLCRhLHphKSxiZShSbixPaSx6YSksYmUoUm4sVmksemEpLGJlKFJuLHNhLHphKSxiZShSbixRbCxibCksYmUoUm4sbGEsYmwpLGJlKFJuLGVzLGJsKSxiZShSbixzYSxibCksYmUoUm4sUWwsbGEpLGJlKFJuLGJsLGxhKSxiZShSbixlcyxsYSksYmUoUm4sbGEsbGEpLGJlKFJuLE9pLGxhKSxiZShSbixVcyxhbCksYmUoUm4sUWwsYWwpLGJlKFJuLGlsLGFsKSxiZShSbix6YSxhbCksYmUoUm4sYmwsYWwpLGJlKFJuLGxhLGFsKSxiZShSbixraSxhbCksYmUoUm4sZXMsYWwpLGJlKFJuLCRhLGFsKSxiZShSbix2aSxhbCksYmUoUm4sc2EsYWwpLGJlKFJuLE9pLGFsKSxiZShSbixsaSxhbCksYmUoUm4sVXMsJGEpLGJlKFJuLFFsLCRhKSxiZShSbixpbCwkYSksYmUoUm4sYmwsJGEpLGJlKFJuLGxhLCRhKSxiZShSbixraSwkYSksYmUoUm4sZXMsJGEpLGJlKFJuLHZpLCRhKSxiZShSbixzYSwkYSksYmUoUm4sVmksJGEpLGJlKFJuLGxpLCRhKSxiZShSbixRbCx2aSksYmUoUm4sYmwsdmkpLGJlKFJuLGxhLHZpKSxiZShSbixlcyx2aSksYmUoUm4sJGEsdmkpLGJlKFJuLHNhLHZpKSxiZShSbixPaSx2aSksYmUoUm4sVXMsTGkpLGJlKFJuLFFsLExpKSxiZShSbixpbCxMaSksYmUoUm4sYmwsTGkpLGJlKFJuLGxhLExpKSxiZShSbixraSxMaSksYmUoUm4sZXMsTGkpLGJlKFJuLHZpLExpKSxiZShSbixzYSxMaSksYmUoUm4sUWwsT2kpLGJlKFJuLGlsLE9pKSxiZShSbix6YSxPaSksYmUoUm4sbGEsT2kpLGJlKFJuLFVzLFZpKSxiZShSbixRbCxWaSksYmUoUm4semEsVmkpLGJlKFJuLGJsLFZpKSxiZShSbixsYSxWaSksYmUoUm4sa2ksVmkpLGJlKFJuLGVzLFZpKSxiZShSbixlcyxsaSksYmUoUm4sbGEsbGkpLGJlKFJuLHZpLFVzKSxiZShSbix2aSxibCksYmUoUm4sdmksaWwpLGJlKFJuLGtpLFVzKSxiZShSbixraSxRbCksYmUoUm4sa2ksemEpfWZ1bmN0aW9uIFNXKGUsbil7cmV0dXJuIFN3ZShlLG4pPyhiZShlLmNvbXBvbmVudHMsYSh3KG4sKEsoKSxzYykpLDIxKSxuKSxMbihlLmNvbXBvbmVudE9yZGVyLG4pLCEwKTohMX1mdW5jdGlvbiBTd2UoZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKHI9YSh3KG4sKEsoKSxzYykpLDIxKSxzPWEoWm4oKHE4KCksYXIpLHIpLDIxKSx1PWEoWm4oUm4sciksMjEpLGk9cy5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspaWYodD1hKGkubmV4dF8xKCksMjEpLCFhKFpuKGUuY29tcG9uZW50cyx0KSwxNSkuaXNFbXB0eSgpKXJldHVybiExO2ZvcihvPXUuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KWlmKHQ9YShvLm5leHRfMSgpLDIxKSwhYShabihlLmNvbXBvbmVudHMsdCksMTUpLmlzRW1wdHkoKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBDd2UoZSl7dndlKCkscndlKHRoaXMpLHRoaXMuY29tcG9uZW50T3JkZXI9bmV3IHByLFNXKHRoaXMsZSksTG4odGhpcy5jb21wb25lbnRPcmRlcixlKX1wKDU3OSwzMzUsezMzNToxLDU3OToxfSxDd2UpLGwuYWRkXzQ9ZnVuY3Rpb24obil7cmV0dXJuIFNXKHRoaXMsbil9LGwuY2FuQWRkPWZ1bmN0aW9uKG4pe3JldHVybiBTd2UodGhpcyxuKX07dmFyIFJuO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiTW9kZWxPcmRlckNvbXBvbmVudEdyb3VwIiw1NzkpO2Z1bmN0aW9uIFR3ZSgpe31wKDEzMTAsMjEwNCx7fSxUd2UpLGwuY29tYmluZT1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG07aWYobi5zaXplXzEoKT09MSl7aD1hKG4uZ2V0XzAoMCksMzYpLGghPXImJihyLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aD0wLG53ZShyLGgsMCwwKSxnbyhyLGgpLE9XKHIucGFkZGluZyxoLnBhZGRpbmcpLHIuc2l6ZV8wLnhfMD1oLnNpemVfMC54XzAsci5zaXplXzAueV8wPWguc2l6ZV8wLnlfMCk7cmV0dXJufWVsc2UgaWYobi5pc0VtcHR5KCkpe3IubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPTAsci5zaXplXzAueF8wPTAsci5zaXplXzAueV8wPTA7cmV0dXJufWZvcih0aGlzLnNvcnRDb21wb25lbnRzKG4sciksaT1hKG4uZ2V0XzAoMCksMzYpLHIubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPTAsZ28ocixpKSxkPTAsbT0wLHU9bi5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMzYpLGY9cy5zaXplXzAsZD1TLk1hdGgubWF4KGQsZi54XzApLG0rPWYueF8wKmYueV8wO2lmKGQ9Uy5NYXRoLm1heChkLFMuTWF0aC5zcXJ0KG0pKlIoJCh3KHIsKG9lKCksZ1ApKSkpKSxvPVIoJCh3KHIsRDMpKSksdGhpcy5wbGFjZUNvbXBvbmVudHMobixyLGQsbyksYWUoaWUodyhpLGhQKSkpKXtmb3IodD1uZXcgSjgsRVcodCxuLG8pLF89bi5pdGVyYXRvcl8wKCk7Xy5oYXNOZXh0XzAoKTspYz1hKF8ubmV4dF8xKCksMzYpLEtuKG1zKGMub2Zmc2V0KSx0LnlldEFub3RoZXJPZmZzZXQpO0tuKG1zKHIuc2l6ZV8wKSx0LmNvbXBhY3RlZEdyYXBoU2l6ZSl9aFcocixuKX0sbC5wbGFjZUNvbXBvbmVudHM9ZnVuY3Rpb24obixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaDtmb3IoZj0wLGg9MCxjPTAsaT1vLHU9bi5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMzYpLGQ9cy5zaXplXzAsZitkLnhfMD50JiYoZj0wLGgrPWMrbyxjPTApLF89cy5vZmZzZXQsTXkocyxmK18ueF8wLGgrXy55XzApLG1zKF8pLGk9Uy5NYXRoLm1heChpLGYrZC54XzApLGM9Uy5NYXRoLm1heChjLGQueV8wKSxmKz1kLnhfMCtvO3Iuc2l6ZV8wLnhfMD1pLHIuc2l6ZV8wLnlfMD1oK2N9LGwuc29ydENvbXBvbmVudHM9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscyx1O2lmKEQodyhyLChvZSgpLFBmKSkpPT09RCgoRl8oKSx5ZikpKXtmb3Iobz1uLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl7Zm9yKHQ9YShvLm5leHRfMSgpLDM2KSx1PTAscz1uZXcgVCh0LmxheWVybGVzc05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTApLHUrPWEodyhpLEo0ZSksMTcpLnZhbHVlXzA7dC5pZF8wPXV9TmUoKSxuLnNvcnRfMChuZXcgSXdlKX19LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb25lbnRzIiwiU2ltcGxlUm93R3JhcGhQbGFjZXIiLDEzMTApO2Z1bmN0aW9uIGJ3ZSgpe31wKDEzMTMsMTMxMCx7fSxid2UpLGwucGxhY2VDb21wb25lbnRzPWZ1bmN0aW9uKG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5O2ZvcihtPTAseT0wLGM9MCxpPW8sXz1udWxsLGg9MCx1PW4uaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDM2KSxmPXMuc2l6ZV8wLChtK2YueF8wPnQmJiFhKHcocywoSygpLHNjKSksMjEpLmNvbnRhaW5zKChyZSgpLFVlKSl8fF8mJmEodyhfLChLKCksc2MpKSwyMSkuY29udGFpbnMoKHJlKCkscWUpKXx8YSh3KHMsKEsoKSxzYykpLDIxKS5jb250YWlucygocmUoKSxqZSkpKSYmKG09aCx5Kz1jK28sYz0wKSxkPXMub2Zmc2V0LGEodyhzLChLKCksc2MpKSwyMSkuY29udGFpbnMoKHJlKCksVWUpKSYmKG09aStvKSxNeShzLG0rZC54XzAseStkLnlfMCksaT1TLk1hdGgubWF4KGksbStmLnhfMCksYSh3KHMsc2MpLDIxKS5jb250YWlucyhsbikmJihoPVMuTWF0aC5tYXgoaCxtK2YueF8wK28pKSxtcyhkKSxjPVMuTWF0aC5tYXgoYyxmLnlfMCksbSs9Zi54XzArbyxfPXM7ci5zaXplXzAueF8wPWksci5zaXplXzAueV8wPXkrY30sbC5zb3J0Q29tcG9uZW50cz1mdW5jdGlvbihuLHIpe30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvbmVudHMiLCJNb2RlbE9yZGVyUm93R3JhcGhQbGFjZXIiLDEzMTMpO2Z1bmN0aW9uIExpbihlLG4pe3ZhciByLHQsbztyZXR1cm4gcj1uLmlkXzAtZS5pZF8wLHI9PTA/KHQ9ZS5zaXplXzAueF8wKmUuc2l6ZV8wLnlfMCxvPW4uc2l6ZV8wLnhfMCpuLnNpemVfMC55XzAsaXIodCxvKSk6cn1mdW5jdGlvbiBJd2UoKXt9cCgxMzExLDEsTm4sSXdlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBMaW4oYShuLDM2KSxhKHIsMzYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG9uZW50cyIsIlNpbXBsZVJvd0dyYXBoUGxhY2VyLzEiLDEzMTEpO2Z1bmN0aW9uIHh3ZSgpe3h3ZT1GLFB3ZT1uZXcgTndlfWZ1bmN0aW9uIGtpbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZTtmb3Iobi5iZWdpbigiQ29tcG91bmQgZ3JhcGggcG9zdHByb2Nlc3NvciIsMSkscj1hZShpZSh3KGUsKG9lKCksQU8pKSkpLHU9YSh3KGUsKEsoKSxaVikpLDIyOSksZD1uZXcgQnIseD11LmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3guaGFzTmV4dF8wKCk7KXtmb3Iodj1hKHgubmV4dF8xKCksMTgpLHM9bmV3IFFpKHUuZ2V0XzEodikpLE5lKCksRHIocyxuZXcgQ1coZSkpLEg9VmluKChBZSgwLHMuYXJyYXkubGVuZ3RoKSxhKHMuYXJyYXlbMF0sMjQ5KSkpLG5lPVJ3ZShhKGxlKHMscy5hcnJheS5sZW5ndGgtMSksMjQ5KSksaz1ILm93bmVyLFJ5KG5lLm93bmVyLGspP0E9ay5uZXN0ZWRHcmFwaDpBPVN0KGspLGY9T2luKHYscyksa2Eodi5iZW5kUG9pbnRzKSxoPW51bGwsaT1uZXcgVChzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMjQ5KSxFPW5ldyBtdCxQVyhFLG8uZ3JhcGhfMCxBKSxtPW8ubmV3RWRnZSx0PW5ldyBqaSxKTSh0LDAsbS5iZW5kUG9pbnRzKSxVZih0LEUpLE09bmV3IFJ0KEFzKG0uc291cmNlKSkscT1uZXcgUnQoQXMobS50YXJnZXQpKSxLbihNLEUpLEtuKHEsRSksaCYmKHQuc2l6ZV8wPT0wP3k9cTp5PShybih0LnNpemVfMCE9MCksYSh0LmhlYWRlci5uZXh0XzAudmFsdWVfMCw4KSksdmU9Uy5NYXRoLmFicyhoLnhfMC15LnhfMCk+WnMsd2U9Uy5NYXRoLmFicyhoLnlfMC15LnlfMCk+WnMsKCFyJiZ2ZSYmd2V8fHImJih2ZXx8d2UpKSYmTG4odi5iZW5kUG9pbnRzLE0pKSxmdCh2LmJlbmRQb2ludHMsdCksdC5zaXplXzA9PTA/aD1NOmg9KHJuKHQuc2l6ZV8wIT0wKSxhKHQudGFpbC5wcmV2LnZhbHVlXzAsOCkpLE1pbihtLGYsRSksUndlKG8pPT1uZSYmKFN0KG5lLm93bmVyKSE9by5ncmFwaF8wJiYoRT1uZXcgbXQsUFcoRSxTdChuZS5vd25lciksQSkpLGoodixnTyxFKSksUmluKG0sdixBKSxkLm1hcF8wLnB1dChtLGQpO0x0KHYsSCksX3QodixuZSl9Zm9yKF89ZC5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOyljPWEoXy5uZXh0XzEoKSwxOCksTHQoYyxudWxsKSxfdChjLG51bGwpO24uZG9uZV8xKCl9ZnVuY3Rpb24gT2luKGUsbil7dmFyIHI7cmV0dXJuIHI9YSh3KGUsKG9lKCksaW8pKSw3NSksbzUobixQd2UpP3I/a2Eocik6KHI9bmV3IGppLGooZSxpbyxyKSk6ciYmaihlLGlvLG51bGwpLHJ9ZnVuY3Rpb24gTWluKGUsbixyKXt2YXIgdCxvO289YSh3KGUsKG9lKCksaW8pKSw3NSksbyYmKHQ9bmV3IGppLEpNKHQsMCxvKSxVZih0LHIpLGZ0KG4sdCkpfWZ1bmN0aW9uIFJpbihlLG4scil7dmFyIHQsbztmb3Iobz1uZXcgcHQoZS5sYWJlbHMsMCk7by5pPG8udGhpcyQwMV8wLnNpemVfMSgpOyl0PShybihvLmk8by50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoby50aGlzJDAxXzAuZ2V0XzAoby5sYXN0PW8uaSsrKSw3MikpLEQodyh0LChLKCksdHEpKSk9PT1EKG4pJiYoUFcodC5wb3MsU3QoZS5zb3VyY2Uub3duZXIpLHIpLEVhKG8pLGVlKG4ubGFiZWxzLHQpKX12YXIgUHdlO2Z1bmN0aW9uIE53ZSgpe31wKDEyODAsMSxKcyxOd2UpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1hKHcoYShuLDI0OSkubmV3RWRnZSwob2UoKSxpbykpLDc1KSwhIXImJnIuc2l6ZV8wIT0wfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC50ZXN0XzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9YSh3KGEobiwyNDkpLm5ld0VkZ2UsKG9lKCksaW8pKSw3NSksISFyJiZyLnNpemVfMCE9MH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvdW5kIiwiQ29tcG91bmRHcmFwaFBvc3Rwcm9jZXNzb3IvMSIsMTI4MCk7ZnVuY3Rpb24gRGluKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IodT1lLm93bmVyLG89YWUoaWUodyh1LChvZSgpLEFmKSkpKSxkPTAsdD0wLF89bmV3IFQoZS5vdXRnb2luZ0VkZ2VzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTgpLHM9enQoYyksaT1zJiZvJiZhZShpZSh3KGMsVV8pKSksaD1jLnRhcmdldC5vd25lcixzJiZpPysrdDpzJiYhaT8rK2Q6U3QoaCkucGFyZW50Tm9kZT09dT8rK3Q6KytkO2ZvcihyPW5ldyBUKGUuaW5jb21pbmdFZGdlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDE4KSxzPXp0KG4pLGk9cyYmbyYmYWUoaWUodyhuLFVfKSkpLGY9bi5zb3VyY2Uub3duZXIscyYmaT8rK2Q6cyYmIWk/Kyt0OlN0KGYpLnBhcmVudE5vZGU9PXU/KytkOisrdDtyZXR1cm4gZC10fWZ1bmN0aW9uIEF3ZShlLG4scix0LG8saSl7dmFyIHM7cz1aOCh0KSxMdChzLG8pLF90KHMsaSksYmUoZS5jcm9zc0hpZXJhcmNoeU1hcCx0LG5ldyBkNChzLG4sci50eXBlXzApKX1mdW5jdGlvbiBGaW4oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYztmb3IoYz1udWxsLHU9bmV3IFQodCk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHM9YShDKHUpLDQ1MykscyE9ciYmZm8ocy5vcmlnRWRnZXMsbywwKSE9LTEpe2M9czticmVha31pPVo4KG8pLEx0KGksci5kdW1teVBvcnQpLF90KGksYy5kdW1teVBvcnQpLGJlKGUuY3Jvc3NIaWVyYXJjaHlNYXAsbyxuZXcgZDQoaSxuLHIudHlwZV8wKSl9ZnVuY3Rpb24gWjgoZSl7dmFyIG47cmV0dXJuIG49bmV3IEgxLGdvKG4sZSksaihuLChvZSgpLGlvKSxudWxsKSxufWZ1bmN0aW9uIHppbihlLG4scix0LG8saSl7dmFyIHMsdSxjLF8sZCxmO3JldHVybiBzPW51bGwsXz10PT0ocXQoKSxpYSk/aS5zb3VyY2U6aS50YXJnZXQsYz1nNChuKSxfLm93bmVyPT1yPyhzPWEoS2UoZS5kdW1teU5vZGVNYXAsXyksMTApLHN8fChzPXUzKF8sYSh3KHIsKG9lKCkseHIpKSwxMDEpLG8sRGluKF8pLG51bGwsXy5wb3MsXy5zaXplXzAsYyxuKSxqKHMsKEsoKSxRbiksXyksQm4oZS5kdW1teU5vZGVNYXAsXyxzKSkpOihzPXUzKChkPW5ldyBoOCxmPVIoJCh3KG4sKG9lKCkscWwpKSkpLzIsUUMoZCxMZixmKSxkKSxhKHcocix4ciksMTAxKSxvLHQ9PWlhPy0xOjEsbnVsbCxuZXcgbXQsbmV3IFkoMCwwKSxjLG4pLHU9JGluKHMscix0KSxqKHMsKEsoKSxRbiksdSksQm4oZS5kdW1teU5vZGVNYXAsdSxzKSksYSh3KG4sKEsoKSxpaSkpLDIxKS5hZGRfMigoVnQoKSxubCkpLE9nKGEodyhuLChvZSgpLHhyKSksMTAxKSk/aihuLHhyLChkdCgpLEF3KSk6aihuLHhyLChkdCgpLEhzKSksc31mdW5jdGlvbiAkaW4oZSxuLHIpe3ZhciB0LG8saTtzd2l0Y2godD1TdChuKSxvPWc0KHQpLGk9bmV3IFpvLExvKGksbiksci5vcmRpbmFsKXtjYXNlIDE6WHIoaSxCVChmbShvKSkpO2JyZWFrO2Nhc2UgMjpYcihpLGZtKG8pKX1yZXR1cm4gaihpLChvZSgpLExmKSwkKHcoZSxMZikpKSxpfWZ1bmN0aW9uIEJpbihlKXt2YXIgbixyLHQsbztmb3Iobz0tMSx0PTAscj1uZXcgVChlKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2lmKG49YShDKHIpLDI0OSksbi50eXBlXzA9PShxdCgpLGlhKSl7bz10PT0wPzA6dC0xO2JyZWFrfWVsc2UgdD09ZS5hcnJheS5sZW5ndGgtMSYmKG89dCk7dCs9MX1yZXR1cm4gb31mdW5jdGlvbiBROChlLG4scix0LG8saSxzKXt2YXIgdSxjLF8sZCxmLGgsbTtyZXR1cm4gZj1hZShpZSh3KG4sKG9lKCksaVkpKSkpLGg9bnVsbCxpPT0ocXQoKSxpYSkmJnQuc291cmNlLm93bmVyPT1yP2g9dC5zb3VyY2U6aT09cGkmJnQudGFyZ2V0Lm93bmVyPT1yJiYoaD10LnRhcmdldCksXz1zLCFffHwhZnx8aD8oZD0ocmUoKSxPbyksaD9kPWguc2lkZTpPZyhhKHcocix4ciksMTAxKSkmJihkPWk9PWlhP2plOnFlKSxjPXppbihlLG4scixpLGQsdCksdT1aOCgoU3QociksdCkpLGk9PWlhPyhMdCh1LGEobGUoYy5wb3J0cywwKSwxMikpLF90KHUsbykpOihMdCh1LG8pLF90KHUsYShsZShjLnBvcnRzLDApLDEyKSkpLF89bmV3IE13ZSh0LHUsYyxhKHcoYywoSygpLFFuKSksMTIpLGksIWgpKTooZWUoXy5vcmlnRWRnZXMsdCksbT1TLk1hdGgubWF4KFIoJCh3KF8ubmV3RWRnZSxVYykpKSxSKCQodyh0LFVjKSkpKSxqKF8ubmV3RWRnZSxVYyxtKSksYmUoZS5jcm9zc0hpZXJhcmNoeU1hcCx0LG5ldyBkNChfLm5ld0VkZ2UsbixpKSksX31mdW5jdGlvbiBHaW4oZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3Iocz1yaChlLmNyb3NzSGllcmFyY2h5TWFwKS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspe2lmKGk9YShzLm5leHRfMSgpLDE4KSxpLmxhYmVscy5hcnJheS5sZW5ndGg+MClmb3IodD1uZXcgUWkoYShabihlLmNyb3NzSGllcmFyY2h5TWFwLGkpLDIxKSksTmUoKSxEcih0LG5ldyBDVyhuKSksbz1uZXcgcHQoaS5sYWJlbHMsMCk7by5pPG8udGhpcyQwMV8wLnNpemVfMSgpOyl7c3dpdGNoKHI9KHJuKG8uaTxvLnRoaXMkMDFfMC5zaXplXzEoKSksYShvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspLDcyKSksdT0tMSxhKHcociwob2UoKSxkdSkpLDI3OCkub3JkaW5hbCl7Y2FzZSAxOnU9dC5hcnJheS5sZW5ndGgtMTticmVhaztjYXNlIDA6dT1CaW4odCk7YnJlYWs7Y2FzZSAyOnU9MH11IT0tMSYmKGM9KEFlKHUsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVt1XSwyNDkpKSxlZShjLm5ld0VkZ2UubGFiZWxzLHIpLGEodyhTdChjLm5ld0VkZ2Uuc291cmNlLm93bmVyKSwoSygpLGlpKSksMjEpLmFkZF8yKChWdCgpLGV3KSksYSh3KFN0KGMubmV3RWRnZS5zb3VyY2Uub3duZXIpLGlpKSwyMSkuYWRkXzIoUXkpLEVhKG8pLGoocix0cSxpKSl9THQoaSxudWxsKSxfdChpLG51bGwpfX1mdW5jdGlvbiBMd2UoZSxuLHIpe3IuYmVnaW4oIkNvbXBvdW5kIGdyYXBoIHByZXByb2Nlc3NvciIsMSksZS5jcm9zc0hpZXJhcmNoeU1hcD1uZXcgRTEsa3dlKGUsbixudWxsKSxHaW4oZSxuKSxqaW4oZSksaihuLChLKCksWlYpLGUuY3Jvc3NIaWVyYXJjaHlNYXApLGUuY3Jvc3NIaWVyYXJjaHlNYXA9bnVsbCxaaShlLmR1bW15Tm9kZU1hcCksci5kb25lXzEoKX1mdW5jdGlvbiBIaW4oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKGk9bmV3IFEsXz1uZXcgVCh0KTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYodT1hKEMoXyksNDUzKSxzPW51bGwsdS50eXBlXzA9PShxdCgpLHBpKSlmb3IoeT1uZXcgVCh1Lm9yaWdFZGdlcyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW09YShDKHkpLDE4KSx2PW0udGFyZ2V0Lm93bmVyLFN0KHYpPT1uP0F3ZShlLG4sdSxtLHUuZHVtbXlQb3J0LG0udGFyZ2V0KTohcnx8UnkodixyKT9GaW4oZSxuLHUsdCxtKTooaD1ROChlLG4scixtLHUuZHVtbXlQb3J0LHBpLHMpLGghPXMmJlJlKGkuYXJyYXksaCksaC5leHBvcnRlZCYmKHM9aCkpO2Vsc2UgZm9yKGY9bmV3IFQodS5vcmlnRWRnZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihkPWEoQyhmKSwxOCksRT1kLnNvdXJjZS5vd25lcixTdChFKT09bilBd2UoZSxuLHUsZCxkLnNvdXJjZSx1LmR1bW15UG9ydCk7ZWxzZXtpZighcnx8UnkoRSxyKSljb250aW51ZTtoPVE4KGUsbixyLGQsdS5kdW1teVBvcnQsaWEscyksaCE9cyYmUmUoaS5hcnJheSxoKSxoLmV4cG9ydGVkJiYocz1oKX1mb3IoYz1uZXcgVChpKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoYyksNDUzKSxmbyhuLmxheWVybGVzc05vZGVzLHUuZHVtbXlOb2RlLDApIT0tMXx8ZWUobi5sYXllcmxlc3NOb2Rlcyx1LmR1bW15Tm9kZSksdS5leHBvcnRlZCYmUmUoby5hcnJheSx1KX1mdW5jdGlvbiBVaW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7aWYoYWUoaWUodyhyLChvZSgpLEFmKSkpKSlmb3IodT1uZXcgVChyLnBvcnRzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHM9YShDKHUpLDEyKSxoPWN1KHMub3V0Z29pbmdFZGdlcyksXz1oLGQ9MCxmPV8ubGVuZ3RoO2Q8ZjsrK2QpYz1fW2RdLGk9Yy50YXJnZXQub3duZXI9PXIsbz1pJiZhZShpZSh3KGMsVV8pKSksbyYmKHk9Yy5zb3VyY2UsbT1hKEtlKGUuZHVtbXlOb2RlTWFwLHkpLDEwKSxtfHwobT11Myh5LChkdCgpLEhzKSx5LnNpZGUsLTEsbnVsbCxudWxsLHkuc2l6ZV8wLGEodyhuLE9hKSw4OCksbiksaihtLChLKCksUW4pLHkpLEJuKGUuZHVtbXlOb2RlTWFwLHksbSksZWUobi5sYXllcmxlc3NOb2RlcyxtKSksdj1jLnRhcmdldCxFPWEoS2UoZS5kdW1teU5vZGVNYXAsdiksMTApLEV8fChFPXUzKHYsKGR0KCksSHMpLHYuc2lkZSwxLG51bGwsbnVsbCx2LnNpemVfMCxhKHcobixPYSksODgpLG4pLGooRSwoSygpLFFuKSx2KSxCbihlLmR1bW15Tm9kZU1hcCx2LEUpLGVlKG4ubGF5ZXJsZXNzTm9kZXMsRSkpLHQ9WjgoYyksTHQodCxhKGxlKG0ucG9ydHMsMCksMTIpKSxfdCh0LGEobGUoRS5wb3J0cywwKSwxMikpLGJlKGUuY3Jvc3NIaWVyYXJjaHlNYXAsYyxuZXcgZDQodCxuLChxdCgpLHBpKSkpLGEodyhuLChLKCksaWkpKSwyMSkuYWRkXzIoKFZ0KCksbmwpKSl9ZnVuY3Rpb24gV2luKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSDtmb3IoYz1uZXcgUSxpPW5ldyBUKG4ubGF5ZXJsZXNzTm9kZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksMTApLHU9bmV3IFQoby5wb3J0cyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iocz1hKEModSksMTIpLGQ9bnVsbCxrPWN1KHMub3V0Z29pbmdFZGdlcyksTT0wLEg9ay5sZW5ndGg7TTxIOysrTSlBPWtbTV0sUnkoQS50YXJnZXQub3duZXIscil8fCh4PVE4KGUsbixyLEEsQS5zb3VyY2UsKHF0KCkscGkpLGQpLHghPWQmJlJlKGMuYXJyYXkseCkseC5leHBvcnRlZCYmKGQ9eCkpO2ZvcihfPW51bGwseT1jdShzLmluY29taW5nRWRnZXMpLEU9MCx2PXkubGVuZ3RoO0U8djsrK0UpbT15W0VdLFJ5KG0uc291cmNlLm93bmVyLHIpfHwoeD1ROChlLG4scixtLG0udGFyZ2V0LChxdCgpLGlhKSxfKSx4IT1fJiZSZShjLmFycmF5LHgpLHguZXhwb3J0ZWQmJihfPXgpKX1mb3IoaD1uZXcgVChjKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksNDUzKSxmbyhuLmxheWVybGVzc05vZGVzLGYuZHVtbXlOb2RlLDApIT0tMXx8ZWUobi5sYXllcmxlc3NOb2RlcyxmLmR1bW15Tm9kZSksZi5leHBvcnRlZCYmUmUodC5hcnJheSxmKX1mdW5jdGlvbiBqaW4oZSl7dmFyIG4scix0LG87Zm9yKHQ9bmV3IExfKG5ldyBBXyhlLmR1bW15Tm9kZU1hcCkudGhpcyQwMSk7dC5oYXNOZXh0OylyPU4xKHQpLG89YShyLmdldEtleSgpLDEyKSxuPWEoci5nZXRWYWx1ZSgpLDEwKSxqKG4sKEsoKSxRbiksbyksaihvLG9hLG4pLGoobyxBMywoemUoKSwhMCkpLFhyKG8sYSh3KG4sRG8pLDY0KSksdyhuLERvKSxqKG8ub3duZXIsKG9lKCkseHIpLChkdCgpLEF3KSksYSh3KFN0KG8ub3duZXIpLGlpKSwyMSkuYWRkXzIoKFZ0KCksbncpKX1mdW5jdGlvbiBrd2UoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKG89bmV3IFEsRT1uZXcgVChuLmxheWVybGVzc05vZGVzKTtFLmk8RS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoeT1hKEMoRSksMTApLG09eS5uZXN0ZWRHcmFwaCxtJiYodD1rd2UoZSxtLHkpLHFyKG8sdCksVWluKGUsbSx5KSxhKHcobSwoSygpLGlpKSksMjEpLmNvbnRhaW5zKChWdCgpLG5sKSkpKWZvcihBPWEodyh5LChvZSgpLHhyKSksMTAxKSxoPWEodyh5LGtmKSwxODEpLmNvbnRhaW5zKChhYSgpLGhjKSkseD1uZXcgVCh5LnBvcnRzKTt4Lmk8eC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHY9YShDKHgpLDEyKSxpPWEoS2UoZS5kdW1teU5vZGVNYXAsdiksMTApLGl8fChpPXUzKHYsQSx2LnNpZGUsLSh2LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoLXYub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgpLG51bGwsbmV3IG10LHYuc2l6ZV8wLGEodyhtLE9hKSw4OCksbSksaihpLFFuLHYpLEJuKGUuZHVtbXlOb2RlTWFwLHYsaSksZWUobS5sYXllcmxlc3NOb2RlcyxpKSkscz1hKGxlKGkucG9ydHMsMCksMTIpLGQ9bmV3IFQodi5sYWJlbHMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhkKSw3MiksdT1uZXcgWXdlLHUuc2l6ZV8wLnhfMD1fLnNpemVfMC54XzAsdS5zaXplXzAueV8wPV8uc2l6ZV8wLnlfMCxlZShzLmxhYmVscyx1KSxofHwoaz12LnNpZGUsZj0wLGVTKGEodyh5LGtmKSwyMSkpJiYoZj1QZWUoXy5wb3MsXy5zaXplXzAsdi5zaXplXzAsMCxrKSksQT09KGR0KCksSHMpfHwocmUoKSx2aSkuY29udGFpbnMoayk/dS5zaXplXzAueF8wPWY6dS5zaXplXzAueV8wPWYpO3JldHVybiBjPW5ldyBRLEhpbihlLG4scixvLGMpLHImJldpbihlLG4scixjKSxjfWZ1bmN0aW9uIE93ZSgpe3RoaXMuZHVtbXlOb2RlTWFwPW5ldyBzbn1wKDEyNzksMSxzcixPd2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0x3ZSh0aGlzLGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb3VuZCIsIkNvbXBvdW5kR3JhcGhQcmVwcm9jZXNzb3IiLDEyNzkpO2Z1bmN0aW9uIE13ZShlLG4scix0LG8saSl7dGhpcy5vcmlnRWRnZXM9bmV3IFEsdGhpcy50eXBlXzA9KHF0KCkscnYpLGVlKHRoaXMub3JpZ0VkZ2VzLGUpLHRoaXMubmV3RWRnZT1uLHRoaXMuZHVtbXlOb2RlPXIsdGhpcy5kdW1teVBvcnQ9dCx0aGlzLnR5cGVfMD1vLHRoaXMuZXhwb3J0ZWQ9aX1wKDQ1MywxLHs0NTM6MX0sTXdlKSxsLmV4cG9ydGVkPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5jb21wb3VuZCIsIkNvbXBvdW5kR3JhcGhQcmVwcm9jZXNzb3IvRXh0ZXJuYWxQb3J0Iiw0NTMpO2Z1bmN0aW9uIFZpbihlKXtyZXR1cm4gZS5uZXdFZGdlLnNvdXJjZS5vd25lci50eXBlXzA9PShXZSgpLEZyKT9hKHcoZS5uZXdFZGdlLnNvdXJjZS5vd25lciwoSygpLFFuKSksMTIpOmUubmV3RWRnZS5zb3VyY2V9ZnVuY3Rpb24gUndlKGUpe3JldHVybiBlLm5ld0VkZ2UudGFyZ2V0Lm93bmVyLnR5cGVfMD09KFdlKCksRnIpP2EodyhlLm5ld0VkZ2UudGFyZ2V0Lm93bmVyLChLKCksUW4pKSwxMik6ZS5uZXdFZGdlLnRhcmdldH1mdW5jdGlvbiBkNChlLG4scil7dGhpcy5uZXdFZGdlPWUsdGhpcy5ncmFwaF8wPW4sdGhpcy50eXBlXzA9cn1wKDI0OSwxLHsyNDk6MX0sZDQpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBhNSh0aGlzLnR5cGVfMCkrIjoiK0Z3ZSh0aGlzLm5ld0VkZ2UpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuY29tcG91bmQiLCJDcm9zc0hpZXJhcmNoeUVkZ2UiLDI0OSk7ZnVuY3Rpb24gcWluKGUsbixyKXt2YXIgdCxvO3JldHVybiBuLnR5cGVfMD09KHF0KCkscGkpJiZyLnR5cGVfMD09aWE/LTE6bi50eXBlXzA9PWlhJiZyLnR5cGVfMD09cGk/MToodD1Ed2Uobi5ncmFwaF8wLGUuZ3JhcGhfMCksbz1Ed2Uoci5ncmFwaF8wLGUuZ3JhcGhfMCksbi50eXBlXzA9PXBpP28tdDp0LW8pfWZ1bmN0aW9uIENXKGUpe3RoaXMuZ3JhcGhfMD1lfWZ1bmN0aW9uIER3ZShlLG4pe3ZhciByLHQsbztyPWUsbz0wO2Rve2lmKHI9PW4pcmV0dXJuIG87aWYodD1yLnBhcmVudE5vZGUsIXQpdGhyb3cgYihuZXcgVEMpO3I9U3QodCksKytvfXdoaWxlKCEwKX1wKDc3NywxLE5uLENXKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBxaW4odGhpcyxhKG4sMjQ5KSxhKHIsMjQ5KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmNvbXBvdW5kIiwiQ3Jvc3NIaWVyYXJjaHlFZGdlQ29tcGFyYXRvciIsNzc3KTtmdW5jdGlvbiBlOShlKXt2YXIgbjtyZXR1cm4gbj1MYW4oZSksbnx8bnVsbH1wKDMwNSwxMzcsezM6MSwzMDU6MSw5NjoxLDEzNzoxfSksbC5pZF8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTEdyYXBoRWxlbWVudCIsMzA1KTtmdW5jdGlvbiBZaW4oZSl7cmV0dXJuIGUubGFiZWxzLmFycmF5Lmxlbmd0aCE9MCYmYShsZShlLmxhYmVscywwKSw3MikudGV4dF8wP2EobGUoZS5sYWJlbHMsMCksNzIpLnRleHRfMDplOShlKX1mdW5jdGlvbiBUVyhlLG4pe2lmKG49PWUuc291cmNlLm93bmVyKXJldHVybiBlLnRhcmdldC5vd25lcjtpZihuPT1lLnRhcmdldC5vd25lcilyZXR1cm4gZS5zb3VyY2Uub3duZXI7dGhyb3cgYihuZXcgR2UoIidub2RlJyBtdXN0IGVpdGhlciBiZSB0aGUgc291cmNlIG5vZGUgb3IgdGFyZ2V0IG5vZGUgb2YgdGhlIGVkZ2UuIikpfWZ1bmN0aW9uIEtpbihlLG4pe2lmKG49PWUuc291cmNlKXJldHVybiBlLnRhcmdldDtpZihuPT1lLnRhcmdldClyZXR1cm4gZS5zb3VyY2U7dGhyb3cgYihuZXcgR2UoIidwb3J0JyBtdXN0IGJlIGVpdGhlciB0aGUgc291cmNlIHBvcnQgb3IgdGFyZ2V0IHBvcnQgb2YgdGhlIGVkZ2UuIikpfWZ1bmN0aW9uIFhpbihlKXtyZXR1cm4henQoZSkmJmUuc291cmNlLm93bmVyLmxheWVyPT1lLnRhcmdldC5vd25lci5sYXllcn1mdW5jdGlvbiB6dChlKXtyZXR1cm4hZS5zb3VyY2V8fCFlLnRhcmdldD8hMTohIWUuc291cmNlLm93bmVyJiZlLnNvdXJjZS5vd25lcj09ZS50YXJnZXQub3duZXJ9ZnVuY3Rpb24gRzEoZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKGk9ZS5zb3VyY2Uscz1lLnRhcmdldCxMdChlLG51bGwpLF90KGUsbnVsbCksbiYmYWUoaWUodyhzLChLKCksY08pKSkpP0x0KGUsQVcocy5vd25lciwocXQoKSxwaSksKHJlKCkscWUpKSk6THQoZSxzKSxuJiZhZShpZSh3KGksKEsoKSxkTykpKSk/X3QoZSxBVyhpLm93bmVyLChxdCgpLGlhKSwocmUoKSxqZSkpKTpfdChlLGkpLHQ9bmV3IFQoZS5sYWJlbHMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw3Miksbz1hKHcociwob2UoKSxkdSkpLDI3OCksbz09KEdzKCksUHcpP2oocixkdSxWZik6bz09VmYmJmoocixkdSxQdyk7dT1hZShpZSh3KGUsKEsoKSxPcykpKSksaihlLE9zLCh6ZSgpLCF1KSksZS5iZW5kUG9pbnRzPUNUKGUuYmVuZFBvaW50cyl9ZnVuY3Rpb24gTHQoZSxuKXtlLnNvdXJjZSYmUGkoZS5zb3VyY2Uub3V0Z29pbmdFZGdlcyxlKSxlLnNvdXJjZT1uLGUuc291cmNlJiZlZShlLnNvdXJjZS5vdXRnb2luZ0VkZ2VzLGUpfWZ1bmN0aW9uIF90KGUsbil7ZS50YXJnZXQmJlBpKGUudGFyZ2V0LmluY29taW5nRWRnZXMsZSksZS50YXJnZXQ9bixlLnRhcmdldCYmZWUoZS50YXJnZXQuaW5jb21pbmdFZGdlcyxlKX1mdW5jdGlvbiBKaW4oZSxuLHIpe2UudGFyZ2V0JiZQaShlLnRhcmdldC5pbmNvbWluZ0VkZ2VzLGUpLGUudGFyZ2V0PW4sZS50YXJnZXQmJkExKGUudGFyZ2V0LmluY29taW5nRWRnZXMscixlKX1mdW5jdGlvbiBGd2UoZSl7dmFyIG4scjtyZXR1cm4gcj1uZXcgQzAsci5zdHJpbmcrPSJlXyIsbj1ZaW4oZSksbiE9bnVsbCYmKHIuc3RyaW5nKz0iIituKSxlLnNvdXJjZSYmZS50YXJnZXQmJihPbigoci5zdHJpbmcrPSIgIixyKSx3NChlLnNvdXJjZSkpLE9uKGVpKChyLnN0cmluZys9IlsiLHIpLGUuc291cmNlLm93bmVyKSwiXSIpLE9uKChyLnN0cmluZys9IiAtPiAiLHIpLHc0KGUudGFyZ2V0KSksT24oZWkoKHIuc3RyaW5nKz0iWyIsciksZS50YXJnZXQub3duZXIpLCJdIikpLHIuc3RyaW5nfWZ1bmN0aW9uIEgxKCl7dGhpcy5iZW5kUG9pbnRzPW5ldyBqaSx0aGlzLmxhYmVscz0oUGEoMywiaW5pdGlhbEFycmF5U2l6ZSIpLG5ldyBfaSgzKSl9cCgxOCwzMDUsezM6MSwxODoxLDMwNToxLDk2OjEsMTM3OjF9LEgxKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gRndlKHRoaXMpfTt2YXIgbjk9Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTEVkZ2UiLDE4KTtmdW5jdGlvbiBiVyhlKXt2YXIgbixyLHQsbztmb3Iobz1CKFJ1LFgsMTk5LGUubGF5ZXJzLmFycmF5Lmxlbmd0aCwwLDIpLHQ9bmV3IHB0KGUubGF5ZXJzLDApO3QuaTx0LnRoaXMkMDFfMC5zaXplXzEoKTspbj0ocm4odC5pPHQudGhpcyQwMV8wLnNpemVfMSgpKSxhKHQudGhpcyQwMV8wLmdldF8wKHQubGFzdD10LmkrKyksMzApKSxyPXQuaS0xLG9bcl09YzMobi5ub2Rlcyk7cmV0dXJuIG99ZnVuY3Rpb24gSVcoKXt0aGlzLnNpemVfMD1uZXcgbXQsdGhpcy5wYWRkaW5nPW5ldyBVVyx0aGlzLm9mZnNldD1uZXcgbXQsdGhpcy5sYXllcmxlc3NOb2Rlcz1uZXcgUSx0aGlzLmxheWVycz1uZXcgUX1wKDM2LDMwNSx7MzoxLDIwOjEsMzY6MSwzMDU6MSw5NjoxLDEzNzoxfSxJVyksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUKHRoaXMubGF5ZXJzKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGF5ZXJzLmFycmF5Lmxlbmd0aD09MD8iRy11bmxheWVyZWQiK20wKHRoaXMubGF5ZXJsZXNzTm9kZXMpOnRoaXMubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPT0wPyJHLWxheWVyZWQiK20wKHRoaXMubGF5ZXJzKToiR1tsYXllcmxlc3MiK20wKHRoaXMubGF5ZXJsZXNzTm9kZXMpKyIsIGxheWVycyIrbTAodGhpcy5sYXllcnMpKyJdIn07dmFyIHp3ZT1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGgiLDM2KTtmdW5jdGlvbiB3RSgpe3dFPUYsJHdlPW5ldyBHd2V9dmFyICR3ZTtwKDY2NiwxLHt9KSxsLmdldFBvc2l0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5wb3N9LGwuZ2V0UHJvcGVydHk9ZnVuY3Rpb24obil7cmV0dXJuIHcodGhpcy5lbGVtZW50LG4pfSxsLmdldFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50LnNpemVfMH0sbC5nZXRWb2xhdGlsZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5pZF8wfSxsLmhhc1Byb3BlcnR5PWZ1bmN0aW9uKG4pe3JldHVybiBfcih0aGlzLmVsZW1lbnQsbil9LGwuc2V0UG9zaXRpb249ZnVuY3Rpb24obil7dGhpcy5lbGVtZW50LnBvcy54XzA9bi54XzAsdGhpcy5lbGVtZW50LnBvcy55XzA9bi55XzB9LGwuc2V0U2l6ZT1mdW5jdGlvbihuKXt0aGlzLmVsZW1lbnQuc2l6ZV8wLnhfMD1uLnhfMCx0aGlzLmVsZW1lbnQuc2l6ZV8wLnlfMD1uLnlfMH0sbC5zZXRWb2xhdGlsZUlkPWZ1bmN0aW9uKG4pe3RoaXMuZWxlbWVudC5pZF8wPW59LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxHcmFwaEFkYXB0ZXJzL0Fic3RyYWN0TFNoYXBlQWRhcHRlciIsNjY2KTtmdW5jdGlvbiBFRShlKXt0aGlzLmVsZW1lbnQ9ZX1wKDQ3NCwxLHs4NTM6MX0sRUUpLGwuZ2V0TGFiZWxzPWZ1bmN0aW9uKCl7dmFyIG4scjtpZighdGhpcy5sYWJlbEFkYXB0ZXJzKWZvcih0aGlzLmxhYmVsQWRhcHRlcnM9TnUodGhpcy5lbGVtZW50LmxhYmVscy5hcnJheS5sZW5ndGgpLHI9bmV3IFQodGhpcy5lbGVtZW50LmxhYmVscyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDcyKSxlZSh0aGlzLmxhYmVsQWRhcHRlcnMsbmV3IGY0KG4pKTtyZXR1cm4gdGhpcy5sYWJlbEFkYXB0ZXJzfSxsLmxhYmVsQWRhcHRlcnM9bnVsbCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGhBZGFwdGVycy9MRWRnZUFkYXB0ZXIiLDQ3NCk7ZnVuY3Rpb24gcjkoZSxuLHIsdCl7dGhpcy5lbGVtZW50PWUsdGhpcy50cmFuc3BhcmVudE5vcnRoU291dGhFZGdlcz1uLHRoaXMudHJhbnNwYXJlbnRDb21tZW50Tm9kZXM9cix0aGlzLm5vZGVGaWx0ZXI9dH1wKDY2NSwxLHt9LHI5KSxsLmdldE5vZGVzPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saSxzO2lmKCF0aGlzLm5vZGVBZGFwdGVycyl7Zm9yKHRoaXMubm9kZUFkYXB0ZXJzPW5ldyBRLG89bmV3IFQodGhpcy5lbGVtZW50LmxheWVycyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih0PWEoQyhvKSwzMCkscz1uZXcgVCh0Lm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoaT1hKEMocyksMTApLHRoaXMubm9kZUZpbHRlci50ZXN0XzAoaSkmJihlZSh0aGlzLm5vZGVBZGFwdGVycyxuZXcgcDQodGhpcyxpLHRoaXMudHJhbnNwYXJlbnROb3J0aFNvdXRoRWRnZXMpKSx0aGlzLnRyYW5zcGFyZW50Q29tbWVudE5vZGVzKSl7aWYoX3IoaSwoSygpLHFoKSkpZm9yKHI9YSh3KGkscWgpLDE1KS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspbj1hKHIubmV4dF8xKCksMTApLGVlKHRoaXMubm9kZUFkYXB0ZXJzLG5ldyBwNCh0aGlzLG4sITEpKTtpZihfcihpLEhoKSlmb3Iocj1hKHcoaSxIaCksMTUpLml0ZXJhdG9yXzAoKTtyLmhhc05leHRfMCgpOyluPWEoci5uZXh0XzEoKSwxMCksZWUodGhpcy5ub2RlQWRhcHRlcnMsbmV3IHA0KHRoaXMsbiwhMSkpfX1yZXR1cm4gdGhpcy5ub2RlQWRhcHRlcnN9LGwuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBrYygiTm90IHN1cHBvcnRlZCBieSBMR3JhcGgiKSl9LGwuZ2V0UHJvcGVydHk9ZnVuY3Rpb24obil7cmV0dXJuIHcodGhpcy5lbGVtZW50LG4pfSxsLmdldFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50LnNpemVfMH0sbC5nZXRWb2xhdGlsZUlkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudC5pZF8wfSxsLmhhc1Byb3BlcnR5PWZ1bmN0aW9uKG4pe3JldHVybiBfcih0aGlzLmVsZW1lbnQsbil9LGwuc2V0UG9zaXRpb249ZnVuY3Rpb24obil7dGhyb3cgYihuZXcga2MoIk5vdCBzdXBwb3J0ZWQgYnkgTEdyYXBoIikpfSxsLnNldFNpemU9ZnVuY3Rpb24obil7dGhpcy5lbGVtZW50LnNpemVfMC54XzA9bi54XzAsdGhpcy5lbGVtZW50LnNpemVfMC55XzA9bi55XzB9LGwuc2V0Vm9sYXRpbGVJZD1mdW5jdGlvbihuKXt0aGlzLmVsZW1lbnQuaWRfMD1ufSxsLm5vZGVBZGFwdGVycz1udWxsLGwudHJhbnNwYXJlbnRDb21tZW50Tm9kZXM9ITEsbC50cmFuc3BhcmVudE5vcnRoU291dGhFZGdlcz0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGhBZGFwdGVycy9MR3JhcGhBZGFwdGVyIiw2NjUpO2Z1bmN0aW9uIGY0KGUpe3RoaXMuZWxlbWVudD1lfXAoNTg1LDY2Nix7MTg3OjF9LGY0KSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGhBZGFwdGVycy9MTGFiZWxBZGFwdGVyIiw1ODUpO2Z1bmN0aW9uIFppbihlLG4pe19tKGEodyhhKGUuZWxlbWVudCwxMCksKG9lKCkseHIpKSwxMDEpKSYmKE5lKCksRHIoYShlLmVsZW1lbnQsMTApLnBvcnRzLG4pKX1mdW5jdGlvbiBwNChlLG4scil7dGhpcy5lbGVtZW50PW4sdGhpcy5wYXJlbnRHcmFwaEFkYXB0ZXI9ZSx0aGlzLnRyYW5zcGFyZW50Tm9ydGhTb3V0aEVkZ2VzPXJ9cCg1ODQsNjY2LHs2OTU6MX0scDQpLGwuZ2V0R3JhcGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRHcmFwaEFkYXB0ZXJ9LGwuZ2V0SW5jb21pbmdFZGdlcz1mdW5jdGlvbigpe3JldHVybiBOZSgpLE5lKCksT3R9LGwuZ2V0TGFiZWxzPWZ1bmN0aW9uKCl7dmFyIG4scjtpZighdGhpcy5sYWJlbEFkYXB0ZXJzKWZvcih0aGlzLmxhYmVsQWRhcHRlcnM9TnUoYSh0aGlzLmVsZW1lbnQsMTApLmxhYmVscy5hcnJheS5sZW5ndGgpLHI9bmV3IFQoYSh0aGlzLmVsZW1lbnQsMTApLmxhYmVscyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDcyKSxlZSh0aGlzLmxhYmVsQWRhcHRlcnMsbmV3IGY0KG4pKTtyZXR1cm4gdGhpcy5sYWJlbEFkYXB0ZXJzfSxsLmdldE1hcmdpbj1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPWEodGhpcy5lbGVtZW50LDEwKS5tYXJnaW4sbmV3IFJXKG4udG9wXzAsbi5yaWdodCxuLmJvdHRvbSxuLmxlZnQpfSxsLmdldE91dGdvaW5nRWRnZXM9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxOZSgpLE90fSxsLmdldFBvcnRzPWZ1bmN0aW9uKCl7dmFyIG4scjtpZighdGhpcy5wb3J0QWRhcHRlcnMpZm9yKHRoaXMucG9ydEFkYXB0ZXJzPU51KGEodGhpcy5lbGVtZW50LDEwKS5wb3J0cy5hcnJheS5sZW5ndGgpLHI9bmV3IFQoYSh0aGlzLmVsZW1lbnQsMTApLnBvcnRzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTIpLGVlKHRoaXMucG9ydEFkYXB0ZXJzLG5ldyBCd2Uobix0aGlzLnRyYW5zcGFyZW50Tm9ydGhTb3V0aEVkZ2VzKSk7cmV0dXJuIHRoaXMucG9ydEFkYXB0ZXJzfSxsLmlzQ29tcG91bmROb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIGFlKGllKHcoYSh0aGlzLmVsZW1lbnQsMTApLChLKCksWFYpKSkpfSxsLnNldE1hcmdpbj1mdW5jdGlvbihuKXthKHRoaXMuZWxlbWVudCwxMCkubWFyZ2luLmxlZnQ9bi5sZWZ0LGEodGhpcy5lbGVtZW50LDEwKS5tYXJnaW4udG9wXzA9bi50b3BfMCxhKHRoaXMuZWxlbWVudCwxMCkubWFyZ2luLnJpZ2h0PW4ucmlnaHQsYSh0aGlzLmVsZW1lbnQsMTApLm1hcmdpbi5ib3R0b209bi5ib3R0b219LGwuc2V0UGFkZGluZz1mdW5jdGlvbihuKXthKHRoaXMuZWxlbWVudCwxMCkucGFkZGluZy5sZWZ0PW4ubGVmdCxhKHRoaXMuZWxlbWVudCwxMCkucGFkZGluZy50b3BfMD1uLnRvcF8wLGEodGhpcy5lbGVtZW50LDEwKS5wYWRkaW5nLnJpZ2h0PW4ucmlnaHQsYSh0aGlzLmVsZW1lbnQsMTApLnBhZGRpbmcuYm90dG9tPW4uYm90dG9tfSxsLnNvcnRQb3J0TGlzdD1mdW5jdGlvbigpe1ppbih0aGlzLCh3RSgpLCR3ZSkpfSxsLmxhYmVsQWRhcHRlcnM9bnVsbCxsLnBhcmVudEdyYXBoQWRhcHRlcj1udWxsLGwucG9ydEFkYXB0ZXJzPW51bGwsbC50cmFuc3BhcmVudE5vcnRoU291dGhFZGdlcz0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGhBZGFwdGVycy9MTm9kZUFkYXB0ZXIiLDU4NCk7ZnVuY3Rpb24gQndlKGUsbil7dGhpcy5lbGVtZW50PWUsdGhpcy50cmFuc3BhcmVudE5vcnRoU291dGhFZGdlcz1ufXAoMTc4OCw2NjYsezg1MjoxfSxCd2UpLGwuZ2V0SW5jb21pbmdFZGdlcz1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGkscyx1LGM7aWYodGhpcy50cmFuc3BhcmVudE5vcnRoU291dGhFZGdlcyYmYSh0aGlzLmVsZW1lbnQsMTIpLm93bmVyLnR5cGVfMD09KFdlKCksdGkpKXJldHVybiBOZSgpLE5lKCksT3Q7aWYoIXRoaXMuaW5jb21pbmdFZGdlQWRhcHRlcnMpe2Zvcih0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzPW5ldyBRLHQ9bmV3IFQoYSh0aGlzLmVsZW1lbnQsMTIpLmluY29taW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyh0KSwxOCksZWUodGhpcy5pbmNvbWluZ0VkZ2VBZGFwdGVycyxuZXcgRUUobikpO2lmKHRoaXMudHJhbnNwYXJlbnROb3J0aFNvdXRoRWRnZXMmJihvPWEodyhhKHRoaXMuZWxlbWVudCwxMiksKEsoKSxvYSkpLDEwKSxvKSlmb3Iocj1uZXcgWGUoUWUodHQobykudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHIpOyluPWEodG4ociksMTgpLGVlKHRoaXMuaW5jb21pbmdFZGdlQWRhcHRlcnMsbmV3IEVFKG4pKTtpZihfcihhKHRoaXMuZWxlbWVudCwxMikub3duZXIsKEsoKSxaMSkpJiYodT1hKHcoYSh0aGlzLmVsZW1lbnQsMTIpLm93bmVyLFoxKSwzMzcpLGM9YSh4cyh1LnNsUG9ydHMsdGhpcy5lbGVtZW50KSwxMTMpLGMpKWZvcihzPW5ldyBUKGMuaW5jb21pbmdTTEVkZ2VzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMzQwKSxlZSh0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzLG5ldyBFRShpLmxFZGdlKSl9cmV0dXJuIHRoaXMuaW5jb21pbmdFZGdlQWRhcHRlcnN9LGwuZ2V0TGFiZWxzPWZ1bmN0aW9uKCl7dmFyIG4scjtpZighdGhpcy5sYWJlbEFkYXB0ZXJzKWZvcih0aGlzLmxhYmVsQWRhcHRlcnM9TnUoYSh0aGlzLmVsZW1lbnQsMTIpLmxhYmVscy5hcnJheS5sZW5ndGgpLHI9bmV3IFQoYSh0aGlzLmVsZW1lbnQsMTIpLmxhYmVscyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDcyKSxlZSh0aGlzLmxhYmVsQWRhcHRlcnMsbmV3IGY0KG4pKTtyZXR1cm4gdGhpcy5sYWJlbEFkYXB0ZXJzfSxsLmdldE91dGdvaW5nRWRnZXM9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHMsdSxjO2lmKHRoaXMudHJhbnNwYXJlbnROb3J0aFNvdXRoRWRnZXMmJmEodGhpcy5lbGVtZW50LDEyKS5vd25lci50eXBlXzA9PShXZSgpLHRpKSlyZXR1cm4gTmUoKSxOZSgpLE90O2lmKCF0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzKXtmb3IodGhpcy5vdXRnb2luZ0VkZ2VBZGFwdGVycz1uZXcgUSx0PW5ldyBUKGEodGhpcy5lbGVtZW50LDEyKS5vdXRnb2luZ0VkZ2VzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEModCksMTgpLGVlKHRoaXMub3V0Z29pbmdFZGdlQWRhcHRlcnMsbmV3IEVFKG4pKTtpZih0aGlzLnRyYW5zcGFyZW50Tm9ydGhTb3V0aEVkZ2VzJiYobz1hKHcoYSh0aGlzLmVsZW1lbnQsMTIpLChLKCksb2EpKSwxMCksbykpZm9yKHI9bmV3IFhlKFFlKFJyKG8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspbj1hKHRuKHIpLDE4KSxlZSh0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzLG5ldyBFRShuKSk7aWYoX3IoYSh0aGlzLmVsZW1lbnQsMTIpLm93bmVyLChLKCksWjEpKSYmKHU9YSh3KGEodGhpcy5lbGVtZW50LDEyKS5vd25lcixaMSksMzM3KSxjPWEoeHModS5zbFBvcnRzLHRoaXMuZWxlbWVudCksMTEzKSxjKSlmb3Iocz1uZXcgVChjLm91dGdvaW5nU0xFZGdlcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDM0MCksZWUodGhpcy5vdXRnb2luZ0VkZ2VBZGFwdGVycyxuZXcgRUUoaS5sRWRnZSkpfXJldHVybiB0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzfSxsLmdldFNpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLmVsZW1lbnQsMTIpLnNpZGV9LGwuaGFzQ29tcG91bmRDb25uZWN0aW9ucz1mdW5jdGlvbigpe3JldHVybiBhZShpZSh3KGEodGhpcy5lbGVtZW50LDEyKSwoSygpLEEzKSkpKX0sbC5pbmNvbWluZ0VkZ2VBZGFwdGVycz1udWxsLGwubGFiZWxBZGFwdGVycz1udWxsLGwub3V0Z29pbmdFZGdlQWRhcHRlcnM9bnVsbCxsLnRyYW5zcGFyZW50Tm9ydGhTb3V0aEVkZ2VzPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxHcmFwaEFkYXB0ZXJzL0xQb3J0QWRhcHRlciIsMTc4OCk7ZnVuY3Rpb24gUWluKGUsbil7dmFyIHIsdCxvLGk7aWYoaT1lLnNpZGUub3JkaW5hbC1uLnNpZGUub3JkaW5hbCxpIT0wKXJldHVybiBpO2lmKHI9YSh3KGUsKG9lKCksV2MpKSwxNyksdD1hKHcobixXYyksMTcpLHImJnQmJihvPXIudmFsdWVfMC10LnZhbHVlXzAsbyE9MCkpcmV0dXJuIG87c3dpdGNoKGUuc2lkZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIGlyKGUucG9zLnhfMCxuLnBvcy54XzApO2Nhc2UgMjpyZXR1cm4gaXIoZS5wb3MueV8wLG4ucG9zLnlfMCk7Y2FzZSAzOnJldHVybiBpcihuLnBvcy54XzAsZS5wb3MueF8wKTtjYXNlIDQ6cmV0dXJuIGlyKG4ucG9zLnlfMCxlLnBvcy55XzApO2RlZmF1bHQ6dGhyb3cgYihuZXcgcm8oIlBvcnQgc2lkZSBpcyB1bmRlZmluZWQiKSl9fWZ1bmN0aW9uIEd3ZSgpe31wKDE3ODksMSxObixHd2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIFFpbihhKG4sMTIpLGEociwxMikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxHcmFwaEFkYXB0ZXJzL1BvcnRDb21wYXJhdG9yIiwxNzg5KTtmdW5jdGlvbiB4Vygpe31wKDgxOCwxLEluLHhXKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEwKSx3RSgpLCEwfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMR3JhcGhBZGFwdGVycy9sYW1iZGEkMCRUeXBlIiw4MTgpO2Z1bmN0aW9uIGVhbihlLG4pe3ZhciByO3N3aXRjaChyPWUub3duZXIsbi5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuLShlLnBvcy55XzArZS5zaXplXzAueV8wKTtjYXNlIDI6cmV0dXJuIGUucG9zLnhfMC1yLnNpemVfMC54XzA7Y2FzZSAzOnJldHVybiBlLnBvcy55XzAtci5zaXplXzAueV8wO2Nhc2UgNDpyZXR1cm4tKGUucG9zLnhfMCtlLnNpemVfMC54XzApfXJldHVybiAwfWZ1bmN0aW9uIEh3ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihvPWUub3duZXIscz1vLnNpemVfMC54XzAsaT1vLnNpemVfMC55XzAsczw9MCYmaTw9MClyZXR1cm4gcmUoKSxPbztzd2l0Y2goXz1lLnBvcy54XzAsZD1lLnBvcy55XzAsdT1lLnNpemVfMC54XzAscj1lLnNpemVfMC55XzAsbi5vcmRpbmFsKXtjYXNlIDI6Y2FzZSAxOmlmKF88MClyZXR1cm4gcmUoKSxqZTtpZihfK3U+cylyZXR1cm4gcmUoKSxxZTticmVhaztjYXNlIDQ6Y2FzZSAzOmlmKGQ8MClyZXR1cm4gcmUoKSxVZTtpZihkK3I+aSlyZXR1cm4gcmUoKSxsbn1yZXR1cm4gYz0oXyt1LzIpL3MsdD0oZCtyLzIpL2ksYyt0PD0xJiZjLXQ8PTA/KHJlKCksamUpOmMrdD49MSYmYy10Pj0wPyhyZSgpLHFlKTp0PC41PyhyZSgpLFVlKToocmUoKSxsbil9ZnVuY3Rpb24gbmFuKGUsbixyKXtzd2l0Y2goci5vcmRpbmFsKXtjYXNlIDE6ZS54XzA9bi54XzAvMixlLnlfMD0wO2JyZWFrO2Nhc2UgMjplLnhfMD1uLnhfMCxlLnlfMD1uLnlfMC8yO2JyZWFrO2Nhc2UgMzplLnhfMD1uLnhfMC8yLGUueV8wPW4ueV8wO2JyZWFrO2Nhc2UgNDplLnhfMD0wLGUueV8wPW4ueV8wLzJ9fWZ1bmN0aW9uIFBXKGUsbixyKXt2YXIgdCxvLGk7aWYobiE9cil7dD1uO2RvIEtuKGUsdC5vZmZzZXQpLG89dC5wYXJlbnROb2RlLG8mJihpPXQucGFkZGluZyxtZChlLGkubGVmdCxpLnRvcF8wKSxLbihlLG8ucG9zKSx0PVN0KG8pKTt3aGlsZShvKTt0PXI7ZG8gcnQoZSx0Lm9mZnNldCksbz10LnBhcmVudE5vZGUsbyYmKGk9dC5wYWRkaW5nLEZ2KGUsaS5sZWZ0LGkudG9wXzApLHJ0KGUsby5wb3MpLHQ9U3QobykpO3doaWxlKG8pfX1mdW5jdGlvbiB1MyhlLG4scix0LG8saSxzLHUsYyl7dmFyIF8sZCxmLGgsbSx5LEU7c3dpdGNoKG09cixkPW5ldyBhYyhjKSx6XyhkLChXZSgpLEZyKSksaihkLChLKCksUVYpLHMpLGooZCwob2UoKSx4ciksKGR0KCksYWkpKSxFPVIoJChlLmdldFByb3BlcnR5KExmKSkpLGooZCxMZixFKSxmPW5ldyBabyxMbyhmLGQpLG4hPUhzJiZuIT1xMHx8KHQ+PTA/bT1mbSh1KTptPUJUKGZtKHUpKSxlLnNldFByb3BlcnR5KGF3LG0pKSxfPW5ldyBtdCxoPSExLGUuaGFzUHJvcGVydHkocmQpPyhuUShfLGEoZS5nZXRQcm9wZXJ0eShyZCksOCkpLGg9ITApOlcybihfLHMueF8wLzIscy55XzAvMiksbS5vcmRpbmFsKXtjYXNlIDQ6aihkLEVpLChybCgpLEYwKSksaihkLGRQLCgkXygpLEtwKSksZC5zaXplXzAueV8wPXMueV8wLEU8MCYmKGQuc2l6ZV8wLnhfMD0tRSksWHIoZiwocmUoKSxxZSkpLGh8fChfLnhfMD1zLnhfMCksXy54XzAtPXMueF8wO2JyZWFrO2Nhc2UgMjpqKGQsRWksKHJsKCkseGYpKSxqKGQsZFAsKCRfKCksSnkpKSxkLnNpemVfMC55XzA9cy55XzAsRTwwJiYoZC5zaXplXzAueF8wPS1FKSxYcihmLChyZSgpLGplKSksaHx8KF8ueF8wPTApO2JyZWFrO2Nhc2UgMTpqKGQsQl8sKGxjKCksSnApKSxkLnNpemVfMC54XzA9cy54XzAsRTwwJiYoZC5zaXplXzAueV8wPS1FKSxYcihmLChyZSgpLGxuKSksaHx8KF8ueV8wPXMueV8wKSxfLnlfMC09cy55XzA7YnJlYWs7Y2FzZSAzOmooZCxCXywobGMoKSxHaCkpLGQuc2l6ZV8wLnhfMD1zLnhfMCxFPDAmJihkLnNpemVfMC55XzA9LUUpLFhyKGYsKHJlKCksVWUpKSxofHwoXy55XzA9MCl9aWYoblEoZi5wb3MsXyksaihkLHJkLF8pLG49PW8xfHxuPT1IdXx8bj09YWkpe2lmKHk9MCxuPT1vMSYmZS5oYXNQcm9wZXJ0eShXYykpc3dpdGNoKG0ub3JkaW5hbCl7Y2FzZSAxOmNhc2UgMjp5PWEoZS5nZXRQcm9wZXJ0eShXYyksMTcpLnZhbHVlXzA7YnJlYWs7Y2FzZSAzOmNhc2UgNDp5PS1hKGUuZ2V0UHJvcGVydHkoV2MpLDE3KS52YWx1ZV8wfWVsc2Ugc3dpdGNoKG0ub3JkaW5hbCl7Y2FzZSA0OmNhc2UgMjp5PWkueV8wLG49PUh1JiYoeS89by55XzApO2JyZWFrO2Nhc2UgMTpjYXNlIDM6eT1pLnhfMCxuPT1IdSYmKHkvPW8ueF8wKX1qKGQsSjEseSl9cmV0dXJuIGooZCxEbyxtKSxkfWZ1bmN0aW9uIFV3ZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZDtpZihpPWc0KHQpLHU9YWUoaWUodyh0LChvZSgpLG9ZKSkpKSwodXx8YWUoaWUodyhlLENQKSkpKSYmIU9nKGEodyhlLHhyKSwxMDEpKSlvPWZtKGkpLGM9QVcoZSxyLHI9PShxdCgpLHBpKT9vOkJUKG8pKTtlbHNlIHN3aXRjaChjPW5ldyBabyxMbyhjLGUpLG4/KGQ9Yy5wb3MsZC54XzA9bi54XzAtZS5wb3MueF8wLGQueV8wPW4ueV8wLWUucG9zLnlfMCxJRGUoZCwwLDAsZS5zaXplXzAueF8wLGUuc2l6ZV8wLnlfMCksWHIoYyxId2UoYyxpKSkpOihvPWZtKGkpLFhyKGMscj09KHF0KCkscGkpP286QlQobykpKSxzPWEodyh0LChLKCksaWkpKSwyMSksXz1jLnNpZGUsaS5vcmRpbmFsKXtjYXNlIDI6Y2FzZSAxOihfPT0ocmUoKSxVZSl8fF89PWxuKSYmcy5hZGRfMigoVnQoKSxYcCkpO2JyZWFrO2Nhc2UgNDpjYXNlIDM6KF89PShyZSgpLHFlKXx8Xz09amUpJiZzLmFkZF8yKChWdCgpLFhwKSl9cmV0dXJuIGN9ZnVuY3Rpb24gcmFuKGUpe3ZhciBuLHIsdCxvO2lmKEFnKGEodyhlLm93bmVyLChvZSgpLE9hKSksODgpKSlyZXR1cm4gMDtmb3Iobj0wLHQ9bmV3IFQoZS5ub2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDEwKSxyLnR5cGVfMD09KFdlKCksa3IpJiYobz1yLnNpemVfMC54XzAsbj1TLk1hdGgubWF4KG4sbykpO3JldHVybiBufWZ1bmN0aW9uIGc0KGUpe3ZhciBuLHI7cmV0dXJuIHI9YSh3KGUsKG9lKCksT2EpKSw4OCkscj09KFdyKCksQnMpPyhuPVIoJCh3KGUsZ1ApKSksbj49MT9tbzokcyk6cn1mdW5jdGlvbiBXd2UoZSxuLHIsdCl7dmFyIG8saSxzLHUsYztzd2l0Y2goYz1uZXcgUnQobi5wb3MpLGMueF8wKz1uLnNpemVfMC54XzAvMixjLnlfMCs9bi5zaXplXzAueV8wLzIsdT1SKCQodyhuLChvZSgpLExmKSkpKSxpPWUuc2l6ZV8wLHM9ZS5wYWRkaW5nLG89ZS5vZmZzZXQsYSh3KG4sKEsoKSxEbykpLDY0KS5vcmRpbmFsKXtjYXNlIDE6Yy54XzArPXMubGVmdCtvLnhfMC1yLzIsYy55XzA9LXQtdSxuLnBvcy55XzA9LShzLnRvcF8wK3Urby55XzApO2JyZWFrO2Nhc2UgMjpjLnhfMD1pLnhfMCtzLmxlZnQrcy5yaWdodCt1LGMueV8wKz1zLnRvcF8wK28ueV8wLXQvMixuLnBvcy54XzA9aS54XzArcy5yaWdodCt1LW8ueF8wO2JyZWFrO2Nhc2UgMzpjLnhfMCs9cy5sZWZ0K28ueF8wLXIvMixjLnlfMD1pLnlfMCtzLnRvcF8wK3MuYm90dG9tK3Usbi5wb3MueV8wPWkueV8wK3MuYm90dG9tK3Utby55XzA7YnJlYWs7Y2FzZSA0OmMueF8wPS1yLXUsYy55XzArPXMudG9wXzArby55XzAtdC8yLG4ucG9zLnhfMD0tKHMubGVmdCt1K28ueF8wKX1yZXR1cm4gY31mdW5jdGlvbiBoNChlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9bnVsbCxfcihlLChGbigpLHNtKSkmJihyPWEodyhlLHNtKSw5Niksci5oYXNQcm9wZXJ0eShuKSYmKHQ9ci5nZXRQcm9wZXJ0eShuKSkpLHQ9PW51bGwmJlN0KGUpJiYodD13KFN0KGUpLG4pKSx0fWZ1bmN0aW9uIGp3ZShlKXt2YXIgbixyLHQ7Zm9yKHQ9cW4scj1uZXcgVChlLmxheWVybGVzc05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTApLF9yKG4sKEsoKSxycikpJiYodD1TLk1hdGgubWluKHQsYSh3KG4scnIpLDE3KS52YWx1ZV8wKSk7cmV0dXJuIHR9ZnVuY3Rpb24gdGFuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXztpZih1PWUuc2lkZSx1PT0ocmUoKSxPbykmJm4hPShkdCgpLEhzKSYmbiE9KGR0KCkscTApJiYodT1Id2UoZSxyKSxYcihlLHUpLCEoZS5wcm9wZXJ0eU1hcD9lLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5jb250YWluc0tleSgob2UoKSxMZikpJiZ1IT1PbyYmKGUucG9zLnhfMCE9MHx8ZS5wb3MueV8wIT0wKSYmaihlLExmLGVhbihlLHUpKSksbj09KGR0KCksSHUpKXtzd2l0Y2goXz0wLHUub3JkaW5hbCl7Y2FzZSAxOmNhc2UgMzppPWUub3duZXIuc2l6ZV8wLnhfMCxpPjAmJihfPWUucG9zLnhfMC9pKTticmVhaztjYXNlIDI6Y2FzZSA0Om89ZS5vd25lci5zaXplXzAueV8wLG8+MCYmKF89ZS5wb3MueV8wL28pfWooZSwoSygpLEoxKSxfKX1pZihjPWUuc2l6ZV8wLHM9ZS5hbmNob3IsdClzLnhfMD10LnhfMCxzLnlfMD10LnlfMCxlLmV4cGxpY2l0bHlTdXBwbGllZFBvcnRBbmNob3I9ITA7ZWxzZSBpZihuIT1IcyYmbiE9cTAmJnUhPU9vKXN3aXRjaCh1Lm9yZGluYWwpe2Nhc2UgMTpzLnhfMD1jLnhfMC8yO2JyZWFrO2Nhc2UgMjpzLnhfMD1jLnhfMCxzLnlfMD1jLnlfMC8yO2JyZWFrO2Nhc2UgMzpzLnhfMD1jLnhfMC8yLHMueV8wPWMueV8wO2JyZWFrO2Nhc2UgNDpzLnlfMD1jLnlfMC8yfWVsc2Ugcy54XzA9Yy54XzAvMixzLnlfMD1jLnlfMC8yfWZ1bmN0aW9uIFJ5KGUsbil7dmFyIHIsdDtmb3Iocj1lLHQ9U3QocikucGFyZW50Tm9kZTt0Oyl7aWYocj10LHI9PW4pcmV0dXJuITA7dD1TdChyKS5wYXJlbnROb2RlfXJldHVybiExfWZ1bmN0aW9uIG9hbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKGk9bmV3IFkobixyKSxkPW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoXz1hKEMoZCksMTApLEtuKF8ucG9zLGkpLGg9bmV3IFQoXy5wb3J0cyk7aC5pPGgudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihmPWEoQyhoKSwxMiksbz1uZXcgVChmLm91dGdvaW5nRWRnZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksMTgpLFVmKHQuYmVuZFBvaW50cyxpKSxzPWEodyh0LChvZSgpLGlvKSksNzUpLHMmJlVmKHMsaSksYz1uZXcgVCh0LmxhYmVscyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDcyKSxLbih1LnBvcyxpKX1mdW5jdGlvbiBOVyhlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4O2ZvcihpPTAscz0wLF89bmV3IFQoZS5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKF8pLDEwKSxpPVMuTWF0aC5tYXgoaSx1Lm1hcmdpbi5sZWZ0KSxzPVMuTWF0aC5tYXgocyx1Lm1hcmdpbi5yaWdodCk7Zm9yKGM9bmV3IFQoZS5ub2Rlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtzd2l0Y2godT1hKEMoYyksMTApLHI9YSh3KHUsKG9lKCksX3UpKSwyNTUpLHIub3JkaW5hbCl7Y2FzZSAxOnk9MDticmVhaztjYXNlIDI6eT0xO2JyZWFrO2Nhc2UgNTp5PS41O2JyZWFrO2RlZmF1bHQ6Zm9yKHQ9MCxmPTAsbT1uZXcgVCh1LnBvcnRzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaD1hKEMobSksMTIpLGguaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTB8fCsrdCxoLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wfHwrK2Y7dCtmPT0wP3k9LjU6eT1mLyh0K2YpfXY9ZS5zaXplXzAsZD11LnNpemVfMC54XzAseD0odi54XzAtZCkqeSx5Pi41P3gtPXMqMiooeS0uNSk6eTwuNSYmKHgrPWkqMiooLjUteSkpLG89dS5tYXJnaW4ubGVmdCx4PG8mJih4PW8pLEU9dS5tYXJnaW4ucmlnaHQseD52LnhfMC1FLWQmJih4PXYueF8wLUUtZCksdS5wb3MueF8wPW4reH19ZnVuY3Rpb24gQVcoZSxuLHIpe3ZhciB0LG8saSxzLHU7c3dpdGNoKHU9bnVsbCxuLm9yZGluYWwpe2Nhc2UgMTpmb3Iobz1uZXcgVChlLnBvcnRzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYodD1hKEMobyksMTIpLGFlKGllKHcodCwoSygpLGNPKSkpKSlyZXR1cm4gdDt1PW5ldyBabyxqKHUsKEsoKSxjTyksKHplKCksITApKTticmVhaztjYXNlIDI6Zm9yKHM9bmV3IFQoZS5wb3J0cyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKGk9YShDKHMpLDEyKSxhZShpZSh3KGksKEsoKSxkTykpKSkpcmV0dXJuIGk7dT1uZXcgWm8saih1LChLKCksZE8pLCh6ZSgpLCEwKSl9cmV0dXJuIHUmJihMbyh1LGUpLFhyKHUsciksbmFuKHUucG9zLGUuc2l6ZV8wLHIpKSx1fWZ1bmN0aW9uIFZ3ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4O2lmKGg9bmV3IFJ0KGUuc2l6ZV8wKSx4PW4ueF8wL2gueF8wLHU9bi55XzAvaC55XzAsRT1uLnhfMC1oLnhfMCxpPW4ueV8wLWgueV8wLHIpZm9yKG89RCh3KGUsKG9lKCkseHIpKSk9PT1EKChkdCgpLGFpKSkseT1uZXcgVChlLnBvcnRzKTt5Lmk8eS50aGlzJDAxLmFycmF5Lmxlbmd0aDspc3dpdGNoKG09YShDKHkpLDEyKSxtLnNpZGUub3JkaW5hbCl7Y2FzZSAxOm98fChtLnBvcy54XzAqPXgpO2JyZWFrO2Nhc2UgMjptLnBvcy54XzArPUUsb3x8KG0ucG9zLnlfMCo9dSk7YnJlYWs7Y2FzZSAzOm98fChtLnBvcy54XzAqPXgpLG0ucG9zLnlfMCs9aTticmVhaztjYXNlIDQ6b3x8KG0ucG9zLnlfMCo9dSl9Zm9yKF89bmV3IFQoZS5sYWJlbHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSw3MiksZD1jLnBvcy54XzArYy5zaXplXzAueF8wLzIsZj1jLnBvcy55XzArYy5zaXplXzAueV8wLzIsdj1kL2gueF8wLHM9Zi9oLnlfMCx2K3M+PTEmJih2LXM+MCYmZj49MD8oYy5wb3MueF8wKz1FLGMucG9zLnlfMCs9aSpzKTp2LXM8MCYmZD49MCYmKGMucG9zLnhfMCs9RSp2LGMucG9zLnlfMCs9aSkpO2Uuc2l6ZV8wLnhfMD1uLnhfMCxlLnNpemVfMC55XzA9bi55XzAsaihlLChvZSgpLGpfKSwoU2EoKSx0PWEoaXModFMpLDkpLG5ldyBKYSh0LGEoRGwodCx0Lmxlbmd0aCksOSksMCkpKX1mdW5jdGlvbiBjdShlKXtyZXR1cm4gYShJcyhlLEIobjksZjYsMTgsZS5hcnJheS5sZW5ndGgsMCwxKSksNDgzKX1mdW5jdGlvbiBjMyhlKXtyZXR1cm4gYShJcyhlLEIoUnUsSWMsMTAsZS5hcnJheS5sZW5ndGgsMCwxKSksMTk5KX1mdW5jdGlvbiBxd2UoZSl7cmV0dXJuIGEoSXMoZSxCKG8yZSxnaWUsMTIsZS5hcnJheS5sZW5ndGgsMCwxKSksMjA0Mil9ZnVuY3Rpb24gTFcoKXt0aGlzLnBvcz1uZXcgbXQsdGhpcy5zaXplXzA9bmV3IG10fXAoNDA0LDMwNSx7MzoxLDMwNToxLDQwNDoxLDk2OjEsMTM3OjF9KSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMU2hhcGUiLDQwNCk7ZnVuY3Rpb24gaWFuKGUpe3JldHVybiBlLnRleHRfMD9lLnRleHRfMDplOShlKX1mdW5jdGlvbiBZd2UoKXtrVy5jYWxsKHRoaXMsIiIpfWZ1bmN0aW9uIGtXKGUpe0xXLmNhbGwodGhpcyksdGhpcy50ZXh0XzA9ZX1wKDcyLDQwNCx7MzoxLDMwNToxLDcyOjEsNDA0OjEsOTY6MSwxMzc6MX0sWXdlLGtXKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1pYW4odGhpcyksbj09bnVsbD8ibGFiZWwiOiJsXyIrbn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTExhYmVsIiw3Mik7ZnVuY3Rpb24gS3dlKGUsbil7cmV0dXJuIGUubGVmdCs9bi5sZWZ0LGUucmlnaHQrPW4ucmlnaHQsZS50b3BfMCs9bi50b3BfMCxlLmJvdHRvbSs9bi5ib3R0b20sZX1mdW5jdGlvbiBPVyhlLG4pe3JldHVybiBlLmxlZnQ9bi5sZWZ0LGUucmlnaHQ9bi5yaWdodCxlLnRvcF8wPW4udG9wXzAsZS5ib3R0b209bi5ib3R0b20sZX1mdW5jdGlvbiBNVyhlLG4scix0LG8pe2UudG9wXzA9bixlLnJpZ2h0PXIsZS5ib3R0b209dCxlLmxlZnQ9b31mdW5jdGlvbiBhYW4oZSxuKXtlLmJvdHRvbT1ufWZ1bmN0aW9uIGxhbihlLG4pe2UubGVmdD1ufWZ1bmN0aW9uIHNhbihlLG4pe2UucmlnaHQ9bn1mdW5jdGlvbiB1YW4oZSxuKXtlLnRvcF8wPW59ZnVuY3Rpb24gWHdlKCl7fWZ1bmN0aW9uIG00KGUsbixyLHQpe01XKHRoaXMsZSxuLHIsdCl9ZnVuY3Rpb24gSndlKGUsbil7dmFyIHI7Zm9yKHI9MDtyPG4ubGVuZ3RoO3IrKylpZihlPT0oSGUocixuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHIpKSlyZXR1cm4hMDtyZXR1cm4hMX1wKDIxNCwxLHszOjEsNDoxLDIxNDoxLDQyMzoxfSksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDIxNCk/KHI9YShuLDIxNCksdGhpcy50b3BfMD09ci50b3BfMCYmdGhpcy5ib3R0b209PXIuYm90dG9tJiZ0aGlzLmxlZnQ9PXIubGVmdCYmdGhpcy5yaWdodD09ci5yaWdodCk6ITF9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIG49Y2godGhpcy5sZWZ0KTw8MTYsbnw9Y2godGhpcy5ib3R0b20pJnpyLHI9Y2godGhpcy5yaWdodCk8PDE2LHJ8PWNoKHRoaXMudG9wXzApJnpyLG5ecn0sbC5wYXJzZV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKHM9MDtzPG4ubGVuZ3RoJiZKd2UoKEhlKHMsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChzKSksYChbeyInIAlccgpgKTspKytzO2ZvcihyPW4ubGVuZ3RoO3I+MCYmSndlKChIZShyLTEsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChyLTEpKSxgKV19IicgCVxyCmApOyktLXI7aWYoczxyKXtmPWVmKChndChzLHIsbi5sZW5ndGgpLG4uc3Vic3RyKHMsci1zKSksIix8OyIpO3RyeXtmb3IoYz1mLF89MCxkPWMubGVuZ3RoO188ZDsrK18pe2lmKHU9Y1tfXSxpPWVmKHUsIj0iKSxpLmxlbmd0aCE9Mil0aHJvdyBiKG5ldyBHZSgiRXhwZWN0aW5nIGEgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMuIikpO289bmYoaVswXSksaD1RZChuZihpWzFdKSksVGUobywidG9wIik/dGhpcy50b3BfMD1oOlRlKG8sImxlZnQiKT90aGlzLmxlZnQ9aDpUZShvLCJib3R0b20iKT90aGlzLmJvdHRvbT1oOlRlKG8sInJpZ2h0IikmJih0aGlzLnJpZ2h0PWgpfX1jYXRjaChtKXt0aHJvdyBtPXdyKG0pLEwobSwxMzApPyh0PW0sYihuZXcgR2UoIlRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgcGFydHMgdGhhdCBjYW5ub3QgYmUgcGFyc2VkIGFzIG51bWJlcnMuIit0KSkpOmIobSl9fX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIlt0b3A9Iit0aGlzLnRvcF8wKyIsbGVmdD0iK3RoaXMubGVmdCsiLGJvdHRvbT0iK3RoaXMuYm90dG9tKyIscmlnaHQ9Iit0aGlzLnJpZ2h0KyJdIn0sbC5ib3R0b209MCxsLmxlZnQ9MCxsLnJpZ2h0PTAsbC50b3BfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLm1hdGgiLCJTcGFjaW5nIiwyMTQpO2Z1bmN0aW9uIHZFKCl7WHdlLmNhbGwodGhpcyl9ZnVuY3Rpb24gWndlKCl7bTQuY2FsbCh0aGlzLDAsMCwwLDApfWZ1bmN0aW9uIFJXKGUsbixyLHQpe200LmNhbGwodGhpcyxlLG4scix0KX1mdW5jdGlvbiB0OShlKXttNC5jYWxsKHRoaXMsZS50b3BfMCxlLnJpZ2h0LGUuYm90dG9tLGUubGVmdCl9cCgxNDAsMjE0LGhpZSx2RSxad2UsUlcsdDkpO3ZhciBEVz1nKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5tYXRoIiwiRWxrTWFyZ2luIiwxNDApO2Z1bmN0aW9uIG85KCl7dkUuY2FsbCh0aGlzKX1wKDY2MCwxNDAsaGllLG85KSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMTWFyZ2luIiw2NjApO2Z1bmN0aW9uIHk0KGUsbixyKXt2YXIgdCxvLGkscztzPVN0KGUpLHQ9cy5wYWRkaW5nLG89cy5vZmZzZXQsaT1lLnBvcyxuJiYoaS54XzA9aS54XzAtdC5sZWZ0LW8ueF8wKSxyJiYoaS55XzA9aS55XzAtdC50b3BfMC1vLnlfMCl9ZnVuY3Rpb24gRlcoZSl7dmFyIG4scix0LG87Zm9yKGUucG9ydFNpZGVJbmRpY2VzPW5ldyBRMihhKHZuKCR0KSwyOTcpKSx0PTAscj0ocmUoKSxVZSksbj0wO248ZS5wb3J0cy5hcnJheS5sZW5ndGg7bisrKW89YShsZShlLnBvcnRzLG4pLDEyKSxvLnNpZGUhPXImJih0IT1uJiZ5aChlLnBvcnRTaWRlSW5kaWNlcyxyLG5ldyBacihKKHQpLEoobikpKSxyPW8uc2lkZSx0PW4pO3loKGUucG9ydFNpZGVJbmRpY2VzLHIsbmV3IFpyKEoodCksSihuKSkpfWZ1bmN0aW9uIGljKGUpe3ZhciBuLHIsdDtmb3Iobj1uZXcgUSx0PW5ldyBUKGUucG9ydHMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxMiksZWUobixyLmNvbm5lY3RlZEVkZ2VzKTtyZXR1cm4gdm4obiksbmV3IFAyKG4pfWZ1bmN0aW9uIF8zKGUpe3ZhciBuO3JldHVybiBlLmxhYmVscy5hcnJheS5sZW5ndGghPTAmJmEobGUoZS5sYWJlbHMsMCksNzIpLnRleHRfMD9hKGxlKGUubGFiZWxzLDApLDcyKS50ZXh0XzA6KG49ZTkoZSksbj8/IiIrKGUubGF5ZXI/Zm8oZS5sYXllci5ub2RlcyxlLDApOi0xKSl9ZnVuY3Rpb24gU3QoZSl7cmV0dXJuIWUuZ3JhcGhfMCYmZS5sYXllcj9lLmxheWVyLm93bmVyOmUuZ3JhcGhfMH1mdW5jdGlvbiB0dChlKXt2YXIgbixyLHQ7Zm9yKG49bmV3IFEsdD1uZXcgVChlLnBvcnRzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTIpLGVlKG4sci5pbmNvbWluZ0VkZ2VzKTtyZXR1cm4gdm4obiksbmV3IFAyKG4pfWZ1bmN0aW9uIFF3ZShlKXtyZXR1cm4gZS5sYXllcj9mbyhlLmxheWVyLm5vZGVzLGUsMCk6LTF9ZnVuY3Rpb24gelcoZSl7dmFyIG4scjtzd2l0Y2goYSh3KFN0KGUpLChvZSgpLFFxKSksNDI5KS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG49ZS5wb3Mscj1lLnNpemVfMCxuZXcgWShuLnhfMCtyLnhfMC8yLG4ueV8wK3IueV8wLzIpO2Nhc2UgMTpyZXR1cm4gbmV3IFJ0KGUucG9zKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBScihlKXt2YXIgbixyLHQ7Zm9yKG49bmV3IFEsdD1uZXcgVChlLnBvcnRzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTIpLGVlKG4sci5vdXRnb2luZ0VkZ2VzKTtyZXR1cm4gdm4obiksbmV3IFAyKG4pfWZ1bmN0aW9uIEFvKGUsbil7dmFyIHI7cmV0dXJuIGUucG9ydFNpZGVzQ2FjaGVkfHxGVyhlKSxyPWEoWnQoZS5wb3J0U2lkZUluZGljZXMsbiksNDIpLHI/bmV3IE9jKGUucG9ydHMsYShyLmZpcnN0LDE3KS52YWx1ZV8wLGEoci5zZWNvbmQsMTcpLnZhbHVlXzApOihOZSgpLE5lKCksT3QpfWZ1bmN0aW9uIFUxKGUsbil7c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBpaChlLnBvcnRzLChVaSgpLGpXKSk7Y2FzZSAyOnJldHVybiBpaChlLnBvcnRzLChVaSgpLHFXKSk7ZGVmYXVsdDpyZXR1cm4gTmUoKSxOZSgpLE90fX1mdW5jdGlvbiAkVyhlLG4scil7dmFyIHQsbztzd2l0Y2gobz1udWxsLG4ub3JkaW5hbCl7Y2FzZSAxOm89KFVpKCksalcpO2JyZWFrO2Nhc2UgMjpvPShVaSgpLHFXKX1zd2l0Y2godD1udWxsLHIub3JkaW5hbCl7Y2FzZSAxOnQ9KFVpKCksVlcpO2JyZWFrO2Nhc2UgMjp0PShVaSgpLFdXKTticmVhaztjYXNlIDM6dD0oVWkoKSxZVyk7YnJlYWs7Y2FzZSA0OnQ9KFVpKCksS1cpfXJldHVybiBvJiZ0P2loKGUucG9ydHMsbmV3IFppZShuZXcgZWEoUChJKFdZZSwxKSxNZSwxNzgsMCxbYSh2bihvKSwxNzgpLGEodm4odCksMTc4KV0pKSkpOihOZSgpLE5lKCksT3QpfWZ1bmN0aW9uICRjKGUsbil7c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBpaChlLnBvcnRzLChVaSgpLFZXKSk7Y2FzZSAyOnJldHVybiBpaChlLnBvcnRzLChVaSgpLFdXKSk7Y2FzZSAzOnJldHVybiBpaChlLnBvcnRzLChVaSgpLFlXKSk7Y2FzZSA0OnJldHVybiBpaChlLnBvcnRzLChVaSgpLEtXKSk7ZGVmYXVsdDpyZXR1cm4gTmUoKSxOZSgpLE90fX1mdW5jdGlvbiB3ZihlLG4scil7aWYociYmKG48MHx8bj5yLm5vZGVzLmFycmF5Lmxlbmd0aCkpdGhyb3cgYihuZXcgR2UoImluZGV4IG11c3QgYmUgPj0gMCBhbmQgPD0gbGF5ZXIgbm9kZSBjb3VudCIpKTtlLmxheWVyJiZQaShlLmxheWVyLm5vZGVzLGUpLGUubGF5ZXI9cixyJiZBMShyLm5vZGVzLG4sZSl9ZnVuY3Rpb24gaHQoZSxuKXtlLmxheWVyJiZQaShlLmxheWVyLm5vZGVzLGUpLGUubGF5ZXI9bixlLmxheWVyJiZlZShlLmxheWVyLm5vZGVzLGUpfWZ1bmN0aW9uIHpfKGUsbil7ZS50eXBlXzA9bn1mdW5jdGlvbiBlMmUoZSl7dmFyIG47cmV0dXJuIG49bmV3IEMwLG4uc3RyaW5nKz0ibiIsZS50eXBlXzAhPShXZSgpLGtyKSYmT24oT24oKG4uc3RyaW5nKz0iKCIsbiksYTUoZS50eXBlXzApLnRvTG93ZXJDYXNlKCkpLCIpIiksT24oKG4uc3RyaW5nKz0iXyIsbiksXzMoZSkpLG4uc3RyaW5nfWZ1bmN0aW9uIGFjKGUpe0xXLmNhbGwodGhpcyksdGhpcy50eXBlXzA9KFdlKCksa3IpLHRoaXMucG9ydHM9KFBhKDYsImluaXRpYWxBcnJheVNpemUiKSxuZXcgX2koNikpLHRoaXMubGFiZWxzPShQYSgyLCJpbml0aWFsQXJyYXlTaXplIiksbmV3IF9pKDIpKSx0aGlzLm1hcmdpbj1uZXcgbzksdGhpcy5wYWRkaW5nPW5ldyBVVyx0aGlzLmdyYXBoXzA9ZX1wKDEwLDQwNCx7MzoxLDMwNToxLDEwOjEsNDA0OjEsOTY6MSwxMzc6MX0sYWMpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBlMmUodGhpcyl9LGwucG9ydFNpZGVzQ2FjaGVkPSExO3ZhciBSdT1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMTm9kZSIsMTApO2Z1bmN0aW9uIFdlKCl7V2U9Rixrcj1uZXcgU0UoIk5PUk1BTCIsMCksaXQ9bmV3IFNFKCJMT05HX0VER0UiLDEpLEZyPW5ldyBTRSgiRVhURVJOQUxfUE9SVCIsMiksdGk9bmV3IFNFKCJOT1JUSF9TT1VUSF9QT1JUIiwzKSxZbz1uZXcgU0UoIkxBQkVMIiw0KSxOcz1uZXcgU0UoIkJSRUFLSU5HX1BPSU5UIiw1KX1mdW5jdGlvbiBTRShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGNhbihlKXtyZXR1cm4gV2UoKSx3bigobjJlKCkscjJlKSxlKX1mdW5jdGlvbiBfYW4oKXtyZXR1cm4gV2UoKSxQKEkoaTksMSksVywyNzMsMCxba3IsaXQsRnIsdGksWW8sTnNdKX1wKDI3MywyMix7MzoxLDM0OjEsMjI6MSwyNzM6MX0sU0UpO3ZhciBOcyxGcixZbyxpdCxrcix0aSxpOT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTE5vZGUvTm9kZVR5cGUiLDI3MyxnbixfYW4sY2FuKTtmdW5jdGlvbiBuMmUoKXtuMmU9RixyMmU9eW4oKFdlKCksUChJKGk5LDEpLFcsMjczLDAsW2tyLGl0LEZyLHRpLFlvLE5zXSkpKX12YXIgcjJlO2Z1bmN0aW9uIEJXKCl7fXAoNzc1LDEsSW4sQlcpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhZShpZSh3KGEobiw3MiksKG9lKCksdk8pKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMTm9kZS9sYW1iZGEkMCRUeXBlIiw3NzUpO2Z1bmN0aW9uIE9oKCl7WHdlLmNhbGwodGhpcyl9ZnVuY3Rpb24gVzEoZSl7bTQuY2FsbCh0aGlzLGUsZSxlLGUpfWZ1bmN0aW9uIEdXKGUpe200LmNhbGwodGhpcyxlLnRvcF8wLGUucmlnaHQsZS5ib3R0b20sZS5sZWZ0KX1wKDEwNywyMTQsbWllLE9oLFcxLEdXKTt2YXIgSFc9Zygib3JnLmVjbGlwc2UuZWxrLmNvcmUubWF0aCIsIkVsa1BhZGRpbmciLDEwNyk7ZnVuY3Rpb24gVVcoKXtPaC5jYWxsKHRoaXMpfXAoNzc4LDEwNyxtaWUsVVcpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxQYWRkaW5nIiw3NzgpO2Z1bmN0aW9uIFVpKCl7VWk9RixxVz1uZXcgczJlLGpXPW5ldyBjMmUsVlc9bmV3IF8yZSxXVz1uZXcgZDJlLFlXPW5ldyBmMmUsS1c9bmV3IHAyZX1mdW5jdGlvbiBBcyhlKXtyZXR1cm4ga28oUChJKG90LDEpLFgsOCwwLFtlLm93bmVyLnBvcyxlLnBvcyxlLmFuY2hvcl0pKX1mdW5jdGlvbiBhOShlKXtyZXR1cm4gZS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCtlLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RofWZ1bmN0aW9uIHc0KGUpe3ZhciBuO3JldHVybiBlLmxhYmVscy5hcnJheS5sZW5ndGghPTAmJmEobGUoZS5sYWJlbHMsMCksNzIpLnRleHRfMD9hKGxlKGUubGFiZWxzLDApLDcyKS50ZXh0XzA6KG49ZTkoZSksbj8/IiIrKGUub3duZXI/Zm8oZS5vd25lci5wb3J0cyxlLDApOi0xKSl9ZnVuY3Rpb24gdDJlKGUpe3JldHVybiBlLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoLWUub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGh9ZnVuY3Rpb24gZGFuKGUsbil7ZS5jb25uZWN0ZWRUb0V4dGVybmFsTm9kZXM9bn1mdW5jdGlvbiBMbyhlLG4pe2Uub3duZXImJlBpKGUub3duZXIucG9ydHMsZSksZS5vd25lcj1uLGUub3duZXImJmVlKGUub3duZXIucG9ydHMsZSl9ZnVuY3Rpb24gWHIoZSxuKXtpZighbil0aHJvdyBiKG5ldyBfaCk7aWYoZS5zaWRlPW4sIWUuZXhwbGljaXRseVN1cHBsaWVkUG9ydEFuY2hvcilzd2l0Y2goZS5zaWRlLm9yZGluYWwpe2Nhc2UgMTplLmFuY2hvci54XzA9ZS5zaXplXzAueF8wLzIsZS5hbmNob3IueV8wPTA7YnJlYWs7Y2FzZSAyOmUuYW5jaG9yLnhfMD1lLnNpemVfMC54XzAsZS5hbmNob3IueV8wPWUuc2l6ZV8wLnlfMC8yO2JyZWFrO2Nhc2UgMzplLmFuY2hvci54XzA9ZS5zaXplXzAueF8wLzIsZS5hbmNob3IueV8wPWUuc2l6ZV8wLnlfMDticmVhaztjYXNlIDQ6ZS5hbmNob3IueF8wPTAsZS5hbmNob3IueV8wPWUuc2l6ZV8wLnlfMC8yfX1mdW5jdGlvbiBabygpe1VpKCksTFcuY2FsbCh0aGlzKSx0aGlzLnNpZGU9KHJlKCksT28pLHRoaXMuYW5jaG9yPW5ldyBtdCxuZXcgbzksdGhpcy5sYWJlbHM9KFBhKDIsImluaXRpYWxBcnJheVNpemUiKSxuZXcgX2koMikpLHRoaXMuaW5jb21pbmdFZGdlcz0oUGEoNCwiaW5pdGlhbEFycmF5U2l6ZSIpLG5ldyBfaSg0KSksdGhpcy5vdXRnb2luZ0VkZ2VzPShQYSg0LCJpbml0aWFsQXJyYXlTaXplIiksbmV3IF9pKDQpKSx0aGlzLmNvbm5lY3RlZEVkZ2VzPW5ldyBhMmUodGhpcy5pbmNvbWluZ0VkZ2VzLHRoaXMub3V0Z29pbmdFZGdlcyl9cCgxMiw0MDQsezM6MSwzMDU6MSwxMjoxLDQwNDoxLDk2OjEsMTM3OjF9LFpvKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7cmV0dXJuIG49bmV3IEMwLE9uKChuLnN0cmluZys9InBfIixuKSx3NCh0aGlzKSksdGhpcy5vd25lciYmT24oZWkoKG4uc3RyaW5nKz0iWyIsbiksdGhpcy5vd25lciksIl0iKSx0aGlzLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0xJiZ0aGlzLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wJiZhKGxlKHRoaXMuaW5jb21pbmdFZGdlcywwKSwxOCkuc291cmNlIT10aGlzJiYocj1hKGxlKHRoaXMuaW5jb21pbmdFZGdlcywwKSwxOCkuc291cmNlLE9uKChuLnN0cmluZys9IiA8PCAiLG4pLHc0KHIpKSxPbihlaSgobi5zdHJpbmcrPSJbIixuKSxyLm93bmVyKSwiXSIpKSx0aGlzLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wJiZ0aGlzLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0xJiZhKGxlKHRoaXMub3V0Z29pbmdFZGdlcywwKSwxOCkudGFyZ2V0IT10aGlzJiYodD1hKGxlKHRoaXMub3V0Z29pbmdFZGdlcywwKSwxOCkudGFyZ2V0LE9uKChuLnN0cmluZys9IiA+PiAiLG4pLHc0KHQpKSxPbihlaSgobi5zdHJpbmcrPSJbIixuKSx0Lm93bmVyKSwiXSIpKSxuLnN0cmluZ30sbC5jb25uZWN0ZWRUb0V4dGVybmFsTm9kZXM9ITAsbC5leHBsaWNpdGx5U3VwcGxpZWRQb3J0QW5jaG9yPSExO3ZhciBXVyxqVyxWVyxxVyxZVyxLVyxvMmU9Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTFBvcnQiLDEyKTtmdW5jdGlvbiBEeShlKXt0aGlzLnRoaXMkMDE9ZX1wKDQwOCwxLFR1LER5KSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgVCh0aGlzLnRoaXMkMDEuaW5jb21pbmdFZGdlcyksbmV3IGkyZShuKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTFBvcnQvMSIsNDA4KTtmdW5jdGlvbiBpMmUoZSl7dGhpcy52YWwkZWRnZXNJdGVyMj1lfXAoMTMwOSwxLHN0LGkyZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIGEoQyh0aGlzLnZhbCRlZGdlc0l0ZXIyKSwxOCkuc291cmNlfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB4byh0aGlzLnZhbCRlZGdlc0l0ZXIyKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtKMih0aGlzLnZhbCRlZGdlc0l0ZXIyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTFBvcnQvMS8xIiwxMzA5KTtmdW5jdGlvbiBNaChlKXt0aGlzLnRoaXMkMDE9ZX1wKDM2OSwxLFR1LE1oKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgVCh0aGlzLnRoaXMkMDEub3V0Z29pbmdFZGdlcyksbmV3IFhXKG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMUG9ydC8yIiwzNjkpO2Z1bmN0aW9uIFhXKGUpe3RoaXMudmFsJGVkZ2VzSXRlcjI9ZX1wKDc3NiwxLHN0LFhXKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gYShDKHRoaXMudmFsJGVkZ2VzSXRlcjIpLDE4KS50YXJnZXR9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHhvKHRoaXMudmFsJGVkZ2VzSXRlcjIpfSxsLnJlbW92ZT1mdW5jdGlvbigpe0oyKHRoaXMudmFsJGVkZ2VzSXRlcjIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMUG9ydC8yLzEiLDc3Nik7ZnVuY3Rpb24gYTJlKGUsbil7dGhpcy5maXJzdEl0ZXJhYmxlPWUsdGhpcy5zZWNvbmRJdGVyYWJsZT1ufXAoMTMwMiwxLFR1LGEyZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMcyh0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTFBvcnQvQ29tYmluZUl0ZXIiLDEzMDIpO2Z1bmN0aW9uIENFKGUpe3JldHVybiB4byhlLmZpcnN0SXRlcmF0b3IpfHx4byhlLnNlY29uZEl0ZXJhdG9yKX1mdW5jdGlvbiBMcyhlKXt0aGlzLnRoaXMkMTE9ZSx0aGlzLmZpcnN0SXRlcmF0b3I9bmV3IFQodGhpcy50aGlzJDExLmZpcnN0SXRlcmFibGUpLHRoaXMuc2Vjb25kSXRlcmF0b3I9bmV3IFQodGhpcy50aGlzJDExLnNlY29uZEl0ZXJhYmxlKX1wKDIwOCwxLHN0LExzKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtRaWUoKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gQ0UodGhpcyl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIHhvKHRoaXMuZmlyc3RJdGVyYXRvcik/Qyh0aGlzLmZpcnN0SXRlcmF0b3IpOkModGhpcy5zZWNvbmRJdGVyYXRvcil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxQb3J0L0NvbWJpbmVJdGVyLzEiLDIwOCk7ZnVuY3Rpb24gbDJlKGUpe3JldHVybiBVaSgpLGEoZSwxMikub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGghPTB9ZnVuY3Rpb24gczJlKCl7fXAoMTMwMywxLEpzLHMyZSksbC5hcHBseV8xPWZ1bmN0aW9uKG4pe3JldHVybiBsMmUobil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gVWkoKSxhKG4sMTIpLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMUG9ydC9sYW1iZGEkMCRUeXBlIiwxMzAzKTtmdW5jdGlvbiB1MmUoZSl7cmV0dXJuIFVpKCksYShlLDEyKS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MH1mdW5jdGlvbiBjMmUoKXt9cCgxMzA0LDEsSnMsYzJlKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIHUyZShuKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBVaSgpLGEobiwxMikuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGghPTB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxQb3J0L2xhbWJkYSQxJFR5cGUiLDEzMDQpO2Z1bmN0aW9uIF8yZSgpe31wKDEzMDUsMSxKcyxfMmUpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gVWkoKSxhKG4sMTIpLnNpZGU9PShyZSgpLFVlKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBVaSgpLGEobiwxMikuc2lkZT09KHJlKCksVWUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMUG9ydC9sYW1iZGEkMiRUeXBlIiwxMzA1KTtmdW5jdGlvbiBkMmUoKXt9cCgxMzA2LDEsSnMsZDJlKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIFVpKCksYShuLDEyKS5zaWRlPT0ocmUoKSxxZSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gVWkoKSxhKG4sMTIpLnNpZGU9PShyZSgpLHFlKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoIiwiTFBvcnQvbGFtYmRhJDMkVHlwZSIsMTMwNik7ZnVuY3Rpb24gZjJlKCl7fXAoMTMwNywxLEpzLGYyZSksbC5hcHBseV8xPWZ1bmN0aW9uKG4pe3JldHVybiBVaSgpLGEobiwxMikuc2lkZT09KHJlKCksbG4pfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFVpKCksYShuLDEyKS5zaWRlPT0ocmUoKSxsbil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaCIsIkxQb3J0L2xhbWJkYSQ0JFR5cGUiLDEzMDcpO2Z1bmN0aW9uIHAyZSgpe31wKDEzMDgsMSxKcyxwMmUpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gVWkoKSxhKG4sMTIpLnNpZGU9PShyZSgpLGplKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBVaSgpLGEobiwxMikuc2lkZT09KHJlKCksamUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMUG9ydC9sYW1iZGEkNSRUeXBlIiwxMzA4KTtmdW5jdGlvbiBKVyhlKXtyZXR1cm4gZm8oZS5vd25lci5sYXllcnMsZSwwKX1mdW5jdGlvbiBvaShlKXt0aGlzLnNpemVfMD1uZXcgbXQsdGhpcy5ub2Rlcz1uZXcgUSx0aGlzLm93bmVyPWV9cCgzMCwzMDUsezM6MSwyMDoxLDMwNToxLDMwOjEsOTY6MSwxMzc6MX0sb2kpLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe0V0KHRoaXMsbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgVCh0aGlzLm5vZGVzKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIkxfIitmbyh0aGlzLm93bmVyLmxheWVycyx0aGlzLDApK20wKHRoaXMubm9kZXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgiLCJMYXllciIsMzApO2Z1bmN0aW9uIGcyZShlLG4pe3ZhciByLHQsbyxpLHM7eXIoZSkmJihzPWEodyhuLChvZSgpLGpfKSksMTgxKSxEKFYoZSx4cikpPT09RCgoZHQoKSxxMCkpJiZucihlLHhyLEhzKSx0PShFZCgpLG5ldyB2ZCh5cihlKSkpLGk9bmV3IGtSKHlyKGUpP25ldyB2ZCh5cihlKSk6bnVsbCxlKSxvPWJmZSh0LGksITEsITApLE1sKHMsKFNhKCksWWYpKSxyPWEodyhuLG93KSw4KSxyLnhfMD1TLk1hdGgubWF4KG8ueF8wLHIueF8wKSxyLnlfMD1TLk1hdGgubWF4KG8ueV8wLHIueV8wKSl9ZnVuY3Rpb24gaDJlKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3Iobj1qcyhlKSxpPWFlKGllKFYobiwob2UoKSxBZikpKSksZD0wLG89MCxfPW5ldyBZZSgoIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxlLm91dGdvaW5nRWRnZXMpKTtfLmN1cnNvciE9Xy50aGlzJDAxXzIuc2l6ZV8xKCk7KWM9YShlbihfKSw3NCksdT1iZChjKSxzPXUmJmkmJmFlKGllKFYoYyxVXykpKSxoPXlvKGEoTygoIWMudGFyZ2V0cyYmKGMudGFyZ2V0cz1uZXcgTGUoYW4sYyw1LDgpKSxjLnRhcmdldHMpLDApLDg0KSksdSYmcz8rK286dSYmIXM/KytkOnlyKGgpPT1ufHxoPT1uPysrbzorK2Q7Zm9yKHQ9bmV3IFllKCghZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGUuaW5jb21pbmdFZGdlcykpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDc0KSx1PWJkKHIpLHM9dSYmaSYmYWUoaWUoVihyLFVfKSkpLGY9eW8oYShPKCghci5zb3VyY2VzJiYoci5zb3VyY2VzPW5ldyBMZShhbixyLDQsNykpLHIuc291cmNlcyksMCksODQpKSx1JiZzPysrZDp1JiYhcz8rK286eXIoZik9PW58fGY9PW4/KytkOisrbztyZXR1cm4gZC1vfWZ1bmN0aW9uIG0yZShlKXtpZigoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLnNpemVfMD09MCl0aHJvdyBiKG5ldyBlbSgiRWRnZXMgbXVzdCBoYXZlIGEgc291cmNlLiIpKTtpZigoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLnNpemVfMD09MCl0aHJvdyBiKG5ldyBlbSgiRWRnZXMgbXVzdCBoYXZlIGEgdGFyZ2V0LiIpKTtpZighZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLCEoZS5zb3VyY2VzLnNpemVfMDw9MSYmKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzLnNpemVfMDw9MSkpKXRocm93IGIobmV3IGVtKCJIeXBlcmVkZ2VzIGFyZSBub3Qgc3VwcG9ydGVkLiIpKX1mdW5jdGlvbiBmYW4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihzPWFlKGllKFYoZSwob2UoKSxBZikpKSksaD1hKFYoZSxrZiksMjEpLGM9ITEsXz0hMSxmPW5ldyBZZSgoIWUucG9ydHMmJihlLnBvcnRzPW5ldyBVKHVhLGUsOSw5KSksZS5wb3J0cykpO2YuY3Vyc29yIT1mLnRoaXMkMDFfMi5zaXplXzEoKSYmKCFjfHwhXyk7KXtmb3IoaT1hKGVuKGYpLDEyMyksdT0wLG89UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsWyghaS5pbmNvbWluZ0VkZ2VzJiYoaS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixpLDgsNSkpLGkuaW5jb21pbmdFZGdlcyksKCFpLm91dGdvaW5nRWRnZXMmJihpLm91dGdvaW5nRWRnZXM9bmV3IExlKE1yLGksNyw0KSksaS5vdXRnb2luZ0VkZ2VzKV0pKSk7X24obykmJih0PWEodG4obyksNzQpLGQ9cyYmYmQodCkmJmFlKGllKFYodCxVXykpKSxyPVpIZSgoIXQuc291cmNlcyYmKHQuc291cmNlcz1uZXcgTGUoYW4sdCw0LDcpKSx0LnNvdXJjZXMpLGkpP2U9PXlyKHlvKGEoTygoIXQudGFyZ2V0cyYmKHQudGFyZ2V0cz1uZXcgTGUoYW4sdCw1LDgpKSx0LnRhcmdldHMpLDApLDg0KSkpOmU9PXlyKHlvKGEoTygoIXQuc291cmNlcyYmKHQuc291cmNlcz1uZXcgTGUoYW4sdCw0LDcpKSx0LnNvdXJjZXMpLDApLDg0KSkpLCEoKGR8fHIpJiYoKyt1LHU+MSkpKTspOyh1PjB8fGguY29udGFpbnMoKGFhKCksaGMpKSYmKCFpLmxhYmVscyYmKGkubGFiZWxzPW5ldyBVKFF0LGksMSw3KSksaS5sYWJlbHMpLnNpemVfMD4wKSYmKGM9ITApLHU+MSYmKF89ITApfWMmJm4uYWRkXzIoKFZ0KCksbmwpKSxfJiZuLmFkZF8yKChWdCgpLEJFKSl9ZnVuY3Rpb24geTJlKGUpe3ZhciBuLHIsdCxvLGkscztyZXR1cm4gdD1uZXcgSVcsZ28odCxlKSxEKHcodCwob2UoKSxPYSkpKT09PUQoKFdyKCksQnMpKSYmaih0LE9hLGc0KHQpKSx3KHQsKFZOKCksTXYpKT09bnVsbCYmKHM9YShnVmUoZSksMTY3KSxqKHQsTXYsZUkocy5nZXRQcm9wZXJ0eShNdikpKSksaih0LChLKCksUW4pLGUpLGoodCxpaSwobj1hKGlzKG5PKSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKSksbz14bm4oKHlyKGUpJiYoRWQoKSxuZXcgdmQoeXIoZSkpKSxFZCgpLG5ldyBrUih5cihlKT9uZXcgdmQoeXIoZSkpOm51bGwsZSkpLG1vKSxpPWEodyh0LHNZKSwxMDcpLHI9dC5wYWRkaW5nLEt3ZShyLGkpLEt3ZShyLG8pLHR9ZnVuY3Rpb24gdzJlKGUsbil7dmFyIHIsdCxvLGk7cj1hKHcoZSwob2UoKSxPYSkpLDg4KSxpPWEoVihuLGF3KSw2NCksbz1hKHcoZSx4ciksMTAxKSxvIT0oZHQoKSxIcykmJm8hPXEwP2k9PShyZSgpLE9vKSYmKGk9SWVlKG4sciksaT09T28mJihpPWZtKHIpKSk6KHQ9aDJlKG4pLHQ+MD9pPWZtKHIpOmk9QlQoZm0ocikpKSxucihuLGF3LGkpfWZ1bmN0aW9uIHBhbihlLG4scix0KXt2YXIgbyxpLHMsdSxjO3JldHVybiB1PXlvKGEoTygoIW4uc291cmNlcyYmKG4uc291cmNlcz1uZXcgTGUoYW4sbiw0LDcpKSxuLnNvdXJjZXMpLDApLDg0KSksYz15byhhKE8oKCFuLnRhcmdldHMmJihuLnRhcmdldHM9bmV3IExlKGFuLG4sNSw4KSksbi50YXJnZXRzKSwwKSw4NCkpLHlyKHUpPT15cihjKXx8WGYoYyx1KT9udWxsOihzPVFUKG4pLHM9PXI/dDooaT1hKEtlKGUubm9kZUFuZFBvcnRNYXAscyksMTApLGkmJihvPWkubmVzdGVkR3JhcGgsbyk/bzpudWxsKSl9ZnVuY3Rpb24gZ2FuKGUpe3ZhciBuLHI7aWYoYWUoaWUoVihlLChvZSgpLEFmKSkpKSl7Zm9yKHI9bmV3IFhlKFFlKEVjKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspaWYobj1hKHRuKHIpLDc0KSxiZChuKSYmYWUoaWUoVihuLFVfKSkpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGhhbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtmb3IoaD0wLG89bmV3IFllKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YShlbihvKSwyNyksYWUoaWUoVih0LChvZSgpLFZfKSkpKXx8KGQ9eXIodCksKEQoVihkLER1KSkhPT1EKChmdSgpLFZjKSl8fEQoVihkLEhfKSk9PT1EKChIYygpLFh5KSl8fEQoVihkLEhfKSk9PT1EKChIYygpLEt5KSl8fGFlKGllKFYoZCxRMSkpKXx8RChWKGQsUGYpKSE9PUQoKEZfKCkseWYpKXx8RChWKGQsejApKT09PUQoKFNsKCksaWQpKXx8RChWKGQsejApKT09PUQoKFNsKCksRmYpKXx8RChWKGQsV18pKT09PUQoKGpjKCksY3cpKXx8RChWKGQsV18pKT09PUQoKGpjKCksX3cpKSkmJiFhZShpZShWKHQsd1ApKSkmJihucih0LChLKCkscnIpLEooaCkpLCsraCksRTJlKGUsdCxyKSk7Zm9yKGg9MCxfPW5ldyBZZSgoIW4uY29udGFpbmVkRWRnZXMmJihuLmNvbnRhaW5lZEVkZ2VzPW5ldyBVKE1yLG4sMTIsMykpLG4uY29udGFpbmVkRWRnZXMpKTtfLmN1cnNvciE9Xy50aGlzJDAxXzIuc2l6ZV8xKCk7KXU9YShlbihfKSw3NCksKEQoVihuLChvZSgpLER1KSkpIT09RCgoZnUoKSxWYykpfHxEKFYobixIXykpPT09RCgoSGMoKSxYeSkpfHxEKFYobixIXykpPT09RCgoSGMoKSxLeSkpfHxhZShpZShWKG4sUTEpKSl8fEQoVihuLFBmKSkhPT1EKChGXygpLHlmKSl8fEQoVihuLHowKSk9PT1EKChTbCgpLGlkKSl8fEQoVihuLHowKSk9PT1EKChTbCgpLEZmKSl8fEQoVihuLFdfKSk9PT1EKChqYygpLGN3KSl8fEQoVihuLFdfKSk9PT1EKChqYygpLF93KSkpJiYobnIodSwoSygpLHJyKSxKKGgpKSwrK2gpLEU9V3UodSksdj1aMCh1KSxmPWFlKGllKFYoRSxBZikpKSx5PSFhZShpZShWKHUsVl8pKSksbT1mJiZiZCh1KSYmYWUoaWUoVih1LFVfKSkpLGk9eXIoRSk9PW4mJnlyKEUpPT15cih2KSxzPSh5cihFKT09biYmdj09bileKHlyKHYpPT1uJiZFPT1uKSx5JiYhbSYmKHN8fGkpJiZaVyhlLHUsbixyKTtpZih5cihuKSlmb3IoYz1uZXcgWWUoUiRlKHlyKG4pKSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl1PWEoZW4oYyksNzQpLEU9V3UodSksRT09biYmYmQodSkmJihtPWFlKGllKFYoRSwob2UoKSxBZikpKSkmJmFlKGllKFYodSxVXykpKSxtJiZaVyhlLHUsbixyKSl9ZnVuY3Rpb24gbWFuKGUsbil7dmFyIHIsdCxvLGk7aWYoaT15MmUobiksIW4ucG9ydHMmJihuLnBvcnRzPW5ldyBVKHVhLG4sOSw5KSksTHIobmV3IFNlKG51bGwsKCFuLnBvcnRzJiYobi5wb3J0cz1uZXcgVSh1YSxuLDksOSkpLG5ldyB4ZShuLnBvcnRzLDE2KSkpLG5ldyBUMmUoaSkpLG89YSh3KGksKEsoKSxpaSkpLDIxKSxmYW4obixvKSxvLmNvbnRhaW5zKChWdCgpLG5sKSkpZm9yKHQ9bmV3IFllKCghbi5wb3J0cyYmKG4ucG9ydHM9bmV3IFUodWEsbiw5LDkpKSxuLnBvcnRzKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEoZW4odCksMTIzKSxFYW4oZSxuLGkscik7cmV0dXJuIGEoVihuLChvZSgpLGpfKSksMTgxKS5zaXplXzEoKSE9MCYmZzJlKG4saSksYWUoaWUodyhpLGNZKSkpJiZvLmFkZF8yKHNQKSxfcihpLFIzKSYmaVBlKG5ldyBiWShSKCQodyhpLFIzKSkpKSxpKSxEKFYobixOZikpPT09RCgocGMoKSxRYykpP3lhbihlLG4saSk6aGFuKGUsbixpKSxpfWZ1bmN0aW9uIHlhbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZSxGZSxubjtmb3Iocz1uZXcgcHIscT1hKHcociwob2UoKSxPYSkpLDg4KSxFPTAsZnQocywoIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKSk7cy5zaXplXzAhPTA7KWQ9YShzLnNpemVfMD09MD9udWxsOihybihzLnNpemVfMCE9MCksWmEocyxzLmhlYWRlci5uZXh0XzApKSwyNyksXz15cihkKSwoRChWKF8sRHUpKSE9PUQoKGZ1KCksVmMpKXx8RChWKF8sSF8pKT09PUQoKEhjKCksWHkpKXx8RChWKF8sSF8pKT09PUQoKEhjKCksS3kpKXx8YWUoaWUoVihfLFExKSkpfHxEKFYoXyxQZikpIT09RCgoRl8oKSx5ZikpfHxEKFYoXyx6MCkpPT09RCgoU2woKSxpZCkpfHxEKFYoXyx6MCkpPT09RCgoU2woKSxGZikpfHxEKFYoXyxXXykpPT09RCgoamMoKSxjdykpfHxEKFYoXyxXXykpPT09RCgoamMoKSxfdykpKSYmIWFlKGllKFYoZCx3UCkpKSYmbnIoZCwoSygpLHJyKSxKKEUrKykpLHg9IWFlKGllKFYoZCxWXykpKSx4JiYoaD0oIWQuY2hpbGRyZW4mJihkLmNoaWxkcmVuPW5ldyBVKFVuLGQsMTAsMTEpKSxkLmNoaWxkcmVuKS5zaXplXzAhPTAseT1nYW4oZCksbT1EKFYoZCxOZikpPT09RCgocGMoKSxRYykpLG5uPSFXcyhkLChGbigpLFR3KSl8fHBjZSh4bihWKGQsVHcpKSksTT1udWxsLG5uJiZtJiYoaHx8eSkmJihNPXkyZShkKSxqKE0sT2EscSksX3IoTSxSMykmJmlQZShuZXcgYlkoUigkKHcoTSxSMykpKSksTSksYShWKGQsal8pLDE4MSkuc2l6ZV8xKCkhPTAmJihmPU0sTHIobmV3IFNlKG51bGwsKCFkLnBvcnRzJiYoZC5wb3J0cz1uZXcgVSh1YSxkLDksOSkpLG5ldyB4ZShkLnBvcnRzLDE2KSkpLG5ldyBiMmUoZikpLGcyZShkLE0pKSksbmU9cix2ZT1hKEtlKGUubm9kZUFuZFBvcnRNYXAseXIoZCkpLDEwKSx2ZSYmKG5lPXZlLm5lc3RlZEdyYXBoKSxrPUUyZShlLGQsbmUpLE0mJihrLm5lc3RlZEdyYXBoPU0sTS5wYXJlbnROb2RlPWssZnQocywoIWQuY2hpbGRyZW4mJihkLmNoaWxkcmVuPW5ldyBVKFVuLGQsMTAsMTEpKSxkLmNoaWxkcmVuKSkpKTtmb3IoRT0wLGJyKHMsbixzLnRhaWwucHJldixzLnRhaWwpO3Muc2l6ZV8wIT0wOyl7Zm9yKGk9YShzLnNpemVfMD09MD9udWxsOihybihzLnNpemVfMCE9MCksWmEocyxzLmhlYWRlci5uZXh0XzApKSwyNyksYz1uZXcgWWUoKCFpLmNvbnRhaW5lZEVkZ2VzJiYoaS5jb250YWluZWRFZGdlcz1uZXcgVShNcixpLDEyLDMpKSxpLmNvbnRhaW5lZEVkZ2VzKSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl1PWEoZW4oYyksNzQpLG0yZSh1KSwoRChWKG4sRHUpKSE9PUQoKGZ1KCksVmMpKXx8RChWKG4sSF8pKT09PUQoKEhjKCksWHkpKXx8RChWKG4sSF8pKT09PUQoKEhjKCksS3kpKXx8YWUoaWUoVihuLFExKSkpfHxEKFYobixQZikpIT09RCgoRl8oKSx5ZikpfHxEKFYobix6MCkpPT09RCgoU2woKSxpZCkpfHxEKFYobix6MCkpPT09RCgoU2woKSxGZikpfHxEKFYobixXXykpPT09RCgoamMoKSxjdykpfHxEKFYobixXXykpPT09RCgoamMoKSxfdykpKSYmbnIodSwoSygpLHJyKSxKKEUrKykpLERlPXlvKGEoTygoIXUuc291cmNlcyYmKHUuc291cmNlcz1uZXcgTGUoYW4sdSw0LDcpKSx1LnNvdXJjZXMpLDApLDg0KSksRmU9eW8oYShPKCghdS50YXJnZXRzJiYodS50YXJnZXRzPW5ldyBMZShhbix1LDUsOCkpLHUudGFyZ2V0cyksMCksODQpKSwhKGFlKGllKFYodSxWXykpKXx8YWUoaWUoVihEZSxWXykpKXx8YWUoaWUoVihGZSxWXykpKSkmJih2PWJkKHUpJiZhZShpZShWKERlLEFmKSkpJiZhZShpZShWKHUsVV8pKSksSD1pLHZ8fFhmKEZlLERlKT9IPURlOlhmKERlLEZlKSYmKEg9RmUpLG5lPXIsdmU9YShLZShlLm5vZGVBbmRQb3J0TWFwLEgpLDEwKSx2ZSYmKG5lPXZlLm5lc3RlZEdyYXBoKSxBPVpXKGUsdSxILG5lKSxqKEEsKEsoKSxKVikscGFuKGUsdSxuLHIpKSk7aWYobT1EKFYoaSxOZikpPT09RCgocGMoKSxRYykpLG0pZm9yKG89bmV3IFllKCghaS5jaGlsZHJlbiYmKGkuY2hpbGRyZW49bmV3IFUoVW4saSwxMCwxMSkpLGkuY2hpbGRyZW4pKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YShlbihvKSwyNyksbm49IVdzKHQsKEZuKCksVHcpKXx8cGNlKHhuKFYodCxUdykpKSx3ZT1EKFYodCxOZikpPT09RChRYyksbm4mJndlJiZicihzLHQscy50YWlsLnByZXYscy50YWlsKX19ZnVuY3Rpb24gd2FuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihpPWpzKGUpLG89bmV3IFllKCghZS5vdXRnb2luZ0VkZ2VzJiYoZS5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixlLDcsNCkpLGUub3V0Z29pbmdFZGdlcykpO28uY3Vyc29yIT1vLnRoaXMkMDFfMi5zaXplXzEoKTspaWYodD1hKGVuKG8pLDc0KSx1PXlvKGEoTygoIXQudGFyZ2V0cyYmKHQudGFyZ2V0cz1uZXcgTGUoYW4sdCw1LDgpKSx0LnRhcmdldHMpLDApLDg0KSksIVhmKHUsaSkpcmV0dXJuITA7Zm9yKHI9bmV3IFllKCghZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGUuaW5jb21pbmdFZGdlcykpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspaWYobj1hKGVuKHIpLDc0KSxzPXlvKGEoTygoIW4uc291cmNlcyYmKG4uc291cmNlcz1uZXcgTGUoYW4sbiw0LDcpKSxuLnNvdXJjZXMpLDApLDg0KSksIVhmKHMsaSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gWlcoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam47aWYobTJlKG4pLGM9YShPKCghbi5zb3VyY2VzJiYobi5zb3VyY2VzPW5ldyBMZShhbixuLDQsNykpLG4uc291cmNlcyksMCksODQpLGQ9YShPKCghbi50YXJnZXRzJiYobi50YXJnZXRzPW5ldyBMZShhbixuLDUsOCkpLG4udGFyZ2V0cyksMCksODQpLHU9eW8oYyksXz15byhkKSxzPSghbi5zZWN0aW9ucyYmKG4uc2VjdGlvbnM9bmV3IFUoZ3Isbiw2LDYpKSxuLnNlY3Rpb25zKS5zaXplXzA9PTA/bnVsbDphKE8oKCFuLnNlY3Rpb25zJiYobi5zZWN0aW9ucz1uZXcgVShncixuLDYsNikpLG4uc2VjdGlvbnMpLDApLDE2NiksbmU9YShLZShlLm5vZGVBbmRQb3J0TWFwLHUpLDEwKSxGZT1hKEtlKGUubm9kZUFuZFBvcnRNYXAsXyksMTApLHZlPW51bGwsbm49bnVsbCxMKGMsMTkzKSYmKHE9YShLZShlLm5vZGVBbmRQb3J0TWFwLGMpLDMwNSksTChxLDEyKT92ZT1hKHEsMTIpOkwocSwxMCkmJihuZT1hKHEsMTApLHZlPWEobGUobmUucG9ydHMsMCksMTIpKSksTChkLDE5MykmJihEZT1hKEtlKGUubm9kZUFuZFBvcnRNYXAsZCksMzA1KSxMKERlLDEyKT9ubj1hKERlLDEyKTpMKERlLDEwKSYmKEZlPWEoRGUsMTApLG5uPWEobGUoRmUucG9ydHMsMCksMTIpKSksIW5lfHwhRmUpdGhyb3cgYihuZXcgZW0oIlRoZSBzb3VyY2Ugb3IgdGhlIHRhcmdldCBvZiBlZGdlICIrbisiIGNvdWxkIG5vdCBiZSBmb3VuZC4gVGhpcyB1c3VhbGx5IGhhcHBlbnMgd2hlbiBhbiBlZGdlIGNvbm5lY3RzIGEgbm9kZSBsYWlkIG91dCBieSBFTEsgTGF5ZXJlZCB0byBhIG5vZGUgaW4gYW5vdGhlciBsZXZlbCBvZiBoaWVyYXJjaHkgbGFpZCBvdXQgYnkgZWl0aGVyIGFub3RoZXIgaW5zdGFuY2Ugb2YgRUxLIExheWVyZWQgb3IgYW5vdGhlciBsYXlvdXQgYWxnb3JpdGhtIGFsbHRvZ2V0aGVyLiBUaGUgZm9ybWVyIGNhbiBiZSBzb2x2ZWQgYnkgc2V0dGluZyB0aGUgaGllcmFyY2h5SGFuZGxpbmcgb3B0aW9uIHRvIElOQ0xVREVfQ0hJTERSRU4uIikpO2ZvcihFPW5ldyBIMSxnbyhFLG4pLGooRSwoSygpLFFuKSxuKSxqKEUsKG9lKCksaW8pLG51bGwpLG09YSh3KHQsaWkpLDIxKSxuZT09RmUmJm0uYWRkXzIoKFZ0KCksR0UpKSx2ZXx8KEg9KHF0KCkscGkpLHdlPW51bGwscyYmT2coYSh3KG5lLHhyKSwxMDEpKSYmKHdlPW5ldyBZKHMuc3RhcnRYLHMuc3RhcnRZKSxQemUod2UsUVQobikpLE56ZSh3ZSxyKSxYZihfLHUpJiYoSD1pYSxLbih3ZSxuZS5wb3MpKSksdmU9VXdlKG5lLHdlLEgsdCkpLG5ufHwoSD0ocXQoKSxpYSksam49bnVsbCxzJiZPZyhhKHcoRmUseHIpLDEwMSkpJiYoam49bmV3IFkocy5lbmRYLHMuZW5kWSksUHplKGpuLFFUKG4pKSxOemUoam4scikpLG5uPVV3ZShGZSxqbixILFN0KEZlKSkpLEx0KEUsdmUpLF90KEUsbm4pLCh2ZS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xfHx2ZS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xfHxubi5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xfHxubi5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xKSYmbS5hZGRfMigoVnQoKSxCRSkpLGg9bmV3IFllKCghbi5sYWJlbHMmJihuLmxhYmVscz1uZXcgVShRdCxuLDEsNykpLG4ubGFiZWxzKSk7aC5jdXJzb3IhPWgudGhpcyQwMV8yLnNpemVfMSgpOylpZihmPWEoZW4oaCksMTM1KSwhYWUoaWUoVihmLFZfKSkpJiZmLnRleHRfMClzd2l0Y2godj1sOShmKSxlZShFLmxhYmVscyx2KSxhKHcodixkdSksMjc4KS5vcmRpbmFsKXtjYXNlIDE6Y2FzZSAyOm0uYWRkXzIoKFZ0KCksZXcpKTticmVhaztjYXNlIDA6bS5hZGRfMigoVnQoKSxReSkpLGoodixkdSwoR3MoKSx4dykpfWlmKGk9YSh3KHQscUUpLDMyMikseD1hKHcodCx4UCksMzIzKSxvPWk9PShNRSgpLFMzKXx8eD09KFFFKCksQk8pLHMmJighcy5iZW5kUG9pbnRzJiYocy5iZW5kUG9pbnRzPW5ldyBqcihCYSxzLDUpKSxzLmJlbmRQb2ludHMpLnNpemVfMCE9MCYmbyl7Zm9yKEE9cVQocykseT1uZXcgamksTT1kbihBLDApO00uY3VycmVudE5vZGUhPU0udGhpcyQwMS50YWlsOylrPWEodW4oTSksOCksTG4oeSxuZXcgUnQoaykpO2ooRSxucSx5KX1yZXR1cm4gRX1mdW5jdGlvbiBFYW4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKGM9bmV3IFkodC54XzArdC53aWR0aF8wLzIsdC55XzArdC5oZWlnaHQvMiksbT1oMmUodCkseT1hKFYobiwob2UoKSx4cikpLDEwMSksdj1hKFYodCxhdyksNjQpLFVHZShwJGUodCksTGYpfHwodC54XzA9PTAmJnQueV8wPT0wP0U9MDpFPVdFbih0LHYpLG5yKHQsTGYsRSkpLF89bmV3IFkobi53aWR0aF8wLG4uaGVpZ2h0KSxvPXUzKHQseSx2LG0sXyxjLG5ldyBZKHQud2lkdGhfMCx0LmhlaWdodCksYSh3KHIsT2EpLDg4KSxyKSxqKG8sKEsoKSxRbiksdCksaT1hKGxlKG8ucG9ydHMsMCksMTIpLGRhbihpLHdhbih0KSksaihvLGtmLChhYSgpLEVlKFkwKSkpLGY9YShWKG4sa2YpLDE4MSkuY29udGFpbnMoaGMpLHU9bmV3IFllKCghdC5sYWJlbHMmJih0LmxhYmVscz1uZXcgVShRdCx0LDEsNykpLHQubGFiZWxzKSk7dS5jdXJzb3IhPXUudGhpcyQwMV8yLnNpemVfMSgpOylpZihzPWEoZW4odSksMTM1KSwhYWUoaWUoVihzLFZfKSkpJiZzLnRleHRfMCYmKGg9bDkocyksZWUoaS5sYWJlbHMsaCksIWYpKXN3aXRjaChkPTAsZVMoYShWKG4sa2YpLDIxKSkmJihkPVBlZShuZXcgWShzLnhfMCxzLnlfMCksbmV3IFkocy53aWR0aF8wLHMuaGVpZ2h0KSxuZXcgWSh0LndpZHRoXzAsdC5oZWlnaHQpLDAsdikpLHYub3JkaW5hbCl7Y2FzZSAyOmNhc2UgNDpoLnNpemVfMC54XzA9ZDticmVhaztjYXNlIDE6Y2FzZSAzOmguc2l6ZV8wLnlfMD1kfWoobyxzdywkKFYoeXIobiksc3cpKSksaihvLHV3LCQoVih5cihuKSx1dykpKSxqKG8sTWYsJChWKHlyKG4pLE1mKSkpLGVlKHIubGF5ZXJsZXNzTm9kZXMsbyksQm4oZS5ub2RlQW5kUG9ydE1hcCx0LG8pfWZ1bmN0aW9uIGw5KGUpe3ZhciBuO3JldHVybiBuPW5ldyBrVyhlLnRleHRfMCksZ28obixlKSxqKG4sKEsoKSxRbiksZSksbi5zaXplXzAueF8wPWUud2lkdGhfMCxuLnNpemVfMC55XzA9ZS5oZWlnaHQsbi5wb3MueF8wPWUueF8wLG4ucG9zLnlfMD1lLnlfMCxufWZ1bmN0aW9uIEUyZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKGQ9bmV3IGFjKHIpLGdvKGQsbiksaihkLChLKCksUW4pLG4pLGQuc2l6ZV8wLnhfMD1uLndpZHRoXzAsZC5zaXplXzAueV8wPW4uaGVpZ2h0LGQucG9zLnhfMD1uLnhfMCxkLnBvcy55XzA9bi55XzAsZWUoci5sYXllcmxlc3NOb2RlcyxkKSxCbihlLm5vZGVBbmRQb3J0TWFwLG4sZCksKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pLnNpemVfMCE9MHx8YWUoaWUoVihuLChvZSgpLEFmKSkpKSkmJmooZCxYViwoemUoKSwhMCkpLF89YSh3KHIsaWkpLDIxKSxmPWEodyhkLChvZSgpLHhyKSksMTAxKSxmPT0oZHQoKSxxMCk/aihkLHhyLEhzKTpmIT1IcyYmXy5hZGRfMigoVnQoKSxudykpLGg9MCx0PWEodyhyLE9hKSw4OCksYz1uZXcgWWUoKCFuLnBvcnRzJiYobi5wb3J0cz1uZXcgVSh1YSxuLDksOSkpLG4ucG9ydHMpKTtjLmN1cnNvciE9Yy50aGlzJDAxXzIuc2l6ZV8xKCk7KXU9YShlbihjKSwxMjMpLG89eXIobiksKEQoVihvLER1KSkhPT1EKChmdSgpLFZjKSl8fEQoVihvLEhfKSk9PT1EKChIYygpLFh5KSl8fEQoVihvLEhfKSk9PT1EKChIYygpLEt5KSl8fGFlKGllKFYobyxRMSkpKXx8RChWKG8sUGYpKSE9PUQoKEZfKCkseWYpKXx8RChWKG8sejApKT09PUQoKFNsKCksaWQpKXx8RChWKG8sejApKT09PUQoKFNsKCksRmYpKXx8RChWKG8sV18pKT09PUQoKGpjKCksY3cpKXx8RChWKG8sV18pKT09PUQoKGpjKCksX3cpKSkmJiFhZShpZShWKG4sd1ApKSkmJm5yKHUscnIsSihoKyspKSxhZShpZShWKHUsVl8pKSl8fHZhbihlLHUsZCxfLHQsZik7Zm9yKHM9bmV3IFllKCghbi5sYWJlbHMmJihuLmxhYmVscz1uZXcgVShRdCxuLDEsNykpLG4ubGFiZWxzKSk7cy5jdXJzb3IhPXMudGhpcyQwMV8yLnNpemVfMSgpOylpPWEoZW4ocyksMTM1KSwhYWUoaWUoVihpLFZfKSkpJiZpLnRleHRfMCYmZWUoZC5sYWJlbHMsbDkoaSkpO3JldHVybiBhZShpZSh3KGQsVkUpKSkmJl8uYWRkXzIoKFZ0KCksYVApKSxhZShpZSh3KGQsQ1ApKSkmJihfLmFkZF8yKChWdCgpLGxQKSksXy5hZGRfMihCRSksaihkLHhyLEhzKSksZH1mdW5jdGlvbiB2YW4oZSxuLHIsdCxvLGkpe3ZhciBzLHUsYyxfLGQsZjtmb3IoXz1uZXcgWm8sZ28oXyxuKSxYcihfLGEoVihuLChvZSgpLGF3KSksNjQpKSxqKF8sKEsoKSxRbiksbiksTG8oXyxyKSxmPV8uc2l6ZV8wLGYueF8wPW4ud2lkdGhfMCxmLnlfMD1uLmhlaWdodCxkPV8ucG9zLGQueF8wPW4ueF8wLGQueV8wPW4ueV8wLEJuKGUubm9kZUFuZFBvcnRNYXAsbixfKSxzPU1wKHBvKE5vKG5ldyBTZShudWxsLCghbi5vdXRnb2luZ0VkZ2VzJiYobi5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixuLDcsNCkpLG5ldyB4ZShuLm91dGdvaW5nRWRnZXMsMTYpKSksbmV3IEkyZSksbmV3IFMyZSksbmV3IHgyZShuKSksc3x8KHM9TXAocG8oTm8obmV3IFNlKG51bGwsKCFuLmluY29taW5nRWRnZXMmJihuLmluY29taW5nRWRnZXM9bmV3IExlKE1yLG4sOCw1KSksbmV3IHhlKG4uaW5jb21pbmdFZGdlcywxNikpKSxuZXcgUDJlKSxuZXcgQzJlKSxuZXcgTjJlKG4pKSksc3x8KHM9TXAobmV3IFNlKG51bGwsKCFuLm91dGdvaW5nRWRnZXMmJihuLm91dGdvaW5nRWRnZXM9bmV3IExlKE1yLG4sNyw0KSksbmV3IHhlKG4ub3V0Z29pbmdFZGdlcywxNikpKSxuZXcgQTJlKSksaihfLEEzLCh6ZSgpLCEhcykpLHRhbihfLGksbyxhKFYobixyZCksOCkpLGM9bmV3IFllKCghbi5sYWJlbHMmJihuLmxhYmVscz1uZXcgVShRdCxuLDEsNykpLG4ubGFiZWxzKSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl1PWEoZW4oYyksMTM1KSwhYWUoaWUoVih1LFZfKSkpJiZ1LnRleHRfMCYmZWUoXy5sYWJlbHMsbDkodSkpO3N3aXRjaChvLm9yZGluYWwpe2Nhc2UgMjpjYXNlIDE6KF8uc2lkZT09KHJlKCksVWUpfHxfLnNpZGU9PWxuKSYmdC5hZGRfMigoVnQoKSxYcCkpO2JyZWFrO2Nhc2UgNDpjYXNlIDM6KF8uc2lkZT09KHJlKCkscWUpfHxfLnNpZGU9PWplKSYmdC5hZGRfMigoVnQoKSxYcCkpfXJldHVybiBffWZ1bmN0aW9uIHYyZSgpe3RoaXMubm9kZUFuZFBvcnRNYXA9bmV3IHNufWZ1bmN0aW9uIFNhbihlLG4pe3JldHVybiBYZihuLGpzKGUpKX1mdW5jdGlvbiBDYW4oZSxuKXtyZXR1cm4gWGYobixqcyhlKSl9ZnVuY3Rpb24gVGFuKGUpe3JldHVybiBiZChlKSYmYWUoaWUoVihlLChvZSgpLFVfKSkpKX1wKDEzMzAsMSx7fSx2MmUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaC50cmFuc2Zvcm0iLCJFbGtHcmFwaEltcG9ydGVyIiwxMzMwKTtmdW5jdGlvbiBTMmUoKXt9cCgxMzM0LDEse30sUzJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHlvKGEobiw4NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhJbXBvcnRlci8wbWV0aG9kcmVmJGNvbm5lY3RhYmxlU2hhcGVUb05vZGUkVHlwZSIsMTMzNCk7ZnVuY3Rpb24gQzJlKCl7fXAoMTMzNywxLHt9LEMyZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiB5byhhKG4sODQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoSW1wb3J0ZXIvMW1ldGhvZHJlZiRjb25uZWN0YWJsZVNoYXBlVG9Ob2RlJFR5cGUiLDEzMzcpO2Z1bmN0aW9uIFQyZShlKXt0aGlzLnRvcExldmVsR3JhcGhfMT1lfXAoMTMzMSwxLEplLFQyZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7dzJlKHRoaXMudG9wTGV2ZWxHcmFwaF8xLGEobiwxMjMpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoSW1wb3J0ZXIvbGFtYmRhJDAkVHlwZSIsMTMzMSk7ZnVuY3Rpb24gYjJlKGUpe3RoaXMuZmluYWxOZXN0ZWRHcmFwaF8xPWV9cCgxMzMyLDEsSmUsYjJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt3MmUodGhpcy5maW5hbE5lc3RlZEdyYXBoXzEsYShuLDEyMykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkMSRUeXBlIiwxMzMyKTtmdW5jdGlvbiBJMmUoKXt9cCgxMzMzLDEse30sSTJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShkbmUoYShuLDc0KSksMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoSW1wb3J0ZXIvbGFtYmRhJDIkVHlwZSIsMTMzMyk7ZnVuY3Rpb24geDJlKGUpe3RoaXMuZWxrcG9ydF8wPWV9cCgxMzM1LDEsSW4seDJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gU2FuKHRoaXMuZWxrcG9ydF8wLGEobiwyNykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkNCRUeXBlIiwxMzM1KTtmdW5jdGlvbiBQMmUoKXt9cCgxMzM2LDEse30sUDJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShtdm4oYShuLDc0KSksMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoSW1wb3J0ZXIvbGFtYmRhJDUkVHlwZSIsMTMzNik7ZnVuY3Rpb24gTjJlKGUpe3RoaXMuZWxrcG9ydF8wPWV9cCgxMzM4LDEsSW4sTjJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gQ2FuKHRoaXMuZWxrcG9ydF8wLGEobiwyNykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkNyRUeXBlIiwxMzM4KTtmdW5jdGlvbiBBMmUoKXt9cCgxMzM5LDEsSW4sQTJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gVGFuKGEobiw3NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkOCRUeXBlIiwxMzM5KTtmdW5jdGlvbiBkMygpe2QzPUYsTzJlPW5ldyBtdH1mdW5jdGlvbiBiYW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG07aWYoaT1hKHcoZSwoSygpLFFuKSksNzQpLCEhaSl7Zm9yKHQ9ZS5iZW5kUG9pbnRzLG89bmV3IFJ0KHIpLEtuKG8sUGFuKGUpKSxSeShlLnRhcmdldC5vd25lcixlLnNvdXJjZS5vd25lcik/KGg9ZS5zb3VyY2UsZj1rbyhQKEkob3QsMSksWCw4LDAsW2gucG9zLGguYW5jaG9yXSkpLHJ0KGYscikpOmY9QXMoZS5zb3VyY2UpLGJyKHQsZix0LmhlYWRlcix0LmhlYWRlci5uZXh0XzApLG09QXMoZS50YXJnZXQpLHcoZSxnTykhPW51bGwmJktuKG0sYSh3KGUsZ08pLDgpKSxicih0LG0sdC50YWlsLnByZXYsdC50YWlsKSxVZih0LG8pLHM9RmcoaSwhMCwhMCksREEocyxhKE8oKCFpLnNvdXJjZXMmJihpLnNvdXJjZXM9bmV3IExlKGFuLGksNCw3KSksaS5zb3VyY2VzKSwwKSw4NCkpLEZBKHMsYShPKCghaS50YXJnZXRzJiYoaS50YXJnZXRzPW5ldyBMZShhbixpLDUsOCkpLGkudGFyZ2V0cyksMCksODQpKSxWVCh0LHMpLGQ9bmV3IFQoZS5sYWJlbHMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhkKSw3MiksdT1hKHcoXyxRbiksMTM1KSxUZCh1LF8uc2l6ZV8wLnhfMCksQ2QodSxfLnNpemVfMC55XzApLF9sKHUsXy5wb3MueF8wK28ueF8wLF8ucG9zLnlfMCtvLnlfMCksbnIodSwoUmgoKSxwOSksaWUodyhfLHA5KSkpO2M9YSh3KGUsKG9lKCksaW8pKSw3NSksYz8oVWYoYyxvKSxucihpLGlvLGMpKTpucihpLGlvLG51bGwpLG49PShmYygpLGNtKT9ucihpLHVjLGNtKTpucihpLHVjLG51bGwpfX1mdW5jdGlvbiBMMmUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTTtpZihvPXcobiwoSygpLFFuKSksISFMKG8sMjA3KSl7Zm9yKHk9YShvLDI3KSxFPW4ucGFyZW50Tm9kZSxoPW5ldyBSdChuLm9mZnNldCksaT1uLnBhZGRpbmcsaC54XzArPWkubGVmdCxoLnlfMCs9aS50b3BfMCxNPWEoVih5LChvZSgpLFBQKSksMTgxKSwkaShNLChnYSgpLHBBKSkmJihtPWEoVih5LHNZKSwxMDcpLGFhbihtLGkuYm90dG9tKSx1YW4obSxpLnRvcF8wKSxsYW4obSxpLmxlZnQpLHNhbihtLGkucmlnaHQpKSxyPW5ldyBRLGQ9bmV3IFQobi5sYXllcmxlc3NOb2Rlcyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihjPWEoQyhkKSwxMCksTCh3KGMsUW4pLDIwNyk/SWFuKGMsaCk6TCh3KGMsUW4pLDE5MykmJiFFJiYodD1hKHcoYyxRbiksMTIzKSxBPVd3ZShuLGMsdC53aWR0aF8wLHQuaGVpZ2h0KSxfbCh0LEEueF8wLEEueV8wKSkseD1uZXcgVChjLnBvcnRzKTt4Lmk8eC50aGlzJDAxLmFycmF5Lmxlbmd0aDspdj1hKEMoeCksMTIpLExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZSh2Lm91dGdvaW5nRWRnZXMsMTYpKSxuZXcgTTJlKGMpKSxuZXcgUjJlKHIpKTtpZihFKWZvcih4PW5ldyBUKEUucG9ydHMpO3guaTx4LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl2PWEoQyh4KSwxMiksTHIoSm4obmV3IFNlKG51bGwsbmV3IHhlKHYub3V0Z29pbmdFZGdlcywxNikpLG5ldyBEMmUoRSkpLG5ldyBGMmUocikpO2ZvcihrPWEoVih5LHVjKSwyMjMpLHU9bmV3IFQocik7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDE4KSxiYW4ocyxrLGgpO2Zvcih4YW4obiksXz1uZXcgVChuLmxheWVybGVzc05vZGVzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTApLGY9Yy5uZXN0ZWRHcmFwaCxmJiZMMmUoZSxmKX19ZnVuY3Rpb24gSWFuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3IodD1hKHcoZSwoSygpLFFuKSksMjcpLHk9YSh3KGUsKG9lKCksRVApKSwxNykudmFsdWVfMCxpPWEodyhlLFRQKSwxNykudmFsdWVfMCxucih0LEVQLEooeSkpLG5yKHQsVFAsSihpKSksQ2kodCxlLnBvcy54XzArbi54XzApLFRpKHQsZS5wb3MueV8wK24ueV8wKSwoYShWKHQsal8pLDE4MSkuc2l6ZV8xKCkhPTB8fGUubmVzdGVkR3JhcGh8fEQodyhTdChlKSx4UCkpPT09RCgoUUUoKSxudikpJiZmUGUoKFJmKCksKGUucHJvcGVydHlNYXA/ZS5wcm9wZXJ0eU1hcDooTmUoKSxOZSgpLGt1KSkuY29udGFpbnNLZXkobmQpP2g9YSh3KGUsbmQpLDIwMyk6aD1hKHcoU3QoZSksS0UpLDIwMyksaCkpKSYmKFRkKHQsZS5zaXplXzAueF8wKSxDZCh0LGUuc2l6ZV8wLnlfMCkpLGY9bmV3IFQoZS5wb3J0cyk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGYpLDEyKSxFPXcoXyxRbiksTChFLDE5MykmJihvPWEoRSwxMjMpLF9sKG8sXy5wb3MueF8wLF8ucG9zLnlfMCksbnIobyxhdyxfLnNpZGUpKTtmb3IobT1hKHcoZSxlZCksMTgxKS5zaXplXzEoKSE9MCxjPW5ldyBUKGUubGFiZWxzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEMoYyksNzIpLChtfHxhKHcocyxlZCksMTgxKS5zaXplXzEoKSE9MCkmJihyPWEodyhzLFFuKSwxMzUpLFJnKHIscy5zaXplXzAueF8wLHMuc2l6ZV8wLnlfMCksX2wocixzLnBvcy54XzAscy5wb3MueV8wKSk7aWYoIWVTKGEodyhlLGtmKSwyMSkpKWZvcihkPW5ldyBUKGUucG9ydHMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoXz1hKEMoZCksMTIpLHU9bmV3IFQoXy5sYWJlbHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSw3Mikscj1hKHcocyxRbiksMTM1KSxUZChyLHMuc2l6ZV8wLnhfMCksQ2QocixzLnNpemVfMC55XzApLF9sKHIscy5wb3MueF8wLHMucG9zLnlfMCl9ZnVuY3Rpb24geGFuKGUpe3ZhciBuLHIsdCxvLGk7dD1hKHcoZSwoSygpLFFuKSksMjcpLGk9YShWKHQsKG9lKCksal8pKSwxODEpLmNvbnRhaW5zKChTYSgpLGkxKSksZS5wYXJlbnROb2RlfHwobz1hKHcoZSxpaSksMjEpLG49bmV3IFkoZS5zaXplXzAueF8wK2UucGFkZGluZy5sZWZ0K2UucGFkZGluZy5yaWdodCxlLnNpemVfMC55XzArZS5wYWRkaW5nLnRvcF8wK2UucGFkZGluZy5ib3R0b20pLG8uY29udGFpbnMoKFZ0KCksbmwpKT8obnIodCx4ciwoZHQoKSxhaSkpLHdkKHQsbi54XzAsbi55XzAsITEsITApKTphZShpZShWKHQsSU8pKSl8fHdkKHQsbi54XzAsbi55XzAsITAsITApKSxpP25yKHQsal8sRWUoaTEpKTpucih0LGpfLChyPWEoaXModFMpLDkpLG5ldyBKYShyLGEoRGwocixyLmxlbmd0aCksOSksMCkpKX1mdW5jdGlvbiBQYW4oZSl7dmFyIG4scix0LG87aWYobz1hKHcoZSwoSygpLEpWKSksMzYpLG8pe2Zvcih0PW5ldyBtdCxuPVN0KGUuc291cmNlLm93bmVyKTtuIT1vOylyPW4ucGFyZW50Tm9kZSxuPVN0KHIpLG1kKEtuKEtuKHQsci5wb3MpLG4ub2Zmc2V0KSxuLnBhZGRpbmcubGVmdCxuLnBhZGRpbmcudG9wXzApO3JldHVybiB0fXJldHVybiBPMmV9ZnVuY3Rpb24gazJlKCl7ZDMoKX1mdW5jdGlvbiBOYW4oZSxuKXtyZXR1cm4gZDMoKSwhUnkobi50YXJnZXQub3duZXIsZSl9ZnVuY3Rpb24gQWFuKGUsbil7cmV0dXJuIGQzKCksUnkobi50YXJnZXQub3duZXIsZSl9cCgxMjk3LDEse30sazJlKTt2YXIgTzJlO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaC50cmFuc2Zvcm0iLCJFbGtHcmFwaExheW91dFRyYW5zZmVycmVyIiwxMjk3KTtmdW5jdGlvbiBNMmUoZSl7dGhpcy5sbm9kZV8wPWV9cCgxMjk4LDEsSW4sTTJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTmFuKHRoaXMubG5vZGVfMCxhKG4sMTgpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoTGF5b3V0VHJhbnNmZXJyZXIvbGFtYmRhJDAkVHlwZSIsMTI5OCk7ZnVuY3Rpb24gUjJlKGUpe3RoaXMuZWRnZUxpc3RfMD1lfXAoMTI5OSwxLEplLFIyZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7ZDMoKSxlZSh0aGlzLmVkZ2VMaXN0XzAsYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5ncmFwaC50cmFuc2Zvcm0iLCJFbGtHcmFwaExheW91dFRyYW5zZmVycmVyL2xhbWJkYSQxJFR5cGUiLDEyOTkpO2Z1bmN0aW9uIEQyZShlKXt0aGlzLnBhcmVudExOb2RlXzA9ZX1wKDEzMDAsMSxJbixEMmUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBBYW4odGhpcy5wYXJlbnRMTm9kZV8wLGEobiwxOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuZ3JhcGgudHJhbnNmb3JtIiwiRWxrR3JhcGhMYXlvdXRUcmFuc2ZlcnJlci9sYW1iZGEkMiRUeXBlIiwxMzAwKTtmdW5jdGlvbiBGMmUoZSl7dGhpcy5lZGdlTGlzdF8wPWV9cCgxMzAxLDEsSmUsRjJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtkMygpLGVlKHRoaXMuZWRnZUxpc3RfMCxhKG4sMTgpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmdyYXBoLnRyYW5zZm9ybSIsIkVsa0dyYXBoTGF5b3V0VHJhbnNmZXJyZXIvbGFtYmRhJDMkVHlwZSIsMTMwMSk7ZnVuY3Rpb24gejJlKGUpe3ZhciBuLHIsdDtyZXR1cm4gcj1lLmdldElkZW50aWZpZXIoKSxyPyhuPWUuZUNvbnRhaW5lcl8wKCksTChuLDE2NykmJih0PXoyZShhKG4sMTY3KSksdCE9bnVsbCk/dCsiLiIrcjpyKTpudWxsfWZ1bmN0aW9uIExhbihlKXt2YXIgbjtyZXR1cm4gbj13KGUsKEsoKSxRbikpLEwobiwxNjcpP3oyZShhKG4sMTY3KSk6bnVsbH1mdW5jdGlvbiBFZihlLG4pe3JldHVybiBhKHhzKGUuaGFzaE1hcFZhbHVlc1RvS2V5LG4pLDM0KX1mdW5jdGlvbiBRVyhlLG4pe3ZhciByO3JldHVybiByPWEoeHMoZS5tdWx0aU1hcEtleVRvVmFsdWVzLG4pLDY3KSwhciYmKHI9bmV3IHByKSxyfWZ1bmN0aW9uIGthbihlLG4pe3ZhciByLHQsbyxpO2ZvcihvPShpPW5ldyBrXyhlLm11bHRpTWFwS2V5VG9WYWx1ZXMpLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgS0koaSkpO28udmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KWlmKHQ9KHI9YShvLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKHIuZ2V0S2V5KCksMzQpKSxZJChuLGEodCwxNykpPDApcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gT2FuKGUsbil7dmFyIHIsdCxvLGk7Zm9yKG89KGk9bmV3IGtfKGUubXVsdGlNYXBLZXlUb1ZhbHVlcykudGhpcyQwMS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyBLSShpKSk7by52YWwkb3V0ZXJJdGVyMi5oYXNOZXh0XzAoKTspaWYodD0ocj1hKG8udmFsJG91dGVySXRlcjIubmV4dF8xKCksNDQpLGEoci5nZXRLZXkoKSwzNCkpLFkkKG4sYSh0LDE3KSk+MClyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBlaihlLG4scil7dmFyIHQsbyxpO3Q9YSh4cyhlLmhhc2hNYXBWYWx1ZXNUb0tleSxyKSwzNCksdCE9bnVsbCYmKGk9YSh4cyhlLm11bHRpTWFwS2V5VG9WYWx1ZXMsdCksNjcpLFlkKGksciwhMCkpLG89YSh4cyhlLm11bHRpTWFwS2V5VG9WYWx1ZXMsbiksNjcpLG98fChvPW5ldyBwcixSYyhlLm11bHRpTWFwS2V5VG9WYWx1ZXMsbixvKSksYnIobyxyLG8udGFpbC5wcmV2LG8udGFpbCksUmMoZS5oYXNoTWFwVmFsdWVzVG9LZXkscixuKX1mdW5jdGlvbiBNYW4oZSxuLHIpe3ZhciB0LG87Zm9yKG89bmV3IFQocik7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9QyhvKSxlaihlLG4sdCl9ZnVuY3Rpb24gbmooKXt0aGlzLm11bHRpTWFwS2V5VG9WYWx1ZXM9bmV3IERjLHRoaXMuaGFzaE1hcFZhbHVlc1RvS2V5PW5ldyBEY31wKDgxOSwxLHt9LG5qKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiQmlMaW5rZWRIYXNoTXVsdGlNYXAiLDgxOSk7ZnVuY3Rpb24gUmFuKGUsbil7bi5iZWdpbigiTm9kZSBtYXJnaW4gY2FsY3VsYXRpb24iLDEpLExyKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLmxheWVycywxNikpLG5ldyBCMmUpLG5ldyBHMmUpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gRGFuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaDtpZih1PWUubWFyZ2luLGY9YSh3KGUsKEsoKSxxaCkpLDE1KSxuPWEodyhlLEhoKSwxNSksISghZiYmIW4pKXtpZihpPVIoJCh6ZihlLChvZSgpLHhPKSkpKSxzPVIoJCh6ZihlLGdZKSkpLGg9MCxmKXtmb3IoXz0wLG89Zi5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTApLF89Uy5NYXRoLm1heChfLHQuc2l6ZV8wLnlfMCksaCs9dC5zaXplXzAueF8wO2grPWkqKGYuc2l6ZV8xKCktMSksdS50b3BfMCs9XytzfWlmKHI9MCxuKXtmb3IoXz0wLG89bi5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTApLF89Uy5NYXRoLm1heChfLHQuc2l6ZV8wLnlfMCkscis9dC5zaXplXzAueF8wO3IrPWkqKG4uc2l6ZV8xKCktMSksdS5ib3R0b20rPV8rc31jPVMuTWF0aC5tYXgoaCxyKSxjPmUuc2l6ZV8wLnhfMCYmKGQ9KGMtZS5zaXplXzAueF8wKS8yLHUubGVmdD1TLk1hdGgubWF4KHUubGVmdCxkKSx1LnJpZ2h0PVMuTWF0aC5tYXgodS5yaWdodCxkKSl9fWZ1bmN0aW9uICQyZSgpe31wKDE1NTAsMSxzciwkMmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe1JhbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiQ29tbWVudE5vZGVNYXJnaW5DYWxjdWxhdG9yIiwxNTUwKTtmdW5jdGlvbiBCMmUoKXt9cCgxNTUxLDEse30sQjJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJDb21tZW50Tm9kZU1hcmdpbkNhbGN1bGF0b3IvbGFtYmRhJDAkVHlwZSIsMTU1MSk7ZnVuY3Rpb24gRzJlKCl7fXAoMTU1MiwxLEplLEcyZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7RGFuKGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiQ29tbWVudE5vZGVNYXJnaW5DYWxjdWxhdG9yL2xhbWJkYSQxJFR5cGUiLDE1NTIpO2Z1bmN0aW9uIEgyZShlKXt2YXIgbixyLHQsbyxpLHM7Zm9yKG89YSh3KGUsKEsoKSxjUCkpLDEyKSxzPW5ldyBUKGUucG9ydHMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGk9YShDKHMpLDEyKSx0PW5ldyBUKGkub3V0Z29pbmdFZGdlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXJldHVybiBuPWEoQyh0KSwxOCksX3QobixvKSxpO2ZvcihyPW5ldyBUKGkuaW5jb21pbmdFZGdlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KXJldHVybiBuPWEoQyhyKSwxOCksTHQobixvKSxpfXJldHVybiBudWxsfWZ1bmN0aW9uIEZhbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihuLmJlZ2luKCJDb21tZW50IHBvc3QtcHJvY2Vzc2luZyIsMSksaT1uZXcgVChlLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iobz1hKEMoaSksMzApLHQ9bmV3IFEsdT1uZXcgVChvLm5vZGVzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTApLGM9YSh3KHMsKEsoKSxxaCkpLDE1KSxyPWEodyhzLEhoKSwxNSksKGN8fHIpJiYoemFuKHMsYyxyKSxjJiZxcih0LGMpLHImJnFyKHQscikpO3FyKG8ubm9kZXMsdCl9bi5kb25lXzEoKX1mdW5jdGlvbiB6YW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseDtpZihFPWUucG9zLHY9ZS5zaXplXzAsaD1lLm1hcmdpbixmPVIoJCh6ZihlLChvZSgpLHhPKSkpKSxuKXtmb3IoZD1mKihuLnNpemVfMSgpLTEpLG09MCxjPW4uaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXM9YShjLm5leHRfMSgpLDEwKSxkKz1zLnNpemVfMC54XzAsbT1TLk1hdGgubWF4KG0scy5zaXplXzAueV8wKTtmb3IoeD1FLnhfMC0oZC12LnhfMCkvMixpPUUueV8wLWgudG9wXzArbSx0PXYueF8wLyhuLnNpemVfMSgpKzEpLG89dCx1PW4uaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDEwKSxzLnBvcy54XzA9eCxzLnBvcy55XzA9aS1zLnNpemVfMC55XzAseCs9cy5zaXplXzAueF8wK2YsXz1IMmUocyksXy5wb3MueF8wPXMuc2l6ZV8wLnhfMC8yLV8uYW5jaG9yLnhfMCxfLnBvcy55XzA9cy5zaXplXzAueV8wLHk9YSh3KHMsKEsoKSxjUCkpLDEyKSx5LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK3kub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTEmJih5LnBvcy54XzA9by15LmFuY2hvci54XzAseS5wb3MueV8wPTAsTG8oeSxlKSksbys9dH1pZihyKXtmb3IoZD1mKihyLnNpemVfMSgpLTEpLG09MCxjPXIuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXM9YShjLm5leHRfMSgpLDEwKSxkKz1zLnNpemVfMC54XzAsbT1TLk1hdGgubWF4KG0scy5zaXplXzAueV8wKTtmb3IoeD1FLnhfMC0oZC12LnhfMCkvMixpPUUueV8wK3YueV8wK2guYm90dG9tLW0sdD12LnhfMC8oci5zaXplXzEoKSsxKSxvPXQsdT1yLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxMCkscy5wb3MueF8wPXgscy5wb3MueV8wPWkseCs9cy5zaXplXzAueF8wK2YsXz1IMmUocyksXy5wb3MueF8wPXMuc2l6ZV8wLnhfMC8yLV8uYW5jaG9yLnhfMCxfLnBvcy55XzA9MCx5PWEodyhzLChLKCksY1ApKSwxMikseS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCt5Lm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0xJiYoeS5wb3MueF8wPW8teS5hbmNob3IueF8wLHkucG9zLnlfMD12LnlfMCxMbyh5LGUpKSxvKz10fX1mdW5jdGlvbiBVMmUoKXt9cCgxNTUzLDEsc3IsVTJlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtGYW4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkNvbW1lbnRQb3N0cHJvY2Vzc29yIiwxNTUzKTtmdW5jdGlvbiAkYW4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseDtmb3Iobi5iZWdpbigiQ29tbWVudCBwcmUtcHJvY2Vzc2luZyIsMSkscj0wLGM9bmV3IFQoZS5sYXllcmxlc3NOb2Rlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHU9YShDKGMpLDEwKSxhZShpZSh3KHUsKG9lKCksVkUpKSkpKXtmb3IoKytyLG89MCx0PW51bGwsXz1udWxsLHk9bmV3IFQodS5wb3J0cyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWg9YShDKHkpLDEyKSxvKz1oLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK2gub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgsaC5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MSYmKHQ9YShsZShoLmluY29taW5nRWRnZXMsMCksMTgpLF89dC5zb3VyY2UpLGgub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTEmJih0PWEobGUoaC5vdXRnb2luZ0VkZ2VzLDApLDE4KSxfPXQudGFyZ2V0KTtpZihvPT0xJiZfLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK18ub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTEmJiFhZShpZSh3KF8ub3duZXIsVkUpKSkpQmFuKHUsdCxfLF8ub3duZXIpLEoyKGMpO2Vsc2V7Zm9yKHg9bmV3IFEsbT1uZXcgVCh1LnBvcnRzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihoPWEoQyhtKSwxMiksZj1uZXcgVChoLm91dGdvaW5nRWRnZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSwxOCksZC50YXJnZXQub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTB8fFJlKHguYXJyYXksZCk7Zm9yKHM9bmV3IFQoaC5pbmNvbWluZ0VkZ2VzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTgpLGkuc291cmNlLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wfHxSZSh4LmFycmF5LGkpfWZvcih2PW5ldyBUKHgpO3YuaTx2LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylFPWEoQyh2KSwxOCksRzEoRSwhMCl9fW4uaXNMb2dnaW5nRW5hYmxlZCgpJiZuLmxvZ18wKCJGb3VuZCAiK3IrIiBjb21tZW50IGJveGVzIiksbi5kb25lXzEoKX1mdW5jdGlvbiBCYW4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBO2lmKGg9ITEsZj0hMSxPZyhhKHcodCwob2UoKSx4cikpLDEwMSkpKXtzPSExLHU9ITE7ZTpmb3IoeT1uZXcgVCh0LnBvcnRzKTt5Lmk8eS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKG09YShDKHkpLDEyKSx2PVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFtuZXcgRHkobSksbmV3IE1oKG0pXSkpKTtfbih2KTspaWYoRT1hKHRuKHYpLDEyKSwhYWUoaWUodyhFLm93bmVyLFZFKSkpKXtpZihtLnNpZGU9PShyZSgpLFVlKSl7cz0hMDticmVhayBlfWlmKG0uc2lkZT09bG4pe3U9ITA7YnJlYWsgZX19aD11JiYhcyxmPXMmJiF1fWlmKCFoJiYhZiYmdC5sYWJlbHMuYXJyYXkubGVuZ3RoIT0wKXtmb3IoZD0wLF89bmV3IFQodC5sYWJlbHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSw3MiksZCs9Yy5wb3MueV8wK2Muc2l6ZV8wLnlfMC8yO2QvPXQubGFiZWxzLmFycmF5Lmxlbmd0aCxBPWQ+PXQuc2l6ZV8wLnlfMC8yfWVsc2UgQT0hZjtBPyh4PWEodyh0LChLKCkscWgpKSwxNSkseD9oP2k9eDoobz1hKHcodCxIaCksMTUpLG8/eC5zaXplXzEoKTw9by5zaXplXzEoKT9pPXg6aT1vOihpPW5ldyBRLGoodCxIaCxpKSkpOihpPW5ldyBRLGoodCxxaCxpKSkpOihvPWEodyh0LChLKCksSGgpKSwxNSksbz9mP2k9bzooeD1hKHcodCxxaCksMTUpLHg/by5zaXplXzEoKTw9eC5zaXplXzEoKT9pPW86aT14OihpPW5ldyBRLGoodCxxaCxpKSkpOihpPW5ldyBRLGoodCxIaCxpKSkpLGkuYWRkXzIoZSksaihlLChLKCksY1ApLHIpLG4udGFyZ2V0PT1yPyhfdChuLG51bGwpLHIuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgrci5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MCYmTG8ocixudWxsKSxHYW4ocikpOihMdChuLG51bGwpLHIuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgrci5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MCYmTG8ocixudWxsKSksa2Eobi5iZW5kUG9pbnRzKX1mdW5jdGlvbiBHYW4oZSl7dmFyIG4scjtuPWEodyhlLChLKCksb2EpKSwxMCksbiYmKHI9bi5sYXllcixQaShyLm5vZGVzLG4pLHIubm9kZXMuYXJyYXkubGVuZ3RoPT0wJiZQaShTdChuKS5sYXllcnMscikpfWZ1bmN0aW9uIFcyZSgpe31wKDE1NTQsMSxzcixXMmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpeyRhbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiQ29tbWVudFByZXByb2Nlc3NvciIsMTU1NCk7ZnVuY3Rpb24gSGFuKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKG4uYmVnaW4oIkNvbnN0cmFpbnRzIFBvc3Rwcm9jZXNzb3IiLDEpLHM9MCxpPW5ldyBUKGUubGF5ZXJzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihvPWEoQyhpKSwzMCksYz0wLHU9ITEsdD1uZXcgVChvLm5vZGVzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTApLHIudHlwZV8wPT0oV2UoKSxrcikmJih1PSEwLGoociwob2UoKSxUUCksSihzKSksaihyLEVQLEooYykpLCsrYyk7dSYmKytzfW4uZG9uZV8xKCl9ZnVuY3Rpb24gajJlKCl7fXAoMTU1NSwxLHNyLGoyZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7SGFuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJDb25zdHJhaW50c1Bvc3Rwcm9jZXNzb3IiLDE1NTUpO2Z1bmN0aW9uIFVhbihlLG4pe3ZhciByLHQ7cmV0dXJuIShhZShpZSh3KG4sKEsoKSxPcykpKSl8fCh0PW4uc291cmNlLm93bmVyLGU9PShybCgpLFdFKSYmdC50eXBlXzA9PShXZSgpLFlvKSl8fChyPWEodyh0LChvZSgpLEVpKSksMTcxKSxyPT1GMCkpfWZ1bmN0aW9uIFdhbihlLG4pe3ZhciByLHQ7cmV0dXJuIShhZShpZSh3KG4sKEsoKSxPcykpKSl8fCh0PW4udGFyZ2V0Lm93bmVyLGU9PShybCgpLGpFKSYmdC50eXBlXzA9PShXZSgpLFlvKSl8fChyPWEodyh0LChvZSgpLEVpKSksMTcxKSxyPT14ZikpfWZ1bmN0aW9uIGphbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihfPW5ldyBUKGUpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7c3dpdGNoKGM9YShDKF8pLDEwKSxzPWEodyhjLChvZSgpLEVpKSksMTcxKSxpPW51bGwscy5vcmRpbmFsKXtjYXNlIDE6Y2FzZSAyOmk9KCRfKCksS3ApO2JyZWFrO2Nhc2UgMzpjYXNlIDQ6aT0oJF8oKSxKeSl9aWYoaSlqKGMsKEsoKSxkUCksKCRfKCksS3ApKSxpPT1KeT9FNChjLHMsKHF0KCksaWEpKTppPT1LcCYmRTQoYyxzLChxdCgpLHBpKSk7ZWxzZSBpZihPZyhhKHcoYyx4ciksMTAxKSkmJmMucG9ydHMuYXJyYXkubGVuZ3RoIT0wKXtmb3Iobj0hMCxmPW5ldyBUKGMucG9ydHMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoZD1hKEMoZiksMTIpLCEoZC5zaWRlPT0ocmUoKSxxZSkmJmQuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgtZC5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD4wfHxkLnNpZGU9PWplJiZkLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoLWQub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg8MCkpe249ITE7YnJlYWt9Zm9yKG89bmV3IFQoZC5vdXRnb2luZ0VkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYocj1hKEMobyksMTgpLHU9YSh3KHIudGFyZ2V0Lm93bmVyLEVpKSwxNzEpLHU9PShybCgpLGpFKXx8dT09eGYpe249ITE7YnJlYWt9Zm9yKHQ9bmV3IFQoZC5pbmNvbWluZ0VkZ2VzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYocj1hKEModCksMTgpLHU9YSh3KHIuc291cmNlLm93bmVyLEVpKSwxNzEpLHU9PShybCgpLFdFKXx8dT09RjApe249ITE7YnJlYWt9fW4mJkU0KGMscywocXQoKSxydikpfX19ZnVuY3Rpb24gVmFuKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKGk9bmV3IF9pKGUubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoKSxvPW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7c3dpdGNoKHQ9YShDKG8pLDEwKSxyPWEodyh0LChvZSgpLEVpKSksMTcxKSxuPW51bGwsci5vcmRpbmFsKXtjYXNlIDE6Y2FzZSAyOm49KCRfKCksS3ApO2JyZWFrO2Nhc2UgMzpjYXNlIDQ6bj0oJF8oKSxKeSl9bj8oaih0LChLKCksZFApLCgkXygpLEtwKSksbj09Snk/RTQodCxyLChxdCgpLGlhKSk6bj09S3AmJkU0KHQsciwocXQoKSxwaSkpKTpSZShpLmFycmF5LHQpfXJldHVybiBpfWZ1bmN0aW9uIHFhbihlLG4pe3ZhciByO24uYmVnaW4oIkVkZ2UgYW5kIGxheWVyIGNvbnN0cmFpbnQgZWRnZSByZXZlcnNhbCIsMSkscj1WYW4oZSksamFuKHIpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gRTQoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihkPXF3ZShlLnBvcnRzKSxmPTAsaD1kLmxlbmd0aDtmPGg7KytmKXtpZihfPWRbZl0scj09KHF0KCksaWEpfHxyPT1ydilmb3IoYz1jdShfLm91dGdvaW5nRWRnZXMpLG89YyxpPTAscz1vLmxlbmd0aDtpPHM7KytpKXQ9b1tpXSxXYW4obix0KSYmRzEodCwhMCk7aWYocj09cGl8fHI9PXJ2KWZvcih1PWN1KF8uaW5jb21pbmdFZGdlcyksbz11LGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpdD1vW2ldLFVhbihuLHQpJiZHMSh0LCEwKX19ZnVuY3Rpb24gVjJlKCl7fXAoMTU1NiwxLHNyLFYyZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cWFuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFZGdlQW5kTGF5ZXJDb25zdHJhaW50RWRnZVJldmVyc2VyIiwxNTU2KTtmdW5jdGlvbiBZYW4oZSxuKXtuLmJlZ2luKCJFbmQgbGFiZWwgcG9zdC1wcm9jZXNzaW5nIiwxKSxMcihKbihObyhuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcnMsMTYpKSxuZXcgWTJlKSxuZXcgSzJlKSxuZXcgWDJlKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIEthbihlKXt2YXIgbixyLHQsbyxpO2ZvcihuPWEodyhlLChLKCksSEUpKSw4NSksaT1lLnBvcyx0PW4udmFsdWVzXzAoKS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMzE0KSxvPXIuY2VsbFJlY3RhbmdsZSxvLnhfMCs9aS54XzAsby55XzArPWkueV8wLHIuaG9yaXpvbnRhbExheW91dE1vZGU/SGZlKHIpOldmZShyKTtqKGUsSEUsbnVsbCl9ZnVuY3Rpb24gcTJlKCl7fWZ1bmN0aW9uIFhhbihlKXtyZXR1cm4oZS50eXBlXzA9PShXZSgpLGtyKXx8ZS50eXBlXzA9PUZyKSYmX3IoZSwoSygpLEhFKSl9cCgxNTU3LDEsc3IscTJlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtZYW4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkVuZExhYmVsUG9zdHByb2Nlc3NvciIsMTU1Nyk7ZnVuY3Rpb24gWTJlKCl7fXAoMTU1OCwxLHt9LFkyZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2UobnVsbCxuZXcgeGUoYShuLDMwKS5ub2RlcywxNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxQb3N0cHJvY2Vzc29yL2xhbWJkYSQwJFR5cGUiLDE1NTgpO2Z1bmN0aW9uIEsyZSgpe31wKDE1NTksMSxJbixLMmUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBYYW4oYShuLDEwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFbmRMYWJlbFBvc3Rwcm9jZXNzb3IvbGFtYmRhJDEkVHlwZSIsMTU1OSk7ZnVuY3Rpb24gWDJlKCl7fXAoMTU2MCwxLEplLFgyZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7S2FuKGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxQb3N0cHJvY2Vzc29yL2xhbWJkYSQyJFR5cGUiLDE1NjApO2Z1bmN0aW9uIEphbihlLG4scil7dmFyIHQsbztzd2l0Y2gobz1lLnNpemVfMCx0PWUubWFyZ2luLG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybi10LnRvcF8wLXI7Y2FzZSAzOnJldHVybiBvLnlfMCt0LmJvdHRvbStyO2Nhc2UgMjpyZXR1cm4gby54XzArdC5yaWdodCtyO2Nhc2UgNDpyZXR1cm4tdC5sZWZ0LXI7ZGVmYXVsdDpyZXR1cm4gMH19ZnVuY3Rpb24gWmFuKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYoIWV8fGUuYXJyYXkubGVuZ3RoPT0wKXJldHVybiBudWxsO2ZvcihpPW5ldyBZZmUobiwhciksbz1uZXcgVChlKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksNzIpLFlIKGksKHdFKCksbmV3IGY0KHQpKSk7cmV0dXJuIHM9aS5jZWxsUmVjdGFuZ2xlLHMuaGVpZ2h0PShjPWkucGFkZGluZyxpLm1pbmltdW1Db250ZW50QXJlYVNpemUueV8wK2MudG9wXzArYy5ib3R0b20pLHMud2lkdGhfMD0odT1pLnBhZGRpbmcsaS5taW5pbXVtQ29udGVudEFyZWFTaXplLnhfMCt1LmxlZnQrdS5yaWdodCksaX1mdW5jdGlvbiBRYW4oZSxuLHIsdCl7b2xuKHQsZSxuLHIpfWZ1bmN0aW9uIGVsbihlLG4scix0LG8pe3ZhciBpLHMsdSxjO2ZvcihjPShpPWEoaXMoJHQpLDkpLG5ldyBKYShpLGEoRGwoaSxpLmxlbmd0aCksOSksMCkpLHU9bmV3IFQoZS5wb3J0cyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDEyKSxuW3MuaWRfMF0mJihubG4ocyxuW3MuaWRfMF0sdCksTWwoYyxzLnNpZGUpKTtvPyhzOShlLG4sKHJlKCkscWUpLDIqcix0KSxzOShlLG4samUsMipyLHQpKTooczkoZSxuLChyZSgpLFVlKSwyKnIsdCksczkoZSxuLGxuLDIqcix0KSl9ZnVuY3Rpb24gbmxuKGUsbixyKXt2YXIgdCxvLGkscyx1O3N3aXRjaCh0PW4uY2VsbFJlY3RhbmdsZSxpPWUub3duZXIuc2l6ZV8wLG89ZS5vd25lci5tYXJnaW4sdT1lLnBvcyxzPWtvKFAoSShvdCwxKSxYLDgsMCxbdSxlLmFuY2hvcl0pKSxlLnNpZGUub3JkaW5hbCl7Y2FzZSAxOnV1KG4sKE5pKCksVWwpKSx0LnlfMD0tby50b3BfMC1yLXQuaGVpZ2h0LGEoYShsZShuLmxhYmVscywwKSwxODcpLmdldFByb3BlcnR5KChLKCksamgpKSwyOTEpPT0oRGEoKSxCdSk/KGNzKG4sKHRhKCksSGwpKSx0LnhfMD1zLnhfMC1SKCQodyhlLFpwKSkpLXItdC53aWR0aF8wKTooY3MobiwodGEoKSxzdSkpLHQueF8wPXMueF8wK1IoJCh3KGUsWnApKSkrcik7YnJlYWs7Y2FzZSAyOmNzKG4sKHRhKCksc3UpKSx0LnhfMD1pLnhfMCtvLnJpZ2h0K3IsYShhKGxlKG4ubGFiZWxzLDApLDE4NykuZ2V0UHJvcGVydHkoKEsoKSxqaCkpLDI5MSk9PShEYSgpLEJ1KT8odXUobiwoTmkoKSxVbCkpLHQueV8wPXMueV8wLVIoJCh3KGUsWnApKSktci10LmhlaWdodCk6KHV1KG4sKE5pKCksX3MpKSx0LnlfMD1zLnlfMCtSKCQodyhlLFpwKSkpK3IpO2JyZWFrO2Nhc2UgMzp1dShuLChOaSgpLF9zKSksdC55XzA9aS55XzArby5ib3R0b20rcixhKGEobGUobi5sYWJlbHMsMCksMTg3KS5nZXRQcm9wZXJ0eSgoSygpLGpoKSksMjkxKT09KERhKCksQnUpPyhjcyhuLCh0YSgpLEhsKSksdC54XzA9cy54XzAtUigkKHcoZSxacCkpKS1yLXQud2lkdGhfMCk6KGNzKG4sKHRhKCksc3UpKSx0LnhfMD1zLnhfMCtSKCQodyhlLFpwKSkpK3IpO2JyZWFrO2Nhc2UgNDpjcyhuLCh0YSgpLEhsKSksdC54XzA9LW8ubGVmdC1yLXQud2lkdGhfMCxhKGEobGUobi5sYWJlbHMsMCksMTg3KS5nZXRQcm9wZXJ0eSgoSygpLGpoKSksMjkxKT09KERhKCksQnUpPyh1dShuLChOaSgpLFVsKSksdC55XzA9cy55XzAtUigkKHcoZSxacCkpKS1yLXQuaGVpZ2h0KToodXUobiwoTmkoKSxfcykpLHQueV8wPXMueV8wK1IoJCh3KGUsWnApKSkrcil9fWZ1bmN0aW9uIHJsbihlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIHoxKCksWUM7Y2FzZSAzOnJldHVybiB6MSgpLHFDO2Nhc2UgMjpyZXR1cm4gejEoKSxjODtjYXNlIDQ6cmV0dXJuIHoxKCksdTg7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gdGxuKGUsbil7dmFyIHIsdCxvO24uYmVnaW4oIkVuZCBsYWJlbCBwcmUtcHJvY2Vzc2luZyIsMSkscj1SKCQodyhlLChvZSgpLHRnKSkpKSx0PVIoJCh3KGUsTWYpKSksbz1BZyhhKHcoZSxPYSksODgpKSxMcihObyhuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcnMsMTYpKSxuZXcgZUVlKSxuZXcgbkVlKHIsdCxvKSksbi5kb25lXzEoKX1mdW5jdGlvbiBvbG4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2ZvcihzPWUucG9ydHMuYXJyYXkubGVuZ3RoLGM9QihEbm4sV0YsMzE0LHMsMCwxKSx1PTA7dTxzO3UrKylpPWEobGUoZS5wb3J0cyx1KSwxMiksaS5pZF8wPXUsY1t1XT1aYW4oWjJlKGkpLHIsdCk7Zm9yKGVsbihlLGMscixuLHQpLF89bmV3IHNuLG89MDtvPGMubGVuZ3RoO28rKyljW29dJiZCbihfLGEobGUoZS5wb3J0cyxvKSwxMiksY1tvXSk7Xy5oYXNoQ29kZU1hcC5zaXplXzArXy5zdHJpbmdNYXAuc2l6ZV8wIT0wJiYoaihlLChLKCksSEUpLF8pLGlsbihlLGMpKX1mdW5jdGlvbiBzOShlLG4scix0LG8pe3ZhciBpLHMsdSxjO2ZvcihzPXhybihyVSh0VShybG4ocikpLHQpLEphbihlLHIsbykpLGM9JGMoZSxyKS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMTIpLG5bdS5pZF8wXSYmKGk9blt1LmlkXzBdLmNlbGxSZWN0YW5nbGUsZWUocy5yZWN0YW5nbGVOb2RlcyxuZXcgXzgoaSxlVShzLGkpKSkpO25VKHMpfWZ1bmN0aW9uIGlsbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihzPWUubWFyZ2luLGM9ZS5zaXplXzAsdT1uZXcgdGwoLXMubGVmdCwtcy50b3BfMCxzLmxlZnQrYy54XzArcy5yaWdodCxzLnRvcF8wK2MueV8wK3MuYm90dG9tKSx0PW4sbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sciYmUnYodSxyLmNlbGxSZWN0YW5nbGUpO3MubGVmdD0tdS54XzAscy50b3BfMD0tdS55XzAscy5yaWdodD11LndpZHRoXzAtcy5sZWZ0LWMueF8wLHMuYm90dG9tPXUuaGVpZ2h0LXMudG9wXzAtYy55XzB9ZnVuY3Rpb24gSjJlKCl7fWZ1bmN0aW9uIFoyZShlKXt2YXIgbixyLHQsbyxpO2lmKG89bmV3IFEsaT1RMmUoZSxvKSxuPWEodyhlLChLKCksb2EpKSwxMCksbilmb3IodD1uZXcgVChuLnBvcnRzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTIpLEQodyhyLFFuKSk9PT1EKGUpJiYoaT1TLk1hdGgubWF4KGksUTJlKHIsbykpKTtyZXR1cm4gby5hcnJheS5sZW5ndGg9PTB8fGooZSxacCxpKSxpIT0tMT9vOm51bGx9ZnVuY3Rpb24gUTJlKGUsbil7dmFyIHIsdCxvLGkscyx1O2Zvcih1PS0xLHM9bmV3IHByLHQ9bmV3IExzKGUuY29ubmVjdGVkRWRnZXMpO3hvKHQuZmlyc3RJdGVyYXRvcil8fHhvKHQuc2Vjb25kSXRlcmF0b3IpOyl7Zm9yKHI9YSh4byh0LmZpcnN0SXRlcmF0b3IpP0ModC5maXJzdEl0ZXJhdG9yKTpDKHQuc2Vjb25kSXRlcmF0b3IpLDE4KSx1PVMuTWF0aC5tYXgodSxSKCQodyhyLChvZSgpLFVjKSkpKSksci5zb3VyY2U9PWU/THIoSm4obmV3IFNlKG51bGwsbmV3IHhlKHIubGFiZWxzLDE2KSksbmV3IHJFZSksbmV3IHRFZShzKSk6THIoSm4obmV3IFNlKG51bGwsbmV3IHhlKHIubGFiZWxzLDE2KSksbmV3IG9FZSksbmV3IGlFZShzKSksaT1kbihzLDApO2kuY3VycmVudE5vZGUhPWkudGhpcyQwMS50YWlsOylvPWEodW4oaSksNzIpLF9yKG8sKEsoKSxVaCkpfHxqKG8sVWgscik7cXIobixzKSxrYShzKX1yZXR1cm4gdX1wKDE1NjEsMSxzcixKMmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe3RsbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxQcmVwcm9jZXNzb3IiLDE1NjEpO2Z1bmN0aW9uIGVFZSgpe31wKDE1NjIsMSx7fSxlRWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwzMCkubm9kZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkVuZExhYmVsUHJlcHJvY2Vzc29yL2xhbWJkYSQwJFR5cGUiLDE1NjIpO2Z1bmN0aW9uIG5FZShlLG4scil7dGhpcy5lZGdlTGFiZWxTcGFjaW5nXzE9ZSx0aGlzLmxhYmVsTGFiZWxTcGFjaW5nXzM9bix0aGlzLnZlcnRpY2FsTGF5b3V0XzU9cn1wKDE1NjMsMSxKZSxuRWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1Fhbih0aGlzLmVkZ2VMYWJlbFNwYWNpbmdfMSx0aGlzLmxhYmVsTGFiZWxTcGFjaW5nXzMsdGhpcy52ZXJ0aWNhbExheW91dF81LGEobiwxMCkpfSxsLmVkZ2VMYWJlbFNwYWNpbmdfMT0wLGwubGFiZWxMYWJlbFNwYWNpbmdfMz0wLGwudmVydGljYWxMYXlvdXRfNT0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxQcmVwcm9jZXNzb3IvbGFtYmRhJDEkVHlwZSIsMTU2Myk7ZnVuY3Rpb24gckVlKCl7fXAoMTU2NCwxLEluLHJFZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEQodyhhKG4sNzIpLChvZSgpLGR1KSkpPT09RCgoR3MoKSxQdykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxQcmVwcm9jZXNzb3IvbGFtYmRhJDIkVHlwZSIsMTU2NCk7ZnVuY3Rpb24gdEVlKGUpe3RoaXMubGFiZWxzXzA9ZX1wKDE1NjUsMSxKZSx0RWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0xuKHRoaXMubGFiZWxzXzAsYShuLDcyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFbmRMYWJlbFByZXByb2Nlc3Nvci9sYW1iZGEkMyRUeXBlIiwxNTY1KTtmdW5jdGlvbiBvRWUoKXt9cCgxNTY2LDEsSW4sb0VlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gRCh3KGEobiw3MiksKG9lKCksZHUpKSk9PT1EKChHcygpLFZmKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFbmRMYWJlbFByZXByb2Nlc3Nvci9sYW1iZGEkNCRUeXBlIiwxNTY2KTtmdW5jdGlvbiBpRWUoZSl7dGhpcy5sYWJlbHNfMD1lfXAoMTU2NywxLEplLGlFZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7TG4odGhpcy5sYWJlbHNfMCxhKG4sNzIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkVuZExhYmVsUHJlcHJvY2Vzc29yL2xhbWJkYSQ1JFR5cGUiLDE1NjcpO2Z1bmN0aW9uIGYzKCl7ZjM9RixsRWU9bmV3IHNFZX1mdW5jdGlvbiBhbG4oZSl7dmFyIG4scix0LG87Zm9yKHI9bmV3IHNuLG89bmV3IFQoZS5sYWJlbHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxODcpLG49YSh0LmdldFByb3BlcnR5KChLKCksVWgpKSwxOCksanQoci5oYXNoQ29kZU1hcCxuKXx8Qm4ocixuLG5ldyB1RWUobikpLGVlKGEoX28oanQoci5oYXNoQ29kZU1hcCxuKSksNDY2KS5sYWJlbHMsdCk7cmV0dXJuIG5ldyBRaShuZXcgdGMocikpfWZ1bmN0aW9uIGxsbihlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3IodD0wLHI9bmV3IFQoZS5sYXllcnMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobj1hKEMociksMzApLGk9bmV3IFQobi5ub2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwxMCksby5pZF8wPXQrKyx1PW5ldyBUKG8ucG9ydHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMikscy5pZF8wPXQrK31mdW5jdGlvbiBzbG4oZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKG49MCxvPW5ldyBUKGUuaW5jb21pbmdFZGdlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE4KSxyPU1wKG5ldyBTZShudWxsLG5ldyB4ZSh0LmxhYmVscywxNikpLG5ldyBmRWUpLHImJisrbjtmb3Iocz1uZXcgVChlLm91dGdvaW5nRWRnZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxOCksdT1NcChuZXcgU2UobnVsbCxuZXcgeGUoaS5sYWJlbHMsMTYpKSxuZXcgcEVlKSx1JiYrK247cmV0dXJuIG4+PTJ9ZnVuY3Rpb24gdWxuKGUsbil7bi5iZWdpbigiU29ydCBlbmQgbGFiZWxzIiwxKSxMcihKbihObyhuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcnMsMTYpKSxuZXcgY0VlKSxuZXcgX0VlKSxuZXcgZEVlKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIGNsbihlKXt2YXIgbixyLHQsbztpZihuPSExLF9yKGUsKEsoKSxIRSkpKWZvcihyPWEodyhlLEhFKSw4NSksbz1uZXcgVChlLnBvcnRzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTIpLHNsbih0KSYmKG58fChsbG4oU3QoZSkpLG49ITApLF9sbihhKHIuZ2V0XzModCksMzE0KSkpfWZ1bmN0aW9uIF9sbihlKXt2YXIgbixyLHQsbztmb3IodD1hbG4oZSksRHIodCxsRWUpLG89ZS5sYWJlbHMsby5hcnJheS5sZW5ndGg9MCxyPW5ldyBUKHQpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSw0NjYpLHFyKG8sbi5sYWJlbHMpfWZ1bmN0aW9uIGFFZSgpe2YzKCl9cCgxNjE1LDEsc3IsYUVlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXt1bG4oYShuLDM2KSxyKX07dmFyIGxFZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxTb3J0ZXIiLDE2MTUpO2Z1bmN0aW9uIGRsbihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9cW8oZS5lZGdlLnNvdXJjZS5pZF8wLG4uZWRnZS5zb3VyY2UuaWRfMCksciE9MD9yOih0PXFvKGUuZWRnZS50YXJnZXQub3duZXIuaWRfMCxuLmVkZ2UudGFyZ2V0Lm93bmVyLmlkXzApLHQhPTA/dDpxbyhuLmVkZ2UudGFyZ2V0LmlkXzAsZS5lZGdlLnRhcmdldC5pZF8wKSl9ZnVuY3Rpb24gc0VlKCl7fXAoMTYxNiwxLE5uLHNFZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gZGxuKGEobiw0NjYpLGEociw0NjYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxTb3J0ZXIvMSIsMTYxNik7ZnVuY3Rpb24gdUVlKGUpe3RoaXMubGFiZWxzPW5ldyBRLHFyKHRoaXMubGFiZWxzLHRoaXMubGFiZWxzKSx0aGlzLmVkZ2U9ZX1wKDQ2NiwxLHs0NjY6MX0sdUVlKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxTb3J0ZXIvTGFiZWxHcm91cCIsNDY2KTtmdW5jdGlvbiBjRWUoKXt9cCgxNjE3LDEse30sY0VlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGYzKCksbmV3IFNlKG51bGwsbmV3IHhlKGEobiwzMCkubm9kZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkVuZExhYmVsU29ydGVyL2xhbWJkYSQwJFR5cGUiLDE2MTcpO2Z1bmN0aW9uIF9FZSgpe31wKDE2MTgsMSxJbixfRWUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBmMygpLGEobiwxMCkudHlwZV8wPT0oV2UoKSxrcil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFbmRMYWJlbFNvcnRlci9sYW1iZGEkMSRUeXBlIiwxNjE4KTtmdW5jdGlvbiBkRWUoKXt9cCgxNjE5LDEsSmUsZEVlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtjbG4oYShuLDEwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJFbmRMYWJlbFNvcnRlci9sYW1iZGEkMiRUeXBlIiwxNjE5KTtmdW5jdGlvbiBmRWUoKXt9cCgxNjIwLDEsSW4sZkVlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gZjMoKSxEKHcoYShuLDcyKSwob2UoKSxkdSkpKT09PUQoKEdzKCksVmYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkVuZExhYmVsU29ydGVyL2xhbWJkYSQzJFR5cGUiLDE2MjApO2Z1bmN0aW9uIHBFZSgpe31wKDE2MjEsMSxJbixwRWUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBmMygpLEQodyhhKG4sNzIpLChvZSgpLGR1KSkpPT09RCgoR3MoKSxQdykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRW5kTGFiZWxTb3J0ZXIvbGFtYmRhJDQkVHlwZSIsMTYyMSk7ZnVuY3Rpb24gdTkoZSxuKXtyZXR1cm4gUy5NYXRoLmFicyhlKTxTLk1hdGguYWJzKG4pP2U6bn1mdW5jdGlvbiBmbG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2U7aWYoIW4uaXNFbXB0eSgpKXtpZihvPW5ldyBqaSx1PXJ8fGEobi5nZXRfMCgwKSwxOCkseT11LnNvdXJjZSxfdigpLGg9eS5vd25lci50eXBlXzAsIShoPT0oV2UoKSxrcil8fGg9PXRpfHxoPT1Gcnx8aD09TnMpKXRocm93IGIobmV3IEdlKCJUaGUgdGFyZ2V0IG5vZGUgb2YgdGhlIGVkZ2UgbXVzdCBiZSBhIG5vcm1hbCBub2RlIG9yIGEgbm9ydGhTb3V0aFBvcnQuIikpO2ZvcihNdChvLGtvKFAoSShvdCwxKSxYLDgsMCxbeS5vd25lci5wb3MseS5wb3MseS5hbmNob3JdKSkpLChyZSgpLGtpKS5jb250YWlucyh5LnNpZGUpJiYodj1SKCQodyh5LChLKCksdHcpKSkpLGY9bmV3IFkoa28oUChJKG90LDEpLFgsOCwwLFt5Lm93bmVyLnBvcyx5LnBvcyx5LmFuY2hvcl0pKS54XzAsdiksYnIobyxmLG8udGFpbC5wcmV2LG8udGFpbCkpLGQ9bnVsbCx0PSExLGM9bi5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspcz1hKGMubmV4dF8xKCksMTgpLGk9cy5iZW5kUG9pbnRzLGkuc2l6ZV8wIT0wJiYodD8oXz15dShLbihkLChybihpLnNpemVfMCE9MCksYShpLmhlYWRlci5uZXh0XzAudmFsdWVfMCw4KSkpLC41KSxicihvLF8sby50YWlsLnByZXYsby50YWlsKSx0PSExKTp0PSEwLGQ9Q3QoKHJuKGkuc2l6ZV8wIT0wKSxhKGkudGFpbC5wcmV2LnZhbHVlXzAsOCkpKSxmdChvLGkpLGthKGkpKTtFPXUudGFyZ2V0LGtpLmNvbnRhaW5zKEUuc2lkZSkmJih2PVIoJCh3KEUsKEsoKSx0dykpKSksZj1uZXcgWShrbyhQKEkob3QsMSksWCw4LDAsW0Uub3duZXIucG9zLEUucG9zLEUuYW5jaG9yXSkpLnhfMCx2KSxicihvLGYsby50YWlsLnByZXYsby50YWlsKSksTXQobyxrbyhQKEkob3QsMSksWCw4LDAsW0Uub3duZXIucG9zLEUucG9zLEUuYW5jaG9yXSkpKSxlLnNwbGluZVJvdXRpbmdNb2RlPT0oZHcoKSxlNykmJih4PShybihvLnNpemVfMCE9MCksYShvLmhlYWRlci5uZXh0XzAudmFsdWVfMCw4KSksQT1hKFZhKG8sMSksOCksaz1uZXcgWE0oZVgoeS5zaWRlKSksay54XzAqPTUsay55XzAqPTUsTT1ydChuZXcgWShBLnhfMCxBLnlfMCkseCksSD1uZXcgWSh1OShrLnhfMCxNLnhfMCksdTkoay55XzAsTS55XzApKSxLbihILHgpLHE9ZG4obywxKSxSQyhxLEgpLG5lPShybihvLnNpemVfMCE9MCksYShvLnRhaWwucHJldi52YWx1ZV8wLDgpKSx2ZT1hKFZhKG8sby5zaXplXzAtMiksOCksaz1uZXcgWE0oZVgoRS5zaWRlKSksay54XzAqPTUsay55XzAqPTUsTT1ydChuZXcgWSh2ZS54XzAsdmUueV8wKSxuZSksd2U9bmV3IFkodTkoay54XzAsTS54XzApLHU5KGsueV8wLE0ueV8wKSksS24od2UsbmUpLFptKG8sby5zaXplXzAtMSx3ZSkpLG09bmV3IFhLKG8pLGZ0KHUuYmVuZFBvaW50cyxDNWUobSkpfX1mdW5jdGlvbiBwbG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZighbi5oYW5kbGVkKXtmb3Iobi5oYW5kbGVkPSEwLHQ9bi5lZGdlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOyl7aWYocj1hKHQubmV4dF8xKCksMTgpLG4uaXNTdHJhaWdodCYmbi5lZGdlcy5tYXBfMC5zaXplXzEoKTw9MSl7cz1uLmJvdW5kaW5nQm94LnhfMCx1PW4uYm91bmRpbmdCb3gueF8wK24uYm91bmRpbmdCb3gud2lkdGhfMCxjPW5ldyBZKHMrKHUtcykvMixuLmNlbnRlckNvbnRyb2xQb2ludFkpLExuKGEobi5lZGdlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSwxOCkuYmVuZFBvaW50cyxjKTtjb250aW51ZX1pZihvPWEoS2Uobi5lZGdlSW5mb3JtYXRpb24sciksNDY4KSxvLmludmVydGVkTGVmdHx8by5pbnZlcnRlZFJpZ2h0KXtobG4oZSxyLG4pO2NvbnRpbnVlfWk9ZS5zcGxpbmVSb3V0aW5nTW9kZT09KGR3KCksaXYpJiYoby5ub3JtYWxTb3VyY2VOb2RlfHxvLm5vcm1hbFRhcmdldE5vZGUpJiZ2bG4oZSxuKSYmbi5lZGdlcy5tYXBfMC5zaXplXzEoKTw9MSxpP21sbihyLG4pOmdsbihlLHIsbil9bi5pbnZlcnNlT3JkZXImJkV0KG4uZWRnZXMsbmV3IFNFZSl9fWZ1bmN0aW9uIGdsbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2Q9ci5ib3VuZGluZ0JveC54XzAscz1yLmJvdW5kaW5nQm94LnhfMCtyLmJvdW5kaW5nQm94LndpZHRoXzAsaT1hKEtlKHIuZWRnZUluZm9ybWF0aW9uLG4pLDQ2OCksbT1pLnN0YXJ0WSx5PWkuZW5kWSxjPW5ldyBZKGQsbSksZj1uZXcgWShzLHkpLG89ZCxyLmlzV2VzdE9mSW5pdGlhbExheWVyfHwobys9ZS5lZGdlTm9kZVNwYWNpbmcpLG8rPXIueERlbHRhK3IucmFuayplLmVkZ2VFZGdlU3BhY2luZyxfPW5ldyBZKG8sbSksaD1uZXcgWShvLHkpLHp2KG4uYmVuZFBvaW50cyxQKEkob3QsMSksWCw4LDAsW2MsX10pKSx1PXIuZWRnZXMubWFwXzAuc2l6ZV8xKCk+MSx1JiYodD1uZXcgWShvLHIuY2VudGVyQ29udHJvbFBvaW50WSksTG4obi5iZW5kUG9pbnRzLHQpKSx6dihuLmJlbmRQb2ludHMsUChJKG90LDEpLFgsOCwwLFtoLGZdKSl9ZnVuY3Rpb24gaGxuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7ZD1yLmJvdW5kaW5nQm94LnhfMCxzPXIuYm91bmRpbmdCb3gueF8wK3IuYm91bmRpbmdCb3gud2lkdGhfMCxpPWEoS2Uoci5lZGdlSW5mb3JtYXRpb24sbiksNDY4KSxtPWkuc3RhcnRZLHk9aS5lbmRZLGkuaW52ZXJ0ZWRMZWZ0P2M9bmV3IFkocyxtKTpjPW5ldyBZKGQsbSksaS5pbnZlcnRlZFJpZ2h0P2Y9bmV3IFkoZCx5KTpmPW5ldyBZKHMseSksbz1kLHIuaXNXZXN0T2ZJbml0aWFsTGF5ZXJ8fChvKz1lLmVkZ2VOb2RlU3BhY2luZyksbys9ci54RGVsdGErci5yYW5rKmUuZWRnZUVkZ2VTcGFjaW5nLF89bmV3IFkobyxtKSxoPW5ldyBZKG8seSksenYobi5iZW5kUG9pbnRzLFAoSShvdCwxKSxYLDgsMCxbYyxfXSkpLHU9ci5lZGdlcy5tYXBfMC5zaXplXzEoKT4xLHUmJih0PW5ldyBZKG8sci5jZW50ZXJDb250cm9sUG9pbnRZKSxMbihuLmJlbmRQb2ludHMsdCkpLHp2KG4uYmVuZFBvaW50cyxQKEkob3QsMSksWCw4LDAsW2gsZl0pKX1mdW5jdGlvbiBtbG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGU7dT1hKEtlKG4uZWRnZUluZm9ybWF0aW9uLGUpLDQ2OCksQT1uLmJvdW5kaW5nQm94LnhfMCxjPW4uYm91bmRpbmdCb3gueF8wK24uYm91bmRpbmdCb3gud2lkdGhfMCx3ZT11LnN0YXJ0WSxEZT11LmVuZFkscz13ZTxEZSxFPW5ldyBZKEEsd2UpLGs9bmV3IFkoYyxEZSksbz0oQStjKS8yLHY9bmV3IFkobyx3ZSksTT1uZXcgWShvLERlKSxpPXlsbihlLHdlLERlKSxxPUFzKG4uc291cmNlUG9ydCksbmU9bmV3IFkobyxpKSx2ZT1BcyhuLnRhcmdldFBvcnQpLHI9azJuKFAoSShvdCwxKSxYLDgsMCxbcSxuZSx2ZV0pKSxtPSExLHg9bi5zb3VyY2VQb3J0Lm93bmVyLHgmJngubGF5ZXImJnUubm9ybWFsU291cmNlTm9kZSYmKF89cyYmeC5pZF8wPHgubGF5ZXIubm9kZXMuYXJyYXkubGVuZ3RoLTF8fCFzJiZ4LmlkXzA+MCxfP18mJihoPXguaWRfMCxzPysraDotLWgsZj1hKGxlKHgubGF5ZXIubm9kZXMsaCksMTApLHQ9Z0VlKGYpLG09IShZTSh0LHEsclswXSl8fFNEZSh0LHEsclswXSkpKTptPSEwKSx5PSExLEg9bi50YXJnZXRQb3J0Lm93bmVyLEgmJkgubGF5ZXImJnUubm9ybWFsVGFyZ2V0Tm9kZSYmKGQ9cyYmSC5pZF8wPjB8fCFzJiZILmlkXzA8SC5sYXllci5ub2Rlcy5hcnJheS5sZW5ndGgtMSxkPyhoPUguaWRfMCxzPy0taDorK2gsZj1hKGxlKEgubGF5ZXIubm9kZXMsaCksMTApLHQ9Z0VlKGYpLHk9IShZTSh0LHJbMF0sdmUpfHxTRGUodCxyWzBdLHZlKSkpOnk9ITApLG0mJnkmJkxuKGUuYmVuZFBvaW50cyxuZSksbXx8enYoZS5iZW5kUG9pbnRzLFAoSShvdCwxKSxYLDgsMCxbRSx2XSkpLHl8fHp2KGUuYmVuZFBvaW50cyxQKEkob3QsMSksWCw4LDAsW00sa10pKX1mdW5jdGlvbiB5bG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpZihpPTAscz0wLGUuc291cmNlKWZvcihjPW5ldyBUKGUudGFyZ2V0Lm93bmVyLnBvcnRzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoYyksMTIpLGkrPXUuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGg7ZWxzZSBpPTE7aWYoZS50YXJnZXQpZm9yKGM9bmV3IFQoZS5zb3VyY2Uub3duZXIucG9ydHMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxMikscys9dS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aDtlbHNlIHM9MTtyZXR1cm4gbz1LcihJQyhzLWkpKSx0PShyK24pLzIrKHItbikqKC40Km8pLHR9ZnVuY3Rpb24gd2xuKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKHQ9bmV3IFQoZS5sYXllcnMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocj1hKEModCksMzApLG49MCxpPW5ldyBUKHIubm9kZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxMCksby5pZF8wPW4rK31mdW5jdGlvbiBnRWUoZSl7dmFyIG4scix0O3JldHVybiByPWUucG9zLHQ9ZS5zaXplXzAsbj1lLm1hcmdpbixuZXcgdGwoci54XzAtbi5sZWZ0LHIueV8wLW4udG9wXzAsdC54XzArKG4ubGVmdCtuLnJpZ2h0KSx0LnlfMCsobi50b3BfMCtuLmJvdHRvbSkpfWZ1bmN0aW9uIEVsbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihlLmVkZ2VFZGdlU3BhY2luZz1SKCQodyhuLChvZSgpLHJnKSkpKSxlLmVkZ2VOb2RlU3BhY2luZz1SKCQodyhuLHFfKSkpLGUuc3BsaW5lUm91dGluZ01vZGU9YSh3KG4sQ08pLDM1MCksZS5jb21wYWN0aW9uU3RyYXRlZ3k9YSh3KG4sbVApLDI4Miksd2xuKG4pLHU9YShUbyhKbihKbihObyhObyhuZXcgU2UobnVsbCxuZXcgeGUobi5sYXllcnMsMTYpKSxuZXcgbUVlKSxuZXcgeUVlKSxuZXcgd0VlKSxuZXcgRUVlKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksbz11Lml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOylyPWEoby5uZXh0XzEoKSwxOCkscz1hKHcociwoSygpLEdfKSksMTUpLHMuZm9yRWFjaF8wKG5ldyB2RWUoZSkpLGoocixHXyxudWxsKTtmb3IodD11Lml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwxOCksYz1hKHcociwoSygpLGFxKSksMTgpLGk9YSh3KHIsbmcpLDE1KSxmbG4oZSxpLGMpLGoocixuZyxudWxsKX1mdW5jdGlvbiB2bG4oZSxuKXt2YXIgcix0LG8saSxzO3JldHVybiBlLmNvbXBhY3Rpb25TdHJhdGVneT09KFp5KCksJEUpPyEwOihpPW4uYm91bmRpbmdCb3gueF8wLHI9bi5ib3VuZGluZ0JveC54XzArbi5ib3VuZGluZ0JveC53aWR0aF8wLCEobi5pbml0aWFsU2VnbWVudCYmKHQ9bi5zb3VyY2VOb2RlLHM9dC5sYXllci5zaXplXzAueF8wLXQuc2l6ZV8wLnhfMC8yLG89aS0odC5wb3MueF8wK3Quc2l6ZV8wLnhfMCksbz5zKXx8bi5sYXN0U2VnbWVudCYmKHQ9bi50YXJnZXROb2RlLHM9dC5sYXllci5zaXplXzAueF8wLXQuc2l6ZV8wLnhfMC8yLG89dC5wb3MueF8wLXIsbz5zKSkpfWZ1bmN0aW9uIGhFZSgpe31wKDE1NjgsMSxzcixoRWUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0Vsbih0aGlzLGEobiwzNikpfSxsLmVkZ2VFZGdlU3BhY2luZz0wLGwuZWRnZU5vZGVTcGFjaW5nPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkZpbmFsU3BsaW5lQmVuZHBvaW50c0NhbGN1bGF0b3IiLDE1NjgpO2Z1bmN0aW9uIG1FZSgpe31wKDE1NjksMSx7fSxtRWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwzMCkubm9kZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkZpbmFsU3BsaW5lQmVuZHBvaW50c0NhbGN1bGF0b3IvbGFtYmRhJDAkVHlwZSIsMTU2OSk7ZnVuY3Rpb24geUVlKCl7fXAoMTU3MCwxLHt9LHlFZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2UobnVsbCxuZXcgTzEobmV3IFhlKFFlKFJyKGEobiwxMCkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRmluYWxTcGxpbmVCZW5kcG9pbnRzQ2FsY3VsYXRvci9sYW1iZGEkMSRUeXBlIiwxNTcwKTtmdW5jdGlvbiB3RWUoKXt9cCgxNTcxLDEsSW4sd0VlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4henQoYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJGaW5hbFNwbGluZUJlbmRwb2ludHNDYWxjdWxhdG9yL2xhbWJkYSQyJFR5cGUiLDE1NzEpO2Z1bmN0aW9uIEVFZSgpe31wKDE1NzIsMSxJbixFRWUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBfcihhKG4sMTgpLChLKCksR18pKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkZpbmFsU3BsaW5lQmVuZHBvaW50c0NhbGN1bGF0b3IvbGFtYmRhJDMkVHlwZSIsMTU3Mik7ZnVuY3Rpb24gdkVlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNTczLDEsSmUsdkVlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtwbG4odGhpcy4kJG91dGVyXzAsYShuLDEzMSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRmluYWxTcGxpbmVCZW5kcG9pbnRzQ2FsY3VsYXRvci9sYW1iZGEkNCRUeXBlIiwxNTczKTtmdW5jdGlvbiBTRWUoKXt9cCgxNTc0LDEsSmUsU0VlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtPQyhhKG4sMTgpLmJlbmRQb2ludHMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiRmluYWxTcGxpbmVCZW5kcG9pbnRzQ2FsY3VsYXRvci9sYW1iZGEkNSRUeXBlIiwxNTc0KTtmdW5jdGlvbiBDRWUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAyOnJldHVybiByZSgpLGplO2Nhc2UgNDpyZXR1cm4gcmUoKSxxZTtkZWZhdWx0OnJldHVybiBlfX1mdW5jdGlvbiBURWUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAxOnJldHVybiByZSgpLGxuO2Nhc2UgMzpyZXR1cm4gcmUoKSxVZTtkZWZhdWx0OnJldHVybiBlfX1mdW5jdGlvbiBURShlLG4pe1RsbihuLGUpLHJqKGUucGFkZGluZykscmooYSh3KGUsKG9lKCksSVApKSwyMTQpKX1mdW5jdGlvbiBjOShlLG4pe2JsbihuLGUpLHRqKGUucGFkZGluZyksdGooYSh3KGUsKG9lKCksSVApKSwyMTQpKX1mdW5jdGlvbiBTbG4oZSl7c3dpdGNoKGEodyhlLChLKCksQl8pKSwzMTEpLm9yZGluYWwpe2Nhc2UgMTpqKGUsQl8sKGxjKCksR2gpKTticmVhaztjYXNlIDI6aihlLEJfLChsYygpLEpwKSl9fWZ1bmN0aW9uIENsbihlKXtzd2l0Y2goYSh3KGUsKG9lKCksRWkpKSwxNzEpLm9yZGluYWwpe2Nhc2UgMTpqKGUsRWksKHJsKCksakUpKTticmVhaztjYXNlIDI6aihlLEVpLChybCgpLHhmKSk7YnJlYWs7Y2FzZSAzOmooZSxFaSwocmwoKSxXRSkpO2JyZWFrO2Nhc2UgNDpqKGUsRWksKHJsKCksRjApKX19ZnVuY3Rpb24gYkVlKGUpe3ZhciBuO19yKGUsKG9lKCksZWQpKSYmKG49YSh3KGUsZWQpLDIxKSxuLmNvbnRhaW5zKChxZigpLEtsKSk/KG4ucmVtb3ZlXzEoS2wpLG4uYWRkXzIoWGwpKTpuLmNvbnRhaW5zKFhsKSYmKG4ucmVtb3ZlXzEoWGwpLG4uYWRkXzIoS2wpKSl9ZnVuY3Rpb24gSUVlKGUpe3ZhciBuO19yKGUsKG9lKCksZWQpKSYmKG49YSh3KGUsZWQpLDIxKSxuLmNvbnRhaW5zKChxZigpLFpsKSk/KG4ucmVtb3ZlXzEoWmwpLG4uYWRkXzIoVGwpKTpuLmNvbnRhaW5zKFRsKSYmKG4ucmVtb3ZlXzEoVGwpLG4uYWRkXzIoWmwpKSl9ZnVuY3Rpb24gVGxuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE07aWYoQT0wLG4uc2l6ZV8wLnhfMD09MClmb3Iodj1uZXcgVChlKTt2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aDspeT1hKEModiksMTApLEE9Uy5NYXRoLm1heChBLHkucG9zLnhfMCt5LnNpemVfMC54XzAreS5tYXJnaW4ucmlnaHQpO2Vsc2UgQT1uLnNpemVfMC54XzAtbi5vZmZzZXQueF8wO2ZvcihBLT1uLm9mZnNldC54XzAsRT1uZXcgVChlKTtFLmk8RS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe3N3aXRjaCh5PWEoQyhFKSwxMCksYkUoeS5wb3MsQS15LnNpemVfMC54XzApLHJqKHkucGFkZGluZyksYkVlKHkpLCh5LnByb3BlcnR5TWFwP3kucHJvcGVydHlNYXA6KE5lKCksTmUoKSxrdSkpLmNvbnRhaW5zS2V5KChvZSgpLE9mKSkmJmJFKGEodyh5LE9mKSw4KSxBLXkuc2l6ZV8wLnhfMCksYSh3KHksX3UpLDI1NSkub3JkaW5hbCl7Y2FzZSAxOmooeSxfdSwoJHUoKSxiVCkpO2JyZWFrO2Nhc2UgMjpqKHksX3UsKCR1KCksVFQpKX1mb3IoeD15LnNpemVfMCxNPW5ldyBUKHkucG9ydHMpO00uaTxNLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGs9YShDKE0pLDEyKSxiRShrLnBvcyx4LnhfMC1rLnNpemVfMC54XzApLGJFKGsuYW5jaG9yLGsuc2l6ZV8wLnhfMCksWHIoayxDRWUoay5zaWRlKSkscz1hKHcoayxXYyksMTcpLHMmJmooayxXYyxKKC1zLnZhbHVlXzApKSxpPW5ldyBUKGsub3V0Z29pbmdFZGdlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iobz1hKEMoaSksMTgpLHQ9ZG4oby5iZW5kUG9pbnRzLDApO3QuY3VycmVudE5vZGUhPXQudGhpcyQwMS50YWlsOylyPWEodW4odCksOCksci54XzA9QS1yLnhfMDtpZihfPWEodyhvLGlvKSw3NSksXylmb3IoYz1kbihfLDApO2MuY3VycmVudE5vZGUhPWMudGhpcyQwMS50YWlsOyl1PWEodW4oYyksOCksdS54XzA9QS11LnhfMDtmb3IoaD1uZXcgVChvLmxhYmVscyk7aC5pPGgudGhpcyQwMS5hcnJheS5sZW5ndGg7KWQ9YShDKGgpLDcyKSxiRShkLnBvcyxBLWQuc2l6ZV8wLnhfMCl9Zm9yKG09bmV3IFQoay5sYWJlbHMpO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhtKSw3MiksYkUoZC5wb3Msay5zaXplXzAueF8wLWQuc2l6ZV8wLnhfMCl9Zm9yKHkudHlwZV8wPT0oV2UoKSxGcikmJihqKHksKEsoKSxEbyksQ0VlKGEodyh5LERvKSw2NCkpKSxDbG4oeSkpLGY9bmV3IFQoeS5sYWJlbHMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSw3MiksYkVlKGQpLGJFKGQucG9zLHgueF8wLWQuc2l6ZV8wLnhfMCl9fWZ1bmN0aW9uIGJFKGUsbil7ZS54XzA9bi1lLnhfMH1mdW5jdGlvbiByaihlKXt2YXIgbixyO249ZS5sZWZ0LHI9ZS5yaWdodCxlLmxlZnQ9cixlLnJpZ2h0PW59ZnVuY3Rpb24gYmxuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE07aWYoQT0wLG4uc2l6ZV8wLnlfMD09MClmb3Iodj1uZXcgVChlKTt2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aDspeT1hKEModiksMTApLEE9Uy5NYXRoLm1heChBLHkucG9zLnlfMCt5LnNpemVfMC55XzAreS5tYXJnaW4uYm90dG9tKTtlbHNlIEE9bi5zaXplXzAueV8wLW4ub2Zmc2V0LnlfMDtmb3IoQS09bi5vZmZzZXQueV8wLEU9bmV3IFQoZSk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtzd2l0Y2goeT1hKEMoRSksMTApLElFKHkucG9zLEEteS5zaXplXzAueV8wKSx0aih5LnBhZGRpbmcpLElFZSh5KSwoeS5wcm9wZXJ0eU1hcD95LnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5jb250YWluc0tleSgob2UoKSxPZikpJiZJRShhKHcoeSxPZiksOCksQS15LnNpemVfMC55XzApLGEodyh5LF91KSwyNTUpLm9yZGluYWwpe2Nhc2UgMzpqKHksX3UsKCR1KCksWk4pKTticmVhaztjYXNlIDQ6aih5LF91LCgkdSgpLGVBKSl9Zm9yKHg9eS5zaXplXzAsTT1uZXcgVCh5LnBvcnRzKTtNLmk8TS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihrPWEoQyhNKSwxMiksSUUoay5wb3MseC55XzAtay5zaXplXzAueV8wKSxJRShrLmFuY2hvcixrLnNpemVfMC55XzApLFhyKGssVEVlKGsuc2lkZSkpLHM9YSh3KGssV2MpLDE3KSxzJiZqKGssV2MsSigtcy52YWx1ZV8wKSksaT1uZXcgVChrLm91dGdvaW5nRWRnZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKG89YShDKGkpLDE4KSx0PWRuKG8uYmVuZFBvaW50cywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDgpLHIueV8wPUEtci55XzA7aWYoXz1hKHcobyxpbyksNzUpLF8pZm9yKGM9ZG4oXywwKTtjLmN1cnJlbnROb2RlIT1jLnRoaXMkMDEudGFpbDspdT1hKHVuKGMpLDgpLHUueV8wPUEtdS55XzA7Zm9yKGg9bmV3IFQoby5sYWJlbHMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhoKSw3MiksSUUoZC5wb3MsQS1kLnNpemVfMC55XzApfWZvcihtPW5ldyBUKGsubGFiZWxzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZD1hKEMobSksNzIpLElFKGQucG9zLGsuc2l6ZV8wLnlfMC1kLnNpemVfMC55XzApfWZvcih5LnR5cGVfMD09KFdlKCksRnIpJiYoaih5LChLKCksRG8pLFRFZShhKHcoeSxEbyksNjQpKSksU2xuKHkpKSxmPW5ldyBUKHkubGFiZWxzKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspZD1hKEMoZiksNzIpLElFZShkKSxJRShkLnBvcyx4LnlfMC1kLnNpemVfMC55XzApfX1mdW5jdGlvbiBJRShlLG4pe2UueV8wPW4tZS55XzB9ZnVuY3Rpb24gdGooZSl7dmFyIG4scjtyPWUudG9wXzAsbj1lLmJvdHRvbSxlLnRvcF8wPW4sZS5ib3R0b209cn1mdW5jdGlvbiBJbG4oZSxuLHIpe3ZhciB0LG8saSxzO2ZvcihyLmJlZ2luKCJHcmFwaCB0cmFuc2Zvcm1hdGlvbiAoIitlLm1vZGUrIikiLDEpLHM9djEobi5sYXllcmxlc3NOb2RlcyksaT1uZXcgVChuLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDMwKSxxcihzLG8ubm9kZXMpO2lmKHQ9YSh3KG4sKG9lKCksSHEpKSw0MjgpLHQ9PShUMygpLG5QKSlzd2l0Y2goYSh3KG4sT2EpLDg4KS5vcmRpbmFsKXtjYXNlIDI6VEUobixzKTticmVhaztjYXNlIDM6eEUobixzKTticmVhaztjYXNlIDQ6ZS5tb2RlPT0oRnkoKSxwMyk/KHhFKG4scyksYzkobixzKSk6KGM5KG4scykseEUobixzKSl9ZWxzZSBpZihlLm1vZGU9PShGeSgpLHAzKSlzd2l0Y2goYSh3KG4sT2EpLDg4KS5vcmRpbmFsKXtjYXNlIDI6VEUobixzKSxjOShuLHMpO2JyZWFrO2Nhc2UgMzp4RShuLHMpLFRFKG4scyk7YnJlYWs7Y2FzZSA0OlRFKG4scykseEUobixzKX1lbHNlIHN3aXRjaChhKHcobixPYSksODgpLm9yZGluYWwpe2Nhc2UgMjpURShuLHMpLGM5KG4scyk7YnJlYWs7Y2FzZSAzOlRFKG4scykseEUobixzKTticmVhaztjYXNlIDQ6eEUobixzKSxURShuLHMpfXIuZG9uZV8xKCl9ZnVuY3Rpb24geGxuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2Zvcih5PW5ldyBUKGUpO3kuaTx5LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKG09YShDKHkpLDEwKSxCYyhtLnBvcyksQmMobS5zaXplXzApLG9qKG0ucGFkZGluZykseEVlKG0pLE5sbihtKSx2PW5ldyBUKG0ucG9ydHMpO3YuaTx2LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKEU9YShDKHYpLDEyKSxCYyhFLnBvcyksQmMoRS5hbmNob3IpLEJjKEUuc2l6ZV8wKSxYcihFLFBFZShFLnNpZGUpKSxpPWEodyhFLChvZSgpLFdjKSksMTcpLGkmJmooRSxXYyxKKC1pLnZhbHVlXzApKSxvPW5ldyBUKEUub3V0Z29pbmdFZGdlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IodD1hKEMobyksMTgpLHI9ZG4odC5iZW5kUG9pbnRzLDApO3IuY3VycmVudE5vZGUhPXIudGhpcyQwMS50YWlsOyluPWEodW4ociksOCksQmMobik7aWYoYz1hKHcodCxpbyksNzUpLGMpZm9yKHU9ZG4oYywwKTt1LmN1cnJlbnROb2RlIT11LnRoaXMkMDEudGFpbDspcz1hKHVuKHUpLDgpLEJjKHMpO2ZvcihmPW5ldyBUKHQubGFiZWxzKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspXz1hKEMoZiksNzIpLEJjKF8ucG9zKSxCYyhfLnNpemVfMCl9Zm9yKGg9bmV3IFQoRS5sYWJlbHMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhoKSw3MiksQmMoXy5wb3MpLEJjKF8uc2l6ZV8wKX1mb3IobS50eXBlXzA9PShXZSgpLEZyKSYmKGoobSwoSygpLERvKSxQRWUoYSh3KG0sRG8pLDY0KSkpLFBsbihtKSksZD1uZXcgVChtLmxhYmVscyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDcyKSx4RWUoXyksQmMoXy5zaXplXzApLEJjKF8ucG9zKX19ZnVuY3Rpb24gQmMoZSl7dmFyIG47bj1lLnhfMCxlLnhfMD1lLnlfMCxlLnlfMD1ufWZ1bmN0aW9uIG9qKGUpe3ZhciBuLHIsdCxvO289ZS50b3BfMCxuPWUuYm90dG9tLHI9ZS5sZWZ0LHQ9ZS5yaWdodCxlLnRvcF8wPXIsZS5ib3R0b209dCxlLmxlZnQ9byxlLnJpZ2h0PW59ZnVuY3Rpb24geEUoZSxuKXt2YXIgcjt4bG4obikscj1hKHcoZSwob2UoKSxTUCkpLDI4MyksciYmaihlLFNQLHQxbihyKSksQmMoZS5vZmZzZXQpLEJjKGUuc2l6ZV8wKSxvaihlLnBhZGRpbmcpLG9qKGEodyhlLElQKSwyMTQpKX1mdW5jdGlvbiBQbG4oZSl7dmFyIG4scjtyPWEodyhlLChvZSgpLEVpKSksMTcxKSxuPWEodyhlLChLKCksQl8pKSwzMTEpLHI9PShybCgpLEYwKT8oaihlLEVpLE8zKSxqKGUsQl8sKGxjKCksSnApKSk6cj09eGY/KGooZSxFaSxPMyksaihlLEJfLChsYygpLEdoKSkpOm49PShsYygpLEpwKT8oaihlLEVpLEYwKSxqKGUsQl8sUDMpKTpuPT1HaCYmKGooZSxFaSx4ZiksaihlLEJfLFAzKSl9ZnVuY3Rpb24geEVlKGUpe3ZhciBuLHIsdDtfcihlLChvZSgpLGVkKSkmJih0PWEodyhlLGVkKSwyMSksIXQuaXNFbXB0eSgpJiYocj0obj1hKGlzKFl0KSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKSx0LmNvbnRhaW5zKChxZigpLEZhKSk/TWwocixGYSk6TWwocixKbCksdC5jb250YWlucyhDbCl8fE1sKHIsQ2wpLHQuY29udGFpbnMoS2wpP01sKHIsWmwpOnQuY29udGFpbnMoZ2MpP01sKHIsR3UpOnQuY29udGFpbnMoWGwpJiZNbChyLFRsKSx0LmNvbnRhaW5zKFpsKT9NbChyLEtsKTp0LmNvbnRhaW5zKEd1KT9NbChyLGdjKTp0LmNvbnRhaW5zKFRsKSYmTWwocixYbCksaihlLGVkLHIpKSl9ZnVuY3Rpb24gUEVlKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMTpyZXR1cm4gcmUoKSxqZTtjYXNlIDQ6cmV0dXJuIHJlKCksVWU7Y2FzZSAzOnJldHVybiByZSgpLHFlO2Nhc2UgMjpyZXR1cm4gcmUoKSxsbjtkZWZhdWx0OnJldHVybiByZSgpLE9vfX1mdW5jdGlvbiBObG4oZSl7dmFyIG4scix0O3N3aXRjaChuPWEodyhlLChvZSgpLG93KSksOCksaihlLG93LG5ldyBZKG4ueV8wLG4ueF8wKSksYSh3KGUsX3UpLDI1NSkub3JkaW5hbCl7Y2FzZSAxOmooZSxfdSwoJHUoKSxlQSkpO2JyZWFrO2Nhc2UgMjpqKGUsX3UsKCR1KCksWk4pKTticmVhaztjYXNlIDM6aihlLF91LCgkdSgpLFRUKSk7YnJlYWs7Y2FzZSA0OmooZSxfdSwoJHUoKSxiVCkpfShlLnByb3BlcnR5TWFwP2UucHJvcGVydHlNYXA6KE5lKCksTmUoKSxrdSkpLmNvbnRhaW5zS2V5KE9mKSYmKHI9YSh3KGUsT2YpLDgpLHQ9ci54XzAsci54XzA9ci55XzAsci55XzA9dCl9ZnVuY3Rpb24gaWooZSl7dGhpcy5tb2RlPWV9cCg4MDMsMSxzcixpaiksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7SWxuKHRoaXMsYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkdyYXBoVHJhbnNmb3JtZXIiLDgwMyk7ZnVuY3Rpb24gRnkoKXtGeT1GLHAzPW5ldyBhaigiVE9fSU5URVJOQUxfTFRSIiwwKSxfOT1uZXcgYWooIlRPX0lOUFVUX0RJUkVDVElPTiIsMSl9ZnVuY3Rpb24gYWooZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBBbG4oZSl7cmV0dXJuIEZ5KCksd24oKEFFZSgpLExFZSksZSl9ZnVuY3Rpb24gTGxuKCl7cmV0dXJuIEZ5KCksUChJKE5FZSwxKSxXLDUxNywwLFtwMyxfOV0pfXAoNTE3LDIyLHszOjEsMzQ6MSwyMjoxLDUxNzoxfSxhaik7dmFyIF85LHAzLE5FZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkdyYXBoVHJhbnNmb3JtZXIvTW9kZSIsNTE3LGduLExsbixBbG4pO2Z1bmN0aW9uIEFFZSgpe0FFZT1GLExFZT15bigoRnkoKSxQKEkoTkVlLDEpLFcsNTE3LDAsW3AzLF85XSkpKX12YXIgTEVlO2Z1bmN0aW9uIGtsbihlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3Iobz1uZXcgVChuLmxheWVybGVzc05vZGVzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTApLGk9dyh0LChLKCksUW4pKSxMKGksMTIpJiYocz1hKGksMTIpLHU9V3dlKG4sdCxzLnNpemVfMC54XzAscy5zaXplXzAueV8wKSxzLnBvcy54XzA9dS54XzAscy5wb3MueV8wPXUueV8wLFhyKHMsYSh3KHQsRG8pLDY0KSkpO3I9bmV3IFkobi5zaXplXzAueF8wK24ucGFkZGluZy5sZWZ0K24ucGFkZGluZy5yaWdodCxuLnNpemVfMC55XzArbi5wYWRkaW5nLnRvcF8wK24ucGFkZGluZy5ib3R0b20pLGEodyhuLChLKCksaWkpKSwyMSkuY29udGFpbnMoKFZ0KCksbmwpKT8oaihlLChvZSgpLHhyKSwoZHQoKSxhaSkpLGEodyhTdChlKSxpaSksMjEpLmFkZF8yKG53KSxWd2UoZSxyLCExKSk6VndlKGUsciwhMCl9ZnVuY3Rpb24gT2xuKGUsbil7dmFyIHIsdCxvLGk7Zm9yKG4uYmVnaW4oIlJlc2l6ZSBjaGlsZCBncmFwaCB0byBmaXQgcGFyZW50LiIsMSksdD1uZXcgVChlLmxheWVycyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDMwKSxxcihlLmxheWVybGVzc05vZGVzLHIubm9kZXMpLHIubm9kZXMuYXJyYXkubGVuZ3RoPTA7Zm9yKGk9bmV3IFQoZS5sYXllcmxlc3NOb2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEwKSxodChvLG51bGwpO2UubGF5ZXJzLmFycmF5Lmxlbmd0aD0wLE1sbihlKSxlLnBhcmVudE5vZGUmJmtsbihlLnBhcmVudE5vZGUsZSksbi5kb25lXzEoKX1mdW5jdGlvbiBNbG4oZSl7dmFyIG4scix0LG8saTtvPWEodyhlLChvZSgpLGpfKSksMjEpLGk9YSh3KGUsUFApLDIxKSxyPW5ldyBZKGUuc2l6ZV8wLnhfMCtlLnBhZGRpbmcubGVmdCtlLnBhZGRpbmcucmlnaHQsZS5zaXplXzAueV8wK2UucGFkZGluZy50b3BfMCtlLnBhZGRpbmcuYm90dG9tKSxuPW5ldyBSdChyKSxvLmNvbnRhaW5zKChTYSgpLFlmKSkmJih0PWEodyhlLG93KSw4KSxpLmNvbnRhaW5zKChnYSgpLEx3KSkmJih0LnhfMDw9MCYmKHQueF8wPTIwKSx0LnlfMDw9MCYmKHQueV8wPTIwKSksbi54XzA9Uy5NYXRoLm1heChyLnhfMCx0LnhfMCksbi55XzA9Uy5NYXRoLm1heChyLnlfMCx0LnlfMCkpLFJsbihlLHIsbil9ZnVuY3Rpb24gUmxuKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKHQ9YSh3KGUsKG9lKCkseU8pKSwyMSksci54XzA+bi54XzAmJih0LmNvbnRhaW5zKChlMSgpLEd2KSk/ZS5vZmZzZXQueF8wKz0oci54XzAtbi54XzApLzI6dC5jb250YWlucyhIdikmJihlLm9mZnNldC54XzArPXIueF8wLW4ueF8wKSksci55XzA+bi55XzAmJih0LmNvbnRhaW5zKChlMSgpLFd2KSk/ZS5vZmZzZXQueV8wKz0oci55XzAtbi55XzApLzI6dC5jb250YWlucyhVdikmJihlLm9mZnNldC55XzArPXIueV8wLW4ueV8wKSksYSh3KGUsKEsoKSxpaSkpLDIxKS5jb250YWlucygoVnQoKSxubCkpJiYoci54XzA+bi54XzB8fHIueV8wPm4ueV8wKSlmb3Iocz1uZXcgVChlLmxheWVybGVzc05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTApLGkudHlwZV8wPT0oV2UoKSxGcikmJihvPWEodyhpLERvKSw2NCksbz09KHJlKCkscWUpP2kucG9zLnhfMCs9ci54XzAtbi54XzA6bz09bG4mJihpLnBvcy55XzArPXIueV8wLW4ueV8wKSk7dT1lLnBhZGRpbmcsZS5zaXplXzAueF8wPXIueF8wLXUubGVmdC11LnJpZ2h0LGUuc2l6ZV8wLnlfMD1yLnlfMC11LnRvcF8wLXUuYm90dG9tfWZ1bmN0aW9uIGtFZSgpe31wKDE1NzUsMSxzcixrRWUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe09sbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGllcmFyY2hpY2FsTm9kZVJlc2l6aW5nUHJvY2Vzc29yIiwxNTc1KTtmdW5jdGlvbiBPRWUoZSxuKXt2YXIgcix0LG87cmV0dXJuIHQ9bmV3IGFjKGUpLGdvKHQsbiksaih0LChLKCksZlApLG4pLGoodCwob2UoKSx4ciksKGR0KCksYWkpKSxqKHQsX3UsKCR1KCksUU4pKSx6Xyh0LChXZSgpLEZyKSkscj1uZXcgWm8sTG8ocix0KSxYcihyLChyZSgpLGplKSksbz1uZXcgWm8sTG8obyx0KSxYcihvLHFlKSx0fWZ1bmN0aW9uIGxqKGUpe3ZhciBuLHI7cmV0dXJuIG49ZS50eXBlXzAsbj09KFdlKCksRnIpPyhyPWEodyhlLChLKCksRG8pKSw2NCkscj09KHJlKCksVWUpfHxyPT1sbik6ITF9ZnVuY3Rpb24gRGxuKGUsbil7bi5iZWdpbigiSGllcmFyY2hpY2FsIHBvcnQgY29uc3RyYWludCBwcm9jZXNzaW5nIiwxKSxGbG4oZSksemxuKGUpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gRmxuKGUpe3ZhciBuO19tKGEodyhlLChvZSgpLHhyKSksMTAxKSkmJihuPWUubGF5ZXJzLE1FZSgoQWUoMCxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5WzBdLDMwKSkpLE1FZShhKGxlKG4sbi5hcnJheS5sZW5ndGgtMSksMzApKSl9ZnVuY3Rpb24gTUVlKGUpe3ZhciBuLHIsdCxvLGkscyx1O2Zvcih1PWMzKGUubm9kZXMpLEZCKHUsbmV3IERFZSkscj1udWxsLG89dSxpPTAscz1vLmxlbmd0aDtpPHMmJih0PW9baV0sdC50eXBlXzA9PShXZSgpLEZyKSk7KytpKW49YSh3KHQsKEsoKSxEbykpLDY0KSwhKG4hPShyZSgpLGplKSYmbiE9cWUpJiYociYmYSh3KHIsV2gpLDE1KS5hZGRfMih0KSxyPXQpfWZ1bmN0aW9uIHpsbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZSxGZSxubjtpZihuZT1hKHcoZSwob2UoKSx4cikpLDEwMSksbmUhPShkdCgpLEhzKSYmbmUhPXEwKXtmb3IoeT1lLmxheWVycyxtPXkuYXJyYXkubGVuZ3RoLGQ9bmV3IF9pKChQYShtKzIsImFycmF5U2l6ZSIpLGJJKE50KE50KDUsbSsyKSwobSsyKS8xMHwwKSkpKSxFPW5ldyBfaSgoUGEobSsyLCJhcnJheVNpemUiKSxiSShOdChOdCg1LG0rMiksKG0rMikvMTB8MCkpKSksZWUoZCxuZXcgc24pLGVlKGQsbmV3IHNuKSxlZShFLG5ldyBRKSxlZShFLG5ldyBRKSxxPW5ldyBRLG49MDtuPG07bisrKWZvcihyPShBZShuLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbbl0sMzApKSx2ZT0oQWUobixkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W25dLDg1KSksdj1uZXcgc24sUmUoZC5hcnJheSx2KSxEZT0oQWUobixFLmFycmF5Lmxlbmd0aCksYShFLmFycmF5W25dLDE1KSksQT1uZXcgUSxSZShFLmFycmF5LEEpLG89bmV3IFQoci5ub2Rlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtpZih0PWEoQyhvKSwxMCksbGoodCkpe1JlKHEuYXJyYXksdCk7Y29udGludWV9Zm9yKF89bmV3IFhlKFFlKHR0KHQpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihfKTspdT1hKHRuKF8pLDE4KSxGZT11LnNvdXJjZS5vd25lcixsaihGZSkmJih3ZT1hKHZlLmdldF8zKHcoRmUsKEsoKSxRbikpKSwxMCksd2V8fCh3ZT1PRWUoZSxGZSksdmUucHV0KHcoRmUsUW4pLHdlKSxEZS5hZGRfMih3ZSkpLEx0KHUsYShsZSh3ZS5wb3J0cywxKSwxMikpKTtmb3IoYz1uZXcgWGUoUWUoUnIodCkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGMpOyl1PWEodG4oYyksMTgpLG5uPXUudGFyZ2V0Lm93bmVyLGxqKG5uKSYmKHg9YShLZSh2LHcobm4sKEsoKSxRbikpKSwxMCkseHx8KHg9T0VlKGUsbm4pLEJuKHYsdyhubixRbikseCksUmUoQS5hcnJheSx4KSksX3QodSxhKGxlKHgucG9ydHMsMCksMTIpKSl9Zm9yKGY9MDtmPEUuYXJyYXkubGVuZ3RoO2YrKylpZihrPShBZShmLEUuYXJyYXkubGVuZ3RoKSxhKEUuYXJyYXlbZl0sMTUpKSwhay5pc0VtcHR5KCkpZm9yKGg9bnVsbCxmPT0wPyhoPW5ldyBvaShlKSxkZigwLHkuYXJyYXkubGVuZ3RoKSxvRSh5LmFycmF5LDAsaCkpOmY9PWQuYXJyYXkubGVuZ3RoLTE/KGg9bmV3IG9pKGUpLFJlKHkuYXJyYXksaCkpOmg9KEFlKGYtMSx5LmFycmF5Lmxlbmd0aCksYSh5LmFycmF5W2YtMV0sMzApKSxzPWsuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDEwKSxodChpLGgpO2ZvcihIPW5ldyBUKHEpO0guaTxILnRoaXMkMDEuYXJyYXkubGVuZ3RoOylNPWEoQyhIKSwxMCksaHQoTSxudWxsKTtqKGUsKEsoKSxzTykscSl9fWZ1bmN0aW9uIFJFZSgpe31wKDE1NzYsMSxzcixSRWUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0RsbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGllcmFyY2hpY2FsUG9ydENvbnN0cmFpbnRQcm9jZXNzb3IiLDE1NzYpO2Z1bmN0aW9uICRsbihlLG4pe3ZhciByLHQsbyxpO3JldHVybiBvPWUudHlwZV8wLHI9UigkKHcoZSwoSygpLEoxKSkpKSxpPW4udHlwZV8wLHQ9UigkKHcobixKMSkpKSxpIT0oV2UoKSxGcik/LTE6byE9RnI/MTpyPT10PzA6cjx0Py0xOjF9ZnVuY3Rpb24gREVlKCl7fXAoMTU3NywxLE5uLERFZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gJGxuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkhpZXJhcmNoaWNhbFBvcnRDb25zdHJhaW50UHJvY2Vzc29yL05vZGVDb21wYXJhdG9yIiwxNTc3KTtmdW5jdGlvbiBCbG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKG4uYmVnaW4oIkhpZXJhcmNoaWNhbCBwb3J0IGR1bW15IHNpemUgcHJvY2Vzc2luZyIsMSksYz1uZXcgUSxkPW5ldyBRLHQ9UigkKHcoZSwob2UoKSxyZykpKSkscj10KjIsaT1uZXcgVChlLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iobz1hKEMoaSksMzApLGMuYXJyYXkubGVuZ3RoPTAsZC5hcnJheS5sZW5ndGg9MCx1PW5ldyBUKG8ubm9kZXMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMCkscy50eXBlXzA9PShXZSgpLEZyKSYmKF89YSh3KHMsKEsoKSxEbykpLDY0KSxfPT0ocmUoKSxVZSk/UmUoYy5hcnJheSxzKTpfPT1sbiYmUmUoZC5hcnJheSxzKSk7RkVlKGMsITAsciksRkVlKGQsITEscil9bi5kb25lXzEoKX1mdW5jdGlvbiBGRWUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3IodD0wLGM9cixufHwodD1yKihlLmFycmF5Lmxlbmd0aC0xKSxjKj0tMSksaT1uZXcgVChlKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihvPWEoQyhpKSwxMCksaihvLChvZSgpLF91KSwoJHUoKSxRTikpLG8uc2l6ZV8wLnhfMD10LHU9JGMobywocmUoKSxxZSkpLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxMikscy5wb3MueF8wPXQ7dCs9Y319ZnVuY3Rpb24gekVlKCl7fXAoMTU3OCwxLHNyLHpFZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7QmxuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJIaWVyYXJjaGljYWxQb3J0RHVtbXlTaXplUHJvY2Vzc29yIiwxNTc4KTtmdW5jdGlvbiAkRWUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO2ZvcihfPVIoJCh3KG4sKG9lKCksWEUpKSkpLGM9ZVswXS5wb3MueF8wK2VbMF0uc2l6ZV8wLnhfMCtlWzBdLm1hcmdpbi5yaWdodCtfLHU9MTt1PGUubGVuZ3RoO3UrKyl0PWVbdV0ucG9zLG89ZVt1XS5zaXplXzAscj1lW3VdLm1hcmdpbixpPXQueF8wLXIubGVmdC1jLGk8MCYmKHQueF8wLT1pKSxzPW4uc2l6ZV8wLHMueF8wPVMuTWF0aC5tYXgocy54XzAsdC54XzArby54XzApLGM9dC54XzArby54XzArci5yaWdodCtffWZ1bmN0aW9uIEdsbihlKXt2YXIgbixyLHQsbyxpLHM7aWYobz1hKGxlKGUucG9ydHMsMCksMTIpLG8uaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgrby5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MCllLnBvcy54XzA9MDtlbHNle2ZvcihzPTAsdD1QdShOYShQKEkoeGEsMSksTWUsMjAsMCxbbmV3IER5KG8pLG5ldyBNaChvKV0pKSk7X24odCk7KXI9YSh0bih0KSwxMikscys9ci5vd25lci5wb3MueF8wK3IucG9zLnhfMCtyLmFuY2hvci54XzA7bj1hKHcoZSwob2UoKSxyZCkpLDgpLGk9bj9uLnhfMDowLGUucG9zLnhfMD1zLyhvLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK28ub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgpLWl9fWZ1bmN0aW9uIEJFZShlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZDtmb3IoYz1uZXcgVChlLm5vZGVzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYodT1hKEMoYyksMTApLHUudHlwZV8wPT0oV2UoKSxGcikmJihvPWEodyh1LChLKCksRG8pKSw2NCksbz09KHJlKCkscWUpfHxvPT1qZSkpZm9yKHQ9bmV3IFhlKFFlKGljKHUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSxuPXIuYmVuZFBvaW50cyxuLnNpemVfMCE9MCYmKF89ci5zb3VyY2UsXy5vd25lcj09dSYmKGk9KHJuKG4uc2l6ZV8wIT0wKSxhKG4uaGVhZGVyLm5leHRfMC52YWx1ZV8wLDgpKSxpLnlfMD1rbyhQKEkob3QsMSksWCw4LDAsW18ub3duZXIucG9zLF8ucG9zLF8uYW5jaG9yXSkpLnlfMCksZD1yLnRhcmdldCxkLm93bmVyPT11JiYocz0ocm4obi5zaXplXzAhPTApLGEobi50YWlsLnByZXYudmFsdWVfMCw4KSkscy55XzA9a28oUChJKG90LDEpLFgsOCwwLFtkLm93bmVyLnBvcyxkLnBvcyxkLmFuY2hvcl0pKS55XzApKX1mdW5jdGlvbiBHRWUoZSxuKXt2YXIgcjtlLmFycmF5Lmxlbmd0aCE9MCYmKHI9YShJcyhlLEIoUnUsSWMsMTAsZS5hcnJheS5sZW5ndGgsMCwxKSksMTk5KSxGQihyLG5ldyBqRWUpLCRFZShyLG4pKX1mdW5jdGlvbiBIRWUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3IoaD1yLnBhZGRpbmcsZj1yLm9mZnNldCxpPW5ldyBZKHIuc2l6ZV8wLnhfMCtyLnBhZGRpbmcubGVmdCtyLnBhZGRpbmcucmlnaHQsci5zaXplXzAueV8wK3IucGFkZGluZy50b3BfMCtyLnBhZGRpbmcuYm90dG9tKSxzPWkueV8wLF89bmV3IFQoZS5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHU9YShDKF8pLDEwKSx1LnR5cGVfMD09KFdlKCksRnIpKXtzd2l0Y2godD1hKHcodSwoSygpLERvKSksNjQpLG89YSh3KHUsUVYpLDgpLGQ9dS5wb3MsdC5vcmRpbmFsKXtjYXNlIDI6ZC54XzA9ci5zaXplXzAueF8wK2gucmlnaHQtZi54XzA7YnJlYWs7Y2FzZSA0OmQueF8wPS1mLnhfMC1oLmxlZnR9c3dpdGNoKHk9MCx0Lm9yZGluYWwpe2Nhc2UgMjpjYXNlIDQ6bj09KGR0KCksSHUpPyhtPVIoJCh3KHUsSjEpKSksZC55XzA9aS55XzAqbS1hKHcodSwob2UoKSxyZCkpLDgpLnlfMCx5PWQueV8wK28ueV8wLHk0KHUsITEsITApKTpuPT1haSYmKGQueV8wPVIoJCh3KHUsSjEpKSktYSh3KHUsKG9lKCkscmQpKSw4KS55XzAseT1kLnlfMCtvLnlfMCx5NCh1LCExLCEwKSl9cz1TLk1hdGgubWF4KHMseSl9Zm9yKHIuc2l6ZV8wLnlfMCs9cy1pLnlfMCxjPW5ldyBUKGUubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZih1PWEoQyhjKSwxMCksdS50eXBlXzA9PShXZSgpLEZyKSlzd2l0Y2godD1hKHcodSwoSygpLERvKSksNjQpLGQ9dS5wb3MsdC5vcmRpbmFsKXtjYXNlIDE6ZC55XzA9LWYueV8wLWgudG9wXzA7YnJlYWs7Y2FzZSAzOmQueV8wPXIuc2l6ZV8wLnlfMCtoLmJvdHRvbS1mLnlfMH19ZnVuY3Rpb24gSGxuKGUsbixyKXt2YXIgdCxvLGkscztyLmJlZ2luKCJPcnRob2dvbmFsbHkgcm91dGluZyBoaWVyYXJjaGljYWwgcG9ydCBlZGdlcyIsMSksZS5ub3J0aGVybkV4dFBvcnRFZGdlUm91dGluZ0hlaWdodD0wLHQ9amxuKG4pLHFsbihuLHQpLFZsbihlLG4sdCksVWxuKG4pLG89YSh3KG4sKG9lKCkseHIpKSwxMDEpLGk9bi5sYXllcnMsSEVlKChBZSgwLGkuYXJyYXkubGVuZ3RoKSxhKGkuYXJyYXlbMF0sMzApKSxvLG4pLEhFZShhKGxlKGksaS5hcnJheS5sZW5ndGgtMSksMzApLG8sbikscz1uLmxheWVycyxCRWUoKEFlKDAscy5hcnJheS5sZW5ndGgpLGEocy5hcnJheVswXSwzMCkpKSxCRWUoYShsZShzLHMuYXJyYXkubGVuZ3RoLTEpLDMwKSksci5kb25lXzEoKX1mdW5jdGlvbiBVbG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmU7Zm9yKHE9bmV3IFEseT1uZXcgVChlLmxheWVycyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihtPWEoQyh5KSwzMCkseD1uZXcgVChtLm5vZGVzKTt4Lmk8eC50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoRT1hKEMoeCksMTApLEUudHlwZV8wPT0oV2UoKSxGcikmJl9yKEUsKEsoKSxmUCkpKXtmb3IoQT1udWxsLE09bnVsbCxrPW51bGwsd2U9bmV3IFQoRS5wb3J0cyk7d2UuaTx3ZS50aGlzJDAxLmFycmF5Lmxlbmd0aDspc3dpdGNoKHZlPWEoQyh3ZSksMTIpLHZlLnNpZGUub3JkaW5hbCl7Y2FzZSA0OkE9dmU7YnJlYWs7Y2FzZSAyOk09dmU7YnJlYWs7ZGVmYXVsdDprPXZlfWZvcihIPWEobGUoay5vdXRnb2luZ0VkZ2VzLDApLDE4KSxkPW5ldyBKTihILmJlbmRQb2ludHMpLF89bmV3IFJ0KGsucG9zKSxLbihfLEUucG9zKSxmPWRuKGQsMCksUkMoZixfKSxuZT1DVChILmJlbmRQb2ludHMpLGg9bmV3IFJ0KGsucG9zKSxLbihoLEUucG9zKSxicihuZSxoLG5lLnRhaWwucHJldixuZS50YWlsKSxEZT1hKHcoRSxmUCksMTApLEZlPWEobGUoRGUucG9ydHMsMCksMTIpLGM9YShJcyhBLmluY29taW5nRWRnZXMsQihuOSxmNiwxOCwwLDAsMSkpLDQ4MyksdD1jLGk9MCx1PXQubGVuZ3RoO2k8dTsrK2kpbj10W2ldLF90KG4sRmUpLEpNKG4uYmVuZFBvaW50cyxuLmJlbmRQb2ludHMuc2l6ZV8wLGQpO2ZvcihjPWN1KE0ub3V0Z29pbmdFZGdlcykscj1jLG89MCxzPXIubGVuZ3RoO288czsrK28pbj1yW29dLEx0KG4sRmUpLEpNKG4uYmVuZFBvaW50cywwLG5lKTtMdChILG51bGwpLF90KEgsbnVsbCksUmUocS5hcnJheSxFKX1mb3Iodj1uZXcgVChxKTt2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aDspRT1hKEModiksMTApLGh0KEUsbnVsbCl9ZnVuY3Rpb24gV2xuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGY7aWYoZD1hKHcoZSwoSygpLERvKSksNjQpLHQ9YShsZShlLnBvcnRzLDApLDEyKSxkPT0ocmUoKSxVZSk/WHIodCxsbik6ZD09bG4mJlhyKHQsVWUpLGEodyhuLChvZSgpLGpfKSksMTgxKS5jb250YWlucygoU2EoKSxpMSkpKXtpZihjPVIoJCh3KGUsc3cpKSksXz1SKCQodyhlLHV3KSkpLHM9UigkKHcoZSxNZikpKSx1PWEodyhuLGtmKSwyMSksdS5jb250YWlucygoYWEoKSxoYykpKWZvcihyPV8sZj1lLnNpemVfMC54XzAvMi10LnBvcy54XzAsaT1uZXcgVCh0LmxhYmVscyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDcyKSxvLnBvcy55XzA9cixvLnBvcy54XzA9Zi1vLnNpemVfMC54XzAvMixyKz1vLnNpemVfMC55XzArcztlbHNlIGlmKHUuY29udGFpbnMoWTApKWZvcihpPW5ldyBUKHQubGFiZWxzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksNzIpLG8ucG9zLnhfMD1jK2Uuc2l6ZV8wLnhfMC10LnBvcy54XzA7Tm5uKG5ldyBPeCgod0UoKSxuZXcgcjkobiwhMSwhMSxuZXcgeFcpKSksbmV3IHA0KG51bGwsZSwhMSkpfX1mdW5jdGlvbiBqbG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG07aWYoXz1uZXcgUSwhX3IoZSwoSygpLHNPKSkpcmV0dXJuIF87Zm9yKHQ9YSh3KGUsc08pLDE1KS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspbj1hKHQubmV4dF8xKCksMTApLFdsbihuLGUpLFJlKF8uYXJyYXksbik7Zm9yKGk9bmV3IFQoZS5sYXllcnMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksMzApLHU9bmV3IFQoby5ub2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDEwKSxzLnR5cGVfMD09KFdlKCksRnIpJiYoYz1hKHcocyxmUCksMTApLGMmJihkPW5ldyBabyxMbyhkLHMpLGY9YSh3KHMsRG8pLDY0KSxYcihkLGYpLGg9YShsZShjLnBvcnRzLDApLDEyKSxtPW5ldyBIMSxMdChtLGQpLF90KG0saCkpKTtmb3Iocj1uZXcgVChfKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTApLGh0KG4sYShsZShlLmxheWVycyxlLmxheWVycy5hcnJheS5sZW5ndGgtMSksMzApKTtyZXR1cm4gX31mdW5jdGlvbiBVRWUoZSxuKXt2YXIgcjtlLmFycmF5Lmxlbmd0aCE9MCYmKHI9YShJcyhlLEIoUnUsSWMsMTAsZS5hcnJheS5sZW5ndGgsMCwxKSksMTk5KSxGQihyLG5ldyBWRWUpLCRFZShyLG4pKX1mdW5jdGlvbiBWbG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2ZvcihfPW5ldyBsdSxkPW5ldyBsdSx5PW5ldyBsdSxFPW5ldyBsdSxjPVIoJCh3KG4sKG9lKCksb2QpKSkpLGk9UigkKHcobixxbCkpKSx1PW5ldyBUKHIpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihzPWEoQyh1KSwxMCksZj1hKHcocywoSygpLERvKSksNjQpLGY9PShyZSgpLFVlKSlmb3IoZC5tYXBfMC5wdXQocyxkKSxvPW5ldyBYZShRZSh0dChzKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSwxOCksWXIoXyx0LnNvdXJjZS5vd25lcik7ZWxzZSBpZihmPT1sbilmb3IoRS5tYXBfMC5wdXQocyxFKSxvPW5ldyBYZShRZSh0dChzKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSwxOCksWXIoeSx0LnNvdXJjZS5vd25lcik7Xy5tYXBfMC5zaXplXzEoKSE9MCYmKGg9bmV3IGI3KDIsaSksbT1ZSyhoLG4sXyxkLC1jLW4ub2Zmc2V0LnlfMCksbT4wJiYoZS5ub3J0aGVybkV4dFBvcnRFZGdlUm91dGluZ0hlaWdodD1jKyhtLTEpKmksbi5vZmZzZXQueV8wKz1lLm5vcnRoZXJuRXh0UG9ydEVkZ2VSb3V0aW5nSGVpZ2h0LG4uc2l6ZV8wLnlfMCs9ZS5ub3J0aGVybkV4dFBvcnRFZGdlUm91dGluZ0hlaWdodCkpLHkubWFwXzAuc2l6ZV8xKCkhPTAmJihoPW5ldyBiNygxLGkpLG09WUsoaCxuLHksRSxuLnNpemVfMC55XzArYy1uLm9mZnNldC55XzApLG0+MCYmKG4uc2l6ZV8wLnlfMCs9YysobS0xKSppKSl9ZnVuY3Rpb24gcWxuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3Iocj1hKHcoZSwob2UoKSx4cikpLDEwMSkscz1lLnNpemVfMCxpPWUucGFkZGluZyx1PXMueF8wK2kubGVmdCtpLnJpZ2h0LGM9MC1pLnRvcF8wLWUub2Zmc2V0LnlfMCxkPXMueV8wK2kudG9wXzAraS5ib3R0b20tZS5vZmZzZXQueV8wLF89bmV3IFEsZj1uZXcgUSxvPW5ldyBUKG4pO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7c3dpdGNoKHQ9YShDKG8pLDEwKSxyLm9yZGluYWwpe2Nhc2UgMTpjYXNlIDI6Y2FzZSAzOkdsbih0KTticmVhaztjYXNlIDQ6aD1hKHcodCxyZCksOCksbT1oP2gueF8wOjAsdC5wb3MueF8wPXUqUigkKHcodCwoSygpLEoxKSkpKS1tLHk0KHQsITAsITEpO2JyZWFrO2Nhc2UgNTp5PWEodyh0LHJkKSw4KSxFPXk/eS54XzA6MCx0LnBvcy54XzA9UigkKHcodCwoSygpLEoxKSkpKS1FLHk0KHQsITAsITEpLHMueF8wPVMuTWF0aC5tYXgocy54XzAsdC5wb3MueF8wK3Quc2l6ZV8wLnhfMC8yKX1zd2l0Y2goYSh3KHQsKEsoKSxEbykpLDY0KS5vcmRpbmFsKXtjYXNlIDE6dC5wb3MueV8wPWMsUmUoXy5hcnJheSx0KTticmVhaztjYXNlIDM6dC5wb3MueV8wPWQsUmUoZi5hcnJheSx0KX19c3dpdGNoKHIub3JkaW5hbCl7Y2FzZSAxOmNhc2UgMjpHRWUoXyxlKSxHRWUoZixlKTticmVhaztjYXNlIDM6VUVlKF8sZSksVUVlKGYsZSl9fWZ1bmN0aW9uIFdFZSgpe31wKDE1NzksMSxzcixXRWUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0hsbih0aGlzLGEobiwzNikscil9LGwubm9ydGhlcm5FeHRQb3J0RWRnZVJvdXRpbmdIZWlnaHQ9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGllcmFyY2hpY2FsUG9ydE9ydGhvZ29uYWxFZGdlUm91dGVyIiwxNTc5KTtmdW5jdGlvbiBZbG4oZSxuKXtyZXR1cm4gaXIoZS5wb3MueF8wLG4ucG9zLnhfMCl9ZnVuY3Rpb24gakVlKCl7fXAoMTU4MCwxLE5uLGpFZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gWWxuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkhpZXJhcmNoaWNhbFBvcnRPcnRob2dvbmFsRWRnZVJvdXRlci8xIiwxNTgwKTtmdW5jdGlvbiBLbG4oZSxuKXtyZXR1cm4gaXIoUigkKHcoZSwoSygpLEoxKSkpKSxSKCQodyhuLEoxKSkpKX1mdW5jdGlvbiBWRWUoKXt9cCgxNTgxLDEsTm4sVkVlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBLbG4oYShuLDEwKSxhKHIsMTApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGllcmFyY2hpY2FsUG9ydE9ydGhvZ29uYWxFZGdlUm91dGVyLzIiLDE1ODEpO2Z1bmN0aW9uIHFFZShlLG4pe3ZhciByLHQsbyxpLHMsdTtpZih1PWEodyhuLChvZSgpLHhyKSksMTAxKSx1PT0oZHQoKSxIdSl8fHU9PWFpKWZvcihvPW5ldyBZKG4uc2l6ZV8wLnhfMCtuLnBhZGRpbmcubGVmdCtuLnBhZGRpbmcucmlnaHQsbi5zaXplXzAueV8wK24ucGFkZGluZy50b3BfMCtuLnBhZGRpbmcuYm90dG9tKS55XzAscz1uZXcgVChlLm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTApLGkudHlwZV8wPT0oV2UoKSxGcikmJihyPWEodyhpLChLKCksRG8pKSw2NCksIShyIT0ocmUoKSxxZSkmJnIhPWplKSYmKHQ9UigkKHcoaSxKMSkpKSx1PT1IdSYmKHQqPW8pLGkucG9zLnlfMD10LWEodyhpLHJkKSw4KS55XzAseTQoaSwhMSwhMCkpKX1mdW5jdGlvbiBYbG4oZSxuKXt2YXIgcjtuLmJlZ2luKCJIaWVyYXJjaGljYWwgcG9ydCBwb3NpdGlvbiBwcm9jZXNzaW5nIiwxKSxyPWUubGF5ZXJzLHIuYXJyYXkubGVuZ3RoPjAmJnFFZSgoQWUoMCxyLmFycmF5Lmxlbmd0aCksYShyLmFycmF5WzBdLDMwKSksZSksci5hcnJheS5sZW5ndGg+MSYmcUVlKGEobGUocixyLmFycmF5Lmxlbmd0aC0xKSwzMCksZSksbi5kb25lXzEoKX1mdW5jdGlvbiBZRWUoKXt9cCgxNTgyLDEsc3IsWUVlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtYbG4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkhpZXJhcmNoaWNhbFBvcnRQb3NpdGlvblByb2Nlc3NvciIsMTU4Mik7ZnVuY3Rpb24gZzMoKXtnMz1GLHY0PW5ldyBKRWUsUzQ9bmV3IFpFZX1mdW5jdGlvbiBKbG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO2ZvcihyPW5ldyBYRWUsbz1uZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKG8pOylpZih0PWEodG4obyksMTgpLCF6dCh0KSYmKHU9dC5zb3VyY2Uub3duZXIsc2oodSxTNCkpKXtpZihfPXVqKGUsdSxTNCx2NCksXz09LTEpY29udGludWU7ci5pbmNUcmVlc01heEhlaWdodD1TLk1hdGgubWF4KHIuaW5jVHJlZXNNYXhIZWlnaHQsXyksIXIuaW5jVHJlZVJvb3RzJiYoci5pbmNUcmVlUm9vdHM9bmV3IFEpLGVlKHIuaW5jVHJlZVJvb3RzLHUpfWZvcihzPW5ldyBYZShRZShScihuKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocyk7KWlmKGk9YSh0bihzKSwxOCksIXp0KGkpJiYoYz1pLnRhcmdldC5vd25lcixzaihjLHY0KSkpe2lmKF89dWooZSxjLHY0LFM0KSxfPT0tMSljb250aW51ZTtyLm91dFRyZWVzTWF4SGVpZ2h0PVMuTWF0aC5tYXgoci5vdXRUcmVlc01heEhlaWdodCxfKSwhci5vdXRUcmVlUm9vdHMmJihyLm91dFRyZWVSb290cz1uZXcgUSksZWUoci5vdXRUcmVlUm9vdHMsYyl9cmV0dXJuIHJ9ZnVuY3Rpb24gc2ooZSxuKXt2YXIgcix0LG87Zm9yKHI9bnVsbCxvPWEobi5hcHBseV8wKGUpLDIwKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspaWYodD1hKG8ubmV4dF8xKCksMTgpLCFyKXI9dC5zb3VyY2Uub3duZXI9PWU/dC50YXJnZXQub3duZXI6dC5zb3VyY2Uub3duZXI7ZWxzZSBpZigodC5zb3VyY2Uub3duZXI9PWU/dC50YXJnZXQub3duZXI6dC5zb3VyY2Uub3duZXIpIT1yKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIHVqKGUsbixyLHQpe3ZhciBvLGkscyx1LGM7aWYoWnUoKGczKCksbmV3IFhlKFFlKGljKG4pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpPj1lLmRlZ3JlZVRocmVzaG9sZHx8IXNqKG4scikpcmV0dXJuLTE7aWYoSm0oYSh0LmFwcGx5XzAobiksMjApKSlyZXR1cm4gMTtmb3Iobz0wLHM9YSh0LmFwcGx5XzAobiksMjApLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylpZihpPWEocy5uZXh0XzEoKSwxOCksYz1pLnNvdXJjZS5vd25lcj09bj9pLnRhcmdldC5vd25lcjppLnNvdXJjZS5vd25lcix1PXVqKGUsYyxyLHQpLHU9PS0xfHwobz1TLk1hdGgubWF4KG8sdSksbz5lLnRyZWVIZWlnaHRUaHJlc2hvbGQtMSkpcmV0dXJuLTE7cmV0dXJuIG8rMX1mdW5jdGlvbiBjaihlLG4scix0KXt2YXIgbyxpLHMsdTtmb3IoaHQobixhKHQuZ2V0XzAoMCksMzApKSx1PXQuc3ViTGlzdCgxLHQuc2l6ZV8xKCkpLGk9YShyLmFwcGx5XzAobiksMjApLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSwxOCkscz1vLnNvdXJjZS5vd25lcj09bj9vLnRhcmdldC5vd25lcjpvLnNvdXJjZS5vd25lcixjaihlLHMscix1KX1mdW5jdGlvbiBabG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGU7Zm9yKGUubGF5ZXJlZEdyYXBoPW4sZS5kZWdyZWVUaHJlc2hvbGQ9YSh3KG4sKG9lKCksS3EpKSwxNykudmFsdWVfMCxlLnRyZWVIZWlnaHRUaHJlc2hvbGQ9YSh3KG4sSnEpLDE3KS52YWx1ZV8wLGUudHJlZUhlaWdodFRocmVzaG9sZD09MCYmKGUudHJlZUhlaWdodFRocmVzaG9sZD1xbiksdj1uZXcgcHQobi5sYXllcnMsMCk7di5pPHYudGhpcyQwMV8wLnNpemVfMSgpOyl7Zm9yKEU9KHJuKHYuaTx2LnRoaXMkMDFfMC5zaXplXzEoKSksYSh2LnRoaXMkMDFfMC5nZXRfMCh2Lmxhc3Q9di5pKyspLDMwKSksdT1uZXcgUSxkPS0xLE09LTEsaz1uZXcgVChFLm5vZGVzKTtrLmk8ay50aGlzJDAxLmFycmF5Lmxlbmd0aDspQT1hKEMoayksMTApLFp1KChnMygpLG5ldyBYZShRZShpYyhBKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKT49ZS5kZWdyZWVUaHJlc2hvbGQmJih0PUpsbihlLEEpLGQ9Uy5NYXRoLm1heChkLHQuaW5jVHJlZXNNYXhIZWlnaHQpLE09Uy5NYXRoLm1heChNLHQub3V0VHJlZXNNYXhIZWlnaHQpLGVlKHUsbmV3IFpyKEEsdCkpKTtmb3IodmU9bmV3IFEsXz0wO188ZDsrK18pQTEodmUsMCwocm4odi5pPjApLHYudGhpcyQwMS5nZXRfMCh2Lmxhc3Q9LS12LmkpLHdlPW5ldyBvaShlLmxheWVyZWRHcmFwaCkscmYodix3ZSkscm4odi5pPHYudGhpcyQwMV8wLnNpemVfMSgpKSx2LnRoaXMkMDFfMC5nZXRfMCh2Lmxhc3Q9di5pKyspLHdlKSk7Zm9yKHM9bmV3IFQodSk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG89YShDKHMpLDQyKSxtPWEoby5zZWNvbmQsNTgwKS5pbmNUcmVlUm9vdHMsISFtKWZvcihoPW5ldyBUKG0pO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmPWEoQyhoKSwxMCksY2ooZSxmLHY0LHZlKTtmb3Iocj1uZXcgUSxjPTA7YzxNOysrYyllZShyLChEZT1uZXcgb2koZS5sYXllcmVkR3JhcGgpLHJmKHYsRGUpLERlKSk7Zm9yKGk9bmV3IFQodSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG89YShDKGkpLDQyKSxuZT1hKG8uc2Vjb25kLDU4MCkub3V0VHJlZVJvb3RzLCEhbmUpZm9yKHE9bmV3IFQobmUpO3EuaTxxLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylIPWEoQyhxKSwxMCksY2ooZSxILFM0LHIpfWZvcih4PW5ldyBwdChuLmxheWVycywwKTt4Lmk8eC50aGlzJDAxXzAuc2l6ZV8xKCk7KXk9KHJuKHguaTx4LnRoaXMkMDFfMC5zaXplXzEoKSksYSh4LnRoaXMkMDFfMC5nZXRfMCh4Lmxhc3Q9eC5pKyspLDMwKSkseS5ub2Rlcy5hcnJheS5sZW5ndGg9PTAmJkVhKHgpfWZ1bmN0aW9uIEtFZSgpe2czKCl9cCgxNTgzLDEsc3IsS0VlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtabG4odGhpcyxhKG4sMzYpKX0sbC5kZWdyZWVUaHJlc2hvbGQ9MCxsLnRyZWVIZWlnaHRUaHJlc2hvbGQ9MDt2YXIgdjQsUzQ7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkhpZ2hEZWdyZWVOb2RlTGF5ZXJpbmdQcm9jZXNzb3IiLDE1ODMpO2Z1bmN0aW9uIFhFZSgpe31wKDU4MCwxLHs1ODA6MX0sWEVlKSxsLmluY1RyZWVzTWF4SGVpZ2h0PS0xLGwub3V0VHJlZXNNYXhIZWlnaHQ9LTEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkhpZ2hEZWdyZWVOb2RlTGF5ZXJpbmdQcm9jZXNzb3IvSGlnaERlZ3JlZU5vZGVJbmZvcm1hdGlvbiIsNTgwKTtmdW5jdGlvbiBKRWUoKXt9cCgxNTg0LDEse30sSkVlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGczKCksdHQoYShuLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGlnaERlZ3JlZU5vZGVMYXllcmluZ1Byb2Nlc3Nvci9sYW1iZGEkMCRUeXBlIiwxNTg0KTtmdW5jdGlvbiBaRWUoKXt9cCgxNTg1LDEse30sWkVlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGczKCksUnIoYShuLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSGlnaERlZ3JlZU5vZGVMYXllcmluZ1Byb2Nlc3Nvci9sYW1iZGEkMSRUeXBlIiwxNTg1KTtmdW5jdGlvbiBRbG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtyZXR1cm4gcj1hZShpZSh3KGUsKEsoKSxJZikpKSksdT1hZShpZSh3KG4sSWYpKSksdD1hKHcoZSxkcyksMTIpLGM9YSh3KG4sZHMpLDEyKSxvPWEodyhlLHZsKSwxMiksXz1hKHcobix2bCksMTIpLGQ9ISF0JiZ0PT1jLGY9ISFvJiZvPT1fLCFyJiYhdT9uZXcgZGooYShDKG5ldyBUKGUucG9ydHMpKSwxMikuaWRfMD09YShDKG5ldyBUKG4ucG9ydHMpKSwxMikuaWRfMCxkLGYpOihpPSghYWUoaWUodyhlLElmKSkpfHxhZShpZSh3KGUsTDMpKSkpJiYoIWFlKGllKHcobixJZikpKXx8YWUoaWUodyhuLEwzKSkpKSxzPSghYWUoaWUodyhlLElmKSkpfHwhYWUoaWUodyhlLEwzKSkpKSYmKCFhZShpZSh3KG4sSWYpKSl8fCFhZShpZSh3KG4sTDMpKSkpLG5ldyBkaihkJiZpfHxmJiZzLGQsZikpfWZ1bmN0aW9uIF9qKGUsbixyKXt2YXIgdCxvLGk7Zm9yKG4uaWRfMD1yLGk9UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsW25ldyBEeShuKSxuZXcgTWgobildKSkpO19uKGkpOyl0PWEodG4oaSksMTIpLHQuaWRfMD09LTEmJl9qKGUsdCxyKTtpZihuLm93bmVyLnR5cGVfMD09KFdlKCksaXQpKWZvcihvPW5ldyBUKG4ub3duZXIucG9ydHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMiksdCE9biYmdC5pZF8wPT0tMSYmX2ooZSx0LHIpfWZ1bmN0aW9uIGVzbihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPWEoVG8oTm8oTm8obmV3IFNlKG51bGwsbmV3IHhlKG4ubGF5ZXJzLDE2KSksbmV3IGV2ZSksbmV3IG52ZSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSksMTUpLGkuZm9yRWFjaF8wKG5ldyBydmUpLHI9MCxvPWkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDEyKSx0LmlkXzA9PS0xJiZfaihlLHQscisrKX1mdW5jdGlvbiBuc24oZSxuLHIsdCl7dmFyIG8saSxzLHU7Zm9yKG89YSgkYyhuLChyZSgpLGplKSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSxpPWEoJGMobixxZSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSx1PW5ldyBUKGUucG9ydHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHM9YShDKHUpLDEyKTtzLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wOylfdChhKGxlKHMuaW5jb21pbmdFZGdlcywwKSwxOCksbyk7Zm9yKDtzLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wOylMdChhKGxlKHMub3V0Z29pbmdFZGdlcywwKSwxOCksaSl9cnx8aihuLChLKCksZHMpLG51bGwpLHR8fGoobiwoSygpLHZsKSxudWxsKX1mdW5jdGlvbiByc24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZjtmb3Ioci5iZWdpbigiSHlwZXJlZGdlIG1lcmdpbmciLDEpLGVzbihlLG4pLGM9bmV3IHB0KG4ubGF5ZXJzLDApO2MuaTxjLnRoaXMkMDFfMC5zaXplXzEoKTspaWYodT0ocm4oYy5pPGMudGhpcyQwMV8wLnNpemVfMSgpKSxhKGMudGhpcyQwMV8wLmdldF8wKGMubGFzdD1jLmkrKyksMzApKSxkPXUubm9kZXMsZC5hcnJheS5sZW5ndGghPTApZm9yKHQ9bnVsbCxvPW51bGwsaT1udWxsLHM9bnVsbCxfPTA7XzxkLmFycmF5Lmxlbmd0aDtfKyspdD0oQWUoXyxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W19dLDEwKSksbz10LnR5cGVfMCxvPT0oV2UoKSxpdCkmJnM9PWl0JiYoZj1RbG4odCxpKSxmLmFsbG93TWVyZ2UmJihuc24odCxpLGYuc2FtZVNvdXJjZSxmLnNhbWVUYXJnZXQpLEFlKF8sZC5hcnJheS5sZW5ndGgpLEtHKGQuYXJyYXksXywxKSwtLV8sdD1pLG89cykpLGk9dCxzPW87ci5kb25lXzEoKX1mdW5jdGlvbiBRRWUoKXt9cCgxNTkxLDEsc3IsUUVlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtyc24odGhpcyxhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSHlwZXJlZGdlRHVtbXlNZXJnZXIiLDE1OTEpO2Z1bmN0aW9uIGRqKGUsbixyKXt0aGlzLmFsbG93TWVyZ2U9ZSx0aGlzLnNhbWVTb3VyY2U9bix0aGlzLnNhbWVUYXJnZXQ9cn1wKDgwNCwxLHt9LGRqKSxsLmFsbG93TWVyZ2U9ITEsbC5zYW1lU291cmNlPSExLGwuc2FtZVRhcmdldD0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSHlwZXJlZGdlRHVtbXlNZXJnZXIvTWVyZ2VTdGF0ZSIsODA0KTtmdW5jdGlvbiBldmUoKXt9cCgxNTkyLDEse30sZXZlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJIeXBlcmVkZ2VEdW1teU1lcmdlci9sYW1iZGEkMCRUeXBlIiwxNTkyKTtmdW5jdGlvbiBudmUoKXt9cCgxNTkzLDEse30sbnZlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMTApLnBvcnRzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJIeXBlcmVkZ2VEdW1teU1lcmdlci9sYW1iZGEkMSRUeXBlIiwxNTkzKTtmdW5jdGlvbiBydmUoKXt9cCgxNTk0LDEsSmUscnZlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXthKG4sMTIpLmlkXzA9LTF9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJIeXBlcmVkZ2VEdW1teU1lcmdlci9sYW1iZGEkMiRUeXBlIiwxNTk0KTtmdW5jdGlvbiB0c24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseDtpZih0PW5ldyBRLG89cW4saT1xbixzPXFuLHIpZm9yKG89ZS5zaXplXzAueF8wLEU9bmV3IFQobi5wb3J0cyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih5PWEoQyhFKSwxMiksYz1uZXcgVCh5Lm91dGdvaW5nRWRnZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxOCksdS5iZW5kUG9pbnRzLnNpemVfMCE9MCYmKGQ9YSh5eSh1LmJlbmRQb2ludHMpLDgpLGQueF8wPG8mJihpPW8tZC54XzAscz1xbix0LmFycmF5Lmxlbmd0aD0wLG89ZC54XzApLGQueF8wPD1vJiYoUmUodC5hcnJheSx1KSx1LmJlbmRQb2ludHMuc2l6ZV8wPjEmJihzPVMuTWF0aC5taW4ocyxTLk1hdGguYWJzKGEoVmEodS5iZW5kUG9pbnRzLDEpLDgpLnlfMC1kLnlfMCkpKSkpO2Vsc2UgZm9yKEU9bmV3IFQobi5wb3J0cyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih5PWEoQyhFKSwxMiksYz1uZXcgVCh5LmluY29taW5nRWRnZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxOCksdS5iZW5kUG9pbnRzLnNpemVfMCE9MCYmKGg9YShSbCh1LmJlbmRQb2ludHMpLDgpLGgueF8wPm8mJihpPWgueF8wLW8scz1xbix0LmFycmF5Lmxlbmd0aD0wLG89aC54XzApLGgueF8wPj1vJiYoUmUodC5hcnJheSx1KSx1LmJlbmRQb2ludHMuc2l6ZV8wPjEmJihzPVMuTWF0aC5taW4ocyxTLk1hdGguYWJzKGEoVmEodS5iZW5kUG9pbnRzLHUuYmVuZFBvaW50cy5zaXplXzAtMiksOCkueV8wLWgueV8wKSkpKSk7aWYodC5hcnJheS5sZW5ndGghPTAmJmk+bi5zaXplXzAueF8wLzImJnM+bi5zaXplXzAueV8wLzIpe2ZvcihtPW5ldyBabyxMbyhtLG4pLFhyKG0sKHJlKCksVWUpKSxtLnBvcy54XzA9bi5zaXplXzAueF8wLzIseD1uZXcgWm8sTG8oeCxuKSxYcih4LGxuKSx4LnBvcy54XzA9bi5zaXplXzAueF8wLzIseC5wb3MueV8wPW4uc2l6ZV8wLnlfMCxjPW5ldyBUKHQpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxOCkscj8oXz1hKG9rKHUuYmVuZFBvaW50cyksOCksdj11LmJlbmRQb2ludHMuc2l6ZV8wPT0wP0FzKHUudGFyZ2V0KTphKHl5KHUuYmVuZFBvaW50cyksOCksdi55XzA+PV8ueV8wP0x0KHUseCk6THQodSxtKSk6KF89YShJUWUodS5iZW5kUG9pbnRzKSw4KSx2PXUuYmVuZFBvaW50cy5zaXplXzA9PTA/QXModS5zb3VyY2UpOmEoUmwodS5iZW5kUG9pbnRzKSw4KSx2LnlfMD49Xy55XzA/X3QodSx4KTpfdCh1LG0pKSxmPWEodyh1LChvZSgpLGlvKSksNzUpLGYmJllkKGYsXywhMCk7bi5wb3MueF8wPW8tbi5zaXplXzAueF8wLzJ9fWZ1bmN0aW9uIG9zbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihuLmJlZ2luKCJIeXBlcm5vZGVzIHByb2Nlc3NpbmciLDEpLG89bmV3IFQoZS5sYXllcnMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksMzApLHU9bmV3IFQodC5ub2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHM9YShDKHUpLDEwKSxhZShpZSh3KHMsKG9lKCksQ1ApKSkpJiZzLnBvcnRzLmFycmF5Lmxlbmd0aDw9Mil7Zm9yKGY9MCxkPTAscj0wLGk9MCxfPW5ldyBUKHMucG9ydHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzd2l0Y2goYz1hKEMoXyksMTIpLGMuc2lkZS5vcmRpbmFsKXtjYXNlIDE6KytmO2JyZWFrO2Nhc2UgMjorK2Q7YnJlYWs7Y2FzZSAzOisrcjticmVhaztjYXNlIDQ6KytpfWY9PTAmJnI9PTAmJnRzbihlLHMsaTw9ZCl9bi5kb25lXzEoKX1mdW5jdGlvbiB0dmUoKXt9cCgxNTk1LDEsc3IsdHZlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtvc24oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkh5cGVybm9kZXNQcm9jZXNzb3IiLDE1OTUpO2Z1bmN0aW9uIGlzbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtmb3Iobi5iZWdpbigiTGF5ZXIgY29uc3RyYWludCBlZGdlIHJldmVyc2FsIiwxKSxzPW5ldyBUKGUubGF5ZXJzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihpPWEoQyhzKSwzMCksZD0tMSxyPW5ldyBRLF89YzMoaS5ub2Rlcyksbz0wO288Xy5sZW5ndGg7bysrKXQ9YSh3KF9bb10sKEsoKSxCXykpLDMxMSksZD09LTE/dCE9KGxjKCksSnApJiYoZD1vKTp0PT0obGMoKSxKcCkmJihodChfW29dLG51bGwpLHdmKF9bb10sZCsrLGkpKSx0PT0obGMoKSxHaCkmJlJlKHIuYXJyYXksX1tvXSk7Zm9yKGM9bmV3IFQocik7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDEwKSxodCh1LG51bGwpLGh0KHUsaSl9bi5kb25lXzEoKX1mdW5jdGlvbiBvdmUoKXt9cCgxNTk2LDEsc3Isb3ZlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtpc24oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkluTGF5ZXJDb25zdHJhaW50UHJvY2Vzc29yIiwxNTk2KTtmdW5jdGlvbiBhc24oZSxuKXtuLmJlZ2luKCJOb2RlIG1hcmdpbiBjYWxjdWxhdGlvbiIsMSksQkgoUG5uKG5ldyBPeCgod0UoKSxuZXcgcjkoZSwhMSwhMSxuZXcgeFcpKSkpKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIGl2ZSgpe31wKDE1OTcsMSxzcixpdmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe2FzbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSW5uZXJtb3N0Tm9kZU1hcmdpbkNhbGN1bGF0b3IiLDE1OTcpO2Z1bmN0aW9uIGF2ZShlKXt2YXIgbixyLHQsbyxpLHMsdTtpZih1PWEobGUoZS5wb3J0cywwKSwxMiksdS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCYmdS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCl0aHJvdyBiKG5ldyBybygiSW50ZXJhY3RpdmUgbGF5b3V0IGRvZXMgbm90IHN1cHBvcnQgTk9SVEgvU09VVEggcG9ydHMgd2l0aCBpbmNvbWluZyBfYW5kXyBvdXRnb2luZyBlZGdlcy4iKSk7aWYodS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCl7Zm9yKGk9aHIscj1uZXcgVCh1Lm91dGdvaW5nRWRnZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwxOCkscz1uLnRhcmdldC5vd25lcix0PWEodyhzLChvZSgpLGJQKSksMTQwKSxpPVMuTWF0aC5taW4oaSxzLnBvcy54XzAtdC5sZWZ0KTtyZXR1cm4gbmV3IHJJKHZuKGkpKX1pZih1LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wKXtmb3Iobz1WcixyPW5ldyBUKHUuaW5jb21pbmdFZGdlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDE4KSxzPW4uc291cmNlLm93bmVyLHQ9YSh3KHMsKG9lKCksYlApKSwxNDApLG89Uy5NYXRoLm1heChvLHMucG9zLnhfMCtzLnNpemVfMC54XzArdC5yaWdodCk7cmV0dXJuIG5ldyBySSh2bihvKSl9cmV0dXJuIHYyKCksdjIoKSxJNn1mdW5jdGlvbiBsdmUoZSxuKXt2YXIgcix0LG87Zm9yKHQ9bmV3IFhlKFFlKGljKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcmV0dXJuIHI9YSh0bih0KSwxOCksbz1hKG4uYXBwbHlfMChyKSwxMCksbmV3IHJJKHZuKG8ucG9zLnlfMCtvLnNpemVfMC55XzAvMikpO3JldHVybiB2MigpLHYyKCksSTZ9ZnVuY3Rpb24gbHNuKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKGEodyhuLChLKCksaWkpKSwyMSkuY29udGFpbnMoKFZ0KCksbmwpKSl7Zm9yKHU9bmV3IFQobi5sYXllcmxlc3NOb2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHUpLDEwKSxpLnR5cGVfMD09KFdlKCksa3IpJiYobz1hKHcoaSwob2UoKSxiUCkpLDE0MCksZS5taW5YPVMuTWF0aC5taW4oZS5taW5YLGkucG9zLnhfMC1vLmxlZnQpLGUubWF4WD1TLk1hdGgubWF4KGUubWF4WCxpLnBvcy54XzAraS5zaXplXzAueF8wK28ucmlnaHQpLGUubWluWT1TLk1hdGgubWluKGUubWluWSxpLnBvcy55XzAtby50b3BfMCksZS5tYXhZPVMuTWF0aC5tYXgoZS5tYXhZLGkucG9zLnlfMCtpLnNpemVfMC55XzArby5ib3R0b20pKTtmb3Iocz1uZXcgVChuLmxheWVybGVzc05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoaT1hKEMocyksMTApLGkudHlwZV8wIT0oV2UoKSxrcikpc3dpdGNoKGkudHlwZV8wLm9yZGluYWwpe2Nhc2UgMjppZih0PWEodyhpLChvZSgpLEVpKSksMTcxKSx0PT0ocmwoKSxGMCkpe2kucG9zLnhfMD1lLm1pblgtMTAsbHZlKGksbmV3IHV2ZSkudHJhbnNmb3JtKG5ldyBjdmUoaSkpO2JyZWFrfWlmKHQ9PXhmKXtpLnBvcy54XzA9ZS5tYXhYKzEwLGx2ZShpLG5ldyBfdmUpLnRyYW5zZm9ybShuZXcgZHZlKGkpKTticmVha31pZihyPWEodyhpLEJfKSwzMTEpLHI9PShsYygpLEpwKSl7YXZlKGkpLnRyYW5zZm9ybShuZXcgZnZlKGkpKSxpLnBvcy55XzA9ZS5taW5ZLTEwO2JyZWFrfWlmKHI9PUdoKXthdmUoaSkudHJhbnNmb3JtKG5ldyBwdmUoaSkpLGkucG9zLnlfMD1lLm1heFkrMTA7YnJlYWt9YnJlYWs7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiVGhlIG5vZGUgdHlwZSAiK2kudHlwZV8wKyIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgIitkc24pKX19fWZ1bmN0aW9uIHN2ZSgpe31mdW5jdGlvbiBzc24oZSxuKXtyZXR1cm4gZS5wb3MueV8wPShWZShuKSxuKX1mdW5jdGlvbiB1c24oZSxuKXtyZXR1cm4gZS5wb3MueV8wPShWZShuKSxuKX1mdW5jdGlvbiBjc24oZSxuKXtyZXR1cm4gZS5wb3MueF8wPShWZShuKSxuKzEwKX1mdW5jdGlvbiBfc24oZSxuKXtyZXR1cm4gZS5wb3MueF8wPShWZShuKSxuKzEwKX1wKDE1OTgsMSxzcixzdmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe2xzbih0aGlzLGEobiwzNikpfSxsLm1heFg9VnIsbC5tYXhZPVZyLGwubWluWD1ocixsLm1pblk9aHI7dmFyIGRzbj1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiSW50ZXJhY3RpdmVFeHRlcm5hbFBvcnRQb3NpdGlvbmVyIiwxNTk4KTtmdW5jdGlvbiB1dmUoKXt9cCgxNTk5LDEse30sdXZlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxOCkudGFyZ2V0Lm93bmVyfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkMCRUeXBlIiwxNTk5KTtmdW5jdGlvbiBjdmUoZSl7dGhpcy5ub2RlXzA9ZX1wKDE2MDAsMSx7fSxjdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gc3NuKHRoaXMubm9kZV8wLCQobikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkMSRUeXBlIiwxNjAwKTtmdW5jdGlvbiBfdmUoKXt9cCgxNjAxLDEse30sX3ZlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxOCkuc291cmNlLm93bmVyfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkMiRUeXBlIiwxNjAxKTtmdW5jdGlvbiBkdmUoZSl7dGhpcy5ub2RlXzA9ZX1wKDE2MDIsMSx7fSxkdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gdXNuKHRoaXMubm9kZV8wLCQobikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkMyRUeXBlIiwxNjAyKTtmdW5jdGlvbiBmdmUoZSl7dGhpcy5ub2RlXzA9ZX1wKDE2MDMsMSx7fSxmdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gY3NuKHRoaXMubm9kZV8wLCQobikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkNCRUeXBlIiwxNjAzKTtmdW5jdGlvbiBwdmUoZSl7dGhpcy5ub2RlXzA9ZX1wKDE2MDQsMSx7fSxwdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gX3NuKHRoaXMubm9kZV8wLCQobikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlRXh0ZXJuYWxQb3J0UG9zaXRpb25lci9sYW1iZGEkNSRUeXBlIiwxNjA0KTtmdW5jdGlvbiBrdCgpe2t0PUYsU2o9bmV3IEdyKCJESVJFQ1RJT05fUFJFUFJPQ0VTU09SIiwwKSx3aj1uZXcgR3IoIkNPTU1FTlRfUFJFUFJPQ0VTU09SIiwxKSxXcD1uZXcgR3IoIkVER0VfQU5EX0xBWUVSX0NPTlNUUkFJTlRfRURHRV9SRVZFUlNFUiIsMiksZDk9bmV3IEdyKCJJTlRFUkFDVElWRV9FWFRFUk5BTF9QT1JUX1BPU0lUSU9ORVIiLDMpLEdqPW5ldyBHcigiUEFSVElUSU9OX1BSRVBST0NFU1NPUiIsNCkseDQ9bmV3IEdyKCJMQUJFTF9EVU1NWV9JTlNFUlRFUiIsNSksRjQ9bmV3IEdyKCJTRUxGX0xPT1BfUFJFUFJPQ0VTU09SIiw2KSxTZj1uZXcgR3IoIkxBWUVSX0NPTlNUUkFJTlRfUFJFUFJPQ0VTU09SIiw3KSwkaj1uZXcgR3IoIlBBUlRJVElPTl9NSURQUk9DRVNTT1IiLDgpLEFqPW5ldyBHcigiSElHSF9ERUdSRUVfTk9ERV9MQVlFUl9QUk9DRVNTT1IiLDkpLEZqPW5ldyBHcigiTk9ERV9QUk9NT1RJT04iLDEwKSx2Zj1uZXcgR3IoIkxBWUVSX0NPTlNUUkFJTlRfUE9TVFBST0NFU1NPUiIsMTEpLEJqPW5ldyBHcigiUEFSVElUSU9OX1BPU1RQUk9DRVNTT1IiLDEyKSx4aj1uZXcgR3IoIkhJRVJBUkNISUNBTF9QT1JUX0NPTlNUUkFJTlRfUFJPQ0VTU09SIiwxMyksSGo9bmV3IEdyKCJTRU1JX0lOVEVSQUNUSVZFX0NST1NTTUlOX1BST0NFU1NPUiIsMTQpLGZqPW5ldyBHcigiQlJFQUtJTkdfUE9JTlRfSU5TRVJURVIiLDE1KSxMND1uZXcgR3IoIkxPTkdfRURHRV9TUExJVFRFUiIsMTYpLGY5PW5ldyBHcigiUE9SVF9TSURFX1BST0NFU1NPUiIsMTcpLGI0PW5ldyBHcigiSU5WRVJURURfUE9SVF9QUk9DRVNTT1IiLDE4KSxNND1uZXcgR3IoIlBPUlRfTElTVF9TT1JURVIiLDE5KSxXaj1uZXcgR3IoIlNPUlRfQllfSU5QVVRfT1JERVJfT0ZfTU9ERUwiLDIwKSxPND1uZXcgR3IoIk5PUlRIX1NPVVRIX1BPUlRfUFJFUFJPQ0VTU09SIiwyMSkscGo9bmV3IEdyKCJCUkVBS0lOR19QT0lOVF9QUk9DRVNTT1IiLDIyKSx6aj1uZXcgR3IoIk9ORV9TSURFRF9HUkVFRFlfU1dJVENIIiwyMyksamo9bmV3IEdyKCJUV09fU0lERURfR1JFRURZX1NXSVRDSCIsMjQpLFI0PW5ldyBHcigiU0VMRl9MT09QX1BPUlRfUkVTVE9SRVIiLDI1KSxVaj1uZXcgR3IoIlNJTkdMRV9FREdFX0dSQVBIX1dSQVBQRVIiLDI2KSxJND1uZXcgR3IoIklOX0xBWUVSX0NPTlNUUkFJTlRfUFJPQ0VTU09SIiwyNyksVGo9bmV3IEdyKCJFTkRfTk9ERV9QT1JUX0xBQkVMX01BTkFHRU1FTlRfUFJPQ0VTU09SIiwyOCksUmo9bmV3IEdyKCJMQUJFTF9BTkRfTk9ERV9TSVpFX1BST0NFU1NPUiIsMjkpLE1qPW5ldyBHcigiSU5ORVJNT1NUX05PREVfTUFSR0lOX0NBTENVTEFUT1IiLDMwKSx6ND1uZXcgR3IoIlNFTEZfTE9PUF9ST1VURVIiLDMxKSxtaj1uZXcgR3IoIkNPTU1FTlRfTk9ERV9NQVJHSU5fQ0FMQ1VMQVRPUiIsMzIpLFQ0PW5ldyBHcigiRU5EX0xBQkVMX1BSRVBST0NFU1NPUiIsMzMpLE40PW5ldyBHcigiTEFCRUxfRFVNTVlfU1dJVENIRVIiLDM0KSxoaj1uZXcgR3IoIkNFTlRFUl9MQUJFTF9NQU5BR0VNRU5UX1BST0NFU1NPUiIsMzUpLHp5PW5ldyBHcigiTEFCRUxfU0lERV9TRUxFQ1RPUiIsMzYpLGtqPW5ldyBHcigiSFlQRVJFREdFX0RVTU1ZX01FUkdFUiIsMzcpLFBqPW5ldyBHcigiSElFUkFSQ0hJQ0FMX1BPUlRfRFVNTVlfU0laRV9QUk9DRVNTT1IiLDM4KSxEaj1uZXcgR3IoIkxBWUVSX1NJWkVfQU5EX0dSQVBIX0hFSUdIVF9DQUxDVUxBVE9SIiwzOSksUEU9bmV3IEdyKCJISUVSQVJDSElDQUxfUE9SVF9QT1NJVElPTl9QUk9DRVNTT1IiLDQwKSxFaj1uZXcgR3IoIkNPTlNUUkFJTlRTX1BPU1RQUk9DRVNTT1IiLDQxKSx5aj1uZXcgR3IoIkNPTU1FTlRfUE9TVFBST0NFU1NPUiIsNDIpLE9qPW5ldyBHcigiSFlQRVJOT0RFX1BST0NFU1NPUiIsNDMpLE5qPW5ldyBHcigiSElFUkFSQ0hJQ0FMX1BPUlRfT1JUSE9HT05BTF9FREdFX1JPVVRFUiIsNDQpLEE0PW5ldyBHcigiTE9OR19FREdFX0pPSU5FUiIsNDUpLEQ0PW5ldyBHcigiU0VMRl9MT09QX1BPU1RQUk9DRVNTT1IiLDQ2KSxnaj1uZXcgR3IoIkJSRUFLSU5HX1BPSU5UX1JFTU9WRVIiLDQ3KSxrND1uZXcgR3IoIk5PUlRIX1NPVVRIX1BPUlRfUE9TVFBST0NFU1NPUiIsNDgpLExqPW5ldyBHcigiSE9SSVpPTlRBTF9DT01QQUNUT1IiLDQ5KSxQND1uZXcgR3IoIkxBQkVMX0RVTU1ZX1JFTU9WRVIiLDUwKSxiaj1uZXcgR3IoIkZJTkFMX1NQTElORV9CRU5EUE9JTlRTX0NBTENVTEFUT1IiLDUxKSxDaj1uZXcgR3IoIkVORF9MQUJFTF9TT1JURVIiLDUyKSxoMz1uZXcgR3IoIlJFVkVSU0VEX0VER0VfUkVTVE9SRVIiLDUzKSxDND1uZXcgR3IoIkVORF9MQUJFTF9QT1NUUFJPQ0VTU09SIiw1NCksSWo9bmV3IEdyKCJISUVSQVJDSElDQUxfTk9ERV9SRVNJWkVSIiw1NSksdmo9bmV3IEdyKCJESVJFQ1RJT05fUE9TVFBST0NFU1NPUiIsNTYpfWZ1bmN0aW9uIEdyKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZnNuKGUpe3JldHVybiBrdCgpLHduKChodmUoKSxtdmUpLGUpfWZ1bmN0aW9uIGd2ZSgpe3JldHVybiBrdCgpLFAoSShwc24sMSksVyw4MSwwLFtTaix3aixXcCxkOSxHaix4NCxGNCxTZiwkaixBaixGaix2ZixCaix4aixIaixmaixMNCxmOSxiNCxNNCxXaixPNCxwaix6aixqaixSNCxVaixJNCxUaixSaixNaix6NCxtaixUNCxONCxoaix6eSxraixQaixEaixQRSxFaix5aixPaixOaixBNCxENCxnaixrNCxMaixQNCxiaixDaixoMyxDNCxJaix2al0pfXAoODEsMjIsezM6MSwzNDoxLDIyOjEsODE6MSwxOTY6MX0sR3IpLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5vcmRpbmFsKXtjYXNlIDE1OnJldHVybiBuZXcgYmJlO2Nhc2UgMjI6cmV0dXJuIG5ldyBNYmU7Y2FzZSA0NzpyZXR1cm4gbmV3IHpiZTtjYXNlIDI4OmNhc2UgMzU6cmV0dXJuIG5ldyAkdmU7Y2FzZSAzMjpyZXR1cm4gbmV3ICQyZTtjYXNlIDQyOnJldHVybiBuZXcgVTJlO2Nhc2UgMTpyZXR1cm4gbmV3IFcyZTtjYXNlIDQxOnJldHVybiBuZXcgajJlO2Nhc2UgNTY6cmV0dXJuIG5ldyBpaigoRnkoKSxwMykpO2Nhc2UgMDpyZXR1cm4gbmV3IGlqKChGeSgpLF85KSk7Y2FzZSAyOnJldHVybiBuZXcgVjJlO2Nhc2UgNTQ6cmV0dXJuIG5ldyBxMmU7Y2FzZSAzMzpyZXR1cm4gbmV3IEoyZTtjYXNlIDUxOnJldHVybiBuZXcgaEVlO2Nhc2UgNTU6cmV0dXJuIG5ldyBrRWU7Y2FzZSAxMzpyZXR1cm4gbmV3IFJFZTtjYXNlIDM4OnJldHVybiBuZXcgekVlO2Nhc2UgNDQ6cmV0dXJuIG5ldyBXRWU7Y2FzZSA0MDpyZXR1cm4gbmV3IFlFZTtjYXNlIDk6cmV0dXJuIG5ldyBLRWU7Y2FzZSA0OTpyZXR1cm4gbmV3IFpDZTtjYXNlIDM3OnJldHVybiBuZXcgUUVlO2Nhc2UgNDM6cmV0dXJuIG5ldyB0dmU7Y2FzZSAyNzpyZXR1cm4gbmV3IG92ZTtjYXNlIDMwOnJldHVybiBuZXcgaXZlO2Nhc2UgMzpyZXR1cm4gbmV3IHN2ZTtjYXNlIDE4OnJldHVybiBuZXcgd3ZlO2Nhc2UgMjk6cmV0dXJuIG5ldyBFdmU7Y2FzZSA1OnJldHVybiBuZXcgYnZlO2Nhc2UgNTA6cmV0dXJuIG5ldyBQdmU7Y2FzZSAzNDpyZXR1cm4gbmV3IGt2ZTtjYXNlIDM2OnJldHVybiBuZXcgcXZlO2Nhc2UgNTI6cmV0dXJuIG5ldyBhRWU7Y2FzZSAxMTpyZXR1cm4gbmV3IEt2ZTtjYXNlIDc6cmV0dXJuIG5ldyBadmU7Y2FzZSAzOTpyZXR1cm4gbmV3IHJTZTtjYXNlIDQ1OnJldHVybiBuZXcgdFNlO2Nhc2UgMTY6cmV0dXJuIG5ldyBvU2U7Y2FzZSAxMDpyZXR1cm4gbmV3IHVTZTtjYXNlIDQ4OnJldHVybiBuZXcgbVNlO2Nhc2UgMjE6cmV0dXJuIG5ldyB3U2U7Y2FzZSAyMzpyZXR1cm4gbmV3IGE3KChhZCgpLGF2KSk7Y2FzZSA4OnJldHVybiBuZXcgdlNlO2Nhc2UgMTI6cmV0dXJuIG5ldyBUU2U7Y2FzZSA0OnJldHVybiBuZXcgYlNlO2Nhc2UgMTk6cmV0dXJuIG5ldyBrU2U7Y2FzZSAxNzpyZXR1cm4gbmV3IFdTZTtjYXNlIDUzOnJldHVybiBuZXcgalNlO2Nhc2UgNjpyZXR1cm4gbmV3IGxDZTtjYXNlIDI1OnJldHVybiBuZXcgVlNlO2Nhc2UgNDY6cmV0dXJuIG5ldyBaU2U7Y2FzZSAzMTpyZXR1cm4gbmV3IF9DZTtjYXNlIDE0OnJldHVybiBuZXcgbUNlO2Nhc2UgMjY6cmV0dXJuIG5ldyBLYmU7Y2FzZSAyMDpyZXR1cm4gbmV3IFNDZTtjYXNlIDI0OnJldHVybiBuZXcgYTcoKGFkKCksV1ApKTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJObyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBsYXlvdXQgcHJvY2Vzc29yICIrKHRoaXMubmFtZV8wIT1udWxsP3RoaXMubmFtZV8wOiIiK3RoaXMub3JkaW5hbCkpKX19O3ZhciBmaixwaixnaixoaixtaix5aix3aixFaix2aixTaixXcCxDNCxUNCxDaixUaixiaixJaix4aixQaixOaixQRSxBaixMaixraixPaixNaixkOSxiNCxJNCxSaix4NCxQNCxONCx6eSx2ZixTZixEaixBNCxMNCxGaixrNCxPNCx6aiwkaixCaixHaixNNCxmOSxoMyxSNCxENCxGNCx6NCxIaixVaixXaixqaixwc249Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJJbnRlcm1lZGlhdGVQcm9jZXNzb3JTdHJhdGVneSIsODEsZ24sZ3ZlLGZzbik7ZnVuY3Rpb24gaHZlKCl7aHZlPUYsbXZlPXluKGd2ZSgpKX12YXIgbXZlO2Z1bmN0aW9uIGdzbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZDtpZihyLnNvdXJjZS5vd25lciE9bi5vd25lcilmb3Iobz1uZXcgYWMoZSksel8obywoV2UoKSxpdCkpLGoobywoSygpLFFuKSxyKSxqKG8sKG9lKCkseHIpLChkdCgpLGFpKSksUmUodC5hcnJheSxvKSxzPW5ldyBabyxMbyhzLG8pLFhyKHMsKHJlKCksamUpKSx1PW5ldyBabyxMbyh1LG8pLFhyKHUscWUpLF90KHIscyksaT1uZXcgSDEsZ28oaSxyKSxqKGksaW8sbnVsbCksTHQoaSx1KSxfdChpLG4pLHl2ZShvLHMsdSksXz1uZXcgcHQoci5sYWJlbHMsMCk7Xy5pPF8udGhpcyQwMV8wLnNpemVfMSgpOyljPShybihfLmk8Xy50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoXy50aGlzJDAxXzAuZ2V0XzAoXy5sYXN0PV8uaSsrKSw3MikpLGQ9YSh3KGMsZHUpLDI3OCksZD09KEdzKCksVmYpJiYoX3IoYyxVaCl8fGooYyxVaCxyKSxFYShfKSxlZShpLmxhYmVscyxjKSl9ZnVuY3Rpb24gaHNuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkO2lmKHIudGFyZ2V0Lm93bmVyIT1uLm93bmVyKXtmb3Iobz1uZXcgYWMoZSksel8obywoV2UoKSxpdCkpLGoobywoSygpLFFuKSxyKSxqKG8sKG9lKCkseHIpLChkdCgpLGFpKSksUmUodC5hcnJheSxvKSxzPW5ldyBabyxMbyhzLG8pLFhyKHMsKHJlKCksamUpKSx1PW5ldyBabyxMbyh1LG8pLFhyKHUscWUpLGQ9ci50YXJnZXQsX3QocixzKSxpPW5ldyBIMSxnbyhpLHIpLGooaSxpbyxudWxsKSxMdChpLHUpLF90KGksZCksXz1uZXcgcHQoci5sYWJlbHMsMCk7Xy5pPF8udGhpcyQwMV8wLnNpemVfMSgpOyljPShybihfLmk8Xy50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoXy50aGlzJDAxXzAuZ2V0XzAoXy5sYXN0PV8uaSsrKSw3MikpLEQodyhjLGR1KSk9PT1EKChHcygpLFZmKSkmJihqKGMsVWgsciksRWEoXyksZWUoaS5sYWJlbHMsYykpO3l2ZShvLHMsdSl9fWZ1bmN0aW9uIG1zbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztmb3Iobi5iZWdpbigiSW52ZXJ0ZWQgcG9ydCBwcmVwcm9jZXNzaW5nIiwxKSxkPWUubGF5ZXJzLF89bmV3IHB0KGQsMCkscj1udWxsLGs9bmV3IFE7Xy5pPF8udGhpcyQwMV8wLnNpemVfMSgpOyl7Zm9yKEE9cixyPShybihfLmk8Xy50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoXy50aGlzJDAxXzAuZ2V0XzAoXy5sYXN0PV8uaSsrKSwzMCkpLG09bmV3IFQoayk7bS5pPG0udGhpcyQwMS5hcnJheS5sZW5ndGg7KWY9YShDKG0pLDEwKSxodChmLEEpO2ZvcihrLmFycmF5Lmxlbmd0aD0wLHk9bmV3IFQoci5ub2Rlcyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKGY9YShDKHkpLDEwKSxmLnR5cGVfMD09KFdlKCksa3IpJiZPZyhhKHcoZiwob2UoKSx4cikpLDEwMSkpKXtmb3IoeD0kVyhmLChxdCgpLGlhKSwocmUoKSxxZSkpLml0ZXJhdG9yXzAoKTt4Lmhhc05leHRfMCgpOylmb3IoRT1hKHgubmV4dF8xKCksMTIpLGM9RS5pbmNvbWluZ0VkZ2VzLHU9YShJcyhjLEIobjksZjYsMTgsYy5hcnJheS5sZW5ndGgsMCwxKSksNDgzKSxvPXUsaT0wLHM9by5sZW5ndGg7aTxzOysraSl0PW9baV0sZ3NuKGUsRSx0LGspO2Zvcih2PSRXKGYscGksamUpLml0ZXJhdG9yXzAoKTt2Lmhhc05leHRfMCgpOylmb3IoRT1hKHYubmV4dF8xKCksMTIpLGM9RS5vdXRnb2luZ0VkZ2VzLHU9YShJcyhjLEIobjksZjYsMTgsYy5hcnJheS5sZW5ndGgsMCwxKSksNDgzKSxvPXUsaT0wLHM9by5sZW5ndGg7aTxzOysraSl0PW9baV0saHNuKGUsRSx0LGspfX1mb3IoaD1uZXcgVChrKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksMTApLGh0KGYscik7bi5kb25lXzEoKX1mdW5jdGlvbiB5dmUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpPWEobGUobi5pbmNvbWluZ0VkZ2VzLDApLDE4KS5zb3VyY2UsdD1pLm93bmVyLG89dC50eXBlXzAsYz1hKGxlKHIub3V0Z29pbmdFZGdlcywwKSwxOCkudGFyZ2V0LHM9Yy5vd25lcix1PXMudHlwZV8wLG89PShXZSgpLGl0KT9qKGUsKEsoKSxkcyksYSh3KHQsZHMpLDEyKSk6aihlLChLKCksZHMpLGkpLHU9PWl0P2ooZSwoSygpLHZsKSxhKHcocyx2bCksMTIpKTpqKGUsKEsoKSx2bCksYyl9ZnVuY3Rpb24gd3ZlKCl7fXAoMTYwNSwxLHNyLHd2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7bXNuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJJbnZlcnRlZFBvcnRQcm9jZXNzb3IiLDE2MDUpO2Z1bmN0aW9uIHlzbihlLG4pe3ZhciByLHQsbyxpO2lmKGUubGFiZWxzLmFycmF5Lmxlbmd0aD09MClyZXR1cm4gbnVsbDtmb3IoaT1uZXcgaW0sdD1uZXcgVChlLmxhYmVscyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDcyKSxvPXIuc2l6ZV8wLGkud2lkdGhfMD1TLk1hdGgubWF4KGkud2lkdGhfMCxvLnhfMCksaS5oZWlnaHQrPW8ueV8wO3JldHVybiBpLmhlaWdodCs9KGUubGFiZWxzLmFycmF5Lmxlbmd0aC0xKSpuLGl9ZnVuY3Rpb24gd3NuKGUsbixyLHQpe0Vzbih0LGUsbixyKX1mdW5jdGlvbiBFc24oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2lmKGg9UigkKHcoZSwob2UoKSxzdykpKSksbT1SKCQodyhlLHV3KSkpLGY9UigkKHcoZSxNZikpKSx1PWUuc2l6ZV8wLGk9YShsZShlLnBvcnRzLDApLDEyKSxzPWkucG9zLEU9eXNuKGksZiksISFFKXtpZihuLmNvbnRhaW5zKChhYSgpLGhjKSkpc3dpdGNoKGEodyhlLChLKCksRG8pKSw2NCkub3JkaW5hbCl7Y2FzZSAxOkUueF8wPSh1LnhfMC1FLndpZHRoXzApLzItcy54XzAsRS55XzA9bTticmVhaztjYXNlIDM6RS54XzA9KHUueF8wLUUud2lkdGhfMCkvMi1zLnhfMCxFLnlfMD0tbS1FLmhlaWdodDticmVhaztjYXNlIDI6ciYmaS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MCYmaS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MD8oZD10P0UuaGVpZ2h0OmEobGUoaS5sYWJlbHMsMCksNzIpLnNpemVfMC55XzAsRS55XzA9KHUueV8wLWQpLzItcy55XzApOkUueV8wPXUueV8wK20tcy55XzAsRS54XzA9LWgtRS53aWR0aF8wO2JyZWFrO2Nhc2UgNDpyJiZpLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wJiZpLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wPyhkPXQ/RS5oZWlnaHQ6YShsZShpLmxhYmVscywwKSw3Mikuc2l6ZV8wLnlfMCxFLnlfMD0odS55XzAtZCkvMi1zLnlfMCk6RS55XzA9dS55XzArbS1zLnlfMCxFLnhfMD1ofWVsc2UgaWYobi5jb250YWlucyhZMCkpc3dpdGNoKGEodyhlLChLKCksRG8pKSw2NCkub3JkaW5hbCl7Y2FzZSAxOmNhc2UgMzpFLnhfMD1zLnhfMCtoO2JyZWFrO2Nhc2UgMjpjYXNlIDQ6ciYmIWkuY29ubmVjdGVkVG9FeHRlcm5hbE5vZGVzPyhkPXQ/RS5oZWlnaHQ6YShsZShpLmxhYmVscywwKSw3Mikuc2l6ZV8wLnlfMCxFLnlfMD0odS55XzAtZCkvMi1zLnlfMCk6RS55XzA9cy55XzArbX1mb3Iobz1FLnlfMCxfPW5ldyBUKGkubGFiZWxzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksNzIpLHk9Yy5wb3MseS54XzA9RS54XzAseS55XzA9byxvKz1jLnNpemVfMC55XzArZn19ZnVuY3Rpb24gdnNuKGUsbil7dmFyIHIsdCxvLGkscztpZihuLmJlZ2luKCJOb2RlIGFuZCBQb3J0IExhYmVsIFBsYWNlbWVudCBhbmQgTm9kZSBTaXppbmciLDEpLFRmZSgod0UoKSxuZXcgcjkoZSwhMCwhMCxuZXcgdnZlKSkpLGEodyhlLChLKCksaWkpKSwyMSkuY29udGFpbnMoKFZ0KCksbmwpKSlmb3IoaT1hKHcoZSwob2UoKSxrZikpLDIxKSxvPWkuY29udGFpbnMoKGFhKCksJFQpKSxzPWFlKGllKHcoZSxkWSkpKSx0PW5ldyBUKGUubGF5ZXJzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMzApLExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZShyLm5vZGVzLDE2KSksbmV3IFN2ZSksbmV3IEN2ZShpLG8scykpO24uZG9uZV8xKCl9ZnVuY3Rpb24gRXZlKCl7fXAoMTYwNiwxLHNyLEV2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7dnNuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbEFuZE5vZGVTaXplUHJvY2Vzc29yIiwxNjA2KTtmdW5jdGlvbiB2dmUoKXt9cCgxNjA3LDEsSW4sdnZlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEwKS50eXBlXzA9PShXZSgpLGtyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsQW5kTm9kZVNpemVQcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTYwNyk7ZnVuY3Rpb24gU3ZlKCl7fXAoMTYwOCwxLEluLFN2ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMCkudHlwZV8wPT0oV2UoKSxGcil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbEFuZE5vZGVTaXplUHJvY2Vzc29yL2xhbWJkYSQxJFR5cGUiLDE2MDgpO2Z1bmN0aW9uIEN2ZShlLG4scil7dGhpcy5wb3J0TGFiZWxQbGFjZW1lbnRfMT1lLHRoaXMucGxhY2VOZXh0VG9Qb3J0XzI9bix0aGlzLnRyZWF0QXNHcm91cF8zPXJ9cCgxNjA5LDEsSmUsQ3ZlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt3c24odGhpcy5wb3J0TGFiZWxQbGFjZW1lbnRfMSx0aGlzLnBsYWNlTmV4dFRvUG9ydF8yLHRoaXMudHJlYXRBc0dyb3VwXzMsYShuLDEwKSl9LGwucGxhY2VOZXh0VG9Qb3J0XzI9ITEsbC50cmVhdEFzR3JvdXBfMz0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGFiZWxBbmROb2RlU2l6ZVByb2Nlc3Nvci9sYW1iZGEkMiRUeXBlIiwxNjA5KTtmdW5jdGlvbiBUdmUoKXtUdmU9RixJdmU9bmV3IHh2ZX1mdW5jdGlvbiBTc24oZSxuLHIsdCl7dmFyIG8saSxzLHU7Zm9yKG89bmV3IGFjKGUpLHpfKG8sKFdlKCksWW8pKSxqKG8sKEsoKSxRbiksbiksaihvLFVFLHQpLGoobywob2UoKSx4ciksKGR0KCksYWkpKSxqKG8sZHMsbi5zb3VyY2UpLGoobyx2bCxuLnRhcmdldCksaVNlKG4sbyksdT1TLk1hdGguZmxvb3Ioci8yKSxzPW5ldyBUKG8ucG9ydHMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMiksaS5wb3MueV8wPXU7cmV0dXJuIG99ZnVuY3Rpb24gQ3NuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3Iobi5iZWdpbigiTGFiZWwgZHVtbXkgaW5zZXJ0aW9ucyIsMSksZj1uZXcgUSxzPVIoJCh3KGUsKG9lKCksdGcpKSkpLF89UigkKHcoZSxNZikpKSxkPWEodyhlLE9hKSw4OCksbT1uZXcgVChlLmxheWVybGVzc05vZGVzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGg9YShDKG0pLDEwKSxpPW5ldyBYZShRZShScihoKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24oaSk7KWlmKG89YSh0bihpKSwxOCksby5zb3VyY2Uub3duZXIhPW8udGFyZ2V0Lm93bmVyJiZvNShvLmxhYmVscyxJdmUpKXtmb3IoRT1Uc24obykseT1OdShvLmxhYmVscy5hcnJheS5sZW5ndGgpLHI9U3NuKGUsbyxFLHkpLFJlKGYuYXJyYXksciksdD1yLnNpemVfMCx1PW5ldyBwdChvLmxhYmVscywwKTt1Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCk7KWM9KHJuKHUuaTx1LnRoaXMkMDFfMC5zaXplXzEoKSksYSh1LnRoaXMkMDFfMC5nZXRfMCh1Lmxhc3Q9dS5pKyspLDcyKSksRCh3KGMsZHUpKT09PUQoKEdzKCkseHcpKSYmKGQ9PShXcigpLG9sKXx8ZD09JHM/KHQueF8wKz1jLnNpemVfMC54XzArXyx0LnlfMD1TLk1hdGgubWF4KHQueV8wLGMuc2l6ZV8wLnlfMCkpOih0LnhfMD1TLk1hdGgubWF4KHQueF8wLGMuc2l6ZV8wLnhfMCksdC55XzArPWMuc2l6ZV8wLnlfMCtfKSxSZSh5LmFycmF5LGMpLEVhKHUpKTtkPT0oV3IoKSxvbCl8fGQ9PSRzPyh0LnhfMC09Xyx0LnlfMCs9cytFKTp0LnlfMCs9cy1fK0V9cXIoZS5sYXllcmxlc3NOb2RlcyxmKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIFRzbihlKXt2YXIgbjtyZXR1cm4gbj1SKCQodyhlLChvZSgpLFVjKSkpKSxuPDAmJihuPTAsaihlLFVjLG4pKSxufWZ1bmN0aW9uIGJ2ZSgpe1R2ZSgpfXAoMTYxMCwxLHNyLGJ2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7Q3NuKGEobiwzNikscil9O3ZhciBJdmU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsRHVtbXlJbnNlcnRlciIsMTYxMCk7ZnVuY3Rpb24geHZlKCl7fXAoMTYxMSwxLEpzLHh2ZSksbC5hcHBseV8xPWZ1bmN0aW9uKG4pe3JldHVybiBEKHcoYShuLDcyKSwob2UoKSxkdSkpKT09PUQoKEdzKCkseHcpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBEKHcoYShuLDcyKSwob2UoKSxkdSkpKT09PUQoKEdzKCkseHcpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsRHVtbXlJbnNlcnRlci8xIiwxNjExKTtmdW5jdGlvbiBic24oZSxuLHIsdCl7dmFyIG8saTtmb3IoaT1lLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSw3Miksby5wb3MueF8wPW4ueF8wKyh0LnhfMC1vLnNpemVfMC54XzApLzIsby5wb3MueV8wPW4ueV8wLG4ueV8wKz1vLnNpemVfMC55XzArcn1mdW5jdGlvbiBJc24oZSxuLHIsdCxvLGkpe3ZhciBzLHUsYyxfO2Zvcih1PSFQeShKbihlLnN0cmVhbSgpLG5ldyBieShuZXcgTnZlKSkpLnRyeUFkdmFuY2UoKE1fKCksSWgpKSxzPWUsaT09KFdyKCksb2wpJiYocz1xYShzKSksXz1zLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOyljPWEoXy5uZXh0XzEoKSw3MiksYy5wb3MueF8wPW4ueF8wLHU/Yy5wb3MueV8wPW4ueV8wKyh0LnlfMC1jLnNpemVfMC55XzApLzI6bz9jLnBvcy55XzA9bi55XzA6Yy5wb3MueV8wPW4ueV8wK3QueV8wLWMuc2l6ZV8wLnlfMCxuLnhfMCs9Yy5zaXplXzAueF8wK3J9ZnVuY3Rpb24geHNuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7Zm9yKG4uYmVnaW4oIkxhYmVsIGR1bW15IHJlbW92YWwiLDEpLHQ9UigkKHcoZSwob2UoKSx0ZykpKSksbz1SKCQodyhlLE1mKSkpLF89YSh3KGUsT2EpLDg4KSxjPW5ldyBUKGUubGF5ZXJzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHU9YShDKGMpLDMwKSxmPW5ldyBwdCh1Lm5vZGVzLDApO2YuaTxmLnRoaXMkMDFfMC5zaXplXzEoKTspZD0ocm4oZi5pPGYudGhpcyQwMV8wLnNpemVfMSgpKSxhKGYudGhpcyQwMV8wLmdldF8wKGYubGFzdD1mLmkrKyksMTApKSxkLnR5cGVfMD09KFdlKCksWW8pJiYoaD1hKHcoZCwoSygpLFFuKSksMTgpLHk9UigkKHcoaCxVYykpKSxzPUQodyhkLGpoKSk9PT1EKChEYSgpLGowKSkscj1uZXcgUnQoZC5wb3MpLHMmJihyLnlfMCs9eSt0KSxpPW5ldyBZKGQuc2l6ZV8wLnhfMCxkLnNpemVfMC55XzArKGQudHlwZV8wPT1ZbyYmIVB5KEpuKGEodyhkLFVFKSwxNSkuc3RyZWFtKCksbmV3IGJ5KG5ldyBCVykpKS50cnlBZHZhbmNlKChNXygpLEloKSk/MDoteS10KSksbT1hKHcoZCxVRSksMTUpLF89PShXcigpLG9sKXx8Xz09JHM/SXNuKG0scixvLGkscyxfKTpic24obSxyLG8saSkscXIoaC5sYWJlbHMsbSksaDkoZCxEKHcoZSx1YykpPT09RCgoZmMoKSxNVCkpKSxFYShmKSk7bi5kb25lXzEoKX1mdW5jdGlvbiBQdmUoKXt9cCgxNjEyLDEsc3IsUHZlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXt4c24oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsRHVtbXlSZW1vdmVyIiwxNjEyKTtmdW5jdGlvbiBOdmUoKXt9cCgxNjEzLDEsSW4sTnZlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYWUoaWUodyhhKG4sNzIpLChvZSgpLHZPKSkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsRHVtbXlSZW1vdmVyL2xhbWJkYSQwJFR5cGUiLDE2MTMpO2Z1bmN0aW9uIFJoKCl7Umg9RixwOT1uZXcgdnIoImVkZ2VsYWJlbGNlbnRlcmVkbmVzc2FuYWx5c2lzLmluY2x1ZGVsYWJlbCIsKHplKCksUzApKX1mdW5jdGlvbiBQc24oZSl7dmFyIG4scix0O2Zvcih0PTAscj1uZXcgVChlLmxheWVycyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDMwKSxuLmlkXzA9dCwrK3R9ZnVuY3Rpb24gJHkoZSxuLHIpe3ZhciB0LG8saTtmb3IociE9bi5sZWZ0bW9zdExheWVySWQrbi5sZWZ0TG9uZ0VkZ2VEdW1taWVzLnNpemVfMSgpJiZCc24obi5sYWJlbER1bW15LFZzbihuLHItbi5sZWZ0bW9zdExheWVySWQpKSxpPW4ubGFiZWxEdW1teS5sYXllci5pZF8wLGUubGF5ZXJXaWR0aHNbaV09Uy5NYXRoLm1heChlLmxheWVyV2lkdGhzW2ldLG4ubGFiZWxEdW1teS5zaXplXzAueF8wKSxvPWEodyhuLmxhYmVsRHVtbXksKEsoKSxVRSkpLDE1KS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksNzIpLGoodCxwOSwoemUoKSwhMCkpfWZ1bmN0aW9uIE5zbihlLG4pe3ZhciByLHQsbyxpO2ZvcihyPW4ubGFiZWxEdW1teS5zaXplXzAueF8wLGk9bmV3IE9jKFN0KG4ubGFiZWxEdW1teSkubGF5ZXJzLG4ubGVmdG1vc3RMYXllcklkLG4ucmlnaHRtb3N0TGF5ZXJJZCsxKSxvPW5ldyBxMihpKTtvLmk8by50aGlzJDAxXzAuc2l6ZV8xKCk7KWlmKHQ9KHJuKG8uaTxvLnRoaXMkMDFfMC5zaXplXzEoKSksYShvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspLDMwKSksdC5zaXplXzAueF8wPj1yKXJldHVybiAkeShlLG4sdC5pZF8wKSwhMDtyZXR1cm4hMX1mdW5jdGlvbiBBc24oZSxuKXt2YXIgcix0O2Zvcih0PW5ldyBUKG4ubGF5ZXJzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMzApLGUubGF5ZXJXaWR0aHNbci5pZF8wXT1yYW4ocil9ZnVuY3Rpb24gTHNuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IoYz1TdChuLmxhYmVsRHVtbXkpLG89UigkKHcoYywob2UoKSxxXykpKSkqMixkPVIoJCh3KGMsb2cpKSksXz1TLk1hdGgubWF4KG8sZCksaT1CKGN0LFh0LDI4LG4ucmlnaHRtb3N0TGF5ZXJJZC1uLmxlZnRtb3N0TGF5ZXJJZCsxLDE1LDEpLHQ9LV8scj0wLHU9bi5sZWZ0TG9uZ0VkZ2VEdW1taWVzLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxMCksdCs9ZS5sYXllcldpZHRoc1tzLmxheWVyLmlkXzBdK18saVtyKytdPXQ7Zm9yKHQrPWUubGF5ZXJXaWR0aHNbbi5sYWJlbER1bW15LmxheWVyLmlkXzBdK18saVtyKytdPXQsaD1uZXcgVChuLnJpZ2h0TG9uZ0VkZ2VEdW1taWVzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksMTApLHQrPWUubGF5ZXJXaWR0aHNbZi5sYXllci5pZF8wXStfLGlbcisrXT10O3JldHVybiBpfWZ1bmN0aW9uIGtzbihlLG4pe3ZhciByLHQsbztpZihvPXpzbihlLG4pLG8uYXJyYXkubGVuZ3RoIT0wKWZvcihEcihvLG5ldyB6dmUpLHI9by5hcnJheS5sZW5ndGgsdD0wO3Q8cjt0KyspJHkoZSwoQWUodCxvLmFycmF5Lmxlbmd0aCksYShvLmFycmF5W3RdLDI5MykpLFJzbihlLG8sdCkpfWZ1bmN0aW9uIE9zbihlKXt2YXIgbjtmb3Iobj0oUmgoKSxhKHRuKG5ldyBYZShRZSh0dChlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KS5zb3VyY2Uub3duZXIpO24udHlwZV8wPT0oV2UoKSxpdCk7KWoobiwoSygpLEwzKSwoemUoKSwhMCkpLG49YSh0bihuZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCkuc291cmNlLm93bmVyfWZ1bmN0aW9uIE1zbihlLG4pe3ZhciByLHQsbztmb3IodD1Mc24oZSxuKSxvPXRbdC5sZW5ndGgtMV0vMixyPTA7cjx0Lmxlbmd0aDtyKyspaWYodFtyXT49bylyZXR1cm4gbi5sZWZ0bW9zdExheWVySWQrcjtyZXR1cm4gbi5sZWZ0bW9zdExheWVySWQrbi5sZWZ0TG9uZ0VkZ2VEdW1taWVzLnNpemVfMSgpfWZ1bmN0aW9uIFJzbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKGk9bi5hcnJheS5sZW5ndGgscz0oQWUocixuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W3JdLDI5MykpLHU9cy5sYWJlbER1bW15LnNpemVfMC54XzAsZj1zLmxlZnRtb3N0TGF5ZXJJZCxoPTAsXz1zLmxlZnRtb3N0TGF5ZXJJZDtfPD1zLnJpZ2h0bW9zdExheWVySWQ7XysrKXtpZih1PD1lLmxheWVyV2lkdGhzW19dKXJldHVybiBfO2ZvcihkPWUubGF5ZXJXaWR0aHNbX10sYz1udWxsLG89cisxO288aTtvKyspdD0oQWUobyxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W29dLDI5MykpLHQubGVmdG1vc3RMYXllcklkPD1fJiZ0LnJpZ2h0bW9zdExheWVySWQ+PV8mJihjPXQpO2MmJihkPVMuTWF0aC5tYXgoZCxjLmxhYmVsRHVtbXkuc2l6ZV8wLnhfMCkpLGQ+aCYmKGY9XyxoPWQpfXJldHVybiBmfWZ1bmN0aW9uIERzbihlLG4pe3ZhciByLHQ7Zm9yKHQ9bi5sZWZ0bW9zdExheWVySWQscj10KzE7cjw9bi5yaWdodG1vc3RMYXllcklkO3IrKyllLmxheWVyV2lkdGhzW3JdPmUubGF5ZXJXaWR0aHNbdF0mJih0PXIpO3JldHVybiB0fWZ1bmN0aW9uIEZzbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHI9bmV3IFEyKFl5KSxvPShCaCgpLFAoSShZeSwxKSxXLDIzMiwwLFtxeSxPRSxWeSxUZixZcCxxcF0pKSxpPTAscz1vLmxlbmd0aDtpPHM7KytpKXQ9b1tpXSxKQihyLHQsbmV3IFEpO3JldHVybiBMcihwbyhKbihObyhuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcnMsMTYpKSxuZXcgTXZlKSxuZXcgUnZlKSxuZXcgRHZlKG4pKSxuZXcgRnZlKHIpKSxyfWZ1bmN0aW9uIFZqKGUpe3ZhciBuLHI7cmV0dXJuIG49YSh0bihuZXcgWGUoUWUodHQoZS5sYWJlbER1bW15KS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KSxyPWEodG4obmV3IFhlKFFlKFJyKGUubGFiZWxEdW1teSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCksYWUoaWUodyhuLChLKCksT3MpKSkpfHxhZShpZSh3KHIsT3MpKSl9ZnVuY3Rpb24genNuKGUsbil7dmFyIHIsdCxvO2ZvcihvPW5ldyBfaShuLnNpemVfMSgpKSx0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9YSh0Lm5leHRfMSgpLDI5Myksci5sZWZ0bW9zdExheWVySWQ9PXIucmlnaHRtb3N0TGF5ZXJJZD8keShlLHIsci5sZWZ0bW9zdExheWVySWQpOk5zbihlLHIpfHxSZShvLmFycmF5LHIpO3JldHVybiBvfWZ1bmN0aW9uICRzbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2ZvcihyLmJlZ2luKCJMYWJlbCBkdW1teSBzd2l0Y2hpbmciLDEpLHQ9YSh3KG4sKG9lKCksdlApKSwyMzIpLFBzbihuKSxvPUZzbihuLHQpLGUubGF5ZXJXaWR0aHM9QihjdCxYdCwyOCxuLmxheWVycy5hcnJheS5sZW5ndGgsMTUsMSksdT0oQmgoKSxQKEkoWXksMSksVywyMzIsMCxbcXksT0UsVnksVGYsWXAscXBdKSksZD0wLG09dS5sZW5ndGg7ZDxtOysrZClpZihpPXVbZF0sKGk9PVlwfHxpPT1xcHx8aT09VGYpJiYhYSgkaShvLmtleVNldCxpKT9vLnZhbHVlc1tpLm9yZGluYWxdOm51bGwsMTUpLmlzRW1wdHkoKSl7QXNuKGUsbik7YnJlYWt9Zm9yKGM9UChJKFl5LDEpLFcsMjMyLDAsW3F5LE9FLFZ5LFRmLFlwLHFwXSksZj0wLHk9Yy5sZW5ndGg7Zjx5OysrZilpPWNbZl0saT09WXB8fGk9PXFwfHxpPT1UZnx8QXZlKGUsYSgkaShvLmtleVNldCxpKT9vLnZhbHVlc1tpLm9yZGluYWxdOm51bGwsMTUpKTtmb3Iocz1QKEkoWXksMSksVywyMzIsMCxbcXksT0UsVnksVGYsWXAscXBdKSxfPTAsaD1zLmxlbmd0aDtfPGg7KytfKWk9c1tfXSwoaT09WXB8fGk9PXFwfHxpPT1UZikmJkF2ZShlLGEoJGkoby5rZXlTZXQsaSk/by52YWx1ZXNbaS5vcmRpbmFsXTpudWxsLDE1KSk7ZS5sYXllcldpZHRocz1udWxsLHIuZG9uZV8xKCl9ZnVuY3Rpb24gQXZlKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKCFuLmlzRW1wdHkoKSlpZihhKG4uZ2V0XzAoMCksMjkzKS5wbGFjZW1lbnRTdHJhdGVneT09KEJoKCksVGYpKWtzbihlLG4pO2Vsc2UgZm9yKHQ9bi5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspe3N3aXRjaChyPWEodC5uZXh0XzEoKSwyOTMpLHIucGxhY2VtZW50U3RyYXRlZ3kub3JkaW5hbCl7Y2FzZSA1OiR5KGUscixNc24oZSxyKSk7YnJlYWs7Y2FzZSAwOiR5KGUsciwocz1yLnJpZ2h0bW9zdExheWVySWQtci5sZWZ0bW9zdExheWVySWQrMSx1PShzLTEpLzJ8MCxyLmxlZnRtb3N0TGF5ZXJJZCt1KSk7YnJlYWs7Y2FzZSA0OiR5KGUscixEc24oZSxyKSk7YnJlYWs7Y2FzZSAyOkx2ZShyKSwkeShlLHIsKGk9VmoociksaT9yLmxlZnRtb3N0TGF5ZXJJZDpyLnJpZ2h0bW9zdExheWVySWQpKTticmVhaztjYXNlIDE6THZlKHIpLCR5KGUsciwobz1WaihyKSxvP3IucmlnaHRtb3N0TGF5ZXJJZDpyLmxlZnRtb3N0TGF5ZXJJZCkpfU9zbihyLmxhYmVsRHVtbXkpfX1mdW5jdGlvbiBMdmUoZSl7dmFyIG4scjtuPWUucGxhY2VtZW50U3RyYXRlZ3k9PShCaCgpLFZ5KSxyPVZqKGUpLG4mJiFyfHwhbiYmcj9qKGUubGFiZWxEdW1teSwob2UoKSxfdSksKCR1KCksYlQpKTpqKGUubGFiZWxEdW1teSwob2UoKSxfdSksKCR1KCksVFQpKX1mdW5jdGlvbiBCc24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGU7Zm9yKEg9ZS5sYXllcixxPW4ubGF5ZXIscj1mbyhILm5vZGVzLGUsMCksdD1mbyhxLm5vZGVzLG4sMCksaz1hKFUxKGUsKHF0KCksaWEpKS5pdGVyYXRvcl8wKCkubmV4dF8xKCksMTIpLHdlPWEoVTEoZSxwaSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSxNPWEoVTEobixpYSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSxEZT1hKFUxKG4scGkpLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSwxMikseD1jdShrLmluY29taW5nRWRnZXMpLG5lPWN1KHdlLm91dGdvaW5nRWRnZXMpLEE9Y3UoTS5pbmNvbWluZ0VkZ2VzKSx2ZT1jdShEZS5vdXRnb2luZ0VkZ2VzKSx3ZihlLHQscSkscz1BLGQ9MCx5PXMubGVuZ3RoO2Q8eTsrK2Qpbz1zW2RdLF90KG8sayk7Zm9yKHU9dmUsZj0wLEU9dS5sZW5ndGg7ZjxFOysrZilvPXVbZl0sTHQobyx3ZSk7Zm9yKHdmKG4scixIKSxjPXgsaD0wLHY9Yy5sZW5ndGg7aDx2OysraClvPWNbaF0sX3QobyxNKTtmb3IoaT1uZSxfPTAsbT1pLmxlbmd0aDtfPG07KytfKW89aVtfXSxMdChvLERlKX1mdW5jdGlvbiBrdmUoKXtSaCgpfWZ1bmN0aW9uIEdzbihlLG4pe3JldHVybiBSaCgpLG5ldyBPdmUobixlKX1mdW5jdGlvbiBIc24oZSxuKXtyZXR1cm4gUmgoKSxhKFp0KGUsbi5wbGFjZW1lbnRTdHJhdGVneSksMTUpLmFkZF8yKG4pfWZ1bmN0aW9uIFVzbihlLG4pe3JldHVybiBSaCgpLGlyKG4ubGFiZWxEdW1teS5zaXplXzAueF8wLGUubGFiZWxEdW1teS5zaXplXzAueF8wKX1wKDEzNzgsMSxzcixrdmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpeyRzbih0aGlzLGEobiwzNikscil9LGwubGF5ZXJXaWR0aHM9bnVsbDt2YXIgcDk7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsRHVtbXlTd2l0Y2hlciIsMTM3OCk7ZnVuY3Rpb24gV3NuKGUpe3ZhciBuO249ZS5sYWJlbER1bW15O2RvIG49YSh0bihuZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCkuc291cmNlLm93bmVyLG4udHlwZV8wPT0oV2UoKSxpdCkmJmUubGVmdExvbmdFZGdlRHVtbWllcy5hZGRfMihuKTt3aGlsZShuLnR5cGVfMD09KFdlKCksaXQpKTtlLmxlZnRMb25nRWRnZUR1bW1pZXM9cWEoZS5sZWZ0TG9uZ0VkZ2VEdW1taWVzKX1mdW5jdGlvbiBqc24oZSl7dmFyIG47bj1lLmxhYmVsRHVtbXk7ZG8gbj1hKHRuKG5ldyBYZShRZShScihuKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KS50YXJnZXQub3duZXIsbi50eXBlXzA9PShXZSgpLGl0KSYmZWUoZS5yaWdodExvbmdFZGdlRHVtbWllcyxuKTt3aGlsZShuLnR5cGVfMD09KFdlKCksaXQpKX1mdW5jdGlvbiBWc24oZSxuKXtyZXR1cm4gbjxlLmxlZnRMb25nRWRnZUR1bW1pZXMuc2l6ZV8xKCk/YShlLmxlZnRMb25nRWRnZUR1bW1pZXMuZ2V0XzAobiksMTApOm49PWUubGVmdExvbmdFZGdlRHVtbWllcy5zaXplXzEoKT9lLmxhYmVsRHVtbXk6YShsZShlLnJpZ2h0TG9uZ0VkZ2VEdW1taWVzLG4tZS5sZWZ0TG9uZ0VkZ2VEdW1taWVzLnNpemVfMSgpLTEpLDEwKX1mdW5jdGlvbiBPdmUoZSxuKXt2YXIgcix0O2Zvcih0aGlzLmxlZnRMb25nRWRnZUR1bW1pZXM9bmV3IFEsdGhpcy5yaWdodExvbmdFZGdlRHVtbWllcz1uZXcgUSx0aGlzLmxhYmVsRHVtbXk9ZSx0aGlzLnBsYWNlbWVudFN0cmF0ZWd5PW4sV3NuKHRoaXMpLGpzbih0aGlzKSx0aGlzLmxlZnRMb25nRWRnZUR1bW1pZXMuaXNFbXB0eSgpP3RoaXMubGVmdG1vc3RMYXllcklkPWUubGF5ZXIuaWRfMDp0aGlzLmxlZnRtb3N0TGF5ZXJJZD1hKHRoaXMubGVmdExvbmdFZGdlRHVtbWllcy5nZXRfMCgwKSwxMCkubGF5ZXIuaWRfMCx0aGlzLnJpZ2h0TG9uZ0VkZ2VEdW1taWVzLmFycmF5Lmxlbmd0aD09MD90aGlzLnJpZ2h0bW9zdExheWVySWQ9ZS5sYXllci5pZF8wOnRoaXMucmlnaHRtb3N0TGF5ZXJJZD1hKGxlKHRoaXMucmlnaHRMb25nRWRnZUR1bW1pZXMsdGhpcy5yaWdodExvbmdFZGdlRHVtbWllcy5hcnJheS5sZW5ndGgtMSksMTApLmxheWVyLmlkXzAsdD1hKHcoZSwoSygpLFVFKSksMTUpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylpZihyPWEodC5uZXh0XzEoKSw3MiksX3Iociwob2UoKSx2UCkpKXt0aGlzLnBsYWNlbWVudFN0cmF0ZWd5PWEodyhyLHZQKSwyMzIpO2JyZWFrfX1wKDI5MywxLHsyOTM6MX0sT3ZlKSxsLmxlZnRtb3N0TGF5ZXJJZD0wLGwucGxhY2VtZW50U3RyYXRlZ3k9bnVsbCxsLnJpZ2h0bW9zdExheWVySWQ9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGFiZWxEdW1teVN3aXRjaGVyL0xhYmVsRHVtbXlJbmZvIiwyOTMpO2Z1bmN0aW9uIE12ZSgpe31wKDEzNzksMSx7fSxNdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gUmgoKSxuZXcgU2UobnVsbCxuZXcgeGUoYShuLDMwKS5ub2RlcywxNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGFiZWxEdW1teVN3aXRjaGVyL2xhbWJkYSQwJFR5cGUiLDEzNzkpO2Z1bmN0aW9uIFJ2ZSgpe31wKDEzODAsMSxJbixSdmUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBSaCgpLGEobiwxMCkudHlwZV8wPT0oV2UoKSxZbyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbER1bW15U3dpdGNoZXIvbGFtYmRhJDEkVHlwZSIsMTM4MCk7ZnVuY3Rpb24gRHZlKGUpe3RoaXMuZGVmYXVsdFBsYWNlbWVudFN0cmF0ZWd5XzA9ZX1wKDEzODEsMSx7fSxEdmUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gR3NuKHRoaXMuZGVmYXVsdFBsYWNlbWVudFN0cmF0ZWd5XzAsYShuLDEwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbER1bW15U3dpdGNoZXIvbGFtYmRhJDIkVHlwZSIsMTM4MSk7ZnVuY3Rpb24gRnZlKGUpe3RoaXMuaW5mb3NfMD1lfXAoMTM4MiwxLEplLEZ2ZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7SHNuKHRoaXMuaW5mb3NfMCxhKG4sMjkzKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbER1bW15U3dpdGNoZXIvbGFtYmRhJDMkVHlwZSIsMTM4Mik7ZnVuY3Rpb24genZlKCl7fXAoMTM4MywxLE5uLHp2ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gVXNuKGEobiwyOTMpLGEociwyOTMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGFiZWxEdW1teVN3aXRjaGVyL2xhbWJkYSQ0JFR5cGUiLDEzODMpO2Z1bmN0aW9uIHFzbihlLG4pe24uYmVnaW4oIkxhYmVsIG1hbmFnZW1lbnQiLDEpLGVJKHcoZSwoVk4oKSxNdikpKSxuLmRvbmVfMSgpfWZ1bmN0aW9uICR2ZSgpe31wKDgwMiwxLHNyLCR2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cXNuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYWJlbE1hbmFnZW1lbnRQcm9jZXNzb3IiLDgwMik7ZnVuY3Rpb24gWXNuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2ZvcihjPU51KGUudGFpbC1lLmhlYWQmZS5hcnJheS5sZW5ndGgtMSksXz1udWxsLGQ9bnVsbCxpPW5ldyBYMihlKTtpLmN1cnJlbnRJbmRleCE9aS5mZW5jZTspbz1hKEpJKGkpLDEwKSxyPSh1PWEodyhvLChLKCksZHMpKSwxMiksdT91Lm93bmVyOm51bGwpLHQ9KHM9YSh3KG8sdmwpLDEyKSxzP3Mub3duZXI6bnVsbCksKF8hPXJ8fGQhPXQpJiYoR3ZlKGMsbiksXz1yLGQ9dCksUmUoYy5hcnJheSxvKTtHdmUoYyxuKX1mdW5jdGlvbiAkNChlLG4pe3ZhciByLHQ7Zm9yKHQ9ZS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksNzIpLGoociwoSygpLGpoKSxuKX1mdW5jdGlvbiBCdmUoZSxuKXt2YXIgcix0O2Zvcih0PW5ldyBUKGUubGFiZWxzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksNzIpLGoociwoSygpLGpoKSxuKX1mdW5jdGlvbiBEaChlLG4pe3ZhciByLHQsbyxpLHMsdTtpZihlLnR5cGVfMD09KFdlKCksWW8pJiYocj1lLnR5cGVfMD09WW8mJiFQeShKbihhKHcoZSwoSygpLFVFKSksMTUpLnN0cmVhbSgpLG5ldyBieShuZXcgQlcpKSkudHJ5QWR2YW5jZSgoTV8oKSxJaCkpPyhEYSgpLFJUKTpuLGooZSwoSygpLGpoKSxyKSxyIT0oRGEoKSxqMCkpKWZvcih0PWEodyhlLFFuKSwxOCksdT1SKCQodyh0LChvZSgpLFVjKSkpKSxzPTAscj09QnU/cz1lLnNpemVfMC55XzAtUy5NYXRoLmNlaWwodS8yKTpyPT1SVCYmKHM9Uy5NYXRoLmNlaWwoZS5zaXplXzAueV8wLVIoJCh3KFN0KGUpLHRnKSkpLXUpLzIsZS5zaXplXzAueV8wLT1SKCQodyhTdChlKSx0ZykpKSxlLnNpemVfMC55XzAtPXUpLGk9bmV3IFQoZS5wb3J0cyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEyKSxvLnBvcy55XzA9c31mdW5jdGlvbiBHdmUoZSxuKXt2YXIgcix0O2lmKGUuYXJyYXkubGVuZ3RoIT0wKXtpZihlLmFycmF5Lmxlbmd0aD09MilEaCgoQWUoMCxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzBdLDEwKSksKERhKCksQnUpKSxEaCgoQWUoMSxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzFdLDEwKSksajApO2Vsc2UgZm9yKHQ9bmV3IFQoZSk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDEwKSxEaChyLG4pO2UuYXJyYXkubGVuZ3RoPTB9fWZ1bmN0aW9uIEh2ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtmb3IoaT1uZXcgVChlLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwzMCksdT1uZXcgVChvLm5vZGVzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHM9YShDKHUpLDEwKSxzLnR5cGVfMD09KFdlKCksWW8pJiYoYz0oXz1hKHRuKG5ldyBYZShRZSh0dChzKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KSxkPWEodG4obmV3IFhlKFFlKFJyKHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpLCFhZShpZSh3KF8sKEsoKSxPcykpKSl8fCFhZShpZSh3KGQsT3MpKSk/bjp2RmUobikpLERoKHMsYykpLHQ9bmV3IFhlKFFlKFJyKHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSxjPWFlKGllKHcociwoSygpLE9zKSkpKT92RmUobik6bixCdmUocixjKX1mdW5jdGlvbiBLc24oZSxuKXt2YXIgcjtzd2l0Y2gocj1hKHcoZSwob2UoKSxTUCkpLDI4Myksbi5iZWdpbigiTGFiZWwgc2lkZSBzZWxlY3Rpb24gKCIrcisiKSIsMSksci5vcmRpbmFsKXtjYXNlIDA6VXZlKGUsKERhKCksQnUpKTticmVhaztjYXNlIDE6VXZlKGUsKERhKCksajApKTticmVhaztjYXNlIDI6SHZlKGUsKERhKCksQnUpKTticmVhaztjYXNlIDM6SHZlKGUsKERhKCksajApKTticmVhaztjYXNlIDQ6V3ZlKGUsKERhKCksQnUpKTticmVhaztjYXNlIDU6V3ZlKGUsKERhKCksajApKX1uLmRvbmVfMSgpfWZ1bmN0aW9uIFV2ZShlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3IoaT1uZXcgVChlLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwzMCksdT1uZXcgVChvLm5vZGVzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHM9YShDKHUpLDEwKSxzLnR5cGVfMD09KFdlKCksWW8pJiZEaChzLG4pLHQ9bmV3IFhlKFFlKFJyKHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSxCdmUocixuKX1mdW5jdGlvbiBXdmUoZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3Iocj1uZXcgQXAsaT1uZXcgVChlLmxheWVycyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iobz1hKEMoaSksMzApLGM9ITAsdD0wLHU9bmV3IFQoby5ub2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXN3aXRjaChzPWEoQyh1KSwxMCkscy50eXBlXzAub3JkaW5hbCl7Y2FzZSA0OisrdDtjYXNlIDE6TEIocixzKTticmVhaztjYXNlIDA6WHNuKHMsbik7ZGVmYXVsdDpyLmhlYWQ9PXIudGFpbHx8anZlKHIsdCxjLCExLG4pLGM9ITEsdD0wfXIuaGVhZD09ci50YWlsfHxqdmUocix0LGMsITAsbil9fWZ1bmN0aW9uIGp2ZShlLG4scix0LG8pe3ImJighdHx8KGUudGFpbC1lLmhlYWQmZS5hcnJheS5sZW5ndGgtMSk+MSkmJm49PTEmJmEoZS5hcnJheVtlLmhlYWRdLDEwKS50eXBlXzA9PShXZSgpLFlvKT9EaChhKGUuYXJyYXlbZS5oZWFkXSwxMCksKERhKCksQnUpKTp0JiYoIXJ8fChlLnRhaWwtZS5oZWFkJmUuYXJyYXkubGVuZ3RoLTEpPjEpJiZuPT0xJiZhKGUuYXJyYXlbZS50YWlsLTEmZS5hcnJheS5sZW5ndGgtMV0sMTApLnR5cGVfMD09KFdlKCksWW8pP0RoKGEoZS5hcnJheVtlLnRhaWwtMSZlLmFycmF5Lmxlbmd0aC0xXSwxMCksKERhKCksajApKTooZS50YWlsLWUuaGVhZCZlLmFycmF5Lmxlbmd0aC0xKT09Mj8oRGgoYShLMihlKSwxMCksKERhKCksQnUpKSxEaChhKEsyKGUpLDEwKSxqMCkpOllzbihlLG8pLGtCKGUpfWZ1bmN0aW9uIFhzbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHQ9bmV3IFpjZShlLnBvcnRzLmFycmF5Lmxlbmd0aCkscj1udWxsLGk9bmV3IFQoZS5wb3J0cyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEyKSxvLnNpZGUhPXImJih0LmhlYWQ9PXQudGFpbHx8VnZlKHQscixuKSxrQih0KSxyPW8uc2lkZSkscz1aMmUobykscyYmTEIodCxzKTt0LmhlYWQ9PXQudGFpbHx8VnZlKHQscixuKX1mdW5jdGlvbiBWdmUoZSxuLHIpe3ZhciB0LG87aWYoKGUudGFpbC1lLmhlYWQmZS5hcnJheS5sZW5ndGgtMSk9PTIpbj09KHJlKCksVWUpfHxuPT1xZT8oJDQoYShLMihlKSwxNSksKERhKCksQnUpKSwkNChhKEsyKGUpLDE1KSxqMCkpOigkNChhKEsyKGUpLDE1KSwoRGEoKSxqMCkpLCQ0KGEoSzIoZSksMTUpLEJ1KSk7ZWxzZSBmb3Iobz1uZXcgWDIoZSk7by5jdXJyZW50SW5kZXghPW8uZmVuY2U7KXQ9YShKSShvKSwxNSksJDQodCxyKX1mdW5jdGlvbiBxdmUoKXt9cCgxNjE0LDEsc3IscXZlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtLc24oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIkxhYmVsU2lkZVNlbGVjdG9yIiwxNjE0KTtmdW5jdGlvbiBKc24oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQsZixoO2ZvcihzPW5ldyBUKGUubGF5ZXJzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGk9YShDKHMpLDMwKSxoPWMzKGkubm9kZXMpLF89aCxkPTAsZj1fLmxlbmd0aDtkPGY7KytkKXN3aXRjaChjPV9bZF0sYSh3KGMsKG9lKCksRWkpKSwxNzEpLm9yZGluYWwpe2Nhc2UgMTpldW4oYyksaHQoYyxuKSxZdmUoYywhMCx0KTticmVhaztjYXNlIDM6bnVuKGMpLGh0KGMsciksWXZlKGMsITEsbyl9Zm9yKHU9bmV3IHB0KGUubGF5ZXJzLDApO3UuaTx1LnRoaXMkMDFfMC5zaXplXzEoKTspKHJuKHUuaTx1LnRoaXMkMDFfMC5zaXplXzEoKSksYSh1LnRoaXMkMDFfMC5nZXRfMCh1Lmxhc3Q9dS5pKyspLDMwKSkubm9kZXMuYXJyYXkubGVuZ3RoPT0wJiZFYSh1KX1mdW5jdGlvbiBZdmUoZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1uZXcgWGUoUWUoKG4/dHQoZSk6UnIoZSkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihvKTspdD1hKHRuKG8pLDE4KSxpPW4/dC5zb3VyY2Uub3duZXI6dC50YXJnZXQub3duZXIsaS50eXBlXzA9PShXZSgpLFlvKSYmaHQoaSxyKX1mdW5jdGlvbiBac24oZSxuKXt2YXIgcix0LG8saSxzLHUsYztuLmJlZ2luKCJMYXllciBjb25zdHJhaW50IHBvc3Rwcm9jZXNzaW5nIiwxKSxjPWUubGF5ZXJzLGMuYXJyYXkubGVuZ3RoIT0wJiYodD0oQWUoMCxjLmFycmF5Lmxlbmd0aCksYShjLmFycmF5WzBdLDMwKSkscz1hKGxlKGMsYy5hcnJheS5sZW5ndGgtMSksMzApLHI9bmV3IG9pKGUpLGk9bmV3IG9pKGUpLEpzbihlLHQscyxyLGkpLHIubm9kZXMuYXJyYXkubGVuZ3RoPT0wfHwoZGYoMCxjLmFycmF5Lmxlbmd0aCksb0UoYy5hcnJheSwwLHIpKSxpLm5vZGVzLmFycmF5Lmxlbmd0aD09MHx8UmUoYy5hcnJheSxpKSksX3IoZSwoSygpLHVPKSkmJihvPW5ldyBvaShlKSx1PW5ldyBvaShlKSxRc24oZSxvLHUpLG8ubm9kZXMuYXJyYXkubGVuZ3RoPT0wfHwoZGYoMCxjLmFycmF5Lmxlbmd0aCksb0UoYy5hcnJheSwwLG8pKSx1Lm5vZGVzLmFycmF5Lmxlbmd0aD09MHx8UmUoYy5hcnJheSx1KSksbi5kb25lXzEoKX1mdW5jdGlvbiBRc24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3Iocz1hKHcoZSwoSygpLHVPKSksMTUpLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOyl7c3dpdGNoKGk9YShzLm5leHRfMSgpLDEwKSxhKHcoaSwob2UoKSxFaSkpLDE3MSkub3JkaW5hbCl7Y2FzZSAyOmh0KGksbik7YnJlYWs7Y2FzZSA0Omh0KGkscil9Zm9yKG89bmV3IFhlKFFlKGljKGkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihvKTspdD1hKHRuKG8pLDE4KSwhKHQuc291cmNlJiZ0LnRhcmdldCkmJih1PSF0LnRhcmdldCxjPWEodyh0LG9xKSwxMiksdT9fdCh0LGMpOkx0KHQsYykpfX1mdW5jdGlvbiBldW4oZSl7dmFyIG4scjtmb3Iocj1uZXcgWGUoUWUodHQoZSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHIpOylpZihuPWEodG4ociksMTgpLG4uc291cmNlLm93bmVyLnR5cGVfMCE9KFdlKCksWW8pKXRocm93IGIobmV3IEtjKCJOb2RlICciK18zKGUpKyInIGhhcyBpdHMgbGF5ZXIgY29uc3RyYWludCBzZXQgdG8gRklSU1QsIGJ1dCBoYXMgYXQgbGVhc3Qgb25lIGluY29taW5nIGVkZ2UgdGhhdCAgZG9lcyBub3QgY29tZSBmcm9tIGEgRklSU1RfU0VQQVJBVEUgbm9kZS4gVGhhdCBtdXN0IG5vdCBoYXBwZW4uIikpfWZ1bmN0aW9uIG51bihlKXt2YXIgbixyO2ZvcihyPW5ldyBYZShRZShScihlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocik7KWlmKG49YSh0bihyKSwxOCksbi50YXJnZXQub3duZXIudHlwZV8wIT0oV2UoKSxZbykpdGhyb3cgYihuZXcgS2MoIk5vZGUgJyIrXzMoZSkrIicgaGFzIGl0cyBsYXllciBjb25zdHJhaW50IHNldCB0byBMQVNULCBidXQgaGFzIGF0IGxlYXN0IG9uZSBvdXRnb2luZyBlZGdlIHRoYXQgIGRvZXMgbm90IGdvIHRvIGEgTEFTVF9TRVBBUkFURSBub2RlLiBUaGF0IG11c3Qgbm90IGhhcHBlbi4iKSl9ZnVuY3Rpb24gS3ZlKCl7fXAoMTYyMiwxLHNyLEt2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7WnNuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYXllckNvbnN0cmFpbnRQb3N0cHJvY2Vzc29yIiwxNjIyKTtmdW5jdGlvbiBYdmUoKXtYdmU9Rixxaj1uZXcgdnIoInNlcGFyYXRlTGF5ZXJDb25uZWN0aW9ucyIsKEI0KCksZzkpKX1mdW5jdGlvbiBydW4oZSl7dmFyIG4scix0LG8saTtpZih0PWEodyhlLChvZSgpLEVpKSksMTcxKSx0PT0ocmwoKSxGMCkpe2ZvcihyPW5ldyBYZShRZSh0dChlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocik7KWlmKG49YSh0bihyKSwxOCksIUp2ZShuKSl0aHJvdyBiKG5ldyBLYygiTm9kZSAnIitfMyhlKSsiJyBoYXMgaXRzIGxheWVyIGNvbnN0cmFpbnQgc2V0IHRvIEZJUlNUX1NFUEFSQVRFLCBidXQgaGFzIGF0IGxlYXN0IG9uZSBpbmNvbWluZyBlZGdlLiBGSVJTVF9TRVBBUkFURSBub2RlcyBtdXN0IG5vdCBoYXZlIGluY29taW5nIGVkZ2VzLiIpKX1lbHNlIGlmKHQ9PXhmKXtmb3IoaT1uZXcgWGUoUWUoUnIoZSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylpZihvPWEodG4oaSksMTgpLCFKdmUobykpdGhyb3cgYihuZXcgS2MoIk5vZGUgJyIrXzMoZSkrIicgaGFzIGl0cyBsYXllciBjb25zdHJhaW50IHNldCB0byBMQVNUX1NFUEFSQVRFLCBidXQgaGFzIGF0IGxlYXN0IG9uZSBvdXRnb2luZyBlZGdlLiBMQVNUX1NFUEFSQVRFIG5vZGVzIG11c3Qgbm90IGhhdmUgb3V0Z29pbmcgZWRnZXMuIikpfX1mdW5jdGlvbiB0dW4oZSl7dmFyIG4scix0LG87Zm9yKHJ1bihlKSxyPW5ldyBYZShRZShpYyhlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocik7KW49YSh0bihyKSwxOCksdD1uLnNvdXJjZS5vd25lcj09ZSxvPXQ/bi50YXJnZXQ6bi5zb3VyY2UsdD9fdChuLG51bGwpOkx0KG4sbnVsbCksaihuLChLKCksb3EpLG8pLGF1bihlLG8ub3duZXIpfWZ1bmN0aW9uIEp2ZShlKXt2YXIgbixyO3JldHVybiBuPWUuc291cmNlLm93bmVyLHI9ZS50YXJnZXQub3duZXIsbi50eXBlXzA9PShXZSgpLEZyKSYmci50eXBlXzA9PUZyfWZ1bmN0aW9uIG91bihlKXtzd2l0Y2goYSh3KGUsKG9lKCksRWkpKSwxNzEpLm9yZGluYWwpe2Nhc2UgMjpjYXNlIDQ6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gaXVuKGUsbil7dmFyIHIsdCxvO2ZvcihuLmJlZ2luKCJMYXllciBjb25zdHJhaW50IHByZXByb2Nlc3NpbmciLDEpLHI9bmV3IFEsbz1uZXcgcHQoZS5sYXllcmxlc3NOb2RlcywwKTtvLmk8by50aGlzJDAxXzAuc2l6ZV8xKCk7KXQ9KHJuKG8uaTxvLnRoaXMkMDFfMC5zaXplXzEoKSksYShvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspLDEwKSksb3VuKHQpJiYodHVuKHQpLFJlKHIuYXJyYXksdCksRWEobykpO3IuYXJyYXkubGVuZ3RoPT0wfHxqKGUsKEsoKSx1Tyksciksbi5kb25lXzEoKX1mdW5jdGlvbiBhdW4oZSxuKXt2YXIgcjtpZighX3Iobiwob2UoKSxFaSkpJiYocj1sdW4oYSh3KG4scWopLDM3MSksYSh3KGUsRWkpLDE3MSkpLGoobixxaixyKSwhX24obmV3IFhlKFFlKGljKG4pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpKXN3aXRjaChyLm9yZGluYWwpe2Nhc2UgMTpqKG4sRWksKHJsKCksV0UpKTticmVhaztjYXNlIDI6aihuLEVpLChybCgpLGpFKSl9fWZ1bmN0aW9uIFp2ZSgpe1h2ZSgpfXAoMTYyMywxLHNyLFp2ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7aXVuKGEobiwzNikscil9O3ZhciBxajtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGF5ZXJDb25zdHJhaW50UHJlcHJvY2Vzc29yIiwxNjIzKTtmdW5jdGlvbiBCNCgpe0I0PUYsZzk9bmV3IEc0KCJOT05FIiwwKSxIND1uZXcgRzQoIkZJUlNUX1NFUEFSQVRFIiwxKSxVND1uZXcgRzQoIkxBU1RfU0VQQVJBVEUiLDIpLG0zPW5ldyBHNCgiQk9USCIsMyl9ZnVuY3Rpb24gbHVuKGUsbil7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuPT0ocmwoKSxGMCk/SDQ6VTQ7Y2FzZSAxOnJldHVybiBuPT0ocmwoKSxGMCk/SDQ6bTM7Y2FzZSAyOnJldHVybiBuPT0ocmwoKSxGMCk/bTM6VTQ7ZGVmYXVsdDpyZXR1cm4gbTN9fWZ1bmN0aW9uIEc0KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gc3VuKGUpe3JldHVybiBCNCgpLHduKChlU2UoKSxuU2UpLGUpfWZ1bmN0aW9uIHV1bigpe3JldHVybiBCNCgpLFAoSShRdmUsMSksVywzNzEsMCxbZzksSDQsVTQsbTNdKX1wKDM3MSwyMix7MzoxLDM0OjEsMjI6MSwzNzE6MX0sRzQpO3ZhciBtMyxINCxVNCxnOSxRdmU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJMYXllckNvbnN0cmFpbnRQcmVwcm9jZXNzb3IvSGlkZGVuTm9kZUNvbm5lY3Rpb25zIiwzNzEsZ24sdXVuLHN1bik7ZnVuY3Rpb24gZVNlKCl7ZVNlPUYsblNlPXluKChCNCgpLFAoSShRdmUsMSksVywzNzEsMCxbZzksSDQsVTQsbTNdKSkpfXZhciBuU2U7ZnVuY3Rpb24gY3VuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3Iobi5iZWdpbigiTGF5ZXIgc2l6ZSBjYWxjdWxhdGlvbiIsMSksZD1ocixfPVZyLG89ITEsdT1uZXcgVChlLmxheWVycyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHM9YShDKHUpLDMwKSxjPXMuc2l6ZV8wLGMueF8wPTAsYy55XzA9MCxzLm5vZGVzLmFycmF5Lmxlbmd0aCE9MCl7Zm9yKG89ITAsaD1uZXcgVChzLm5vZGVzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksMTApLHk9Zi5zaXplXzAsbT1mLm1hcmdpbixjLnhfMD1TLk1hdGgubWF4KGMueF8wLHkueF8wK20ubGVmdCttLnJpZ2h0KTt0PWEobGUocy5ub2RlcywwKSwxMCksRT10LnBvcy55XzAtdC5tYXJnaW4udG9wXzAsdC50eXBlXzA9PShXZSgpLEZyKSYmKEUtPWEodyhlLChvZSgpLEYzKSksMTQwKS50b3BfMCksaT1hKGxlKHMubm9kZXMscy5ub2Rlcy5hcnJheS5sZW5ndGgtMSksMTApLHI9aS5wb3MueV8wK2kuc2l6ZV8wLnlfMCtpLm1hcmdpbi5ib3R0b20saS50eXBlXzA9PUZyJiYocis9YSh3KGUsKG9lKCksRjMpKSwxNDApLmJvdHRvbSksYy55XzA9ci1FLGQ9Uy5NYXRoLm1pbihkLEUpLF89Uy5NYXRoLm1heChfLHIpfW98fChkPTAsXz0wKSxlLnNpemVfMC55XzA9Xy1kLGUub2Zmc2V0LnlfMC09ZCxuLmRvbmVfMSgpfWZ1bmN0aW9uIHJTZSgpe31wKDE2MjQsMSxzcixyU2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe2N1bihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTGF5ZXJTaXplQW5kR3JhcGhIZWlnaHRDYWxjdWxhdG9yIiwxNjI0KTtmdW5jdGlvbiBfdW4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihuLmJlZ2luKCJFZGdlIGpvaW5pbmciLDEpLHI9YWUoaWUodyhlLChvZSgpLEFPKSkpKSxvPW5ldyBUKGUubGF5ZXJzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9YShDKG8pLDMwKSxzPW5ldyBwdCh0Lm5vZGVzLDApO3MuaTxzLnRoaXMkMDFfMC5zaXplXzEoKTspaT0ocm4ocy5pPHMudGhpcyQwMV8wLnNpemVfMSgpKSxhKHMudGhpcyQwMV8wLmdldF8wKHMubGFzdD1zLmkrKyksMTApKSxpLnR5cGVfMD09KFdlKCksaXQpJiYoaDkoaSxyKSxFYShzKSk7bi5kb25lXzEoKX1mdW5jdGlvbiB0U2UoKXt9ZnVuY3Rpb24gaDkoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKGM9YSgkYyhlLChyZSgpLGplKSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKS5pbmNvbWluZ0VkZ2VzLG09YSgkYyhlLHFlKS5pdGVyYXRvcl8wKCkubmV4dF8xKCksMTIpLm91dGdvaW5nRWRnZXMsdT1jLmFycmF5Lmxlbmd0aCxrPUFzKGEobGUoZS5wb3J0cywwKSwxMikpO3UtLSA+MDspe2ZvcihFPShBZSgwLGMuYXJyYXkubGVuZ3RoKSxhKGMuYXJyYXlbMF0sMTgpKSxvPShBZSgwLG0uYXJyYXkubGVuZ3RoKSxhKG0uYXJyYXlbMF0sMTgpKSxBPW8udGFyZ2V0LmluY29taW5nRWRnZXMsaT1mbyhBLG8sMCksSmluKEUsby50YXJnZXQsaSksTHQobyxudWxsKSxfdChvLG51bGwpLHk9RS5iZW5kUG9pbnRzLG4mJkxuKHksbmV3IFJ0KGspKSx0PWRuKG8uYmVuZFBvaW50cywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDgpLExuKHksbmV3IFJ0KHIpKTtmb3IoeD1FLmxhYmVscyxoPW5ldyBUKG8ubGFiZWxzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksNzIpLFJlKHguYXJyYXksZik7aWYodj1hKHcoRSwob2UoKSxpbykpLDc1KSxzPWEodyhvLGlvKSw3NSkscylmb3Iodnx8KHY9bmV3IGppLGooRSxpbyx2KSksZD1kbihzLDApO2QuY3VycmVudE5vZGUhPWQudGhpcyQwMS50YWlsOylfPWEodW4oZCksOCksTG4odixuZXcgUnQoXykpfX1wKDE2MjUsMSxzcix0U2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe191bihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTG9uZ0VkZ2VKb2luZXIiLDE2MjUpO2Z1bmN0aW9uIGR1bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtpZihuLmJlZ2luKCJFZGdlIHNwbGl0dGluZyIsMSksZS5sYXllcnMuYXJyYXkubGVuZ3RoPD0yKXtuLmRvbmVfMSgpO3JldHVybn1mb3IoaT1uZXcgcHQoZS5sYXllcnMsMCkscz0ocm4oaS5pPGkudGhpcyQwMV8wLnNpemVfMSgpKSxhKGkudGhpcyQwMV8wLmdldF8wKGkubGFzdD1pLmkrKyksMzApKTtpLmk8aS50aGlzJDAxXzAuc2l6ZV8xKCk7KWZvcihvPXMscz0ocm4oaS5pPGkudGhpcyQwMV8wLnNpemVfMSgpKSxhKGkudGhpcyQwMV8wLmdldF8wKGkubGFzdD1pLmkrKyksMzApKSxjPW5ldyBUKG8ubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodT1hKEMoYyksMTApLGQ9bmV3IFQodS5wb3J0cyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihfPWEoQyhkKSwxMiksdD1uZXcgVChfLm91dGdvaW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxOCksaD1yLnRhcmdldCxmPWgub3duZXIubGF5ZXIsZiE9byYmZiE9cyYmaVNlKHIsKG09bmV3IGFjKGUpLHpfKG0sKFdlKCksaXQpKSxqKG0sKEsoKSxRbiksciksaihtLChvZSgpLHhyKSwoZHQoKSxhaSkpLGh0KG0scyksbSkpO24uZG9uZV8xKCl9ZnVuY3Rpb24gb1NlKCl7fWZ1bmN0aW9uIGZ1bihlLG4pe3ZhciByLHQsbztmb3IodD1uZXcgcHQoZS5sYWJlbHMsMCk7dC5pPHQudGhpcyQwMV8wLnNpemVfMSgpOylyPShybih0Lmk8dC50aGlzJDAxXzAuc2l6ZV8xKCkpLGEodC50aGlzJDAxXzAuZ2V0XzAodC5sYXN0PXQuaSsrKSw3MikpLG89YSh3KHIsKG9lKCksZHUpKSwyNzgpLG89PShHcygpLFZmKSYmKEVhKHQpLGVlKG4ubGFiZWxzLHIpLF9yKHIsKEsoKSxVaCkpfHxqKHIsVWgsZSkpfWZ1bmN0aW9uIHB1bihlLG4scil7dmFyIHQsbzt0PW4uc291cmNlLm93bmVyLG89ci50YXJnZXQub3duZXIsdC50eXBlXzA9PShXZSgpLGl0KT8oaihlLChLKCksZHMpLGEodyh0LGRzKSwxMikpLGooZSx2bCxhKHcodCx2bCksMTIpKSxqKGUsSWYsaWUodyh0LElmKSkpKTp0LnR5cGVfMD09WW8/KGooZSwoSygpLGRzKSxhKHcodCxkcyksMTIpKSxqKGUsdmwsYSh3KHQsdmwpLDEyKSksaihlLElmLCh6ZSgpLCEwKSkpOm8udHlwZV8wPT1Zbz8oaihlLChLKCksZHMpLGEodyhvLGRzKSwxMikpLGooZSx2bCxhKHcobyx2bCksMTIpKSxqKGUsSWYsKHplKCksITApKSk6KGooZSwoSygpLGRzKSxuLnNvdXJjZSksaihlLHZsLHIudGFyZ2V0KSl9ZnVuY3Rpb24gaVNlKGUsbil7dmFyIHIsdCxvLGkscyx1O3JldHVybiBpPWUudGFyZ2V0LHU9UigkKHcoZSwob2UoKSxVYykpKSksdTwwJiYodT0wLGooZSxVYyx1KSksbi5zaXplXzAueV8wPXUscz1TLk1hdGguZmxvb3IodS8yKSx0PW5ldyBabyxYcih0LChyZSgpLGplKSksTG8odCxuKSx0LnBvcy55XzA9cyxvPW5ldyBabyxYcihvLHFlKSxMbyhvLG4pLG8ucG9zLnlfMD1zLF90KGUsdCkscj1uZXcgSDEsZ28ocixlKSxqKHIsaW8sbnVsbCksTHQocixvKSxfdChyLGkpLHB1bihuLGUsciksZnVuKGUscikscn1wKDE2MjYsMSxzcixvU2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe2R1bihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTG9uZ0VkZ2VTcGxpdHRlciIsMTYyNik7ZnVuY3Rpb24gVzQoKXtXND1GLF9TZT1uZXcgZFNlLGNTZT1uZXcgZlNlfWZ1bmN0aW9uIGFTZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO009ITE7ZG8gZm9yKE09ITEsaT1uP25ldyBrXyhlLmJpTGF5ZXJNYXAubXVsdGlNYXBLZXlUb1ZhbHVlcykudGhpcyQwMS5zaXplXzEoKS0yOjE7bj9pPj0wOmk8bmV3IGtfKGUuYmlMYXllck1hcC5tdWx0aU1hcEtleVRvVmFsdWVzKS50aGlzJDAxLnNpemVfMSgpO2krPW4/LTE6MSlmb3Iobz1RVyhlLmJpTGF5ZXJNYXAsSihpKSksbT0wO208by5zaXplXzA7bSsrKWlmKGY9YShWYShvLG0pLDEwKSwhIV9yKGYsKEsoKSxycikpJiYhKGthbihlLmJpTGF5ZXJNYXAsSihpKSkmJmUucHJvbW90aW9uU3RyYXRlZ3k9PShTbCgpLGlkKXx8T2FuKGUuYmlMYXllck1hcCxKKGkpKSYmZS5wcm9tb3Rpb25TdHJhdGVneT09KFNsKCksRmYpKSl7Zm9yKGs9ITAseD0wO3g8by5zaXplXzA7eCsrKXY9YShWYShvLHgpLDEwKSxfcih2LHJyKSYmKG4mJmEodyhmLHJyKSwxNykudmFsdWVfMDxhKHcodixyciksMTcpLnZhbHVlXzB8fCFuJiZhKHcoZixyciksMTcpLnZhbHVlXzA+YSh3KHYscnIpLDE3KS52YWx1ZV8wKSYmKGs9ITEpO2lmKGspe2ZvcihjPW4/aSsxOmktMSx1PVFXKGUuYmlMYXllck1hcCxKKGMpKSxzPSExLEE9ITAsdD0hMSxkPWRuKHUsMCk7ZC5jdXJyZW50Tm9kZSE9ZC50aGlzJDAxLnRhaWw7KV89YSh1bihkKSwxMCksX3IoXyxycik/Xy5pZF8wIT1mLmlkXzAmJihzPXN8KG4/YSh3KF8scnIpLDE3KS52YWx1ZV8wPGEodyhmLHJyKSwxNykudmFsdWVfMDphKHcoXyxyciksMTcpLnZhbHVlXzA+YSh3KGYscnIpLDE3KS52YWx1ZV8wKSxBPSExKTohcyYmQSYmXy50eXBlXzA9PShXZSgpLFlvKSYmKHQ9ITAsbj9oPWEodG4obmV3IFhlKFFlKHR0KF8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpLnNvdXJjZS5vd25lcjpoPWEodG4obmV3IFhlKFFlKFJyKF8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpLnRhcmdldC5vd25lcixoPT1mJiYobj9yPWEodG4obmV3IFhlKFFlKFJyKF8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpLnRhcmdldC5vd25lcjpyPWEodG4obmV3IFhlKFFlKHR0KF8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpLnNvdXJjZS5vd25lciwobj9hKEVmKGUuYmlMYXllck1hcCxyKSwxNykudmFsdWVfMC1hKEVmKGUuYmlMYXllck1hcCxoKSwxNykudmFsdWVfMDphKEVmKGUuYmlMYXllck1hcCxoKSwxNykudmFsdWVfMC1hKEVmKGUuYmlMYXllck1hcCxyKSwxNykudmFsdWVfMCk8PTImJihBPSExKSkpO2lmKHQmJkEmJihuP3I9YSh0bihuZXcgWGUoUWUoUnIoZikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCkudGFyZ2V0Lm93bmVyOnI9YSh0bihuZXcgWGUoUWUodHQoZikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCkuc291cmNlLm93bmVyLChuP2EoRWYoZS5iaUxheWVyTWFwLHIpLDE3KS52YWx1ZV8wLWEoRWYoZS5iaUxheWVyTWFwLGYpLDE3KS52YWx1ZV8wOmEoRWYoZS5iaUxheWVyTWFwLGYpLDE3KS52YWx1ZV8wLWEoRWYoZS5iaUxheWVyTWFwLHIpLDE3KS52YWx1ZV8wKTw9MiYmci50eXBlXzA9PShXZSgpLGtyKSYmKEE9ITEpKSxzfHxBKXtmb3IoRT1zU2UoZSxmLG4pO0UubWFwXzAuc2l6ZV8xKCkhPTA7KXk9YShFLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEwKSxFLm1hcF8wLnJlbW92ZV8wKHkpIT1udWxsLGZ0KEUsc1NlKGUseSxuKSk7LS1tLE09ITB9fX13aGlsZShNKX1mdW5jdGlvbiBndW4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2ZvcihlLm5vZGVTaXplQWZmaXg9UigkKHcoZS5tYXN0ZXJHcmFwaCwob2UoKSxvZCkpKSksZS5kdW1teVNpemU9UigkKHcoZS5tYXN0ZXJHcmFwaCxxXykpKSxlLm1heEhlaWdodD1lLm1hc3RlckdyYXBoLmxheWVycy5hcnJheS5sZW5ndGgsdT1lLm1heEhlaWdodC0xLGg9MCxlLm1heFdpZHRoPTAsZS5tYXhXaWR0aFBpeGVsPTAsZS5jdXJyZW50V2lkdGg9VHMoQih2dCxYLDE3LGUubWF4SGVpZ2h0LDAsMSkpLGUuY3VycmVudFdpZHRoUGl4ZWw9VHMoQigkcixYLDM0NSxlLm1heEhlaWdodCw3LDEpKSxzPW5ldyBUKGUubWFzdGVyR3JhcGgubGF5ZXJzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihvPWEoQyhzKSwzMCksby5pZF8wPXUsZj1uZXcgVChvLm5vZGVzKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspZD1hKEMoZiksMTApLGQuaWRfMD1oLCsraDstLXV9Zm9yKGUubGF5ZXJzPUIoaG4sa24sMjgsaCwxNSwxKSxlLmRlZ3JlZURpZmY9Yl8oaG4sW1gsa25dLFs1MywyOF0sMTUsW2gsM10sMiksZS5ub2Rlcz1uZXcgUSxlLm5vZGVzV2l0aEluY29taW5nRWRnZXM9bmV3IFEsbj0wLGUuZHVtbXlOb2RlQ291bnQ9MCxpPW5ldyBUKGUubWFzdGVyR3JhcGgubGF5ZXJzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihvPWEoQyhpKSwzMCksdT1vLmlkXzAsdD0wLEU9MCxjPW8ubm9kZXMuYXJyYXkubGVuZ3RoLF89MCxmPW5ldyBUKG8ubm9kZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSwxMCksaD1kLmlkXzAsZS5sYXllcnNbaF09ZC5sYXllci5pZF8wLF8rPWQuc2l6ZV8wLnlfMCtlLm5vZGVTaXplQWZmaXgscj1adShuZXcgWGUoUWUodHQoZCkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSx5PVp1KG5ldyBYZShRZShScihkKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLGUuZGVncmVlRGlmZltoXVswXT15LXIsZS5kZWdyZWVEaWZmW2hdWzFdPXIsZS5kZWdyZWVEaWZmW2hdWzJdPXksdCs9cixFKz15LHI+MCYmZWUoZS5ub2Rlc1dpdGhJbmNvbWluZ0VkZ2VzLGQpLGVlKGUubm9kZXMsZCk7bi09dCxtPWMrbixfKz1uKmUuZHVtbXlTaXplLEthKGUuY3VycmVudFdpZHRoLHUsSihtKSksS2EoZS5jdXJyZW50V2lkdGhQaXhlbCx1LF8pLGUubWF4V2lkdGg9Uy5NYXRoLm1heChlLm1heFdpZHRoLG0pLGUubWF4V2lkdGhQaXhlbD1TLk1hdGgubWF4KGUubWF4V2lkdGhQaXhlbCxfKSxlLmR1bW15Tm9kZUNvdW50Kz1uLG4rPUV9fWZ1bmN0aW9uIGh1bihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF87Zm9yKGUuYmlMYXllck1hcD1uZXcgbmosXz0wLG89MCx0PW5ldyBUKGUubWFzdGVyR3JhcGgubGF5ZXJzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihuPWEoQyh0KSwzMCksbi5pZF8wPW8sYz1uZXcgVChuLm5vZGVzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoYyksMTApLHUuaWRfMD1fLCsrXzsrK299Zm9yKGk9ZS5wcm9tb3Rpb25TdHJhdGVneT09KFNsKCksaWQpLHM9aT9fU2U6Y1NlLHI9bmV3IFQoZS5tYXN0ZXJHcmFwaC5sYXllcnMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwzMCksRHIobi5ub2RlcyxzKSxNYW4oZS5iaUxheWVyTWFwLEoobi5pZF8wKSxuLm5vZGVzKX1mdW5jdGlvbiBtdW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO3N3aXRjaChyLmJlZ2luKCJOb2RlIHByb21vdGlvbiBoZXVyaXN0aWMiLDEpLGUubWFzdGVyR3JhcGg9bixlLnByb21vdGlvblN0cmF0ZWd5PWEodyhuLChvZSgpLHowKSksMjQzKSxlLnByb21vdGlvblN0cmF0ZWd5IT0oU2woKSxpZCkmJmUucHJvbW90aW9uU3RyYXRlZ3khPUZmP2d1bihlKTpodW4oZSksZD1hKHcoZS5tYXN0ZXJHcmFwaCx0WSksMTcpLnZhbHVlXzAsaT1uZXcgcFNlLGUucHJvbW90aW9uU3RyYXRlZ3kub3JkaW5hbCl7Y2FzZSAyOmNhc2UgMTpCeShlLGkpO2JyZWFrO2Nhc2UgMzpmb3IoZS5wcm9tb3Rpb25TdHJhdGVneT16UCxCeShlLGkpLGM9MCx1PW5ldyBUKGUuY3VycmVudFdpZHRoKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTcpLGM9Uy5NYXRoLm1heChjLHMudmFsdWVfMCk7Yz5lLm1heFdpZHRoJiYoZS5wcm9tb3Rpb25TdHJhdGVneT0kMyxCeShlLGkpKTticmVhaztjYXNlIDQ6Zm9yKGUucHJvbW90aW9uU3RyYXRlZ3k9elAsQnkoZSxpKSxfPTAsbz1uZXcgVChlLmN1cnJlbnRXaWR0aFBpeGVsKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD0kKEMobykpLF89Uy5NYXRoLm1heChfLChWZSh0KSx0KSk7Xz5lLm1heFdpZHRoUGl4ZWwmJihlLnByb21vdGlvblN0cmF0ZWd5PUIzLEJ5KGUsaSkpO2JyZWFrO2Nhc2UgNjpoPUtyKFMuTWF0aC5jZWlsKGUubGF5ZXJzLmxlbmd0aCpkLzEwMCkpLEJ5KGUsbmV3IGdTZShoKSk7YnJlYWs7Y2FzZSA1OmY9S3IoUy5NYXRoLmNlaWwoZS5kdW1teU5vZGVDb3VudCpkLzEwMCkpLEJ5KGUsbmV3IGhTZShmKSk7YnJlYWs7Y2FzZSA4OmFTZShlLCEwKTticmVhaztjYXNlIDk6YVNlKGUsITEpO2JyZWFrO2RlZmF1bHQ6QnkoZSxpKX1lLnByb21vdGlvblN0cmF0ZWd5IT1pZCYmZS5wcm9tb3Rpb25TdHJhdGVneSE9RmY/eXVuKGUsbik6d3VuKGUsbiksci5kb25lXzEoKX1mdW5jdGlvbiBsU2UoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3IoYz0hMCxvPTAsXz1lLmxheWVyc1tuLmlkXzBdLGQ9bi5zaXplXzAueV8wK2Uubm9kZVNpemVBZmZpeCxyPWUuZGVncmVlRGlmZltuLmlkXzBdWzJdLEthKGUuY3VycmVudFdpZHRoLF8sSihhKGxlKGUuY3VycmVudFdpZHRoLF8pLDE3KS52YWx1ZV8wLTErcikpLEthKGUuY3VycmVudFdpZHRoUGl4ZWwsXyxSKCQobGUoZS5jdXJyZW50V2lkdGhQaXhlbCxfKSkpLWQrciplLmR1bW15U2l6ZSksKytfLF8+PWUubWF4SGVpZ2h0PygrK2UubWF4SGVpZ2h0LGVlKGUuY3VycmVudFdpZHRoLEooMSkpLGVlKGUuY3VycmVudFdpZHRoUGl4ZWwsZCkpOih0PWUuZGVncmVlRGlmZltuLmlkXzBdWzFdLEthKGUuY3VycmVudFdpZHRoLF8sSihhKGxlKGUuY3VycmVudFdpZHRoLF8pLDE3KS52YWx1ZV8wKzEtdCkpLEthKGUuY3VycmVudFdpZHRoUGl4ZWwsXyxSKCQobGUoZS5jdXJyZW50V2lkdGhQaXhlbCxfKSkpK2QtdCplLmR1bW15U2l6ZSkpLChlLnByb21vdGlvblN0cmF0ZWd5PT0oU2woKSwkMykmJihhKGxlKGUuY3VycmVudFdpZHRoLF8pLDE3KS52YWx1ZV8wPmUubWF4V2lkdGh8fGEobGUoZS5jdXJyZW50V2lkdGgsXy0xKSwxNykudmFsdWVfMD5lLm1heFdpZHRoKXx8ZS5wcm9tb3Rpb25TdHJhdGVneT09QjMmJihSKCQobGUoZS5jdXJyZW50V2lkdGhQaXhlbCxfKSkpPmUubWF4V2lkdGhQaXhlbHx8UigkKGxlKGUuY3VycmVudFdpZHRoUGl4ZWwsXy0xKSkpPmUubWF4V2lkdGhQaXhlbCkpJiYoYz0hMSkscz1uZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHMpOylpPWEodG4ocyksMTgpLHU9aS5zb3VyY2Uub3duZXIsZS5sYXllcnNbdS5pZF8wXT09XyYmKGY9bFNlKGUsdSksbz1vK2EoZi5maXJzdCwxNykudmFsdWVfMCxjPWMmJmFlKGllKGYuc2Vjb25kKSkpO3JldHVybiBlLmxheWVyc1tuLmlkXzBdPV8sbz1vK2UuZGVncmVlRGlmZltuLmlkXzBdWzBdLG5ldyBacihKKG8pLCh6ZSgpLCEhYykpfWZ1bmN0aW9uIHNTZShlLG4scil7dmFyIHQsbyxpLHMsdSxjO2ZvcihjPWEoRWYoZS5iaUxheWVyTWFwLG4pLDE3KS52YWx1ZV8wLHI/ZWooZS5iaUxheWVyTWFwLEooYysxKSxuKTplaihlLmJpTGF5ZXJNYXAsSihjLTEpLG4pLHM9bmV3IGx1LG89bmV3IFhlKFFlKChyP1JyKG4pOnR0KG4pKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSwxOCkscj9pPXQudGFyZ2V0Lm93bmVyOmk9dC5zb3VyY2Uub3duZXIsRChFZihlLmJpTGF5ZXJNYXAsaSkpPT09RChFZihlLmJpTGF5ZXJNYXAsbikpJiYodT1zLm1hcF8wLnB1dChpLHMpLHU9PW51bGwpO3JldHVybiBzfWZ1bmN0aW9uIEJ5KGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7dT0wLHk9MCxjPVpJKGUubGF5ZXJzLGUubGF5ZXJzLmxlbmd0aCksaT1lLmR1bW15Tm9kZUNvdW50LHM9ZS5tYXhIZWlnaHQsdD1lLmN1cnJlbnRXaWR0aCxvPWUuY3VycmVudFdpZHRoUGl4ZWw7ZG97Zm9yKG09MCxkPW5ldyBUKGUubm9kZXNXaXRoSW5jb21pbmdFZGdlcyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDEwKSxoPWxTZShlLF8pLHI9ITAsKGUucHJvbW90aW9uU3RyYXRlZ3k9PShTbCgpLCQzKXx8ZS5wcm9tb3Rpb25TdHJhdGVneT09QjMpJiYocj1hZShpZShoLnNlY29uZCkpKSxhKGguZmlyc3QsMTcpLnZhbHVlXzA8MCYmcj8oKyttLGM9WkkoZS5sYXllcnMsZS5sYXllcnMubGVuZ3RoKSxlLmR1bW15Tm9kZUNvdW50PWUuZHVtbXlOb2RlQ291bnQrYShoLmZpcnN0LDE3KS52YWx1ZV8wLHkrPWktZS5kdW1teU5vZGVDb3VudCxpPWUuZHVtbXlOb2RlQ291bnQrYShoLmZpcnN0LDE3KS52YWx1ZV8wLHM9ZS5tYXhIZWlnaHQsdD12MShlLmN1cnJlbnRXaWR0aCksbz12MShlLmN1cnJlbnRXaWR0aFBpeGVsKSk6KGUubGF5ZXJzPVpJKGMsYy5sZW5ndGgpLGUuZHVtbXlOb2RlQ291bnQ9aSxlLmN1cnJlbnRXaWR0aD0odm4odCksdD9uZXcgUWkodCk6UW0obmV3IFQodCkpKSxlLmN1cnJlbnRXaWR0aFBpeGVsPSh2bihvKSxvP25ldyBRaShvKTpRbShuZXcgVChvKSkpLGUubWF4SGVpZ2h0PXMpOysrdSxmPW0hPTAmJmFlKGllKG4uYXBwbHlfMChuZXcgWnIoSih5KSxKKHUpKSkpKX13aGlsZShmKX1mdW5jdGlvbiB5dW4oZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3Iobz1uZXcgUSxyPTA7cjw9ZS5tYXhIZWlnaHQ7cisrKXQ9bmV3IG9pKG4pLHQuaWRfMD1lLm1heEhlaWdodC1yLFJlKG8uYXJyYXksdCk7Zm9yKHU9bmV3IFQoZS5ub2Rlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDEwKSxodChzLGEobGUobyxlLm1heEhlaWdodC1lLmxheWVyc1tzLmlkXzBdKSwzMCkpO2ZvcihpPW5ldyBUKG8pO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhpKSwzMCksYy5ub2Rlcy5hcnJheS5sZW5ndGg9PTAmJkoyKGkpO24ubGF5ZXJzLmFycmF5Lmxlbmd0aD0wLHFyKG4ubGF5ZXJzLG8pfWZ1bmN0aW9uIHd1bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKGk9bmV3IFEsbi5sYXllcnMuYXJyYXkubGVuZ3RoPTAscj1hKFRvKFdHKG5ldyBTZShudWxsLG5ldyB4ZShuZXcga18oZS5iaUxheWVyTWFwLm11bHRpTWFwS2V5VG9WYWx1ZXMpLDEpKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSksMTUpLG89ci5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspaWYodD1hKG8ubmV4dF8xKCksMTcpLHM9UVcoZS5iaUxheWVyTWFwLHQpLHMuc2l6ZV8wIT0wKWZvcih1PW5ldyBvaShuKSxSZShpLmFycmF5LHUpLHUuaWRfMD10LnZhbHVlXzAsXz1kbihzLDApO18uY3VycmVudE5vZGUhPV8udGhpcyQwMS50YWlsOyljPWEodW4oXyksMTApLGh0KGMsdSk7cXIobi5sYXllcnMsaSl9ZnVuY3Rpb24gdVNlKCl7VzQoKSx0aGlzLmJpTGF5ZXJNYXA9bmV3IG5qfWZ1bmN0aW9uIEV1bihlLG4pe3JldHVybiBXNCgpLHplKCksYShuLnNlY29uZCwxNykudmFsdWVfMDxlfWZ1bmN0aW9uIHZ1bihlLG4pe3JldHVybiBXNCgpLHplKCksYShuLmZpcnN0LDE3KS52YWx1ZV8wPGV9cCgxNjI3LDEsc3IsdVNlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXttdW4odGhpcyxhKG4sMzYpLHIpfSxsLmR1bW15Tm9kZUNvdW50PTAsbC5kdW1teVNpemU9MCxsLm1heEhlaWdodD0wLGwubWF4V2lkdGg9MCxsLm1heFdpZHRoUGl4ZWw9MCxsLm5vZGVTaXplQWZmaXg9MDt2YXIgY1NlLF9TZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTm9kZVByb21vdGlvbiIsMTYyNyk7ZnVuY3Rpb24gU3VuKGUsbil7cmV0dXJuIF9yKGUsKEsoKSxycikpJiZfcihuLHJyKT9hKHcobixyciksMTcpLnZhbHVlXzAtYSh3KGUscnIpLDE3KS52YWx1ZV8wOjB9ZnVuY3Rpb24gZFNlKCl7fXAoMTYyOCwxLE5uLGRTZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gU3VuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIk5vZGVQcm9tb3Rpb24vMSIsMTYyOCk7ZnVuY3Rpb24gQ3VuKGUsbil7cmV0dXJuIF9yKGUsKEsoKSxycikpJiZfcihuLHJyKT9hKHcoZSxyciksMTcpLnZhbHVlXzAtYSh3KG4scnIpLDE3KS52YWx1ZV8wOjB9ZnVuY3Rpb24gZlNlKCl7fXAoMTYyOSwxLE5uLGZTZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gQ3VuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIk5vZGVQcm9tb3Rpb24vMiIsMTYyOSk7ZnVuY3Rpb24gcFNlKCl7fXAoMTYzMCwxLHt9LHBTZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNDIpLFc0KCksemUoKSwhMH0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJOb2RlUHJvbW90aW9uL2xhbWJkYSQwJFR5cGUiLDE2MzApO2Z1bmN0aW9uIGdTZShlKXt0aGlzLnByb21vdGVVbnRpbE5fMD1lfXAoMTYzMSwxLHt9LGdTZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBFdW4odGhpcy5wcm9tb3RlVW50aWxOXzAsYShuLDQyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnByb21vdGVVbnRpbE5fMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJOb2RlUHJvbW90aW9uL2xhbWJkYSQxJFR5cGUiLDE2MzEpO2Z1bmN0aW9uIGhTZShlKXt0aGlzLnByb21vdGVVbnRpbERfMD1lfXAoMTYzMiwxLHt9LGhTZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiB2dW4odGhpcy5wcm9tb3RlVW50aWxEXzAsYShuLDQyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnByb21vdGVVbnRpbERfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJOb2RlUHJvbW90aW9uL2xhbWJkYSQyJFR5cGUiLDE2MzIpO2Z1bmN0aW9uIFR1bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEg7Zm9yKG4uYmVnaW4oIk9kZCBwb3J0IHNpZGUgcHJvY2Vzc2luZyIsMSkseT1hKHcoZSwob2UoKSx1YykpLDIyMyksbz1uZXcgVChlLmxheWVycyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih0PWEoQyhvKSwzMCksXz1jMyh0Lm5vZGVzKSxzPV8sdT0wLGM9cy5sZW5ndGg7dTxjOysrdSlpZihpPXNbdV0saS50eXBlXzA9PShXZSgpLHRpKSl7aWYoeT09KGZjKCksY20pKWZvcihmPW5ldyBUKGkucG9ydHMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSwxMiksZC5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MHx8eHVuKGQpLGQub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTB8fFB1bihkKTtlbHNlIGlmKEwodyhpLChLKCksUW4pKSwxOCkpdj1hKHcoaSxRbiksMTgpLHg9YSgkYyhpLChyZSgpLGplKSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSxBPWEoJGMoaSxxZSkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEyKSxrPWEodyh4LFFuKSwxMiksTT1hKHcoQSxRbiksMTIpLEx0KHYsTSksX3QodixrKSxIPW5ldyBSdChBLm93bmVyLnBvcyksSC54XzA9a28oUChJKG90LDEpLFgsOCwwLFtNLm93bmVyLnBvcyxNLnBvcyxNLmFuY2hvcl0pKS54XzAsTG4odi5iZW5kUG9pbnRzLEgpLEg9bmV3IFJ0KHgub3duZXIucG9zKSxILnhfMD1rbyhQKEkob3QsMSksWCw4LDAsW2sub3duZXIucG9zLGsucG9zLGsuYW5jaG9yXSkpLnhfMCxMbih2LmJlbmRQb2ludHMsSCk7ZWxzZXtpZihpLnBvcnRzLmFycmF5Lmxlbmd0aD49Mil7Zm9yKEU9ITAsaD1uZXcgVChpLnBvcnRzKSxyPWEoQyhoKSwxMiksbT1udWxsO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihtPXIscj1hKEMoaCksMTIpLCFZbih3KG0sUW4pLHcocixRbikpKXtFPSExO2JyZWFrfX1lbHNlIEU9ITE7Zm9yKGY9bmV3IFQoaS5wb3J0cyk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KWQ9YShDKGYpLDEyKSxkLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wfHxidW4oZCxFKSxkLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wfHxJdW4oZCxFKX1odChpLG51bGwpfW4uZG9uZV8xKCl9ZnVuY3Rpb24gYnVuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2ZvcihjPWEodyhlLChLKCksUW4pKSwxMiksXz1rbyhQKEkob3QsMSksWCw4LDAsW2Mub3duZXIucG9zLGMucG9zLGMuYW5jaG9yXSkpLnhfMCxkPWUub3duZXIucG9zLnlfMCxyPWN1KGUuaW5jb21pbmdFZGdlcyksbz1yLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpdD1vW2ldLF90KHQsYyksTXQodC5iZW5kUG9pbnRzLG5ldyBZKF8sZCkpLG4mJih1PWEodyh0LChvZSgpLGlvKSksNzUpLHV8fCh1PW5ldyBqaSxqKHQsaW8sdSkpLExuKHUsbmV3IFkoXyxkKSkpfWZ1bmN0aW9uIEl1bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtmb3Iobz1hKHcoZSwoSygpLFFuKSksMTIpLF89a28oUChJKG90LDEpLFgsOCwwLFtvLm93bmVyLnBvcyxvLnBvcyxvLmFuY2hvcl0pKS54XzAsZD1lLm93bmVyLnBvcy55XzAscj1jdShlLm91dGdvaW5nRWRnZXMpLHM9cix1PTAsYz1zLmxlbmd0aDt1PGM7Kyt1KWk9c1t1XSxMdChpLG8pLExwKGkuYmVuZFBvaW50cyxuZXcgWShfLGQpKSxuJiYodD1hKHcoaSwob2UoKSxpbykpLDc1KSx0fHwodD1uZXcgamksaihpLGlvLHQpKSxMbih0LG5ldyBZKF8sZCkpKX1mdW5jdGlvbiB4dW4oZSl7dmFyIG4scix0LG8saSxzO2ZvcihzPWEodyhlLChLKCksUW4pKSwxMiksaihzLHR3LGUub3duZXIucG9zLnlfMCksbj1jdShlLmluY29taW5nRWRnZXMpLHQ9bixvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxfdChyLHMpfWZ1bmN0aW9uIFB1bihlKXt2YXIgbixyLHQsbyxpLHM7Zm9yKHI9YSh3KGUsKEsoKSxRbikpLDEyKSxqKHIsdHcsZS5vd25lci5wb3MueV8wKSxuPWN1KGUub3V0Z29pbmdFZGdlcyksbz1uLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpdD1vW2ldLEx0KHQscil9ZnVuY3Rpb24gbVNlKCl7fXAoMTYzMywxLHNyLG1TZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7VHVuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJOb3J0aFNvdXRoUG9ydFBvc3Rwcm9jZXNzb3IiLDE2MzMpO2Z1bmN0aW9uIFlqKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaDtpZihpPW5ldyBhYyhlKSx6XyhpLChXZSgpLHRpKSksaihpLChvZSgpLHhyKSwoZHQoKSxhaSkpLG89MCxuKXtmb3Iocz1uZXcgWm8saihzLChLKCksUW4pLG4pLGooaSxRbixuLm93bmVyKSxYcihzLChyZSgpLGplKSksTG8ocyxpKSxoPWN1KG4uaW5jb21pbmdFZGdlcyksXz1oLGQ9MCxmPV8ubGVuZ3RoO2Q8ZjsrK2QpYz1fW2RdLF90KGMscyk7aihuLG9hLGkpLCsrb31pZihyKXtmb3IodT1uZXcgWm8saihpLChLKCksUW4pLHIub3duZXIpLGoodSxRbixyKSxYcih1LChyZSgpLHFlKSksTG8odSxpKSxoPWN1KHIub3V0Z29pbmdFZGdlcyksXz1oLGQ9MCxmPV8ubGVuZ3RoO2Q8ZjsrK2QpYz1fW2RdLEx0KGMsdSk7aihyLG9hLGkpLCsrb31yZXR1cm4gaihpLChLKCksX1ApLEoobykpLFJlKHQuYXJyYXksaSksaX1mdW5jdGlvbiB5U2UoZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmU7Zm9yKEU9bmV3IF9pKG4uc2l6ZV8wKSxNPW5ldyBfaShuLnNpemVfMCksaD1uZXcgX2kobi5zaXplXzApLHZlPW5ldyBfaShuLnNpemVfMCksdj1uZXcgX2kobi5zaXplXzApLG5lPWRuKG4sMCk7bmUuY3VycmVudE5vZGUhPW5lLnRoaXMkMDEudGFpbDspZm9yKEg9YSh1bihuZSksMTIpLHU9bmV3IFQoSC5vdXRnb2luZ0VkZ2VzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoaT1hKEModSksMTgpLGkuc291cmNlLm93bmVyPT1pLnRhcmdldC5vd25lcil7aWYoSC5zaWRlPT1pLnRhcmdldC5zaWRlKXtSZSh2ZS5hcnJheSxpKTtjb250aW51ZX1lbHNlIGlmKEguc2lkZT09KHJlKCksVWUpJiZpLnRhcmdldC5zaWRlPT1sbil7UmUodi5hcnJheSxpKTtjb250aW51ZX19Zm9yKGM9bmV3IFQodik7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKGMpLDE4KSxOdW4oZSxpLHIsdCwocmUoKSxxZSkpO2ZvcihzPW5ldyBUKHZlKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTgpLHdlPW5ldyBhYyhlKSx6Xyh3ZSwoV2UoKSx0aSkpLGood2UsKG9lKCkseHIpLChkdCgpLGFpKSksaih3ZSwoSygpLFFuKSxpKSxEZT1uZXcgWm8saihEZSxRbixpLnRhcmdldCksWHIoRGUsKHJlKCksamUpKSxMbyhEZSx3ZSksRmU9bmV3IFpvLGooRmUsUW4saS5zb3VyY2UpLFhyKEZlLHFlKSxMbyhGZSx3ZSksaihpLnNvdXJjZSxvYSx3ZSksaihpLnRhcmdldCxvYSx3ZSksTHQoaSxudWxsKSxfdChpLG51bGwpLFJlKHIuYXJyYXksd2UpLGood2UsX1AsSigyKSk7Zm9yKHE9ZG4obiwwKTtxLmN1cnJlbnROb2RlIT1xLnRoaXMkMDEudGFpbDspSD1hKHVuKHEpLDEyKSxfPUguaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGg+MCx4PUgub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg+MCxfJiZ4P1JlKGguYXJyYXksSCk6Xz9SZShFLmFycmF5LEgpOngmJlJlKE0uYXJyYXksSCk7Zm9yKHk9bmV3IFQoRSk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW09YShDKHkpLDEyKSxlZShvLFlqKGUsbSxudWxsLHIpKTtmb3Ioaz1uZXcgVChNKTtrLmk8ay50aGlzJDAxLmFycmF5Lmxlbmd0aDspQT1hKEMoayksMTIpLGVlKG8sWWooZSxudWxsLEEscikpO2ZvcihmPW5ldyBUKGgpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSwxMiksZWUobyxZaihlLGQsZCxyKSl9ZnVuY3Rpb24gTnVuKGUsbixyLHQsbyl7dmFyIGkscyx1LGM7aT1uZXcgYWMoZSksel8oaSwoV2UoKSx0aSkpLGooaSwob2UoKSx4ciksKGR0KCksYWkpKSxqKGksKEsoKSxRbiksbi5zb3VyY2Uub3duZXIpLHM9bmV3IFpvLGoocyxRbixuLnNvdXJjZSksWHIocyxvKSxMbyhzLGkpLGoobi5zb3VyY2Usb2EsaSksdT1uZXcgYWMoZSksel8odSx0aSksaih1LHhyLGFpKSxqKHUsUW4sbi50YXJnZXQub3duZXIpLGM9bmV3IFpvLGooYyxRbixuLnRhcmdldCksWHIoYyxvKSxMbyhjLHUpLGoobi50YXJnZXQsb2EsdSksTHQobixzKSxfdChuLGMpLGRmKDAsci5hcnJheS5sZW5ndGgpLG9FKHIuYXJyYXksMCxpKSxSZSh0LmFycmF5LHUpLGooaSxfUCxKKDEpKSxqKHUsX1AsSigxKSl9ZnVuY3Rpb24gQXVuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lO2ZvcihuLmJlZ2luKCJPZGQgcG9ydCBzaWRlIHByb2Nlc3NpbmciLDEpLEU9bmV3IFEscT1uZXcgUSxfPW5ldyBUKGUubGF5ZXJzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGM9YShDKF8pLDMwKSx4PS0xLHk9YzMoYy5ub2RlcyksZj15LGg9MCxtPWYubGVuZ3RoO2g8bTsrK2gpaWYoZD1mW2hdLCsreCwhIShkLnR5cGVfMD09KFdlKCksa3IpJiZPZyhhKHcoZCwob2UoKSx4cikpLDEwMSkpKSl7Zm9yKF9tKGEodyhkLChvZSgpLHhyKSksMTAxKSl8fEx1bihkKSxqKGQsKEsoKSxYMSksZCksRS5hcnJheS5sZW5ndGg9MCxxLmFycmF5Lmxlbmd0aD0wLHI9bmV3IFEsTT1uZXcgcHIsdDUoTSwkYyhkLChyZSgpLFVlKSkpLHlTZShlLE0sRSxxLHIpLHU9eCxuZT1kLGk9bmV3IFQoRSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKGkpLDEwKSx3Zih0LHUsYyksKyt4LGoodCxYMSxkKSxzPWEobGUodC5wb3J0cywwKSwxMiksdj1hKHcocyxRbiksMTIpLGFlKGllKHcodixoTykpKXx8YSh3KHQsV2gpLDE1KS5hZGRfMihuZSk7Zm9yKGthKE0pLGs9JGMoZCxsbikuaXRlcmF0b3JfMCgpO2suaGFzTmV4dF8wKCk7KUE9YShrLm5leHRfMSgpLDEyKSxicihNLEEsTS5oZWFkZXIsTS5oZWFkZXIubmV4dF8wKTtmb3IoeVNlKGUsTSxxLG51bGwsciksSD1kLG89bmV3IFQocSk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDEwKSx3Zih0LCsreCxjKSxqKHQsWDEsZCkscz1hKGxlKHQucG9ydHMsMCksMTIpLHY9YSh3KHMsUW4pLDEyKSxhZShpZSh3KHYsaE8pKSl8fGEodyhILFdoKSwxNSkuYWRkXzIodCk7ci5hcnJheS5sZW5ndGg9PTB8fGooZCxLVixyKX1uLmRvbmVfMSgpfWZ1bmN0aW9uIEx1bihlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihjPWUucG9ydHMuYXJyYXkubGVuZ3RoLHI9MCxuPWMsbz0yKmMsdT1uZXcgVChlLnBvcnRzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspc3dpdGNoKHM9YShDKHUpLDEyKSxzLnNpZGUub3JkaW5hbCl7Y2FzZSAyOmNhc2UgNDpzLmlkXzA9LTE7YnJlYWs7Y2FzZSAxOmNhc2UgMzp0PXMuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgsaT1zLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoLHQ+MCYmaT4wP3MuaWRfMD1uKys6dD4wP3MuaWRfMD1yKys6aT4wP3MuaWRfMD1vKys6cy5pZF8wPXIrK31OZSgpLERyKGUucG9ydHMsbmV3IEVTZSl9ZnVuY3Rpb24gd1NlKCl7fWZ1bmN0aW9uIGt1bihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9ZS5zaWRlLHQ9bi5zaWRlLHIhPXQ/ci5vcmRpbmFsLXQub3JkaW5hbDplLmlkXzA9PW4uaWRfMD8wOnI9PShyZSgpLFVlKT9lLmlkXzAtbi5pZF8wOm4uaWRfMC1lLmlkXzB9cCgxNjM0LDEsc3Isd1NlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtBdW4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIk5vcnRoU291dGhQb3J0UHJlcHJvY2Vzc29yIiwxNjM0KTtmdW5jdGlvbiBFU2UoKXt9cCgxNjM1LDEsTm4sRVNlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBrdW4oYShuLDEyKSxhKHIsMTIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiTm9ydGhTb3V0aFBvcnRQcmVwcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTYzNSk7ZnVuY3Rpb24gT3VuKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKG89ZS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspZm9yKHQ9YShvLm5leHRfMSgpLDEwKSx1PW5ldyBabyxMbyh1LHQpLFhyKHUsKHJlKCkscWUpKSxqKHUsKEsoKSxwUCksKHplKCksITApKSxzPW4uaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDEwKSxjPW5ldyBabyxMbyhjLGkpLFhyKGMsamUpLGooYyxwUCwhMCkscj1uZXcgSDEsaihyLHBQLCEwKSxMdChyLHUpLF90KHIsYyl9ZnVuY3Rpb24gTXVuKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKG4uYmVnaW4oIlBhcnRpdGlvbiBtaWRwcm9jZXNzaW5nIiwxKSxvPW5ldyBFMSxMcihKbihuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcmxlc3NOb2RlcywxNikpLG5ldyBTU2UpLG5ldyBDU2UobykpLG8udG90YWxTaXplIT0wKXtmb3IodT1hKFRvKFdHKChpPW8ua2V5U2V0LG5ldyBTZShudWxsLChpfHwoby5rZXlTZXQ9bmV3IFNwKG8sby5tYXBfMCkpKS5zcGxpdGVyYXRvcl8wKCkpKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSksMTUpLHQ9dS5pdGVyYXRvcl8wKCkscj1hKHQubmV4dF8xKCksMTcpO3QuaGFzTmV4dF8wKCk7KXM9YSh0Lm5leHRfMSgpLDE3KSxPdW4oYShabihvLHIpLDIxKSxhKFpuKG8scyksMjEpKSxyPXM7bi5kb25lXzEoKX19ZnVuY3Rpb24gdlNlKCl7fWZ1bmN0aW9uIFJ1bihlLG4pe3JldHVybiBiZShlLGEodyhuLChvZSgpLGl3KSksMTcpLG4pfXAoMTYzNiwxLHNyLHZTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7TXVuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25NaWRwcm9jZXNzb3IiLDE2MzYpO2Z1bmN0aW9uIFNTZSgpe31wKDE2MzcsMSxJbixTU2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBfcihhKG4sMTApLChvZSgpLGl3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25NaWRwcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTYzNyk7ZnVuY3Rpb24gQ1NlKGUpe3RoaXMucGFydGl0aW9uVG9Ob2Rlc01hcF8wPWV9cCgxNjM4LDEsSmUsQ1NlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtSdW4odGhpcy5wYXJ0aXRpb25Ub05vZGVzTWFwXzAsYShuLDEwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25NaWRwcm9jZXNzb3IvbGFtYmRhJDEkVHlwZSIsMTYzOCk7ZnVuY3Rpb24gRHVuKGUsbil7dmFyIHIsdCxvLGkscyx1O2ZvcihuLmJlZ2luKCJQYXJ0aXRpb24gcG9zdHByb2Nlc3NpbmciLDEpLHQ9bmV3IFQoZS5sYXllcnMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocj1hKEModCksMzApLGk9bmV3IFQoci5ub2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihvPWEoQyhpKSwxMCksdT1uZXcgVChvLnBvcnRzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTIpLGFlKGllKHcocywoSygpLHBQKSkpKSYmSjIodSk7bi5kb25lXzEoKX1mdW5jdGlvbiBUU2UoKXt9cCgxNjM5LDEsc3IsVFNlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtEdW4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlBhcnRpdGlvblBvc3Rwcm9jZXNzb3IiLDE2MzkpO2Z1bmN0aW9uIEZ1bihlKXt2YXIgbixyO3JldHVybiBfcihlLnRhcmdldC5vd25lciwob2UoKSxpdykpPyhuPWEodyhlLnNvdXJjZS5vd25lcixpdyksMTcpLHI9YSh3KGUudGFyZ2V0Lm93bmVyLGl3KSwxNykscW8obi52YWx1ZV8wLHIudmFsdWVfMCk+MCk6ITF9ZnVuY3Rpb24genVuKGUsbil7dmFyIHI7bi5iZWdpbigiUGFydGl0aW9uIHByZXByb2Nlc3NpbmciLDEpLHI9YShUbyhKbihObyhKbihuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcmxlc3NOb2RlcywxNikpLG5ldyBJU2UpLG5ldyB4U2UpLG5ldyBQU2UpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxDbyldKSkpLDE1KSxMcihyLnN0cmVhbSgpLG5ldyBOU2UpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gJHVuKGUpe3ZhciBuO0cxKGUsITApLG49YmMsX3IoZSwob2UoKSxsdykpJiYobis9YSh3KGUsbHcpLDE3KS52YWx1ZV8wKSxqKGUsbHcsSihuKSl9ZnVuY3Rpb24gYlNlKCl7fXAoMTY0MCwxLHNyLGJTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7enVuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25QcmVwcm9jZXNzb3IiLDE2NDApO2Z1bmN0aW9uIElTZSgpe31wKDE2NDEsMSxJbixJU2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBfcihhKG4sMTApLChvZSgpLGl3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25QcmVwcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTY0MSk7ZnVuY3Rpb24geFNlKCl7fXAoMTY0MiwxLHt9LHhTZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2UobnVsbCxuZXcgTzEobmV3IFhlKFFlKFJyKGEobiwxMCkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiUGFydGl0aW9uUHJlcHJvY2Vzc29yL2xhbWJkYSQxJFR5cGUiLDE2NDIpO2Z1bmN0aW9uIFBTZSgpe31wKDE2NDMsMSxJbixQU2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBGdW4oYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQYXJ0aXRpb25QcmVwcm9jZXNzb3IvbGFtYmRhJDIkVHlwZSIsMTY0Myk7ZnVuY3Rpb24gTlNlKCl7fXAoMTY0NCwxLEplLE5TZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7JHVuKGEobiwxOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiUGFydGl0aW9uUHJlcHJvY2Vzc29yL2xhbWJkYSQzJFR5cGUiLDE2NDQpO2Z1bmN0aW9uIEd5KCl7R3k9RixYaj1uZXcgQlNlLEpqPW5ldyBHU2UsRlNlPW5ldyB6U2UsRFNlPW5ldyBIU2UsUlNlPW5ldyAkU2UsS2o9KFZlKFJTZSksbmV3IFAwZSl9ZnVuY3Rpb24gQVNlKGUsbil7dmFyIHIsdCxvLGkscztpZihlLmFycmF5Lmxlbmd0aD09MClyZXR1cm4gbmV3IFpyKEooMCksSigwKSk7Zm9yKHI9KEFlKDAsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVswXSwxMikpLnNpZGUscz0wLGk9bi5vcmRpbmFsLHQ9bi5vcmRpbmFsKzE7czxlLmFycmF5Lmxlbmd0aC0xJiZyLm9yZGluYWw8aTspKytzLHI9KEFlKHMsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtzXSwxMikpLnNpZGU7Zm9yKG89cztvPGUuYXJyYXkubGVuZ3RoLTEmJnIub3JkaW5hbDx0OykrK28scj0oQWUocyxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5W3NdLDEyKSkuc2lkZTtyZXR1cm4gbmV3IFpyKEoocyksSihvKSl9ZnVuY3Rpb24gQnVuKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKG4uYmVnaW4oIlBvcnQgb3JkZXIgcHJvY2Vzc2luZyIsMSksYz1hKHcoZSwob2UoKSxmWSkpLDQzMCksdD1uZXcgVChlLmxheWVycyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihyPWEoQyh0KSwzMCksaT1uZXcgVChyLm5vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTApLHM9YSh3KG8seHIpLDEwMSksdT1vLnBvcnRzLHM9PShkdCgpLG8xKXx8cz09SHV8fHM9PWFpPyhOZSgpLERyKHUsS2opKTpzIT1IcyYmcyE9cTAmJihOZSgpLERyKHUsRlNlKSxHdW4odSksYz09KEczKCksak8pJiZEcih1LERTZSkpLG8ucG9ydFNpZGVzQ2FjaGVkPSEwLEZXKG8pO24uZG9uZV8xKCl9ZnVuY3Rpb24gTFNlKGUsbixyKXt2YXIgdCxvLGk7aWYoIShyPD1uKzIpKWZvcihvPShyLW4pLzJ8MCx0PTA7dDxvOysrdClpPShBZShuK3QsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtuK3RdLDEyKSksS2EoZSxuK3QsKEFlKHItdC0xLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbci10LTFdLDEyKSkpLEFlKHItdC0xLGUuYXJyYXkubGVuZ3RoKSxlLmFycmF5W3ItdC0xXT1pfWZ1bmN0aW9uIEd1bihlKXt2YXIgbixyO2UuYXJyYXkubGVuZ3RoPD0xfHwobj1BU2UoZSwocmUoKSxsbikpLExTZShlLGEobi5maXJzdCwxNykudmFsdWVfMCxhKG4uc2Vjb25kLDE3KS52YWx1ZV8wKSxyPUFTZShlLGplKSxMU2UoZSxhKHIuZmlyc3QsMTcpLnZhbHVlXzAsYShyLnNlY29uZCwxNykudmFsdWVfMCkpfWZ1bmN0aW9uIGtTZSgpe0d5KCl9ZnVuY3Rpb24gT1NlKGUsbil7R3koKTt2YXIgcjtyZXR1cm4gcj1lLnNpZGUub3JkaW5hbC1uLnNpZGUub3JkaW5hbCxyIT0wP3I6MH1mdW5jdGlvbiBNU2UoZSxuKXtHeSgpO3ZhciByLHQsbyxpLHM7aWYocz1hKHcoZS5vd25lciwob2UoKSx4cikpLDEwMSksaT1lLnNpZGUub3JkaW5hbC1uLnNpZGUub3JkaW5hbCxpIT0wfHwhKHM9PShkdCgpLG8xKXx8cz09SHV8fHM9PWFpKSlyZXR1cm4gMDtpZihzPT0oZHQoKSxvMSkmJihyPWEodyhlLFdjKSwxNyksdD1hKHcobixXYyksMTcpLHImJnQmJihvPXIudmFsdWVfMC10LnZhbHVlXzAsbyE9MCkpKXJldHVybiBvO3N3aXRjaChlLnNpZGUub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBpcihlLnBvcy54XzAsbi5wb3MueF8wKTtjYXNlIDI6cmV0dXJuIGlyKGUucG9zLnlfMCxuLnBvcy55XzApO2Nhc2UgMzpyZXR1cm4gaXIobi5wb3MueF8wLGUucG9zLnhfMCk7Y2FzZSA0OnJldHVybiBpcihuLnBvcy55XzAsZS5wb3MueV8wKTtkZWZhdWx0OnRocm93IGIobmV3IHJvKCJQb3J0IHNpZGUgaXMgdW5kZWZpbmVkIikpfX1mdW5jdGlvbiBIdW4oZSxuKXtHeSgpO3ZhciByO2lmKHI9ZS5zaWRlLm9yZGluYWwtbi5zaWRlLm9yZGluYWwsciE9MClyZXR1cm4gMDtzd2l0Y2goZS5zaWRlLm9yZGluYWwpe2Nhc2UgMjpyZXR1cm4gbTkobixKaiktbTkoZSxKaik7Y2FzZSA0OnJldHVybiBtOShlLFhqKS1tOShuLFhqKX1yZXR1cm4gMH1mdW5jdGlvbiBtOShlLG4pe3ZhciByLHQsbztmb3Iobz0wLHQ9YShuLmFwcGx5XzAoZSksMjApLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwxOCksYWUoaWUodyhyLChLKCksT3MpKSkpfHwrK287cmV0dXJuIG99cCgxNjQ1LDEsc3Isa1NlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtCdW4oYShuLDM2KSxyKX07dmFyIEtqLFJTZSxEU2UsRlNlLFhqLEpqO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQb3J0TGlzdFNvcnRlciIsMTY0NSk7ZnVuY3Rpb24gelNlKCl7fXAoMTY0OCwxLE5uLHpTZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gT1NlKGEobiwxMiksYShyLDEyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlBvcnRMaXN0U29ydGVyL2xhbWJkYSQwJFR5cGUiLDE2NDgpO2Z1bmN0aW9uICRTZSgpe31wKDE2NTAsMSxObiwkU2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIE1TZShhKG4sMTIpLGEociwxMikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQb3J0TGlzdFNvcnRlci9sYW1iZGEkMSRUeXBlIiwxNjUwKTtmdW5jdGlvbiBCU2UoKXt9cCgxNjQ2LDEse30sQlNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEd5KCksYShuLDEyKS5pbmNvbWluZ0VkZ2VzfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiUG9ydExpc3RTb3J0ZXIvbGFtYmRhJDIkVHlwZSIsMTY0Nik7ZnVuY3Rpb24gR1NlKCl7fXAoMTY0NywxLHt9LEdTZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBHeSgpLGEobiwxMikub3V0Z29pbmdFZGdlc30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlBvcnRMaXN0U29ydGVyL2xhbWJkYSQzJFR5cGUiLDE2NDcpO2Z1bmN0aW9uIEhTZSgpe31wKDE2NDksMSxObixIU2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEh1bihhKG4sMTIpLGEociwxMikpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQb3J0TGlzdFNvcnRlci9sYW1iZGEkNCRUeXBlIiwxNjQ5KTtmdW5jdGlvbiBVdW4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihuLmJlZ2luKCJQb3J0IHNpZGUgcHJvY2Vzc2luZyIsMSkscz1uZXcgVChlLmxheWVybGVzc05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMocyksMTApLFVTZShvKTtmb3IodD1uZXcgVChlLmxheWVycyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihyPWEoQyh0KSwzMCksaT1uZXcgVChyLm5vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTApLFVTZShvKTtuLmRvbmVfMSgpfWZ1bmN0aW9uIFVTZShlKXt2YXIgbixyLHQ7aWYoT2coYSh3KGUsKG9lKCkseHIpKSwxMDEpKSlmb3Iocj1uZXcgVChlLnBvcnRzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTIpLG4uc2lkZT09KHJlKCksT28pJiYodD1hKHcobiwoSygpLG9hKSksMTApLHQ/WHIobixhKHcodCxEbyksNjQpKTpuLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoLW4ub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg8MD9YcihuLHFlKTpYcihuLGplKSk7ZWxzZXtmb3Iocj1uZXcgVChlLnBvcnRzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTIpLHQ9YSh3KG4sKEsoKSxvYSkpLDEwKSx0P1hyKG4sYSh3KHQsRG8pLDY0KSk6bi5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aC1uLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPDA/WHIobiwocmUoKSxxZSkpOlhyKG4sKHJlKCksamUpKTtqKGUseHIsKGR0KCksQXcpKX19ZnVuY3Rpb24gV1NlKCl7fXAoMTY1MSwxLHNyLFdTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7VXVuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJQb3J0U2lkZVByb2Nlc3NvciIsMTY1MSk7ZnVuY3Rpb24gV3VuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3Iobi5iZWdpbigiUmVzdG9yaW5nIHJldmVyc2VkIGVkZ2VzIiwxKSxjPW5ldyBUKGUubGF5ZXJzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHU9YShDKGMpLDMwKSxkPW5ldyBUKHUubm9kZXMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoXz1hKEMoZCksMTApLGg9bmV3IFQoXy5wb3J0cyk7aC5pPGgudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihmPWEoQyhoKSwxMikscz1jdShmLm91dGdvaW5nRWRnZXMpLHQ9cyxvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxhZShpZSh3KHIsKEsoKSxPcykpKSkmJkcxKHIsITEpO24uZG9uZV8xKCl9ZnVuY3Rpb24galNlKCl7fXAoMTY1MiwxLHNyLGpTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7V3VuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJSZXZlcnNlZEVkZ2VSZXN0b3JlciIsMTY1Mik7ZnVuY3Rpb24ganVuKGUsbixyKXtyLmJlZ2luKCJTZWxmLUxvb3Agb3JkZXJpbmciLDEpLExyKHBvKEpuKEpuKE5vKG5ldyBTZShudWxsLG5ldyB4ZShuLmxheWVycywxNikpLG5ldyBxU2UpLG5ldyBZU2UpLG5ldyBLU2UpLG5ldyBYU2UpLG5ldyBKU2UoZSkpLHIuZG9uZV8xKCl9ZnVuY3Rpb24gVnVuKGUsbil7aWYobi5hcmVQb3J0c0hpZGRlbilzd2l0Y2goYSh3KG4ubE5vZGUsKEsoKSxpcSkpLDEwMSkub3JkaW5hbCl7Y2FzZSAwOmNhc2UgMTpNMG4obik7Y2FzZSAyOkxyKG5ldyBTZShudWxsLG5ldyB4ZShuLnNsSHlwZXJMb29wcywxNikpLG5ldyBaaiksUDBuKGUucG9ydFJlc3RvcmVyLG4pfWVsc2UgTHIobmV3IFNlKG51bGwsbmV3IHhlKG4uc2xIeXBlckxvb3BzLDE2KSksbmV3IFpqKX1mdW5jdGlvbiBWU2UoKXt0aGlzLnBvcnRSZXN0b3Jlcj1uZXcgd1RlfXAoMTY1NywxLHNyLFZTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7anVuKHRoaXMsYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUG9ydFJlc3RvcmVyIiwxNjU3KTtmdW5jdGlvbiBxU2UoKXt9cCgxNjU4LDEse30scVNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvcnRSZXN0b3Jlci9sYW1iZGEkMCRUeXBlIiwxNjU4KTtmdW5jdGlvbiBZU2UoKXt9cCgxNjU5LDEsSW4sWVNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEwKS50eXBlXzA9PShXZSgpLGtyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUG9ydFJlc3RvcmVyL2xhbWJkYSQxJFR5cGUiLDE2NTkpO2Z1bmN0aW9uIEtTZSgpe31wKDE2NjAsMSxJbixLU2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBfcihhKG4sMTApLChLKCksWjEpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUG9ydFJlc3RvcmVyL2xhbWJkYSQyJFR5cGUiLDE2NjApO2Z1bmN0aW9uIFhTZSgpe31wKDE2NjEsMSx7fSxYU2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYSh3KGEobiwxMCksKEsoKSxaMSkpLDMzNyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvcnRSZXN0b3Jlci9sYW1iZGEkMyRUeXBlIiwxNjYxKTtmdW5jdGlvbiBKU2UoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE2NjIsMSxKZSxKU2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1Z1bih0aGlzLiQkb3V0ZXJfMCxhKG4sMzM3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvcnRSZXN0b3Jlci9sYW1iZGEkNCRUeXBlIiwxNjYyKTtmdW5jdGlvbiBaaigpe31wKDgwNSwxLEplLFpqKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtvMG4oYShuLDEwNSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQb3J0UmVzdG9yZXIvbGFtYmRhJDUkVHlwZSIsODA1KTtmdW5jdGlvbiBxdW4oZSxuKXtuLmJlZ2luKCJTZWxmLUxvb3AgcG9zdC1wcm9jZXNzaW5nIiwxKSxMcihKbihKbihObyhuZXcgU2UobnVsbCxuZXcgeGUoZS5sYXllcnMsMTYpKSxuZXcgUVNlKSxuZXcgZUNlKSxuZXcgbkNlKSxuZXcgckNlKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIFl1bihlKXt2YXIgbjtuPWEodyhlLChLKCksWjEpKSwzMzcpLExyKE5vKG5ldyBTZShudWxsLG5ldyB4ZShuLnNsSHlwZXJMb29wcywxNikpLG5ldyB0Q2UpLG5ldyBvQ2UoZSkpLExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZShuLnNsSHlwZXJMb29wcywxNikpLG5ldyBpQ2UpLG5ldyBhQ2UoZSkpfWZ1bmN0aW9uIEt1bihlLG4pe3ZhciByO3I9bi5sRWRnZSxMdChyLG4uc2xTb3VyY2UubFBvcnQpLF90KHIsbi5zbFRhcmdldC5sUG9ydCksVWYoci5iZW5kUG9pbnRzLGUucG9zKX1mdW5jdGlvbiBaU2UoKXt9ZnVuY3Rpb24gWHVuKGUsbil7YTBuKG4uc2xMYWJlbHMsZS5wb3MpfXAoMTY2MywxLHNyLFpTZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cXVuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvc3RQcm9jZXNzb3IiLDE2NjMpO2Z1bmN0aW9uIFFTZSgpe31wKDE2NjQsMSx7fSxRU2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwzMCkubm9kZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUG9zdFByb2Nlc3Nvci9sYW1iZGEkMCRUeXBlIiwxNjY0KTtmdW5jdGlvbiBlQ2UoKXt9cCgxNjY1LDEsSW4sZUNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEwKS50eXBlXzA9PShXZSgpLGtyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUG9zdFByb2Nlc3Nvci9sYW1iZGEkMSRUeXBlIiwxNjY1KTtmdW5jdGlvbiBuQ2UoKXt9cCgxNjY2LDEsSW4sbkNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gX3IoYShuLDEwKSwoSygpLFoxKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvc3RQcm9jZXNzb3IvbGFtYmRhJDIkVHlwZSIsMTY2Nik7ZnVuY3Rpb24gckNlKCl7fXAoMTY2NywxLEplLHJDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7WXVuKGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQb3N0UHJvY2Vzc29yL2xhbWJkYSQzJFR5cGUiLDE2NjcpO2Z1bmN0aW9uIHRDZSgpe31wKDE2NjgsMSx7fSx0Q2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwxMDUpLnNsRWRnZXMsMSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQb3N0UHJvY2Vzc29yL2xhbWJkYSQ0JFR5cGUiLDE2NjgpO2Z1bmN0aW9uIG9DZShlKXt0aGlzLmxOb2RlXzE9ZX1wKDE2NjksMSxKZSxvQ2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0t1bih0aGlzLmxOb2RlXzEsYShuLDM0MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQb3N0UHJvY2Vzc29yL2xhbWJkYSQ1JFR5cGUiLDE2NjkpO2Z1bmN0aW9uIGlDZSgpe31wKDE2NzAsMSxJbixpQ2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiEhYShuLDEwNSkuc2xMYWJlbHN9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvc3RQcm9jZXNzb3IvbGFtYmRhJDYkVHlwZSIsMTY3MCk7ZnVuY3Rpb24gYUNlKGUpe3RoaXMubE5vZGVfMD1lfXAoMTY3MSwxLEplLGFDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7WHVuKHRoaXMubE5vZGVfMCxhKG4sMTA1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFBvc3RQcm9jZXNzb3IvbGFtYmRhJDckVHlwZSIsMTY3MSk7ZnVuY3Rpb24gSnVuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXztpZih0PWUubE5vZGUsaT10Lm5lc3RlZEdyYXBoLHM9X20oYSh3KHQsKG9lKCkseHIpKSwxMDEpKSxyPSEhaSYmYSh3KGksKEsoKSxpaSkpLDIxKS5jb250YWlucygoVnQoKSxubCkpLCEoc3x8cikpZm9yKF89KHU9bmV3IHRjKGUuc2xQb3J0cykudGhpcyQwMS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyB0Zih1KSk7Xy52YWwkb3V0ZXJJdGVyMi5oYXNOZXh0XzAoKTspYz0obj1hKF8udmFsJG91dGVySXRlcjIubmV4dF8xKCksNDQpLGEobi5nZXRWYWx1ZSgpLDExMykpLGMuaGFkT25seVNlbGZMb29wcyYmKG89Yy5sUG9ydCxMbyhvLG51bGwpLGMuaXNIaWRkZW49ITAsZS5hcmVQb3J0c0hpZGRlbj0hMCl9ZnVuY3Rpb24gWnVuKGUpe0x0KGUsbnVsbCksX3QoZSxudWxsKX1mdW5jdGlvbiBRdW4oZSxuKXt2YXIgcix0LG8saTtmb3Iobi5iZWdpbigiU2VsZi1Mb29wIHByZS1wcm9jZXNzaW5nIiwxKSx0PW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxMCkscDBuKHIpJiYobz0oaT1uZXcgY1RlKHIpLGoociwoSygpLFoxKSxpKSxkMG4oaSksaSksTHIocG8oTm8obmV3IFNlKG51bGwsbmV3IHhlKG8uc2xIeXBlckxvb3BzLDE2KSksbmV3IHNDZSksbmV3IHVDZSksbmV3IGNDZSksSnVuKG8pKTtuLmRvbmVfMSgpfWZ1bmN0aW9uIGxDZSgpe31wKDE2NTMsMSxzcixsQ2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe1F1bihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQcmVQcm9jZXNzb3IiLDE2NTMpO2Z1bmN0aW9uIHNDZSgpe31wKDE2NTQsMSx7fSxzQ2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwxMDUpLnNsRWRnZXMsMSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VsZkxvb3BQcmVQcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTY1NCk7ZnVuY3Rpb24gdUNlKCl7fXAoMTY1NSwxLHt9LHVDZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzQwKS5sRWRnZX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUHJlUHJvY2Vzc29yL2xhbWJkYSQxJFR5cGUiLDE2NTUpO2Z1bmN0aW9uIGNDZSgpe31wKDE2NTYsMSxKZSxjQ2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1p1bihhKG4sMTgpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUHJlUHJvY2Vzc29yL2xhbWJkYSQyJFR5cGUiLDE2NTYpO2Z1bmN0aW9uIGVjbihlLG4scil7bF9uKGUucm91dGluZ0RpcmVjdG9yLHIpLFYwbihyKSxmX24oZS5yb3V0aW5nU2xvdEFzc2lnbmVyLHIpLGVfbihuLHIpfWZ1bmN0aW9uIG5jbihlLG4scil7dmFyIHQ7ci5iZWdpbigiU2VsZi1Mb29wIHJvdXRpbmciLDEpLHQ9cmNuKG4pLGVJKHcobiwoVk4oKSxNdikpKSxMcihwbyhKbihKbihObyhuZXcgU2UobnVsbCxuZXcgeGUobi5sYXllcnMsMTYpKSxuZXcgZENlKSxuZXcgZkNlKSxuZXcgcENlKSxuZXcgZ0NlKSxuZXcgaENlKGUsdCkpLHIuZG9uZV8xKCl9ZnVuY3Rpb24gcmNuKGUpe3N3aXRjaChhKHcoZSwob2UoKSx1YykpLDIyMykub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBuZXcgcmJlO2Nhc2UgMzpyZXR1cm4gbmV3IGZiZTtkZWZhdWx0OnJldHVybiBuZXcgUVRlfX1mdW5jdGlvbiBfQ2UoKXt0aGlzLnJvdXRpbmdEaXJlY3Rvcj1uZXcgaWJlLHRoaXMucm91dGluZ1Nsb3RBc3NpZ25lcj1uZXcgY2JlfXAoMTY3MiwxLHNyLF9DZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7bmNuKHRoaXMsYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUm91dGVyIiwxNjcyKTtmdW5jdGlvbiBkQ2UoKXt9cCgxNjczLDEse30sZENlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFJvdXRlci9sYW1iZGEkMCRUeXBlIiwxNjczKTtmdW5jdGlvbiBmQ2UoKXt9cCgxNjc0LDEsSW4sZkNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEwKS50eXBlXzA9PShXZSgpLGtyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUm91dGVyL2xhbWJkYSQxJFR5cGUiLDE2NzQpO2Z1bmN0aW9uIHBDZSgpe31wKDE2NzUsMSxJbixwQ2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBfcihhKG4sMTApLChLKCksWjEpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUm91dGVyL2xhbWJkYSQyJFR5cGUiLDE2NzUpO2Z1bmN0aW9uIGdDZSgpe31wKDE2NzYsMSx7fSxnQ2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYSh3KGEobiwxMCksKEsoKSxaMSkpLDMzNyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTZWxmTG9vcFJvdXRlci9sYW1iZGEkMyRUeXBlIiwxNjc2KTtmdW5jdGlvbiBoQ2UoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMucm91dGVyXzI9bn1wKDE2NzcsMSxKZSxoQ2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Vjbih0aGlzLiQkb3V0ZXJfMCx0aGlzLnJvdXRlcl8yLGEobiwzMzcpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbGZMb29wUm91dGVyL2xhbWJkYSQ0JFR5cGUiLDE2NzcpO2Z1bmN0aW9uIHRjbihlLG4pe3ZhciByLHQsbyxpO2ZvcihuLmJlZ2luKCJTZW1pLUludGVyYWN0aXZlIENyb3NzaW5nIE1pbmltaXphdGlvbiBQcm9jZXNzb3IiLDEpLHI9ITEsbz1uZXcgVChlLmxheWVycyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDMwKSxpPUdDKEV4KEpuKEpuKG5ldyBTZShudWxsLG5ldyB4ZSh0Lm5vZGVzLDE2KSksbmV3IHlDZSksbmV3IHdDZSksbmV3IEVDZSksbmV3IHZDZSkscj1yfGkucmVmIT1udWxsO3ImJmooZSwoSygpLGVxKSwoemUoKSwhMCkpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gbUNlKCl7fWZ1bmN0aW9uIG9jbihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9YSh3KGUsKG9lKCksT2YpKSw4KSx0PWEodyhuLE9mKSw4KSxpcihyLnlfMCx0LnlfMCl9ZnVuY3Rpb24gaWNuKGUsbil7cmV0dXJuIGEodyhlLChLKCksV2gpKSwxNSkuYWRkXzIobiksbn1wKDE2NzgsMSxzcixtQ2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe3RjbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VtaUludGVyYWN0aXZlQ3Jvc3NNaW5Qcm9jZXNzb3IiLDE2NzgpO2Z1bmN0aW9uIHlDZSgpe31wKDE2NzksMSxJbix5Q2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMTApLnR5cGVfMD09KFdlKCksa3IpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VtaUludGVyYWN0aXZlQ3Jvc3NNaW5Qcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTY3OSk7ZnVuY3Rpb24gd0NlKCl7fXAoMTY4MCwxLEluLHdDZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIERnZShhKG4sMTApKS5jb250YWluc0tleSgob2UoKSxPZikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlIiwiU2VtaUludGVyYWN0aXZlQ3Jvc3NNaW5Qcm9jZXNzb3IvbGFtYmRhJDEkVHlwZSIsMTY4MCk7ZnVuY3Rpb24gRUNlKCl7fXAoMTY4MSwxLE5uLEVDZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gb2NuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbWlJbnRlcmFjdGl2ZUNyb3NzTWluUHJvY2Vzc29yL2xhbWJkYSQyJFR5cGUiLDE2ODEpO2Z1bmN0aW9uIHZDZSgpe31wKDE2ODIsMSx7fSx2Q2UpLGwuYXBwbHlfMz1mdW5jdGlvbihuLHIpe3JldHVybiBpY24oYShuLDEwKSxhKHIsMTApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNlbWlJbnRlcmFjdGl2ZUNyb3NzTWluUHJvY2Vzc29yL2xhbWJkYSQzJFR5cGUiLDE2ODIpO2Z1bmN0aW9uIGFjbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihuLmJlZ2luKCJTb3J0IEJ5IElucHV0IE1vZGVsICIrdyhlLChvZSgpLER1KSksMSksbz0wLHQ9bmV3IFQoZS5sYXllcnMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHI9YShDKHQpLDMwKSxjPW89PTA/MDpvLTEsdT1hKGxlKGUubGF5ZXJzLGMpLDMwKSxzPW5ldyBUKHIubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMCksRCh3KGkseHIpKSE9PUQoKGR0KCksbzEpKSYmRCh3KGkseHIpKSE9PUQoYWkpJiYoTmUoKSxEcihpLnBvcnRzLG5ldyBTYmUodSxhKHcoZSxEdSksMjg0KSxDQ2UoaSksYWUoaWUodyhlLG1PKSkpKSksbi5sb2dfMCgiTm9kZSAiK2krIiBwb3J0czogIitpLnBvcnRzKSk7TmUoKSxEcihyLm5vZGVzLG5ldyBnYmUodSxhKHcoZSxEdSksMjg0KSxhKHcoZSwkcSksMzkwKSkpLG4ubG9nXzAoIkxheWVyICIrbysiOiAiK3IpLCsrb31uLmRvbmVfMSgpfWZ1bmN0aW9uIFNDZSgpe31mdW5jdGlvbiBsY24oZSl7dmFyIG4scjtyPW51bGwsbj1hKGxlKGUub3V0Z29pbmdFZGdlcywwKSwxOCk7ZG97aWYocj1uLnRhcmdldC5vd25lcixfcihyLChLKCksdmwpKSlyZXR1cm4gYSh3KHIsdmwpLDEyKS5vd25lcjtpZihyLnR5cGVfMCE9KFdlKCksa3IpJiZfbihuZXcgWGUoUWUoUnIocikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSluPWEodG4obmV3IFhlKFFlKFJyKHIpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksMTgpO2Vsc2UgaWYoci50eXBlXzAhPWtyKXJldHVybiBudWxsfXdoaWxlKHImJnIudHlwZV8wIT0oV2UoKSxrcikpO3JldHVybiByfWZ1bmN0aW9uIHNjbihlLG4pe3ZhciByLHQsbztvPWxjbihuKSxqKG4sKEsoKSxfTyksbyksbyYmKHQ9cW4sanQoZS5oYXNoQ29kZU1hcCxvKSYmKHQ9YShfbyhqdChlLmhhc2hDb2RlTWFwLG8pKSwxNykudmFsdWVfMCkscj1hKGxlKG4ub3V0Z29pbmdFZGdlcywwKSwxOCksYWUoaWUodyhyLE9zKSkpfHxCbihlLG8sSihTLk1hdGgubWluKGEodyhyLHJyKSwxNykudmFsdWVfMCx0KSkpKX1mdW5jdGlvbiBDQ2UoZSl7dmFyIG47cmV0dXJuIG49bmV3IHNuLF9yKGUsKEsoKSxwTykpP2EodyhlLHBPKSw4NSk6KExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZShlLnBvcnRzLDE2KSksbmV3IFRDZSksbmV3IGJDZShuKSksaihlLHBPLG4pLG4pfXAoMTY4NCwxLHNyLFNDZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7YWNuKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUiLCJTb3J0QnlJbnB1dE1vZGVsUHJvY2Vzc29yIiwxNjg0KTtmdW5jdGlvbiBUQ2UoKXt9cCgxNjg1LDEsSW4sVENlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEyKS5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNvcnRCeUlucHV0TW9kZWxQcm9jZXNzb3IvbGFtYmRhJDAkVHlwZSIsMTY4NSk7ZnVuY3Rpb24gYkNlKGUpe3RoaXMudGFyZ2V0Tm9kZU1vZGVsT3JkZXJfMD1lfXAoMTY4NiwxLEplLGJDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7c2NuKHRoaXMudGFyZ2V0Tm9kZU1vZGVsT3JkZXJfMCxhKG4sMTIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZSIsIlNvcnRCeUlucHV0TW9kZWxQcm9jZXNzb3IvbGFtYmRhJDEkVHlwZSIsMTY4Nik7ZnVuY3Rpb24gSUNlKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKG89ZS5tYXN0ZXIsIW8mJihvPWEoZS5jTm9kZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCkubmV4dF8xKCksNjApKSxORShvLG4sciksZS5jTm9kZXMubWFwXzAuc2l6ZV8xKCkhPTEpZm9yKHQ9bipyLHM9ZS5jTm9kZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksNjApLGkhPW8mJih1PUZoKGkpLHUuaWdub3JlU3BhY2luZy51cD8oaS5oaXRib3gueV8wKz10K0NzLGkuaGl0Ym94LmhlaWdodC09dCtDcyk6dS5pZ25vcmVTcGFjaW5nLmRvd24mJihpLmhpdGJveC5oZWlnaHQtPXQrQ3MpKX1mdW5jdGlvbiBORShlLG4scil7dmFyIHQsbzt0PW4qcixMKGUub3JpZ2luXzAsMTU0KT8obz1GaChlKSxvLmlnbm9yZVNwYWNpbmcudXA/by5pZ25vcmVTcGFjaW5nLmRvd258fChlLmhpdGJveC5oZWlnaHQrPXQrQ3MpOihlLmhpdGJveC55XzAtPXQrQ3MsZS5oaXRib3guaGVpZ2h0Kz10K0NzKSk6TChlLm9yaWdpbl8wLDEwKSYmKGUuaGl0Ym94LnlfMC09dCxlLmhpdGJveC5oZWlnaHQrPTIqdCl9ZnVuY3Rpb24gdWNuKGUsbil7dmFyIHIsdCxvO3JldHVybiBMKG4ub3JpZ2luXzAsMTApJiZhKG4ub3JpZ2luXzAsMTApLnR5cGVfMD09KFdlKCksRnIpP2hyOihvPUZoKG4pLG8/Uy5NYXRoLm1heCgwLGUudmVydGljYWxFZGdlRWRnZVNwYWNpbmcvMi0uNSk6KHI9anAobikscj8odD1SKCQoemYociwob2UoKSxvZCkpKSksUy5NYXRoLm1heCgwLHQvMi0uNSkpOmhyKSl9ZnVuY3Rpb24gY2NuKGUsbil7dmFyIHIsdCxvO3Q9anAobiksbz1SKCQoemYodCwob2UoKSxxbCkpKSkscj1TLk1hdGgubWF4KDAsby8yLS41KSxORShuLHIsMSksZWUoZSxuZXcgUkNlKG4scikpfWZ1bmN0aW9uIF9jbihlLG4pe3ZhciByLHQsbztyZXR1cm4gTChuLm9yaWdpbl8wLDEwKSYmYShuLm9yaWdpbl8wLDEwKS50eXBlXzA9PShXZSgpLEZyKT9ocjoobz1GaChuKSxvP1MuTWF0aC5tYXgoMCxlLnZlcnRpY2FsRWRnZUVkZ2VTcGFjaW5nLzItLjUpOihyPWpwKG4pLHI/KHQ9UigkKHpmKHIsKG9lKCksb2QpKSkpLFMuTWF0aC5tYXgoMCx0LzItLjUpKTpocikpfWZ1bmN0aW9uIGRjbihlLG4scil7SUNlKHIsZSwxKSxlZShuLG5ldyBIQ2UocixlKSl9ZnVuY3Rpb24gZmNuKGUsbixyKXtORShyLGUsMSksZWUobixuZXcgcUNlKHIsZSkpfWZ1bmN0aW9uIHBjbihlLG4scil7dmFyIHQ7dD1TLk1hdGgubWF4KDAsZS52ZXJ0aWNhbEVkZ2VFZGdlU3BhY2luZy8yLS41KSxORShyLHQsMSksZWUobixuZXcgQUNlKHIsdCkpfWZ1bmN0aW9uIHhDZShlKXt1SC5jYWxsKHRoaXMpLHRoaXMudmVydGljYWxFZGdlRWRnZVNwYWNpbmc9UigkKHcoZSwob2UoKSxxbCkpKSksdGhpcy5lZGdlUm91dGluZz1hKHcoZSx1YyksMjIzKX1wKDE3NTksODE3LHt9LHhDZSksbC5jYWxjdWxhdGVDb25zdHJhaW50cz1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtzd2l0Y2godGhpcy5jb21wYWN0b3I9bix0aGlzLmVkZ2VSb3V0aW5nLm9yZGluYWwpe2Nhc2UgMjpyPW5ldyBRLExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLmNvbXBhY3Rvci5jR3JhcGguY05vZGVzLDE2KSksbmV3IFhDZSksbmV3IEpDZSh0aGlzLHIpKSxqQyh0aGlzLG5ldyBMQ2UpLHdpKHIsbmV3IGtDZSksci5hcnJheS5sZW5ndGg9MCxMcihKbihuZXcgU2UobnVsbCxuZXcgeGUodGhpcy5jb21wYWN0b3IuY0dyYXBoLmNOb2RlcywxNikpLG5ldyBPQ2UpLG5ldyBNQ2UocikpLGpDKHRoaXMsbmV3IERDZSksd2kocixuZXcgRkNlKSxyLmFycmF5Lmxlbmd0aD0wLHQ9d19lKE1rKHVmKG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLmNvbXBhY3Rvci5jR3JhcGguY05vZGVzLDE2KSksbmV3IHpDZSh0aGlzKSkpLG5ldyAkQ2UpLExyKG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLmNvbXBhY3Rvci5jR3JhcGguY0dyb3VwcywxNikpLG5ldyBHQ2UodCxyKSksakModGhpcyxuZXcgVUNlKSx3aShyLG5ldyBXQ2UpLHIuYXJyYXkubGVuZ3RoPTA7YnJlYWs7Y2FzZSAzOm89bmV3IFEsakModGhpcyxuZXcgUENlKSxpPXdfZShNayh1ZihuZXcgU2UobnVsbCxuZXcgeGUodGhpcy5jb21wYWN0b3IuY0dyYXBoLmNOb2RlcywxNikpLG5ldyBOQ2UodGhpcykpKSxuZXcgQkNlKSxMcihKbihuZXcgU2UobnVsbCxuZXcgeGUodGhpcy5jb21wYWN0b3IuY0dyYXBoLmNOb2RlcywxNikpLG5ldyBqQ2UpLG5ldyBWQ2UoaSxvKSksakModGhpcyxuZXcgWUNlKSx3aShvLG5ldyBLQ2UpLG8uYXJyYXkubGVuZ3RoPTA7YnJlYWs7ZGVmYXVsdDp0aHJvdyBiKG5ldyBJUmUpfX0sbC52ZXJ0aWNhbEVkZ2VFZGdlU3BhY2luZz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uIiwxNzU5KTtmdW5jdGlvbiBQQ2UoKXt9cCgxNzYwLDEsSnMsUENlKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIEwoYShuLDYwKS5vcmlnaW5fMCwxNTQpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEwoYShuLDYwKS5vcmlnaW5fMCwxNTQpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMCRUeXBlIiwxNzYwKTtmdW5jdGlvbiBOQ2UoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE3NjEsMSx7fSxOQ2UpLGwuYXBwbHlBc0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gdWNuKHRoaXMuJCRvdXRlcl8wLGEobiw2MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMSRUeXBlIiwxNzYxKTtmdW5jdGlvbiBBQ2UoZSxuKXt0aGlzLm5fMT1lLHRoaXMuc3BhY2luZ18yPW59cCgxNzY5LDEsVWIsQUNlKSxsLnJ1bj1mdW5jdGlvbigpe05FKHRoaXMubl8xLHRoaXMuc3BhY2luZ18yLC0xKX0sbC5zcGFjaW5nXzI9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTAkVHlwZSIsMTc2OSk7ZnVuY3Rpb24gTENlKCl7fXAoMTc3MSwxLEpzLExDZSksbC5hcHBseV8xPWZ1bmN0aW9uKG4pe3JldHVybiBMKGEobiw2MCkub3JpZ2luXzAsMTU0KX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBMKGEobiw2MCkub3JpZ2luXzAsMTU0KX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDExJFR5cGUiLDE3NzEpO2Z1bmN0aW9uIGtDZSgpe31wKDE3NzIsMSxKZSxrQ2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2EobiwzODApLnJ1bigpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTIkVHlwZSIsMTc3Mik7ZnVuY3Rpb24gT0NlKCl7fXAoMTc3MywxLEluLE9DZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEwoYShuLDYwKS5vcmlnaW5fMCwxMCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uL2xhbWJkYSQxMyRUeXBlIiwxNzczKTtmdW5jdGlvbiBNQ2UoZSl7dGhpcy5zY2hlZHVsZV8xPWV9cCgxNzc1LDEsSmUsTUNlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtjY24odGhpcy5zY2hlZHVsZV8xLGEobiw2MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTQkVHlwZSIsMTc3NSk7ZnVuY3Rpb24gUkNlKGUsbil7dGhpcy5uXzE9ZSx0aGlzLmZpbmFsU3BhY2luZ18yPW59cCgxNzc0LDEsVWIsUkNlKSxsLnJ1bj1mdW5jdGlvbigpe05FKHRoaXMubl8xLHRoaXMuZmluYWxTcGFjaW5nXzIsLTEpfSxsLmZpbmFsU3BhY2luZ18yPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDE1JFR5cGUiLDE3NzQpO2Z1bmN0aW9uIERDZSgpe31wKDE3NzYsMSxKcyxEQ2UpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gTChhKG4sNjApLm9yaWdpbl8wLDEwKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBMKGEobiw2MCkub3JpZ2luXzAsMTApfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTYkVHlwZSIsMTc3Nik7ZnVuY3Rpb24gRkNlKCl7fXAoMTc3NywxLEplLEZDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7YShuLDM4MCkucnVuKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uL2xhbWJkYSQxNyRUeXBlIiwxNzc3KTtmdW5jdGlvbiB6Q2UoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE3NzgsMSx7fSx6Q2UpLGwuYXBwbHlBc0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gX2NuKHRoaXMuJCRvdXRlcl8wLGEobiw2MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTgkVHlwZSIsMTc3OCk7ZnVuY3Rpb24gJENlKCl7fXAoMTc3OSwxLHt9LCRDZSksbC5nZXRBc0RvdWJsZT1mdW5jdGlvbigpe3JldHVybiAwfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMTkkVHlwZSIsMTc3OSk7ZnVuY3Rpb24gQkNlKCl7fXAoMTc2MiwxLHt9LEJDZSksbC5nZXRBc0RvdWJsZT1mdW5jdGlvbigpe3JldHVybiAwfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMiRUeXBlIiwxNzYyKTtmdW5jdGlvbiBHQ2UoZSxuKXt0aGlzLm1pblNwYWNpbmdfMT1lLHRoaXMuc2NoZWR1bGVfMz1ufXAoMTc4MSwxLEplLEdDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7ZGNuKHRoaXMubWluU3BhY2luZ18xLHRoaXMuc2NoZWR1bGVfMyxhKG4sMzE2KSl9LGwubWluU3BhY2luZ18xPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDIwJFR5cGUiLDE3ODEpO2Z1bmN0aW9uIEhDZShlLG4pe3RoaXMuZ18xPWUsdGhpcy5taW5TcGFjaW5nXzI9bn1wKDE3ODAsMSxVYixIQ2UpLGwucnVuPWZ1bmN0aW9uKCl7SUNlKHRoaXMuZ18xLHRoaXMubWluU3BhY2luZ18yLC0xKX0sbC5taW5TcGFjaW5nXzI9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMjEkVHlwZSIsMTc4MCk7ZnVuY3Rpb24gVUNlKCl7fXAoMTc4MiwxLEpzLFVDZSksbC5hcHBseV8xPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNjApLCEwfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiw2MCksITB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uL2xhbWJkYSQyMiRUeXBlIiwxNzgyKTtmdW5jdGlvbiBXQ2UoKXt9cCgxNzgzLDEsSmUsV0NlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXthKG4sMzgwKS5ydW4oKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDIzJFR5cGUiLDE3ODMpO2Z1bmN0aW9uIGpDZSgpe31wKDE3NjMsMSxJbixqQ2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBMKGEobiw2MCkub3JpZ2luXzAsMTApfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkMyRUeXBlIiwxNzYzKTtmdW5jdGlvbiBWQ2UoZSxuKXt0aGlzLm1pblNwYWNpbmdfMT1lLHRoaXMuc2NoZWR1bGVfMz1ufXAoMTc2NSwxLEplLFZDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7ZmNuKHRoaXMubWluU3BhY2luZ18xLHRoaXMuc2NoZWR1bGVfMyxhKG4sNjApKX0sbC5taW5TcGFjaW5nXzE9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkNCRUeXBlIiwxNzY1KTtmdW5jdGlvbiBxQ2UoZSxuKXt0aGlzLm5fMT1lLHRoaXMubWluU3BhY2luZ18yPW59cCgxNzY0LDEsVWIscUNlKSxsLnJ1bj1mdW5jdGlvbigpe05FKHRoaXMubl8xLHRoaXMubWluU3BhY2luZ18yLC0xKX0sbC5taW5TcGFjaW5nXzI9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJFZGdlQXdhcmVTY2FubGluZUNvbnN0cmFpbnRDYWxjdWxhdGlvbi9sYW1iZGEkNSRUeXBlIiwxNzY0KTtmdW5jdGlvbiBZQ2UoKXt9cCgxNzY2LDEsSnMsWUNlKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIGEobiw2MCksITB9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDYwKSwhMH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDYkVHlwZSIsMTc2Nik7ZnVuY3Rpb24gS0NlKCl7fXAoMTc2NywxLEplLEtDZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7YShuLDM4MCkucnVuKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uL2xhbWJkYSQ3JFR5cGUiLDE3NjcpO2Z1bmN0aW9uIFhDZSgpe31wKDE3NjgsMSxJbixYQ2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBMKGEobiw2MCkub3JpZ2luXzAsMTU0KX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiRWRnZUF3YXJlU2NhbmxpbmVDb25zdHJhaW50Q2FsY3VsYXRpb24vbGFtYmRhJDgkVHlwZSIsMTc2OCk7ZnVuY3Rpb24gSkNlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLnNjaGVkdWxlXzE9bn1wKDE3NzAsMSxKZSxKQ2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3Bjbih0aGlzLiQkb3V0ZXJfMCx0aGlzLnNjaGVkdWxlXzEsYShuLDYwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkVkZ2VBd2FyZVNjYW5saW5lQ29uc3RyYWludENhbGN1bGF0aW9uL2xhbWJkYSQ5JFR5cGUiLDE3NzApO2Z1bmN0aW9uIEFFKCl7QUU9RixRQ2U9bmV3IE8zZX1mdW5jdGlvbiBnY24oZSxuLHIpe3ZhciB0LG8saTtpZihvPWEodyhuLChvZSgpLG1QKSksMjgyKSxvIT0oWnkoKSwkRSkpe3N3aXRjaChyLmJlZ2luKCJIb3Jpem9udGFsIENvbXBhY3Rpb24iLDEpLGUubEdyYXBoPW4saT1uZXcgaTNlLHQ9bmV3IEpkZSgoaS5sYXllcmVkR3JhcGg9bixpLmVkZ2VSb3V0aW5nPWEodyhpLmxheWVyZWRHcmFwaCx1YyksMjIzKSxDY24oaSksQWNuKGkpLE5jbihpKSxpLmNHcmFwaCkpLFplbih0LGUuc3BlY2lhbFNwYWNpbmdzSGFuZGxlciksYSh3KG4sRnEpLDQzMSkub3JkaW5hbCl7Y2FzZSAxOktkZSh0LG5ldyB4Q2UoZS5sR3JhcGgpKTticmVhaztkZWZhdWx0OktkZSh0LChsSCgpLFFkZSkpfXN3aXRjaChvLm9yZGluYWwpe2Nhc2UgMTpsRSh0KTticmVhaztjYXNlIDI6bEUoSXgodCwoV3IoKSxtbykpKTticmVhaztjYXNlIDM6bEUoWGRlKEl4KGxFKHQpLChXcigpLG1vKSksbmV3IG4zZSkpO2JyZWFrO2Nhc2UgNDpsRShYZGUoSXgobEUodCksKFdyKCksbW8pKSxuZXcgcjNlKGkpKSk7YnJlYWs7Y2FzZSA1OmxFKEplbih0LFFDZSkpfUl4KHQsKFdyKCksYW8pKSx0LmZpbmlzaGVkPSEwLEVjbihpKSxyLmRvbmVfMSgpfX1mdW5jdGlvbiBaQ2UoKXtBRSgpLHRoaXMuc3BlY2lhbFNwYWNpbmdzSGFuZGxlcj1uZXcgZTNlKHRoaXMpfWZ1bmN0aW9uIGpwKGUpe3JldHVybiBBRSgpLEwoZS5vcmlnaW5fMCwxMCk/YShlLm9yaWdpbl8wLDEwKTpudWxsfWZ1bmN0aW9uIEZoKGUpe3JldHVybiBBRSgpLEwoZS5vcmlnaW5fMCwxNTQpP2EoZS5vcmlnaW5fMCwxNTQpOm51bGx9ZnVuY3Rpb24gUWooZSxuKXtBRSgpO3ZhciByLHQ7cmV0dXJuIHI9RmgoZSksdD1GaChuKSwhIXImJiEhdCYmIWwwZShyLnJlcHJlc2VudGVkTEVkZ2VzLHQucmVwcmVzZW50ZWRMRWRnZXMpfWZ1bmN0aW9uIGhjbihlLG4scil7cmV0dXJuIEFFKCksZW5uKGEoS2UoZS5sb2NrTWFwLG4pLDUyOSkscil9cCgxNTg2LDEsc3IsWkNlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtnY24odGhpcyxhKG4sMzYpLHIpfTt2YXIgUUNlO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkhvcml6b250YWxHcmFwaENvbXBhY3RvciIsMTU4Nik7ZnVuY3Rpb24gZTNlKGUpe3RoaXMudGhpcyQwMT1lfXAoMTU4NywxLHt9LGUzZSksbC5nZXRIb3Jpem9udGFsU3BhY2luZz1mdW5jdGlvbihuLHIpe3ZhciB0LG8saTtyZXR1cm4gUWoobixyKXx8KHQ9anAobiksbz1qcChyKSx0JiZ0LnR5cGVfMD09KFdlKCksRnIpfHxvJiZvLnR5cGVfMD09KFdlKCksRnIpKT8wOihpPWEodyh0aGlzLnRoaXMkMDEubEdyYXBoLChLKCksZWcpKSwzMTIpLEsxbihpLHQ/dC50eXBlXzA6KFdlKCksaXQpLG8/by50eXBlXzA6KFdlKCksaXQpKSl9LGwuZ2V0VmVydGljYWxTcGFjaW5nPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpO3JldHVybiBRaihuLHIpPzE6KHQ9anAobiksbz1qcChyKSxpPWEodyh0aGlzLnRoaXMkMDEubEdyYXBoLChLKCksZWcpKSwzMTIpLEtZKGksdD90LnR5cGVfMDooV2UoKSxpdCksbz9vLnR5cGVfMDooV2UoKSxpdCkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiSG9yaXpvbnRhbEdyYXBoQ29tcGFjdG9yLzEiLDE1ODcpO2Z1bmN0aW9uIG4zZSgpe31wKDE1ODgsMSx7fSxuM2UpLGwuaXNMb2NrZWQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gQUUoKSxuLmNHcm91cC5vdXREZWdyZWVSZWFsPT0wfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJIb3Jpem9udGFsR3JhcGhDb21wYWN0b3IvbGFtYmRhJDAkVHlwZSIsMTU4OCk7ZnVuY3Rpb24gcjNlKGUpe3RoaXMudHJhbnNmb3JtZXJfMD1lfXAoMTU4OSwxLHt9LHIzZSksbC5pc0xvY2tlZD1mdW5jdGlvbihuLHIpe3JldHVybiBoY24odGhpcy50cmFuc2Zvcm1lcl8wLG4scil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkhvcml6b250YWxHcmFwaENvbXBhY3Rvci9sYW1iZGEkMSRUeXBlIiwxNTg5KTtmdW5jdGlvbiBWbCgpe1ZsPUYsYTNlPW5ldyB1M2UsbDNlPW5ldyBjM2V9ZnVuY3Rpb24gdDNlKGUsbixyLHQsbyxpKXt2YXIgcyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7Zm9yKGQ9dCxuLmluaXRpYWxTZWdtZW50JiZuLmlzU3RyYWlnaHQ/KG09YShLZShlLm5vZGVzTWFwLG4uc291cmNlTm9kZSksNjApLEU9bS5oaXRib3gueF8wK20uaGl0Ym94LndpZHRoXzAsLS1kKTpFPW4uYm91bmRpbmdCb3gueF8wK24uYm91bmRpbmdCb3gud2lkdGhfMCxmPW8sci5sYXN0U2VnbWVudCYmci5pc1N0cmFpZ2h0PyhtPWEoS2UoZS5ub2Rlc01hcCxyLnRhcmdldE5vZGUpLDYwKSxfPW0uaGl0Ym94LnhfMCwrK2YpOl89ci5ib3VuZGluZ0JveC54XzAsdj1fLUUsYz1TLk1hdGgubWF4KDIsZi1kKSx1PXYvYyx5PUUrdSxoPWQ7aDxmOysraClzPWEoaS5nZXRfMChoKSwxMzEpLHg9cy5ib3VuZGluZ0JveC53aWR0aF8wLHMuYm91bmRpbmdCb3gueF8wPXkteC8yLHkrPXV9ZnVuY3Rpb24gbWNuKGUsbil7dmFyIHIsdCxvLGkscztpZighbi5pc0VtcHR5KCkpe2lmKG89YShuLmdldF8wKDApLDEzMSksbi5zaXplXzEoKT09MSl7dDNlKGUsbyxvLDEsMCxuKTtyZXR1cm59Zm9yKHI9MTtyPG4uc2l6ZV8xKCk7KShvLmluaXRpYWxTZWdtZW50fHwhby5pc1N0cmFpZ2h0KSYmKGk9U2NuKG4sciksaSYmKHQ9YShpLmZpcnN0LDE3KS52YWx1ZV8wLHM9YShpLnNlY29uZCwxMzEpLHQzZShlLG8scyxyLHQsbikscj10KzEsbz1zKSl9fWZ1bmN0aW9uIHljbihlKXt2YXIgbixyLHQsbyxpO2Zvcih0PW5ldyBMXyhuZXcgQV8oZS5jb21tZW50T2Zmc2V0cykudGhpcyQwMSk7dC5oYXNOZXh0OylyPU4xKHQpLG49YShyLmdldEtleSgpLDEwKSxpPWEoYShyLmdldFZhbHVlKCksNDIpLmZpcnN0LDEwKSxvPWEoYShyLmdldFZhbHVlKCksNDIpLnNlY29uZCw4KSxLbihtcyhuLnBvcyksS24oQ3QoaS5wb3MpLG8pKX1mdW5jdGlvbiB3Y24oZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZih0PWEoQyhvKSw2MCksaT1qcCh0KSxpJiZpLnR5cGVfMD09KFdlKCksRnIpKXN3aXRjaChhKHcoaSwoSygpLERvKSksNjQpLm9yZGluYWwpe2Nhc2UgNDppLnBvcy54XzA9bi54XzA7YnJlYWs7Y2FzZSAyOmkucG9zLnhfMD1yLnhfMC0oaS5zaXplXzAueF8wK2kubWFyZ2luLnJpZ2h0KTticmVhaztjYXNlIDE6aS5wb3MueV8wPW4ueV8wO2JyZWFrO2Nhc2UgMzppLnBvcy55XzA9ci55XzAtKGkuc2l6ZV8wLnlfMCtpLm1hcmdpbi5ib3R0b20pfX1mdW5jdGlvbiBFY24oZSl7dmFyIG4scix0LG87Zm9yKExyKEpuKG5ldyBTZShudWxsLG5ldyB4ZShlLmNHcmFwaC5jTm9kZXMsMTYpKSxuZXcgXzNlKSxuZXcgZDNlKSx5Y24oZSksTHIoSm4obmV3IFNlKG51bGwsbmV3IHhlKGUuY0dyYXBoLmNOb2RlcywxNikpLG5ldyBmM2UpLG5ldyBwM2UpLGUuZWRnZVJvdXRpbmc9PShmYygpLGNtKSYmKExyKEpuKE5vKG5ldyBTZShudWxsLG5ldyB4ZShuZXcga18oZS5ub2Rlc01hcCksMSkpLG5ldyB5M2UpLG5ldyB3M2UpLG5ldyBFM2UoZSkpLExyKEpuKHBvKE5vKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLmxheWVyZWRHcmFwaC5sYXllcnMsMTYpKSxuZXcgUzNlKSxuZXcgQzNlKSxuZXcgVDNlKSxuZXcgYjNlKSxuZXcgSTNlKGUpKSksbz1uZXcgWShocixociksbj1uZXcgWShWcixWciksdD1uZXcgVChlLmNHcmFwaC5jTm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw2MCksby54XzA9Uy5NYXRoLm1pbihvLnhfMCxyLmhpdGJveC54XzApLG8ueV8wPVMuTWF0aC5taW4oby55XzAsci5oaXRib3gueV8wKSxuLnhfMD1TLk1hdGgubWF4KG4ueF8wLHIuaGl0Ym94LnhfMCtyLmhpdGJveC53aWR0aF8wKSxuLnlfMD1TLk1hdGgubWF4KG4ueV8wLHIuaGl0Ym94LnlfMCtyLmhpdGJveC5oZWlnaHQpO0tuKG1zKGUubGF5ZXJlZEdyYXBoLm9mZnNldCksS04obmV3IFkoby54XzAsby55XzApKSksS24obXMoZS5sYXllcmVkR3JhcGguc2l6ZV8wKSxydChuZXcgWShuLnhfMCxuLnlfMCksbykpLHdjbihlLG8sbiksWmkoZS5ub2Rlc01hcCksWmkoZS5jb21tZW50T2Zmc2V0cyksWmkoZS52ZXJ0aWNhbFNlZ21lbnRzTWFwKSxaaShlLmxvY2tNYXApLGUuY0dyYXBoLmNHcm91cHMuYXJyYXkubGVuZ3RoPTAsZS5jR3JhcGguY05vZGVzLmFycmF5Lmxlbmd0aD0wLGUuY0dyYXBoPW51bGwsZS5sYXllcmVkR3JhcGg9bnVsbH1mdW5jdGlvbiB2Y24oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKEU9bmV3IFEsaD1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcnMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoZj1hKEMoaCksMzApLHk9bmV3IFQoZi5ub2Rlcyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IobT1hKEMoeSksMTApLG89YShLZShlLm5vZGVzTWFwLG0pLDYwKSxjPW5ldyBYZShRZShScihtKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24oYyk7KWlmKHM9YSh0bihjKSwxOCksdD1kbihzLmJlbmRQb2ludHMsMCksXz0hMCxkPW51bGwsdC5jdXJyZW50Tm9kZSE9dC50aGlzJDAxLnRhaWwpe2ZvcihuPWEodW4odCksOCkscj1udWxsLHMuc291cmNlLnNpZGU9PShyZSgpLFVlKSYmKHY9bmV3IExFKG4sbmV3IFkobi54XzAsby5oaXRib3gueV8wKSxvLHMpLHYuaWdub3JlU3BhY2luZy5kb3duPSEwLHYuYVBvcnQ9cy5zb3VyY2UsUmUoRS5hcnJheSx2KSkscy5zb3VyY2Uuc2lkZT09bG4mJih2PW5ldyBMRShuLG5ldyBZKG4ueF8wLG8uaGl0Ym94LnlfMCtvLmhpdGJveC5oZWlnaHQpLG8scyksdi5pZ25vcmVTcGFjaW5nLnVwPSEwLHYuYVBvcnQ9cy5zb3VyY2UsUmUoRS5hcnJheSx2KSk7dC5jdXJyZW50Tm9kZSE9dC50aGlzJDAxLnRhaWw7KXI9YSh1bih0KSw4KSxpSChuLnlfMCxyLnlfMCl8fChkPW5ldyBMRShuLHIsbnVsbCxzKSxSZShFLmFycmF5LGQpLF8mJihfPSExLHIueV8wPG8uaGl0Ym94LnlfMD9kLmlnbm9yZVNwYWNpbmcuZG93bj0hMDpyLnlfMD5vLmhpdGJveC55XzArby5oaXRib3guaGVpZ2h0P2QuaWdub3JlU3BhY2luZy51cD0hMDooZC5pZ25vcmVTcGFjaW5nLnVwPSEwLGQuaWdub3JlU3BhY2luZy5kb3duPSEwKSkpLHQuY3VycmVudE5vZGUhPXQudGhpcyQwMS50YWlsJiYobj1yKTtkJiYoaT1hKEtlKGUubm9kZXNNYXAscy50YXJnZXQub3duZXIpLDYwKSxuLnlfMDxpLmhpdGJveC55XzA/ZC5pZ25vcmVTcGFjaW5nLmRvd249ITA6bi55XzA+aS5oaXRib3gueV8wK2kuaGl0Ym94LmhlaWdodD9kLmlnbm9yZVNwYWNpbmcudXA9ITA6KGQuaWdub3JlU3BhY2luZy51cD0hMCxkLmlnbm9yZVNwYWNpbmcuZG93bj0hMCkpfWZvcih1PW5ldyBYZShRZSh0dChtKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odSk7KXM9YSh0bih1KSwxOCkscy5iZW5kUG9pbnRzLnNpemVfMCE9MCYmKG49YShSbChzLmJlbmRQb2ludHMpLDgpLHMudGFyZ2V0LnNpZGU9PShyZSgpLFVlKSYmKHY9bmV3IExFKG4sbmV3IFkobi54XzAsby5oaXRib3gueV8wKSxvLHMpLHYuaWdub3JlU3BhY2luZy5kb3duPSEwLHYuYVBvcnQ9cy50YXJnZXQsUmUoRS5hcnJheSx2KSkscy50YXJnZXQuc2lkZT09bG4mJih2PW5ldyBMRShuLG5ldyBZKG4ueF8wLG8uaGl0Ym94LnlfMCtvLmhpdGJveC5oZWlnaHQpLG8scyksdi5pZ25vcmVTcGFjaW5nLnVwPSEwLHYuYVBvcnQ9cy50YXJnZXQsUmUoRS5hcnJheSx2KSkpfXJldHVybiBFfWZ1bmN0aW9uIFNjbihlLG4pe3ZhciByLHQ7aWYobjwwfHxuPj1lLnNpemVfMSgpKXJldHVybiBudWxsO2ZvcihyPW47cjxlLnNpemVfMSgpOysrcilpZih0PWEoZS5nZXRfMChyKSwxMzEpLHI9PWUuc2l6ZV8xKCktMXx8IXQuaXNTdHJhaWdodClyZXR1cm4gbmV3IFpyKEoociksdCk7cmV0dXJuIG51bGx9ZnVuY3Rpb24gQ2NuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihuPSExLHI9MCxvPW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih0PWEoQyhvKSwzMCksdC5pZF8wPXIrKyxzPW5ldyBUKHQubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMCksIW4mJiFKbShpYyhpKSkmJihuPSEwKTt1PWNyKChXcigpLEJzKSxQKEkoVnYsMSksVyw4OCwwLFthbyxtb10pKSxufHwoTWwodSxvbCksTWwodSwkcykpLGUuY0dyYXBoPW5ldyBrZGUodSksWmkoZS5ub2Rlc01hcCksWmkoZS5jb21tZW50T2Zmc2V0cyksWmkoZS5sb2NrTWFwKSxaaShlLnZlcnRpY2FsU2VnbWVudHNNYXApfWZ1bmN0aW9uIFRjbihlLG4pe3ZhciByLHQsbztvPW4uc291cmNlLm93bmVyLHI9YShLZShlLm5vZGVzTWFwLG8pLDYwKSx0PXIuaGl0Ym94LnhfMC1yLmhpdGJveFByZUNvbXBhY3Rpb24ueF8wLHJRKG4uYmVuZFBvaW50cyx0LDApfWZ1bmN0aW9uIGJjbihlLG4pe3ZhciByO3I9YShLZShlLnZlcnRpY2FsU2VnbWVudHNNYXAsbiksNjApLHdpKG4uY29uc3RyYWludHMsbmV3IHgzZShlLHIpKX1mdW5jdGlvbiBJY24oZSxuLHIpe3ZhciB0O3Q9YShLZShlLnZlcnRpY2FsU2VnbWVudHNNYXAsciksNjApLGVlKGUuY0dyYXBoLnByZWRlZmluZWRIb3Jpem9udGFsQ29uc3RyYWludHMsbmV3IFpyKG4sdCkpfWZ1bmN0aW9uIHhjbihlLG4scil7cmV0dXJuIEJuKGUudmVydGljYWxTZWdtZW50c01hcCxyLG4pfWZ1bmN0aW9uIFBjbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihuLmFycmF5Lmxlbmd0aCE9MCl7Zm9yKE5lKCksWDUobi5hcnJheSxuLmFycmF5Lmxlbmd0aCxudWxsKSxvPW5ldyBUKG4pLHQ9YShDKG8pLDE1NCk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKG8pLDE1NCksaUgodC5oaXRib3gueF8wLHIuaGl0Ym94LnhfMCkmJiEoYUgoVERlKHQuaGl0Ym94KS55XzAsci5oaXRib3gueV8wKXx8YUgoVERlKHIuaGl0Ym94KS55XzAsdC5oaXRib3gueV8wKSk/dD0ocXIodC5yZXByZXNlbnRlZExFZGdlcyxyLnJlcHJlc2VudGVkTEVkZ2VzKSxxcih0LmFmZmVjdGVkQmVuZHMsci5hZmZlY3RlZEJlbmRzKSxxcih0LmFmZmVjdGVkQm91bmRpbmdCb3hlcyxyLmFmZmVjdGVkQm91bmRpbmdCb3hlcyksZnQodC5qdW5jdGlvblBvaW50cyxyLmp1bmN0aW9uUG9pbnRzKSxxcih0LmNvbnN0cmFpbnRzLHIuY29uc3RyYWludHMpLHFyKHQucG90ZW50aWFsR3JvdXBQYXJlbnRzLHIucG90ZW50aWFsR3JvdXBQYXJlbnRzKSxpPVMuTWF0aC5taW4odC5oaXRib3gueF8wLHIuaGl0Ym94LnhfMCkscz1TLk1hdGgubWluKHQuaGl0Ym94LnlfMCxyLmhpdGJveC55XzApLHU9Uy5NYXRoLm1heCh0LmhpdGJveC54XzArdC5oaXRib3gud2lkdGhfMCxyLmhpdGJveC54XzArci5oaXRib3gud2lkdGhfMCksYz11LWksXz1TLk1hdGgubWF4KHQuaGl0Ym94LnlfMCt0LmhpdGJveC5oZWlnaHQsci5oaXRib3gueV8wK3IuaGl0Ym94LmhlaWdodCksZD1fLXMsYkRlKHQuaGl0Ym94LGkscyxjLGQpLFFlbih0Lmlnbm9yZVNwYWNpbmcsci5pZ25vcmVTcGFjaW5nKSwhdC5hUG9ydCYmKHQuYVBvcnQ9ci5hUG9ydCkscXIodC5qb2luZWQsci5qb2luZWQpLGVlKHQuam9pbmVkLHIpLHQpOihvM2UoZSx0KSx0PXIpO28zZShlLHQpfX1mdW5jdGlvbiBOY24oZSl7dmFyIG4scix0O3N3aXRjaChuPWEodyhlLmxheWVyZWRHcmFwaCwob2UoKSx1YykpLDIyMyksbi5vcmRpbmFsKXtjYXNlIDI6cj12Y24oZSk7YnJlYWs7Y2FzZSAzOnI9KHQ9bmV3IFEsTHIoSm4ocG8oTm8oTm8obmV3IFNlKG51bGwsbmV3IHhlKGUubGF5ZXJlZEdyYXBoLmxheWVycywxNikpLG5ldyBQM2UpLG5ldyBOM2UpLG5ldyBBM2UpLG5ldyBzM2UpLG5ldyBMM2UodCkpLHQpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgYihuZXcgcm8oIkNvbXBhY3Rpb24gbm90IHN1cHBvcnRlZCBmb3IgIituKyIgZWRnZXMuIikpfVBjbihlLHIpLEV0KG5ldyBrXyhlLnZlcnRpY2FsU2VnbWVudHNNYXApLG5ldyB2M2UoZSkpfWZ1bmN0aW9uIEFjbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihzPW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihpPWEoQyhzKSwzMCksYz1uZXcgVChpLm5vZGVzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2lmKHU9YShDKGMpLDEwKSxhZShpZSh3KHUsKG9lKCksVkUpKSkpJiYhSm0oaWModSkpKXt0PWEoTUtlKGljKHUpKSwxOCksZD10LnNvdXJjZS5vd25lcixkPT11JiYoZD10LnRhcmdldC5vd25lciksZj1uZXcgWnIoZCxydChDdCh1LnBvcyksZC5wb3MpKSxCbihlLmNvbW1lbnRPZmZzZXRzLHUsZik7Y29udGludWV9bz1uZXcgdGwodS5wb3MueF8wLXUubWFyZ2luLmxlZnQsdS5wb3MueV8wLXUubWFyZ2luLnRvcF8wLHUuc2l6ZV8wLnhfMCt1Lm1hcmdpbi5sZWZ0K3UubWFyZ2luLnJpZ2h0LHUuc2l6ZV8wLnlfMCt1Lm1hcmdpbi50b3BfMCt1Lm1hcmdpbi5ib3R0b20pLG49emRlKEdkZSgkZGUoQmRlKG5ldyBvSCx1KSxvKSxhM2UpLGUuY0dyYXBoKSxSZGUocWVuKERkZShuZXcgdEgsUChJKGJ4LDEpLE1lLDYwLDAsW25dKSksbiksZS5jR3JhcGgpLF89bmV3IEJrLEJuKGUubG9ja01hcCxuLF8pLHI9WnUobmV3IFhlKFFlKHR0KHUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSktWnUobmV3IFhlKFFlKFJyKHUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkscjwwP1dDKF8sITAsKFdyKCksYW8pKTpyPjAmJldDKF8sITAsKFdyKCksbW8pKSx1LnR5cGVfMD09KFdlKCksRnIpJiZ0ZmUoXyksQm4oZS5ub2Rlc01hcCx1LG4pfX1mdW5jdGlvbiBvM2UoZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3Iocj16ZGUoR2RlKCRkZShCZGUobmV3IG9ILG4pLG5ldyBZTihuLmhpdGJveCkpLGwzZSksZS5jR3JhcGgpLG4ucG90ZW50aWFsR3JvdXBQYXJlbnRzLmFycmF5Lmxlbmd0aD09MHx8T2RlKGEobGUobi5wb3RlbnRpYWxHcm91cFBhcmVudHMsMCksNjApLmNHcm91cCxyKSxjPW5ldyBCayxCbihlLmxvY2tNYXAscixjKSxzPW5ldyBCcix1PW5ldyBCcixpPW5ldyBUKG4ucmVwcmVzZW50ZWRMRWRnZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxOCksWXIocyxvLnNvdXJjZSksWXIodSxvLnRhcmdldCk7dD1zLm1hcF8wLnNpemVfMSgpLXUubWFwXzAuc2l6ZV8xKCksdDwwPyhXQyhjLCEwLChXcigpLGFvKSksV0MoYywhMSxtbykpOnQ+MCYmKFdDKGMsITEsKFdyKCksYW8pKSxXQyhjLCEwLG1vKSksd2kobi5qb2luZWQsbmV3IGszZShlLHIpKSxCbihlLnZlcnRpY2FsU2VnbWVudHNNYXAsbixyKX1mdW5jdGlvbiBpM2UoKXtWbCgpLHRoaXMuY29tbWVudE9mZnNldHM9bmV3IHNuLHRoaXMubm9kZXNNYXA9bmV3IHNuLHRoaXMudmVydGljYWxTZWdtZW50c01hcD1uZXcgc24sdGhpcy5sb2NrTWFwPW5ldyBzbn1mdW5jdGlvbiBMY24oZSl7VmwoKTt2YXIgbjtuPWEoZS5vcmlnaW5fMCwxMCksbi5wb3MueF8wPWUuaGl0Ym94LnhfMCtuLm1hcmdpbi5sZWZ0fWZ1bmN0aW9uIGtjbihlKXtWbCgpO3ZhciBuLHI7bj1lLmhpdGJveC54XzAtZS5oaXRib3hQcmVDb21wYWN0aW9uLnhfMCxyPWEoZS5vcmlnaW5fMCwxNTQpLHdpKHIuYWZmZWN0ZWRCZW5kcyxuZXcgZzNlKG4pKSx3aShyLmFmZmVjdGVkQm91bmRpbmdCb3hlcyxuZXcgaDNlKG4pKSxFdChyLmp1bmN0aW9uUG9pbnRzLG5ldyBtM2UobikpfWZ1bmN0aW9uIE9jbihlLG4pe3JldHVybiBWbCgpLG4ueF8wKz1lfWZ1bmN0aW9uIE1jbihlLG4pe3JldHVybiBWbCgpLG4ueF8wKz1lfWZ1bmN0aW9uIFJjbihlLG4pe3JldHVybiBWbCgpLG4ueF8wKz1lfWZ1bmN0aW9uIERjbihlKXtyZXR1cm4gVmwoKSwhIWUmJiFlLmlzRW1wdHkoKX1mdW5jdGlvbiBGY24oZSxuKXtWbCgpO3ZhciByLHQsbyxpLHMsdTtmb3Iocj1udWxsLHM9bi5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksMTMxKSwhaS5pc1N0cmFpZ2h0JiYodD1HMm4oaS5ib3VuZGluZ0JveCksbz1CMm4oaS5ib3VuZGluZ0JveCksdT1uZXcgTEUodCxvLG51bGwsYShpLmVkZ2VzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDE4KSksZWUodS5hZmZlY3RlZEJvdW5kaW5nQm94ZXMsaS5ib3VuZGluZ0JveCksUmUoZS5hcnJheSx1KSxyJiZlZShyLmNvbnN0cmFpbnRzLHUpLHI9dSl9cCgxNzMwLDEse30saTNlKTt2YXIgYTNlLGwzZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyIiwxNzMwKTtmdW5jdGlvbiBzM2UoKXt9cCgxNzM4LDEsSW4sczNlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gbiE9bnVsbH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci8wbWV0aG9kcmVmJG5vbk51bGwkVHlwZSIsMTczOCk7ZnVuY3Rpb24gdTNlKCl7fXAoMTczMSwxLHt9LHUzZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBWbCgpLHZvKHcoYShhKG4sNjApLm9yaWdpbl8wLDEwKSwoSygpLFFuKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQwJFR5cGUiLDE3MzEpO2Z1bmN0aW9uIGMzZSgpe31wKDE3MzIsMSx7fSxjM2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gVmwoKSxNM2UoYShhKG4sNjApLm9yaWdpbl8wLDE1NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQxJFR5cGUiLDE3MzIpO2Z1bmN0aW9uIF8zZSgpe31wKDE3NDEsMSxJbixfM2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBWbCgpLEwoYShuLDYwKS5vcmlnaW5fMCwxMCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDEwJFR5cGUiLDE3NDEpO2Z1bmN0aW9uIGQzZSgpe31wKDE3NDIsMSxKZSxkM2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0xjbihhKG4sNjApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMTEkVHlwZSIsMTc0Mik7ZnVuY3Rpb24gZjNlKCl7fXAoMTc0MywxLEluLGYzZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFZsKCksTChhKG4sNjApLm9yaWdpbl8wLDE1NCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDEyJFR5cGUiLDE3NDMpO2Z1bmN0aW9uIHAzZSgpe31wKDE3NDcsMSxKZSxwM2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2tjbihhKG4sNjApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMTMkVHlwZSIsMTc0Nyk7ZnVuY3Rpb24gZzNlKGUpe3RoaXMuZGVsdGFYXzA9ZX1wKDE3NDQsMSxKZSxnM2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe09jbih0aGlzLmRlbHRhWF8wLGEobiw4KSl9LGwuZGVsdGFYXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQxNCRUeXBlIiwxNzQ0KTtmdW5jdGlvbiBoM2UoZSl7dGhpcy5kZWx0YVhfMD1lfXAoMTc0NSwxLEplLGgzZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7TWNuKHRoaXMuZGVsdGFYXzAsYShuLDExNikpfSxsLmRlbHRhWF8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMTUkVHlwZSIsMTc0NSk7ZnVuY3Rpb24gbTNlKGUpe3RoaXMuZGVsdGFYXzA9ZX1wKDE3NDYsMSxKZSxtM2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1Jjbih0aGlzLmRlbHRhWF8wLGEobiw4KSl9LGwuZGVsdGFYXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQxNiRUeXBlIiwxNzQ2KTtmdW5jdGlvbiB5M2UoKXt9cCgxNzQ4LDEse30seTNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIFZsKCksbmV3IFNlKG51bGwsbmV3IE8xKG5ldyBYZShRZShScihhKG4sMTApKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMTckVHlwZSIsMTc0OCk7ZnVuY3Rpb24gdzNlKCl7fXAoMTc0OSwxLEluLHczZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFZsKCksenQoYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDE4JFR5cGUiLDE3NDkpO2Z1bmN0aW9uIEUzZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTc1MCwxLEplLEUzZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7VGNuKHRoaXMuJCRvdXRlcl8wLGEobiwxOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQxOSRUeXBlIiwxNzUwKTtmdW5jdGlvbiB2M2UoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE3MzQsMSxKZSx2M2UpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Jjbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTU0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDIkVHlwZSIsMTczNCk7ZnVuY3Rpb24gUzNlKCl7fXAoMTc1MSwxLHt9LFMzZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBWbCgpLG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDIwJFR5cGUiLDE3NTEpO2Z1bmN0aW9uIEMzZSgpe31wKDE3NTIsMSx7fSxDM2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gVmwoKSxuZXcgU2UobnVsbCxuZXcgTzEobmV3IFhlKFFlKFJyKGEobiwxMCkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQyMSRUeXBlIiwxNzUyKTtmdW5jdGlvbiBUM2UoKXt9cCgxNzUzLDEse30sVDNlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIFZsKCksYSh3KGEobiwxOCksKEsoKSxHXykpLDE1KX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMjIkVHlwZSIsMTc1Myk7ZnVuY3Rpb24gYjNlKCl7fXAoMTc1NCwxLEluLGIzZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIERjbihhKG4sMTUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkMjMkVHlwZSIsMTc1NCk7ZnVuY3Rpb24gSTNlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNzU1LDEsSmUsSTNlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXttY24odGhpcy4kJG91dGVyXzAsYShuLDE1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIkxHcmFwaFRvQ0dyYXBoVHJhbnNmb3JtZXIvbGFtYmRhJDI0JFR5cGUiLDE3NTUpO2Z1bmN0aW9uIHgzZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy52c05vZGVfMT1ufXAoMTczMywxLEplLHgzZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7SWNuKHRoaXMuJCRvdXRlcl8wLHRoaXMudnNOb2RlXzEsYShuLDE1NCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQzJFR5cGUiLDE3MzMpO2Z1bmN0aW9uIFAzZSgpe31wKDE3MzUsMSx7fSxQM2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gVmwoKSxuZXcgU2UobnVsbCxuZXcgeGUoYShuLDMwKS5ub2RlcywxNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQ0JFR5cGUiLDE3MzUpO2Z1bmN0aW9uIE4zZSgpe31wKDE3MzYsMSx7fSxOM2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gVmwoKSxuZXcgU2UobnVsbCxuZXcgTzEobmV3IFhlKFFlKFJyKGEobiwxMCkpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQ1JFR5cGUiLDE3MzYpO2Z1bmN0aW9uIEEzZSgpe31wKDE3MzcsMSx7fSxBM2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gVmwoKSxhKHcoYShuLDE4KSwoSygpLEdfKSksMTUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQ2JFR5cGUiLDE3MzcpO2Z1bmN0aW9uIEwzZShlKXt0aGlzLnZlcnRpY2FsU2VnbWVudHNfMD1lfXAoMTczOSwxLEplLEwzZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7RmNuKHRoaXMudmVydGljYWxTZWdtZW50c18wLGEobiwxNSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJMR3JhcGhUb0NHcmFwaFRyYW5zZm9ybWVyL2xhbWJkYSQ4JFR5cGUiLDE3MzkpO2Z1bmN0aW9uIGszZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5jTm9kZV8xPW59cCgxNzQwLDEsSmUsazNlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXt4Y24odGhpcy4kJG91dGVyXzAsdGhpcy5jTm9kZV8xLGEobiwxNTQpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiTEdyYXBoVG9DR3JhcGhUcmFuc2Zvcm1lci9sYW1iZGEkOSRUeXBlIiwxNzQwKTtmdW5jdGlvbiB6Y24oZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKGk9bmV3IHByLG89bmV3IFQoZS5uZXR3b3JrU2ltcGxleEdyYXBoLm5vZGVzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTI1KSx0LmluY29taW5nRWRnZXMubGlzdC5hcnJheS5sZW5ndGg9PTAmJmJyKGksdCxpLnRhaWwucHJldixpLnRhaWwpO2lmKGkuc2l6ZV8wPjEpZm9yKG49RjEoKHI9bmV3IFJfLCsrZS5pbmRleF8wLHIpLGUubmV0d29ya1NpbXBsZXhHcmFwaCksdT1kbihpLDApO3UuY3VycmVudE5vZGUhPXUudGhpcyQwMS50YWlsOylzPWEodW4odSksMTI1KSxGbChCbCgkbChHbCh6bChuZXcgRWwsMSksMCksbikscykpfWZ1bmN0aW9uICRjbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEE7Zm9yKGQ9bmV3IHNuLGM9bmV3IEUxLHQ9bmV3IFQoZS5jb21wYWN0b3IuY0dyYXBoLmNOb2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG49YShDKHQpLDYwKSxfPWpwKG4pLF8pZGkoZC5oYXNoQ29kZU1hcCxfLG4pO2Vsc2UgaWYoQT1GaChuKSxBKWZvcihpPW5ldyBUKEEucmVwcmVzZW50ZWRMRWRnZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxOCksYmUoYyxvLG4pO2ZvcihyPW5ldyBUKGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihuPWEoQyhyKSw2MCksXz1qcChuKSxfKXtmb3IodT1uZXcgWGUoUWUoUnIoXykudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHUpOylpZihzPWEodG4odSksMTgpLCF6dChzKSYmKHk9cy5zb3VyY2UseD1zLnRhcmdldCwhKChyZSgpLGtpKS5jb250YWlucyhzLnNvdXJjZS5zaWRlKSYma2kuY29udGFpbnMocy50YXJnZXQuc2lkZSkpKSl7aWYoRT1hKEtlKGQscy50YXJnZXQub3duZXIpLDYwKSxGbChCbCgkbChHbCh6bChuZXcgRWwsMCksMTAwKSxlLm5Ob2Rlc1tuLmNHcm91cC5pZF8wXSksZS5uTm9kZXNbRS5jR3JvdXAuaWRfMF0pKSx5LnNpZGU9PWplJiZsMmUoKFVpKCkseSkpKXtmb3IoaD1hKFpuKGMscyksMjEpLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylpZihmPWEoaC5uZXh0XzEoKSw2MCksZi5oaXRib3gueF8wPG4uaGl0Ym94LnhfMCl7aWYobT1lLm5Ob2Rlc1tmLmNHcm91cC5pZF8wXSx2PWUubk5vZGVzW24uY0dyb3VwLmlkXzBdLG09PXYpY29udGludWU7RmwoQmwoJGwoR2woemwobmV3IEVsLDEpLDEwMCksbSksdikpfX1pZih4LnNpZGU9PXFlJiZ1MmUoKFVpKCkseCkpKXtmb3IoaD1hKFpuKGMscyksMjEpLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylpZihmPWEoaC5uZXh0XzEoKSw2MCksZi5oaXRib3gueF8wPm4uaGl0Ym94LnhfMCl7aWYobT1lLm5Ob2Rlc1tuLmNHcm91cC5pZF8wXSx2PWUubk5vZGVzW2YuY0dyb3VwLmlkXzBdLG09PXYpY29udGludWU7RmwoQmwoJGwoR2woemwobmV3IEVsLDEpLDEwMCksbSksdikpfX19fX1mdW5jdGlvbiBCY24oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihvPW5ldyBUKGUuY29tcGFjdG9yLmNHcmFwaC5jTm9kZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksNjApLGM9dC5jb25zdHJhaW50cy5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksNjApLHQuY0dyb3VwIT11LmNHcm91cCYmKGRjKGUuY29tcGFjdG9yLmRpcmVjdGlvbik/Zj1lLmNvbXBhY3Rvci5zcGFjaW5nc0hhbmRsZXIuZ2V0SG9yaXpvbnRhbFNwYWNpbmcodCx1KTpmPWUuY29tcGFjdG9yLnNwYWNpbmdzSGFuZGxlci5nZXRWZXJ0aWNhbFNwYWNpbmcodCx1KSxpPXQuY0dyb3VwT2Zmc2V0LnhfMCt0LmhpdGJveC53aWR0aF8wK2YtdS5jR3JvdXBPZmZzZXQueF8wLGk9Uy5NYXRoLmNlaWwoaSksaT1TLk1hdGgubWF4KDAsaSksUWoodCx1KT8ocz1GMShuZXcgUl8sZS5uZXR3b3JrU2ltcGxleEdyYXBoKSxfPUtyKFMuTWF0aC5jZWlsKHUuY0dyb3VwT2Zmc2V0LnhfMC10LmNHcm91cE9mZnNldC54XzApKSxuPV8tKHUuY0dyb3VwT2Zmc2V0LnhfMC10LmNHcm91cE9mZnNldC54XzApLGQ9RmgodCkuYVBvcnQscj10LGR8fChkPUZoKHUpLmFQb3J0LG49LW4scj11KSxkJiYoci5jR3JvdXBPZmZzZXQueF8wLT1uLGQucG9zLnhfMC09biksRmwoQmwoJGwoR2woemwobmV3IEVsLFMuTWF0aC5tYXgoMCxfKSksMSkscyksZS5uTm9kZXNbdC5jR3JvdXAuaWRfMF0pKSxGbChCbCgkbChHbCh6bChuZXcgRWwsUy5NYXRoLm1heCgwLC1fKSksMSkscyksZS5uTm9kZXNbdS5jR3JvdXAuaWRfMF0pKSk6KGg9MSwoTCh0Lm9yaWdpbl8wLDE1NCkmJkwodS5vcmlnaW5fMCwxMCl8fEwodS5vcmlnaW5fMCwxNTQpJiZMKHQub3JpZ2luXzAsMTApKSYmKGg9MiksRmwoQmwoJGwoR2woemwobmV3IEVsLEtyKGkpKSxoKSxlLm5Ob2Rlc1t0LmNHcm91cC5pZF8wXSksZS5uTm9kZXNbdS5jR3JvdXAuaWRfMF0pKSkpfWZ1bmN0aW9uIE8zZSgpe31wKDE3MjksMSx7fSxPM2UpLGwuY29tcGFjdD1mdW5jdGlvbihuKXt2YXIgcix0LG8saSxzO2Zvcih0aGlzLmNvbXBhY3Rvcj1uLHRoaXMubmV0d29ya1NpbXBsZXhHcmFwaD1uZXcgV2ssdGhpcy5uTm9kZXM9QihPSCxNZSwxMjUsdGhpcy5jb21wYWN0b3IuY0dyYXBoLmNHcm91cHMuYXJyYXkubGVuZ3RoLDAsMSksdGhpcy5pbmRleF8wPTAsdD1uZXcgVCh0aGlzLmNvbXBhY3Rvci5jR3JhcGguY0dyb3Vwcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDMxNiksci5pZF8wPXRoaXMuaW5kZXhfMCxzPUYxKFZDKG5ldyBSXyxyKSx0aGlzLm5ldHdvcmtTaW1wbGV4R3JhcGgpLHRoaXMubk5vZGVzW3RoaXMuaW5kZXhfMF09cywrK3RoaXMuaW5kZXhfMDtmb3IoQmNuKHRoaXMpLCRjbih0aGlzKSx6Y24odGhpcyksamsocWsodGhpcy5uZXR3b3JrU2ltcGxleEdyYXBoKSxuZXcgZ20pLGk9bmV3IFQodGhpcy5jb21wYWN0b3IuY0dyYXBoLmNOb2Rlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDYwKSxvLmhpdGJveC54XzA9dGhpcy5uTm9kZXNbby5jR3JvdXAuaWRfMF0ubGF5ZXIrby5jR3JvdXBPZmZzZXQueF8wfSxsLmluZGV4XzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJOZXR3b3JrU2ltcGxleENvbXBhY3Rpb24iLDE3MjkpO2Z1bmN0aW9uIEdjbihlLG4pe3ZhciByO3JldHVybiByPVMxKGUuaGl0Ym94LnhfMCxuLmhpdGJveC54XzApLHI9PTA/aXIoZS5oaXRib3gueV8wLG4uaGl0Ym94LnlfMCk6cn1mdW5jdGlvbiBNM2UoZSl7dmFyIG47cmV0dXJuIG49bmV3IEMwLG4uc3RyaW5nKz0iVmVydGljYWxTZWdtZW50ICIsZWkobixlLmhpdGJveCksbi5zdHJpbmcrPSIgIixPbihuLGx6KG5ldyB4NixuZXcgVChlLnJlcHJlc2VudGVkTEVkZ2VzKSkpLG4uc3RyaW5nfWZ1bmN0aW9uIExFKGUsbixyLHQpe3ZhciBvLGkscztpZih0aGlzLnBvdGVudGlhbEdyb3VwUGFyZW50cz1uZXcgUSx0aGlzLnJlcHJlc2VudGVkTEVkZ2VzPW5ldyBRLHRoaXMuYWZmZWN0ZWRCZW5kcz1uZXcgUSx0aGlzLmFmZmVjdGVkQm91bmRpbmdCb3hlcz1uZXcgUSx0aGlzLmhpdGJveD1uZXcgaW0sdGhpcy5qdW5jdGlvblBvaW50cz1uZXcgamksdGhpcy5pZ25vcmVTcGFjaW5nPW5ldyBCayx0aGlzLmNvbnN0cmFpbnRzPW5ldyBRLHRoaXMuam9pbmVkPW5ldyBRLGVlKHRoaXMuYWZmZWN0ZWRCZW5kcyxlKSxlZSh0aGlzLmFmZmVjdGVkQmVuZHMsbiksdGhpcy5oaXRib3gueF8wPVMuTWF0aC5taW4oZS54XzAsbi54XzApLHRoaXMuaGl0Ym94LnlfMD1TLk1hdGgubWluKGUueV8wLG4ueV8wKSx0aGlzLmhpdGJveC53aWR0aF8wPVMuTWF0aC5hYnMoZS54XzAtbi54XzApLHRoaXMuaGl0Ym94LmhlaWdodD1TLk1hdGguYWJzKGUueV8wLW4ueV8wKSxvPWEodyh0LChvZSgpLGlvKSksNzUpLG8pZm9yKHM9ZG4obywwKTtzLmN1cnJlbnROb2RlIT1zLnRoaXMkMDEudGFpbDspaT1hKHVuKHMpLDgpLGlIKGkueF8wLGUueF8wKSYmTG4odGhpcy5qdW5jdGlvblBvaW50cyxpKTtyJiZlZSh0aGlzLnBvdGVudGlhbEdyb3VwUGFyZW50cyxyKSxlZSh0aGlzLnJlcHJlc2VudGVkTEVkZ2VzLHQpfXAoMTU0LDEsezM0OjEsMTU0OjF9LExFKSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBHY24odGhpcyxhKG4sMTU0KSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBNM2UodGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuY29tcGFjdGlvbiIsIlZlcnRpY2FsU2VnbWVudCIsMTU0KTtmdW5jdGlvbiBSM2UoZSxuLHIpe2UudXBwZXJBZGphY2VuY2llcz15OShlLG4sKHJlKCkscWUpLGUuZWFzdGVybkFkamFjZW5jaWVzKSxlLmxvd2VyQWRqYWNlbmNpZXM9eTkoZSxyLHFlLGUuZWFzdGVybkFkamFjZW5jaWVzKSwhKGUudXBwZXJBZGphY2VuY2llcy5jdXJyZW50U2l6ZT09MHx8ZS5sb3dlckFkamFjZW5jaWVzLmN1cnJlbnRTaXplPT0wKSYmejNlKGUpfWZ1bmN0aW9uIEQzZShlLG4scil7ZS51cHBlckFkamFjZW5jaWVzPXk5KGUsbiwocmUoKSxqZSksZS53ZXN0ZXJuQWRqYWNlbmNpZXMpLGUubG93ZXJBZGphY2VuY2llcz15OShlLHIsamUsZS53ZXN0ZXJuQWRqYWNlbmNpZXMpLCEoZS51cHBlckFkamFjZW5jaWVzLmN1cnJlbnRTaXplPT0wfHxlLmxvd2VyQWRqYWNlbmNpZXMuY3VycmVudFNpemU9PTApJiZ6M2UoZSl9ZnVuY3Rpb24gRjNlKGUsbixyKXtlLnVwcGVyTG93ZXJDcm9zc2luZ3M9MCxlLmxvd2VyVXBwZXJDcm9zc2luZ3M9MCxuIT1yJiYoRDNlKGUsbixyKSxSM2UoZSxuLHIpKX1mdW5jdGlvbiB6M2UoZSl7Zm9yKDtlLnVwcGVyQWRqYWNlbmNpZXMuY3VycmVudFNpemUhPTAmJmUubG93ZXJBZGphY2VuY2llcy5jdXJyZW50U2l6ZSE9MDspdzkoZS51cHBlckFkamFjZW5jaWVzKS5wb3NpdGlvbj53OShlLmxvd2VyQWRqYWNlbmNpZXMpLnBvc2l0aW9uPyhlLnVwcGVyTG93ZXJDcm9zc2luZ3MrPWUudXBwZXJBZGphY2VuY2llcy5jdXJyZW50U2l6ZSxFOShlLmxvd2VyQWRqYWNlbmNpZXMpKTp3OShlLmxvd2VyQWRqYWNlbmNpZXMpLnBvc2l0aW9uPnc5KGUudXBwZXJBZGphY2VuY2llcykucG9zaXRpb24/KGUubG93ZXJVcHBlckNyb3NzaW5ncys9ZS5sb3dlckFkamFjZW5jaWVzLmN1cnJlbnRTaXplLEU5KGUudXBwZXJBZGphY2VuY2llcykpOihlLnVwcGVyTG93ZXJDcm9zc2luZ3MrPUIzZShlLnVwcGVyQWRqYWNlbmNpZXMpLGUubG93ZXJVcHBlckNyb3NzaW5ncys9QjNlKGUubG93ZXJBZGphY2VuY2llcyksRTkoZS51cHBlckFkamFjZW5jaWVzKSxFOShlLmxvd2VyQWRqYWNlbmNpZXMpKX1mdW5jdGlvbiBIY24oZSxuLHIpe2UudXBwZXJMb3dlckNyb3NzaW5ncz0wLGUubG93ZXJVcHBlckNyb3NzaW5ncz0wLG4hPXImJlIzZShlLG4scil9ZnVuY3Rpb24gVWNuKGUsbixyKXtlLnVwcGVyTG93ZXJDcm9zc2luZ3M9MCxlLmxvd2VyVXBwZXJDcm9zc2luZ3M9MCxuIT1yJiZEM2UoZSxuLHIpfWZ1bmN0aW9uIHk5KGUsbixyLHQpe3ZhciBvLGkscyx1LGM7aWYodC5oYXNoQ29kZU1hcC5zaXplXzArdC5zdHJpbmdNYXAuc2l6ZV8wPT0wKWZvcihzPWUuY3VycmVudE5vZGVPcmRlcltlLmZyZWVMYXllckluZGV4XSx1PTAsYz1zLmxlbmd0aDt1PGM7Kyt1KWk9c1t1XSxCbih0LGksbmV3IEczZShlLGkscikpO3JldHVybiBvPWEoX28oanQodC5oYXNoQ29kZU1hcCxuKSksNjc3KSxvLmN1cnJlbnRJbmRleD0wLG8uY3VycmVudFNpemU9by5zaXplXzAsby5jdXJyZW50U2l6ZT09MHx8SDNlKGEobGUoby5hZGphY2VuY3lMaXN0LG8uY3VycmVudEluZGV4KSwyOTQpKSxvfWZ1bmN0aW9uICQzZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IoXz0wLG89ZS5jdXJyZW50Tm9kZU9yZGVyW25dLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpZm9yKHQ9b1tpXSxkPWx2KHQsciksYz1kLml0ZXJhdG9yXzAoKTtjLmhhc05leHRfMCgpOyl1PWEoYy5uZXh0XzEoKSwxMiksQm4oZS5wb3J0UG9zaXRpb25zLHUsSihfKyspKX1mdW5jdGlvbiBlVihlLG4pe3RoaXMucG9ydFBvc2l0aW9ucz1uZXcgc24sdGhpcy5lYXN0ZXJuQWRqYWNlbmNpZXM9bmV3IHNuLHRoaXMud2VzdGVybkFkamFjZW5jaWVzPW5ldyBzbix0aGlzLmN1cnJlbnROb2RlT3JkZXI9ZSx0aGlzLmZyZWVMYXllckluZGV4PW4sdGhpcy5mcmVlTGF5ZXJJbmRleD4wJiYkM2UodGhpcyx0aGlzLmZyZWVMYXllckluZGV4LTEsKHJlKCkscWUpKSx0aGlzLmZyZWVMYXllckluZGV4PHRoaXMuY3VycmVudE5vZGVPcmRlci5sZW5ndGgtMSYmJDNlKHRoaXMsdGhpcy5mcmVlTGF5ZXJJbmRleCsxLChyZSgpLGplKSl9cCg4NDEsMSx7fSxlViksbC5mcmVlTGF5ZXJJbmRleD0wLGwubG93ZXJVcHBlckNyb3NzaW5ncz0wLGwudXBwZXJMb3dlckNyb3NzaW5ncz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuZ3JlZWR5c3dpdGNoIiwiQmV0d2VlbkxheWVyRWRnZVR3b05vZGVDcm9zc2luZ3NDb3VudGVyIiw4NDEpO2Z1bmN0aW9uIFdjbihlLG4pe3ZhciByLHQsbztyPWpjbihuLGUuc2lkZSksdD1hKEtlKGUudGhpcyQwMS5wb3J0UG9zaXRpb25zLHIpLDE3KS52YWx1ZV8wLG89ZS5hZGphY2VuY3lMaXN0LmFycmF5Lmxlbmd0aC0xLGUuYWRqYWNlbmN5TGlzdC5hcnJheS5sZW5ndGghPTAmJmEobGUoZS5hZGphY2VuY3lMaXN0LG8pLDI5NCkucG9zaXRpb249PXQ/KCsrYShsZShlLmFkamFjZW5jeUxpc3QsbyksMjk0KS5jYXJkaW5hbGl0eSwrK2EobGUoZS5hZGphY2VuY3lMaXN0LG8pLDI5NCkuY3VycmVudENhcmRpbmFsaXR5KTplZShlLmFkamFjZW5jeUxpc3QsbmV3IFUzZSh0KSl9ZnVuY3Rpb24gamNuKGUsbil7cmV0dXJuIG49PShyZSgpLGplKT9lLnNvdXJjZTplLnRhcmdldH1mdW5jdGlvbiBCM2UoZSl7cmV0dXJuIGUuY3VycmVudFNpemUtYShsZShlLmFkamFjZW5jeUxpc3QsZS5jdXJyZW50SW5kZXgpLDI5NCkuY3VycmVudENhcmRpbmFsaXR5fWZ1bmN0aW9uIHc5KGUpe3JldHVybiBhKGxlKGUuYWRqYWNlbmN5TGlzdCxlLmN1cnJlbnRJbmRleCksMjk0KX1mdW5jdGlvbiBWY24oZSl7dmFyIG4scix0LG8saSxzO2ZvcihzPWx2KGUubm9kZSxlLnNpZGUpLGk9cy5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspZm9yKG89YShpLm5leHRfMSgpLDEyKSx0PWUuc2lkZT09KHJlKCksamUpP28uaW5jb21pbmdFZGdlczpvLm91dGdvaW5nRWRnZXMscj1uZXcgVCh0KTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTgpLCF6dChuKSYmbi5zb3VyY2Uub3duZXIubGF5ZXIhPW4udGFyZ2V0Lm93bmVyLmxheWVyJiYoV2NuKGUsbiksKytlLnNpemVfMCwrK2UuY3VycmVudFNpemUpfWZ1bmN0aW9uIEU5KGUpe3ZhciBuO2UuY3VycmVudFNpemUhPTAmJihuPWEobGUoZS5hZGphY2VuY3lMaXN0LGUuY3VycmVudEluZGV4KSwyOTQpLG4uY3VycmVudENhcmRpbmFsaXR5PT0xPygrK2UuY3VycmVudEluZGV4LGUuY3VycmVudEluZGV4PGUuYWRqYWNlbmN5TGlzdC5hcnJheS5sZW5ndGgmJkgzZShhKGxlKGUuYWRqYWNlbmN5TGlzdCxlLmN1cnJlbnRJbmRleCksMjk0KSkpOi0tbi5jdXJyZW50Q2FyZGluYWxpdHksLS1lLmN1cnJlbnRTaXplKX1mdW5jdGlvbiBHM2UoZSxuLHIpe3RoaXMudGhpcyQwMT1lLHRoaXMubm9kZT1uLHRoaXMuc2lkZT1yLHRoaXMuYWRqYWNlbmN5TGlzdD1uZXcgUSxWY24odGhpcyksTmUoKSxEcih0aGlzLmFkamFjZW5jeUxpc3QsbnVsbCl9cCg2NzcsMSx7Njc3OjF9LEczZSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIkFkamFjZW5jeUxpc3QgW25vZGU9Iit0aGlzLm5vZGUrIiwgYWRqYWNlbmNpZXM9ICIrdGhpcy5hZGphY2VuY3lMaXN0KyJdIn0sbC5jdXJyZW50SW5kZXg9MCxsLmN1cnJlbnRTaXplPTAsbC5zaXplXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmdyZWVkeXN3aXRjaCIsIkJldHdlZW5MYXllckVkZ2VUd29Ob2RlQ3Jvc3NpbmdzQ291bnRlci9BZGphY2VuY3lMaXN0Iiw2NzcpO2Z1bmN0aW9uIHFjbihlLG4pe3JldHVybiBlLnBvc2l0aW9uPG4ucG9zaXRpb24/LTE6ZS5wb3NpdGlvbj09bi5wb3NpdGlvbj8wOjF9ZnVuY3Rpb24gSDNlKGUpe2UuY3VycmVudENhcmRpbmFsaXR5PWUuY2FyZGluYWxpdHl9ZnVuY3Rpb24gVTNlKGUpe3RoaXMucG9zaXRpb249ZSx0aGlzLmNhcmRpbmFsaXR5PTEsdGhpcy5jdXJyZW50Q2FyZGluYWxpdHk9MX1wKDI5NCwxLHszNDoxLDI5NDoxfSxVM2UpLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIHFjbih0aGlzLGEobiwyOTQpKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIkFkamFjZW5jeSBbcG9zaXRpb249Iit0aGlzLnBvc2l0aW9uKyIsIGNhcmRpbmFsaXR5PSIrdGhpcy5jYXJkaW5hbGl0eSsiLCBjdXJyZW50Q2FyZGluYWxpdHk9Iit0aGlzLmN1cnJlbnRDYXJkaW5hbGl0eSsiXSJ9LGwuY2FyZGluYWxpdHk9MCxsLmN1cnJlbnRDYXJkaW5hbGl0eT0wLGwucG9zaXRpb249MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmdyZWVkeXN3aXRjaCIsIkJldHdlZW5MYXllckVkZ2VUd29Ob2RlQ3Jvc3NpbmdzQ291bnRlci9BZGphY2VuY3lMaXN0L0FkamFjZW5jeSIsMjk0KTtmdW5jdGlvbiBZY24oZSxuLHIpe2lmKGUub25lU2lkZWQpc3dpdGNoKGUuZGlyZWN0aW9uKXtjYXNlIDE6SGNuKGUuaW5CZXR3ZWVuTGF5ZXJDcm9zc2luZ0NvdW50ZXIsbixyKTticmVhaztjYXNlIDA6VWNuKGUuaW5CZXR3ZWVuTGF5ZXJDcm9zc2luZ0NvdW50ZXIsbixyKX1lbHNlIEYzZShlLmluQmV0d2VlbkxheWVyQ3Jvc3NpbmdDb3VudGVyLG4scik7ZS5jcm9zc2luZ01hdHJpeFtuLmlkXzBdW3IuaWRfMF09ZS5pbkJldHdlZW5MYXllckNyb3NzaW5nQ291bnRlci51cHBlckxvd2VyQ3Jvc3NpbmdzLGUuY3Jvc3NpbmdNYXRyaXhbci5pZF8wXVtuLmlkXzBdPWUuaW5CZXR3ZWVuTGF5ZXJDcm9zc2luZ0NvdW50ZXIubG93ZXJVcHBlckNyb3NzaW5nc31mdW5jdGlvbiBXM2UoZSxuLHIpe3JldHVybiBlLmlzQ3Jvc3NpbmdNYXRyaXhGaWxsZWRbbi5pZF8wXVtyLmlkXzBdfHwoWWNuKGUsbixyKSxlLmlzQ3Jvc3NpbmdNYXRyaXhGaWxsZWRbbi5pZF8wXVtyLmlkXzBdPSEwLGUuaXNDcm9zc2luZ01hdHJpeEZpbGxlZFtyLmlkXzBdW24uaWRfMF09ITApLGUuY3Jvc3NpbmdNYXRyaXhbbi5pZF8wXVtyLmlkXzBdfWZ1bmN0aW9uIGozZShlLG4scix0KXt2YXIgbzt0aGlzLmRpcmVjdGlvbj10LHRoaXMub25lU2lkZWQ9ZT09KGFkKCksYXYpLG89bltyXSx0aGlzLmlzQ3Jvc3NpbmdNYXRyaXhGaWxsZWQ9Yl8oeWEsW1gseHVdLFsxODMsMjhdLDE2LFtvLmxlbmd0aCxvLmxlbmd0aF0sMiksdGhpcy5jcm9zc2luZ01hdHJpeD1iXyhobixbWCxrbl0sWzUzLDI4XSwxNSxbby5sZW5ndGgsby5sZW5ndGhdLDIpLHRoaXMuaW5CZXR3ZWVuTGF5ZXJDcm9zc2luZ0NvdW50ZXI9bmV3IGVWKG4scil9cCgyMDI2LDEse30sajNlKSxsLmRpcmVjdGlvbj0wLGwub25lU2lkZWQ9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5ncmVlZHlzd2l0Y2giLCJDcm9zc2luZ01hdHJpeEZpbGxlciIsMjAyNik7ZnVuY3Rpb24gVjNlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtmb3IoZj0wO2Y8bi5sZW5ndGg7ZisrKXtmb3IodT1lLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOylpPWEodS5uZXh0XzEoKSwyMzApLGkuaW5pdEF0TGF5ZXJMZXZlbChmLG4pO2ZvcihoPTA7aDxuW2ZdLmxlbmd0aDtoKyspe2ZvcihjPWUuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KWk9YShjLm5leHRfMSgpLDIzMCksaS5pbml0QXROb2RlTGV2ZWwoZixoLG4pO2ZvcihFPW5bZl1baF0ucG9ydHMsbT0wO208RS5hcnJheS5sZW5ndGg7bSsrKXtmb3IoXz1lLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOylpPWEoXy5uZXh0XzEoKSwyMzApLGkuaW5pdEF0UG9ydExldmVsKGYsaCxtLG4pO2Zvcih5PShBZShtLEUuYXJyYXkubGVuZ3RoKSxhKEUuYXJyYXlbbV0sMTIpKSxyPTAsbz1uZXcgTHMoeS5jb25uZWN0ZWRFZGdlcyk7eG8oby5maXJzdEl0ZXJhdG9yKXx8eG8oby5zZWNvbmRJdGVyYXRvcik7KWZvcih0PWEoeG8oby5maXJzdEl0ZXJhdG9yKT9DKG8uZmlyc3RJdGVyYXRvcik6QyhvLnNlY29uZEl0ZXJhdG9yKSwxOCksZD1lLml0ZXJhdG9yXzAoKTtkLmhhc05leHRfMCgpOylpPWEoZC5uZXh0XzEoKSwyMzApLGkuaW5pdEF0RWRnZUxldmVsKGYsaCxtLHIrKyx0LG4pfX19Zm9yKHM9ZS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksMjMwKSxpLmluaXRBZnRlclRyYXZlcnNhbCgpfXZhciBxM2U9Q3IoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyLmNvdW50aW5nIiwiSUluaXRpYWxpemFibGUiKTtmdW5jdGlvbiBLY24oZSxuKXt2YXIgcix0O3Q9ITE7ZG8gcj1LM2UoZSxuKSx0PXR8cjt3aGlsZShyKTtyZXR1cm4gdH1mdW5jdGlvbiBZM2UoZSxuLHIsdCl7dmFyIG8saTtlLmN1cnJlbnROb2RlT3JkZXI9bixpPXQ/MDoxLGUuc3dpdGNoRGVjaWRlcj0obz1uZXcgajNlKGUuZ3JlZWR5U3dpdGNoVHlwZSxlLmN1cnJlbnROb2RlT3JkZXIscixpKSxuZXcgblRlKHIsZS5jdXJyZW50Tm9kZU9yZGVyLG8sZS5wb3J0UG9zaXRpb25zLGUuZ3JhcGhEYXRhLGUuZ3JlZWR5U3dpdGNoVHlwZT09KGFkKCksYXYpKSl9ZnVuY3Rpb24gWGNuKGUsbil7cmV0dXJuIGU/MDpuLTF9ZnVuY3Rpb24gSzNlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKHI9ITEsdD1lLmN1cnJlbnROb2RlT3JkZXJbbl0ubGVuZ3RoLGk9MDtpPHQtMTtpKyspbz1pKzEscj1yfEpjbihlLG4saSxvKTtyZXR1cm4gcn1mdW5jdGlvbiBKY24oZSxuLHIsdCl7dmFyIG8saSxzO3JldHVybiBvPSExLG4wbihlLnN3aXRjaERlY2lkZXIscix0KSYmKHQwbihlLnN3aXRjaERlY2lkZXIsZS5jdXJyZW50Tm9kZU9yZGVyW25dW3JdLGUuY3VycmVudE5vZGVPcmRlcltuXVt0XSksaT1lLmN1cnJlbnROb2RlT3JkZXJbbl0scz1pW3RdLGlbdF09aVtyXSxpW3JdPXMsbz0hMCksb31mdW5jdGlvbiBYM2UoZSxuKXt0aGlzLmdyYXBoRGF0YT1uLHRoaXMuZ3JlZWR5U3dpdGNoVHlwZT1lfXAoMTg2NywxLFpTLFgzZSksbC5pbml0QXRFZGdlTGV2ZWw9ZnVuY3Rpb24obixyLHQsbyxpLHMpe30sbC5pbml0QXROb2RlTGV2ZWw9ZnVuY3Rpb24obixyLHQpe30sbC5hbHdheXNJbXByb3Zlcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdyZWVkeVN3aXRjaFR5cGUhPShhZCgpLGF2KX0sbC5pbml0QWZ0ZXJUcmF2ZXJzYWw9ZnVuY3Rpb24oKXt0aGlzLnBvcnRQb3NpdGlvbnM9QihobixrbiwyOCx0aGlzLm5Qb3J0cywxNSwxKX0sbC5pbml0QXRMYXllckxldmVsPWZ1bmN0aW9uKG4scil7cltuXVswXS5sYXllci5pZF8wPW59LGwuaW5pdEF0UG9ydExldmVsPWZ1bmN0aW9uKG4scix0LG8peysrdGhpcy5uUG9ydHN9LGwuaXNEZXRlcm1pbmlzdGljPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwubWluaW1pemVDcm9zc2luZ3M9ZnVuY3Rpb24obixyLHQsbyl7cmV0dXJuIFkzZSh0aGlzLG4scix0KSxLY24odGhpcyxyKX0sbC5zZXRGaXJzdExheWVyT3JkZXI9ZnVuY3Rpb24obixyKXt2YXIgdDtyZXR1cm4gdD1YY24ocixuLmxlbmd0aCksWTNlKHRoaXMsbix0LHIpLEszZSh0aGlzLHQpfSxsLm5Qb3J0cz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUuZ3JlZWR5c3dpdGNoIiwiR3JlZWR5U3dpdGNoSGV1cmlzdGljIiwxODY3KTtmdW5jdGlvbiBaY24oZSxuLHIpe2UudXBwZXJMb3dlckNyb3NzaW5ncz0wLGUubG93ZXJVcHBlckNyb3NzaW5ncz0wLG4udHlwZV8wPT0oV2UoKSx0aSkmJnIudHlwZV8wPT10aSYmYSh3KG4sKEsoKSxRbikpLDEwKT09YSh3KHIsUW4pLDEwKSYmKFM5KG4pLnNpZGU9PShyZSgpLFVlKT9KM2UoZSxuLHIpOkozZShlLHIsbikpLG4udHlwZV8wPT10aSYmci50eXBlXzA9PWl0P1M5KG4pLnNpZGU9PShyZSgpLFVlKT9lLnVwcGVyTG93ZXJDcm9zc2luZ3M9MTplLmxvd2VyVXBwZXJDcm9zc2luZ3M9MTpyLnR5cGVfMD09dGkmJm4udHlwZV8wPT1pdCYmKFM5KHIpLnNpZGU9PShyZSgpLFVlKT9lLmxvd2VyVXBwZXJDcm9zc2luZ3M9MTplLnVwcGVyTG93ZXJDcm9zc2luZ3M9MSksZTBuKGUsbixyKX1mdW5jdGlvbiBKM2UoZSxuLHIpe3ZhciB0LG8saSxzO1ozZShlLG4pPlozZShlLHIpPyh0PUFvKHIsKHJlKCkscWUpKSxlLnVwcGVyTG93ZXJDcm9zc2luZ3M9dC5pc0VtcHR5KCk/MDphOShhKHQuZ2V0XzAoMCksMTIpKSxzPUFvKG4samUpLGUubG93ZXJVcHBlckNyb3NzaW5ncz1zLmlzRW1wdHkoKT8wOmE5KGEocy5nZXRfMCgwKSwxMikpKToobz1BbyhyLChyZSgpLGplKSksZS51cHBlckxvd2VyQ3Jvc3NpbmdzPW8uaXNFbXB0eSgpPzA6YTkoYShvLmdldF8wKDApLDEyKSksaT1BbyhuLHFlKSxlLmxvd2VyVXBwZXJDcm9zc2luZ3M9aS5pc0VtcHR5KCk/MDphOShhKGkuZ2V0XzAoMCksMTIpKSl9ZnVuY3Rpb24gUWNuKGUpe3ZhciBuLHIsdCxvO2ZvcihyPWUubGF5ZXIsdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0sUTNlKGUsbiwocmUoKSxsbikpLFEzZShlLG4sVWUpfWZ1bmN0aW9uIHY5KGUsbil7dmFyIHIsdCxvO2ZvcihyPTAsbz1BbyhlLG4pLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSwxMikscis9dyh0LChLKCksb2EpKSE9bnVsbD8xOjA7cmV0dXJuIHJ9ZnVuY3Rpb24gUzkoZSl7dmFyIG4scjtyZXR1cm4gcj1hKGxlKGUucG9ydHMsMCksMTIpLG49YSh3KHIsKEsoKSxRbikpLDEyKSxufWZ1bmN0aW9uIFozZShlLG4pe3ZhciByLHQ7cmV0dXJuIHI9UzkobiksdD1yLGEoS2UoZS5wb3J0UG9zaXRpb25zLHQpLDE3KS52YWx1ZV8wfWZ1bmN0aW9uIGUwbihlLG4scil7bi50eXBlXzA9PShXZSgpLGtyKSYmci50eXBlXzA9PWl0JiYoZS51cHBlckxvd2VyQ3Jvc3NpbmdzPXY5KG4sKHJlKCksbG4pKSxlLmxvd2VyVXBwZXJDcm9zc2luZ3M9djkobixVZSkpLHIudHlwZV8wPT1rciYmbi50eXBlXzA9PWl0JiYoZS51cHBlckxvd2VyQ3Jvc3NpbmdzPXY5KHIsKHJlKCksVWUpKSxlLmxvd2VyVXBwZXJDcm9zc2luZ3M9djkocixsbikpfWZ1bmN0aW9uIFEzZShlLG4scil7dmFyIHQsbyxpLHM7Zm9yKHM9bHYobixyKSxpPTAsbz1zLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSwxMiksQm4oZS5wb3J0UG9zaXRpb25zLHQsSihpKyspKX1mdW5jdGlvbiBlVGUoZSl7dGhpcy5sYXllcj1lLHRoaXMucG9ydFBvc2l0aW9ucz1uZXcgc24sUWNuKHRoaXMpfXAoMjAyOSwxLHt9LGVUZSksbC5sb3dlclVwcGVyQ3Jvc3NpbmdzPTAsbC51cHBlckxvd2VyQ3Jvc3NpbmdzPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5ncmVlZHlzd2l0Y2giLCJOb3J0aFNvdXRoRWRnZU5laWdoYm91cmluZ05vZGVDcm9zc2luZ3NDb3VudGVyIiwyMDI5KTtmdW5jdGlvbiBuMG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHE7cmV0dXJuIGg9ZS5mcmVlTGF5ZXJbbl0sbT1lLmZyZWVMYXllcltyXSx5PWEodyhoLChLKCksV2gpKSwxNSksISF5JiZ5LnNpemVfMSgpIT0wJiZ5LmNvbnRhaW5zKG0pfHwoRT1oLnR5cGVfMCE9KFdlKCksaXQpJiZtLnR5cGVfMCE9aXQsdj1hKHcoaCxYMSksMTApLHg9YSh3KG0sWDEpLDEwKSxBPXYhPXgsaz0hIXYmJnYhPWh8fCEheCYmeCE9bSxNPUM5KGgsKHJlKCksVWUpKSxIPUM5KG0sbG4pLGs9a3woQzkoaCxsbil8fEM5KG0sVWUpKSxxPWsmJkF8fE18fEgsRSYmcSl8fGgudHlwZV8wPT0oV2UoKSx0aSkmJm0udHlwZV8wPT1rcnx8bS50eXBlXzA9PShXZSgpLHRpKSYmaC50eXBlXzA9PWtyPyExOihkPWUuZnJlZUxheWVyW25dLGk9ZS5mcmVlTGF5ZXJbcl0sbz1EQWUoZS5sZWZ0SW5MYXllckNvdW50ZXIsZCxpLChyZSgpLGplKSksYz1EQWUoZS5yaWdodEluTGF5ZXJDb3VudGVyLGQsaSxxZSksWmNuKGUubm9ydGhTb3V0aENvdW50ZXIsZCxpKSxfPVczZShlLmNyb3NzaW5nTWF0cml4RmlsbGVyLGQsaSkrYShvLmZpcnN0LDE3KS52YWx1ZV8wK2EoYy5maXJzdCwxNykudmFsdWVfMCtlLm5vcnRoU291dGhDb3VudGVyLnVwcGVyTG93ZXJDcm9zc2luZ3MsdT1XM2UoZS5jcm9zc2luZ01hdHJpeEZpbGxlcixpLGQpK2Eoby5zZWNvbmQsMTcpLnZhbHVlXzArYShjLnNlY29uZCwxNykudmFsdWVfMCtlLm5vcnRoU291dGhDb3VudGVyLmxvd2VyVXBwZXJDcm9zc2luZ3MsZS5jb3VudENyb3NzaW5nc0NhdXNlZEJ5UG9ydFN3aXRjaCYmKGY9YSh3KGQsUW4pLDEyKSxzPWEodyhpLFFuKSwxMiksdD1SQWUoZS5wYXJlbnRDcm9zc0NvdW50ZXIsZixzKSxfKz1hKHQuZmlyc3QsMTcpLnZhbHVlXzAsdSs9YSh0LnNlY29uZCwxNykudmFsdWVfMCksXz51KX1mdW5jdGlvbiBDOShlLG4pe3ZhciByLHQsbztmb3Iobz1BbyhlLG4pLHQ9by5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspaWYocj1hKHQubmV4dF8xKCksMTIpLHcociwoSygpLG9hKSkhPW51bGx8fENFKG5ldyBMcyhyLmNvbm5lY3RlZEVkZ2VzKSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcjBuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkO2k9ZS5ncmFwaERhdGEucGFyZW50R3JhcGhEYXRhLHU9aS5jdXJyZW50Tm9kZU9yZGVyLGM9aS5wb3J0UG9zaXRpb25zLGUucGFyZW50Q3Jvc3NDb3VudGVyPW5ldyBxMyhjKSxzPWUuZ3JhcGhEYXRhLnBhcmVudF8wLmxheWVyLmlkXzAsdD1zPjA/dVtzLTFdOkIoUnUsSWMsMTAsMCwwLDEpLG89dVtzXSxfPXM8dS5sZW5ndGgtMT91W3MrMV06QihSdSxJYywxMCwwLDAsMSksZD1uPT1yLTEsZD9jNyhlLnBhcmVudENyb3NzQ291bnRlcixvLF8pOmM3KGUucGFyZW50Q3Jvc3NDb3VudGVyLHQsbyl9ZnVuY3Rpb24gdDBuKGUsbixyKXt2YXIgdCxvO2Q3KGUubGVmdEluTGF5ZXJDb3VudGVyLG4sciwocmUoKSxqZSkpLGQ3KGUucmlnaHRJbkxheWVyQ291bnRlcixuLHIscWUpLGUuY291bnRDcm9zc2luZ3NDYXVzZWRCeVBvcnRTd2l0Y2gmJihvPWEodyhuLChLKCksUW4pKSwxMiksdD1hKHcocixRbiksMTIpLGY3KGUucGFyZW50Q3Jvc3NDb3VudGVyLG8sdCkpfWZ1bmN0aW9uIG5UZShlLG4scix0LG8saSl7aWYodGhpcy5jcm9zc2luZ01hdHJpeEZpbGxlcj1yLHRoaXMuZ3JhcGhEYXRhPW8sZT49bi5sZW5ndGgpdGhyb3cgYihuZXcgbm8oIkdyZWVkeSBTd2l0Y2hEZWNpZGVyOiBGcmVlIGxheWVyIG5vdCBpbiBncmFwaC4iKSk7dGhpcy5mcmVlTGF5ZXI9bltlXSx0aGlzLmxlZnRJbkxheWVyQ291bnRlcj1uZXcgcTModCksXzcodGhpcy5sZWZ0SW5MYXllckNvdW50ZXIsdGhpcy5mcmVlTGF5ZXIsKHJlKCksamUpKSx0aGlzLnJpZ2h0SW5MYXllckNvdW50ZXI9bmV3IHEzKHQpLF83KHRoaXMucmlnaHRJbkxheWVyQ291bnRlcix0aGlzLmZyZWVMYXllcixxZSksdGhpcy5ub3J0aFNvdXRoQ291bnRlcj1uZXcgZVRlKHRoaXMuZnJlZUxheWVyKSx0aGlzLmNvdW50Q3Jvc3NpbmdzQ2F1c2VkQnlQb3J0U3dpdGNoPSFpJiZvLmhhc1BhcmVudCYmIW8udXNlQm90dG9tVXAmJnRoaXMuZnJlZUxheWVyWzBdLnR5cGVfMD09KFdlKCksRnIpLHRoaXMuY291bnRDcm9zc2luZ3NDYXVzZWRCeVBvcnRTd2l0Y2gmJnIwbih0aGlzLGUsbi5sZW5ndGgpfXAoMjAxNiwxLHt9LG5UZSksbC5jb3VudENyb3NzaW5nc0NhdXNlZEJ5UG9ydFN3aXRjaD0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmdyZWVkeXN3aXRjaCIsIlN3aXRjaERlY2lkZXIiLDIwMTYpO2Z1bmN0aW9uIHJUZShlLG4pe3ZhciByLHQsbztZcihlLnNsRWRnZXMsbikmJihuLnNsSHlwZXJMb29wPWUsdD1uLnNsU291cmNlLGZvKGUuc2xQb3J0cyx0LDApIT0tMXx8ZWUoZS5zbFBvcnRzLHQpLG89bi5zbFRhcmdldCxmbyhlLnNsUG9ydHMsbywwKSE9LTF8fGVlKGUuc2xQb3J0cyxvKSxyPW4ubEVkZ2UubGFiZWxzLHIuYXJyYXkubGVuZ3RoIT0wJiYoIWUuc2xMYWJlbHMmJihlLnNsTGFiZWxzPW5ldyBvVGUoZSkpLGkwbihlLnNsTGFiZWxzLHIpKSl9ZnVuY3Rpb24gbzBuKGUpe3ZhciBuLHIsdDtmb3IoZS5zbFBvcnRzQnlTaWRlPW5ldyBMeigocmUoKSxQKEkoJHQsMSksam8sNjQsMCxbT28sVWUscWUsbG4samVdKSkubGVuZ3RoLGUuc2xQb3J0cy5hcnJheS5sZW5ndGgpLHQ9bmV3IFQoZS5zbFBvcnRzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTEzKSxuPXIubFBvcnQuc2lkZSxiZShlLnNsUG9ydHNCeVNpZGUsbixyKTtlLnNlbGZMb29wVHlwZT1nMG4ocmgoZS5zbFBvcnRzQnlTaWRlKSl9ZnVuY3Rpb24gblYoZSxuKXtlLmxlZnRtb3N0UG9ydD1ufWZ1bmN0aW9uIHJWKGUsbil7ZS5yaWdodG1vc3RQb3J0PW59ZnVuY3Rpb24gdFYoZSxuLHIpe3ZhciB0O2Uucm91dGluZ1Nsb3Rbbi5vcmRpbmFsXT1yLHQ9ZS5zbEhvbGRlci5yb3V0aW5nU2xvdENvdW50LHRbbi5vcmRpbmFsXT1TLk1hdGgubWF4KHRbbi5vcmRpbmFsXSxyKzEpfWZ1bmN0aW9uIHRUZShlKXt2YXIgbjt0aGlzLnNsUG9ydHM9bmV3IFEsdGhpcy5zbEVkZ2VzPW5ldyBCcix0aGlzLm9jY3VwaWVkUG9ydFNpZGVzPShuPWEoaXMoJHQpLDkpLG5ldyBKYShuLGEoRGwobixuLmxlbmd0aCksOSksMCkpLHRoaXMucm91dGluZ1Nsb3Q9QihobixrbiwyOCwocmUoKSxQKEkoJHQsMSksam8sNjQsMCxbT28sVWUscWUsbG4samVdKSkubGVuZ3RoLDE1LDEpLHRoaXMuc2xIb2xkZXI9ZX1wKDEwNSwxLHsxMDU6MX0sdFRlKSxsLmxlZnRtb3N0UG9ydD1udWxsLGwucmlnaHRtb3N0UG9ydD1udWxsLGwuc2xMYWJlbHM9bnVsbCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzIiwiU2VsZkh5cGVyTG9vcCIsMTA1KTtmdW5jdGlvbiBpMG4oZSxuKXt2YXIgcix0O2Zvcih0PW5ldyBUKG4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw3MiksZWUoZS5sTGFiZWxzLHIpLHUwbihlLHIpfWZ1bmN0aW9uIGEwbihlLG4pe2RjKGUubGF5b3V0RGlyZWN0aW9uKT9sMG4oZSxuKTpzMG4oZSxuKX1mdW5jdGlvbiBsMG4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihpPWUucG9zaXRpb24ueF8wLHM9ZS5wb3NpdGlvbi55XzAsdD1uZXcgVChlLmxMYWJlbHMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw3Miksbz1yLnBvcyxlLmFsaWdubWVudD09KGtzKCksSHkpfHxlLnNpZGU9PShyZSgpLHFlKT9vLnhfMD1pOmUuYWxpZ25tZW50PT1VeXx8ZS5zaWRlPT0ocmUoKSxqZSk/by54XzA9aStlLnNpemVfMC54XzAtci5zaXplXzAueF8wOm8ueF8wPWkrKGUuc2l6ZV8wLnhfMC1yLnNpemVfMC54XzApLzIsby55XzA9cyxLbihvLG4pLHMrPXIuc2l6ZV8wLnlfMCtlLmxhYmVsTGFiZWxTcGFjaW5nfWZ1bmN0aW9uIHMwbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKGk9ZS5wb3NpdGlvbi54XzAscz1lLnBvc2l0aW9uLnlfMCx0PW5ldyBUKGUubExhYmVscyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDcyKSxvPXIucG9zLG8ueF8wPWksZS5zaWRlPT0ocmUoKSxVZSk/by55XzA9cytlLnNpemVfMC55XzAtci5zaXplXzAueV8wOm8ueV8wPXMsS24obyxuKSxpKz1yLnNpemVfMC54XzArZS5sYWJlbExhYmVsU3BhY2luZ31mdW5jdGlvbiB1MG4oZSxuKXt2YXIgcjtyPW4uc2l6ZV8wLGRjKGUubGF5b3V0RGlyZWN0aW9uKT8oZS5zaXplXzAueF8wPVMuTWF0aC5tYXgoZS5zaXplXzAueF8wLHIueF8wKSxlLnNpemVfMC55XzArPXIueV8wLGUubExhYmVscy5hcnJheS5sZW5ndGg+MSYmKGUuc2l6ZV8wLnlfMCs9ZS5sYWJlbExhYmVsU3BhY2luZykpOihlLnNpemVfMC54XzArPXIueF8wLGUuc2l6ZV8wLnlfMD1TLk1hdGgubWF4KGUuc2l6ZV8wLnlfMCxyLnlfMCksZS5sTGFiZWxzLmFycmF5Lmxlbmd0aD4xJiYoZS5zaXplXzAueF8wKz1lLmxhYmVsTGFiZWxTcGFjaW5nKSl9ZnVuY3Rpb24gb1RlKGUpe3ZhciBuO3RoaXMubExhYmVscz1uZXcgUSx0aGlzLnNpemVfMD1uZXcgbXQsdGhpcy5wb3NpdGlvbj1uZXcgbXQsbj1lLnNsSG9sZGVyLmxOb2RlLHRoaXMubGF5b3V0RGlyZWN0aW9uPWEodyhTdChuKSwob2UoKSxPYSkpLDg4KSx0aGlzLmxhYmVsTGFiZWxTcGFjaW5nPVIoJChoNChuLE1mKSkpfXAoMjAxMywxLHt9LG9UZSksbC5pZF8wPTAsbC5sYWJlbExhYmVsU3BhY2luZz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMiLCJTZWxmSHlwZXJMb29wTGFiZWxzIiwyMDEzKTtmdW5jdGlvbiBrcygpe2tzPUYsemg9bmV3IGo0KCJDRU5URVIiLDApLEh5PW5ldyBqNCgiTEVGVCIsMSksVXk9bmV3IGo0KCJSSUdIVCIsMiksVDk9bmV3IGo0KCJUT1AiLDMpfWZ1bmN0aW9uIGo0KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gYzBuKGUpe3JldHVybiBrcygpLHduKChhVGUoKSxsVGUpLGUpfWZ1bmN0aW9uIF8wbigpe3JldHVybiBrcygpLFAoSShpVGUsMSksVyw0MjEsMCxbemgsSHksVXksVDldKX1wKDQyMSwyMix7MzoxLDM0OjEsMjI6MSw0MjE6MX0sajQpO3ZhciB6aCxIeSxVeSxUOSxpVGU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMiLCJTZWxmSHlwZXJMb29wTGFiZWxzL0FsaWdubWVudCIsNDIxLGduLF8wbixjMG4pO2Z1bmN0aW9uIGFUZSgpe2FUZT1GLGxUZT15bigoa3MoKSxQKEkoaVRlLDEpLFcsNDIxLDAsW3poLEh5LFV5LFQ5XSkpKX12YXIgbFRlO2Z1bmN0aW9uIHNUZShlLG4scil7dGhpcy5sRWRnZT1lLHRoaXMuc2xTb3VyY2U9bix0aGlzLnNsVGFyZ2V0PXIsZWUobi5vdXRnb2luZ1NMRWRnZXMsdGhpcyksZWUoci5pbmNvbWluZ1NMRWRnZXMsdGhpcyl9cCgzNDAsMSx7MzQwOjF9LHNUZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcyIsIlNlbGZMb29wRWRnZSIsMzQwKTtmdW5jdGlvbiBkMG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfO2ZvcihzPW5ldyBRLHQ9bmV3IFhlKFFlKFJyKGUubE5vZGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSx6dChyKSYmZWUocyxuZXcgc1RlKHIsdVRlKGUsci5zb3VyY2UpLHVUZShlLHIudGFyZ2V0KSkpO2ZvcihfPShpPW5ldyB0YyhlLnNsUG9ydHMpLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgdGYoaSkpO18udmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KXU9KG49YShfLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKG4uZ2V0VmFsdWUoKSwxMTMpKSx1LmxQb3J0LmlkXzA9MDtmb3IoYz0obz1uZXcgdGMoZS5zbFBvcnRzKS50aGlzJDAxLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCksbmV3IHRmKG8pKTtjLnZhbCRvdXRlckl0ZXIyLmhhc05leHRfMCgpOyl1PShuPWEoYy52YWwkb3V0ZXJJdGVyMi5uZXh0XzEoKSw0NCksYShuLmdldFZhbHVlKCksMTEzKSksdS5sUG9ydC5pZF8wPT0wJiZlZShlLnNsSHlwZXJMb29wcyxmMG4oZSx1KSl9ZnVuY3Rpb24gZjBuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztmb3IodT1uZXcgdFRlKGUpLHI9bmV3IHByLGJyKHIsbixyLnRhaWwucHJldixyLnRhaWwpO3Iuc2l6ZV8wIT0wOyl7Zm9yKHQ9YShyLnNpemVfMD09MD9udWxsOihybihyLnNpemVfMCE9MCksWmEocixyLmhlYWRlci5uZXh0XzApKSwxMTMpLHQubFBvcnQuaWRfMD0xLHM9bmV3IFQodC5vdXRnb2luZ1NMRWRnZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhzKSwzNDApLHJUZSh1LG8pLF89by5zbFRhcmdldCxfLmxQb3J0LmlkXzA9PTAmJmJyKHIsXyxyLnRhaWwucHJldixyLnRhaWwpO2ZvcihpPW5ldyBUKHQuaW5jb21pbmdTTEVkZ2VzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMzQwKSxyVGUodSxvKSxjPW8uc2xTb3VyY2UsYy5sUG9ydC5pZF8wPT0wJiZicihyLGMsci50YWlsLnByZXYsci50YWlsKX1yZXR1cm4gdX1mdW5jdGlvbiB1VGUoZSxuKXtyZXR1cm4gb19lKGUuc2xQb3J0cyxuKXx8UmMoZS5zbFBvcnRzLG4sbmV3IGZUZShuKSksYSh4cyhlLnNsUG9ydHMsbiksMTEzKX1mdW5jdGlvbiBjVGUoZSl7dGhpcy5zbEh5cGVyTG9vcHM9bmV3IFEsdGhpcy5zbFBvcnRzPW5ldyBEYyx0aGlzLnJvdXRpbmdTbG90Q291bnQ9QihobixrbiwyOCwocmUoKSxQKEkoJHQsMSksam8sNjQsMCxbT28sVWUscWUsbG4samVdKSkubGVuZ3RoLDE1LDEpLHRoaXMubE5vZGU9ZX1mdW5jdGlvbiBwMG4oZSl7cmV0dXJuIGUudHlwZV8wIT0oV2UoKSxrcik/ITE6TXAobmV3IFNlKG51bGwsbmV3IE8xKG5ldyBYZShRZShScihlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKSxuZXcgX1RlKX1wKDMzNywxLHszMzc6MX0sY1RlKSxsLmFyZVBvcnRzSGlkZGVuPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMiLCJTZWxmTG9vcEhvbGRlciIsMzM3KTtmdW5jdGlvbiBfVGUoKXt9cCgxNzkwLDEsSW4sX1RlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4genQoYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMiLCJTZWxmTG9vcEhvbGRlci9sYW1iZGEkMCRUeXBlIiwxNzkwKTtmdW5jdGlvbiBkVGUoZSl7cmV0dXJuIGUuaW5jb21pbmdTTEVkZ2VzLmFycmF5Lmxlbmd0aC1lLm91dGdvaW5nU0xFZGdlcy5hcnJheS5sZW5ndGh9ZnVuY3Rpb24gZlRlKGUpe3RoaXMuaW5jb21pbmdTTEVkZ2VzPW5ldyBRLHRoaXMub3V0Z29pbmdTTEVkZ2VzPW5ldyBRLHRoaXMubFBvcnQ9ZSx0aGlzLmhhZE9ubHlTZWxmTG9vcHM9IVB5KEpuKG5ldyBTZShudWxsLG5ldyBPMShuZXcgTHMoZS5jb25uZWN0ZWRFZGdlcykpKSxuZXcgYnkobmV3IHBUZSkpKS50cnlBZHZhbmNlKChNXygpLEloKSl9cCgxMTMsMSx7MTEzOjF9LGZUZSksbC5oYWRPbmx5U2VsZkxvb3BzPSExLGwuaXNIaWRkZW49ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcyIsIlNlbGZMb29wUG9ydCIsMTEzKTtmdW5jdGlvbiBwVGUoKXt9cCgxODU1LDEsSW4scFRlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4genQoYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMiLCJTZWxmTG9vcFBvcnQvbGFtYmRhJDAkVHlwZSIsMTg1NSk7ZnVuY3Rpb24gQ2YoKXtDZj1GLHczPW5ldyB5MygiT05FX1NJREUiLDApLFk0PW5ldyB5MygiVFdPX1NJREVTX0NPUk5FUiIsMSksSzQ9bmV3IHkzKCJUV09fU0lERVNfT1BQT1NJTkciLDIpLHE0PW5ldyB5MygiVEhSRUVfU0lERVMiLDMpLFY0PW5ldyB5MygiRk9VUl9TSURFUyIsNCl9ZnVuY3Rpb24geTMoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBnMG4oZSl7Q2YoKTt2YXIgbixyO2lmKGUuY29udGFpbnMoKHJlKCksT28pKSl0aHJvdyBiKG5ldyBHZSgiUG9ydCBzaWRlcyBtdXN0IG5vdCBjb250YWluIFVOREVGSU5FRCIpKTtzd2l0Y2goZS5zaXplXzEoKSl7Y2FzZSAxOnJldHVybiB3MztjYXNlIDI6cmV0dXJuIG49ZS5jb250YWlucyhxZSkmJmUuY29udGFpbnMoamUpLHI9ZS5jb250YWlucyhVZSkmJmUuY29udGFpbnMobG4pLG58fHI/SzQ6WTQ7Y2FzZSAzOnJldHVybiBxNDtjYXNlIDQ6cmV0dXJuIFY0O2RlZmF1bHQ6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIGgwbihlKXtyZXR1cm4gQ2YoKSx3bigoaFRlKCksbVRlKSxlKX1mdW5jdGlvbiBtMG4oKXtyZXR1cm4gQ2YoKSxQKEkoZ1RlLDEpLFcsMzc1LDAsW3czLFk0LEs0LHE0LFY0XSl9cCgzNzUsMjIsezM6MSwzNDoxLDIyOjEsMzc1OjF9LHkzKTt2YXIgVjQsdzMscTQsWTQsSzQsZ1RlPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzIiwiU2VsZkxvb3BUeXBlIiwzNzUsZ24sbTBuLGgwbik7ZnVuY3Rpb24gaFRlKCl7aFRlPUYsbVRlPXluKChDZigpLFAoSShnVGUsMSksVywzNzUsMCxbdzMsWTQsSzQscTQsVjRdKSkpfXZhciBtVGU7ZnVuY3Rpb24gTTAoKXtNMD1GLHZUZT1QKEkoJHQsMSksam8sNjQsMCxbKHJlKCksVWUpLHFlLGxuXSksRVRlPVAoSSgkdCwxKSxqbyw2NCwwLFtxZSxsbixqZV0pLFNUZT1QKEkoJHQsMSksam8sNjQsMCxbbG4samUsVWVdKSxDVGU9UChJKCR0LDEpLGpvLDY0LDAsW2plLFVlLHFlXSl9ZnVuY3Rpb24gajEoZSxuKXtMcihwbyhlLnN0cmVhbSgpLG5ldyBOVGUpLG5ldyBBVGUobikpfWZ1bmN0aW9uIEUzKGUsbixyLHQpe3ZhciBvLGk7Zm9yKG89bjtvPGUuYXJyYXkubGVuZ3RoO28rKylpZihpPShBZShvLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbb10sMTIpKSxyLnRlc3RfMChpKSlSZSh0LmFycmF5LGkpO2Vsc2UgcmV0dXJuIG87cmV0dXJuIGUuYXJyYXkubGVuZ3RofWZ1bmN0aW9uIGI5KGUsbixyLHQsbyl7dmFyIGkscztpPWEoVG8oSm4obi5zdHJlYW0oKSxuZXcgT1RlKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksT0MoaSkscz1hKHZfKGUudGFyZ2V0QXJlYXMscix0KSwxNSksbz09MD9zLmFkZEFsbF8wKDAsaSk6cy5hZGRBbGwoaSl9ZnVuY3Rpb24gV3koZSxuLHIsdCxvKXtiOShlLGEoWm4obi5zbFBvcnRzQnlTaWRlLHIpLDE1KSxyLHQsbyl9ZnVuY3Rpb24geTBuKGUpe3ZhciBuLHI7Zm9yKHI9MDtyPGUuYXJyYXkubGVuZ3RoJiYhKGRUZSgoQWUocixlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5W3JdLDExMykpKT4wKTtyKyspO2lmKHI+MCYmcjxlLmFycmF5Lmxlbmd0aC0xKXJldHVybiByO2ZvcihuPTA7bjxlLmFycmF5Lmxlbmd0aCYmIShkVGUoKEFlKG4sZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtuXSwxMTMpKSk+MCk7bisrKTtyZXR1cm4gbj4wJiZyPGUuYXJyYXkubGVuZ3RoLTE/bjplLmFycmF5Lmxlbmd0aC8yfDB9ZnVuY3Rpb24gdzBuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7Zm9yKGUudGFyZ2V0QXJlYXM9bmV3IERhZShuZXcgZWEoKHJlKCksUChJKCR0LDEpLGpvLDY0LDAsW09vLFVlLHFlLGxuLGplXSkpKSxuZXcgZWEoKFYxKCksUChJKHg5LDEpLFcsMzcyLDAsW1kxLFIwLHExXSkpKSkscz1QKEkoJHQsMSksam8sNjQsMCxbT28sVWUscWUsbG4samVdKSx1PTAsYz1zLmxlbmd0aDt1PGM7Kyt1KWZvcihpPXNbdV0scj1QKEkoeDksMSksVywzNzIsMCxbWTEsUjAscTFdKSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSxfS2UoZS50YXJnZXRBcmVhcyxpLG4sbmV3IFEpfWZ1bmN0aW9uIEUwbihlKXt2YXIgbixyLHQ7cmV0dXJuIGUuc2lkZT09KHJlKCksVWUpJiYobj15VGUoZSkscj0kaShuLHFlKSx0PSRpKG4samUpLHR8fHQmJnIpfWZ1bmN0aW9uIHYwbihlKXt2YXIgbjtyZXR1cm4gZS5zaWRlPT0ocmUoKSxsbikmJihuPXlUZShlKSwkaShuLHFlKSl9ZnVuY3Rpb24geVRlKGUpe3ZhciBuLHIsdCxvLGk7aWYocj0obj1hKGlzKCR0KSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKSxpPWEodyhlLChLKCksb2EpKSwxMCksaSlmb3Iobz1uZXcgVChpLnBvcnRzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTIpLEQodyh0LFFuKSk9PT1EKGUpJiZDRShuZXcgTHModC5jb25uZWN0ZWRFZGdlcykpJiZNbChyLHQuc2lkZSk7cmV0dXJuIHJ9ZnVuY3Rpb24gUzBuKGUpe3ZhciBuLHIsdCxvO2ZvcihvPWEoWm4oZS5zbExvb3BzQnlUeXBlLChDZigpLFY0KSksMTUpLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOylmb3IodD1hKG8ubmV4dF8xKCksMTA1KSxyPXJoKHQuc2xQb3J0c0J5U2lkZSkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49YShyLm5leHRfMSgpLDY0KSxXeShlLHQsbiwoVjEoKSxSMCksMSl9ZnVuY3Rpb24gQzBuKGUsbil7dmFyIHIsdCxvLGkscztmb3Iobj09KHR2KCksWE8pJiZPQyhhKFpuKGUuc2xMb29wc0J5VHlwZSwoQ2YoKSx3MykpLDE1KSksbz1hKFpuKGUuc2xMb29wc0J5VHlwZSwoQ2YoKSx3MykpLDE1KS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspc3dpdGNoKHQ9YShvLm5leHRfMSgpLDEwNSkscj1hKGxlKHQuc2xQb3J0cywwKSwxMTMpLmxQb3J0LnNpZGUsaT1uZXcgUWkodC5zbFBvcnRzKSxEcihpLG5ldyBrVGUpLG4ub3JkaW5hbCl7Y2FzZSAyOmI5KGUsaSxyLChWMSgpLFIwKSwxKTticmVhaztjYXNlIDE6Y2FzZSAwOnM9eTBuKGkpLGI5KGUsbmV3IE9jKGksMCxzKSxyLChWMSgpLFIwKSwwKSxiOShlLG5ldyBPYyhpLHMsaS5hcnJheS5sZW5ndGgpLHIsUjAsMSl9fWZ1bmN0aW9uIFQwbihlKXt2YXIgbixyLHQsbztmb3Iobz1hKFpuKGUuc2xMb29wc0J5VHlwZSwoQ2YoKSxxNCkpLDE1KS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTA1KSxyPShuPXJoKHQuc2xQb3J0c0J5U2lkZSksbi5jb250YWlucygocmUoKSxVZSkpP24uY29udGFpbnMocWUpP24uY29udGFpbnMobG4pP24uY29udGFpbnMoamUpP251bGw6dlRlOkNUZTpTVGU6RVRlKSxXeShlLHQsclswXSwoVjEoKSxxMSksMCksV3koZSx0LHJbMV0sUjAsMSksV3koZSx0LHJbMl0sWTEsMSl9ZnVuY3Rpb24gYjBuKGUpe3ZhciBuLHIsdDtmb3IodD1hKFpuKGUuc2xMb29wc0J5VHlwZSwoQ2YoKSxZNCkpLDE1KS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMTA1KSxuPW9WKHIpLFd5KGUscixuWzBdLChWMSgpLHExKSwwKSxXeShlLHIsblsxXSxZMSwxKX1mdW5jdGlvbiBJMG4oZSl7dmFyIG4scix0O2Zvcih0PWEoWm4oZS5zbExvb3BzQnlUeXBlLChDZigpLEs0KSksMTUpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSwxMDUpLG49b1YociksV3koZSxyLG5bMF0sKFYxKCkscTEpLDApLFd5KGUscixuWzFdLFkxLDEpfWZ1bmN0aW9uIHgwbihlLG4pe3ZhciByLHQsbyxpO3I9bi5sTm9kZSxpPW5ldyBRaShyLnBvcnRzKSxvPTAsdD1yLnBvcnRzLHQuYXJyYXkubGVuZ3RoPTAsajEoYSh2XyhlLnRhcmdldEFyZWFzLChyZSgpLFVlKSwoVjEoKSxZMSkpLDE1KSxyKSxvPUUzKGksbyxuZXcgTVRlLHQpLGoxKGEodl8oZS50YXJnZXRBcmVhcyxVZSxSMCksMTUpLHIpLG89RTMoaSxvLG5ldyBSVGUsdCksajEoYSh2XyhlLnRhcmdldEFyZWFzLFVlLHExKSwxNSksciksajEoYSh2XyhlLnRhcmdldEFyZWFzLHFlLFkxKSwxNSksciksajEoYSh2XyhlLnRhcmdldEFyZWFzLHFlLFIwKSwxNSksciksbz1FMyhpLG8sbmV3IERUZSx0KSxqMShhKHZfKGUudGFyZ2V0QXJlYXMscWUscTEpLDE1KSxyKSxqMShhKHZfKGUudGFyZ2V0QXJlYXMsbG4sWTEpLDE1KSxyKSxvPUUzKGksbyxuZXcgRlRlLHQpLGoxKGEodl8oZS50YXJnZXRBcmVhcyxsbixSMCksMTUpLHIpLG89RTMoaSxvLG5ldyB6VGUsdCksajEoYSh2XyhlLnRhcmdldEFyZWFzLGxuLHExKSwxNSksciksajEoYSh2XyhlLnRhcmdldEFyZWFzLGplLFkxKSwxNSksciksbz1FMyhpLG8sbmV3IFBUZSx0KSxqMShhKHZfKGUudGFyZ2V0QXJlYXMsamUsUjApLDE1KSxyKSxqMShhKHZfKGUudGFyZ2V0QXJlYXMsamUscTEpLDE1KSxyKX1mdW5jdGlvbiBQMG4oZSxuKXt2YXIgcjt3MG4oZSksZS5zbExvb3BzQnlUeXBlPShyPW5ldyBSNixMcihuZXcgU2UobnVsbCxuZXcgeGUobi5zbEh5cGVyTG9vcHMsMTYpKSxuZXcgTFRlKHIpKSxyKSxDMG4oZSxhKHcobi5sTm9kZSwob2UoKSxTTykpLDM0OSkpLGIwbihlKSxUMG4oZSksUzBuKGUpLEkwbihlKSx4MG4oZSxuKSxMcihObyhuZXcgU2UobnVsbCxSYWUoZEtlKGUudGFyZ2V0QXJlYXMpLnRoaXMkMDEpKSxuZXcgSVRlKSxuZXcgeFRlKSxuLmFyZVBvcnRzSGlkZGVuPSExLGUuc2xMb29wc0J5VHlwZT1udWxsfWZ1bmN0aW9uIHdUZSgpe00wKCl9ZnVuY3Rpb24gTjBuKGUsbil7TTAoKSxMbyhuLGUpfWZ1bmN0aW9uIEEwbihlLG4pe3JldHVybiBNMCgpLGJlKGUsbi5zZWxmTG9vcFR5cGUsbil9ZnVuY3Rpb24gTDBuKGUsbil7cmV0dXJuIE0wKCkscW8oZS5pbmNvbWluZ1NMRWRnZXMuYXJyYXkubGVuZ3RoLWUub3V0Z29pbmdTTEVkZ2VzLmFycmF5Lmxlbmd0aCxuLmluY29taW5nU0xFZGdlcy5hcnJheS5sZW5ndGgtbi5vdXRnb2luZ1NMRWRnZXMuYXJyYXkubGVuZ3RoKX1mdW5jdGlvbiBvVihlKXtNMCgpO3ZhciBuO3JldHVybiBuPWEoSTIocmgoZS5zbFBvcnRzQnlTaWRlKSxCKCR0LGpvLDY0LDIsMCwxKSksMTI2KSxfeShuLDAsbi5sZW5ndGgsbnVsbCksblswXT09KHJlKCksVWUpJiZuWzFdPT1qZSYmKFRyKG4sMCxqZSksVHIobiwxLFVlKSksbn1wKDE3OTgsMSx7fSx3VGUpO3ZhciBFVGUsdlRlLFNUZSxDVGU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5vcmRlcmluZyIsIlBvcnRSZXN0b3JlciIsMTc5OCk7ZnVuY3Rpb24gVjEoKXtWMT1GLFkxPW5ldyBJOSgiU1RBUlQiLDApLFIwPW5ldyBJOSgiTUlERExFIiwxKSxxMT1uZXcgSTkoIkVORCIsMil9ZnVuY3Rpb24gSTkoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBrMG4oZSl7cmV0dXJuIFYxKCksd24oKFRUZSgpLGJUZSksZSl9ZnVuY3Rpb24gTzBuKCl7cmV0dXJuIFYxKCksUChJKHg5LDEpLFcsMzcyLDAsW1kxLFIwLHExXSl9cCgzNzIsMjIsezM6MSwzNDoxLDIyOjEsMzcyOjF9LEk5KTt2YXIgcTEsUjAsWTEseDk9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0UmVzdG9yZXIvUG9ydFNpZGVBcmVhIiwzNzIsZ24sTzBuLGswbik7ZnVuY3Rpb24gVFRlKCl7VFRlPUYsYlRlPXluKChWMSgpLFAoSSh4OSwxKSxXLDM3MiwwLFtZMSxSMCxxMV0pKSl9dmFyIGJUZTtmdW5jdGlvbiBJVGUoKXt9cCgxNzk5LDEse30sSVRlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE0wKCksYShuLDE1KS5zdHJlYW0oKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5vcmRlcmluZyIsIlBvcnRSZXN0b3Jlci9sYW1iZGEkMCRUeXBlIiwxNzk5KTtmdW5jdGlvbiB4VGUoKXt9cCgxODAwLDEsSmUseFRlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtNMCgpLGEobiwxMTMpLmlzSGlkZGVuPSExfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQxJFR5cGUiLDE4MDApO2Z1bmN0aW9uIFBUZSgpe31wKDE4MDksMSxJbixQVGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBNMCgpLGEobiwxMikuc2lkZT09KHJlKCksamUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQxMCRUeXBlIiwxODA5KTtmdW5jdGlvbiBOVGUoKXt9cCgxODEwLDEse30sTlRlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE0wKCksYShuLDExMykubFBvcnR9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0UmVzdG9yZXIvbGFtYmRhJDExJFR5cGUiLDE4MTApO2Z1bmN0aW9uIEFUZShlKXt0aGlzLmxOb2RlXzA9ZX1wKDE4MTEsMSxKZSxBVGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe04wbih0aGlzLmxOb2RlXzAsYShuLDEyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0UmVzdG9yZXIvbGFtYmRhJDEyJFR5cGUiLDE4MTEpO2Z1bmN0aW9uIExUZShlKXt0aGlzLmxvb3BzXzA9ZX1wKDE4MDEsMSxKZSxMVGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0Ewbih0aGlzLmxvb3BzXzAsYShuLDEwNSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQyJFR5cGUiLDE4MDEpO2Z1bmN0aW9uIGtUZSgpe31wKDE4MDIsMSxObixrVGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEwwbihhKG4sMTEzKSxhKHIsMTEzKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5vcmRlcmluZyIsIlBvcnRSZXN0b3Jlci9sYW1iZGEkMyRUeXBlIiwxODAyKTtmdW5jdGlvbiBPVGUoKXt9cCgxODAzLDEsSW4sT1RlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTTAoKSxhKG4sMTEzKS5pc0hpZGRlbn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5vcmRlcmluZyIsIlBvcnRSZXN0b3Jlci9sYW1iZGEkNCRUeXBlIiwxODAzKTtmdW5jdGlvbiBNVGUoKXt9cCgxODA0LDEsSW4sTVRlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gRTBuKGEobiwxMikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQ1JFR5cGUiLDE4MDQpO2Z1bmN0aW9uIFJUZSgpe31wKDE4MDUsMSxJbixSVGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBNMCgpLGEobiwxMikuc2lkZT09KHJlKCksVWUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQ2JFR5cGUiLDE4MDUpO2Z1bmN0aW9uIERUZSgpe31wKDE4MDYsMSxJbixEVGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBNMCgpLGEobiwxMikuc2lkZT09KHJlKCkscWUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFJlc3RvcmVyL2xhbWJkYSQ3JFR5cGUiLDE4MDYpO2Z1bmN0aW9uIEZUZSgpe31wKDE4MDcsMSxJbixGVGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiB2MG4oYShuLDEyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0UmVzdG9yZXIvbGFtYmRhJDgkVHlwZSIsMTgwNyk7ZnVuY3Rpb24gelRlKCl7fXAoMTgwOCwxLEluLHpUZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIE0wKCksYShuLDEyKS5zaWRlPT0ocmUoKSxsbil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0UmVzdG9yZXIvbGFtYmRhJDkkVHlwZSIsMTgwOCk7ZnVuY3Rpb24gTTBuKGUpe3N3aXRjaChhKHcoZS5sTm9kZSwob2UoKSxWcSkpLDM4Nykub3JkaW5hbCl7Y2FzZSAxOkxyKHBvKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLnNsSHlwZXJMb29wcywxNikpLG5ldyBHVGUpLG5ldyBIVGUpLG5ldyBVVGUpO2JyZWFrO2Nhc2UgMjpEMG4oZSk7YnJlYWs7Y2FzZSAwOlIwbihlKX19ZnVuY3Rpb24gUjBuKGUpe3ZhciBuLHIsdCxvLGkscztmb3Iocz1uZXcgUWkoZS5zbEh5cGVyTG9vcHMpLERyKHMsbmV3IFZUZSksbj0oWDQoKSxQKEkoaVYsMSksVywyNzYsMCxbTjksazksUDksUjksTDksQTksTTksTzldKSkscj0wLGk9bmV3IFQocyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEwNSksdD1uW3Ilbi5sZW5ndGhdLEYwbihvLHQpLCsrcn1mdW5jdGlvbiBEMG4oZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKHQ9MCx1PTAscz1uZXcgVChlLnNsSHlwZXJMb29wcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDEwNSksbz1hKFRvKEpuKG5ldyBTZShudWxsLG5ldyB4ZShpLnNsUG9ydHMsMTYpKSxuZXcgYVYpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxDbyldKSkpLDE1KSxyPW51bGwsdDw9dT8ocj0ocmUoKSxVZSksdCs9by5zaXplXzEoKSk6dTx0JiYocj0ocmUoKSxsbiksdSs9by5zaXplXzEoKSksbj1yLExyKHBvKG8uc3RyZWFtKCksbmV3IFdUZSksbmV3IGpUZShuKSl9ZnVuY3Rpb24gRjBuKGUsbil7dmFyIHIsdCxvLGkscztmb3Iocz1lLnNsUG9ydHMsbi5maXJzdFNpZGUhPW4uc2Vjb25kU2lkZSYmRHIocyxuZXcgcVRlKSxvPXMuYXJyYXkubGVuZ3RoLzJ8MCx0PTA7dDxvO3QrKylpPShBZSh0LHMuYXJyYXkubGVuZ3RoKSxhKHMuYXJyYXlbdF0sMTEzKSksaS5pc0hpZGRlbiYmWHIoaS5sUG9ydCxuLmZpcnN0U2lkZSk7Zm9yKHI9bztyPHMuYXJyYXkubGVuZ3RoO3IrKylpPShBZShyLHMuYXJyYXkubGVuZ3RoKSxhKHMuYXJyYXlbcl0sMTEzKSksaS5pc0hpZGRlbiYmWHIoaS5sUG9ydCxuLnNlY29uZFNpZGUpfWZ1bmN0aW9uIHowbihlLG4pe1hyKG4sZSl9ZnVuY3Rpb24gJDBuKGUsbil7cmV0dXJuIHFvKG4uc2xQb3J0cy5hcnJheS5sZW5ndGgsZS5zbFBvcnRzLmFycmF5Lmxlbmd0aCl9ZnVuY3Rpb24gQjBuKGUsbil7cmV0dXJuIHFvKHQyZShlLmxQb3J0KSx0MmUobi5sUG9ydCkpfWZ1bmN0aW9uIFg0KCl7WDQ9RixOOT1uZXcgJGgoIk5PUlRIIiwwLChyZSgpLFVlKSxVZSksazk9bmV3ICRoKCJTT1VUSCIsMSxsbixsbiksUDk9bmV3ICRoKCJFQVNUIiwyLHFlLHFlKSxSOT1uZXcgJGgoIldFU1QiLDMsamUsamUpLEw5PW5ldyAkaCgiTk9SVEhfV0VTVF9DT1JORVIiLDQsamUsVWUpLEE5PW5ldyAkaCgiTk9SVEhfRUFTVF9DT1JORVIiLDUsVWUscWUpLE05PW5ldyAkaCgiU09VVEhfV0VTVF9DT1JORVIiLDYsbG4samUpLE85PW5ldyAkaCgiU09VVEhfRUFTVF9DT1JORVIiLDcscWUsbG4pfWZ1bmN0aW9uICRoKGUsbixyLHQpe21uLmNhbGwodGhpcyxlLG4pLHRoaXMuZmlyc3RTaWRlPXIsdGhpcy5zZWNvbmRTaWRlPXR9ZnVuY3Rpb24gRzBuKGUpe3JldHVybiBYNCgpLHduKCgkVGUoKSxCVGUpLGUpfWZ1bmN0aW9uIEgwbigpe3JldHVybiBYNCgpLFAoSShpViwxKSxXLDI3NiwwLFtOOSxrOSxQOSxSOSxMOSxBOSxNOSxPOV0pfXAoMjc2LDIyLHszOjEsMzQ6MSwyMjoxLDI3NjoxfSwkaCk7dmFyIFA5LE45LEE5LEw5LGs5LE85LE05LFI5LGlWPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFNpZGVBc3NpZ25lci9UYXJnZXQiLDI3NixnbixIMG4sRzBuKTtmdW5jdGlvbiAkVGUoKXskVGU9RixCVGU9eW4oKFg0KCksUChJKGlWLDEpLFcsMjc2LDAsW045LGs5LFA5LFI5LEw5LEE5LE05LE85XSkpKX12YXIgQlRlO2Z1bmN0aW9uIEdUZSgpe31wKDE3OTEsMSx7fSxHVGUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gSm4obmV3IFNlKG51bGwsbmV3IHhlKGEobiwxMDUpLnNsUG9ydHMsMTYpKSxuZXcgYVYpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFNpZGVBc3NpZ25lci9sYW1iZGEkMSRUeXBlIiwxNzkxKTtmdW5jdGlvbiBIVGUoKXt9cCgxNzkyLDEse30sSFRlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMTMpLmxQb3J0fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFNpZGVBc3NpZ25lci9sYW1iZGEkMiRUeXBlIiwxNzkyKTtmdW5jdGlvbiBVVGUoKXt9cCgxNzkzLDEsSmUsVVRlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtYcihhKG4sMTIpLChyZSgpLFVlKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0U2lkZUFzc2lnbmVyL2xhbWJkYSQzJFR5cGUiLDE3OTMpO2Z1bmN0aW9uIFdUZSgpe31wKDE3OTQsMSx7fSxXVGUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDExMykubFBvcnR9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0U2lkZUFzc2lnbmVyL2xhbWJkYSQ0JFR5cGUiLDE3OTQpO2Z1bmN0aW9uIGpUZShlKXt0aGlzLmZpbmFsTmV3UG9ydFNpZGVfMD1lfXAoMTc5NSwxLEplLGpUZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7ejBuKHRoaXMuZmluYWxOZXdQb3J0U2lkZV8wLGEobiwxMikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFNpZGVBc3NpZ25lci9sYW1iZGEkNSRUeXBlIiwxNzk1KTtmdW5jdGlvbiBWVGUoKXt9cCgxNzk2LDEsTm4sVlRlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiAkMG4oYShuLDEwNSksYShyLDEwNSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMub3JkZXJpbmciLCJQb3J0U2lkZUFzc2lnbmVyL2xhbWJkYSQ2JFR5cGUiLDE3OTYpO2Z1bmN0aW9uIHFUZSgpe31wKDE3OTcsMSxObixxVGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEIwbihhKG4sMTEzKSxhKHIsMTEzKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5vcmRlcmluZyIsIlBvcnRTaWRlQXNzaWduZXIvbGFtYmRhJDckVHlwZSIsMTc5Nyk7ZnVuY3Rpb24gYVYoKXt9cCg4MjAsMSxJbixhViksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMTMpLmlzSGlkZGVufSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLm9yZGVyaW5nIiwiUG9ydFNpZGVBc3NpZ25lci9sYW1iZGEkOCRUeXBlIiw4MjApLHAoMjEwOCwxLHt9KSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJBYnN0cmFjdFNlbGZMb29wUm91dGVyIiwyMTA4KTtmdW5jdGlvbiBZVGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKHI9MCxvPW5ldyBUKChBZSgwLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbMF0sMTA1KSkuc2xIb2xkZXIubE5vZGUucG9ydHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMiksdC5pZF8wPXIrKztmb3Iobj09KHJlKCksVWUpP0RyKGUsbmV3IEtUZSk6RHIoZSxuZXcgWFRlKSx1PTAsZD1lLmFycmF5Lmxlbmd0aC0xO3U8ZDspcz0oQWUodSxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5W3VdLDEwNSkpLF89KEFlKGQsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtkXSwxMDUpKSxpPW49PVVlP3MucmlnaHRtb3N0UG9ydDpzLmxlZnRtb3N0UG9ydCxjPW49PVVlP18ubGVmdG1vc3RQb3J0Ol8ucmlnaHRtb3N0UG9ydCxHYyhzLG4sKGtzKCksVXkpLGkpLEdjKF8sbixIeSxjKSwrK3UsLS1kO3U9PWQmJkdjKChBZSh1LGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbdV0sMTA1KSksbiwoa3MoKSx6aCksbnVsbCl9ZnVuY3Rpb24gVTBuKGUsbil7dmFyIHI7c3dpdGNoKG4ub3JkaW5hbCl7Y2FzZSAyOmNhc2UgNDpyPWUubGVmdG1vc3RQb3J0LGUucmlnaHRtb3N0UG9ydC5sUG9ydC5wb3MueV8wPHIubFBvcnQucG9zLnlfMCYmKHI9ZS5yaWdodG1vc3RQb3J0KSxHYyhlLG4sKGtzKCksVDkpLHIpO2JyZWFrO2Nhc2UgMTpjYXNlIDM6R2MoZSxuLChrcygpLHpoKSxudWxsKX19ZnVuY3Rpb24gR2MoZSxuLHIsdCl7dmFyIG87bz1lLnNsTGFiZWxzLG8uc2lkZT1uLG8uYWxpZ25tZW50PXIsby5hbGlnbm1lbnRSZWZlcmVuY2VTTFBvcnQ9dH1mdW5jdGlvbiBXMG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihyPW51bGwsYz1udWxsLG89YSh3KGUubE5vZGUsKG9lKCksU08pKSwzNDkpLG89PSh0digpLEgzKSYmKHI9bmV3IFEsYz1uZXcgUSksdT1uZXcgVChlLnNsSHlwZXJMb29wcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHM9YShDKHUpLDEwNSksaT1zLnNsTGFiZWxzLCEhaSlzd2l0Y2gocy5zZWxmTG9vcFR5cGUub3JkaW5hbCl7Y2FzZSAwOm49YShlRShuZXcgd2gocy5vY2N1cGllZFBvcnRTaWRlcykpLDY0KSxvPT1IMyYmbj09KHJlKCksVWUpP1JlKHIuYXJyYXkscyk6bz09SDMmJm49PShyZSgpLGxuKT9SZShjLmFycmF5LHMpOlUwbihzLG4pO2JyZWFrO2Nhc2UgMTpfPXMubGVmdG1vc3RQb3J0LmxQb3J0LnNpZGUsZD1zLnJpZ2h0bW9zdFBvcnQubFBvcnQuc2lkZSxfPT0ocmUoKSxVZSk/R2MocyxVZSwoa3MoKSxIeSkscy5sZWZ0bW9zdFBvcnQpOmQ9PVVlP0djKHMsVWUsKGtzKCksVXkpLHMucmlnaHRtb3N0UG9ydCk6Xz09bG4/R2Mocyxsbiwoa3MoKSxVeSkscy5sZWZ0bW9zdFBvcnQpOmQ9PWxuJiZHYyhzLGxuLChrcygpLEh5KSxzLnJpZ2h0bW9zdFBvcnQpO2JyZWFrO2Nhc2UgMjpjYXNlIDM6dD1zLm9jY3VwaWVkUG9ydFNpZGVzLCRpKHQsKHJlKCksVWUpKT8kaSh0LGxuKT8kaSh0LGplKT8kaSh0LHFlKXx8R2MocyxVZSwoa3MoKSxVeSkscy5yaWdodG1vc3RQb3J0KTpHYyhzLFVlLChrcygpLEh5KSxzLmxlZnRtb3N0UG9ydCk6R2MocyxVZSwoa3MoKSx6aCksbnVsbCk6R2Mocyxsbiwoa3MoKSx6aCksbnVsbCk7YnJlYWs7Y2FzZSA0OmY9cy5sZWZ0bW9zdFBvcnQubFBvcnQuc2lkZSxoPXMubGVmdG1vc3RQb3J0LmxQb3J0LnNpZGUsZj09KHJlKCksVWUpfHxoPT1VZT9HYyhzLGxuLChrcygpLHpoKSxudWxsKTpHYyhzLFVlLChrcygpLHpoKSxudWxsKX1yJiYoci5hcnJheS5sZW5ndGg9PTB8fFlUZShyLChyZSgpLFVlKSksYy5hcnJheS5sZW5ndGg9PTB8fFlUZShjLChyZSgpLGxuKSkpfWZ1bmN0aW9uIGowbihlKXt2YXIgbixyLHQsbztzd2l0Y2gobz1lLnNsTGFiZWxzLG49by5hbGlnbm1lbnRSZWZlcmVuY2VTTFBvcnQsdD1vLnNpemVfMCxyPW8ucG9zaXRpb24sby5hbGlnbm1lbnQub3JkaW5hbCl7Y2FzZSAwOnIueF8wPShlLnNsSG9sZGVyLmxOb2RlLnNpemVfMC54XzAtdC54XzApLzI7YnJlYWs7Y2FzZSAxOnIueF8wPW4ubFBvcnQucG9zLnhfMCtuLmxQb3J0LmFuY2hvci54XzA7YnJlYWs7Y2FzZSAyOnIueF8wPW4ubFBvcnQucG9zLnhfMCtuLmxQb3J0LmFuY2hvci54XzAtdC54XzA7YnJlYWs7Y2FzZSAzOnIueV8wPW4ubFBvcnQucG9zLnlfMCtuLmxQb3J0LmFuY2hvci55XzB9fWZ1bmN0aW9uIFYwbihlKXt2YXIgbixyO2ZvcihXMG4oZSkscj1uZXcgVChlLnNsSHlwZXJMb29wcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDEwNSksbi5zbExhYmVscyYmajBuKG4pfWZ1bmN0aW9uIHEwbihlLG4pe3JldHVybiBxbyhlLmxlZnRtb3N0UG9ydC5sUG9ydC5pZF8wLG4ubGVmdG1vc3RQb3J0LmxQb3J0LmlkXzApfWZ1bmN0aW9uIFkwbihlLG4pe3JldHVybiBxbyhuLmxlZnRtb3N0UG9ydC5sUG9ydC5pZF8wLGUubGVmdG1vc3RQb3J0LmxQb3J0LmlkXzApfWZ1bmN0aW9uIEtUZSgpe31wKDE4MTYsMSxObixLVGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHEwbihhKG4sMTA1KSxhKHIsMTA1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5yb3V0aW5nIiwiTGFiZWxQbGFjZXIvbGFtYmRhJDAkVHlwZSIsMTgxNik7ZnVuY3Rpb24gWFRlKCl7fXAoMTgxNywxLE5uLFhUZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gWTBuKGEobiwxMDUpLGEociwxMDUpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJMYWJlbFBsYWNlci9sYW1iZGEkMSRUeXBlIiwxODE3KTtmdW5jdGlvbiBLMG4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQ7aWYocz1lLnNsU291cmNlLmxQb3J0LHU9ZS5zbFRhcmdldC5sUG9ydCxzLnNpZGUhPXUuc2lkZSlmb3IoZD1lLnNsSHlwZXJMb29wLG89cy5zaWRlLGM9bnVsbDtvIT11LnNpZGU7KWM9bj09MD9kQShvKTpfZWUobyksaT1sVihvLGQucm91dGluZ1Nsb3Rbby5vcmRpbmFsXSxyKSxfPWxWKGMsZC5yb3V0aW5nU2xvdFtjLm9yZGluYWxdLHIpLExuKHQsS24oaSxfKSksbz1jfWZ1bmN0aW9uIEpUZShlLG4scix0KXt2YXIgbyxpLHMsdSxjO3N3aXRjaChjPWUuc2xIeXBlckxvb3AsaT1uLmxQb3J0LHM9aS5zaWRlLHU9bFYocyxjLnJvdXRpbmdTbG90W3Mub3JkaW5hbF0sciksbz1LbihDdChpLnBvcyksaS5hbmNob3IpLGkuc2lkZS5vcmRpbmFsKXtjYXNlIDE6Y2FzZSAzOnUueF8wKz1vLnhfMDticmVhaztjYXNlIDI6Y2FzZSA0OnUueV8wKz1vLnlfMH1icih0LHUsdC50YWlsLnByZXYsdC50YWlsKX1mdW5jdGlvbiBYMG4oZSxuLHIpe3ZhciB0LG87c3dpdGNoKG89ZS5sTm9kZSx0PW8ubWFyZ2luLG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybi10LnRvcF8wLXI7Y2FzZSAyOnJldHVybiBvLnNpemVfMC54XzArdC5yaWdodCtyO2Nhc2UgMzpyZXR1cm4gby5zaXplXzAueV8wK3QuYm90dG9tK3I7Y2FzZSA0OnJldHVybi10LmxlZnQtcjtkZWZhdWx0OnJldHVybi0xfX1mdW5jdGlvbiBKMG4oZSl7dmFyIG4scix0LG8saTtyZXR1cm4gcj1lLnNsU291cmNlLmxQb3J0LHQ9ci5zaWRlLG89ZS5zbFRhcmdldC5sUG9ydCxpPW8uc2lkZSx0PT1pP3IuaWRfMDxvLmlkXzA/MDoxOmRBKHQpPT1pPzA6X2VlKHQpPT1pPzE6KG49ZS5zbEh5cGVyTG9vcCwkaShuLm9jY3VwaWVkUG9ydFNpZGVzLGRBKHQpKT8wOjEpfWZ1bmN0aW9uIEQ5KGUsbixyLHQsbyxpKXt2YXIgcyx1LGMsXyxkO2ZvcihzPVgwbihuLHIsaSksdT1yPT0ocmUoKSxVZSl8fHI9PWplPy0xOjEsXz1lW3Iub3JkaW5hbF0sZD0wO2Q8Xy5sZW5ndGg7ZCsrKWM9X1tkXSxjPjAmJihjKz1vKSxfW2RdPXMscys9dSooYyt0KX1mdW5jdGlvbiBaMG4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYztmb3IoYz1CKGN0LFgsMTA5LChyZSgpLFAoSSgkdCwxKSxqbyw2NCwwLFtPbyxVZSxxZSxsbixqZV0pKS5sZW5ndGgsMCwyKSxpPVAoSSgkdCwxKSxqbyw2NCwwLFtPbyxVZSxxZSxsbixqZV0pLHM9MCx1PWkubGVuZ3RoO3M8dTsrK3Mpbz1pW3NdLGNbby5vcmRpbmFsXT1CKGN0LFh0LDI4LGUucm91dGluZ1Nsb3RDb3VudFtvLm9yZGluYWxdLDE1LDEpO3JldHVybiBaVGUoYyxlLFVlKSxaVGUoYyxlLGxuKSxEOShjLGUsVWUsbixyLHQpLEQ5KGMsZSxxZSxuLHIsdCksRDkoYyxlLGxuLG4scix0KSxEOShjLGUsamUsbixyLHQpLGN9ZnVuY3Rpb24gbFYoZSxuLHIpe3ZhciB0O3N3aXRjaCh0PXJbZS5vcmRpbmFsXVtuXSxlLm9yZGluYWwpe2Nhc2UgMTpjYXNlIDM6cmV0dXJuIG5ldyBZKDAsdCk7Y2FzZSAyOmNhc2UgNDpyZXR1cm4gbmV3IFkodCwwKTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBaVGUoZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKG89ZVtyLm9yZGluYWxdLHU9bmV3IFQobi5zbEh5cGVyTG9vcHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMDUpLGk9cy5zbExhYmVscyxpJiZpLnNpZGU9PXImJih0PXMucm91dGluZ1Nsb3Rbci5vcmRpbmFsXSxvW3RdPVMuTWF0aC5tYXgob1t0XSxpLnNpemVfMC55XzApKX1mdW5jdGlvbiBRMG4oZSxuLHIsdCl7dmFyIG8saTtzd2l0Y2goaT1uLnNpZGUsbz1yW2kub3JkaW5hbF1bZS5yb3V0aW5nU2xvdFtpLm9yZGluYWxdXSxpLm9yZGluYWwpe2Nhc2UgMTpvLT10K24uc2l6ZV8wLnlfMCxuLnBvc2l0aW9uLnlfMD1vO2JyZWFrO2Nhc2UgMzpvKz10LG4ucG9zaXRpb24ueV8wPW87YnJlYWs7Y2FzZSA0Om8tPXQrbi5zaXplXzAueF8wLG4ucG9zaXRpb24ueF8wPW87YnJlYWs7Y2FzZSAyOm8rPXQsbi5wb3NpdGlvbi54XzA9b319ZnVuY3Rpb24gZV9uKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2ZvcihzPW4ubE5vZGUsZD1zLnNpemVfMCxjPXMubWFyZ2luLHQ9UigkKGg0KHMsKG9lKCkscWwpKSkpLG89UigkKGg0KHMsdGcpKSksXz1SKCQoaDQocyxOTykpKSx1PW5ldyBvOSxNVyh1LGMudG9wXzAsYy5yaWdodCxjLmJvdHRvbSxjLmxlZnQpLGg9WjBuKG4sdCxvLF8pLHg9bmV3IFQobi5zbEh5cGVyTG9vcHMpO3guaTx4LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHY9YShDKHgpLDEwNSkseT12LnNsRWRnZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7eS5oYXNOZXh0XzAoKTspbT1hKHkubmV4dF8xKCksMzQwKSxpPW0ubEVkZ2UsZj1KMG4obSkscj0oQT1uZXcgamksSlRlKG0sbS5zbFNvdXJjZSxoLEEpLEswbihtLGYsaCxBKSxKVGUobSxtLnNsVGFyZ2V0LGgsQSksQSkscj1lLm1vZGlmeUJlbmRQb2ludHMobSxmLHIpLGthKGkuYmVuZFBvaW50cyksZnQoaS5iZW5kUG9pbnRzLHIpLExyKG5ldyBTZShudWxsLG5ldyB4ZShyLDE2KSksbmV3IGViZShkLHUpKTtFPXYuc2xMYWJlbHMsRSYmKFEwbih2LEUsaCxvKSxrPW5ldyBSdChFLnBvc2l0aW9uKSxzVihkLHUsayksS24oayxFLnNpemVfMCksc1YoZCx1LGspKX1NVyhjLHUudG9wXzAsdS5yaWdodCx1LmJvdHRvbSx1LmxlZnQpfWZ1bmN0aW9uIHNWKGUsbixyKXtuLmxlZnQ9Uy5NYXRoLm1heChuLmxlZnQsLXIueF8wKSxuLnJpZ2h0PVMuTWF0aC5tYXgobi5yaWdodCxyLnhfMC1lLnhfMCksbi50b3BfMD1TLk1hdGgubWF4KG4udG9wXzAsLXIueV8wKSxuLmJvdHRvbT1TLk1hdGgubWF4KG4uYm90dG9tLHIueV8wLWUueV8wKX1mdW5jdGlvbiBRVGUoKXt9cCgxODU2LDIxMDgse30sUVRlKSxsLm1vZGlmeUJlbmRQb2ludHM9ZnVuY3Rpb24obixyLHQpe3JldHVybiB0fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJPcnRob2dvbmFsU2VsZkxvb3BSb3V0ZXIiLDE4NTYpO2Z1bmN0aW9uIGViZShlLG4pe3RoaXMubm9kZVNpemVfMT1lLHRoaXMubmV3Tm9kZU1hcmdpbnNfMj1ufXAoMTg1OCwxLEplLGViZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7c1YodGhpcy5ub2RlU2l6ZV8xLHRoaXMubmV3Tm9kZU1hcmdpbnNfMixhKG4sOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJPcnRob2dvbmFsU2VsZkxvb3BSb3V0ZXIvbGFtYmRhJDAkVHlwZSIsMTg1OCk7ZnVuY3Rpb24gbl9uKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7Zm9yKGM9bmV3IGppLG49ZG4oZSwwKSx1PW51bGwscj1hKHVuKG4pLDgpLG89YSh1bihuKSw4KTtuLmN1cnJlbnROb2RlIT1uLnRoaXMkMDEudGFpbDspdT1yLHI9byxvPWEodW4obiksOCksaT1uYmUocnQobmV3IFkodS54XzAsdS55XzApLHIpKSxzPW5iZShydChuZXcgWShvLnhfMCxvLnlfMCkscikpLHQ9MTAsdD1TLk1hdGgubWluKHQsUy5NYXRoLmFicyhpLnhfMCtpLnlfMCkvMiksdD1TLk1hdGgubWluKHQsUy5NYXRoLmFicyhzLnhfMCtzLnlfMCkvMiksaS54XzA9SUMoaS54XzApKnQsaS55XzA9SUMoaS55XzApKnQscy54XzA9SUMocy54XzApKnQscy55XzA9SUMocy55XzApKnQsTG4oYyxLbihpLHIpKSxMbihjLEtuKHMscikpO3JldHVybiBjfWZ1bmN0aW9uIG5iZShlKXtyZXR1cm4gZS54XzA+PS0uMDEmJmUueF8wPD1DcyYmKGUueF8wPTApLGUueV8wPj0tLjAxJiZlLnlfMDw9Q3MmJihlLnlfMD0wKSxlfWZ1bmN0aW9uIHJiZSgpe31wKDE4NTcsMTg1Nix7fSxyYmUpLGwubW9kaWZ5QmVuZFBvaW50cz1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtyZXR1cm4gbz1uLnNsU291cmNlLmxQb3J0LFptKHQsMCxLbihDdChvLnBvcyksby5hbmNob3IpKSxpPW4uc2xUYXJnZXQubFBvcnQsTG4odCxLbihDdChpLnBvcyksaS5hbmNob3IpKSxuX24odCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMucm91dGluZyIsIlBvbHlsaW5lU2VsZkxvb3BSb3V0ZXIiLDE4NTcpO2Z1bmN0aW9uIEo0KCl7SjQ9RixWcD1uZXcgYWJlfWZ1bmN0aW9uIHJfbihlKXt2YXIgbjtmb3Iobj0wO248ZS5hcnJheS5sZW5ndGg7bisrKShBZShuLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbbl0sMTIpKS5pZF8wPW59ZnVuY3Rpb24gRjkoZSxuLHIsdCl7dmFyIG8saSxzLHU7cmV0dXJuIGUucG9ydFBlbmFsdGllcz09bnVsbCYmaV9uKGUsbikscz1uLmxOb2RlLnBvcnRzLmFycmF5Lmxlbmd0aCxpPXIubFBvcnQuaWRfMCx1PXQubFBvcnQuaWRfMCxvPXUtMSxvPDAmJihvPXMtMSksaTw9bz9lLnBvcnRQZW5hbHRpZXNbb10tZS5wb3J0UGVuYWx0aWVzW2ldOmUucG9ydFBlbmFsdGllc1tzLTFdLWUucG9ydFBlbmFsdGllc1tpXStlLnBvcnRQZW5hbHRpZXNbb119ZnVuY3Rpb24gdF9uKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKGk9cmgoZS5zbFBvcnRzQnlTaWRlKSxyPShyZSgpLFAoSSgkdCwxKSxqbyw2NCwwLFtPbyxVZSxxZSxsbixqZV0pKSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KWlmKG49clt0XSxuIT1PbyYmIWkuY29udGFpbnMobikpcmV0dXJuIG47cmV0dXJuIG51bGx9ZnVuY3Rpb24gb19uKGUpe3ZhciBuLHI7Zm9yKG49ZS5sZWZ0bW9zdFBvcnQubFBvcnQuc2lkZSxyPWUucmlnaHRtb3N0UG9ydC5sUG9ydC5zaWRlO24hPXI7KU1sKGUub2NjdXBpZWRQb3J0U2lkZXMsbiksbj1kQShuKTtNbChlLm9jY3VwaWVkUG9ydFNpZGVzLG4pfWZ1bmN0aW9uIGlfbihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPW4ubE5vZGUucG9ydHMsZS5wb3J0UGVuYWx0aWVzPUIoaG4sa24sMjgsaS5hcnJheS5sZW5ndGgsMTUsMSksbz0wLHQ9MDt0PGkuYXJyYXkubGVuZ3RoO3QrKylyPShBZSh0LGkuYXJyYXkubGVuZ3RoKSxhKGkuYXJyYXlbdF0sMTIpKSxyLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wJiZyLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wP28rPTE6bys9MyxlLnBvcnRQZW5hbHRpZXNbdF09b31mdW5jdGlvbiBhX24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKHU9bi5zbFBvcnRzLHM9bi5zbEhvbGRlcixjPWEobGUodSx1LmFycmF5Lmxlbmd0aC0xKSwxMTMpLGQ9KEFlKDAsdS5hcnJheS5sZW5ndGgpLGEodS5hcnJheVswXSwxMTMpKSxfPUY5KGUscyxjLGQpLGk9MTtpPHUuYXJyYXkubGVuZ3RoO2krKylyPShBZShpLTEsdS5hcnJheS5sZW5ndGgpLGEodS5hcnJheVtpLTFdLDExMykpLG89KEFlKGksdS5hcnJheS5sZW5ndGgpLGEodS5hcnJheVtpXSwxMTMpKSx0PUY5KGUscyxyLG8pLHQ+XyYmKGM9cixkPW8sXz10KTtuLmxlZnRtb3N0UG9ydD1kLG4ucmlnaHRtb3N0UG9ydD1jfWZ1bmN0aW9uIGxfbihlLG4pe3ZhciByLHQsbyxpO2ZvcihyX24obi5sTm9kZS5wb3J0cyksTHIocG8obmV3IFNlKG51bGwsbmV3IHhlKG4uc2xIeXBlckxvb3BzLDE2KSksbmV3IGxiZSksbmV3IHNiZSksaT1uZXcgVChuLnNsSHlwZXJMb29wcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtzd2l0Y2gobz1hKEMoaSksMTA1KSxvLnNlbGZMb29wVHlwZS5vcmRpbmFsKXtjYXNlIDA6cj1hKGxlKG8uc2xQb3J0cywwKSwxMTMpLmxQb3J0LnNpZGUsblYobyxhKHZhKGJoKGEoWm4oby5zbFBvcnRzQnlTaWRlLHIpLDE1KS5zdHJlYW0oKSxWcCkpLDExMykpLHJWKG8sYSh2YShjZihhKFpuKG8uc2xQb3J0c0J5U2lkZSxyKSwxNSkuc3RyZWFtKCksVnApKSwxMTMpKTticmVhaztjYXNlIDE6dD1vVihvKSxuVihvLGEodmEoYmgoYShabihvLnNsUG9ydHNCeVNpZGUsdFswXSksMTUpLnN0cmVhbSgpLFZwKSksMTEzKSksclYobyxhKHZhKGNmKGEoWm4oby5zbFBvcnRzQnlTaWRlLHRbMV0pLDE1KS5zdHJlYW0oKSxWcCkpLDExMykpO2JyZWFrO2Nhc2UgMjp1X24oZSxvKTticmVhaztjYXNlIDM6c19uKG8pO2JyZWFrO2Nhc2UgNDphX24oZSxvKX1vX24obyl9ZS5wb3J0UGVuYWx0aWVzPW51bGx9ZnVuY3Rpb24gc19uKGUpe3ZhciBuLHI7c3dpdGNoKG49bnVsbCxyPW51bGwsdF9uKGUpLm9yZGluYWwpe2Nhc2UgMTpuPShyZSgpLHFlKSxyPWplO2JyZWFrO2Nhc2UgMjpuPShyZSgpLGxuKSxyPVVlO2JyZWFrO2Nhc2UgMzpuPShyZSgpLGplKSxyPXFlO2JyZWFrO2Nhc2UgNDpuPShyZSgpLFVlKSxyPWxufW5WKGUsYSh2YShiaChhKFpuKGUuc2xQb3J0c0J5U2lkZSxuKSwxNSkuc3RyZWFtKCksVnApKSwxMTMpKSxyVihlLGEodmEoY2YoYShabihlLnNsUG9ydHNCeVNpZGUsciksMTUpLnN0cmVhbSgpLFZwKSksMTEzKSl9ZnVuY3Rpb24gdV9uKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztjPWEoSTIocmgobi5zbFBvcnRzQnlTaWRlKSxCKCR0LGpvLDY0LDIsMCwxKSksMTI2KSxfPW4uc2xIb2xkZXIscj1vYmUobixjWzBdKSxvPXRiZShuLGNbMV0pLHQ9RjkoZSxfLHIsbyksaT1vYmUobixjWzFdKSx1PXRiZShuLGNbMF0pLHM9RjkoZSxfLGksdSksdDw9cz8obi5sZWZ0bW9zdFBvcnQ9cixuLnJpZ2h0bW9zdFBvcnQ9byk6KG4ubGVmdG1vc3RQb3J0PWksbi5yaWdodG1vc3RQb3J0PXUpfWZ1bmN0aW9uIHRiZShlLG4pe3JldHVybiBhKHZhKGNmKGEoWm4oZS5zbFBvcnRzQnlTaWRlLG4pLDE1KS5zdHJlYW0oKSxWcCkpLDExMyl9ZnVuY3Rpb24gb2JlKGUsbil7cmV0dXJuIGEodmEoYmgoYShabihlLnNsUG9ydHNCeVNpZGUsbiksMTUpLnN0cmVhbSgpLFZwKSksMTEzKX1mdW5jdGlvbiBpYmUoKXtKNCgpfWZ1bmN0aW9uIGNfbihlLG4pe3JldHVybiBKNCgpLHFvKGUubFBvcnQuaWRfMCxuLmxQb3J0LmlkXzApfXAoMTgxMiwxLHt9LGliZSksbC5wb3J0UGVuYWx0aWVzPW51bGw7dmFyIFZwO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMucm91dGluZyIsIlJvdXRpbmdEaXJlY3RvciIsMTgxMik7ZnVuY3Rpb24gYWJlKCl7fXAoMTgxMywxLE5uLGFiZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gY19uKGEobiwxMTMpLGEociwxMTMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJSb3V0aW5nRGlyZWN0b3IvbGFtYmRhJDAkVHlwZSIsMTgxMyk7ZnVuY3Rpb24gbGJlKCl7fXAoMTgxNCwxLHt9LGxiZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBKNCgpLGEobiwxMDUpLnNsUG9ydHN9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUubG9vcHMucm91dGluZyIsIlJvdXRpbmdEaXJlY3Rvci9sYW1iZGEkMSRUeXBlIiwxODE0KTtmdW5jdGlvbiBzYmUoKXt9cCgxODE1LDEsSmUsc2JlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtKNCgpLGEobiwxNSkuc29ydF8wKFZwKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5yb3V0aW5nIiwiUm91dGluZ0RpcmVjdG9yL2xhbWJkYSQyJFR5cGUiLDE4MTUpO2Z1bmN0aW9uIF9fbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKGk9bmV3IFQobi5zbEh5cGVyTG9vcHMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksMTA1KSxzPWEoS2UoZS5zbExvb3BUb1NlZ21lbnRNYXAsbyksMTE4KS5yb3V0aW5nU2xvdCx0PW5ldyB3aChvLm9jY3VwaWVkUG9ydFNpZGVzKTt0Lmk8dC50aGlzJDExLmFsbC5sZW5ndGg7KXI9YShlRSh0KSw2NCksdFYobyxyLHMpfWZ1bmN0aW9uIGRfbihlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3Iocz1uZXcgcHIsaT1uZXcgVChlLmh5cGVyRWRnZVNlZ21lbnRzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTE4KSxFNyhvLG8uaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzLmFycmF5Lmxlbmd0aCksWlAobyxvLm91dGdvaW5nU2VnbWVudERlcGVuZGVuY2llcy5hcnJheS5sZW5ndGgpLG8ub3V0RGVwV2VpZ2h0PT0wJiYoby5yb3V0aW5nU2xvdD0wLGJyKHMsbyxzLnRhaWwucHJldixzLnRhaWwpKTtmb3IoO3Muc2l6ZV8wIT0wOylmb3Iobz1hKHMuc2l6ZV8wPT0wP251bGw6KHJuKHMuc2l6ZV8wIT0wKSxaYShzLHMuaGVhZGVyLm5leHRfMCkpLDExOCksdD1vLnJvdXRpbmdTbG90KzEscj1uZXcgVChvLmluY29taW5nU2VnbWVudERlcGVuZGVuY2llcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDEzMiksdT1uLnNvdXJjZSxqSyh1LFMuTWF0aC5tYXgodS5yb3V0aW5nU2xvdCx0KSksWlAodSx1Lm91dERlcFdlaWdodC0xKSx1Lm91dERlcFdlaWdodD09MCYmYnIocyx1LHMudGFpbC5wcmV2LHMudGFpbCl9ZnVuY3Rpb24gZl9uKGUsbil7dmFyIHIsdDtyPXBfbihuKSxoX24oZSxuLHIpLG01ZShlLmh5cGVyRWRnZVNlZ21lbnRzLGEodyhTdChuLmxOb2RlKSwoSygpLFZoKSksMjM0KSksZF9uKGUpLF9fbihlLG4pLHQ9QihobixrbiwyOCxuLmxOb2RlLnBvcnRzLmFycmF5Lmxlbmd0aCwxNSwxKSx6OShlLG4sKHJlKCksVWUpLHQsciksejkoZSxuLHFlLHQsciksejkoZSxuLGxuLHQsciksejkoZSxuLGplLHQsciksZS5oeXBlckVkZ2VTZWdtZW50cz1udWxsLGUuc2xMb29wVG9TZWdtZW50TWFwPW51bGwsZS5zbExvb3BBY3Rpdml0eU92ZXJQb3J0cz1udWxsfWZ1bmN0aW9uIHBfbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZDtmb3Iocj0wLHU9bmV3IFQoZS5zbEh5cGVyTG9vcHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMDUpLHMuc2xMYWJlbHMmJihzLnNsTGFiZWxzLmlkXzA9cisrKTtmb3Iobj1iXyh5YSxbWCx4dV0sWzE4MywyOF0sMTYsW3Iscl0sMiksZD1lLnNsSHlwZXJMb29wcyxvPTA7bzxkLmFycmF5Lmxlbmd0aDtvKyspaWYoYz0oQWUobyxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W29dLDEwNSkpLGMuc2xMYWJlbHMpZm9yKGk9bysxO2k8ZC5hcnJheS5sZW5ndGg7aSsrKV89KEFlKGksZC5hcnJheS5sZW5ndGgpLGEoZC5hcnJheVtpXSwxMDUpKSxfLnNsTGFiZWxzJiYodD15X24oYyxfKSxuW2Muc2xMYWJlbHMuaWRfMF1bXy5zbExhYmVscy5pZF8wXT10LG5bXy5zbExhYmVscy5pZF8wXVtjLnNsTGFiZWxzLmlkXzBdPXQpO3JldHVybiBufWZ1bmN0aW9uIGdfbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihjPW4uc2xIeXBlckxvb3BzLG89bi5sTm9kZS5wb3J0cyx1PW5ldyBUKGMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocz1hKEModSksMTA1KSxpPUIoeWEseHUsMjgsby5hcnJheS5sZW5ndGgsMTYsMSksQm4oZS5zbExvb3BBY3Rpdml0eU92ZXJQb3J0cyxzLGkpLHI9cy5sZWZ0bW9zdFBvcnQubFBvcnQuaWRfMC0xLHQ9cy5yaWdodG1vc3RQb3J0LmxQb3J0LmlkXzA7ciE9dDspcj0ocisxKSVvLmFycmF5Lmxlbmd0aCxpW3JdPSEwfWZ1bmN0aW9uIHViZShlLG4scil7dmFyIHQsbyxpLHM7Zm9yKG89YShLZShlLnNsTG9vcEFjdGl2aXR5T3ZlclBvcnRzLHIpLDE4MyksdD0wLHM9bmV3IFQobi5zbFBvcnRzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksMTEzKSxvW2kubFBvcnQuaWRfMF0mJisrdDtyZXR1cm4gdH1mdW5jdGlvbiBoX24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfO2ZvcihfPW4uc2xIeXBlckxvb3BzLGUuaHlwZXJFZGdlU2VnbWVudHM9bmV3IF9pKF8uYXJyYXkubGVuZ3RoKSxlLnNsTG9vcFRvU2VnbWVudE1hcD1uZXcgc24sdT1uZXcgVChfKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTA1KSxpPW5ldyBLMyhudWxsKSxlZShlLmh5cGVyRWRnZVNlZ21lbnRzLGkpLEJuKGUuc2xMb29wVG9TZWdtZW50TWFwLHMsaSk7Zm9yKGUuc2xMb29wQWN0aXZpdHlPdmVyUG9ydHM9bmV3IHNuLGdfbihlLG4pLHQ9MDt0PF8uYXJyYXkubGVuZ3RoLTE7dCsrKWZvcihjPWEobGUobi5zbEh5cGVyTG9vcHMsdCksMTA1KSxvPXQrMTtvPF8uYXJyYXkubGVuZ3RoO28rKyltX24oZSxjLGEobGUobi5zbEh5cGVyTG9vcHMsbyksMTA1KSxyKX1mdW5jdGlvbiBtX24oZSxuLHIsdCl7dmFyIG8saSxzLHU7bz11YmUoZSxuLHIpLGk9dWJlKGUscixuKSxzPWEoS2UoZS5zbExvb3BUb1NlZ21lbnRNYXAsbiksMTE4KSx1PWEoS2UoZS5zbExvb3BUb1NlZ21lbnRNYXAsciksMTE4KSxvPGk/bmV3IEtfKChmcygpLEJmKSxzLHUsaS1vKTppPG8/bmV3IEtfKChmcygpLEJmKSx1LHMsby1pKToobyE9MHx8ISghbi5zbExhYmVsc3x8IXIuc2xMYWJlbHMpJiZ0W24uc2xMYWJlbHMuaWRfMF1bci5zbExhYmVscy5pZF8wXSkmJihuZXcgS18oKGZzKCksQmYpLHMsdSwwKSxuZXcgS18oQmYsdSxzLDApKX1mdW5jdGlvbiB5X24oZSxuKXt2YXIgcix0LG8saSxzLHU7cmV0dXJuIG89ZS5zbExhYmVscyxpPW4uc2xMYWJlbHMsIW98fCFpfHxvLnNpZGUhPWkuc2lkZXx8by5zaWRlPT0ocmUoKSxxZSl8fG8uc2lkZT09KHJlKCksamUpPyExOihzPW8ucG9zaXRpb24ueF8wLHI9cytvLnNpemVfMC54XzAsdT1pLnBvc2l0aW9uLnhfMCx0PXUraS5zaXplXzAueF8wLHM8PXQmJnI+PXUpfWZ1bmN0aW9uIHo5KGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE07Zm9yKEE9YShUbyhFeChKbihuZXcgU2UobnVsbCxuZXcgeGUobi5zbEh5cGVyTG9vcHMsMTYpKSxuZXcgX2JlKHIpKSxuZXcgZGJlKHIpKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksZj1xbixkPWJ0LGM9bmV3IFQobi5sTm9kZS5wb3J0cyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDEyKSx1LnNpZGU9PXImJihmPVMuTWF0aC5taW4oZix1LmlkXzApLGQ9Uy5NYXRoLm1heChkLHUuaWRfMCkpO2lmKGY9PXFuKWZvcihzPTA7czxBLnNpemVfMSgpO3MrKyl0VihhKEEuZ2V0XzAocyksMTA1KSxyLHMpO2Vsc2UgZm9yKGs9QihobixrbiwyOCxvLmxlbmd0aCwxNSwxKSxKWmUoayxrLmxlbmd0aCkseD1BLml0ZXJhdG9yXzAoKTt4Lmhhc05leHRfMCgpOyl7Zm9yKHY9YSh4Lm5leHRfMSgpLDEwNSksaT1hKEtlKGUuc2xMb29wQWN0aXZpdHlPdmVyUG9ydHMsdiksMTgzKSxfPTAsRT1mO0U8PWQ7RSsrKWlbRV0mJihfPVMuTWF0aC5tYXgoXyx0W0VdKSk7aWYodi5zbExhYmVscyl7Zm9yKG09di5zbExhYmVscy5pZF8wLE09bmV3IEJyLGg9MDtoPG8ubGVuZ3RoO2grKylvW21dW2hdJiZZcihNLEooa1toXSkpO2Zvcig7c3MoTSxKKF8pKTspKytffWZvcih0Vih2LHIsXykseT1mO3k8PWQ7eSsrKWlbeV0mJih0W3ldPV8rMSk7di5zbExhYmVscyYmKGtbdi5zbExhYmVscy5pZF8wXT1fKX19ZnVuY3Rpb24gY2JlKCl7fWZ1bmN0aW9uIHdfbihlLG4pe3JldHVybiAkaShuLm9jY3VwaWVkUG9ydFNpZGVzLGUpfWZ1bmN0aW9uIEVfbihlLG4scil7cmV0dXJuIHFvKG4ucm91dGluZ1Nsb3RbZS5vcmRpbmFsXSxyLnJvdXRpbmdTbG90W2Uub3JkaW5hbF0pfXAoMTgxOCwxLHt9LGNiZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5yb3V0aW5nIiwiUm91dGluZ1Nsb3RBc3NpZ25lciIsMTgxOCk7ZnVuY3Rpb24gX2JlKGUpe3RoaXMuc2lkZV8wPWV9cCgxODE5LDEsSW4sX2JlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gd19uKHRoaXMuc2lkZV8wLGEobiwxMDUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5yb3V0aW5nIiwiUm91dGluZ1Nsb3RBc3NpZ25lci9sYW1iZGEkMCRUeXBlIiwxODE5KTtmdW5jdGlvbiBkYmUoZSl7dGhpcy5zaWRlXzA9ZX1wKDE4MjAsMSxObixkYmUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEVfbih0aGlzLnNpZGVfMCxhKG4sMTA1KSxhKHIsMTA1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5sb29wcy5yb3V0aW5nIiwiUm91dGluZ1Nsb3RBc3NpZ25lci9sYW1iZGEkMSRUeXBlIiwxODIwKTtmdW5jdGlvbiB2X24oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQ7Zm9yKGk9ZS5zbFNvdXJjZS5sUG9ydC5zaWRlLHM9YShWYShyLDApLDgpLGQ9MTtkPHIuc2l6ZV8wO2QrKylfPWEoVmEocixkKSw4KSxicih0LHMsdC50YWlsLnByZXYsdC50YWlsKSx1PXl1KEtuKG5ldyBSdChzKSxfKSwuNSksYz15dShuZXcgWE0oZVgoaSkpLG8pLEtuKHUsYyksYnIodCx1LHQudGFpbC5wcmV2LHQudGFpbCkscz1fLGk9bj09MD9kQShpKTpfZWUoaSk7TG4odCwocm4oci5zaXplXzAhPTApLGEoci50YWlsLnByZXYudmFsdWVfMCw4KSkpfWZ1bmN0aW9uIGZiZSgpe31wKDE4NTksMTg1Nix7fSxmYmUpLGwubW9kaWZ5QmVuZFBvaW50cz1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzLHU7cmV0dXJuIG89UigkKGg0KG4uc2xIeXBlckxvb3Auc2xIb2xkZXIubE5vZGUsKG9lKCksdGcpKSkpLHU9bmV3IE5EZShQKEkob3QsMSksWCw4LDAsWyhzPW4uc2xTb3VyY2UubFBvcnQsS24obmV3IFJ0KHMucG9zKSxzLmFuY2hvcikpXSkpLHZfbihuLHIsdCx1LG8pLExuKHUsKGk9bi5zbFRhcmdldC5sUG9ydCxLbihuZXcgUnQoaS5wb3MpLGkuYW5jaG9yKSkpLEM1ZShuZXcgWEsodSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLmxvb3BzLnJvdXRpbmciLCJTcGxpbmVTZWxmTG9vcFJvdXRlciIsMTg1OSk7ZnVuY3Rpb24gcGJlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2lmKHlpKGUuYmlnZ2VyVGhhbixuKSl7aWYoc3MoYShLZShlLmJpZ2dlclRoYW4sbiksNDkpLHIpKXJldHVybiAxfWVsc2UgQm4oZS5iaWdnZXJUaGFuLG4sbmV3IEJyKTtpZih5aShlLmJpZ2dlclRoYW4scikpe2lmKHNzKGEoS2UoZS5iaWdnZXJUaGFuLHIpLDQ5KSxuKSlyZXR1cm4tMX1lbHNlIEJuKGUuYmlnZ2VyVGhhbixyLG5ldyBCcik7aWYoeWkoZS5zbWFsbGVyVGhhbixuKSl7aWYoc3MoYShLZShlLnNtYWxsZXJUaGFuLG4pLDQ5KSxyKSlyZXR1cm4tMX1lbHNlIEJuKGUuc21hbGxlclRoYW4sbixuZXcgQnIpO2lmKHlpKGUuc21hbGxlclRoYW4scikpe2lmKHNzKGEoS2UoZS5iaWdnZXJUaGFuLHIpLDQ5KSxuKSlyZXR1cm4gMX1lbHNlIEJuKGUuc21hbGxlclRoYW4scixuZXcgQnIpO2lmKGUub3JkZXJpbmdTdHJhdGVneT09KGZ1KCksSE8pfHwhX3IobiwoSygpLHJyKSl8fCFfcihyLChLKCkscnIpKSl7Zm9yKGY9bnVsbCxfPW5ldyBUKG4ucG9ydHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhfKSwxMiksdS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MHx8YShsZSh1LmluY29taW5nRWRnZXMsMCksMTgpLnNvdXJjZS5vd25lci5sYXllciE9bi5sYXllciYmKGY9YShsZSh1LmluY29taW5nRWRnZXMsMCksMTgpLnNvdXJjZSk7Zm9yKG09bnVsbCxjPW5ldyBUKHIucG9ydHMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxMiksdS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MHx8YShsZSh1LmluY29taW5nRWRnZXMsMCksMTgpLnNvdXJjZS5vd25lci5sYXllciE9ci5sYXllciYmKG09YShsZSh1LmluY29taW5nRWRnZXMsMCksMTgpLnNvdXJjZSk7aWYoZiYmbSl7aWYoZD1mLm93bmVyLGg9bS5vd25lcixkJiZkPT1oKXtmb3IoRT1uZXcgVChkLnBvcnRzKTtFLmk8RS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2lmKHk9YShDKEUpLDEyKSx5PT1mKXJldHVybiBqeShlLHIsbiksLTE7aWYoeT09bSlyZXR1cm4gankoZSxuLHIpLDF9cmV0dXJuIHFvKCQ5KGUsbiksJDkoZSxyKSl9Zm9yKHg9ZS5wcmV2aW91c0xheWVyLEE9MCxrPXgubGVuZ3RoO0E8azsrK0Epe2lmKHY9eFtBXSx2PT1kKXJldHVybiBqeShlLHIsbiksLTE7aWYodj09aClyZXR1cm4gankoZSxuLHIpLDF9fWlmKCFfcihuLChLKCkscnIpKXx8IV9yKHIscnIpKXJldHVybiBvPSQ5KGUsbikscz0kOShlLHIpLG8+cz9qeShlLG4scik6ankoZSxyLG4pLG88cz8tMTpvPnM/MTowfXJldHVybiB0PWEodyhuLChLKCkscnIpKSwxNykudmFsdWVfMCxpPWEodyhyLHJyKSwxNykudmFsdWVfMCx0Pmk/ankoZSxuLHIpOmp5KGUscixuKSx0PGk/LTE6dD5pPzE6MH1mdW5jdGlvbiAkOShlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9YShOUWUoeHkoSm4obmV3IFNlKG51bGwsbmV3IHhlKG4ucG9ydHMsMTYpKSxuZXcgeWJlKSkpLDEyKSx0JiYocj1hKGxlKHQuaW5jb21pbmdFZGdlcywwKSwxOCkscik/YSh3KHIsKEsoKSxycikpLDE3KS52YWx1ZV8wOkExbihlLmxvbmdFZGdlTm9kZU9yZGVyKX1mdW5jdGlvbiBqeShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IodD1hKEtlKGUuYmlnZ2VyVGhhbixuKSw0OSksaT1hKEtlKGUuYmlnZ2VyVGhhbixyKSw0OSksbz1hKEtlKGUuc21hbGxlclRoYW4sbiksNDkpLHM9YShLZShlLnNtYWxsZXJUaGFuLHIpLDQ5KSx0Lm1hcF8wLnB1dChyLHQpLHMubWFwXzAucHV0KG4scyksZD1pLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KV89YShkLm5leHRfMSgpLDEwKSx0Lm1hcF8wLnB1dChfLHQpLFlyKGEoS2UoZS5zbWFsbGVyVGhhbixfKSw0OSksbiksZnQoYShLZShlLnNtYWxsZXJUaGFuLF8pLDQ5KSxvKTtmb3IoYz1vLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDEwKSxzLm1hcF8wLnB1dCh1LHMpLFlyKGEoS2UoZS5iaWdnZXJUaGFuLHUpLDQ5KSxyKSxmdChhKEtlKGUuYmlnZ2VyVGhhbix1KSw0OSksaSl9ZnVuY3Rpb24gZ2JlKGUsbixyKXtoYmUuY2FsbCh0aGlzLG4sciksdGhpcy5wcmV2aW91c0xheWVyPUIoUnUsSWMsMTAsZS5ub2Rlcy5hcnJheS5sZW5ndGgsMCwxKSxJcyhlLm5vZGVzLHRoaXMucHJldmlvdXNMYXllcil9ZnVuY3Rpb24gaGJlKGUsbil7dGhpcy5iaWdnZXJUaGFuPW5ldyBzbix0aGlzLnNtYWxsZXJUaGFuPW5ldyBzbix0aGlzLmxvbmdFZGdlTm9kZU9yZGVyPShaRSgpLE1QKSx0aGlzLm9yZGVyaW5nU3RyYXRlZ3k9ZSx0aGlzLmxvbmdFZGdlTm9kZU9yZGVyPW59ZnVuY3Rpb24gbWJlKGUsbixyKXtoYmUuY2FsbCh0aGlzLG4sciksdGhpcy5wcmV2aW91c0xheWVyPWV9cCg1ODYsMSxObixnYmUsbWJlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBwYmUodGhpcyxhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUucHJlc2VydmVvcmRlciIsIk1vZGVsT3JkZXJOb2RlQ29tcGFyYXRvciIsNTg2KTtmdW5jdGlvbiB5YmUoKXt9cCgxODIxLDEsSW4seWJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEyKS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS5wcmVzZXJ2ZW9yZGVyIiwiTW9kZWxPcmRlck5vZGVDb21wYXJhdG9yL2xhbWJkYSQwJFR5cGUiLDE4MjEpO2Z1bmN0aW9uIHdiZShlKXtlLmJpZ2dlclRoYW49bmV3IHNuLGUuc21hbGxlclRoYW49bmV3IHNufWZ1bmN0aW9uIEViZShlLG4pe3JldHVybiBfcihlLChLKCkscnIpKSYmX3Iobixycik/cW8oYSh3KGUscnIpLDE3KS52YWx1ZV8wLGEodyhuLHJyKSwxNykudmFsdWVfMCk6MH1mdW5jdGlvbiB2YmUoZSxuLHIpe3JldHVybiBTX24oZSxhKG4sMTIpLGEociwxMikpfWZ1bmN0aW9uIFNfbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEE7aWYodD1uLGM9cixlLnBvcnRNb2RlbE9yZGVyJiZ0LnNpZGU9PShyZSgpLGplKSYmYy5zaWRlPT0ocmUoKSxqZSkmJihBPXQsdD1jLGM9QSkseWkoZS5iaWdnZXJUaGFuLHQpKXtpZihzcyhhKEtlKGUuYmlnZ2VyVGhhbix0KSw0OSksYykpcmV0dXJuIDF9ZWxzZSBCbihlLmJpZ2dlclRoYW4sdCxuZXcgQnIpO2lmKHlpKGUuYmlnZ2VyVGhhbixjKSl7aWYoc3MoYShLZShlLmJpZ2dlclRoYW4sYyksNDkpLHQpKXJldHVybi0xfWVsc2UgQm4oZS5iaWdnZXJUaGFuLGMsbmV3IEJyKTtpZih5aShlLnNtYWxsZXJUaGFuLHQpKXtpZihzcyhhKEtlKGUuc21hbGxlclRoYW4sdCksNDkpLGMpKXJldHVybi0xfWVsc2UgQm4oZS5zbWFsbGVyVGhhbix0LG5ldyBCcik7aWYoeWkoZS5zbWFsbGVyVGhhbixjKSl7aWYoc3MoYShLZShlLmJpZ2dlclRoYW4sYyksNDkpLHQpKXJldHVybiAxfWVsc2UgQm4oZS5zbWFsbGVyVGhhbixjLG5ldyBCcik7aWYodC5zaWRlIT1jLnNpZGUpcmV0dXJuIHg9Q19uKHQuc2lkZSxjLnNpZGUpLHg9PS0xP2VsKGUsYyx0KTplbChlLHQsYykseDtpZih0LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wJiZjLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wKXtpZihlLnBvcnRNb2RlbE9yZGVyJiYoeD1FYmUodCxjKSx4IT0wKSlyZXR1cm4geD09LTE/ZWwoZSxjLHQpOng9PTEmJmVsKGUsdCxjKSx4O2lmKGk9YShsZSh0LmluY29taW5nRWRnZXMsMCksMTgpLnNvdXJjZS5vd25lcixkPWEobGUoYy5pbmNvbWluZ0VkZ2VzLDApLDE4KS5zb3VyY2Uub3duZXIsaT09ZClyZXR1cm4gbz1hKHcoYShsZSh0LmluY29taW5nRWRnZXMsMCksMTgpLChLKCkscnIpKSwxNykudmFsdWVfMCxfPWEodyhhKGxlKGMuaW5jb21pbmdFZGdlcywwKSwxOCkscnIpLDE3KS52YWx1ZV8wLG8+Xz9lbChlLHQsYyk6ZWwoZSxjLHQpLG88Xz8tMTpvPl8/MTowO2Zvcih5PWUucHJldmlvdXNMYXllcixFPTAsdj15Lmxlbmd0aDtFPHY7KytFKXtpZihtPXlbRV0sbT09aSlyZXR1cm4gZWwoZSx0LGMpLDE7aWYobT09ZClyZXR1cm4gZWwoZSxjLHQpLC0xfX1yZXR1cm4gdC5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCYmYy5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MD8odT1hKHcodCwoSygpLF9PKSksMTApLGg9YSh3KGMsX08pLDEwKSxlLnN0cmF0ZWd5PT0oZnUoKSxVTykmJnUmJmgmJl9yKHUscnIpJiZfcihoLHJyKT8obz1hKHcodSxyciksMTcpLnZhbHVlXzAsXz1hKHcoaCxyciksMTcpLnZhbHVlXzAsbz5fP2VsKGUsdCxjKTplbChlLGMsdCksbzxfPy0xOm8+Xz8xOjApOmUucG9ydE1vZGVsT3JkZXImJih4PUViZSh0LGMpLHghPTApPyh4PT0tMT9lbChlLGMsdCk6eD09MSYmZWwoZSx0LGMpLHgpOihzPTAsZj0wLF9yKGEobGUodC5vdXRnb2luZ0VkZ2VzLDApLDE4KSxycikmJihzPWEodyhhKGxlKHQub3V0Z29pbmdFZGdlcywwKSwxOCkscnIpLDE3KS52YWx1ZV8wKSxfcihhKGxlKGMub3V0Z29pbmdFZGdlcywwKSwxOCkscnIpJiYoZj1hKHcoYShsZSh0Lm91dGdvaW5nRWRnZXMsMCksMTgpLHJyKSwxNykudmFsdWVfMCksdSYmdT09aD9hZShpZSh3KGEobGUodC5vdXRnb2luZ0VkZ2VzLDApLDE4KSxPcykpKSYmIWFlKGllKHcoYShsZShjLm91dGdvaW5nRWRnZXMsMCksMTgpLE9zKSkpPyhlbChlLHQsYyksMSk6IWFlKGllKHcoYShsZSh0Lm91dGdvaW5nRWRnZXMsMCksMTgpLE9zKSkpJiZhZShpZSh3KGEobGUoYy5vdXRnb2luZ0VkZ2VzLDApLDE4KSxPcykpKT8oZWwoZSxjLHQpLC0xKToocz5mP2VsKGUsdCxjKTplbChlLGMsdCksczxmPy0xOnM+Zj8xOjApOihlLnRhcmdldE5vZGVNb2RlbE9yZGVyJiYoZS50YXJnZXROb2RlTW9kZWxPcmRlci5jb250YWluc0tleSh1KSYmKHM9YShlLnRhcmdldE5vZGVNb2RlbE9yZGVyLmdldF8zKHUpLDE3KS52YWx1ZV8wKSxlLnRhcmdldE5vZGVNb2RlbE9yZGVyLmNvbnRhaW5zS2V5KGgpJiYoZj1hKGUudGFyZ2V0Tm9kZU1vZGVsT3JkZXIuZ2V0XzMoaCksMTcpLnZhbHVlXzApKSxzPmY/ZWwoZSx0LGMpOmVsKGUsYyx0KSxzPGY/LTE6cz5mPzE6MCkpKTp0LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wJiZjLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wPyhlbChlLHQsYyksMSk6dC5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCYmYy5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MD8oZWwoZSxjLHQpLC0xKTpfcih0LChLKCkscnIpKSYmX3IoYyxycik/KG89YSh3KHQscnIpLDE3KS52YWx1ZV8wLF89YSh3KGMscnIpLDE3KS52YWx1ZV8wLG8+Xz9lbChlLHQsYyk6ZWwoZSxjLHQpLG88Xz8tMTpvPl8/MTowKTooZWwoZSxjLHQpLC0xKX1mdW5jdGlvbiBlbChlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IodD1hKEtlKGUuYmlnZ2VyVGhhbixuKSw0OSksaT1hKEtlKGUuYmlnZ2VyVGhhbixyKSw0OSksbz1hKEtlKGUuc21hbGxlclRoYW4sbiksNDkpLHM9YShLZShlLnNtYWxsZXJUaGFuLHIpLDQ5KSx0Lm1hcF8wLnB1dChyLHQpLHMubWFwXzAucHV0KG4scyksZD1pLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KV89YShkLm5leHRfMSgpLDEyKSx0Lm1hcF8wLnB1dChfLHQpLFlyKGEoS2UoZS5zbWFsbGVyVGhhbixfKSw0OSksbiksZnQoYShLZShlLnNtYWxsZXJUaGFuLF8pLDQ5KSxvKTtmb3IoYz1vLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDEyKSxzLm1hcF8wLnB1dCh1LHMpLFlyKGEoS2UoZS5iaWdnZXJUaGFuLHUpLDQ5KSxyKSxmdChhKEtlKGUuYmlnZ2VyVGhhbix1KSw0OSksaSl9ZnVuY3Rpb24gU2JlKGUsbixyLHQpe3diZSh0aGlzKSx0aGlzLnByZXZpb3VzTGF5ZXI9QihSdSxJYywxMCxlLm5vZGVzLmFycmF5Lmxlbmd0aCwwLDEpLHRoaXMuc3RyYXRlZ3k9bixJcyhlLm5vZGVzLHRoaXMucHJldmlvdXNMYXllciksdGhpcy50YXJnZXROb2RlTW9kZWxPcmRlcj1yLHRoaXMucG9ydE1vZGVsT3JkZXI9dH1mdW5jdGlvbiBDYmUoZSxuLHIsdCl7d2JlKHRoaXMpLHRoaXMucHJldmlvdXNMYXllcj1lLHRoaXMuc3RyYXRlZ3k9bix0aGlzLnRhcmdldE5vZGVNb2RlbE9yZGVyPXIsdGhpcy5wb3J0TW9kZWxPcmRlcj10fXAoODIxLDEsTm4sU2JlLENiZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gdmJlKHRoaXMsbixyKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxsLnBvcnRNb2RlbE9yZGVyPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUucHJlc2VydmVvcmRlciIsIk1vZGVsT3JkZXJQb3J0Q29tcGFyYXRvciIsODIxKTtmdW5jdGlvbiBDX24oZSxuKXtyZXR1cm4gcW8oZS5vcmRpbmFsLG4ub3JkaW5hbCl9ZnVuY3Rpb24gdVYoKXt9ZnVuY3Rpb24gVGJlKGUpe3ZhciBuLHI7cmV0dXJuIHI9Uy5NYXRoLnNxcnQoKGUuc3VtV2lkdGg9PW51bGwmJihlLnN1bVdpZHRoPWZWKGUsbmV3IFZiZSkpLFIoZS5zdW1XaWR0aCkvKGUuZGFyKihlLm1heEhlaWdodD09bnVsbCYmKGUubWF4SGVpZ2h0PUdiZShlLG5ldyBoVikpLFIoZS5tYXhIZWlnaHQpKSkpKSxuPVNuKEhvKFMuTWF0aC5yb3VuZChyKSkpLG49Uy5NYXRoLm1pbihuLGUubG9uZ2VzdFBhdGgpLG59cCg4MTUsMSx7fSx1ViksbC5nZXRDdXRJbmRleGVzPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHM7Zm9yKGk9VGJlKHIpLHQ9bmV3IFEscz1yLmxvbmdlc3RQYXRoL2ksbz0xO288aTsrK28pZWUodCxKKFNuKEhvKFMuTWF0aC5yb3VuZChvKnMpKSkpKTtyZXR1cm4gdH0sbC5ndWFyYW50ZWVWYWxpZD1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiQVJEQ3V0SW5kZXhIZXVyaXN0aWMiLDgxNSk7ZnVuY3Rpb24gVF9uKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuO2ZvcihBPW5ldyBwdChlLmxheWVycywwKSxkPW4uaXRlcmF0b3JfMCgpLHk9MCxfPWEoZC5uZXh0XzEoKSwxNykudmFsdWVfMCxIPTAscj1uZXcgQnIsbmU9bmV3IGx1O0EuaTxBLnRoaXMkMDFfMC5zaXplXzEoKTspe2Zvcih4PShybihBLmk8QS50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoQS50aGlzJDAxXzAuZ2V0XzAoQS5sYXN0PUEuaSsrKSwzMCkpLE09bmV3IFQoeC5ub2Rlcyk7TS5pPE0udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Ioaz1hKEMoTSksMTApLG09bmV3IFhlKFFlKFJyKGspLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihtKTspZj1hKHRuKG0pLDE4KSxuZS5tYXBfMC5wdXQoZixuZSk7Zm9yKGg9bmV3IFhlKFFlKHR0KGspLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihoKTspZj1hKHRuKGgpLDE4KSxuZS5tYXBfMC5yZW1vdmVfMChmKSE9bnVsbH1pZih5KzE9PV8pe2ZvcihvPW5ldyBvaShlKSxyZihBLG8pLGk9bmV3IG9pKGUpLHJmKEEsaSksd2U9bmUubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7d2UuaGFzTmV4dF8wKCk7KXZlPWEod2UubmV4dF8xKCksMTgpLHIubWFwXzAuY29udGFpbnNLZXkodmUpfHwoKytILHIubWFwXzAucHV0KHZlLHIpKSxzPW5ldyBhYyhlKSxqKHMsKG9lKCkseHIpLChkdCgpLEF3KSksaHQocyxvKSx6XyhzLChXZSgpLE5zKSksRT1uZXcgWm8sTG8oRSxzKSxYcihFLChyZSgpLGplKSksRGU9bmV3IFpvLExvKERlLHMpLFhyKERlLHFlKSx0PW5ldyBhYyhlKSxqKHQseHIsQXcpLGh0KHQsaSksel8odCxOcyksdj1uZXcgWm8sTG8odix0KSxYcih2LGplKSxGZT1uZXcgWm8sTG8oRmUsdCksWHIoRmUscWUpLHE9bmV3IEgxLEx0KHEsdmUuc291cmNlKSxfdChxLEUpLGoocSwoSygpLHJyKSxhKHcodmUscnIpLDE3KSksam49bmV3IEgxLEx0KGpuLERlKSxfdChqbix2KSxqKGpuLHJyLGEodyh2ZSxyciksMTcpKSxMdCh2ZSxGZSksdT1uZXcgY1Yocyx0LHEsam4sdmUpLGoocyxLMSx1KSxqKHQsSzEsdSksbm49cS5zb3VyY2Uub3duZXIsbm4udHlwZV8wPT1OcyYmKGM9YSh3KG5uLEsxKSwzMTMpLGMubmV4dF8wPXUsdS5wcmV2PWMpO2lmKGQuaGFzTmV4dF8wKCkpXz1hKGQubmV4dF8xKCksMTcpLnZhbHVlXzA7ZWxzZSBicmVha30rK3l9cmV0dXJuIEooSCl9ZnVuY3Rpb24gYl9uKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkO2ZvcihkPUIoaG4sa24sMjgsZS5sYXllcnMuYXJyYXkubGVuZ3RoKzEsMTUsMSksXz1uZXcgQnIsdD0wLGk9bmV3IFQoZS5sYXllcnMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKG89YShDKGkpLDMwKSxkW3QrK109Xy5tYXBfMC5zaXplXzEoKSxjPW5ldyBUKG8ubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocz1hKEMoYyksMTApLHI9bmV3IFhlKFFlKFJyKHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspbj1hKHRuKHIpLDE4KSxfLm1hcF8wLnB1dChuLF8pO2Zvcih1PW5ldyBUKG8ubm9kZXMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocz1hKEModSksMTApLHI9bmV3IFhlKFFlKHR0KHMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspbj1hKHRuKHIpLDE4KSxfLm1hcF8wLnJlbW92ZV8wKG4pIT1udWxsfXJldHVybiBkfWZ1bmN0aW9uIElfbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO2ZvcihoPW5ldyBRLG89bmV3IFEsRT1udWxsLHU9bi5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMTcpLGk9bmV3IExiZShzLnZhbHVlXzApLFJlKG8uYXJyYXksaSksRSYmKGkucHJldj1FLEUuc3VjPWkpLEU9aTtmb3Ioaz1iX24oZSksZD0wO2Q8by5hcnJheS5sZW5ndGg7KytkKXtmb3IobT1udWxsLHY9X1YoKEFlKDAsby5hcnJheS5sZW5ndGgpLGEoby5hcnJheVswXSw2NjEpKSkscj1udWxsLHQ9aHIsZj0xO2Y8ZS5sYXllcnMuYXJyYXkubGVuZ3RoOysrZil4PXY/Uy5NYXRoLmFicyh2LmluZGV4XzAtZik6Uy5NYXRoLmFicyhmLW0uaW5kZXhfMCkrMSx5PW0/Uy5NYXRoLmFicyhmLW0uaW5kZXhfMCk6eCsxLHk8eD8oXz1tLGM9eSk6KF89dixjPXgpLEE9KE09UigkKHcoZSwob2UoKSx2WSkpKSksa1tmXStTLk1hdGgucG93KGMsTSkpLEE8dCYmKHQ9QSxyPV8sci5uZXdJbmRleD1mKSx2JiZmPT12LmluZGV4XzAmJihtPXYsdj1QX24odikpO3ImJihlZShoLEooci5uZXdJbmRleCkpLHIuYXNzaWduZWQ9ITAsTl9uKHIpKX1yZXR1cm4gTmUoKSxYNShoLmFycmF5LGguYXJyYXkubGVuZ3RoLG51bGwpLGh9ZnVuY3Rpb24geF9uKGUsbil7dmFyIHIsdCxvO3N3aXRjaChuLmJlZ2luKCJCcmVha2luZyBQb2ludCBJbnNlcnRpb24iLDEpLHQ9bmV3IHBWKGUpLGEodyhlLChvZSgpLExPKSksMzUxKS5vcmRpbmFsKXtjYXNlIDI6bz1uZXcgbVY7YnJlYWs7Y2FzZSAwOm89bmV3IHVWO2JyZWFrO2RlZmF1bHQ6bz1uZXcgeVZ9aWYocj1vLmdldEN1dEluZGV4ZXMoZSx0KSxhZShpZSh3KGUsU1kpKSkmJihyPUlfbihlLHIpKSwhby5ndWFyYW50ZWVWYWxpZCgpJiZfcihlLEFQKSlzd2l0Y2goYSh3KGUsQVApLDM1Mikub3JkaW5hbCl7Y2FzZSAyOnI9SmJlKHQscik7YnJlYWs7Y2FzZSAxOnI9WGJlKHQscil9aWYoci5pc0VtcHR5KCkpe24uZG9uZV8xKCk7cmV0dXJufVRfbihlLHIpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gYmJlKCl7fXAoMTU0NCwxLHNyLGJiZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7eF9uKGEobiwzNikscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUud3JhcHBpbmciLCJCcmVha2luZ1BvaW50SW5zZXJ0ZXIiLDE1NDQpO2Z1bmN0aW9uIGNWKGUsbixyLHQsbyl7dGhpcy5zdGFydF8wPWUsdGhpcy5lbmQ9bix0aGlzLm5vZGVTdGFydEVkZ2U9cix0aGlzLnN0YXJ0RW5kRWRnZT10LHRoaXMub3JpZ2luYWxFZGdlPW99ZnVuY3Rpb24gSWJlKGUpe3ZhciBuO3JldHVybiBuPWEodyhlLChLKCksSzEpKSwzMTMpLG4/bi5lbmQ9PWU6ITF9ZnVuY3Rpb24geGJlKGUpe3ZhciBuO3JldHVybiBuPWEodyhlLChLKCksSzEpKSwzMTMpLG4/bi5zdGFydF8wPT1lOiExfXAoMzEzLDEsezMxMzoxfSxjViksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IEMwLG4uc3RyaW5nKz0iQlBJbmZvWyIsbi5zdHJpbmcrPWAKCXN0YXJ0PWAsZWkobix0aGlzLnN0YXJ0XzApLG4uc3RyaW5nKz1gCgllbmQ9YCxlaShuLHRoaXMuZW5kKSxuLnN0cmluZys9YAoJbm9kZVN0YXJ0RWRnZT1gLGVpKG4sdGhpcy5ub2RlU3RhcnRFZGdlKSxuLnN0cmluZys9YAoJc3RhcnRFbmRFZGdlPWAsZWkobix0aGlzLnN0YXJ0RW5kRWRnZSksbi5zdHJpbmcrPWAKCW9yaWdpbmFsRWRnZT1gLGVpKG4sdGhpcy5vcmlnaW5hbEVkZ2UpLG4uc3RyaW5nKz1gCglzdGFydEluTGF5ZXJEdW1teT1gLGVpKG4sdGhpcy5zdGFydEluTGF5ZXJEdW1teSksbi5zdHJpbmcrPWAKCXN0YXJ0SW5MYXllckVkZ2U9YCxlaShuLHRoaXMuc3RhcnRJbkxheWVyRWRnZSksbi5zdHJpbmcrPWAKCWVuZEluTGF5ZXJEdW1teT1gLGVpKG4sdGhpcy5lbmRJbkxheWVyRHVtbXkpLG4uc3RyaW5nKz1gCgllbmRJbkxheWVyRWRnZT1gLGVpKG4sdGhpcy5lbmRJbkxheWVyRWRnZSksbi5zdHJpbmd9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUud3JhcHBpbmciLCJCcmVha2luZ1BvaW50SW5zZXJ0ZXIvQlBJbmZvIiwzMTMpO2Z1bmN0aW9uIFBfbihlKXtyZXR1cm4gZS5zdWM/X1YoZS5zdWMpOm51bGx9ZnVuY3Rpb24gTl9uKGUpe3ZhciBuO2lmKCFlLmFzc2lnbmVkKXRocm93IGIobmV3IHJvKCJDYW5ub3Qgb2Zmc2V0IGFuIHVuYXNzaWduZWQgY3V0LiIpKTtuPWUubmV3SW5kZXgtZS5pbmRleF8wLGUuaW5kZXhfMCs9bixOYmUoZSxuKSxBYmUoZSxuKX1mdW5jdGlvbiBQYmUoZSxuKXtlLmluZGV4XzArPW59ZnVuY3Rpb24gTmJlKGUsbil7ZS5wcmV2JiYhZS5wcmV2LmFzc2lnbmVkJiYoUGJlKGUucHJldixuKSxOYmUoZS5wcmV2LG4pKX1mdW5jdGlvbiBBYmUoZSxuKXtlLnN1YyYmIWUuc3VjLmFzc2lnbmVkJiYoUGJlKGUuc3VjLG4pLEFiZShlLnN1YyxuKSl9ZnVuY3Rpb24gX1YoZSl7aWYoZS5hc3NpZ25lZCl7aWYoZS5zdWMpcmV0dXJuIF9WKGUuc3VjKX1lbHNlIHJldHVybiBlO3JldHVybiBudWxsfWZ1bmN0aW9uIExiZShlKXt0aGlzLmluZGV4XzA9ZX1wKDY2MSwxLHs2NjE6MX0sTGJlKSxsLmFzc2lnbmVkPSExLGwuaW5kZXhfMD0wLGwubmV3SW5kZXg9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiQnJlYWtpbmdQb2ludEluc2VydGVyL0N1dCIsNjYxKTtmdW5jdGlvbiBrYmUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2ZvcihjPUI5KGUsciksXz1COShuLHIpLG89ITE7YyYmXyYmKHR8fExfbihjLF8scikpOylzPUI5KGMsciksdT1COShfLHIpLHYzKG4pLHYzKGUpLGk9Yy5sYXllcixoOShjLCExKSxoOShfLCExKSxyPyh3ZihuLF8uaWRfMCxpKSxuLmlkXzA9Xy5pZF8wLHdmKGUsYy5pZF8wKzEsaSksZS5pZF8wPWMuaWRfMCk6KHdmKGUsYy5pZF8wLGkpLGUuaWRfMD1jLmlkXzAsd2YobixfLmlkXzArMSxpKSxuLmlkXzA9Xy5pZF8wKSxodChjLG51bGwpLGh0KF8sbnVsbCksYz1zLF89dSxvPSEwO3JldHVybiBvfWZ1bmN0aW9uIEFfbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihvPW5ldyBUKGUubGF5ZXJzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9YShDKG8pLDMwKSxzPW5ldyBUKHYxKHQubm9kZXMpKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoaT1hKEMocyksMTApLHhiZShpKSYmKHI9YSh3KGksKEsoKSxLMSkpLDMxMyksIXIucHJldiYmci5uZXh0XzApKWZvcihuPXIsYz1yLm5leHRfMDtjOylrYmUoYy5zdGFydF8wLGMuc3RhcnRJbkxheWVyRHVtbXksITEsITApLHYzKG4uZW5kKSx2MyhjLnN0YXJ0XzApLHYzKGMuc3RhcnRJbkxheWVyRHVtbXkpLHYzKGMuZW5kSW5MYXllckR1bW15KSxfdChjLmVuZEluTGF5ZXJFZGdlLG4uZW5kSW5MYXllckVkZ2UudGFyZ2V0KSxfdChuLmVuZEluTGF5ZXJFZGdlLG51bGwpLGh0KG4uZW5kLG51bGwpLGh0KGMuc3RhcnRfMCxudWxsKSxodChjLnN0YXJ0SW5MYXllckR1bW15LG51bGwpLGh0KGMuZW5kSW5MYXllckR1bW15LG51bGwpLHU9bmV3IGNWKG4uc3RhcnRfMCxjLmVuZCxuLm5vZGVTdGFydEVkZ2UsYy5zdGFydEVuZEVkZ2UsYy5vcmlnaW5hbEVkZ2UpLHUuc3RhcnRJbkxheWVyRHVtbXk9bi5zdGFydEluTGF5ZXJEdW1teSx1LnN0YXJ0SW5MYXllckVkZ2U9bi5zdGFydEluTGF5ZXJFZGdlLHUuZW5kSW5MYXllckR1bW15PW4uZW5kSW5MYXllckR1bW15LHUuZW5kSW5MYXllckVkZ2U9Yy5lbmRJbkxheWVyRWRnZSx1LnByZXY9bi5wcmV2LHUubmV4dF8wPWMubmV4dF8wLGoobi5zdGFydF8wLEsxLHUpLGooYy5lbmQsSzEsdSksYz1jLm5leHRfMCxuPXV9ZnVuY3Rpb24gT2JlKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtvPW4/bmV3IFJiZTpuZXcgRGJlLGk9ITE7ZG8gZm9yKGk9ITEsXz1uP3FhKGUubGF5ZXJzKTplLmxheWVycyxjPV8uaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KWZvcih1PWEoYy5uZXh0XzEoKSwzMCksaD12MSh1Lm5vZGVzKSxufHxxYShoKSxmPW5ldyBUKGgpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkPWEoQyhmKSwxMCksby50ZXN0XzAoZCkmJih0PWQscj1hKHcoZCwoSygpLEsxKSksMzEzKSxzPW4/ci5lbmRJbkxheWVyRHVtbXk6ci5zdGFydEluTGF5ZXJEdW1teSxpPWtiZSh0LHMsbiwhMSkpO3doaWxlKGkpfWZ1bmN0aW9uIExfbihlLG4scil7dmFyIHQsbyxpLHMsdTtmb3IoaT1lLmxheWVyLHU9cj9uOmUsdD1yP2U6bixvPXUuaWRfMCsxO288dC5pZF8wOysrbylpZihzPWEobGUoaS5ub2RlcyxvKSwxMCksIShzLnR5cGVfMD09KFdlKCksTnMpfHxrX24ocykpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGtfbihlKXt2YXIgbixyO2lmKGUudHlwZV8wPT0oV2UoKSxpdCkpe2ZvcihyPW5ldyBYZShRZShpYyhlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocik7KWlmKG49YSh0bihyKSwxOCksIXp0KG4pJiZlLmxheWVyPT1UVyhuLGUpLmxheWVyKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIEI5KGUsbil7dmFyIHIsdCxvLGk7Zm9yKG89bj9ScihlKTp0dChlKSx0PW5ldyBYZShRZShvLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspaWYocj1hKHRuKHQpLDE4KSxpPVRXKHIsZSksaS50eXBlXzA9PShXZSgpLGl0KSYmaS5sYXllciE9ZS5sYXllcilyZXR1cm4gaTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBPX24oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKGY9ZS5sYXllcnMsZD1uZXcgcHQoZiwwKSxyZihkLG5ldyBvaShlKSksQT0hMSxzPTE7ZC5pPGQudGhpcyQwMV8wLnNpemVfMSgpOyl7Zm9yKF89KHJuKGQuaTxkLnRoaXMkMDFfMC5zaXplXzEoKSksYShkLnRoaXMkMDFfMC5nZXRfMChkLmxhc3Q9ZC5pKyspLDMwKSksRT0oQWUocyxmLmFycmF5Lmxlbmd0aCksYShmLmFycmF5W3NdLDMwKSksdj12MShfLm5vZGVzKSx4PXYuYXJyYXkubGVuZ3RoLHk9bmV3IFQodik7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWg9YShDKHkpLDEwKSxodChoLEUpO2lmKEEpe2ZvcihtPXFhKHYpLml0ZXJhdG9yXzAoKTttLmhhc05leHRfMCgpOylmb3IoaD1hKG0ubmV4dF8xKCksMTApLGk9bmV3IFQodjEodHQoaCkpKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTgpLEcxKG8sITApLGooZSwoSygpLE4zKSwoemUoKSwhMCkpLHQ9QmJlKGUsbyx4KSxyPWEodyhoLEsxKSwzMTMpLGs9YShsZSh0LHQuYXJyYXkubGVuZ3RoLTEpLDE4KSxyLnN0YXJ0SW5MYXllckR1bW15PWsuc291cmNlLm93bmVyLHIuc3RhcnRJbkxheWVyRWRnZT1rLHIuZW5kSW5MYXllckR1bW15PW8udGFyZ2V0Lm93bmVyLHIuZW5kSW5MYXllckVkZ2U9bztBPSExfWVsc2Ugdi5hcnJheS5sZW5ndGghPTAmJihuPShBZSgwLHYuYXJyYXkubGVuZ3RoKSxhKHYuYXJyYXlbMF0sMTApKSxuLnR5cGVfMD09KFdlKCksTnMpJiYoQT0hMCxzPS0xKSk7KytzfWZvcih1PW5ldyBwdChlLmxheWVycywwKTt1Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCk7KWM9KHJuKHUuaTx1LnRoaXMkMDFfMC5zaXplXzEoKSksYSh1LnRoaXMkMDFfMC5nZXRfMCh1Lmxhc3Q9dS5pKyspLDMwKSksYy5ub2Rlcy5hcnJheS5sZW5ndGg9PTAmJkVhKHUpfWZ1bmN0aW9uIE1fbihlLG4pe3ZhciByLHQsbyxpLHM7aWYobi5iZWdpbigiQnJlYWtpbmcgUG9pbnQgUHJvY2Vzc29yIiwxKSxPX24oZSksYWUoaWUodyhlLChvZSgpLENZKSkpKSl7Zm9yKG89bmV3IFQoZS5sYXllcnMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksMzApLHI9MCxzPW5ldyBUKHQubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMCksaS5pZF8wPXIrKztBX24oZSksT2JlKGUsITApLE9iZShlLCExKX1uLmRvbmVfMSgpfWZ1bmN0aW9uIHYzKGUpe3ZhciBuO2ZvcihuPWUuaWRfMCsxO248ZS5sYXllci5ub2Rlcy5hcnJheS5sZW5ndGg7KytuKS0tYShsZShlLmxheWVyLm5vZGVzLG4pLDEwKS5pZF8wfWZ1bmN0aW9uIE1iZSgpe31wKDE1NDUsMSxzcixNYmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe01fbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiQnJlYWtpbmdQb2ludFByb2Nlc3NvciIsMTU0NSk7ZnVuY3Rpb24gUmJlKCl7fXAoMTU0NiwxLEluLFJiZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIEliZShhKG4sMTApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkJyZWFraW5nUG9pbnRQcm9jZXNzb3IvMG1ldGhvZHJlZiRpc0VuZCRUeXBlIiwxNTQ2KTtmdW5jdGlvbiBEYmUoKXt9cCgxNTQ3LDEsSW4sRGJlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4geGJlKGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiQnJlYWtpbmdQb2ludFByb2Nlc3Nvci8xbWV0aG9kcmVmJGlzU3RhcnQkVHlwZSIsMTU0Nyk7ZnVuY3Rpb24gZFYoZSxuKXtyZXR1cm4gbj9mdChlLG4pOiExfWZ1bmN0aW9uIFJfbihlLG4scil7dmFyIHQsbyxpLHMsdTtmb3Ioci5iZWdpbigiQnJlYWtpbmcgUG9pbnQgUmVtb3ZpbmciLDEpLGUuZWRnZVJvdXRpbmc9YSh3KG4sKG9lKCksdWMpKSwyMjMpLGk9bmV3IFQobi5sYXllcnMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksMzApLHU9bmV3IFQodjEoby5ub2RlcykpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwxMCksSWJlKHMpJiYodD1hKHcocywoSygpLEsxKSksMzEzKSwhdC5uZXh0XzAmJkZiZShlLHQpKTtyLmRvbmVfMSgpfWZ1bmN0aW9uIEZiZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O3N3aXRjaChkPW5ldyBqaSxlLmVkZ2VSb3V0aW5nLm9yZGluYWwpe2Nhc2UgMzpoPWEodyhuLm5vZGVTdGFydEVkZ2UsKEsoKSxHXykpLDE1KSxtPWEodyhuLnN0YXJ0RW5kRWRnZSxHXyksMTUpLHk9YSh3KG4ub3JpZ2luYWxFZGdlLEdfKSwxNSkscj1hKHcobi5ub2RlU3RhcnRFZGdlLG5nKSwxNSksdD1hKHcobi5zdGFydEVuZEVkZ2UsbmcpLDE1KSxvPWEodyhuLm9yaWdpbmFsRWRnZSxuZyksMTUpLHM9bmV3IFEscXIocyxoKSxtLmZvckVhY2hfMChuZXcgJGJlKSxxcihzLHFhKG0pKSxxcihzLHkpLGk9bmV3IFEscXIoaSxyKSxxcihpLHFhKHQpKSxxcihpLG8pLGoobi5vcmlnaW5hbEVkZ2UsR18scyksaihuLm9yaWdpbmFsRWRnZSxuZyxpKSxqKG4ub3JpZ2luYWxFZGdlLGFxLG4ub3JpZ2luYWxFZGdlKSxqKG4ubm9kZVN0YXJ0RWRnZSxHXyxudWxsKSxqKG4ubm9kZVN0YXJ0RWRnZSxuZyxudWxsKSxqKG4uc3RhcnRFbmRFZGdlLEdfLG51bGwpLGoobi5zdGFydEVuZEVkZ2UsbmcsbnVsbCk7YnJlYWs7Y2FzZSAxOmZ0KGQsbi5ub2RlU3RhcnRFZGdlLmJlbmRQb2ludHMpLExuKGQsbi5zdGFydF8wLnBvcyksZnQoZCxxYShuLnN0YXJ0RW5kRWRnZS5iZW5kUG9pbnRzKSksTG4oZCxuLmVuZC5wb3MpLGZ0KGQsbi5vcmlnaW5hbEVkZ2UuYmVuZFBvaW50cyk7YnJlYWs7ZGVmYXVsdDpmdChkLG4ubm9kZVN0YXJ0RWRnZS5iZW5kUG9pbnRzKSxmdChkLHFhKG4uc3RhcnRFbmRFZGdlLmJlbmRQb2ludHMpKSxmdChkLG4ub3JpZ2luYWxFZGdlLmJlbmRQb2ludHMpfWthKG4ub3JpZ2luYWxFZGdlLmJlbmRQb2ludHMpLGZ0KG4ub3JpZ2luYWxFZGdlLmJlbmRQb2ludHMsZCksTHQobi5vcmlnaW5hbEVkZ2Usbi5ub2RlU3RhcnRFZGdlLnNvdXJjZSksdT1hKHcobi5ub2RlU3RhcnRFZGdlLChvZSgpLGlvKSksNzUpLF89YSh3KG4uc3RhcnRFbmRFZGdlLGlvKSw3NSksYz1hKHcobi5vcmlnaW5hbEVkZ2UsaW8pLDc1KSwodXx8X3x8YykmJihmPW5ldyBqaSxkVihmLGMpLGRWKGYsXyksZFYoZix1KSxqKG4ub3JpZ2luYWxFZGdlLGlvLGYpKSxMdChuLnN0YXJ0RW5kRWRnZSxudWxsKSxfdChuLnN0YXJ0RW5kRWRnZSxudWxsKSxMdChuLm5vZGVTdGFydEVkZ2UsbnVsbCksX3Qobi5ub2RlU3RhcnRFZGdlLG51bGwpLGh0KG4uZW5kLG51bGwpLGh0KG4uc3RhcnRfMCxudWxsKSxuLnByZXYmJkZiZShlLG4ucHJldil9ZnVuY3Rpb24gemJlKCl7fXAoMTU0OCwxLHNyLHpiZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7Ul9uKHRoaXMsYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkJyZWFraW5nUG9pbnRSZW1vdmVyIiwxNTQ4KTtmdW5jdGlvbiAkYmUoKXt9cCgxNTQ5LDEsSmUsJGJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXthKG4sMTMxKS5pbnZlcnNlT3JkZXI9ITB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUud3JhcHBpbmciLCJCcmVha2luZ1BvaW50UmVtb3Zlci9sYW1iZGEkMCRUeXBlIiwxNTQ5KTtmdW5jdGlvbiBCYmUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTTtmb3IoZD1SKCQodyhlLChvZSgpLHRkKSkpKSx0PVIoJCh3KGUsbVkpKSksaD1uZXcgYlIsaihoLHRkLGQrdCksXz1uLHg9Xy50YXJnZXQsRT1fLnNvdXJjZS5vd25lcixBPV8udGFyZ2V0Lm93bmVyLHY9SlcoRS5sYXllciksaz1KVyhBLmxheWVyKSxvPW5ldyBRLGY9djtmPD1rO2YrKyl1PW5ldyBhYyhlKSx6Xyh1LChXZSgpLGl0KSksaih1LChLKCksUW4pLF8pLGoodSx4ciwoZHQoKSxhaSkpLGoodSxOUCxoKSxtPWEobGUoZS5sYXllcnMsZiksMzApLGY9PXY/d2YodSxtLm5vZGVzLmFycmF5Lmxlbmd0aC1yLG0pOmh0KHUsbSksTT1SKCQodyhfLFVjKSkpLE08MCYmKE09MCxqKF8sVWMsTSkpLHUuc2l6ZV8wLnlfMD1NLHk9Uy5NYXRoLmZsb29yKE0vMikscz1uZXcgWm8sWHIocywocmUoKSxqZSkpLExvKHMsdSkscy5wb3MueV8wPXksYz1uZXcgWm8sWHIoYyxxZSksTG8oYyx1KSxjLnBvcy55XzA9eSxfdChfLHMpLGk9bmV3IEgxLGdvKGksXyksaihpLGlvLG51bGwpLEx0KGksYyksX3QoaSx4KSxEX24odSxfLGkpLFJlKG8uYXJyYXksaSksXz1pO3JldHVybiBvfWZ1bmN0aW9uIERfbihlLG4scil7dmFyIHQ7dD1uLnNvdXJjZS5vd25lcix0LnR5cGVfMD09KFdlKCksaXQpPyhqKGUsKEsoKSxkcyksYSh3KHQsZHMpLDEyKSksaihlLHZsLGEodyh0LHZsKSwxMikpKTooaihlLChLKCksZHMpLG4uc291cmNlKSxqKGUsdmwsci50YXJnZXQpKX1mdW5jdGlvbiBHYmUoZSxuKXtyZXR1cm4gUigkKHZhKEdDKHBvKG5ldyBTZShudWxsLG5ldyB4ZShlLmdyYXBoXzAubGF5ZXJzLDE2KSksbmV3IFliZShlKSksbikpKSl9ZnVuY3Rpb24gSGJlKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKG89MCxzPW5ldyBUKG4ubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaT1hKEMocyksMTApLG8rPWkuc2l6ZV8wLnlfMCtpLm1hcmdpbi5ib3R0b20raS5tYXJnaW4udG9wXzArZS5pbkxheWVyU3BhY2luZyx0PW5ldyBYZShRZSh0dChpKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXI9YSh0bih0KSwxOCksci5zb3VyY2Uub3duZXIudHlwZV8wPT0oV2UoKSx0aSkmJihjPXIuc291cmNlLm93bmVyLHU9YSh3KGMsKEsoKSxRbikpLDEwKSxvKz11LnNpemVfMC55XzArdS5tYXJnaW4uYm90dG9tK3UubWFyZ2luLnRvcF8wKTtyZXR1cm4gb31mdW5jdGlvbiBVYmUoZSxuKXt2YXIgcix0LG8saTtmb3Iocj0wLG89bmV3IFQobi5ub2Rlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDEwKSxpPXQuc2l6ZV8wLnhfMCt0Lm1hcmdpbi5yaWdodCt0Lm1hcmdpbi5sZWZ0K2Uuc3BhY2luZyxyPVMuTWF0aC5tYXgocixpKTtyZXR1cm4gcn1mdW5jdGlvbiBmVihlLG4pe3JldHVybiBSKCQodmEoR0MocG8obmV3IFNlKG51bGwsbmV3IHhlKGUuZ3JhcGhfMC5sYXllcnMsMTYpKSxuZXcgcWJlKGUpKSxuKSkpKX1mdW5jdGlvbiBXYmUoZSl7dmFyIG4scix0LG8saSxzO2lmKGUuY3V0c0FsbG93ZWQ9PW51bGwpaWYoZS5jdXRzQWxsb3dlZD1CKHlhLHh1LDI4LGUuZ3JhcGhfMC5sYXllcnMuYXJyYXkubGVuZ3RoLDE2LDEpLGUuY3V0c0FsbG93ZWRbMF09ITEsX3IoZS5ncmFwaF8wLChvZSgpLGtPKSkpZm9yKHQ9YSh3KGUuZ3JhcGhfMCxrTyksMTUpLHI9dC5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspbj1hKHIubmV4dF8xKCksMTcpLnZhbHVlXzAsbj4wJiZuPGUuY3V0c0FsbG93ZWQubGVuZ3RoJiYoZS5jdXRzQWxsb3dlZFtuXT0hMSk7ZWxzZSBmb3Iocz1uZXcgVChlLmdyYXBoXzAubGF5ZXJzKSxzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aCYmQyhzKSxvPTE7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDMwKSxlLmN1dHNBbGxvd2VkW28rK109el9uKGkpfWZ1bmN0aW9uIGpiZShlKXt2YXIgbixyLHQ7Zm9yKHQ9ZS5sb25nZXN0UGF0aCxlLndpZHRocz1CKGN0LFh0LDI4LHQsMTUsMSksZS5oZWlnaHRzPUIoY3QsWHQsMjgsdCwxNSwxKSxuPTA7bjx0O24rKylyPWEobGUoZS5ncmFwaF8wLmxheWVycyxuKSwzMCksZS53aWR0aHNbbl09VWJlKGUsciksZS5oZWlnaHRzW25dPUhiZShlLHIpfWZ1bmN0aW9uIEZfbihlLG4pe3JldHVybiBlLmN1dHNBbGxvd2VkPT1udWxsJiZXYmUoZSksZS5jdXRzQWxsb3dlZFtuXX1mdW5jdGlvbiB6X24oZSl7dmFyIG4scix0LG8saSxzLHUsYztuPSEwLG89bnVsbCxpPW51bGw7ZTpmb3IoYz1uZXcgVChlLm5vZGVzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHU9YShDKGMpLDEwKSx0PW5ldyBYZShRZSh0dCh1KS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXtpZihyPWEodG4odCksMTgpLG8mJm8hPXUpe249ITE7YnJlYWsgZX1pZihvPXUscz1yLnNvdXJjZS5vd25lcixpJiZpIT1zKXtuPSExO2JyZWFrIGV9aT1zfXJldHVybiBufWZ1bmN0aW9uIHBWKGUpe3ZhciBuLHIsdDt0aGlzLmdyYXBoXzA9ZSx0PWEodyhlLChvZSgpLE9hKSksODgpLG49UigkKHcoZSxnUCkpKSxyPVIoJCh3KGUseVkpKSksdD09KFdyKCksYW8pfHx0PT1tb3x8dD09QnM/dGhpcy5kYXI9bipyOnRoaXMuZGFyPTEvKG4qciksdGhpcy5zcGFjaW5nPVIoJCh3KGUsb2cpKSksdGhpcy5pbkxheWVyU3BhY2luZz1SKCQodyhlLG9kKSkpLHRoaXMubG9uZ2VzdFBhdGg9ZS5sYXllcnMuYXJyYXkubGVuZ3RofWZ1bmN0aW9uICRfbihlLG4pe3JldHVybiBWZShlKSxlKyhWZShuKSxuKX1wKDgxMSwxLHt9LHBWKSxsLmRhcj0wLGwuaW5MYXllclNwYWNpbmc9MCxsLmxvbmdlc3RQYXRoPTAsbC5zcGFjaW5nPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkdyYXBoU3RhdHMiLDgxMSk7ZnVuY3Rpb24gZ1YoKXt9cCg4MTIsMSx7fSxnViksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIFMuTWF0aC5tYXgoUigkKG4pKSxSKCQocikpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkdyYXBoU3RhdHMvMG1ldGhvZHJlZiRtYXgkVHlwZSIsODEyKTtmdW5jdGlvbiBoVigpe31wKDgxMywxLHt9LGhWKSxsLmFwcGx5XzM9ZnVuY3Rpb24obixyKXtyZXR1cm4gUy5NYXRoLm1heChSKCQobikpLFIoJChyKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiR3JhcGhTdGF0cy8ybWV0aG9kcmVmJG1heCRUeXBlIiw4MTMpO2Z1bmN0aW9uIFZiZSgpe31wKDE3MjYsMSx7fSxWYmUpLGwuYXBwbHlfMz1mdW5jdGlvbihuLHIpe3JldHVybiAkX24oJChuKSwkKHIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkdyYXBoU3RhdHMvbGFtYmRhJDEkVHlwZSIsMTcyNik7ZnVuY3Rpb24gcWJlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNzI3LDEse30scWJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIFViZSh0aGlzLiQkb3V0ZXJfMCxhKG4sMzApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkdyYXBoU3RhdHMvbGFtYmRhJDIkVHlwZSIsMTcyNyk7ZnVuY3Rpb24gWWJlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNzI4LDEse30sWWJlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEhiZSh0aGlzLiQkb3V0ZXJfMCxhKG4sMzApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIkdyYXBoU3RhdHMvbGFtYmRhJDYkVHlwZSIsMTcyOCk7ZnVuY3Rpb24gbVYoKXt9cCg4MTQsMSx7fSxtViksbC5nZXRDdXRJbmRleGVzPWZ1bmN0aW9uKG4scil7dmFyIHQ7cmV0dXJuIHQ9YSh3KG4sKG9lKCksd1kpKSwxNSksdHx8KE5lKCksTmUoKSxPdCl9LGwuZ3VhcmFudGVlVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLmludGVybWVkaWF0ZS53cmFwcGluZyIsIklDdXRJbmRleENhbGN1bGF0b3IvTWFudWFsQ3V0SW5kZXhDYWxjdWxhdG9yIiw4MTQpO2Z1bmN0aW9uIHlWKCl7fXAoODE2LDEse30seVYpLGwuZ2V0Q3V0SW5kZXhlcz1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxIO2ZvcihIPShyLndpZHRocz09bnVsbCYmamJlKHIpLHIud2lkdGhzKSxfPShyLmhlaWdodHM9PW51bGwmJmpiZShyKSxyLmhlaWdodHMpLE09QihjdCxYdCwyOCxILmxlbmd0aCwxNSwxKSxNWzBdPUhbMF0sQT1IWzBdLGQ9MTtkPEgubGVuZ3RoO2QrKylNW2RdPU1bZC0xXStIW2RdLEErPUhbZF07Zm9yKGk9VGJlKHIpLTEsdT1hKHcobiwob2UoKSxFWSkpLDE3KS52YWx1ZV8wLG89VnIsdD1uZXcgUSxtPVMuTWF0aC5tYXgoMCxpLXUpO208PVMuTWF0aC5taW4oci5sb25nZXN0UGF0aC0xLGkrdSk7bSsrKXtpZih2PUEvKG0rMSkseD0wLGY9MSxzPW5ldyBRLGs9VnIsaD0wLGM9MCxFPV9bMF0sbT09MClrPUEsYz0oci5tYXhIZWlnaHQ9PW51bGwmJihyLm1heEhlaWdodD1HYmUocixuZXcgaFYpKSxSKHIubWF4SGVpZ2h0KSk7ZWxzZXtmb3IoO2Y8ci5sb25nZXN0UGF0aDspTVtmLTFdLXg+PXYmJihlZShzLEooZikpLGs9Uy5NYXRoLm1heChrLE1bZi0xXS1oKSxjKz1FLHgrPU1bZi0xXS14LGg9TVtmLTFdLEU9X1tmXSksRT1TLk1hdGgubWF4KEUsX1tmXSksKytmO2MrPUV9eT1TLk1hdGgubWluKDEvaywxL3IuZGFyL2MpLHk+byYmKG89eSx0PXMpfXJldHVybiB0fSxsLmd1YXJhbnRlZVZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5pbnRlcm1lZGlhdGUud3JhcHBpbmciLCJNU0RDdXRJbmRleEhldXJpc3RpYyIsODE2KTtmdW5jdGlvbiBCX24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7aWYoIXIuaXNFbXB0eSgpKXtmb3IodT0wLGg9MCx0PXIuaXRlcmF0b3JfMCgpLHk9YSh0Lm5leHRfMSgpLDE3KS52YWx1ZV8wO3U8bi5sb25nZXN0UGF0aDspe2lmKHU9PXkmJihoPTAsdC5oYXNOZXh0XzAoKT95PWEodC5uZXh0XzEoKSwxNykudmFsdWVfMDp5PW4ubG9uZ2VzdFBhdGgrMSksdSE9aCl7Zm9yKHY9YShsZShlLmxheWVycyx1KSwzMCksbT1hKGxlKGUubGF5ZXJzLGgpLDMwKSxFPXYxKHYubm9kZXMpLGY9bmV3IFQoRSk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKGQ9YShDKGYpLDEwKSx3ZihkLG0ubm9kZXMuYXJyYXkubGVuZ3RoLG0pLGg9PTApZm9yKHM9djEodHQoZCkpLGk9bmV3IFQocyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDE4KSxHMShvLCEwKSxqKGUsKEsoKSxOMyksKHplKCksITApKSxCYmUoZSxvLDEpfSsraCwrK3V9Zm9yKGM9bmV3IHB0KGUubGF5ZXJzLDApO2MuaTxjLnRoaXMkMDFfMC5zaXplXzEoKTspXz0ocm4oYy5pPGMudGhpcyQwMV8wLnNpemVfMSgpKSxhKGMudGhpcyQwMV8wLmdldF8wKGMubGFzdD1jLmkrKyksMzApKSxfLm5vZGVzLmFycmF5Lmxlbmd0aD09MCYmRWEoYyl9fWZ1bmN0aW9uIEdfbihlLG4pe3ZhciByLHQsbyxpLHM7aWYobi5iZWdpbigiUGF0aC1MaWtlIEdyYXBoIFdyYXBwaW5nIiwxKSxlLmxheWVycy5hcnJheS5sZW5ndGg9PTApe24uZG9uZV8xKCk7cmV0dXJufWlmKG89bmV3IHBWKGUpLHM9KG8ubWF4V2lkdGg9PW51bGwmJihvLm1heFdpZHRoPWZWKG8sbmV3IGdWKSksUihvLm1heFdpZHRoKSpvLmxvbmdlc3RQYXRoKSxyPXMvKG8ubWF4V2lkdGg9PW51bGwmJihvLm1heFdpZHRoPWZWKG8sbmV3IGdWKSksUihvLm1heFdpZHRoKSksby5kYXI+cil7bi5kb25lXzEoKTtyZXR1cm59c3dpdGNoKGEodyhlLChvZSgpLExPKSksMzUxKS5vcmRpbmFsKXtjYXNlIDI6aT1uZXcgbVY7YnJlYWs7Y2FzZSAwOmk9bmV3IHVWO2JyZWFrO2RlZmF1bHQ6aT1uZXcgeVZ9aWYodD1pLmdldEN1dEluZGV4ZXMoZSxvKSwhaS5ndWFyYW50ZWVWYWxpZCgpKXN3aXRjaChhKHcoZSxBUCksMzUyKS5vcmRpbmFsKXtjYXNlIDI6dD1KYmUobyx0KTticmVhaztjYXNlIDE6dD1YYmUobyx0KX1CX24oZSxvLHQpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gS2JlKCl7fWZ1bmN0aW9uIFhiZShlLG4pe3ZhciByLHQsbyxpO2ZvcihpPW5ldyBRLG89MCx0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXtmb3Iocj1KKGEodC5uZXh0XzEoKSwxNykudmFsdWVfMCtvKTtyLnZhbHVlXzA8ZS5sb25nZXN0UGF0aCYmIUZfbihlLHIudmFsdWVfMCk7KXI9SihyLnZhbHVlXzArMSksKytvO2lmKHIudmFsdWVfMD49ZS5sb25nZXN0UGF0aClicmVhaztSZShpLmFycmF5LHIpfXJldHVybiBpfWZ1bmN0aW9uIEhfbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87Zm9yKHM9bmV3IFEsdT0wLHI9MCxjPTA7dTxuLmFycmF5Lmxlbmd0aC0xJiZyPGUuc2l6ZV8xKCk7KXtmb3IodD1hKGUuZ2V0XzAociksMTcpLnZhbHVlXzArYzsoQWUodSsxLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbdSsxXSwxNykpLnZhbHVlXzA8dDspKyt1O2ZvcihfPTAsaT10LShBZSh1LG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbdV0sMTcpKS52YWx1ZV8wLG89KEFlKHUrMSxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W3UrMV0sMTcpKS52YWx1ZV8wLXQsaT5vJiYrK18sZWUocywoQWUodStfLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbdStfXSwxNykpKSxjKz0oQWUodStfLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbdStfXSwxNykpLnZhbHVlXzAtdCwrK3I7cjxlLnNpemVfMSgpJiZhKGUuZ2V0XzAociksMTcpLnZhbHVlXzArYzw9KEFlKHUrXyxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W3UrX10sMTcpKS52YWx1ZV8wOykrK3I7dSs9MStffXJldHVybiBzfWZ1bmN0aW9uIEpiZShlLG4pe3ZhciByLHQ7aWYobi5pc0VtcHR5KCkpcmV0dXJuIE5lKCksTmUoKSxPdDtmb3IodD1uZXcgUSxlZSh0LEooYnQpKSxyPTE7cjxlLmxvbmdlc3RQYXRoOysrcillLmN1dHNBbGxvd2VkPT1udWxsJiZXYmUoZSksZS5jdXRzQWxsb3dlZFtyXSYmZWUodCxKKHIpKTtyZXR1cm4gdC5hcnJheS5sZW5ndGg9PTE/KE5lKCksTmUoKSxPdCk6KGVlKHQsSihxbikpLEhfbihuLHQpKX1wKDE2ODMsMSxzcixLYmUpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0dfbihhKG4sMzYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQuaW50ZXJtZWRpYXRlLndyYXBwaW5nIiwiU2luZ2xlRWRnZUdyYXBoV3JhcHBlciIsMTY4Myk7ZnVuY3Rpb24gQmgoKXtCaD1GLHF5PW5ldyBrRSgiTUVESUFOX0xBWUVSIiwwKSxPRT1uZXcga0UoIlRBSUxfTEFZRVIiLDEpLFZ5PW5ldyBrRSgiSEVBRF9MQVlFUiIsMiksVGY9bmV3IGtFKCJTUEFDRV9FRkZJQ0lFTlRfTEFZRVIiLDMpLFlwPW5ldyBrRSgiV0lERVNUX0xBWUVSIiw0KSxxcD1uZXcga0UoIkNFTlRFUl9MQVlFUiIsNSl9ZnVuY3Rpb24ga0UoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBVX24oZSl7cmV0dXJuIEJoKCksd24oKFpiZSgpLFFiZSksZSl9ZnVuY3Rpb24gV19uKCl7cmV0dXJuIEJoKCksUChJKFl5LDEpLFcsMjMyLDAsW3F5LE9FLFZ5LFRmLFlwLHFwXSl9cCgyMzIsMjIsezM6MSwzNDoxLDIyOjEsMjMyOjF9LGtFKTt2YXIgcXAsVnkscXksVGYsT0UsWXAsWXk9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiQ2VudGVyRWRnZUxhYmVsUGxhY2VtZW50U3RyYXRlZ3kiLDIzMixnbixXX24sVV9uKTtmdW5jdGlvbiBaYmUoKXtaYmU9RixRYmU9eW4oKEJoKCksUChJKFl5LDEpLFcsMjMyLDAsW3F5LE9FLFZ5LFRmLFlwLHFwXSkpKX12YXIgUWJlO2Z1bmN0aW9uIFo0KCl7WjQ9RixFVj1uZXcgd1YoIlFVQURSQVRJQyIsMCksRzk9bmV3IHdWKCJTQ0FOTElORSIsMSl9ZnVuY3Rpb24gd1YoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBqX24oZSl7cmV0dXJuIFo0KCksd24oKGVJZSgpLG5JZSksZSl9ZnVuY3Rpb24gVl9uKCl7cmV0dXJuIFo0KCksUChJKHZWLDEpLFcsNDMxLDAsW0VWLEc5XSl9cCg0MzEsMjIsezM6MSwzNDoxLDIyOjEsNDMxOjF9LHdWKTt2YXIgRVYsRzksdlY9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiQ29uc3RyYWludENhbGN1bGF0aW9uU3RyYXRlZ3kiLDQzMSxnbixWX24sal9uKTtmdW5jdGlvbiBlSWUoKXtlSWU9RixuSWU9eW4oKFo0KCksUChJKHZWLDEpLFcsNDMxLDAsW0VWLEc5XSkpKX12YXIgbkllO2Z1bmN0aW9uIE1FKCl7TUU9RixSRT1uZXcgSDkoIkxBWUVSX1NXRUVQIiwwKSxTMz1uZXcgSDkoIklOVEVSQUNUSVZFIiwxKSxTVj1uZXcgSDkoIk5PTkUiLDIpfWZ1bmN0aW9uIHJJZShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG5ldyBhNygoYWQoKSxqMykpO2Nhc2UgMTpyZXR1cm4gbmV3IHRBZTtjYXNlIDI6cmV0dXJuIG5ldyBQQWU7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgY3Jvc3NpbmcgbWluaW1pemVyICIrKGUubmFtZV8wIT1udWxsP2UubmFtZV8wOiIiK2Uub3JkaW5hbCkpKX19ZnVuY3Rpb24gSDkoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBxX24oZSl7cmV0dXJuIE1FKCksd24oKHRJZSgpLG9JZSksZSl9ZnVuY3Rpb24gWV9uKCl7cmV0dXJuIE1FKCksUChJKENWLDEpLFcsMzIyLDAsW1JFLFMzLFNWXSl9cCgzMjIsMjIsezM6MSwzNDoxLDIyOjEsMzIyOjEsMTg4OjEsMTk2OjF9LEg5KSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHJJZSh0aGlzKX0sbC5jcmVhdGVfMj1mdW5jdGlvbigpe3JldHVybiBySWUodGhpcyl9O3ZhciBTMyxSRSxTVixDVj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJDcm9zc2luZ01pbmltaXphdGlvblN0cmF0ZWd5IiwzMjIsZ24sWV9uLHFfbik7ZnVuY3Rpb24gdEllKCl7dEllPUYsb0llPXluKChNRSgpLFAoSShDViwxKSxXLDMyMiwwLFtSRSxTMyxTVl0pKSl9dmFyIG9JZTtmdW5jdGlvbiBRNCgpe1E0PUYsVFY9bmV3IFU5KCJBUkQiLDApLGVQPW5ldyBVOSgiTVNEIiwxKSxXOT1uZXcgVTkoIk1BTlVBTCIsMil9ZnVuY3Rpb24gVTkoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBLX24oZSl7cmV0dXJuIFE0KCksd24oKGlJZSgpLGFJZSksZSl9ZnVuY3Rpb24gWF9uKCl7cmV0dXJuIFE0KCksUChJKGJWLDEpLFcsMzUxLDAsW1RWLGVQLFc5XSl9cCgzNTEsMjIsezM6MSwzNDoxLDIyOjEsMzUxOjF9LFU5KTt2YXIgVFYsVzksZVAsYlY9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiQ3V0dGluZ1N0cmF0ZWd5IiwzNTEsZ24sWF9uLEtfbik7ZnVuY3Rpb24gaUllKCl7aUllPUYsYUllPXluKChRNCgpLFAoSShiViwxKSxXLDM1MSwwLFtUVixlUCxXOV0pKSl9dmFyIGFJZTtmdW5jdGlvbiBIYygpe0hjPUYsajk9bmV3IEMzKCJHUkVFRFkiLDApLElWPW5ldyBDMygiREVQVEhfRklSU1QiLDEpLFY5PW5ldyBDMygiSU5URVJBQ1RJVkUiLDIpLFh5PW5ldyBDMygiTU9ERUxfT1JERVIiLDMpLEt5PW5ldyBDMygiR1JFRURZX01PREVMX09SREVSIiw0KX1mdW5jdGlvbiBsSWUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgaUs7Y2FzZSAxOnJldHVybiBuZXcgVVBlO2Nhc2UgMjpyZXR1cm4gbmV3IEtQZTtjYXNlIDM6cmV0dXJuIG5ldyBRUGU7Y2FzZSA0OnJldHVybiBuZXcgVlBlO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGN5Y2xlIGJyZWFrZXIgIisoZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsKSkpfX1mdW5jdGlvbiBDMyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEpfbihlKXtyZXR1cm4gSGMoKSx3bigoc0llKCksdUllKSxlKX1mdW5jdGlvbiBaX24oKXtyZXR1cm4gSGMoKSxQKEkoeFYsMSksVywzNDgsMCxbajksSVYsVjksWHksS3ldKX1wKDM0OCwyMix7MzoxLDM0OjEsMjI6MSwzNDg6MSwxODg6MSwxOTY6MX0sQzMpLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gbEllKHRoaXMpfSxsLmNyZWF0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIGxJZSh0aGlzKX07dmFyIElWLGo5LEt5LFY5LFh5LHhWPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkN5Y2xlQnJlYWtpbmdTdHJhdGVneSIsMzQ4LGduLFpfbixKX24pO2Z1bmN0aW9uIHNJZSgpe3NJZT1GLHVJZT15bigoSGMoKSxQKEkoeFYsMSksVywzNDgsMCxbajksSVYsVjksWHksS3ldKSkpfXZhciB1SWU7ZnVuY3Rpb24gVDMoKXtUMz1GLG5QPW5ldyBQVigiUkVBRElOR19ESVJFQ1RJT04iLDApLE5WPW5ldyBQVigiUk9UQVRJT04iLDEpfWZ1bmN0aW9uIFBWKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gUV9uKGUpe3JldHVybiBUMygpLHduKChjSWUoKSxfSWUpLGUpfWZ1bmN0aW9uIGUxbigpe3JldHVybiBUMygpLFAoSShBViwxKSxXLDQyOCwwLFtuUCxOVl0pfXAoNDI4LDIyLHszOjEsMzQ6MSwyMjoxLDQyODoxfSxQVik7dmFyIG5QLE5WLEFWPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkRpcmVjdGlvbkNvbmdydWVuY3kiLDQyOCxnbixlMW4sUV9uKTtmdW5jdGlvbiBjSWUoKXtjSWU9RixfSWU9eW4oKFQzKCksUChJKEFWLDEpLFcsNDI4LDAsW25QLE5WXSkpKX12YXIgX0llO2Z1bmN0aW9uICRfKCl7JF89RixZOT1uZXcgcTkoIk5PTkUiLDApLEp5PW5ldyBxOSgiSU5DT01JTkdfT05MWSIsMSksS3A9bmV3IHE5KCJPVVRHT0lOR19PTkxZIiwyKX1mdW5jdGlvbiBxOShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIG4xbihlKXtyZXR1cm4gJF8oKSx3bigoZkllKCkscEllKSxlKX1mdW5jdGlvbiByMW4oKXtyZXR1cm4gJF8oKSxQKEkoZEllLDEpLFcsNDYwLDAsW1k5LEp5LEtwXSl9cCg0NjAsMjIsezM6MSwzNDoxLDIyOjEsNDYwOjF9LHE5KTt2YXIgSnksWTksS3AsZEllPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkVkZ2VDb25zdHJhaW50Iiw0NjAsZ24scjFuLG4xbik7ZnVuY3Rpb24gZkllKCl7ZkllPUYscEllPXluKCgkXygpLFAoSShkSWUsMSksVyw0NjAsMCxbWTksSnksS3BdKSkpfXZhciBwSWU7ZnVuY3Rpb24gclAoKXtyUD1GLFg5PW5ldyBERSgiQUxXQVlTX1VQIiwwKSxLOT1uZXcgREUoIkFMV0FZU19ET1dOIiwxKSxaOT1uZXcgREUoIkRJUkVDVElPTl9VUCIsMiksSjk9bmV3IERFKCJESVJFQ1RJT05fRE9XTiIsMyksUTk9bmV3IERFKCJTTUFSVF9VUCIsNCksdFA9bmV3IERFKCJTTUFSVF9ET1dOIiw1KX1mdW5jdGlvbiB0MW4oZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBLOTtjYXNlIDE6cmV0dXJuIFg5O2Nhc2UgMjpyZXR1cm4gSjk7Y2FzZSAzOnJldHVybiBaOTtjYXNlIDQ6cmV0dXJuIHRQO2Nhc2UgNTpyZXR1cm4gUTk7ZGVmYXVsdDpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gREUoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBvMW4oZSl7cmV0dXJuIHJQKCksd24oKGdJZSgpLGhJZSksZSl9ZnVuY3Rpb24gaTFuKCl7cmV0dXJuIHJQKCksUChJKExWLDEpLFcsMjgzLDAsW1g5LEs5LFo5LEo5LFE5LHRQXSl9cCgyODMsMjIsezM6MSwzNDoxLDIyOjEsMjgzOjF9LERFKTt2YXIgSzksWDksSjksWjksdFAsUTksTFY9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiRWRnZUxhYmVsU2lkZVNlbGVjdGlvbiIsMjgzLGduLGkxbixvMW4pO2Z1bmN0aW9uIGdJZSgpe2dJZT1GLGhJZT15bigoclAoKSxQKEkoTFYsMSksVywyODMsMCxbWDksSzksWjksSjksUTksdFBdKSkpfXZhciBoSWU7ZnVuY3Rpb24gYjMoKXtiMz1GLE9WPW5ldyBrVigiTk9ORSIsMCksb1A9bmV3IGtWKCJJTVBST1ZFX1NUUkFJR0hUTkVTUyIsMSl9ZnVuY3Rpb24ga1YoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBhMW4oZSl7cmV0dXJuIGIzKCksd24oKG1JZSgpLHlJZSksZSl9ZnVuY3Rpb24gbDFuKCl7cmV0dXJuIGIzKCksUChJKE1WLDEpLFcsNDg4LDAsW09WLG9QXSl9cCg0ODgsMjIsezM6MSwzNDoxLDIyOjEsNDg4OjF9LGtWKTt2YXIgb1AsT1YsTVY9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiRWRnZVN0cmFpZ2h0ZW5pbmdTdHJhdGVneSIsNDg4LGduLGwxbixhMW4pO2Z1bmN0aW9uIG1JZSgpe21JZT1GLHlJZT15bigoYjMoKSxQKEkoTVYsMSksVyw0ODgsMCxbT1Ysb1BdKSkpfXZhciB5SWU7ZnVuY3Rpb24gSTMoKXtJMz1GLGlQPW5ldyBGRSgiTk9ORSIsMCksRFY9bmV3IEZFKCJMRUZUVVAiLDEpLHpWPW5ldyBGRSgiUklHSFRVUCIsMiksUlY9bmV3IEZFKCJMRUZURE9XTiIsMyksRlY9bmV3IEZFKCJSSUdIVERPV04iLDQpLGVPPW5ldyBGRSgiQkFMQU5DRUQiLDUpfWZ1bmN0aW9uIEZFKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gczFuKGUpe3JldHVybiBJMygpLHduKCh3SWUoKSxFSWUpLGUpfWZ1bmN0aW9uIHUxbigpe3JldHVybiBJMygpLFAoSSgkViwxKSxXLDI4MSwwLFtpUCxEVix6VixSVixGVixlT10pfXAoMjgxLDIyLHszOjEsMzQ6MSwyMjoxLDI4MToxfSxGRSk7dmFyIGVPLFJWLERWLGlQLEZWLHpWLCRWPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkZpeGVkQWxpZ25tZW50IiwyODEsZ24sdTFuLHMxbik7ZnVuY3Rpb24gd0llKCl7d0llPUYsRUllPXluKChJMygpLFAoSSgkViwxKSxXLDI4MSwwLFtpUCxEVix6VixSVixGVixlT10pKSl9dmFyIEVJZTtmdW5jdGlvbiBaeSgpe1p5PUYsJEU9bmV3IHpFKCJOT05FIiwwKSxHVj1uZXcgekUoIkxFRlQiLDEpLFdWPW5ldyB6RSgiUklHSFQiLDIpLFVWPW5ldyB6RSgiTEVGVF9SSUdIVF9DT05TVFJBSU5UX0xPQ0tJTkciLDMpLEhWPW5ldyB6RSgiTEVGVF9SSUdIVF9DT05ORUNUSU9OX0xPQ0tJTkciLDQpLEJWPW5ldyB6RSgiRURHRV9MRU5HVEgiLDUpfWZ1bmN0aW9uIHpFKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gYzFuKGUpe3JldHVybiBaeSgpLHduKCh2SWUoKSxTSWUpLGUpfWZ1bmN0aW9uIF8xbigpe3JldHVybiBaeSgpLFAoSShqViwxKSxXLDI4MiwwLFskRSxHVixXVixVVixIVixCVl0pfXAoMjgyLDIyLHszOjEsMzQ6MSwyMjoxLDI4MjoxfSx6RSk7dmFyIEJWLEdWLEhWLFVWLCRFLFdWLGpWPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkdyYXBoQ29tcGFjdGlvblN0cmF0ZWd5IiwyODIsZ24sXzFuLGMxbik7ZnVuY3Rpb24gdkllKCl7dkllPUYsU0llPXluKChaeSgpLFAoSShqViwxKSxXLDI4MiwwLFskRSxHVixXVixVVixIVixCVl0pKSl9dmFyIFNJZTtmdW5jdGlvbiBWdCgpe1Z0PUYsYVA9bmV3IGJmKCJDT01NRU5UUyIsMCksbmw9bmV3IGJmKCJFWFRFUk5BTF9QT1JUUyIsMSksQkU9bmV3IGJmKCJIWVBFUkVER0VTIiwyKSxsUD1uZXcgYmYoIkhZUEVSTk9ERVMiLDMpLG53PW5ldyBiZigiTk9OX0ZSRUVfUE9SVFMiLDQpLFhwPW5ldyBiZigiTk9SVEhfU09VVEhfUE9SVFMiLDUpLEdFPW5ldyBiZigiU0VMRl9MT09QUyIsNiksUXk9bmV3IGJmKCJDRU5URVJfTEFCRUxTIiw3KSxldz1uZXcgYmYoIkVORF9MQUJFTFMiLDgpLHNQPW5ldyBiZigiUEFSVElUSU9OUyIsOSl9ZnVuY3Rpb24gYmYoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBkMW4oZSl7cmV0dXJuIFZ0KCksd24oKENJZSgpLFRJZSksZSl9ZnVuY3Rpb24gZjFuKCl7cmV0dXJuIFZ0KCksUChJKG5PLDEpLFcsMjU5LDAsW2FQLG5sLEJFLGxQLG53LFhwLEdFLFF5LGV3LHNQXSl9cCgyNTksMjIsezM6MSwzNDoxLDIyOjEsMjU5OjF9LGJmKTt2YXIgUXksYVAsZXcsbmwsQkUsbFAsbncsWHAsc1AsR0Usbk89Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiR3JhcGhQcm9wZXJ0aWVzIiwyNTksZ24sZjFuLGQxbik7ZnVuY3Rpb24gQ0llKCl7Q0llPUYsVEllPXluKChWdCgpLFAoSShuTywxKSxXLDI1OSwwLFthUCxubCxCRSxsUCxudyxYcCxHRSxReSxldyxzUF0pKSl9dmFyIFRJZTtmdW5jdGlvbiBydygpe3J3PUYsdE89bmV3IHJPKCJPTkVfU0lERUQiLDApLG9PPW5ldyByTygiVFdPX1NJREVEIiwxKSx4Mz1uZXcgck8oIk9GRiIsMil9ZnVuY3Rpb24gck8oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBwMW4oZSl7cmV0dXJuIHJ3KCksd24oKGJJZSgpLElJZSksZSl9ZnVuY3Rpb24gZzFuKCl7cmV0dXJuIHJ3KCksUChJKGlPLDEpLFcsMjk5LDAsW3RPLG9PLHgzXSl9cCgyOTksMjIsezM6MSwzNDoxLDIyOjEsMjk5OjF9LHJPKTt2YXIgeDMsdE8sb08saU89Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiR3JlZWR5U3dpdGNoVHlwZSIsMjk5LGduLGcxbixwMW4pO2Z1bmN0aW9uIGJJZSgpe2JJZT1GLElJZT15bigocncoKSxQKEkoaU8sMSksVywyOTksMCxbdE8sb08seDNdKSkpfXZhciBJSWU7ZnVuY3Rpb24gbGMoKXtsYz1GLFAzPW5ldyBhTygiTk9ORSIsMCksSnA9bmV3IGFPKCJUT1AiLDEpLEdoPW5ldyBhTygiQk9UVE9NIiwyKX1mdW5jdGlvbiBhTyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGgxbihlKXtyZXR1cm4gbGMoKSx3bigoUEllKCksTkllKSxlKX1mdW5jdGlvbiBtMW4oKXtyZXR1cm4gbGMoKSxQKEkoeEllLDEpLFcsMzExLDAsW1AzLEpwLEdoXSl9cCgzMTEsMjIsezM6MSwzNDoxLDIyOjEsMzExOjF9LGFPKTt2YXIgR2gsUDMsSnAseEllPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkluTGF5ZXJDb25zdHJhaW50IiwzMTEsZ24sbTFuLGgxbik7ZnVuY3Rpb24gUEllKCl7UEllPUYsTkllPXluKChsYygpLFAoSSh4SWUsMSksVywzMTEsMCxbUDMsSnAsR2hdKSkpfXZhciBOSWU7ZnVuY3Rpb24gdVAoKXt1UD1GLGxPPW5ldyBWVigiQ0VOVEVSIiwwKSxxVj1uZXcgVlYoIlRPUF9MRUZUIiwxKX1mdW5jdGlvbiBWVihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHkxbihlKXtyZXR1cm4gdVAoKSx3bigoQUllKCksTEllKSxlKX1mdW5jdGlvbiB3MW4oKXtyZXR1cm4gdVAoKSxQKEkoWVYsMSksVyw0MjksMCxbbE8scVZdKX1wKDQyOSwyMix7MzoxLDM0OjEsMjI6MSw0Mjk6MX0sVlYpO3ZhciBsTyxxVixZVj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJJbnRlcmFjdGl2ZVJlZmVyZW5jZVBvaW50Iiw0MjksZ24sdzFuLHkxbik7ZnVuY3Rpb24gQUllKCl7QUllPUYsTEllPXluKCh1UCgpLFAoSShZViwxKSxXLDQyOSwwLFtsTyxxVl0pKSl9dmFyIExJZTtmdW5jdGlvbiBLKCl7Sz1GO3ZhciBlLG47UW49bmV3IHRyKCJvcmlnaW4iKSxKVj1uZXcgdHIoImNvb3JkaW5hdGVPcmlnaW4iKSxmTz1uZXcgdHIoInByb2Nlc3NvcnMiKSxYVj1uZXcgdnIoImNvbXBvdW5kTm9kZSIsKHplKCksITEpKSxBMz1uZXcgdnIoImluc2lkZUNvbm5lY3Rpb25zIiwhMSksbnE9bmV3IHRyKCJvcmlnaW5hbEJlbmRwb2ludHMiKSxycT1uZXcgdHIoIm9yaWdpbmFsRHVtbXlOb2RlUG9zaXRpb24iKSx0cT1uZXcgdHIoIm9yaWdpbmFsTGFiZWxFZGdlIiksVUU9bmV3IHRyKCJyZXByZXNlbnRlZExhYmVscyIpLEhFPW5ldyB0cigiZW5kTGFiZWxzIiksVWg9bmV3IHRyKCJlbmRMYWJlbC5vcmlnaW4iKSxqaD1uZXcgdnIoImxhYmVsU2lkZSIsKERhKCksRFQpKSxacD1uZXcgdnIoIm1heEVkZ2VUaGlja25lc3MiLDApLE9zPW5ldyB2cigicmV2ZXJzZWQiLCExKSxWaD1uZXcgdHIoInJhbmRvbSIpLGRzPW5ldyB2cigibG9uZ0VkZ2VTb3VyY2UiLG51bGwpLHZsPW5ldyB2cigibG9uZ0VkZ2VUYXJnZXQiLG51bGwpLElmPW5ldyB2cigibG9uZ0VkZ2VIYXNMYWJlbER1bW1pZXMiLCExKSxMMz1uZXcgdnIoImxvbmdFZGdlQmVmb3JlTGFiZWxEdW1teSIsITEpLGRQPW5ldyB2cigiZWRnZUNvbnN0cmFpbnQiLCgkXygpLFk5KSksWDE9bmV3IHRyKCJpbkxheWVyTGF5b3V0VW5pdCIpLEJfPW5ldyB2cigiaW5MYXllckNvbnN0cmFpbnQiLChsYygpLFAzKSksV2g9bmV3IHZyKCJpbkxheWVyU3VjY2Vzc29yQ29uc3RyYWludCIsbmV3IFEpLGVxPW5ldyB2cigiaW5MYXllclN1Y2Nlc3NvckNvbnN0cmFpbnRCZXR3ZWVuTm9uRHVtbWllcyIsITEpLG9hPW5ldyB0cigicG9ydER1bW15IiksX1A9bmV3IHZyKCJjcm9zc2luZ0hpbnQiLEooMCkpLGlpPW5ldyB2cigiZ3JhcGhQcm9wZXJ0aWVzIiwobj1hKGlzKG5PKSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKSksRG89bmV3IHZyKCJleHRlcm5hbFBvcnRTaWRlIiwocmUoKSxPbykpLFFWPW5ldyB2cigiZXh0ZXJuYWxQb3J0U2l6ZSIsbmV3IG10KSxzTz1uZXcgdHIoImV4dGVybmFsUG9ydFJlcGxhY2VkRHVtbWllcyIpLGZQPW5ldyB0cigiZXh0ZXJuYWxQb3J0UmVwbGFjZWREdW1teSIpLHNjPW5ldyB2cigiZXh0ZXJuYWxQb3J0Q29ubmVjdGlvbnMiLChlPWEoaXMoJHQpLDkpLG5ldyBKYShlLGEoRGwoZSxlLmxlbmd0aCksOSksMCkpKSxKMT1uZXcgdnIoInBvcnRSYXRpb09yUG9zaXRpb24iLDApLEtWPW5ldyB0cigiYmFyeWNlbnRlckFzc29jaWF0ZXMiKSxxaD1uZXcgdHIoIlRvcFNpZGVDb21tZW50cyIpLEhoPW5ldyB0cigiQm90dG9tU2lkZUNvbW1lbnRzIiksY1A9bmV3IHRyKCJDb21tZW50Q29ubmVjdGlvblBvcnQiKSxjTz1uZXcgdnIoImlucHV0Q29sbGVjdCIsITEpLGRPPW5ldyB2cigib3V0cHV0Q29sbGVjdCIsITEpLE4zPW5ldyB2cigiY3ljbGljIiwhMSksWlY9bmV3IHRyKCJjcm9zc0hpZXJhcmNoeU1hcCIpLGdPPW5ldyB0cigidGFyZ2V0T2Zmc2V0IiksbmV3IHZyKCJzcGxpbmVMYWJlbFNpemUiLG5ldyBtdCksZWc9bmV3IHRyKCJzcGFjaW5ncyIpLHBQPW5ldyB2cigicGFydGl0aW9uQ29uc3RyYWludCIsITEpLEsxPW5ldyB0cigiYnJlYWtpbmdQb2ludC5pbmZvIiksYXE9bmV3IHRyKCJzcGxpbmVzLnN1cnZpdmluZ0VkZ2UiKSxHXz1uZXcgdHIoInNwbGluZXMucm91dGUuc3RhcnQiKSxuZz1uZXcgdHIoInNwbGluZXMuZWRnZUNoYWluIiksaXE9bmV3IHRyKCJvcmlnaW5hbFBvcnRDb25zdHJhaW50cyIpLFoxPW5ldyB0cigic2VsZkxvb3BIb2xkZXIiKSx0dz1uZXcgdHIoInNwbGluZXMubnNQb3J0WSIpLHJyPW5ldyB0cigibW9kZWxPcmRlciIpLF9PPW5ldyB0cigibG9uZ0VkZ2VUYXJnZXROb2RlIiksRDA9bmV3IHZyKCJmaXJzdFRyeVdpdGhJbml0aWFsT3JkZXIiLCExKSxRcD1uZXcgdnIoImZpcnN0VHJ5V2l0aEluaXRpYWxPcmRlciIsITEpLHVPPW5ldyB0cigibGF5ZXJDb25zdHJhaW50cy5oaWRkZW5Ob2RlcyIpLG9xPW5ldyB0cigibGF5ZXJDb25zdHJhaW50cy5vcHBvc2lkZVBvcnQiKSxwTz1uZXcgdHIoInRhcmdldE5vZGUubW9kZWxPcmRlciIpfXZhciBLVixIaCxLMSxjUCxYVixKVixfUCxaVixOMyxkUCxIRSxVaCxzYyxzTyxmUCxEbyxRVixEMCxpaSx1TyxjTyxBMyxCXyxYMSxXaCxlcSxqaCxMMyxJZixkcyx2bCxfTyxacCxycixRbixucSxycSx0cSxvcSxpcSxkTyxwUCxvYSxKMSxmTyxWaCxVRSxPcyxRcCxaMSxlZyxuZyx0dyxHXyxhcSxwTyxnTyxxaDtmdW5jdGlvbiBybCgpe3JsPUYsTzM9bmV3IGszKCJOT05FIiwwKSxXRT1uZXcgazMoIkZJUlNUIiwxKSxGMD1uZXcgazMoIkZJUlNUX1NFUEFSQVRFIiwyKSxqRT1uZXcgazMoIkxBU1QiLDMpLHhmPW5ldyBrMygiTEFTVF9TRVBBUkFURSIsNCl9ZnVuY3Rpb24gazMoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBFMW4oZSl7cmV0dXJuIHJsKCksd24oKGtJZSgpLE9JZSksZSl9ZnVuY3Rpb24gdjFuKCl7cmV0dXJuIHJsKCksUChJKGxxLDEpLFcsMTcxLDAsW08zLFdFLEYwLGpFLHhmXSl9cCgxNzEsMjIsezM6MSwzNDoxLDIyOjEsMTcxOjF9LGszKTt2YXIgV0UsRjAsakUseGYsTzMsbHE9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiTGF5ZXJDb25zdHJhaW50IiwxNzEsZ24sdjFuLEUxbik7ZnVuY3Rpb24ga0llKCl7a0llPUYsT0llPXluKChybCgpLFAoSShscSwxKSxXLDE3MSwwLFtPMyxXRSxGMCxqRSx4Zl0pKSl9dmFyIE9JZTtmdW5jdGlvbiBzcSgpe3NxPUYseXE9KFQzKCksblApLHV4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmRpcmVjdGlvbkNvbmdydWVuY3kiLHlxKSx2eGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5mZWVkYmFja0VkZ2VzIiwoemUoKSwhMSkpLFRxPSh1UCgpLGxPKSxJeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5pbnRlcmFjdGl2ZVJlZmVyZW5jZVBvaW50IixUcSksR3hlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubWVyZ2VFZGdlcyIsITEpLEh4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm1lcmdlSGllcmFyY2h5RWRnZXMiLCEwKSxSSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5hbGxvd05vbkZsb3dQb3J0c1RvU3dpdGNoU2lkZXMiLCExKSxrcT0oRzMoKSxXTyksdDRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucG9ydFNvcnRpbmdTdHJhdGVneSIsa3EpLEooMSksXzRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQudGhvcm91Z2huZXNzIixKKDcpKSxkNGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC51bm5lY2Vzc2FyeUJlbmRwb2ludHMiLCExKSxTeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5nZW5lcmF0ZVBvc2l0aW9uQW5kTGF5ZXJJZHMiLCExKSxtcT0oSGMoKSxqOSksc3hlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3ljbGVCcmVha2luZy5zdHJhdGVneSIsbXEpLHhxPShqYygpLFJPKSxCeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIseHEpLGJxPShybCgpLE8zKSxreGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5sYXllckNvbnN0cmFpbnQiLGJxKSxKKC0xKSxMeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5sYXllckNob2ljZUNvbnN0cmFpbnQiLG51bGwpLEooLTEpLE94ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLmxheWVySWQiLEooLTEpKSxKKC0xKSxNeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5taW5XaWR0aC51cHBlckJvdW5kT25XaWR0aCIsSig0KSksSigtMSksRHhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubWluV2lkdGgudXBwZXJMYXllckVzdGltYXRpb25TY2FsaW5nRmFjdG9yIixKKDIpKSxJcT0oU2woKSxGUCksJHhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubm9kZVByb21vdGlvbi5zdHJhdGVneSIsSXEpLEooMCksenhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubm9kZVByb21vdGlvbi5tYXhJdGVyYXRpb25zIixKKDApKSxOeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5jb2ZmbWFuR3JhaGFtLmxheWVyQm91bmQiLEoocW4pKSxocT0oTUUoKSxSRSksbHhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uc3RyYXRlZ3kiLGhxKSxWSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5mb3JjZU5vZGVNb2RlbE9yZGVyIiwhMSksUUllPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uaGllcmFyY2hpY2FsU3dlZXBpbmVzcyIsLjEpLGl4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnNlbWlJbnRlcmFjdGl2ZSIsITEpLG54ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmluTGF5ZXJQcmVkT2YiLG51bGwpLHJ4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmluTGF5ZXJTdWNjT2YiLG51bGwpLEooLTEpLHR4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnBvc2l0aW9uQ2hvaWNlQ29uc3RyYWludCIsbnVsbCksSigtMSksb3hlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24ucG9zaXRpb25JZCIsSigtMSkpLEooMCkscUllPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uZ3JlZWR5U3dpdGNoLmFjdGl2YXRpb25UaHJlc2hvbGQiLEooNDApKSxncT0ocncoKSxvTyksSkllPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uZ3JlZWR5U3dpdGNoLnR5cGUiLGdxKSxwcT14MyxZSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2hIaWVyYXJjaGljYWwudHlwZSIscHEpLExxPShRRSgpLGV2KSxyNGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LnN0cmF0ZWd5IixMcSkscXhlPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5mYXZvclN0cmFpZ2h0RWRnZXMiKSxQcT0oYjMoKSxvUCksVXhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5iay5lZGdlU3RyYWlnaHRlbmluZyIsUHEpLE5xPShJMygpLGlQKSxqeGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LmJrLmZpeGVkQWxpZ25tZW50IixOcSksWHhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5saW5lYXJTZWdtZW50cy5kZWZsZWN0aW9uRGFtcGVuaW5nIiwuMyksWnhlPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5uZXR3b3JrU2ltcGxleC5ub2RlRmxleGliaWxpdHkiKSxBcT0oUmYoKSxEUCksUXhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5uZXR3b3JrU2ltcGxleC5ub2RlRmxleGliaWxpdHkuZGVmYXVsdCIsQXEpLHZxPShCUCgpLFlPKSxweGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zZWxmTG9vcERpc3RyaWJ1dGlvbiIsdnEpLFNxPSh0digpLEpPKSxneGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zZWxmTG9vcE9yZGVyaW5nIixTcSksQ3E9KGR3KCksaXYpLGh4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMubW9kZSIsQ3EpLHl4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMuc2xvcHB5LmxheWVyU3BhY2luZ0ZhY3RvciIsLjIpLGR4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnBvbHlsaW5lLnNsb3BlZEVkZ2Vab25lV2lkdGgiLDIpLGw0ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnNwYWNpbmcuYmFzZVZhbHVlIixudWxsKSx1NGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5zcGFjaW5nLmVkZ2VOb2RlQmV0d2VlbkxheWVycyIsMTApLHM0ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnNwYWNpbmcuZWRnZUVkZ2VCZXR3ZWVuTGF5ZXJzIiwxMCksYzRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuc3BhY2luZy5ub2RlTm9kZUJldHdlZW5MYXllcnMiLDIwKSxKKDApLG80ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnByaW9yaXR5LmRpcmVjdGlvbiIsSigwKSksSigwKSxpNGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5wcmlvcml0eS5zaG9ydG5lc3MiLEooMCkpLEooMCksYTRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucHJpb3JpdHkuc3RyYWlnaHRuZXNzIixKKDApKSxESWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb21wYWN0aW9uLmNvbm5lY3RlZENvbXBvbmVudHMiLCExKSxjcT0oWnkoKSwkRSksekllPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29tcGFjdGlvbi5wb3N0Q29tcGFjdGlvbi5zdHJhdGVneSIsY3EpLHVxPShaNCgpLEc5KSxGSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb21wYWN0aW9uLnBvc3RDb21wYWN0aW9uLmNvbnN0cmFpbnRzIix1cSksVHhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaGlnaERlZ3JlZU5vZGVzLnRyZWF0bWVudCIsITEpLEooMCksQ3hlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaGlnaERlZ3JlZU5vZGVzLnRocmVzaG9sZCIsSigxNikpLEooMCksYnhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaGlnaERlZ3JlZU5vZGVzLnRyZWVIZWlnaHQiLEooNSkpLFJxPShIUCgpLG83KSxrNGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIsUnEpLGY0ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmFkZGl0aW9uYWxFZGdlU3BhY2luZyIsMTApLGg0ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmNvcnJlY3Rpb25GYWN0b3IiLDEpLE1xPShRNCgpLGVQKSxDNGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLnN0cmF0ZWd5IixNcSksdzRlPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY3V0dGluZy5jdXRzIiksT3E9SigxKSxKKDApLHY0ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmN1dHRpbmcubXNkLmZyZWVkb20iLE9xKSxEcT0oR1AoKSxyNyksRDRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcudmFsaWRpZnkuc3RyYXRlZ3kiLERxKSxPNGU9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy52YWxpZGlmeS5mb3JiaWRkZW5JbmRpY2VzIiksUDRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmltcHJvdmVDdXRzIiwhMCksSTRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmRpc3RhbmNlUGVuYWx0eSIsMiksQTRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmltcHJvdmVXcmFwcGVkRWRnZXMiLCEwKSxFcT0oclAoKSx0UCksX3hlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZUxhYmVscy5zaWRlU2VsZWN0aW9uIixFcSksd3E9KEJoKCkscXkpLGN4ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VMYWJlbHMuY2VudGVyTGFiZWxQbGFjZW1lbnRTdHJhdGVneSIsd3EpLGZxPShmdSgpLFZjKSxqSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIuc3RyYXRlZ3kiLGZxKSxXSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIucG9ydE1vZGVsT3JkZXIiLCExKSxVSWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIubm9Nb2RlbE9yZGVyIiwhMSksX3E9KEZfKCkseWYpLCRJZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jb21wb25lbnRzIixfcSksZHE9KFpFKCksRk8pLEhJZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5sb25nRWRnZVN0cmF0ZWd5IixkcSksQkllPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLmNyb3NzaW5nQ291bnRlck5vZGVJbmZsdWVuY2UiLDApLEdJZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jcm9zc2luZ0NvdW50ZXJQb3J0SW5mbHVlbmNlIiwwKSxQeGU9VjkseHhlPVMzLFJ4ZT1PUCxGeGU9T1AsQXhlPU1PLGV4ZT0ocGMoKSxRYyksYXhlPVJFLFpJZT1SRSxLSWU9UkUsWEllPVFjLFl4ZT1udixLeGU9ZXYsV3hlPWV2LFZ4ZT1ldixKeGU9R08sbjRlPW52LGU0ZT1udixteGU9KGZjKCksY20pLHd4ZT1jbSxFeGU9aXYsZnhlPU1ULHA0ZT1mdyxnNGU9JGYsbTRlPWZ3LHk0ZT0kZixUNGU9ZncsYjRlPSRmLEU0ZT1XOSxTNGU9ZVAsRjRlPWZ3LHo0ZT0kZixNNGU9ZncsUjRlPSRmLE40ZT0kZix4NGU9JGYsTDRlPSRmfWZ1bmN0aW9uIE1JZSgpe3NxKCl9cCg4NTksMSxwbCxNSWUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmRpcmVjdGlvbkNvbmdydWVuY3kiKSwiIiksIkRpcmVjdGlvbiBDb25ncnVlbmN5IiksIlNwZWNpZmllcyBob3cgZHJhd2luZ3Mgb2YgdGhlIHNhbWUgZ3JhcGggd2l0aCBkaWZmZXJlbnQgbGF5b3V0IGRpcmVjdGlvbnMgY29tcGFyZSB0byBlYWNoIG90aGVyOiBlaXRoZXIgYSBuYXR1cmFsIHJlYWRpbmcgZGlyZWN0aW9uIGlzIHByZXNlcnZlZCBvciB0aGUgZHJhd2luZ3MgYXJlIHJvdGF0ZWQgdmVyc2lvbnMgb2YgZWFjaCBvdGhlci4iKSx5cSksKEpjKCksbXIpKSxBViksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmZlZWRiYWNrRWRnZXMiKSwiIiksIkZlZWRiYWNrIEVkZ2VzIiksIldoZXRoZXIgZmVlZGJhY2sgZWRnZXMgc2hvdWxkIGJlIGhpZ2hsaWdodGVkIGJ5IHJvdXRpbmcgYXJvdW5kIHRoZSBub2Rlcy4iKSwoemUoKSwhMSkpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaW50ZXJhY3RpdmVSZWZlcmVuY2VQb2ludCIpLCIiKSwiSW50ZXJhY3RpdmUgUmVmZXJlbmNlIFBvaW50IiksIkRldGVybWluZXMgd2hpY2ggcG9pbnQgb2YgYSBub2RlIGlzIGNvbnNpZGVyZWQgYnkgaW50ZXJhY3RpdmUgbGF5b3V0IHBoYXNlcy4iKSxUcSksbXIpLFlWKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaW50ZXJhY3RpdmVSZWZlcmVuY2VQb2ludCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmN5Y2xlQnJlYWtpbmcuc3RyYXRlZ3kiLFB4ZSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaW50ZXJhY3RpdmVSZWZlcmVuY2VQb2ludCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnN0cmF0ZWd5Iix4eGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubWVyZ2VFZGdlcyIpLCIiKSwiTWVyZ2UgRWRnZXMiKSwiRWRnZXMgdGhhdCBoYXZlIG5vIHBvcnRzIGFyZSBtZXJnZWQgc28gdGhleSB0b3VjaCB0aGUgY29ubmVjdGVkIG5vZGVzIGF0IHRoZSBzYW1lIHBvaW50cy4gV2hlbiB0aGlzIG9wdGlvbiBpcyBkaXNhYmxlZCwgb25lIHBvcnQgaXMgY3JlYXRlZCBmb3IgZWFjaCBlZGdlIGRpcmVjdGx5IGNvbm5lY3RlZCB0byBhIG5vZGUuIFdoZW4gaXQgaXMgZW5hYmxlZCwgYWxsIHN1Y2ggaW5jb21pbmcgZWRnZXMgc2hhcmUgYW4gaW5wdXQgcG9ydCwgYW5kIGFsbCBvdXRnb2luZyBlZGdlcyBzaGFyZSBhbiBvdXRwdXQgcG9ydC4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5tZXJnZUhpZXJhcmNoeUVkZ2VzIiksIiIpLCJNZXJnZSBIaWVyYXJjaHktQ3Jvc3NpbmcgRWRnZXMiKSwiSWYgaGllcmFyY2hpY2FsIGxheW91dCBpcyBhY3RpdmUsIGhpZXJhcmNoeS1jcm9zc2luZyBlZGdlcyB1c2UgYXMgZmV3IGhpZXJhcmNoaWNhbCBwb3J0cyBhcyBwb3NzaWJsZS4gVGhleSBhcmUgYnJva2VuIGJ5IHRoZSBhbGdvcml0aG0sIHdpdGggaGllcmFyY2hpY2FsIHBvcnRzIGluc2VydGVkIGFzIHJlcXVpcmVkLiBVc3VhbGx5LCBvbmUgc3VjaCBwb3J0IGlzIGNyZWF0ZWQgZm9yIGVhY2ggZWRnZSBhdCBlYWNoIGhpZXJhcmNoeSBjcm9zc2luZyBwb2ludC4gV2l0aCB0aGlzIG9wdGlvbiBzZXQgdG8gdHJ1ZSwgd2UgdHJ5IHRvIGNyZWF0ZSBhcyBmZXcgaGllcmFyY2hpY2FsIHBvcnRzIGFzIHBvc3NpYmxlIGluIHRoZSBwcm9jZXNzLiBJbiBwYXJ0aWN1bGFyLCBhbGwgZWRnZXMgdGhhdCBmb3JtIGEgaHlwZXJlZGdlIGNhbiBzaGFyZSBhIHBvcnQuIiksITApLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKHgybihtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmFsbG93Tm9uRmxvd1BvcnRzVG9Td2l0Y2hTaWRlcyIpLCIiKSwiQWxsb3cgTm9uLUZsb3cgUG9ydHMgVG8gU3dpdGNoIFNpZGVzIiksIlNwZWNpZmllcyB3aGV0aGVyIG5vbi1mbG93IHBvcnRzIG1heSBzd2l0Y2ggc2lkZXMgaWYgdGhlaXIgbm9kZSdzIHBvcnQgY29uc3RyYWludHMgYXJlIGVpdGhlciBGSVhFRF9TSURFIG9yIEZJWEVEX09SREVSLiBBIG5vbi1mbG93IHBvcnQgaXMgYSBwb3J0IG9uIGEgc2lkZSB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBjdXJyZW50bHkgY29uZmlndXJlZCBsYXlvdXQgZmxvdy4gRm9yIGluc3RhbmNlLCBnaXZlbiBhIGxlZnQtdG8tcmlnaHQgbGF5b3V0IGRpcmVjdGlvbiwgbm9ydGggYW5kIHNvdXRoIHBvcnRzIHdvdWxkIGJlIGNvbnNpZGVyZWQgbm9uLWZsb3cgcG9ydHMuIEZ1cnRoZXIgbm90ZSB0aGF0IHRoZSB1bmRlcmx5aW5nIGNyaXRlcml1bSB3aGV0aGVyIHRvIHN3aXRjaCBzaWRlcyBvciBub3Qgc29sZWx5IHJlbGllcyBvbiB0aGUgbWluaW1pemF0aW9uIG9mIGVkZ2UgY3Jvc3NpbmdzLiBIZW5jZSwgZWRnZSBsZW5ndGggYW5kIG90aGVyIGFlc3RoZXRpY3MgY3JpdGVyaWEgYXJlIG5vdCBhZGRyZXNzZWQuIiksITEpLG50KSxBciksRWUoUV8pKSxQKEkoc2UsMSksWCwyLDYsWyJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub3J0aE9yU291dGhQb3J0Il0pKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucG9ydFNvcnRpbmdTdHJhdGVneSIpLCIiKSwiUG9ydCBTb3J0aW5nIFN0cmF0ZWd5IiksIk9ubHkgcmVsZXZhbnQgZm9yIG5vZGVzIHdpdGggRklYRURfU0lERSBwb3J0IGNvbnN0cmFpbnRzLiBEZXRlcm1pbmVzIHRoZSB3YXkgYSBub2RlJ3MgcG9ydHMgYXJlIGRpc3RyaWJ1dGVkIG9uIHRoZSBzaWRlcyBvZiBhIG5vZGUgaWYgdGhlaXIgb3JkZXIgaXMgbm90IHByZXNjcmliZWQuIFRoZSBvcHRpb24gaXMgc2V0IG9uIHBhcmVudCBub2Rlcy4iKSxrcSksbXIpLFVZKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC50aG9yb3VnaG5lc3MiKSwiIiksIlRob3JvdWdobmVzcyIpLCJIb3cgbXVjaCBlZmZvcnQgc2hvdWxkIGJlIHNwZW50IHRvIHByb2R1Y2UgYSBuaWNlIGxheW91dC4iKSxKKDcpKSxibyksdnQpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnVubmVjZXNzYXJ5QmVuZHBvaW50cyIpLCIiKSwiQWRkIFVubmVjZXNzYXJ5IEJlbmRwb2ludHMiKSwiQWRkcyBiZW5kIHBvaW50cyBldmVuIGlmIGFuIGVkZ2UgZG9lcyBub3QgY2hhbmdlIGRpcmVjdGlvbi4gSWYgdHJ1ZSwgZWFjaCBsb25nIGVkZ2UgZHVtbXkgd2lsbCBjb250cmlidXRlIGEgYmVuZCBwb2ludCB0byBpdHMgZWRnZXMgYW5kIGhpZXJhcmNoeS1jcm9zc2luZyBlZGdlcyB3aWxsIGFsd2F5cyBnZXQgYSBiZW5kIHBvaW50IHdoZXJlIHRoZXkgY3Jvc3MgaGllcmFyY2h5IGJvdW5kYXJpZXMuIEJ5IGRlZmF1bHQsIGJlbmQgcG9pbnRzIGFyZSBvbmx5IGFkZGVkIHdoZXJlIGFuIGVkZ2UgY2hhbmdlcyBkaXJlY3Rpb24uIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZ2VuZXJhdGVQb3NpdGlvbkFuZExheWVySWRzIiksIiIpLCJHZW5lcmF0ZSBQb3NpdGlvbiBhbmQgTGF5ZXIgSURzIiksIklmIGVuYWJsZWQgcG9zaXRpb24gaWQgYW5kIGxheWVyIGlkIGFyZSBnZW5lcmF0ZWQsIHdoaWNoIGFyZSB1c3VhbGx5IG9ubHkgdXNlZCBpbnRlcm5hbGx5IHdoZW4gc2V0dGluZyB0aGUgaW50ZXJhY3RpdmVMYXlvdXQgb3B0aW9uLiBUaGlzIG9wdGlvbiBzaG91bGQgYmUgc3BlY2lmaWVkIG9uIHRoZSByb290IG5vZGUuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3ljbGVCcmVha2luZy5zdHJhdGVneSIpLCJjeWNsZUJyZWFraW5nIiksIkN5Y2xlIEJyZWFraW5nIFN0cmF0ZWd5IiksIlN0cmF0ZWd5IGZvciBjeWNsZSBicmVha2luZy4gQ3ljbGUgYnJlYWtpbmcgbG9va3MgZm9yIGN5Y2xlcyBpbiB0aGUgZ3JhcGggYW5kIGRldGVybWluZXMgd2hpY2ggZWRnZXMgdG8gcmV2ZXJzZSB0byBicmVhayB0aGUgY3ljbGVzLiBSZXZlcnNlZCBlZGdlcyB3aWxsIGVuZCB1cCBwb2ludGluZyB0byB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIG9mIHJlZ3VsYXIgZWRnZXMgKHRoYXQgaXMsIHJldmVyc2VkIGVkZ2VzIHdpbGwgcG9pbnQgbGVmdCBpZiBlZGdlcyB1c3VhbGx5IHBvaW50IHJpZ2h0KS4iKSxtcSksbXIpLHhWKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIpLCJsYXllcmluZyIpLCJOb2RlIExheWVyaW5nIFN0cmF0ZWd5IiksIlN0cmF0ZWd5IGZvciBub2RlIGxheWVyaW5nLiIpLHhxKSxtciksQVkpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLmxheWVyQ29uc3RyYWludCIpLCJsYXllcmluZyIpLCJMYXllciBDb25zdHJhaW50IiksIkRldGVybWluZXMgYSBjb25zdHJhaW50IG9uIHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5vZGUgcmVnYXJkaW5nIHRoZSBsYXllcmluZy4iKSxicSksbXIpLGxxKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5sYXllckNob2ljZUNvbnN0cmFpbnQiKSwibGF5ZXJpbmciKSwiTGF5ZXIgQ2hvaWNlIENvbnN0cmFpbnQiKSwiQWxsb3dzIHRvIHNldCBhIGNvbnN0cmFpbnQgcmVnYXJkaW5nIHRoZSBsYXllciBwbGFjZW1lbnQgb2YgYSBub2RlLiBMZXQgaSBiZSB0aGUgdmFsdWUgb2YgdGVoIGNvbnN0cmFpbnQuIEFzc3VtZWQgdGhlIGRyYXdpbmcgaGFzIG4gbGF5ZXJzIGFuZCBpIDwgbi4gSWYgc2V0IHRvIGksIGl0IGV4cHJlc3NlcyB0aGF0IHRoZSBub2RlIHNob3VsZCBiZSBwbGFjZWQgaW4gaS10aCBsYXllci4gU2hvdWxkIGk+PW4gYmUgdHJ1ZSB0aGVuIHRoZSBub2RlIGlzIHBsYWNlZCBpbiB0aGUgbGFzdCBsYXllciBvZiB0aGUgZHJhd2luZy4gTm90ZSB0aGF0IHRoaXMgb3B0aW9uIGlzIG5vdCBwYXJ0IG9mIGFueSBvZiBFTEsgTGF5ZXJlZCdzIGRlZmF1bHQgY29uZmlndXJhdGlvbnMgYnV0IGlzIG9ubHkgZXZhbHVhdGVkIGFzIHBhcnQgb2YgdGhlIGBJbnRlcmFjdGl2ZUxheWVyZWRHcmFwaFZpc2l0b3JgLCB3aGljaCBtdXN0IGJlIGFwcGxpZWQgbWFudWFsbHkgb3IgdXNlZCB2aWEgdGhlIGBEaWFncmFtTGF5b3V0RW5naW5lLiIpLG51bGwpLGJvKSx2dCksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubGF5ZXJJZCIpLCJsYXllcmluZyIpLCJMYXllciBJRCIpLCJMYXllciBpZGVudGlmaWVyIHRoYXQgd2FzIGNhbGN1bGF0ZWQgYnkgRUxLIExheWVyZWQgZm9yIGEgbm9kZS4gVGhpcyBpcyBvbmx5IGdlbmVyYXRlZCBpZiBpbnRlcmFjdGl2ZUxheW90IG9yIGdlbmVyYXRlUG9zaXRpb25BbmRMYXllcklkcyBpcyBzZXQuIiksSigtMSkpLGJvKSx2dCksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubWluV2lkdGgudXBwZXJCb3VuZE9uV2lkdGgiKSwibGF5ZXJpbmcubWluV2lkdGgiKSwiVXBwZXIgQm91bmQgT24gV2lkdGggW01pbldpZHRoIExheWVyZXJdIiksIkRlZmluZXMgYSBsb29zZSB1cHBlciBib3VuZCBvbiB0aGUgd2lkdGggb2YgdGhlIE1pbldpZHRoIGxheWVyZXIuIElmIHNldCB0byAnLTEnIG11bHRpcGxlIHZhbHVlcyBhcmUgdGVzdGVkIGFuZCB0aGUgYmVzdCByZXN1bHQgaXMgc2VsZWN0ZWQuIiksSig0KSksYm8pLHZ0KSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubWluV2lkdGgudXBwZXJCb3VuZE9uV2lkdGgiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIsUnhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm1pbldpZHRoLnVwcGVyTGF5ZXJFc3RpbWF0aW9uU2NhbGluZ0ZhY3RvciIpLCJsYXllcmluZy5taW5XaWR0aCIpLCJVcHBlciBMYXllciBFc3RpbWF0aW9uIFNjYWxpbmcgRmFjdG9yIFtNaW5XaWR0aCBMYXllcmVyXSIpLCJNdWx0aXBsaWVkIHdpdGggVXBwZXIgQm91bmQgT24gV2lkdGggZm9yIGRlZmluaW5nIGFuIHVwcGVyIGJvdW5kIG9uIHRoZSB3aWR0aCBvZiBsYXllcnMgd2hpY2ggaGF2ZW4ndCBiZWVuIGRldGVybWluZWQgeWV0LCBidXQgd2hvc2UgbWF4aW11bSB3aWR0aCBoYWQgYmVlbiAocm91Z2hseSkgZXN0aW1hdGVkIGJ5IHRoZSBNaW5XaWR0aCBhbGdvcml0aG0uIENvbXBlbnNhdGVzIGZvciB0b28gaGlnaCBlc3RpbWF0aW9ucy4gSWYgc2V0IHRvICctMScgbXVsdGlwbGUgdmFsdWVzIGFyZSB0ZXN0ZWQgYW5kIHRoZSBiZXN0IHJlc3VsdCBpcyBzZWxlY3RlZC4iKSxKKDIpKSxibyksdnQpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5taW5XaWR0aC51cHBlckxheWVyRXN0aW1hdGlvblNjYWxpbmdGYWN0b3IiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIsRnhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm5vZGVQcm9tb3Rpb24uc3RyYXRlZ3kiKSwibGF5ZXJpbmcubm9kZVByb21vdGlvbiIpLCJOb2RlIFByb21vdGlvbiBTdHJhdGVneSIpLCJSZWR1Y2VzIG51bWJlciBvZiBkdW1teSBub2RlcyBhZnRlciBsYXllcmluZyBwaGFzZSAoaWYgcG9zc2libGUpLiIpLElxKSxtciksJFkpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm5vZGVQcm9tb3Rpb24ubWF4SXRlcmF0aW9ucyIpLCJsYXllcmluZy5ub2RlUHJvbW90aW9uIiksIk1heCBOb2RlIFByb21vdGlvbiBJdGVyYXRpb25zIiksIkxpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIG5vZGUgcHJvbW90aW9uLiIpLEooMCkpLGJvKSx2dCksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm5vZGVQcm9tb3Rpb24ubWF4SXRlcmF0aW9ucyIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm5vZGVQcm9tb3Rpb24uc3RyYXRlZ3kiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcuY29mZm1hbkdyYWhhbS5sYXllckJvdW5kIiksImxheWVyaW5nLmNvZmZtYW5HcmFoYW0iKSwiTGF5ZXIgQm91bmQiKSwiVGhlIG1heGltdW0gbnVtYmVyIG9mIG5vZGVzIGFsbG93ZWQgcGVyIGxheWVyLiIpLEoocW4pKSxibyksdnQpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5jb2ZmbWFuR3JhaGFtLmxheWVyQm91bmQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIsQXhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnN0cmF0ZWd5IiksImNyb3NzaW5nTWluaW1pemF0aW9uIiksIkNyb3NzaW5nIE1pbmltaXphdGlvbiBTdHJhdGVneSIpLCJTdHJhdGVneSBmb3IgY3Jvc3NpbmcgbWluaW1pemF0aW9uLiIpLGhxKSxtciksQ1YpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmZvcmNlTm9kZU1vZGVsT3JkZXIiKSwiY3Jvc3NpbmdNaW5pbWl6YXRpb24iKSwiRm9yY2UgTm9kZSBNb2RlbCBPcmRlciIpLCJUaGUgbm9kZSBvcmRlciBnaXZlbiBieSB0aGUgbW9kZWwgZG9lcyBub3QgY2hhbmdlIHRvIHByb2R1Y2UgYSBiZXR0ZXIgbGF5b3V0LiBFLmcuIGlmIG5vZGUgQSBpcyBiZWZvcmUgbm9kZSBCIGluIHRoZSBtb2RlbCB0aGlzIGlzIG5vdCBjaGFuZ2VkIGR1cmluZyBjcm9zc2luZyBtaW5pbWl6YXRpb24uIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBub2RlIG1vZGVsIG9yZGVyIGlzIGFscmVhZHkgcmVzcGVjdGVkIGJlZm9yZSBjcm9zc2luZyBtaW5pbWl6YXRpb24uIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHNldHRpbmcgY29uc2lkZXJNb2RlbE9yZGVyLnN0cmF0ZWd5IHRvIE5PREVTX0FORF9FREdFUy4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5oaWVyYXJjaGljYWxTd2VlcGluZXNzIiksImNyb3NzaW5nTWluaW1pemF0aW9uIiksIkhpZXJhcmNoaWNhbCBTd2VlcGluZXNzIiksIkhvdyBsaWtlbHkgaXQgaXMgdG8gdXNlIGNyb3NzLWhpZXJhcmNoeSAoMSkgdnMgYm90dG9tLXVwICgtMSkuIiksLjEpLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmhpZXJhcmNoaWNhbFN3ZWVwaW5lc3MiLCJvcmcuZWNsaXBzZS5lbGsuaGllcmFyY2h5SGFuZGxpbmciLGV4ZSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5zZW1pSW50ZXJhY3RpdmUiKSwiY3Jvc3NpbmdNaW5pbWl6YXRpb24iKSwiU2VtaS1JbnRlcmFjdGl2ZSBDcm9zc2luZyBNaW5pbWl6YXRpb24iKSwiUHJlc2VydmVzIHRoZSBvcmRlciBvZiBub2RlcyB3aXRoaW4gYSBsYXllciBidXQgc3RpbGwgbWluaW1pemVzIGNyb3NzaW5ncyBiZXR3ZWVuIGVkZ2VzIGNvbm5lY3RpbmcgbG9uZyBlZGdlIGR1bW1pZXMuIERlcml2ZXMgdGhlIGRlc2lyZWQgb3JkZXIgZnJvbSBwb3NpdGlvbnMgc3BlY2lmaWVkIGJ5IHRoZSAnb3JnLmVjbGlwc2UuZWxrLnBvc2l0aW9uJyBsYXlvdXQgb3B0aW9uLiBSZXF1aXJlcyBhIGNyb3NzaW5nIG1pbmltaXphdGlvbiBzdHJhdGVneSB0aGF0IGlzIGFibGUgdG8gcHJvY2VzcyAnaW4tbGF5ZXInIGNvbnN0cmFpbnRzLiIpLCExKSxudCksQXIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5zZW1pSW50ZXJhY3RpdmUiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5zdHJhdGVneSIsYXhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmluTGF5ZXJQcmVkT2YiKSwiY3Jvc3NpbmdNaW5pbWl6YXRpb24iKSwiSW4gTGF5ZXIgUHJlZGVjZXNzb3Igb2YiKSwiQWxsb3dzIHRvIHNldCBhIGNvbnN0cmFpbnQgd2hpY2ggc3BlY2lmaWVzIG9mIHdoaWNoIG5vZGUgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgcHJlZGVjZXNzb3IuIElmIHNldCB0byAncycgdGhlbiB0aGUgbm9kZSBpcyB0aGUgcHJlZGVjZXNzb3Igb2YgJ3MnIGFuZCBpcyBpbiB0aGUgc2FtZSBsYXllciIpLG51bGwpLHdnKSxzZSksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uaW5MYXllclN1Y2NPZiIpLCJjcm9zc2luZ01pbmltaXphdGlvbiIpLCJJbiBMYXllciBTdWNjZXNzb3Igb2YiKSwiQWxsb3dzIHRvIHNldCBhIGNvbnN0cmFpbnQgd2hpY2ggc3BlY2lmaWVzIG9mIHdoaWNoIG5vZGUgdGhlIGN1cnJlbnQgbm9kZSBpcyB0aGUgc3VjY2Vzc29yLiBJZiBzZXQgdG8gJ3MnIHRoZW4gdGhlIG5vZGUgaXMgdGhlIHN1Y2Nlc3NvciBvZiAncycgYW5kIGlzIGluIHRoZSBzYW1lIGxheWVyIiksbnVsbCksd2cpLHNlKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5wb3NpdGlvbkNob2ljZUNvbnN0cmFpbnQiKSwiY3Jvc3NpbmdNaW5pbWl6YXRpb24iKSwiUG9zaXRpb24gQ2hvaWNlIENvbnN0cmFpbnQiKSwiQWxsb3dzIHRvIHNldCBhIGNvbnN0cmFpbnQgcmVnYXJkaW5nIHRoZSBwb3NpdGlvbiBwbGFjZW1lbnQgb2YgYSBub2RlIGluIGEgbGF5ZXIuIEFzc3VtZWQgdGhlIGxheWVyIGluIHdoaWNoIHRoZSBub2RlIHBsYWNlZCBpbmNsdWRlcyBuIG90aGVyIG5vZGVzIGFuZCBpIDwgbi4gSWYgc2V0IHRvIGksIGl0IGV4cHJlc3NlcyB0aGF0IHRoZSBub2RlIHNob3VsZCBiZSBwbGFjZWQgYXQgdGhlIGktdGggcG9zaXRpb24uIFNob3VsZCBpPj1uIGJlIHRydWUgdGhlbiB0aGUgbm9kZSBpcyBwbGFjZWQgYXQgdGhlIGxhc3QgcG9zaXRpb24gaW4gdGhlIGxheWVyLiBOb3RlIHRoYXQgdGhpcyBvcHRpb24gaXMgbm90IHBhcnQgb2YgYW55IG9mIEVMSyBMYXllcmVkJ3MgZGVmYXVsdCBjb25maWd1cmF0aW9ucyBidXQgaXMgb25seSBldmFsdWF0ZWQgYXMgcGFydCBvZiB0aGUgYEludGVyYWN0aXZlTGF5ZXJlZEdyYXBoVmlzaXRvcmAsIHdoaWNoIG11c3QgYmUgYXBwbGllZCBtYW51YWxseSBvciB1c2VkIHZpYSB0aGUgYERpYWdyYW1MYXlvdXRFbmdpbmUuIiksbnVsbCksYm8pLHZ0KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5wb3NpdGlvbklkIiksImNyb3NzaW5nTWluaW1pemF0aW9uIiksIlBvc2l0aW9uIElEIiksIlBvc2l0aW9uIHdpdGhpbiBhIGxheWVyIHRoYXQgd2FzIGRldGVybWluZWQgYnkgRUxLIExheWVyZWQgZm9yIGEgbm9kZS4gVGhpcyBpcyBvbmx5IGdlbmVyYXRlZCBpZiBpbnRlcmFjdGl2ZUxheW90IG9yIGdlbmVyYXRlUG9zaXRpb25BbmRMYXllcklkcyBpcyBzZXQuIiksSigtMSkpLGJvKSx2dCksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uZ3JlZWR5U3dpdGNoLmFjdGl2YXRpb25UaHJlc2hvbGQiKSwiY3Jvc3NpbmdNaW5pbWl6YXRpb24uZ3JlZWR5U3dpdGNoIiksIkdyZWVkeSBTd2l0Y2ggQWN0aXZhdGlvbiBUaHJlc2hvbGQiKSwiQnkgZGVmYXVsdCBpdCBpcyBkZWNpZGVkIGF1dG9tYXRpY2FsbHkgaWYgdGhlIGdyZWVkeSBzd2l0Y2ggaXMgYWN0aXZhdGVkIG9yIG5vdC4gVGhlIGRlY2lzaW9uIGlzIGJhc2VkIG9uIHdoZXRoZXIgdGhlIHNpemUgb2YgdGhlIGlucHV0IGdyYXBoICh3aXRob3V0IGR1bW15IG5vZGVzKSBpcyBzbWFsbGVyIHRoYW4gdGhlIHZhbHVlIG9mIHRoaXMgb3B0aW9uLiBBICcwJyBlbmZvcmNlcyB0aGUgYWN0aXZhdGlvbi4iKSxKKDQwKSksYm8pLHZ0KSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2gudHlwZSIpLCJjcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2giKSwiR3JlZWR5IFN3aXRjaCBDcm9zc2luZyBNaW5pbWl6YXRpb24iKSwiR3JlZWR5IFN3aXRjaCBzdHJhdGVneSBmb3IgY3Jvc3NpbmcgbWluaW1pemF0aW9uLiBUaGUgZ3JlZWR5IHN3aXRjaCBoZXVyaXN0aWMgaXMgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHJlZ3VsYXIgY3Jvc3NpbmcgbWluaW1pemF0aW9uIGFzIGEgcG9zdC1wcm9jZXNzb3IuIE5vdGUgdGhhdCBpZiAnaGllcmFyY2h5SGFuZGxpbmcnIGlzIHNldCB0byAnSU5DTFVERV9DSElMRFJFTicsIHRoZSAnZ3JlZWR5U3dpdGNoSGllcmFyY2hpY2FsLnR5cGUnIG9wdGlvbiBtdXN0IGJlIHVzZWQuIiksZ3EpLG1yKSxpTyksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmdyZWVkeVN3aXRjaC50eXBlIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uc3RyYXRlZ3kiLFpJZSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2hIaWVyYXJjaGljYWwudHlwZSIpLCJjcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2hIaWVyYXJjaGljYWwiKSwiR3JlZWR5IFN3aXRjaCBDcm9zc2luZyBNaW5pbWl6YXRpb24gKGhpZXJhcmNoaWNhbCkiKSwiQWN0aXZhdGVzIHRoZSBncmVlZHkgc3dpdGNoIGhldXJpc3RpYyBpbiBjYXNlIGhpZXJhcmNoaWNhbCBsYXlvdXQgaXMgdXNlZC4gVGhlIGRpZmZlcmVuY2VzIHRvIHRoZSBub24taGllcmFyY2hpY2FsIGNhc2UgKHNlZSAnZ3JlZWR5U3dpdGNoLnR5cGUnKSBhcmU6IDEpIGdyZWVkeSBzd2l0Y2ggaXMgaW5hY3RpdmUgYnkgZGVmYXVsdCwgMykgb25seSB0aGUgb3B0aW9uIHZhbHVlIHNldCBvbiB0aGUgbm9kZSBhdCB3aGljaCBoaWVyYXJjaGljYWwgbGF5b3V0IHN0YXJ0cyBpcyByZWxldmFudCwgYW5kIDIpIGlmIGl0J3MgYWN0aXZhdGVkIGJ5IHRoZSB1c2VyLCBpdCBwcm9wZXJseSBhZGRyZXNzZXMgaGllcmFyY2h5LWNyb3NzaW5nIGVkZ2VzLiIpLHBxKSxtciksaU8pLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2hIaWVyYXJjaGljYWwudHlwZSIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnN0cmF0ZWd5IixLSWUpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmdyZWVkeVN3aXRjaEhpZXJhcmNoaWNhbC50eXBlIiwib3JnLmVjbGlwc2UuZWxrLmhpZXJhcmNoeUhhbmRsaW5nIixYSWUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5zdHJhdGVneSIpLCJub2RlUGxhY2VtZW50IiksIk5vZGUgUGxhY2VtZW50IFN0cmF0ZWd5IiksIlN0cmF0ZWd5IGZvciBub2RlIHBsYWNlbWVudC4iKSxMcSksbXIpLE1ZKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LmZhdm9yU3RyYWlnaHRFZGdlcyIpLCJub2RlUGxhY2VtZW50IiksIkZhdm9yIFN0cmFpZ2h0IEVkZ2VzIE92ZXIgQmFsYW5jaW5nIiksIkZhdm9yIHN0cmFpZ2h0IGVkZ2VzIG92ZXIgYSBiYWxhbmNlZCBub2RlIHBsYWNlbWVudC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgZGV0ZXJtaW5lZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSB1c2VkICdlZGdlUm91dGluZycuIEZvciBhbiBvcnRob2dvbmFsIHN0eWxlIGl0IGlzIHNldCB0byB0cnVlLCBmb3IgYWxsIG90aGVyIHN0eWxlcyB0byBmYWxzZS4iKSxudCksQXIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LmZhdm9yU3RyYWlnaHRFZGdlcyIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQuc3RyYXRlZ3kiLFl4ZSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5mYXZvclN0cmFpZ2h0RWRnZXMiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LnN0cmF0ZWd5IixLeGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5iay5lZGdlU3RyYWlnaHRlbmluZyIpLCJub2RlUGxhY2VtZW50LmJrIiksIkJLIEVkZ2UgU3RyYWlnaHRlbmluZyIpLCJTcGVjaWZpZXMgd2hldGhlciB0aGUgQnJhbmRlcyBLb2VwZiBub2RlIHBsYWNlciB0cmllcyB0byBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIHN0cmFpZ2h0IGVkZ2VzIGF0IHRoZSBleHBlbnNlIG9mIGRpYWdyYW0gc2l6ZS4gVGhlcmUgaXMgYSBzdWJ0bGUgZGlmZmVyZW5jZSB0byB0aGUgJ2Zhdm9yU3RyYWlnaHRFZGdlcycgb3B0aW9uLCB3aGljaCBkZWNpZGVzIHdoZXRoZXIgYSBiYWxhbmNlZCBwbGFjZW1lbnQgb2YgdGhlIG5vZGVzIGlzIGRlc2lyZWQsIG9yIG5vdC4gSW4gYmsgdGVybXMgdGhpcyBtZWFucyBjb21iaW5pbmcgdGhlIGZvdXIgYWxpZ25tZW50cyBpbnRvIGEgc2luZ2xlIGJhbGFuY2VkIG9uZSwgb3Igbm90LiBUaGlzIG9wdGlvbiBvbiB0aGUgb3RoZXIgaGFuZCB0cmllcyB0byBzdHJhaWdodGVuIGFkZGl0aW9uYWwgZWRnZXMgZHVyaW5nIHRoZSBjcmVhdGlvbiBvZiBlYWNoIG9mIHRoZSBmb3VyIGFsaWdubWVudHMuIiksUHEpLG1yKSxNViksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQuYmsuZWRnZVN0cmFpZ2h0ZW5pbmciLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LnN0cmF0ZWd5IixXeGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5iay5maXhlZEFsaWdubWVudCIpLCJub2RlUGxhY2VtZW50LmJrIiksIkJLIEZpeGVkIEFsaWdubWVudCIpLCJUZWxscyB0aGUgQksgbm9kZSBwbGFjZXIgdG8gdXNlIGEgY2VydGFpbiBhbGlnbm1lbnQgKG91dCBvZiBpdHMgZm91cikgaW5zdGVhZCBvZiB0aGUgb25lIHByb2R1Y2luZyB0aGUgc21hbGxlc3QgaGVpZ2h0LCBvciB0aGUgY29tYmluYXRpb24gb2YgYWxsIGZvdXIuIiksTnEpLG1yKSwkViksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQuYmsuZml4ZWRBbGlnbm1lbnQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LnN0cmF0ZWd5IixWeGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5saW5lYXJTZWdtZW50cy5kZWZsZWN0aW9uRGFtcGVuaW5nIiksIm5vZGVQbGFjZW1lbnQubGluZWFyU2VnbWVudHMiKSwiTGluZWFyIFNlZ21lbnRzIERlZmxlY3Rpb24gRGFtcGVuaW5nIiksIkRhbXBlbnMgdGhlIG1vdmVtZW50IG9mIG5vZGVzIHRvIGtlZXAgdGhlIGRpYWdyYW0gZnJvbSBnZXR0aW5nIHRvbyBsYXJnZS4iKSwuMyksUHQpLCRyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5saW5lYXJTZWdtZW50cy5kZWZsZWN0aW9uRGFtcGVuaW5nIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5zdHJhdGVneSIsSnhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgubm9kZUZsZXhpYmlsaXR5IiksIm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgiKSwiTm9kZSBGbGV4aWJpbGl0eSIpLCJBaW1zIGF0IHNob3J0ZXIgYW5kIHN0cmFpZ2h0ZXIgZWRnZXMuIFR3byBjb25maWd1cmF0aW9ucyBhcmUgcG9zc2libGU6IChhKSBhbGxvdyBwb3J0cyB0byBtb3ZlIGZyZWVseSBvbiB0aGUgc2lkZSB0aGV5IGFyZSBhc3NpZ25lZCB0byAodGhlIG9yZGVyIGlzIGFsd2F5cyBkZWZpbmVkIGJlZm9yZWhhbmQpLCAoYikgYWRkaXRpb25hbGx5IGFsbG93IHRvIGVubGFyZ2UgYSBub2RlIHdoZXJldmVyIGl0IGhlbHBzLiBJZiB0aGlzIG9wdGlvbiBpcyBub3QgY29uZmlndXJlZCBmb3IgYSBub2RlLCB0aGUgJ25vZGVGbGV4aWJpbGl0eS5kZWZhdWx0JyB2YWx1ZSBpcyB1c2VkLCB3aGljaCBpcyBzcGVjaWZpZWQgZm9yIHRoZSBub2RlJ3MgcGFyZW50LiIpLG1yKSwkTyksRWUoSnIpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgubm9kZUZsZXhpYmlsaXR5Iiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubm9kZVBsYWNlbWVudC5zdHJhdGVneSIsbjRlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgubm9kZUZsZXhpYmlsaXR5LmRlZmF1bHQiKSwibm9kZVBsYWNlbWVudC5uZXR3b3JrU2ltcGxleC5ub2RlRmxleGliaWxpdHkiKSwiTm9kZSBGbGV4aWJpbGl0eSBEZWZhdWx0IiksIkRlZmF1bHQgdmFsdWUgb2YgdGhlICdub2RlRmxleGliaWxpdHknIG9wdGlvbiBmb3IgdGhlIGNoaWxkcmVuIG9mIGEgaGllcmFyY2hpY2FsIG5vZGUuIiksQXEpLG1yKSwkTyksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgubm9kZUZsZXhpYmlsaXR5LmRlZmF1bHQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LnN0cmF0ZWd5IixlNGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZVJvdXRpbmcuc2VsZkxvb3BEaXN0cmlidXRpb24iKSwiZWRnZVJvdXRpbmciKSwiU2VsZi1Mb29wIERpc3RyaWJ1dGlvbiIpLCJBbHRlciB0aGUgZGlzdHJpYnV0aW9uIG9mIHRoZSBsb29wcyBhcm91bmQgdGhlIG5vZGUuIEl0IG9ubHkgdGFrZXMgZWZmZWN0IGZvciBQb3J0Q29uc3RyYWludHMuRlJFRS4iKSx2cSksbXIpLFZZKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zZWxmTG9vcE9yZGVyaW5nIiksImVkZ2VSb3V0aW5nIiksIlNlbGYtTG9vcCBPcmRlcmluZyIpLCJBbHRlciB0aGUgb3JkZXJpbmcgb2YgdGhlIGxvb3BzIHRoZXkgY2FuIGVpdGhlciBiZSBzdGFja2VkIG9yIHNlcXVlbmNlZC4gSXQgb25seSB0YWtlcyBlZmZlY3QgZm9yIFBvcnRDb25zdHJhaW50cy5GUkVFLiIpLFNxKSxtcikscVkpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMubW9kZSIpLCJlZGdlUm91dGluZy5zcGxpbmVzIiksIlNwbGluZSBSb3V0aW5nIE1vZGUiKSwiU3BlY2lmaWVzIHRoZSB3YXkgY29udHJvbCBwb2ludHMgYXJlIGFzc2VtYmxlZCBmb3IgZWFjaCBpbmRpdmlkdWFsIGVkZ2UuIENPTlNFUlZBVElWRSBlbnN1cmVzIHRoYXQgZWRnZXMgYXJlIHByb3Blcmx5IHJvdXRlZCBhcm91bmQgdGhlIG5vZGVzIGJ1dCBmZWVscyByYXRoZXIgb3J0aG9nb25hbCBhdCB0aW1lcy4gU0xPUFBZIHVzZXMgZmV3ZXIgY29udHJvbCBwb2ludHMgdG8gb2J0YWluIGN1cnZpZXIgZWRnZSByb3V0ZXMgYnV0IG1heSByZXN1bHQgaW4gZWRnZXMgb3ZlcmxhcHBpbmcgbm9kZXMuIiksQ3EpLG1yKSxKWSksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMubW9kZSIsIm9yZy5lY2xpcHNlLmVsay5lZGdlUm91dGluZyIsbXhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMuc2xvcHB5LmxheWVyU3BhY2luZ0ZhY3RvciIpLCJlZGdlUm91dGluZy5zcGxpbmVzLnNsb3BweSIpLCJTbG9wcHkgU3BsaW5lIExheWVyIFNwYWNpbmcgRmFjdG9yIiksIlNwYWNpbmcgZmFjdG9yIGZvciByb3V0aW5nIGFyZWEgYmV0d2VlbiBsYXllcnMgd2hlbiB1c2luZyBzbG9wcHkgc3BsaW5lIHJvdXRpbmcuIiksLjIpLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMuc2xvcHB5LmxheWVyU3BhY2luZ0ZhY3RvciIsIm9yZy5lY2xpcHNlLmVsay5lZGdlUm91dGluZyIsd3hlKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zcGxpbmVzLnNsb3BweS5sYXllclNwYWNpbmdGYWN0b3IiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zcGxpbmVzLm1vZGUiLEV4ZSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5wb2x5bGluZS5zbG9wZWRFZGdlWm9uZVdpZHRoIiksImVkZ2VSb3V0aW5nLnBvbHlsaW5lIiksIlNsb3BlZCBFZGdlIFpvbmUgV2lkdGgiKSwiV2lkdGggb2YgdGhlIHN0cmlwIHRvIHRoZSBsZWZ0IGFuZCB0byB0aGUgcmlnaHQgb2YgZWFjaCBsYXllciB3aGVyZSB0aGUgcG9seWxpbmUgZWRnZSByb3V0ZXIgaXMgYWxsb3dlZCB0byByZWZyYWluIGZyb20gZW5zdXJpbmcgdGhhdCBlZGdlcyBhcmUgcm91dGVkIGhvcml6b250YWxseS4gVGhpcyBwcmV2ZW50cyBhd2t3YXJkIGJlbmQgcG9pbnRzIGZvciBub2RlcyB0aGF0IGV4dGVudCBhbG1vc3QgdG8gdGhlIGVkZ2Ugb2YgdGhlaXIgbGF5ZXIuIiksMiksUHQpLCRyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZVJvdXRpbmcucG9seWxpbmUuc2xvcGVkRWRnZVpvbmVXaWR0aCIsIm9yZy5lY2xpcHNlLmVsay5lZGdlUm91dGluZyIsZnhlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnNwYWNpbmcuYmFzZVZhbHVlIiksInNwYWNpbmciKSwiU3BhY2luZyBCYXNlIFZhbHVlIiksIkFuIG9wdGlvbmFsIGJhc2UgdmFsdWUgZm9yIGFsbCBvdGhlciBsYXlvdXQgb3B0aW9ucyBvZiB0aGUgJ3NwYWNpbmcnIGdyb3VwLiBJdCBjYW4gYmUgdXNlZCB0byBjb252ZW5pZW50bHkgYWx0ZXIgdGhlIG92ZXJhbGwgJ3NwYWNpb3VzbmVzcycgb2YgdGhlIGRyYXdpbmcuIFdoZW5ldmVyIGFuIGV4cGxpY2l0IHZhbHVlIGlzIHNldCBmb3IgdGhlIG90aGVyIGxheW91dCBvcHRpb25zLCB0aGlzIGJhc2UgdmFsdWUgd2lsbCBoYXZlIG5vIGVmZmVjdC4gVGhlIGJhc2UgdmFsdWUgaXMgbm90IGluaGVyaXRlZCwgaS5lLiBpdCBtdXN0IGJlIHNldCBmb3IgZWFjaCBoaWVyYXJjaGljYWwgbm9kZS4iKSxQdCksJHIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnNwYWNpbmcuZWRnZU5vZGVCZXR3ZWVuTGF5ZXJzIiksInNwYWNpbmciKSwiRWRnZSBOb2RlIEJldHdlZW4gTGF5ZXJzIFNwYWNpbmciKSwiVGhlIHNwYWNpbmcgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gbm9kZXMgYW5kIGVkZ2VzIHRoYXQgYXJlIHJvdXRlZCBuZXh0IHRvIHRoZSBub2RlJ3MgbGF5ZXIuIEZvciB0aGUgc3BhY2luZyBiZXR3ZWVuIG5vZGVzIGFuZCBlZGdlcyB0aGF0IGNyb3NzIHRoZSBub2RlJ3MgbGF5ZXIgJ3NwYWNpbmcuZWRnZU5vZGUnIGlzIHVzZWQuIiksMTApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuc3BhY2luZy5lZGdlRWRnZUJldHdlZW5MYXllcnMiKSwic3BhY2luZyIpLCJFZGdlIEVkZ2UgQmV0d2VlbiBMYXllciBTcGFjaW5nIiksIlNwYWNpbmcgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gcGFpcnMgb2YgZWRnZXMgdGhhdCBhcmUgcm91dGVkIGJldHdlZW4gdGhlIHNhbWUgcGFpciBvZiBsYXllcnMuIE5vdGUgdGhhdCAnc3BhY2luZy5lZGdlRWRnZScgaXMgdXNlZCBmb3IgdGhlIHNwYWNpbmcgYmV0d2VlbiBwYWlycyBvZiBlZGdlcyBjcm9zc2luZyB0aGUgc2FtZSBsYXllci4iKSwxMCksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5zcGFjaW5nLm5vZGVOb2RlQmV0d2VlbkxheWVycyIpLCJzcGFjaW5nIiksIk5vZGUgTm9kZSBCZXR3ZWVuIExheWVycyBTcGFjaW5nIiksIlRoZSBzcGFjaW5nIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGFueSBwYWlyIG9mIG5vZGVzIG9mIHR3byBhZGphY2VudCBsYXllcnMuIE5vdGUgdGhhdCAnc3BhY2luZy5ub2RlTm9kZScgaXMgdXNlZCBmb3IgdGhlIHNwYWNpbmcgYmV0d2VlbiBub2RlcyB3aXRoaW4gdGhlIGxheWVyIGl0c2VsZi4iKSwyMCksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5wcmlvcml0eS5kaXJlY3Rpb24iKSwicHJpb3JpdHkiKSwiRGlyZWN0aW9uIFByaW9yaXR5IiksIkRlZmluZXMgaG93IGltcG9ydGFudCBpdCBpcyB0byBoYXZlIGEgY2VydGFpbiBlZGdlIHBvaW50IGludG8gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3ZlcmFsbCBsYXlvdXQuIFRoaXMgb3B0aW9uIGlzIGV2YWx1YXRlZCBkdXJpbmcgdGhlIGN5Y2xlIGJyZWFraW5nIHBoYXNlLiIpLEooMCkpLGJvKSx2dCksRWUobXUpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucHJpb3JpdHkuc2hvcnRuZXNzIiksInByaW9yaXR5IiksIlNob3J0bmVzcyBQcmlvcml0eSIpLCJEZWZpbmVzIGhvdyBpbXBvcnRhbnQgaXQgaXMgdG8ga2VlcCBhbiBlZGdlIGFzIHNob3J0IGFzIHBvc3NpYmxlLiBUaGlzIG9wdGlvbiBpcyBldmFsdWF0ZWQgZHVyaW5nIHRoZSBsYXllcmluZyBwaGFzZS4iKSxKKDApKSxibyksdnQpLEVlKG11KSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnByaW9yaXR5LnN0cmFpZ2h0bmVzcyIpLCJwcmlvcml0eSIpLCJTdHJhaWdodG5lc3MgUHJpb3JpdHkiKSwiRGVmaW5lcyBob3cgaW1wb3J0YW50IGl0IGlzIHRvIGtlZXAgYW4gZWRnZSBzdHJhaWdodCwgaS5lLiBhbGlnbmVkIHdpdGggb25lIG9mIHRoZSB0d28gYXhlcy4gVGhpcyBvcHRpb24gaXMgZXZhbHVhdGVkIGR1cmluZyBub2RlIHBsYWNlbWVudC4iKSxKKDApKSxibyksdnQpLEVlKG11KSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbXBhY3Rpb24uY29ubmVjdGVkQ29tcG9uZW50cyIpLCJjb21wYWN0aW9uIiksIkNvbm5lY3RlZCBDb21wb25lbnRzIENvbXBhY3Rpb24iKSwiVHJpZXMgdG8gZnVydGhlciBjb21wYWN0IGNvbXBvbmVudHMgKGRpc2Nvbm5lY3RlZCBzdWItZ3JhcGhzKS4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29tcGFjdGlvbi5jb25uZWN0ZWRDb21wb25lbnRzIiwib3JnLmVjbGlwc2UuZWxrLnNlcGFyYXRlQ29ubmVjdGVkQ29tcG9uZW50cyIsITApLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29tcGFjdGlvbi5wb3N0Q29tcGFjdGlvbi5zdHJhdGVneSIpLCJjb21wYWN0aW9uLnBvc3RDb21wYWN0aW9uIiksIlBvc3QgQ29tcGFjdGlvbiBTdHJhdGVneSIpLCJTcGVjaWZpZXMgd2hldGhlciBhbmQgaG93IHBvc3QtcHJvY2VzcyBjb21wYWN0aW9uIGlzIGFwcGxpZWQuIiksY3EpLG1yKSxqViksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29tcGFjdGlvbi5wb3N0Q29tcGFjdGlvbi5jb25zdHJhaW50cyIpLCJjb21wYWN0aW9uLnBvc3RDb21wYWN0aW9uIiksIlBvc3QgQ29tcGFjdGlvbiBDb25zdHJhaW50IENhbGN1bGF0aW9uIiksIlNwZWNpZmllcyB3aGV0aGVyIGFuZCBob3cgcG9zdC1wcm9jZXNzIGNvbXBhY3Rpb24gaXMgYXBwbGllZC4iKSx1cSksbXIpLHZWKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5oaWdoRGVncmVlTm9kZXMudHJlYXRtZW50IiksImhpZ2hEZWdyZWVOb2RlcyIpLCJIaWdoIERlZ3JlZSBOb2RlIFRyZWF0bWVudCIpLCJNYWtlcyByb29tIGFyb3VuZCBoaWdoIGRlZ3JlZSBub2RlcyB0byBwbGFjZSBsZWFmcyBhbmQgdHJlZXMuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuaGlnaERlZ3JlZU5vZGVzLnRocmVzaG9sZCIpLCJoaWdoRGVncmVlTm9kZXMiKSwiSGlnaCBEZWdyZWUgTm9kZSBUaHJlc2hvbGQiKSwiV2hldGhlciBhIG5vZGUgaXMgY29uc2lkZXJlZCB0byBoYXZlIGEgaGlnaCBkZWdyZWUuIiksSigxNikpLGJvKSx2dCksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmhpZ2hEZWdyZWVOb2Rlcy50aHJlc2hvbGQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5oaWdoRGVncmVlTm9kZXMudHJlYXRtZW50IiwhMCksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5oaWdoRGVncmVlTm9kZXMudHJlZUhlaWdodCIpLCJoaWdoRGVncmVlTm9kZXMiKSwiSGlnaCBEZWdyZWUgTm9kZSBNYXhpbXVtIFRyZWUgSGVpZ2h0IiksIk1heGltdW0gaGVpZ2h0IG9mIGEgc3VidHJlZSBjb25uZWN0ZWQgdG8gYSBoaWdoIGRlZ3JlZSBub2RlIHRvIGJlIG1vdmVkIHRvIHNlcGFyYXRlIGxheWVycy4iKSxKKDUpKSxibyksdnQpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5oaWdoRGVncmVlTm9kZXMudHJlZUhlaWdodCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmhpZ2hEZWdyZWVOb2Rlcy50cmVhdG1lbnQiLCEwKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5IiksIndyYXBwaW5nIiksIkdyYXBoIFdyYXBwaW5nIFN0cmF0ZWd5IiksIkZvciBjZXJ0YWluIGdyYXBocyBhbmQgY2VydGFpbiBwcmVzY3JpYmVkIGRyYXdpbmcgYXJlYXMgaXQgbWF5IGJlIGRlc2lyYWJsZSB0byBzcGxpdCB0aGUgbGFpZCBvdXQgZ3JhcGggaW50byBjaHVua3MgdGhhdCBhcmUgcGxhY2VkIHNpZGUgYnkgc2lkZS4gVGhlIGVkZ2VzIHRoYXQgY29ubmVjdCBkaWZmZXJlbnQgY2h1bmtzIGFyZSAnd3JhcHBlZCcgYXJvdW5kIGZyb20gdGhlIGVuZCBvZiBvbmUgY2h1bmsgdG8gdGhlIHN0YXJ0IG9mIHRoZSBvdGhlciBjaHVuay4gVGhlIHBvaW50cyBiZXR3ZWVuIHRoZSBjaHVua3MgYXJlIHJlZmVycmVkIHRvIGFzICdjdXRzJy4iKSxScSksbXIpLG5LKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5hZGRpdGlvbmFsRWRnZVNwYWNpbmciKSwid3JhcHBpbmciKSwiQWRkaXRpb25hbCBXcmFwcGVkIEVkZ2VzIFNwYWNpbmciKSwiVG8gdmlzdWFsbHkgc2VwYXJhdGUgZWRnZXMgdGhhdCBhcmUgd3JhcHBlZCBmcm9tIHJlZ3VsYXJseSByb3V0ZWQgZWRnZXMgYW4gYWRkaXRpb25hbCBzcGFjaW5nIHZhbHVlIGNhbiBiZSBzcGVjaWZpZWQgaW4gZm9ybSBvZiB0aGlzIGxheW91dCBvcHRpb24uIFRoZSBzcGFjaW5nIGlzIGFkZGVkIHRvIHRoZSByZWd1bGFyIGVkZ2VOb2RlIHNwYWNpbmcuIiksMTApLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmFkZGl0aW9uYWxFZGdlU3BhY2luZyIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5IixwNGUpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmFkZGl0aW9uYWxFZGdlU3BhY2luZyIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5IixnNGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY29ycmVjdGlvbkZhY3RvciIpLCJ3cmFwcGluZyIpLCJDb3JyZWN0aW9uIEZhY3RvciBmb3IgV3JhcHBpbmciKSwiQXQgdGltZXMgYW5kIGZvciBjZXJ0YWluIHR5cGVzIG9mIGdyYXBocyB0aGUgZXhlY3V0ZWQgd3JhcHBpbmcgbWF5IHByb2R1Y2UgcmVzdWx0cyB0aGF0IGFyZSBjb25zaXN0ZW50bHkgYmlhc2VkIGluIHRoZSBzYW1lIGZhc2hpb246IGVpdGhlciB3cmFwcGluZyB0byBvZnRlbiBvciB0byByYXJlbHkuIFRoaXMgZmFjdG9yIGNhbiBiZSB1c2VkIHRvIGNvcnJlY3QgdGhlIGJpYXMuIEludGVybmFsbHksIGl0IGlzIHNpbXBseSBtdWx0aXBsaWVkIHdpdGggdGhlICdhc3BlY3QgcmF0aW8nIGxheW91dCBvcHRpb24uIiksMSksUHQpLCRyKSxFZShPZSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY29ycmVjdGlvbkZhY3RvciIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5IixtNGUpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmNvcnJlY3Rpb25GYWN0b3IiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIseTRlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmN1dHRpbmcuc3RyYXRlZ3kiKSwid3JhcHBpbmcuY3V0dGluZyIpLCJDdXR0aW5nIFN0cmF0ZWd5IiksIlRoZSBzdHJhdGVneSBieSB3aGljaCB0aGUgbGF5ZXIgaW5kZXhlcyBhcmUgZGV0ZXJtaW5lZCBhdCB3aGljaCB0aGUgbGF5ZXJpbmcgY3J1bWJsZXMgaW50byBjaHVua3MuIiksTXEpLG1yKSxiViksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmN1dHRpbmcuc3RyYXRlZ3kiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIsVDRlKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLnN0cmF0ZWd5Iiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuc3RyYXRlZ3kiLGI0ZSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLmN1dHMiKSwid3JhcHBpbmcuY3V0dGluZyIpLCJNYW51YWxseSBTcGVjaWZpZWQgQ3V0cyIpLCJBbGxvd3MgdGhlIHVzZXIgdG8gc3BlY2lmeSBoZXIgb3duIGN1dHMgZm9yIGEgY2VydGFpbiBncmFwaC4iKSx6cyksamEpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLmN1dHMiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLnN0cmF0ZWd5IixFNGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY3V0dGluZy5tc2QuZnJlZWRvbSIpLCJ3cmFwcGluZy5jdXR0aW5nLm1zZCIpLCJNU0QgRnJlZWRvbSIpLCJUaGUgTVNEIGN1dHRpbmcgc3RyYXRlZ3kgc3RhcnRzIHdpdGggYW4gaW5pdGlhbCBndWVzcyBvbiB0aGUgbnVtYmVyIG9mIGNodW5rcyB0aGUgZ3JhcGggc2hvdWxkIGJlIHNwbGl0IGludG8uIFRoZSBmcmVlZG9tIHNwZWNpZmllcyBob3cgbXVjaCB0aGUgc3RyYXRlZ3kgbWF5IGRldmlhdGUgZnJvbSB0aGlzIGd1ZXNzLiBFLmcuIGlmIGFuIGluaXRpYWwgbnVtYmVyIG9mIDMgaXMgY29tcHV0ZWQsIGEgZnJlZWRvbSBvZiAxIGFsbG93cyAyLCAzLCBhbmQgNCBjdXRzLiIpLE9xKSxibyksdnQpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5jdXR0aW5nLm1zZC5mcmVlZG9tIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY3V0dGluZy5zdHJhdGVneSIsUzRlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnZhbGlkaWZ5LnN0cmF0ZWd5IiksIndyYXBwaW5nLnZhbGlkaWZ5IiksIlZhbGlkaWZpY2F0aW9uIFN0cmF0ZWd5IiksIldoZW4gd3JhcHBpbmcgZ3JhcGhzLCBvbmUgY2FuIHNwZWNpZnkgaW5kaWNlcyB0aGF0IGFyZSBub3QgYWxsb3dlZCBhcyBzcGxpdCBwb2ludHMuIFRoZSB2YWxpZGlmaWNhdGlvbiBzdHJhdGVneSBtYWtlcyBzdXJlIGV2ZXJ5IGNvbXB1dGVkIHNwbGl0IHBvaW50IGlzIGFsbG93ZWQuIiksRHEpLG1yKSxlSyksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnZhbGlkaWZ5LnN0cmF0ZWd5Iiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuc3RyYXRlZ3kiLEY0ZSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcudmFsaWRpZnkuc3RyYXRlZ3kiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIsejRlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnZhbGlkaWZ5LmZvcmJpZGRlbkluZGljZXMiKSwid3JhcHBpbmcudmFsaWRpZnkiKSwiVmFsaWQgSW5kaWNlcyBmb3IgV3JhcHBpbmciKSxudWxsKSx6cyksamEpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy52YWxpZGlmeS5mb3JiaWRkZW5JbmRpY2VzIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuc3RyYXRlZ3kiLE00ZSksVXIobiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcudmFsaWRpZnkuZm9yYmlkZGVuSW5kaWNlcyIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5IixSNGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmltcHJvdmVDdXRzIiksIndyYXBwaW5nLm11bHRpRWRnZSIpLCJJbXByb3ZlIEN1dHMiKSwiRm9yIGdlbmVyYWwgZ3JhcGhzIGl0IGlzIGltcG9ydGFudCB0aGF0IG5vdCB0b28gbWFueSBlZGdlcyB3cmFwIGJhY2t3YXJkcy4gVGh1cyBhIGNvbXByb21pc2UgYmV0d2VlbiBldmVubHktZGlzdHJpYnV0ZWQgY3V0cyBhbmQgdGhlIHRvdGFsIG51bWJlciBvZiBjdXQgZWRnZXMgaXMgc291Z2h0LiIpLCEwKSxudCksQXIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5tdWx0aUVkZ2UuaW1wcm92ZUN1dHMiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIsTjRlKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLm11bHRpRWRnZS5kaXN0YW5jZVBlbmFsdHkiKSwid3JhcHBpbmcubXVsdGlFZGdlIiksIkRpc3RhbmNlIFBlbmFsdHkgV2hlbiBJbXByb3ZpbmcgQ3V0cyIpLG51bGwpLDIpLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLm11bHRpRWRnZS5kaXN0YW5jZVBlbmFsdHkiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5zdHJhdGVneSIseDRlKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5tdWx0aUVkZ2UuZGlzdGFuY2VQZW5hbHR5Iiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmltcHJvdmVDdXRzIiwhMCksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5tdWx0aUVkZ2UuaW1wcm92ZVdyYXBwZWRFZGdlcyIpLCJ3cmFwcGluZy5tdWx0aUVkZ2UiKSwiSW1wcm92ZSBXcmFwcGVkIEVkZ2VzIiksIlRoZSBpbml0aWFsIHdyYXBwaW5nIGlzIHBlcmZvcm1lZCBpbiBhIHZlcnkgc2ltcGxlIHdheS4gQXMgYSBjb25zZXF1ZW5jZSwgZWRnZXMgdGhhdCB3cmFwIGZyb20gb25lIGNodW5rIHRvIGFub3RoZXIgbWF5IGJlIHVubmVjZXNzYXJpbHkgbG9uZy4gQWN0aXZhdGluZyB0aGlzIG9wdGlvbiB0cmllcyB0byBzaG9ydGVuIHN1Y2ggZWRnZXMuIiksITApLG50KSxBciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLm11bHRpRWRnZS5pbXByb3ZlV3JhcHBlZEVkZ2VzIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuc3RyYXRlZ3kiLEw0ZSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlTGFiZWxzLnNpZGVTZWxlY3Rpb24iKSwiZWRnZUxhYmVscyIpLCJFZGdlIExhYmVsIFNpZGUgU2VsZWN0aW9uIiksIk1ldGhvZCB0byBkZWNpZGUgb24gZWRnZSBsYWJlbCBzaWRlcy4iKSxFcSksbXIpLExWKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlTGFiZWxzLmNlbnRlckxhYmVsUGxhY2VtZW50U3RyYXRlZ3kiKSwiZWRnZUxhYmVscyIpLCJFZGdlIENlbnRlciBMYWJlbCBQbGFjZW1lbnQgU3RyYXRlZ3kiKSwiRGV0ZXJtaW5lcyBpbiB3aGljaCBsYXllciBjZW50ZXIgbGFiZWxzIG9mIGxvbmcgZWRnZXMgc2hvdWxkIGJlIHBsYWNlZC4iKSx3cSksbXIpLFl5KSxjcihPZSxQKEkoenUsMSksVywxNzAsMCxbWGNdKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIuc3RyYXRlZ3kiKSwiY29uc2lkZXJNb2RlbE9yZGVyIiksIkNvbnNpZGVyIE1vZGVsIE9yZGVyIiksIlByZXNlcnZlcyB0aGUgb3JkZXIgb2Ygbm9kZXMgYW5kIGVkZ2VzIGluIHRoZSBtb2RlbCBmaWxlIGlmIHRoaXMgZG9lcyBub3QgbGVhZCB0byBhZGRpdGlvbmFsIGVkZ2UgY3Jvc3NpbmdzLiBEZXBlbmRpbmcgb24gdGhlIHN0cmF0ZWd5IHRoaXMgaXMgbm90IGFsd2F5cyBwb3NzaWJsZSBzaW5jZSB0aGUgbm9kZSBhbmQgZWRnZSBvcmRlciBtaWdodCBiZSBjb25mbGljdGluZy4iKSxmcSksbXIpLEdZKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIucG9ydE1vZGVsT3JkZXIiKSwiY29uc2lkZXJNb2RlbE9yZGVyIiksIkNvbnNpZGVyIFBvcnQgT3JkZXIiKSwiSWYgZGlzYWJsZWQgdGhlIHBvcnQgb3JkZXIgb2Ygb3V0cHV0IHBvcnRzIGlzIGRlcml2ZWQgZnJvbSB0aGUgZWRnZSBvcmRlciBhbmQgaW5wdXQgcG9ydHMgYXJlIG9yZGVyZWQgYnkgdGhlaXIgaW5jb21pbmcgY29ubmVjdGlvbnMuIElmIGVuYWJsZWQgYWxsIHBvcnRzIGFyZSBvcmRlcmVkIGJ5IHRoZSBwb3J0IG1vZGVsIG9yZGVyLiIpLCExKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5ub01vZGVsT3JkZXIiKSwiY29uc2lkZXJNb2RlbE9yZGVyIiksIk5vIE1vZGVsIE9yZGVyIiksIlNldCBvbiBhIG5vZGUgdG8gbm90IHNldCBhIG1vZGVsIG9yZGVyIGZvciB0aGlzIG5vZGUgZXZlbiB0aG91Z2ggaXQgaXMgYSByZWFsIG5vZGUuIiksITEpLG50KSxBciksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLmNvbXBvbmVudHMiKSwiY29uc2lkZXJNb2RlbE9yZGVyIiksIkNvbnNpZGVyIE1vZGVsIE9yZGVyIGZvciBDb21wb25lbnRzIiksIklmIHNldCB0byBOT05FIHRoZSB1c3VhbCBvcmRlcmluZyBzdHJhdGVneSAoYnkgY3VtdWxhdGl2ZSBub2RlIHByaW9yaXR5IGFuZCBzaXplIG9mIG5vZGVzKSBpcyB1c2VkLiBJTlNJREVfUE9SVF9TSURFUyBvcmRlcnMgdGhlIGNvbXBvbmVudHMgd2l0aCBleHRlcm5hbCBwb3J0cyBvbmx5IGluc2lkZSB0aGUgZ3JvdXBzIHdpdGggdGhlIHNhbWUgcG9ydCBzaWRlLiBGT1JDRV9NT0RFTF9PUkRFUiBlbmZvcmNlcyB0aGUgbW9kZSBvcmRlciBvbiBjb21wb25lbnRzLiBUaGlzIG9wdGlvbiBtaWdodCBwcm9kdWNlIGJhZCBhbGlnbm1lbnRzIGFuZCBzdWIgb3B0aW1hbCBkcmF3aW5ncyBpbiB0ZXJtcyBvZiB1c2VkIGFyZWEgc2luY2UgdGhlIG9yZGVyaW5nIHNob3VsZCBiZSByZXNwZWN0ZWQuIiksX3EpLG1yKSx3VyksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jb21wb25lbnRzIiwib3JnLmVjbGlwc2UuZWxrLnNlcGFyYXRlQ29ubmVjdGVkQ29tcG9uZW50cyIsbnVsbCksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIubG9uZ0VkZ2VTdHJhdGVneSIpLCJjb25zaWRlck1vZGVsT3JkZXIiKSwiTG9uZyBFZGdlIE9yZGVyaW5nIFN0cmF0ZWd5IiksIkluZGljYXRlcyB3aGV0aGVyIGxvbmcgZWRnZXMgYXJlIHNvcnRlZCB1bmRlciwgb3Zlciwgb3IgZXF1YWwgdG8gbm9kZXMgdGhhdCBoYXZlIG5vIGNvbm5lY3Rpb24gdG8gYSBwcmV2aW91cyBsYXllciBpbiBhIGxlZnQtdG8tcmlnaHQgb3IgcmlnaHQtdG8tbGVmdCBsYXlvdXQuIFVuZGVyIGFuZCBvdmVyIGNoYW5nZXMgdG8gcmlnaHQgYW5kIGxlZnQgaW4gYSB2ZXJ0aWNhbCBsYXlvdXQuIiksZHEpLG1yKSxrWSksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLmNyb3NzaW5nQ291bnRlck5vZGVJbmZsdWVuY2UiKSwiY29uc2lkZXJNb2RlbE9yZGVyIiksIkNyb3NzaW5nIENvdW50ZXIgTm9kZSBPcmRlciBJbmZsdWVuY2UiKSwiSW5kaWNhdGVzIHdpdGggd2hhdCBwZXJjZW50YWdlICgxIGZvciAxMDAlKSB2aW9sYXRpb25zIG9mIHRoZSBub2RlIG1vZGVsIG9yZGVyIGFyZSB3ZWlnaHRlZCBhZ2FpbnN0IHRoZSBjcm9zc2luZ3MgZS5nLiBhIHZhbHVlIG9mIDAuNSBtZWFucyB0d28gbW9kZWwgb3JkZXIgdmlvbGF0aW9ucyBhcmUgYXMgaW1wb3J0YW50IGFzIG9uIGVkZ2UgY3Jvc3NpbmcuIFRoaXMgYWxsb3dzIHNvbWUgZWRnZSBjcm9zc2luZ3MgaW4gZmF2b3Igb2YgcHJlc2VydmluZyB0aGUgbW9kZWwgb3JkZXIuIEl0IGlzIGFkdmlzZWQgdG8gc2V0IHRoaXMgdmFsdWUgdG8gYSB2ZXJ5IHNtYWxsIHBvc2l0aXZlIHZhbHVlIChlLmcuIDAuMDAxKSB0byBoYXZlIG1pbmltYWwgY3Jvc3NpbmcgYW5kIGEgb3B0aW1hbCBub2RlIG9yZGVyLiBEZWZhdWx0cyB0byBubyBpbmZsdWVuY2UgKDApLiIpLDApLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jcm9zc2luZ0NvdW50ZXJOb2RlSW5mbHVlbmNlIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLnN0cmF0ZWd5IixudWxsKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jcm9zc2luZ0NvdW50ZXJQb3J0SW5mbHVlbmNlIiksImNvbnNpZGVyTW9kZWxPcmRlciIpLCJDcm9zc2luZyBDb3VudGVyIFBvcnQgT3JkZXIgSW5mbHVlbmNlIiksIkluZGljYXRlcyB3aXRoIHdoYXQgcGVyY2VudGFnZSAoMSBmb3IgMTAwJSkgdmlvbGF0aW9ucyBvZiB0aGUgcG9ydCBtb2RlbCBvcmRlciBhcmUgd2VpZ2h0ZWQgYWdhaW5zdCB0aGUgY3Jvc3NpbmdzIGUuZy4gYSB2YWx1ZSBvZiAwLjUgbWVhbnMgdHdvIG1vZGVsIG9yZGVyIHZpb2xhdGlvbnMgYXJlIGFzIGltcG9ydGFudCBhcyBvbiBlZGdlIGNyb3NzaW5nLiBUaGlzIGFsbG93cyBzb21lIGVkZ2UgY3Jvc3NpbmdzIGluIGZhdm9yIG9mIHByZXNlcnZpbmcgdGhlIG1vZGVsIG9yZGVyLiBJdCBpcyBhZHZpc2VkIHRvIHNldCB0aGlzIHZhbHVlIHRvIGEgdmVyeSBzbWFsbCBwb3NpdGl2ZSB2YWx1ZSAoZS5nLiAwLjAwMSkgdG8gaGF2ZSBtaW5pbWFsIGNyb3NzaW5nIGFuZCBhIG9wdGltYWwgcG9ydCBvcmRlci4gRGVmYXVsdHMgdG8gbm8gaW5mbHVlbmNlICgwKS4iKSwwKSxQdCksJHIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIuY3Jvc3NpbmdDb3VudGVyUG9ydEluZmx1ZW5jZSIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5zdHJhdGVneSIsbnVsbCksJDRlKChuZXcgQjRlLG4pKX07dmFyIFJJZSxESWUsRkllLHVxLHpJZSxjcSwkSWUsX3EsQkllLEdJZSxISWUsZHEsVUllLFdJZSxqSWUsZnEsVkllLHFJZSxZSWUscHEsS0llLFhJZSxKSWUsZ3EsWkllLFFJZSxleGUsbnhlLHJ4ZSx0eGUsb3hlLGl4ZSxheGUsbHhlLGhxLHN4ZSxtcSx1eGUseXEsY3hlLHdxLF94ZSxFcSxkeGUsZnhlLHB4ZSx2cSxneGUsU3EsaHhlLENxLG14ZSx5eGUsd3hlLEV4ZSx2eGUsU3hlLEN4ZSxUeGUsYnhlLEl4ZSxUcSx4eGUsUHhlLE54ZSxBeGUsTHhlLGt4ZSxicSxPeGUsTXhlLFJ4ZSxEeGUsRnhlLHp4ZSwkeGUsSXEsQnhlLHhxLEd4ZSxIeGUsVXhlLFBxLFd4ZSxqeGUsTnEsVnhlLHF4ZSxZeGUsS3hlLFh4ZSxKeGUsWnhlLFF4ZSxBcSxlNGUsbjRlLHI0ZSxMcSx0NGUsa3EsbzRlLGk0ZSxhNGUsbDRlLHM0ZSx1NGUsYzRlLF80ZSxkNGUsZjRlLHA0ZSxnNGUsaDRlLG00ZSx5NGUsdzRlLEU0ZSx2NGUsT3EsUzRlLEM0ZSxNcSxUNGUsYjRlLEk0ZSx4NGUsUDRlLE40ZSxBNGUsTDRlLGs0ZSxScSxPNGUsTTRlLFI0ZSxENGUsRHEsRjRlLHo0ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkxheWVyZWRNZXRhRGF0YVByb3ZpZGVyIiw4NTkpO2Z1bmN0aW9uIG9lKCl7b2U9Rix4Tz0oRm4oKSxaRGUpLGdZPVFEZSxEMz0kUSxxbD1lRmUsdGc9QlEsdGQ9R1EsTWY9SFEsc3c9VVEsdXc9V1EsUE89dEEsb2Q9dDEsTk89bkZlLFhFPXFRLE5QPXNtLFIzPShzcSgpLGw0ZSkscmc9czRlLHFfPXU0ZSxvZz1jNGUsSjRlPW5ldyB5dChMVCxKKDApKSxsdz1vNGUscFk9aTRlLFloPWE0ZSxUWT1rNGUsbVk9ZjRlLHlZPWg0ZSxMTz1DNGUsd1k9dzRlLEVZPXY0ZSxBUD1ENGUsa089TzRlLFNZPVA0ZSx2WT1JNGUsQ1k9QTRlLG5kPVp4ZSxLRT1ReGUsQ089aHhlLHFxPXl4ZSxyUGU9SXcsdFBlPWlBLG5QZT1rVCxlUGU9b0EsaFk9KHBtKCksS2YpLG5ldyB5dCh1bSxoWSksdVk9bmV3IFcxKDEyKSxzWT1uZXcgeXQoWmMsdVkpLFdxPShmYygpLE53KSx1Yz1uZXcgeXQobVEsV3EpLExmPW5ldyB5dChwYSwwKSxaNGU9bmV3IHl0KGZSLEooMSkpLGdQPW5ldyB5dChTZyxVbSksVl89ckEseHI9anYsYXc9UGcsVzRlPXhULF91PUhEZSxOZj1iZyxRNGU9bmV3IHl0KHBSLCh6ZSgpLCEwKSksQWY9UFQsVV89aVIsal89cjEsUFA9VzAsSU89V2YsVXE9KFdyKCksQnMpLE9hPW5ldyB5dChuMSxVcSksZWQ9SWcsSVA9VFEsa2Y9amYsWDRlPWRSLGRZPUZRLF9ZPShrZygpLHpUKSxuZXcgeXQoa1EsX1kpLHE0ZT1zUixZNGU9dVIsSzRlPWNSLFY0ZT1sUixBTz1kNGUsV189QnhlLHowPSR4ZSxKRT1fNGUsRWk9a3hlLEhfPXN4ZSxxRT1seGUsUTE9VkllLEJxPXFJZSx3Tz1KSWUsTTM9WUllLEVPPWl4ZSxvWT1HeGUsaVk9SHhlLFFxPUl4ZSx4UD1yNGUsYk89anhlLFRPPXZ4ZSxsWT1YeGUsVnE9cHhlLFNPPWd4ZSx5Tz1JVCxhWT1VeGUsbVA9ekllLEZxPUZJZSxoUD1ESWUsWHE9VHhlLEtxPUN4ZSxKcT1ieGUsb3c9eGcsaW89eWQsVWM9d1EsZHU9b1Isdk89dFIsR3E9UUllLFdjPV9SLFZFPWpEZSxDUD1xRGUscmQ9TVEsY1k9WURlLGl3PUtEZSxuWT1NeGUsclk9RHhlLE9mPWxtLGhPPVJJZSx0WT16eGUsU1A9X3hlLHZQPWN4ZSxiUD1idyxlWT1OeGUsWUU9cXhlLEYzPWpRLEhxPXV4ZSxmWT10NGUsanE9ZHhlLEc0ZT1ueGUsSDRlPXJ4ZSxqNGU9THhlLFU0ZT10eGUsWnE9YVIsVFA9T3hlLEVQPW94ZSxEdT1qSWUsJHE9SEllLHlQPUJJZSx6cT1HSWUsd1A9VUllLFBmPSRJZSxtTz1XSWUsWXE9U3hlfWZ1bmN0aW9uICQ0ZShlKXtoZChlLG5ldyBKXyhqWihqTihnZChkZChwZChmZChuZXcgWl8sIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiksIkVMSyBMYXllcmVkIiksIkxheWVyLWJhc2VkIGFsZ29yaXRobSBwcm92aWRlZCBieSB0aGUgRWNsaXBzZSBMYXlvdXQgS2VybmVsLiBBcnJhbmdlcyBhcyBtYW55IGVkZ2VzIGFzIHBvc3NpYmxlIGludG8gb25lIGRpcmVjdGlvbiBieSBwbGFjaW5nIG5vZGVzIGludG8gc3Vic2VxdWVudCBsYXllcnMuIFRoaXMgaW1wbGVtZW50YXRpb24gc3VwcG9ydHMgZGlmZmVyZW50IHJvdXRpbmcgc3R5bGVzIChzdHJhaWdodCwgb3J0aG9nb25hbCwgc3BsaW5lcyk7IGlmIG9ydGhvZ29uYWwgcm91dGluZyBpcyBzZWxlY3RlZCwgYXJiaXRyYXJ5IHBvcnQgY29uc3RyYWludHMgYXJlIHJlc3BlY3RlZCwgdGh1cyBlbmFibGluZyB0aGUgbGF5b3V0IG9mIGJsb2NrIGRpYWdyYW1zIHN1Y2ggYXMgYWN0b3Itb3JpZW50ZWQgbW9kZWxzIG9yIGNpcmN1aXQgc2NoZW1hdGljcy4gRnVydGhlcm1vcmUsIGZ1bGwgbGF5b3V0IG9mIGNvbXBvdW5kIGdyYXBocyB3aXRoIGNyb3NzLWhpZXJhcmNoeSBlZGdlcyBpcyBzdXBwb3J0ZWQgd2hlbiB0aGUgcmVzcGVjdGl2ZSBvcHRpb24gaXMgYWN0aXZhdGVkIG9uIHRoZSB0b3AgbGV2ZWwuIiksbmV3IG9QZSksIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiksY3IoKEh3KCksc0QpLFAoSShKQSwxKSxXLDI0NSwwLFtLQSxYQSxZQSxsRCxxQSxWQV0pKSkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuY29tbWVudENvbW1lbnQiLHRlKHhPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmNvbW1lbnROb2RlIix0ZShnWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5jb21wb25lbnRDb21wb25lbnQiLHRlKEQzKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmVkZ2VFZGdlIix0ZShxbCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5lZGdlTGFiZWwiLHRlKHRnKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmVkZ2VOb2RlIix0ZSh0ZCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbExhYmVsIix0ZShNZikpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbFBvcnRIb3Jpem9udGFsIix0ZShzdykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbFBvcnRWZXJ0aWNhbCIsdGUodXcpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubGFiZWxOb2RlIix0ZShQTykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5ub2RlTm9kZSIsdGUob2QpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZVNlbGZMb29wIix0ZShOTykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5wb3J0UG9ydCIsdGUoWEUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuaW5kaXZpZHVhbCIsdGUoTlApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuc3BhY2luZy5iYXNlVmFsdWUiLHRlKFIzKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnNwYWNpbmcuZWRnZUVkZ2VCZXR3ZWVuTGF5ZXJzIix0ZShyZykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5zcGFjaW5nLmVkZ2VOb2RlQmV0d2VlbkxheWVycyIsdGUocV8pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuc3BhY2luZy5ub2RlTm9kZUJldHdlZW5MYXllcnMiLHRlKG9nKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wcmlvcml0eSIsSigwKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLnByaW9yaXR5LmRpcmVjdGlvbiIsdGUobHcpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucHJpb3JpdHkuc2hvcnRuZXNzIix0ZShwWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5wcmlvcml0eS5zdHJhaWdodG5lc3MiLHRlKFloKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnN0cmF0ZWd5Iix0ZShUWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC53cmFwcGluZy5hZGRpdGlvbmFsRWRnZVNwYWNpbmciLHRlKG1ZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmNvcnJlY3Rpb25GYWN0b3IiLHRlKHlZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmN1dHRpbmcuc3RyYXRlZ3kiLHRlKExPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLmN1dHRpbmcuY3V0cyIsdGUod1kpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcuY3V0dGluZy5tc2QuZnJlZWRvbSIsdGUoRVkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcudmFsaWRpZnkuc3RyYXRlZ3kiLHRlKEFQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLnZhbGlkaWZ5LmZvcmJpZGRlbkluZGljZXMiLHRlKGtPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLndyYXBwaW5nLm11bHRpRWRnZS5pbXByb3ZlQ3V0cyIsdGUoU1kpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmRpc3RhbmNlUGVuYWx0eSIsdGUodlkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQud3JhcHBpbmcubXVsdGlFZGdlLmltcHJvdmVXcmFwcGVkRWRnZXMiLHRlKENZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubmV0d29ya1NpbXBsZXgubm9kZUZsZXhpYmlsaXR5Iix0ZShuZCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50Lm5ldHdvcmtTaW1wbGV4Lm5vZGVGbGV4aWJpbGl0eS5kZWZhdWx0Iix0ZShLRSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5lZGdlUm91dGluZy5zcGxpbmVzLm1vZGUiLHRlKENPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNwbGluZXMuc2xvcHB5LmxheWVyU3BhY2luZ0ZhY3RvciIsdGUocXEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd25MYXlvdXQiLHRlKHJQZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5zY2FsZUZhY3RvciIsdGUodFBlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVXaWR0aCIsdGUoblBlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVBc3BlY3RSYXRpbyIsdGUoZVBlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLm5vZGVUeXBlIixoWSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wYWRkaW5nIix1WSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5lZGdlUm91dGluZyIsV3EpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9ydC5ib3JkZXJPZmZzZXQiLDApLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucmFuZG9tU2VlZCIsSigxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5hc3BlY3RSYXRpbyIsVW0pLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubm9MYXlvdXQiLHRlKFZfKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0Q29uc3RyYWludHMiLHRlKHhyKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0LnNpZGUiLHRlKGF3KSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5kZWJ1Z01vZGUiLHRlKFc0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuYWxpZ25tZW50Iix0ZShfdSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuaGllcmFyY2h5SGFuZGxpbmciLHRlKE5mKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5zZXBhcmF0ZUNvbm5lY3RlZENvbXBvbmVudHMiLCh6ZSgpLCEwKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5pbnNpZGVTZWxmTG9vcHMuYWN0aXZhdGUiLHRlKEFmKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5pbnNpZGVTZWxmTG9vcHMueW8iLHRlKFVfKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5jb25zdHJhaW50cyIsdGUoal8pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm9wdGlvbnMiLHRlKFBQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5maXhlZEdyYXBoU2l6ZSIsdGUoSU8pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmRpcmVjdGlvbiIsVXEpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubm9kZUxhYmVscy5wbGFjZW1lbnQiLHRlKGVkKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlTGFiZWxzLnBhZGRpbmciLHRlKElQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0TGFiZWxzLnBsYWNlbWVudCIsdGUoa2YpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMubmV4dFRvUG9ydElmUG9zc2libGUiLHRlKFg0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9ydExhYmVscy50cmVhdEFzR3JvdXAiLHRlKGRZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0QWxpZ25tZW50LmRlZmF1bHQiLF9ZKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRBbGlnbm1lbnQubm9ydGgiLHRlKHE0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5zb3V0aCIsdGUoWTRlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0QWxpZ25tZW50Lndlc3QiLHRlKEs0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5lYXN0Iix0ZShWNGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQudW5uZWNlc3NhcnlCZW5kcG9pbnRzIix0ZShBTykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5zdHJhdGVneSIsdGUoV18pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcubm9kZVByb21vdGlvbi5zdHJhdGVneSIsdGUoejApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQudGhvcm91Z2huZXNzIix0ZShKRSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5sYXllckNvbnN0cmFpbnQiLHRlKEVpKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmN5Y2xlQnJlYWtpbmcuc3RyYXRlZ3kiLHRlKEhfKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnN0cmF0ZWd5Iix0ZShxRSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5mb3JjZU5vZGVNb2RlbE9yZGVyIix0ZShRMSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5ncmVlZHlTd2l0Y2guYWN0aXZhdGlvblRocmVzaG9sZCIsdGUoQnEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uZ3JlZWR5U3dpdGNoLnR5cGUiLHRlKHdPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmdyZWVkeVN3aXRjaEhpZXJhcmNoaWNhbC50eXBlIix0ZShNMykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5zZW1pSW50ZXJhY3RpdmUiLHRlKEVPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm1lcmdlRWRnZXMiLHRlKG9ZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm1lcmdlSGllcmFyY2h5RWRnZXMiLHRlKGlZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmludGVyYWN0aXZlUmVmZXJlbmNlUG9pbnQiLHRlKFFxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQuc3RyYXRlZ3kiLHRlKHhQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQuYmsuZml4ZWRBbGlnbm1lbnQiLHRlKGJPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmZlZWRiYWNrRWRnZXMiLHRlKFRPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLm5vZGVQbGFjZW1lbnQubGluZWFyU2VnbWVudHMuZGVmbGVjdGlvbkRhbXBlbmluZyIsdGUobFkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZVJvdXRpbmcuc2VsZkxvb3BEaXN0cmlidXRpb24iLHRlKFZxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VSb3V0aW5nLnNlbGZMb29wT3JkZXJpbmciLHRlKFNPKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5jb250ZW50QWxpZ25tZW50Iix0ZSh5TykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LmJrLmVkZ2VTdHJhaWdodGVuaW5nIix0ZShhWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb21wYWN0aW9uLnBvc3RDb21wYWN0aW9uLnN0cmF0ZWd5Iix0ZShtUCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb21wYWN0aW9uLnBvc3RDb21wYWN0aW9uLmNvbnN0cmFpbnRzIix0ZShGcSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb21wYWN0aW9uLmNvbm5lY3RlZENvbXBvbmVudHMiLHRlKGhQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmhpZ2hEZWdyZWVOb2Rlcy50cmVhdG1lbnQiLHRlKFhxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmhpZ2hEZWdyZWVOb2Rlcy50aHJlc2hvbGQiLHRlKEtxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmhpZ2hEZWdyZWVOb2Rlcy50cmVlSGVpZ2h0Iix0ZShKcSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUubWluaW11bSIsdGUob3cpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmp1bmN0aW9uUG9pbnRzIix0ZShpbykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuZWRnZS50aGlja25lc3MiLHRlKFVjKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5lZGdlTGFiZWxzLnBsYWNlbWVudCIsdGUoZHUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmVkZ2VMYWJlbHMuaW5saW5lIix0ZSh2TykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5oaWVyYXJjaGljYWxTd2VlcGluZXNzIix0ZShHcSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9ydC5pbmRleCIsdGUoV2MpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmNvbW1lbnRCb3giLHRlKFZFKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5oeXBlcm5vZGUiLHRlKENQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3J0LmFuY2hvciIsdGUocmQpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5hY3RpdmF0ZSIsdGUoY1kpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5wYXJ0aXRpb24iLHRlKGl3KSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLm1pbldpZHRoLnVwcGVyQm91bmRPbldpZHRoIix0ZShuWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5taW5XaWR0aC51cHBlckxheWVyRXN0aW1hdGlvblNjYWxpbmdGYWN0b3IiLHRlKHJZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5wb3NpdGlvbiIsdGUoT2YpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuYWxsb3dOb25GbG93UG9ydHNUb1N3aXRjaFNpZGVzIix0ZShoTykpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5ub2RlUHJvbW90aW9uLm1heEl0ZXJhdGlvbnMiLHRlKHRZKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmVkZ2VMYWJlbHMuc2lkZVNlbGVjdGlvbiIsdGUoU1ApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZUxhYmVscy5jZW50ZXJMYWJlbFBsYWNlbWVudFN0cmF0ZWd5Iix0ZSh2UCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubWFyZ2lucyIsdGUoYlApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQubGF5ZXJpbmcuY29mZm1hbkdyYWhhbS5sYXllckJvdW5kIix0ZShlWSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5ub2RlUGxhY2VtZW50LmZhdm9yU3RyYWlnaHRFZGdlcyIsdGUoWUUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcucG9ydHNTdXJyb3VuZGluZyIsdGUoRjMpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZGlyZWN0aW9uQ29uZ3J1ZW5jeSIsdGUoSHEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQucG9ydFNvcnRpbmdTdHJhdGVneSIsdGUoZlkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZWRnZVJvdXRpbmcucG9seWxpbmUuc2xvcGVkRWRnZVpvbmVXaWR0aCIsdGUoanEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY3Jvc3NpbmdNaW5pbWl6YXRpb24uaW5MYXllclByZWRPZiIsdGUoRzRlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLmluTGF5ZXJTdWNjT2YiLHRlKEg0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5sYXllcmluZy5sYXllckNob2ljZUNvbnN0cmFpbnQiLHRlKGo0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5wb3NpdGlvbkNob2ljZUNvbnN0cmFpbnQiLHRlKFU0ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsuaW50ZXJhY3RpdmVMYXlvdXQiLHRlKFpxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmxheWVyaW5nLmxheWVySWQiLHRlKFRQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNyb3NzaW5nTWluaW1pemF0aW9uLnBvc2l0aW9uSWQiLHRlKEVQKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5zdHJhdGVneSIsdGUoRHUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLmxvbmdFZGdlU3RyYXRlZ3kiLHRlKCRxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5jcm9zc2luZ0NvdW50ZXJOb2RlSW5mbHVlbmNlIix0ZSh5UCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZC5jb25zaWRlck1vZGVsT3JkZXIuY3Jvc3NpbmdDb3VudGVyUG9ydEluZmx1ZW5jZSIsdGUoenEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLm5vTW9kZWxPcmRlciIsdGUod1ApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuY29uc2lkZXJNb2RlbE9yZGVyLmNvbXBvbmVudHMiLHRlKFBmKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkLmNvbnNpZGVyTW9kZWxPcmRlci5wb3J0TW9kZWxPcmRlciIsdGUobU8pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIiwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQuZ2VuZXJhdGVQb3NpdGlvbkFuZExheWVySWRzIix0ZShZcSkpfWZ1bmN0aW9uIEI0ZSgpe29lKCl9cCg5OTgsMSxwbCxCNGUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXskNGUobil9O3ZhciBfdSxoTyxnUCxWRSxoUCxGcSxtUCxQZix5UCx6cSwkcSx3UCxtTyxEdSx5TyxRMSxCcSxNMyx3TyxHcSxHNGUsSDRlLFU0ZSxFUCxFTyxxRSxIXyxXNGUsT2EsSHEsVXEsdlAsdk8sZHUsU1AsdWMsV3EsanEsVnEsU08sQ08scXEsVWMsVE8sWXEsTmYsS3EsWHEsSnEsQ1AsQWYsVV8sWnEsUXEsaW8sZVksajRlLEVpLFRQLG5ZLHJZLHRZLHowLFdfLGJQLG9ZLGlZLElQLGVkLGFZLGJPLFlFLGxZLG5kLEtFLHhQLGpfLElPLG93LFBQLFZfLHNZLHVZLGNZLGl3LF9ZLFY0ZSxxNGUsWTRlLEs0ZSxyZCxMZix4cixXYyxYNGUsa2YsZFksYXcsZlksT2YsSjRlLGx3LHBZLFloLFo0ZSxRNGUsUjMseE8sZ1ksRDMscWwscmcsdGcsdGQscV8sTlAsTWYsUE8sc3csdXcsb2Qsb2csTk8sRjMsWEUsSkUsZVBlLG5QZSxyUGUsaFksdFBlLEFPLG1ZLHlZLHdZLEVZLExPLHZZLFNZLENZLFRZLGtPLEFQO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiTGF5ZXJlZE9wdGlvbnMiLDk5OCk7ZnVuY3Rpb24gb1BlKCl7fXAoOTk5LDEse30sb1BlKSxsLmNyZWF0ZV8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IF95ZSxufSxsLmRlc3Ryb3k9ZnVuY3Rpb24obil7fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkxheWVyZWRPcHRpb25zL0xheWVyZWRGYWN0b3J5Iiw5OTkpO2Z1bmN0aW9uIExQKCl7TFA9RixhUGU9bmV3IG16ZX1mdW5jdGlvbiBpUGUoZSxuKXtTMW4oZSkuYWNjZXB0KG4pfWZ1bmN0aW9uIFMxbihlKXtyZXR1cm4gZWUoZS5maWx0ZXJzLChRaCgpLGhSZSkpLGMkKGUuYmFzZVNwYWNpbmcsUigkKHRlKChPTygpLGtQKSkpKSk/bmV3IHd6ZTpuZXcgRXplKGUpfWZ1bmN0aW9uIEMxbihlLG4pe3ZhciByO3I9dGUoKE9PKCksa1ApKSE9bnVsbCYmbi5nZXREZWZhdWx0KCkhPW51bGw/UigkKG4uZ2V0RGVmYXVsdCgpKSkvUigkKHRlKGtQKSkpOjEsQm4oZS5mYWN0b3JNYXAsbixyKX1mdW5jdGlvbiBUMW4oZSxuKXtMcihKbihuZXcgU2UobnVsbCxuZXcgeGUobmV3IGtfKGUuZmFjdG9yTWFwKSwxKSksbmV3IHZ6ZShlLG4pKSxuZXcgQ3plKGUsbikpfWZ1bmN0aW9uIGIxbihlLG4scil7cmV0dXJuIVB5KEpuKG5ldyBTZShudWxsLG5ldyB4ZShlLmZpbHRlcnMsMTYpKSxuZXcgYnkobmV3IFN6ZShuLHIpKSkpLnRyeUFkdmFuY2UoKE1fKCksSWgpKX1mdW5jdGlvbiBJMW4oZSxuLHIpe24uc2V0UHJvcGVydHkocixSKCQoS2UoZS5mYWN0b3JNYXAscikpKSplLmJhc2VTcGFjaW5nKX1mdW5jdGlvbiB4MW4oZSxuLHIpe3JldHVybiBMUCgpLHIuYWNjZXB0XzQoZSxuKX1wKDEzOTEsMSx7fSksbC5iYXNlU3BhY2luZz0wO3ZhciBhUGU7Zygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkVsa1NwYWNpbmdzL0Fic3RyYWN0U3BhY2luZ3NCdWlsZGVyIiwxMzkxKTtmdW5jdGlvbiBPTygpe09PPUYsTFAoKSxrUD0ob2UoKSxvZCksbFBlPVRzKFAoSShxTSwxKSxWRiwxNDksMCxbRDMscWwsdGcsdGQsTWYsUE8sc3csdXcsTk8sWEUscmcscV8sb2ddKSl9ZnVuY3Rpb24gYlkoZSl7T08oKSx0aGlzLmZpbHRlcnM9VHMoUChJKG8ybiwxKSxNZSw4NDUsMCxbYVBlXSkpLHRoaXMuZmFjdG9yTWFwPW5ldyBzbix0aGlzLmJhc2VTcGFjaW5nPWUsQm4odGhpcy5mYWN0b3JNYXAsa1AsMSksd2kobFBlLG5ldyB5emUodGhpcykpfXAoNzkyLDEzOTEse30sYlkpO3ZhciBrUCxsUGU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJMYXllcmVkU3BhY2luZ3MvTGF5ZXJlZFNwYWNpbmdzQnVpbGRlciIsNzkyKTtmdW5jdGlvbiBqYygpe2pjPUYsUk89bmV3IGlnKCJORVRXT1JLX1NJTVBMRVgiLDApLHhZPW5ldyBpZygiTE9OR0VTVF9QQVRIIiwxKSxQWT1uZXcgaWcoIkxPTkdFU1RfUEFUSF9TT1VSQ0UiLDIpLE1PPW5ldyBpZygiQ09GRk1BTl9HUkFIQU0iLDMpLElZPW5ldyBpZygiSU5URVJBQ1RJVkUiLDQpLE5ZPW5ldyBpZygiU1RSRVRDSF9XSURUSCIsNSksT1A9bmV3IGlnKCJNSU5fV0lEVEgiLDYpLGN3PW5ldyBpZygiQkZfTU9ERUxfT1JERVIiLDcpLF93PW5ldyBpZygiREZfTU9ERUxfT1JERVIiLDgpfWZ1bmN0aW9uIHNQZShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG5ldyBrTmU7Y2FzZSAxOnJldHVybiBuZXcgRU5lO2Nhc2UgMzpyZXR1cm4gbmV3IGxOZTtjYXNlIDQ6cmV0dXJuIG5ldyBoTmU7Y2FzZSA1OnJldHVybiBuZXcgUk5lO2Nhc2UgNjpyZXR1cm4gbmV3IFBOZTtjYXNlIDI6cmV0dXJuIG5ldyBUTmU7Y2FzZSA3OnJldHVybiBuZXcgbk5lO2Nhc2UgODpyZXR1cm4gbmV3IGROZTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJObyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBsYXllcmVyICIrKGUubmFtZV8wIT1udWxsP2UubmFtZV8wOiIiK2Uub3JkaW5hbCkpKX19ZnVuY3Rpb24gaWcoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBQMW4oZSl7cmV0dXJuIGpjKCksd24oKHVQZSgpLGNQZSksZSl9ZnVuY3Rpb24gTjFuKCl7cmV0dXJuIGpjKCksUChJKEFZLDEpLFcsMjY1LDAsW1JPLHhZLFBZLE1PLElZLE5ZLE9QLGN3LF93XSl9cCgyNjUsMjIsezM6MSwzNDoxLDIyOjEsMjY1OjEsMTg4OjEsMTk2OjF9LGlnKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHNQZSh0aGlzKX0sbC5jcmVhdGVfMj1mdW5jdGlvbigpe3JldHVybiBzUGUodGhpcyl9O3ZhciBjdyxNTyxfdyxJWSx4WSxQWSxPUCxSTyxOWSxBWT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJMYXllcmluZ1N0cmF0ZWd5IiwyNjUsZ24sTjFuLFAxbik7ZnVuY3Rpb24gdVBlKCl7dVBlPUYsY1BlPXluKChqYygpLFAoSShBWSwxKSxXLDI2NSwwLFtSTyx4WSxQWSxNTyxJWSxOWSxPUCxjdyxfd10pKSl9dmFyIGNQZTtmdW5jdGlvbiBaRSgpe1pFPUYsRk89bmV3IERPKCJEVU1NWV9OT0RFX09WRVIiLDApLExZPW5ldyBETygiRFVNTVlfTk9ERV9VTkRFUiIsMSksTVA9bmV3IERPKCJFUVVBTCIsMil9ZnVuY3Rpb24gQTFuKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMDpyZXR1cm4gcW47Y2FzZSAxOnJldHVybi0xO2RlZmF1bHQ6cmV0dXJuIDB9fWZ1bmN0aW9uIERPKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gTDFuKGUpe3JldHVybiBaRSgpLHduKChfUGUoKSxkUGUpLGUpfWZ1bmN0aW9uIGsxbigpe3JldHVybiBaRSgpLFAoSShrWSwxKSxXLDM5MCwwLFtGTyxMWSxNUF0pfXAoMzkwLDIyLHszOjEsMzQ6MSwyMjoxLDM5MDoxfSxETyk7dmFyIEZPLExZLE1QLGtZPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIkxvbmdFZGdlT3JkZXJpbmdTdHJhdGVneSIsMzkwLGduLGsxbixMMW4pO2Z1bmN0aW9uIF9QZSgpe19QZT1GLGRQZT15bigoWkUoKSxQKEkoa1ksMSksVywzOTAsMCxbRk8sTFksTVBdKSkpfXZhciBkUGU7ZnVuY3Rpb24gUmYoKXtSZj1GLERQPW5ldyBSUCgiTk9ORSIsMCksek89bmV3IFJQKCJQT1JUX1BPU0lUSU9OIiwxKSxsZz1uZXcgUlAoIk5PREVfU0laRV9XSEVSRV9TUEFDRV9QRVJNSVRTIiwyKSxhZz1uZXcgUlAoIk5PREVfU0laRSIsMyl9ZnVuY3Rpb24gZlBlKGUpe3JldHVybiBlPT1sZ3x8ZT09YWd9ZnVuY3Rpb24gUlAoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBwUGUoZSl7UmYoKTt2YXIgbjtyZXR1cm4oZS5wcm9wZXJ0eU1hcD9lLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5jb250YWluc0tleSgob2UoKSxuZCkpP249YSh3KGUsbmQpLDIwMyk6bj1hKHcoU3QoZSksS0UpLDIwMyksbn1mdW5jdGlvbiBPMW4oZSl7cmV0dXJuIFJmKCksd24oKGdQZSgpLGhQZSksZSl9ZnVuY3Rpb24gTTFuKCl7cmV0dXJuIFJmKCksUChJKCRPLDEpLFcsMjAzLDAsW0RQLHpPLGxnLGFnXSl9cCgyMDMsMjIsezM6MSwzNDoxLDIyOjEsMjAzOjF9LFJQKTt2YXIgYWcsbGcsRFAsek8sJE89Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiTm9kZUZsZXhpYmlsaXR5IiwyMDMsZ24sTTFuLE8xbik7ZnVuY3Rpb24gZ1BlKCl7Z1BlPUYsaFBlPXluKChSZigpLFAoSSgkTywxKSxXLDIwMywwLFtEUCx6TyxsZyxhZ10pKSl9dmFyIGhQZTtmdW5jdGlvbiBRRSgpe1FFPUYsT1k9bmV3IHozKCJTSU1QTEUiLDApLEJPPW5ldyB6MygiSU5URVJBQ1RJVkUiLDEpLEdPPW5ldyB6MygiTElORUFSX1NFR01FTlRTIiwyKSxldj1uZXcgejMoIkJSQU5ERVNfS09FUEYiLDMpLG52PW5ldyB6MygiTkVUV09SS19TSU1QTEVYIiw0KX1mdW5jdGlvbiBtUGUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgSkxlO2Nhc2UgMTpyZXR1cm4gbmV3IG5MZTtjYXNlIDI6cmV0dXJuIG5ldyBpTGU7Y2FzZSAzOnJldHVybiBuZXcgcDZlO2Nhc2UgNDpyZXR1cm4gbmV3IF9MZTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJObyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBub2RlIHBsYWNlciAiKyhlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWwpKSl9fWZ1bmN0aW9uIHozKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gUjFuKGUpe3JldHVybiBRRSgpLHduKCh5UGUoKSx3UGUpLGUpfWZ1bmN0aW9uIEQxbigpe3JldHVybiBRRSgpLFAoSShNWSwxKSxXLDMyMywwLFtPWSxCTyxHTyxldixudl0pfXAoMzIzLDIyLHszOjEsMzQ6MSwyMjoxLDMyMzoxLDE4ODoxLDE5NjoxfSx6MyksbC5jcmVhdGVfMT1mdW5jdGlvbigpe3JldHVybiBtUGUodGhpcyl9LGwuY3JlYXRlXzI9ZnVuY3Rpb24oKXtyZXR1cm4gbVBlKHRoaXMpfTt2YXIgZXYsQk8sR08sbnYsT1ksTVk9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiTm9kZVBsYWNlbWVudFN0cmF0ZWd5IiwzMjMsZ24sRDFuLFIxbik7ZnVuY3Rpb24geVBlKCl7eVBlPUYsd1BlPXluKChRRSgpLFAoSShNWSwxKSxXLDMyMywwLFtPWSxCTyxHTyxldixudl0pKSl9dmFyIHdQZTtmdW5jdGlvbiBTbCgpe1NsPUYsRlA9bmV3IERmKCJOT05FIiwwKSwkMz1uZXcgRGYoIk5JS09MT1YiLDEpLEIzPW5ldyBEZigiTklLT0xPVl9QSVhFTCIsMiksRFk9bmV3IERmKCJOSUtPTE9WX0lNUFJPVkVEIiwzKSxGWT1uZXcgRGYoIk5JS09MT1ZfSU1QUk9WRURfUElYRUwiLDQpLFJZPW5ldyBEZigiRFVNTVlOT0RFX1BFUkNFTlRBR0UiLDUpLHpZPW5ldyBEZigiTk9ERUNPVU5UX1BFUkNFTlRBR0UiLDYpLHpQPW5ldyBEZigiTk9fQk9VTkRBUlkiLDcpLGlkPW5ldyBEZigiTU9ERUxfT1JERVJfTEVGVF9UT19SSUdIVCIsOCksRmY9bmV3IERmKCJNT0RFTF9PUkRFUl9SSUdIVF9UT19MRUZUIiw5KX1mdW5jdGlvbiBEZihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEYxbihlKXtyZXR1cm4gU2woKSx3bigoRVBlKCksdlBlKSxlKX1mdW5jdGlvbiB6MW4oKXtyZXR1cm4gU2woKSxQKEkoJFksMSksVywyNDMsMCxbRlAsJDMsQjMsRFksRlksUlkselkselAsaWQsRmZdKX1wKDI0MywyMix7MzoxLDM0OjEsMjI6MSwyNDM6MX0sRGYpO3ZhciBSWSxpZCxGZiwkMyxEWSxGWSxCMyx6WSxGUCx6UCwkWT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJOb2RlUHJvbW90aW9uU3RyYXRlZ3kiLDI0Myxnbix6MW4sRjFuKTtmdW5jdGlvbiBFUGUoKXtFUGU9Rix2UGU9eW4oKFNsKCksUChJKCRZLDEpLFcsMjQzLDAsW0ZQLCQzLEIzLERZLEZZLFJZLHpZLHpQLGlkLEZmXSkpKX12YXIgdlBlO2Z1bmN0aW9uIGZ1KCl7ZnU9RixWYz1uZXcgJFAoIk5PTkUiLDApLEJZPW5ldyAkUCgiTk9ERVNfQU5EX0VER0VTIiwxKSxITz1uZXcgJFAoIlBSRUZFUl9FREdFUyIsMiksVU89bmV3ICRQKCJQUkVGRVJfTk9ERVMiLDMpfWZ1bmN0aW9uICRQKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gJDFuKGUpe3JldHVybiBmdSgpLHduKChTUGUoKSxDUGUpLGUpfWZ1bmN0aW9uIEIxbigpe3JldHVybiBmdSgpLFAoSShHWSwxKSxXLDI4NCwwLFtWYyxCWSxITyxVT10pfXAoMjg0LDIyLHszOjEsMzQ6MSwyMjoxLDI4NDoxfSwkUCk7dmFyIEJZLFZjLEhPLFVPLEdZPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIk9yZGVyaW5nU3RyYXRlZ3kiLDI4NCxnbixCMW4sJDFuKTtmdW5jdGlvbiBTUGUoKXtTUGU9RixDUGU9eW4oKGZ1KCksUChJKEdZLDEpLFcsMjg0LDAsW1ZjLEJZLEhPLFVPXSkpKX12YXIgQ1BlO2Z1bmN0aW9uIEczKCl7RzM9RixXTz1uZXcgSFkoIklOUFVUX09SREVSIiwwKSxqTz1uZXcgSFkoIlBPUlRfREVHUkVFIiwxKX1mdW5jdGlvbiBIWShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEcxbihlKXtyZXR1cm4gRzMoKSx3bigoVFBlKCksYlBlKSxlKX1mdW5jdGlvbiBIMW4oKXtyZXR1cm4gRzMoKSxQKEkoVVksMSksVyw0MzAsMCxbV08sak9dKX1wKDQzMCwyMix7MzoxLDM0OjEsMjI6MSw0MzA6MX0sSFkpO3ZhciBXTyxqTyxVWT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJQb3J0U29ydGluZ1N0cmF0ZWd5Iiw0MzAsZ24sSDFuLEcxbik7ZnVuY3Rpb24gVFBlKCl7VFBlPUYsYlBlPXluKChHMygpLFAoSShVWSwxKSxXLDQzMCwwLFtXTyxqT10pKSl9dmFyIGJQZTtmdW5jdGlvbiBxdCgpe3F0PUYscnY9bmV3IFZPKCJVTkRFRklORUQiLDApLGlhPW5ldyBWTygiSU5QVVQiLDEpLHBpPW5ldyBWTygiT1VUUFVUIiwyKX1mdW5jdGlvbiBWTyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFUxbihlKXtyZXR1cm4gcXQoKSx3bigoeFBlKCksUFBlKSxlKX1mdW5jdGlvbiBXMW4oKXtyZXR1cm4gcXQoKSxQKEkoSVBlLDEpLFcsNDYzLDAsW3J2LGlhLHBpXSl9cCg0NjMsMjIsezM6MSwzNDoxLDIyOjEsNDYzOjF9LFZPKTt2YXIgaWEscGkscnYsSVBlPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIlBvcnRUeXBlIiw0NjMsZ24sVzFuLFUxbik7ZnVuY3Rpb24geFBlKCl7eFBlPUYsUFBlPXluKChxdCgpLFAoSShJUGUsMSksVyw0NjMsMCxbcnYsaWEscGldKSkpfXZhciBQUGU7ZnVuY3Rpb24gQlAoKXtCUD1GLFdZPW5ldyBxTygiRVFVQUxMWSIsMCksWU89bmV3IHFPKCJOT1JUSCIsMSksalk9bmV3IHFPKCJOT1JUSF9TT1VUSCIsMil9ZnVuY3Rpb24gcU8oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBqMW4oZSl7cmV0dXJuIEJQKCksd24oKE5QZSgpLEFQZSksZSl9ZnVuY3Rpb24gVjFuKCl7cmV0dXJuIEJQKCksUChJKFZZLDEpLFcsMzg3LDAsW1dZLFlPLGpZXSl9cCgzODcsMjIsezM6MSwzNDoxLDIyOjEsMzg3OjF9LHFPKTt2YXIgV1ksWU8salksVlk9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiU2VsZkxvb3BEaXN0cmlidXRpb25TdHJhdGVneSIsMzg3LGduLFYxbixqMW4pO2Z1bmN0aW9uIE5QZSgpe05QZT1GLEFQZT15bigoQlAoKSxQKEkoVlksMSksVywzODcsMCxbV1ksWU8salldKSkpfXZhciBBUGU7ZnVuY3Rpb24gdHYoKXt0dj1GLEpPPW5ldyBLTygiU1RBQ0tFRCIsMCksWE89bmV3IEtPKCJSRVZFUlNFX1NUQUNLRUQiLDEpLEgzPW5ldyBLTygiU0VRVUVOQ0VEIiwyKX1mdW5jdGlvbiBLTyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHExbihlKXtyZXR1cm4gdHYoKSx3bigoTFBlKCksa1BlKSxlKX1mdW5jdGlvbiBZMW4oKXtyZXR1cm4gdHYoKSxQKEkocVksMSksVywzNDksMCxbSk8sWE8sSDNdKX1wKDM0OSwyMix7MzoxLDM0OjEsMjI6MSwzNDk6MX0sS08pO3ZhciBYTyxIMyxKTyxxWT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJTZWxmTG9vcE9yZGVyaW5nU3RyYXRlZ3kiLDM0OSxnbixZMW4scTFuKTtmdW5jdGlvbiBMUGUoKXtMUGU9RixrUGU9eW4oKHR2KCksUChJKHFZLDEpLFcsMzQ5LDAsW0pPLFhPLEgzXSkpKX12YXIga1BlO2Z1bmN0aW9uIEsxbihlLG4scil7cmV0dXJuIE9QZShlLG4scixlLm5vZGVUeXBlU3BhY2luZ09wdGlvbnNIb3Jpem9udGFsKX1mdW5jdGlvbiBPUGUoZSxuLHIsdCl7dmFyIG87cmV0dXJuIG89dFtuLm9yZGluYWxdW3Iub3JkaW5hbF0sUigkKHcoZS5ncmFwaF8wLG8pKSl9ZnVuY3Rpb24gWVkoZSxuLHIpe3ZhciB0LG8saSxzLHU7cmV0dXJuIHM9ZS50eXBlXzAsdT1uLnR5cGVfMCx0PXJbcy5vcmRpbmFsXVt1Lm9yZGluYWxdLG89JCh6ZihlLHQpKSxpPSQoemYobix0KSksUy5NYXRoLm1heCgoVmUobyksbyksKFZlKGkpLGkpKX1mdW5jdGlvbiBLWShlLG4scil7cmV0dXJuIE9QZShlLG4scixlLm5vZGVUeXBlU3BhY2luZ09wdGlvbnNWZXJ0aWNhbCl9ZnVuY3Rpb24gc2coZSxuLHIpe3JldHVybiBZWShuLHIsZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWwpfWZ1bmN0aW9uIFUzKGUsbixyLHQpe1RyKGUubm9kZVR5cGVTcGFjaW5nT3B0aW9uc1ZlcnRpY2FsW24ub3JkaW5hbF0sci5vcmRpbmFsLHQpLFRyKGUubm9kZVR5cGVTcGFjaW5nT3B0aW9uc1ZlcnRpY2FsW3Iub3JkaW5hbF0sbi5vcmRpbmFsLHQpfWZ1bmN0aW9uIG92KGUsbixyLHQsbyl7VHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWxbbi5vcmRpbmFsXSxyLm9yZGluYWwsdCksVHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWxbci5vcmRpbmFsXSxuLm9yZGluYWwsdCksVHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zSG9yaXpvbnRhbFtuLm9yZGluYWxdLHIub3JkaW5hbCxvKSxUcihlLm5vZGVUeXBlU3BhY2luZ09wdGlvbnNIb3Jpem9udGFsW3Iub3JkaW5hbF0sbi5vcmRpbmFsLG8pfWZ1bmN0aW9uIE1QZShlLG4scil7VHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWxbbi5vcmRpbmFsXSxuLm9yZGluYWwscil9ZnVuY3Rpb24gWk8oZSxuLHIsdCl7VHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWxbbi5vcmRpbmFsXSxuLm9yZGluYWwsciksVHIoZS5ub2RlVHlwZVNwYWNpbmdPcHRpb25zSG9yaXpvbnRhbFtuLm9yZGluYWxdLG4ub3JkaW5hbCx0KX1mdW5jdGlvbiBSUGUoZSl7dmFyIG47dGhpcy5ncmFwaF8wPWUsbj0oV2UoKSxQKEkoaTksMSksVywyNzMsMCxba3IsaXQsRnIsdGksWW8sTnNdKSkubGVuZ3RoLHRoaXMubm9kZVR5cGVTcGFjaW5nT3B0aW9uc0hvcml6b250YWw9Yl8ocU0sW1gsVkZdLFs2MDEsMTQ5XSwwLFtuLG5dLDIpLHRoaXMubm9kZVR5cGVTcGFjaW5nT3B0aW9uc1ZlcnRpY2FsPWJfKHFNLFtYLFZGXSxbNjAxLDE0OV0sMCxbbixuXSwyKSxaTyh0aGlzLGtyLChvZSgpLG9kKSxvZyksb3YodGhpcyxrcixpdCx0ZCxxXyksVTModGhpcyxrcix0aSx0ZCksVTModGhpcyxrcixGcix0ZCksb3YodGhpcyxrcixZbyxvZCxvZyksWk8odGhpcyxpdCxxbCxyZyksVTModGhpcyxpdCx0aSxxbCksVTModGhpcyxpdCxGcixxbCksb3YodGhpcyxpdCxZbyx0ZCxxXyksTVBlKHRoaXMsdGkscWwpLFUzKHRoaXMsdGksRnIscWwpLFUzKHRoaXMsdGksWW8sUE8pLE1QZSh0aGlzLEZyLFhFKSxvdih0aGlzLEZyLFlvLHV3LHN3KSxaTyh0aGlzLFlvLHFsLHFsKSxaTyh0aGlzLE5zLHFsLHJnKSxvdih0aGlzLE5zLGtyLHRkLHFfKSxvdih0aGlzLE5zLFlvLHRkLHFfKSxvdih0aGlzLE5zLGl0LHRkLHFfKX1mdW5jdGlvbiB6ZihlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9bnVsbCxfcihlLChvZSgpLE5QKSkmJihyPWEodyhlLE5QKSw5Niksci5oYXNQcm9wZXJ0eShuKSYmKHQ9ci5nZXRQcm9wZXJ0eShuKSkpLHQ9PW51bGwmJih0PXcoU3QoZSksbikpLHR9cCgzMTIsMSx7MzEyOjF9LFJQZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJTcGFjaW5ncyIsMzEyKTtmdW5jdGlvbiBkdygpe2R3PUYsZTc9bmV3IFFPKCJDT05TRVJWQVRJVkUiLDApLFhZPW5ldyBRTygiQ09OU0VSVkFUSVZFX1NPRlQiLDEpLGl2PW5ldyBRTygiU0xPUFBZIiwyKX1mdW5jdGlvbiBRTyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFgxbihlKXtyZXR1cm4gZHcoKSx3bigoRFBlKCksRlBlKSxlKX1mdW5jdGlvbiBKMW4oKXtyZXR1cm4gZHcoKSxQKEkoSlksMSksVywzNTAsMCxbZTcsWFksaXZdKX1wKDM1MCwyMix7MzoxLDM0OjEsMjI6MSwzNTA6MX0sUU8pO3ZhciBlNyxYWSxpdixKWT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLm9wdGlvbnMiLCJTcGxpbmVSb3V0aW5nTW9kZSIsMzUwLGduLEoxbixYMW4pO2Z1bmN0aW9uIERQZSgpe0RQZT1GLEZQZT15bigoZHcoKSxQKEkoSlksMSksVywzNTAsMCxbZTcsWFksaXZdKSkpfXZhciBGUGU7ZnVuY3Rpb24gR1AoKXtHUD1GLFFZPW5ldyBuNygiTk8iLDApLHI3PW5ldyBuNygiR1JFRURZIiwxKSxaWT1uZXcgbjcoIkxPT0tfQkFDSyIsMil9ZnVuY3Rpb24gbjcoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBaMW4oZSl7cmV0dXJuIEdQKCksd24oKHpQZSgpLCRQZSksZSl9ZnVuY3Rpb24gUTFuKCl7cmV0dXJuIEdQKCksUChJKGVLLDEpLFcsMzUyLDAsW1FZLHI3LFpZXSl9cCgzNTIsMjIsezM6MSwzNDoxLDIyOjEsMzUyOjF9LG43KTt2YXIgcjcsWlksUVksZUs9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5vcHRpb25zIiwiVmFsaWRpZnlTdHJhdGVneSIsMzUyLGduLFExbixaMW4pO2Z1bmN0aW9uIHpQZSgpe3pQZT1GLCRQZT15bigoR1AoKSxQKEkoZUssMSksVywzNTIsMCxbUVkscjcsWlldKSkpfXZhciAkUGU7ZnVuY3Rpb24gSFAoKXtIUD1GLG83PW5ldyB0NygiT0ZGIiwwKSxmdz1uZXcgdDcoIlNJTkdMRV9FREdFIiwxKSwkZj1uZXcgdDcoIk1VTFRJX0VER0UiLDIpfWZ1bmN0aW9uIHQ3KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZWRuKGUpe3JldHVybiBIUCgpLHduKChCUGUoKSxHUGUpLGUpfWZ1bmN0aW9uIG5kbigpe3JldHVybiBIUCgpLFAoSShuSywxKSxXLDM4OCwwLFtvNyxmdywkZl0pfXAoMzg4LDIyLHszOjEsMzQ6MSwyMjoxLDM4ODoxfSx0Nyk7dmFyICRmLG83LGZ3LG5LPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQub3B0aW9ucyIsIldyYXBwaW5nU3RyYXRlZ3kiLDM4OCxnbixuZG4sZWRuKTtmdW5jdGlvbiBCUGUoKXtCUGU9RixHUGU9eW4oKEhQKCksUChJKG5LLDEpLFcsMzg4LDAsW283LGZ3LCRmXSkpKX12YXIgR1BlO2Z1bmN0aW9uIEhQZSgpe0hQZT1GLFdQZT1XaShuZXcgSHIsKHh0KCksaG8pLChrdCgpLGgzKSl9ZnVuY3Rpb24gcksoZSxuKXt2YXIgcix0LG87aWYoIWUudmlzaXRlZFtuLmlkXzBdKXtmb3IoZS52aXNpdGVkW24uaWRfMF09ITAsZS5hY3RpdmVbbi5pZF8wXT0hMCx0PW5ldyBYZShRZShScihuKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXI9YSh0bih0KSwxOCksIXp0KHIpJiYobz1yLnRhcmdldC5vd25lcixlLmFjdGl2ZVtvLmlkXzBdP2VlKGUuZWRnZXNUb0JlUmV2ZXJzZWQscik6cksoZSxvKSk7ZS5hY3RpdmVbbi5pZF8wXT0hMX19ZnVuY3Rpb24gcmRuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtO2ZvcihyLmJlZ2luKCJEZXB0aC1maXJzdCBjeWNsZSByZW1vdmFsIiwxKSxmPW4ubGF5ZXJsZXNzTm9kZXMsZD1mLmFycmF5Lmxlbmd0aCxlLnNvdXJjZXM9bmV3IFEsZS52aXNpdGVkPUIoeWEseHUsMjgsZCwxNiwxKSxlLmFjdGl2ZT1CKHlhLHh1LDI4LGQsMTYsMSksZS5lZGdlc1RvQmVSZXZlcnNlZD1uZXcgUSxzPTAsXz1uZXcgVChmKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTApLGMuaWRfMD1zLEptKHR0KGMpKSYmZWUoZS5zb3VyY2VzLGMpLCsrcztmb3IobT1uZXcgVChlLnNvdXJjZXMpO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyloPWEoQyhtKSwxMCkscksoZSxoKTtmb3IoaT0wO2k8ZDtpKyspZS52aXNpdGVkW2ldfHwodT0oQWUoaSxmLmFycmF5Lmxlbmd0aCksYShmLmFycmF5W2ldLDEwKSkscksoZSx1KSk7Zm9yKG89bmV3IFQoZS5lZGdlc1RvQmVSZXZlcnNlZCk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE4KSxHMSh0LCEwKSxqKG4sKEsoKSxOMyksKHplKCksITApKTtlLnNvdXJjZXM9bnVsbCxlLnZpc2l0ZWQ9bnVsbCxlLmFjdGl2ZT1udWxsLGUuZWRnZXNUb0JlUmV2ZXJzZWQ9bnVsbCxyLmRvbmVfMSgpfWZ1bmN0aW9uIFVQZSgpe0hQZSgpfXAoMTM5OCwxLFd0LFVQZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLFdQZX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cmRuKHRoaXMsYShuLDM2KSxyKX07dmFyIFdQZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDFjeWNsZXMiLCJEZXB0aEZpcnN0Q3ljbGVCcmVha2VyIiwxMzk4KTtmdW5jdGlvbiB0Sygpe3RLPUYsalBlPVdpKG5ldyBIciwoeHQoKSxobyksKGt0KCksaDMpKX1mdW5jdGlvbiB0ZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam4sU3IsY2EsY28sV2E7Zm9yKHIuYmVnaW4oIkdyZWVkeSBjeWNsZSByZW1vdmFsIiwxKSxrPW4ubGF5ZXJsZXNzTm9kZXMsV2E9ay5hcnJheS5sZW5ndGgsZS5pbmRlZz1CKGhuLGtuLDI4LFdhLDE1LDEpLGUub3V0ZGVnPUIoaG4sa24sMjgsV2EsMTUsMSksZS5tYXJrPUIoaG4sa24sMjgsV2EsMTUsMSksXz0wLHg9bmV3IFQoayk7eC5pPHgudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoRT1hKEMoeCksMTApLEUuaWRfMD1fLHdlPW5ldyBUKEUucG9ydHMpO3dlLmk8d2UudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IocT1hKEMod2UpLDEyKSx1PW5ldyBUKHEuaW5jb21pbmdFZGdlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKHUpLDE4KSx0LnNvdXJjZS5vd25lciE9RSYmKG5uPWEodyh0LChvZSgpLGx3KSksMTcpLnZhbHVlXzAsZS5pbmRlZ1tfXSs9bm4+MD9ubisxOjEpO2ZvcihzPW5ldyBUKHEub3V0Z29pbmdFZGdlcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKHMpLDE4KSx0LnRhcmdldC5vd25lciE9RSYmKG5uPWEodyh0LChvZSgpLGx3KSksMTcpLnZhbHVlXzAsZS5vdXRkZWdbX10rPW5uPjA/bm4rMToxKX1lLm91dGRlZ1tfXT09MD9MbihlLnNpbmtzLEUpOmUuaW5kZWdbX109PTAmJkxuKGUuc291cmNlcyxFKSwrK199Zm9yKHk9LTEsbT0xLGY9bmV3IFEsZS5yYW5kb21fMD1hKHcobiwoSygpLFZoKSksMjM0KTtXYT4wOyl7Zm9yKDtlLnNpbmtzLnNpemVfMCE9MDspU3I9YShvayhlLnNpbmtzKSwxMCksZS5tYXJrW1NyLmlkXzBdPXktLSxvSyhlLFNyKSwtLVdhO2Zvcig7ZS5zb3VyY2VzLnNpemVfMCE9MDspY2E9YShvayhlLnNvdXJjZXMpLDEwKSxlLm1hcmtbY2EuaWRfMF09bSsrLG9LKGUsY2EpLC0tV2E7aWYoV2E+MCl7Zm9yKGg9YnQsQT1uZXcgVChrKTtBLmk8QS50aGlzJDAxLmFycmF5Lmxlbmd0aDspRT1hKEMoQSksMTApLGUubWFya1tFLmlkXzBdPT0wJiYoTT1lLm91dGRlZ1tFLmlkXzBdLWUuaW5kZWdbRS5pZF8wXSxNPj1oJiYoTT5oJiYoZi5hcnJheS5sZW5ndGg9MCxoPU0pLFJlKGYuYXJyYXksRSkpKTtkPWUuY2hvb3NlTm9kZVdpdGhNYXhPdXRmbG93KGYpLGUubWFya1tkLmlkXzBdPW0rKyxvSyhlLGQpLC0tV2F9fWZvcihqbj1rLmFycmF5Lmxlbmd0aCsxLF89MDtfPGsuYXJyYXkubGVuZ3RoO18rKyllLm1hcmtbX108MCYmKGUubWFya1tfXSs9am4pO2Zvcih2PW5ldyBUKGspO3YuaTx2LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoRT1hKEModiksMTApLEZlPXF3ZShFLnBvcnRzKSxuZT1GZSx2ZT0wLERlPW5lLmxlbmd0aDt2ZTxEZTsrK3ZlKWZvcihxPW5lW3ZlXSxIPWN1KHEub3V0Z29pbmdFZGdlcyksbz1ILGk9MCxjPW8ubGVuZ3RoO2k8YzsrK2kpdD1vW2ldLGNvPXQudGFyZ2V0Lm93bmVyLmlkXzAsZS5tYXJrW0UuaWRfMF0+ZS5tYXJrW2NvXSYmKEcxKHQsITApLGoobixOMywoemUoKSwhMCkpKTtlLmluZGVnPW51bGwsZS5vdXRkZWc9bnVsbCxlLm1hcms9bnVsbCxrYShlLnNvdXJjZXMpLGthKGUuc2lua3MpLHIuZG9uZV8xKCl9ZnVuY3Rpb24gb0soZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO2ZvcihjPW5ldyBUKG4ucG9ydHMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodT1hKEMoYyksMTIpLG89bmV3IExzKHUuY29ubmVjdGVkRWRnZXMpO3hvKG8uZmlyc3RJdGVyYXRvcil8fHhvKG8uc2Vjb25kSXRlcmF0b3IpOyl0PWEoeG8oby5maXJzdEl0ZXJhdG9yKT9DKG8uZmlyc3RJdGVyYXRvcik6QyhvLnNlY29uZEl0ZXJhdG9yKSwxOCkscj10LnNvdXJjZT09dT90LnRhcmdldDp0LnNvdXJjZSxpPXIub3duZXIsbiE9aSYmKF89YSh3KHQsKG9lKCksbHcpKSwxNykudmFsdWVfMCxfPDAmJihfPTApLHM9aS5pZF8wLGUubWFya1tzXT09MCYmKHQudGFyZ2V0PT1yPyhlLmluZGVnW3NdLT1fKzEsZS5pbmRlZ1tzXTw9MCYmZS5vdXRkZWdbc10+MCYmTG4oZS5zb3VyY2VzLGkpKTooZS5vdXRkZWdbc10tPV8rMSxlLm91dGRlZ1tzXTw9MCYmZS5pbmRlZ1tzXT4wJiZMbihlLnNpbmtzLGkpKSkpfWZ1bmN0aW9uIGlLKCl7dEsoKSx0aGlzLnNvdXJjZXM9bmV3IHByLHRoaXMuc2lua3M9bmV3IHByfXAoNzkzLDEsV3QsaUspLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDM2KSxqUGV9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe3Rkbih0aGlzLGEobiwzNikscil9LGwuY2hvb3NlTm9kZVdpdGhNYXhPdXRmbG93PWZ1bmN0aW9uKG4pe3JldHVybiBhKGxlKG4saXgodGhpcy5yYW5kb21fMCxuLmFycmF5Lmxlbmd0aCkpLDEwKX07dmFyIGpQZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDFjeWNsZXMiLCJHcmVlZHlDeWNsZUJyZWFrZXIiLDc5Myk7ZnVuY3Rpb24gVlBlKCl7dEsoKSxpSy5jYWxsKHRoaXMpfXAoMTQwMSw3OTMsV3QsVlBlKSxsLmNob29zZU5vZGVXaXRoTWF4T3V0Zmxvdz1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtmb3IoaT1udWxsLHI9cW4sbz1uZXcgVChuKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTApLF9yKHQsKEsoKSxycikpJiZhKHcodCxyciksMTcpLnZhbHVlXzA8ciYmKHI9YSh3KHQscnIpLDE3KS52YWx1ZV8wLGk9dCk7cmV0dXJuIGl8fGEobGUobixpeCh0aGlzLnJhbmRvbV8wLG4uYXJyYXkubGVuZ3RoKSksMTApfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDFjeWNsZXMiLCJHcmVlZHlNb2RlbE9yZGVyQ3ljbGVCcmVha2VyIiwxNDAxKTtmdW5jdGlvbiBxUGUoKXtxUGU9RixYUGU9V2koTW4obmV3IEhyLCh4dCgpLGpsKSwoa3QoKSxkOSkpLGhvLGgzKX1mdW5jdGlvbiBZUGUoZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKG4uaWRfMD0tMSx1PVUxKG4sKHF0KCkscGkpKS5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspZm9yKHM9YSh1Lm5leHRfMSgpLDEyKSxvPW5ldyBUKHMub3V0Z29pbmdFZGdlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE4KSxpPXQudGFyZ2V0Lm93bmVyLG4hPWkmJihpLmlkXzA8MD9yLmFkZF8yKHQpOmkuaWRfMD4wJiZZUGUoZSxpLHIpKTtuLmlkXzA9MH1mdW5jdGlvbiBvZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7Zm9yKHIuYmVnaW4oIkludGVyYWN0aXZlIGN5Y2xlIGJyZWFraW5nIiwxKSxmPW5ldyBRLG09bmV3IFQobi5sYXllcmxlc3NOb2Rlcyk7bS5pPG0udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihoPWEoQyhtKSwxMCksaC5pZF8wPTEseT16VyhoKS54XzAsZD1VMShoLChxdCgpLHBpKSkuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KWZvcihfPWEoZC5uZXh0XzEoKSwxMiksaT1uZXcgVChfLm91dGdvaW5nRWRnZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhpKSwxOCksRT10LnRhcmdldC5vd25lcixFIT1oJiYodj16VyhFKS54XzAsdjx5JiZSZShmLmFycmF5LHQpKTtmb3Iocz1uZXcgVChmKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMocyksMTgpLEcxKHQsITApO2ZvcihmLmFycmF5Lmxlbmd0aD0wLGM9bmV3IFQobi5sYXllcmxlc3NOb2Rlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDEwKSx1LmlkXzA+MCYmWVBlKGUsdSxmKTtmb3Iobz1uZXcgVChmKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTgpLEcxKHQsITApO2YuYXJyYXkubGVuZ3RoPTAsci5kb25lXzEoKX1mdW5jdGlvbiBLUGUoKXtxUGUoKX1wKDEzOTksMSxXdCxLUGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDM2KSxYUGV9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe29kbih0aGlzLGEobiwzNikscil9O3ZhciBYUGU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAxY3ljbGVzIiwiSW50ZXJhY3RpdmVDeWNsZUJyZWFrZXIiLDEzOTkpO2Z1bmN0aW9uIEpQZSgpe0pQZT1GLGVOZT1XaShuZXcgSHIsKHh0KCksaG8pLChrdCgpLGgzKSl9ZnVuY3Rpb24gWlBlKGUsbixyKXt2YXIgdDtzd2l0Y2godD0wLGEodyhuLChvZSgpLEVpKSksMTcxKS5vcmRpbmFsKXtjYXNlIDI6dD0yKi1yK2UuZmlyc3RTZXBhcmF0ZU1vZGVsT3JkZXIsKytlLmZpcnN0U2VwYXJhdGVNb2RlbE9yZGVyO2JyZWFrO2Nhc2UgMTp0PS1yO2JyZWFrO2Nhc2UgMzp0PXI7YnJlYWs7Y2FzZSA0OnQ9MipyK2UubGFzdFNlcGFyYXRlTW9kZWxPcmRlciwrK2UubGFzdFNlcGFyYXRlTW9kZWxPcmRlcn1yZXR1cm4gX3IobiwoSygpLHJyKSkmJih0Kz1hKHcobixyciksMTcpLnZhbHVlXzApLHR9ZnVuY3Rpb24gaWRuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2ZvcihyLmJlZ2luKCJNb2RlbCBvcmRlciBjeWNsZSBicmVha2luZyIsMSksZS5maXJzdFNlcGFyYXRlTW9kZWxPcmRlcj0wLGUubGFzdFNlcGFyYXRlTW9kZWxPcmRlcj0wLG09bmV3IFEsZD1uLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aCxfPW5ldyBUKG4ubGF5ZXJsZXNzTm9kZXMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSwxMCksX3IoYywoSygpLHJyKSkmJihkPVMuTWF0aC5tYXgoZCxhKHcoYyxyciksMTcpLnZhbHVlXzArMSkpO2ZvcihFPW5ldyBUKG4ubGF5ZXJsZXNzTm9kZXMpO0UuaTxFLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoeT1hKEMoRSksMTApLHM9WlBlKGUseSxkKSxoPVUxKHksKHF0KCkscGkpKS5pdGVyYXRvcl8wKCk7aC5oYXNOZXh0XzAoKTspZm9yKGY9YShoLm5leHRfMSgpLDEyKSxpPW5ldyBUKGYub3V0Z29pbmdFZGdlcyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKGkpLDE4KSx2PXQudGFyZ2V0Lm93bmVyLHU9WlBlKGUsdixkKSx1PHMmJlJlKG0uYXJyYXksdCk7Zm9yKG89bmV3IFQobSk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE4KSxHMSh0LCEwKSxqKG4sKEsoKSxOMyksKHplKCksITApKTttLmFycmF5Lmxlbmd0aD0wLHIuZG9uZV8xKCl9ZnVuY3Rpb24gUVBlKCl7SlBlKCl9cCgxNDAwLDEsV3QsUVBlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwzNiksZU5lfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtpZG4odGhpcyxhKG4sMzYpLHIpfSxsLmZpcnN0U2VwYXJhdGVNb2RlbE9yZGVyPTAsbC5sYXN0U2VwYXJhdGVNb2RlbE9yZGVyPTA7dmFyIGVOZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDFjeWNsZXMiLCJNb2RlbE9yZGVyQ3ljbGVCcmVha2VyIiwxNDAwKTtmdW5jdGlvbiBhSygpe2FLPUYsck5lPU1uKE1uKE1uKG5ldyBIciwoeHQoKSxqbCksKGt0KCksV3ApKSxPdSxTZiksSm8sdmYpfWZ1bmN0aW9uIGFkbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4O2ZvcihyLmJlZ2luKCJCcmVhZHRoIGZpcnN0IG1vZGVsIG9yZGVyIGxheWVyaW5nIiwxKSxlLmxheWVyZWRHcmFwaD1uLHY9bmV3IFEsRT1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcmxlc3NOb2Rlcyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KW09YShDKEUpLDEwKSxtLnR5cGVfMD09KFdlKCksa3IpJiZSZSh2LmFycmF5LG0pO2ZvcihOZSgpLERyKHYsbmV3IHROZSksYz0hMCxvPW5ldyBvaShlLmxheWVyZWRHcmFwaCksdD1udWxsLGVlKGUubGF5ZXJlZEdyYXBoLmxheWVycyxvKSx5PW5ldyBUKHYpO3kuaTx5LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihtPWEoQyh5KSwxMCksYylodChtLG8pLGM9ITE7ZWxzZXtmb3IodT1uZXcgWGUoUWUodHQobSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHUpOylpPWEodG4odSksMTgpLChpLnNvdXJjZS5vd25lci50eXBlXzA9PShXZSgpLGtyKSYmaS5zb3VyY2Uub3duZXIubGF5ZXI9PW98fGkuc291cmNlLm93bmVyLnR5cGVfMD09WW8mJmEodG4obmV3IFhlKFFlKHR0KGkuc291cmNlLm93bmVyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KS5zb3VyY2Uub3duZXIubGF5ZXI9PW8pJiYodD1uZXcgb2koZS5sYXllcmVkR3JhcGgpLGVlKGUubGF5ZXJlZEdyYXBoLmxheWVycyx0KSxvPW5ldyBvaShlLmxheWVyZWRHcmFwaCksZWUoZS5sYXllcmVkR3JhcGgubGF5ZXJzLG8pKTtmb3Iocz1uZXcgWGUoUWUodHQobSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHMpOylpPWEodG4ocyksMTgpLGkuc291cmNlLm93bmVyLnR5cGVfMD09KFdlKCksWW8pJiYhaS5zb3VyY2Uub3duZXIubGF5ZXImJmh0KGkuc291cmNlLm93bmVyLHQpO2h0KG0sbyl9Zm9yKGUubGF5ZXJlZEdyYXBoLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aD0wLHg9bmV3IFEsZj1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcnMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhmKSwzMCksXy5ub2Rlcy5hcnJheS5sZW5ndGg9PTAmJlJlKHguYXJyYXksXyk7Zm9yKHl6KGUubGF5ZXJlZEdyYXBoLmxheWVycyx4KSxoPTAsZD1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcnMpO2QuaTxkLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhkKSwzMCksXy5pZF8wPWgsKytoO3IuZG9uZV8xKCl9ZnVuY3Rpb24gbk5lKCl7YUsoKX1mdW5jdGlvbiBsZG4oZSxuKXtpZihhSygpLF9yKGUsKEsoKSxycikpJiZfcihuLHJyKSlyZXR1cm4gcW8oYSh3KGUscnIpLDE3KS52YWx1ZV8wLGEodyhuLHJyKSwxNykudmFsdWVfMCk7dGhyb3cgYihuZXcgZW0oIlRoZSBCRiBtb2RlbCBvcmRlciBsYXllciBhc3NpZ25lciByZXF1aXJlcyBhbGwgcmVhbCBub2RlcyB0byBoYXZlIGEgbW9kZWwgb3JkZXIuIikpfXAoMTQxMywxLFd0LG5OZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLHJOZX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7YWRuKHRoaXMsYShuLDM2KSxyKX07dmFyIHJOZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJCcmVhZHRoRmlyc3RNb2RlbE9yZGVyTGF5ZXJlciIsMTQxMyk7ZnVuY3Rpb24gdE5lKCl7fXAoMTQxNCwxLE5uLHROZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gbGRuKGEobiwxMCksYShyLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAybGF5ZXJzIiwiQnJlYWR0aEZpcnN0TW9kZWxPcmRlckxheWVyZXIvbGFtYmRhJDAkVHlwZSIsMTQxNCk7ZnVuY3Rpb24gb05lKCl7b05lPUYsc05lPU1uKE1uKE1uKG5ldyBIciwoeHQoKSxqbCksKGt0KCksV3ApKSxPdSxTZiksSm8sdmYpfWZ1bmN0aW9uIHNkbihlLG4pe3ZhciByLHQsbztmb3IodD1uZXcgWGUoUWUoUnIoZSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylpZihyPWEodG4odCksMTgpLG89ci50YXJnZXQub3duZXIsby5sYXllcj09bilyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiB1ZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3IodD1hKFpuKGUuaW5Ub3BvLG4pLDE1KSxvPWEoWm4oZS5pblRvcG8sciksMTUpLGk9dC5saXN0SXRlcmF0b3JfMSh0LnNpemVfMSgpKSxzPW8ubGlzdEl0ZXJhdG9yXzEoby5zaXplXzEoKSk7aS5oYXNQcmV2aW91cygpJiZzLmhhc1ByZXZpb3VzKCk7KWlmKHU9YShpLnByZXZpb3VzXzAoKSwxNyksYz1hKHMucHJldmlvdXNfMCgpLDE3KSx1IT1jKXJldHVybiBxbyh1LnZhbHVlXzAsYy52YWx1ZV8wKTtyZXR1cm4haS5oYXNOZXh0XzAoKSYmIXMuaGFzTmV4dF8wKCk/MDppLmhhc05leHRfMCgpPzE6LTF9ZnVuY3Rpb24gaU5lKGUsbil7dmFyIHI7cmV0dXJuIHI9bmV3IG9pKGUpLFJlKG4uYXJyYXkscikscn1mdW5jdGlvbiBhTmUoZSxuLHIpe3ZhciB0LG8saSxzLHU7aWYoIWUubm9kZU1hcmtbci5pZF8wXSl7Zm9yKG89bmV3IFhlKFFlKFJyKHIpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihvKTspe2Zvcih0PWEodG4obyksMTgpLHU9dC50YXJnZXQub3duZXIscz1uZXcgWGUoUWUodHQodSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHMpOylpPWEodG4ocyksMTgpLGkuc291cmNlLm93bmVyPT1uJiYoZS5lZGdlTWFya1tpLmlkXzBdPSEwKTthTmUoZSxuLHUpfWUubm9kZU1hcmtbci5pZF8wXT0hMH19ZnVuY3Rpb24gY2RuKGUsbixyKXtyZXR1cm4tcW8oZS50b3BvT3JkW24uaWRfMF0sZS50b3BvT3JkW3IuaWRfMF0pfWZ1bmN0aW9uIF9kbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEg7aWYoci5iZWdpbigiQ29mZm1hbi1HcmFoYW0gTGF5ZXJpbmciLDEpLG4ubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPT0wKXtyLmRvbmVfMSgpO3JldHVybn1mb3IoSD1hKHcobiwob2UoKSxlWSkpLDE3KS52YWx1ZV8wLGM9MCxzPTAsaD1uZXcgVChuLmxheWVybGVzc05vZGVzKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKGY9YShDKGgpLDEwKSxmLmlkXzA9YysrLGk9bmV3IFhlKFFlKFJyKGYpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspbz1hKHRuKGkpLDE4KSxvLmlkXzA9cysrO2ZvcihlLm5vZGVNYXJrPUIoeWEseHUsMjgsYywxNiwxKSxlLmVkZ2VNYXJrPUIoeWEseHUsMjgscywxNiwxKSxlLmluRGVnPUIoaG4sa24sMjgsYywxNSwxKSxlLm91dERlZz1CKGhuLGtuLDI4LGMsMTUsMSksZS50b3BvT3JkPUIoaG4sa24sMjgsYywxNSwxKSx0SShlLmluVG9wbyksZGRuKGUsbikseT1uZXcgb3gobmV3IHVOZShlKSksTT1uZXcgVChuLmxheWVybGVzc05vZGVzKTtNLmk8TS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihBPWEoQyhNKSwxMCksaT1uZXcgWGUoUWUodHQoQSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylvPWEodG4oaSksMTgpLGUuZWRnZU1hcmtbby5pZF8wXXx8KytlLmluRGVnW0EuaWRfMF07ZS5pbkRlZ1tBLmlkXzBdPT0wJiZ4aChFeSh5LEEpLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKX1mb3IodT0wO3kuaGVhcC5hcnJheS5sZW5ndGghPTA7KWZvcihBPWEoZGsoeSksMTApLGUudG9wb09yZFtBLmlkXzBdPXUrKyxpPW5ldyBYZShRZShScihBKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24oaSk7KW89YSh0bihpKSwxOCksIWUuZWRnZU1hcmtbby5pZF8wXSYmKHY9by50YXJnZXQub3duZXIsLS1lLmluRGVnW3YuaWRfMF0sYmUoZS5pblRvcG8sdixKKGUudG9wb09yZFtBLmlkXzBdKSksZS5pbkRlZ1t2LmlkXzBdPT0wJiZ4aChFeSh5LHYpLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKSk7Zm9yKG09bmV3IG94KG5ldyBjTmUoZSkpLGs9bmV3IFQobi5sYXllcmxlc3NOb2Rlcyk7ay5pPGsudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoQT1hKEMoayksMTApLGk9bmV3IFhlKFFlKFJyKEEpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspbz1hKHRuKGkpLDE4KSxlLmVkZ2VNYXJrW28uaWRfMF18fCsrZS5vdXREZWdbQS5pZF8wXTtlLm91dERlZ1tBLmlkXzBdPT0wJiZ4aChFeShtLEEpLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKX1mb3IoZD1uZXcgUSx0PWlOZShuLGQpO20uaGVhcC5hcnJheS5sZW5ndGghPTA7KWZvcih4PWEoZGsobSksMTApLCh0Lm5vZGVzLmFycmF5Lmxlbmd0aD49SHx8IXNkbih4LHQpKSYmKHQ9aU5lKG4sZCkpLGh0KHgsdCksaT1uZXcgWGUoUWUodHQoeCkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylvPWEodG4oaSksMTgpLCFlLmVkZ2VNYXJrW28uaWRfMF0mJihFPW8uc291cmNlLm93bmVyLC0tZS5vdXREZWdbRS5pZF8wXSxlLm91dERlZ1tFLmlkXzBdPT0wJiZ4aChFeShtLEUpLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKSk7Zm9yKF89ZC5hcnJheS5sZW5ndGgtMTtfPj0wOy0tXyllZShuLmxheWVycywoQWUoXyxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W19dLDMwKSkpO24ubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPTAsci5kb25lXzEoKX1mdW5jdGlvbiBkZG4oZSxuKXt2YXIgcix0LG8saTtmb3IoaT1uZXcgVChuLmxheWVybGVzc05vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKG89YShDKGkpLDEwKSxaMihlLm5vZGVNYXJrKSx0PW5ldyBYZShRZShScihvKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXI9YSh0bih0KSwxOCksYU5lKGUsbyxyLnRhcmdldC5vd25lcil9ZnVuY3Rpb24gbE5lKCl7b05lKCksdGhpcy5pblRvcG89bmV3IFI2fXAoMTQwNCwxLFd0LGxOZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLHNOZX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7X2RuKHRoaXMsYShuLDM2KSxyKX07dmFyIHNOZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJDb2ZmbWFuR3JhaGFtTGF5ZXJlciIsMTQwNCk7ZnVuY3Rpb24gdU5lKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNDA1LDEsTm4sdU5lKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiB1ZG4odGhpcy4kJG91dGVyXzAsYShuLDEwKSxhKHIsMTApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJDb2ZmbWFuR3JhaGFtTGF5ZXJlci8wbWV0aG9kcmVmJGNvbXBhcmVOb2Rlc0luVG9wbyRUeXBlIiwxNDA1KTtmdW5jdGlvbiBjTmUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE0MDYsMSxObixjTmUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIGNkbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wMmxheWVycyIsIkNvZmZtYW5HcmFoYW1MYXllcmVyL2xhbWJkYSQxJFR5cGUiLDE0MDYpO2Z1bmN0aW9uIGxLKCl7bEs9RixmTmU9TW4oTW4oTW4obmV3IEhyLCh4dCgpLGpsKSwoa3QoKSxXcCkpLE91LFNmKSxKbyx2Zil9ZnVuY3Rpb24gc0soZSxuLHIpe3ZhciB0LG87Zm9yKG48ZS5sYXllcmVkR3JhcGgubGF5ZXJzLmFycmF5Lmxlbmd0aD8oZS5jdXJyZW50TGF5ZXI9YShsZShlLmxheWVyZWRHcmFwaC5sYXllcnMsbiksMzApLGUuY3VycmVudER1bW15TGF5ZXI9YShsZShlLmxheWVyZWRHcmFwaC5sYXllcnMsbi0xKSwzMCksZS5jdXJyZW50TGF5ZXJJZD1uKTooZS5jdXJyZW50RHVtbXlMYXllcj1uZXcgb2koZS5sYXllcmVkR3JhcGgpLGUuY3VycmVudER1bW15TGF5ZXIuaWRfMD1uLTEsZWUoZS5sYXllcmVkR3JhcGgubGF5ZXJzLGUuY3VycmVudER1bW15TGF5ZXIpLGUuY3VycmVudExheWVyPW5ldyBvaShlLmxheWVyZWRHcmFwaCksZS5jdXJyZW50TGF5ZXIuaWRfMD1uLGVlKGUubGF5ZXJlZEdyYXBoLmxheWVycyxlLmN1cnJlbnRMYXllciksZS5jdXJyZW50TGF5ZXJJZD1uKSxodChyLGUuY3VycmVudExheWVyKSxvPW5ldyBYZShRZSh0dChyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSwxOCksIXQuc291cmNlLm93bmVyLmxheWVyJiZ0LnNvdXJjZS5vd25lci50eXBlXzA9PShXZSgpLFlvKSYmaHQodC5zb3VyY2Uub3duZXIsZS5jdXJyZW50RHVtbXlMYXllcil9ZnVuY3Rpb24gX05lKGUsbil7dmFyIHIsdCxvO2ZvcihvPWUsdD1uZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylyPWEodG4odCksMTgpLHIuc291cmNlLm93bmVyLmxheWVyJiYobz1TLk1hdGgubWF4KG8sci5zb3VyY2Uub3duZXIubGF5ZXIuaWRfMCkpO3JldHVybiBvfWZ1bmN0aW9uIGZkbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHM9bmV3IFhlKFFlKHR0KG4pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihzKTspaWYoaT1hKHRuKHMpLDE4KSxlLm5vZGVzVG9QbGFjZS5zaXplXzA9PTA/KG89aS5zb3VyY2Uub3duZXIudHlwZV8wPT0oV2UoKSxrcikmJiEhaS5zb3VyY2Uub3duZXIubGF5ZXImJmkuc291cmNlLm93bmVyLmxheWVyLmlkXzA9PWUuY3VycmVudExheWVySWQsX24obmV3IFhlKFFlKHR0KGkuc291cmNlLm93bmVyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpPyhyPWEodG4obmV3IFhlKFFlKHR0KGkuc291cmNlLm93bmVyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLDE4KS5zb3VyY2Uub3duZXIubGF5ZXIsdD1pLnNvdXJjZS5vd25lci50eXBlXzA9PVlvJiYhIXImJnIuaWRfMD09ZS5jdXJyZW50TGF5ZXJJZCk6dD0hMSk6KG89aS5zb3VyY2Uub3duZXIudHlwZV8wPT0oV2UoKSxrcikmJmkuc291cmNlLm93bmVyLmlkXzA9PWUuY3VycmVudExheWVySWQsdD1pLnNvdXJjZS5vd25lci50eXBlXzA9PVlvJiZhKHRuKG5ldyBYZShRZSh0dChpLnNvdXJjZS5vd25lcikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSwxOCkuc291cmNlLm93bmVyLmlkXzA9PWUuY3VycmVudExheWVySWQpLG98fHQpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gdUsoZSl7dmFyIG4scix0LG87Zm9yKGUubWF4VG9QbGFjZT0wLG89ZG4oZS5ub2Rlc1RvUGxhY2UsMCk7by5jdXJyZW50Tm9kZSE9by50aGlzJDAxLnRhaWw7KXQ9YSh1bihvKSwxMCksdC5pZF8wPj1lLmxheWVyZWRHcmFwaC5sYXllcnMuYXJyYXkubGVuZ3RoJiYobj1uZXcgb2koZS5sYXllcmVkR3JhcGgpLG4uaWRfMD10LmlkXzAtMSxlZShlLmxheWVyZWRHcmFwaC5sYXllcnMsbikscj1uZXcgb2koZS5sYXllcmVkR3JhcGgpLHIuaWRfMD10LmlkXzAsZWUoZS5sYXllcmVkR3JhcGgubGF5ZXJzLHIpKSxodCh0LGEobGUoZS5sYXllcmVkR3JhcGgubGF5ZXJzLHQuaWRfMCksMzApKX1mdW5jdGlvbiBwZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKHIuYmVnaW4oIkRlcHRoIGZpcnN0IG1vZGVsIG9yZGVyIGxheWVyaW5nIiwxKSxlLmxheWVyZWRHcmFwaD1uLHY9bmV3IFEsRT1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcmxlc3NOb2Rlcyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KW09YShDKEUpLDEwKSxtLnR5cGVfMD09KFdlKCksa3IpJiZSZSh2LmFycmF5LG0pO2ZvcihOZSgpLERyKHYsbmV3IHBOZSkscz0hMCxlLmN1cnJlbnRMYXllcj1uZXcgb2koZS5sYXllcmVkR3JhcGgpLGUuY3VycmVudER1bW15TGF5ZXI9bnVsbCxlZShlLmxheWVyZWRHcmFwaC5sYXllcnMsZS5jdXJyZW50TGF5ZXIpLGUuY3VycmVudExheWVyLmlkXzA9MCxlLmN1cnJlbnRMYXllcklkPTAsZS5ub2Rlc1RvUGxhY2U9bmV3IHByLHk9bmV3IFQodik7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKG09YShDKHkpLDEwKSxzKWh0KG0sZS5jdXJyZW50TGF5ZXIpLHM9ITE7ZWxzZSBpZihmZG4oZSxtKSlpZihoPWUuY3VycmVudExheWVySWQsaD1fTmUoaCxtKSx0PWgrMixkPWgtZS5jdXJyZW50TGF5ZXJJZCxlLm5vZGVzVG9QbGFjZS5zaXplXzA9PTApc0soZSx0LG0pO2Vsc2UgaWYoZD4wKXtmb3Ioaz1kbihlLm5vZGVzVG9QbGFjZSwwKTtrLmN1cnJlbnROb2RlIT1rLnRoaXMkMDEudGFpbDspQT1hKHVuKGspLDEwKSxBLmlkXzArPWgtZS5tYXhUb1BsYWNlO3VLKGUpLGthKGUubm9kZXNUb1BsYWNlKSxzSyhlLHQsbSl9ZWxzZXtmb3IoTG4oZS5ub2Rlc1RvUGxhY2UsbSksbS5pZF8wPXQsZS5tYXhUb1BsYWNlPVMuTWF0aC5tYXgoZS5tYXhUb1BsYWNlLHQpLGk9bmV3IFhlKFFlKHR0KG0pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspbz1hKHRuKGkpLDE4KSwhby5zb3VyY2Uub3duZXIubGF5ZXImJm8uc291cmNlLm93bmVyLnR5cGVfMD09KFdlKCksWW8pJiYoTG4oZS5ub2Rlc1RvUGxhY2Usby5zb3VyY2Uub3duZXIpLG8uc291cmNlLm93bmVyLmlkXzA9dC0xKTtlLmN1cnJlbnRMYXllcklkPXR9ZWxzZSB1SyhlKSxrYShlLm5vZGVzVG9QbGFjZSksdD0wLF9uKG5ldyBYZShRZSh0dChtKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpPyhoPTAsaD1fTmUoaCxtKSx0PWgrMixzSyhlLHQsbSkpOihMbihlLm5vZGVzVG9QbGFjZSxtKSxtLmlkXzA9MCxlLm1heFRvUGxhY2U9Uy5NYXRoLm1heChlLm1heFRvUGxhY2UsMCksZS5jdXJyZW50TGF5ZXI9YShsZShlLmxheWVyZWRHcmFwaC5sYXllcnMsMCksMzApLGUuY3VycmVudExheWVySWQ9MCk7Zm9yKGUubm9kZXNUb1BsYWNlLnNpemVfMD09MHx8dUsoZSksZS5sYXllcmVkR3JhcGgubGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoPTAseD1uZXcgUSxfPW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKF8pLDMwKSx1Lm5vZGVzLmFycmF5Lmxlbmd0aD09MCYmUmUoeC5hcnJheSx1KTtmb3IoeXooZS5sYXllcmVkR3JhcGgubGF5ZXJzLHgpLGY9MCxjPW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDMwKSx1LmlkXzA9ZiwrK2Y7ci5kb25lXzEoKX1mdW5jdGlvbiBkTmUoKXtsSygpfWZ1bmN0aW9uIGdkbihlLG4pe2lmKGxLKCksX3IoZSwoSygpLHJyKSkmJl9yKG4scnIpKXJldHVybiBxbyhhKHcoZSxyciksMTcpLnZhbHVlXzAsYSh3KG4scnIpLDE3KS52YWx1ZV8wKTt0aHJvdyBiKG5ldyBlbSgiVGhlIERGIG1vZGVsIG9yZGVyIGxheWVyIGFzc2lnbmVyIHJlcXVpcmVzIGFsbCByZWFsIG5vZGVzIHRvIGhhdmUgYSBtb2RlbCBvcmRlci4iKSl9cCgxNDE1LDEsV3QsZE5lKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwzNiksZk5lfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtwZG4odGhpcyxhKG4sMzYpLHIpfSxsLmN1cnJlbnRMYXllcklkPTAsbC5tYXhUb1BsYWNlPTA7dmFyIGZOZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJEZXB0aEZpcnN0TW9kZWxPcmRlckxheWVyZXIiLDE0MTUpO2Z1bmN0aW9uIHBOZSgpe31wKDE0MTYsMSxObixwTmUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIGdkbihhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wMmxheWVycyIsIkRlcHRoRmlyc3RNb2RlbE9yZGVyTGF5ZXJlci9sYW1iZGEkMCRUeXBlIiwxNDE2KTtmdW5jdGlvbiBnTmUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3IoZS5pZF8wPTEsbz1lLmxheWVyLGY9bmV3IGx1LGQ9VTEoZSwocXQoKSxwaSkpLml0ZXJhdG9yXzAoKTtkLmhhc05leHRfMCgpOylmb3IoXz1hKGQubmV4dF8xKCksMTIpLHQ9bmV3IFQoXy5vdXRnb2luZ0VkZ2VzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTgpLGM9ci50YXJnZXQub3duZXIsZSE9YyYmKGk9Yy5sYXllcixpLmlkXzA8PW8uaWRfMCYmKHM9by5pZF8wKzEscz09bi5sYXllcnMuYXJyYXkubGVuZ3RoPyh1PW5ldyBvaShuKSx1LmlkXzA9cyxlZShuLmxheWVycyx1KSxodChjLHUpKToodT1hKGxlKG4ubGF5ZXJzLHMpLDMwKSxodChjLHUpKSxmLm1hcF8wLnB1dChjLGYpKSk7cmV0dXJuIGZ9ZnVuY3Rpb24gaGRuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQTtmb3Iobi5iZWdpbigiSW50ZXJhY3RpdmUgbm9kZSBsYXllcmluZyIsMSkscj1uZXcgUSxoPW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGQ9YShDKGgpLDEwKSxjPWQucG9zLnhfMCx1PWMrZC5zaXplXzAueF8wLHU9Uy5NYXRoLm1heChjKzEsdSksQT1uZXcgcHQociwwKSx0PW51bGw7QS5pPEEudGhpcyQwMV8wLnNpemVfMSgpOylpZih2PShybihBLmk8QS50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoQS50aGlzJDAxXzAuZ2V0XzAoQS5sYXN0PUEuaSsrKSw1NzgpKSx2LnN0YXJ0XzA+PXUpe3JuKEEuaT4wKSxBLnRoaXMkMDEuZ2V0XzAoQS5sYXN0PS0tQS5pKTticmVha31lbHNlIHYuZW5kPmMmJih0Pyhxcih0Lm5vZGVzLHYubm9kZXMpLHQuZW5kPVMuTWF0aC5tYXgodC5lbmQsdi5lbmQpLEVhKEEpKTooZWUodi5ub2RlcyxkKSx2LnN0YXJ0XzA9Uy5NYXRoLm1pbih2LnN0YXJ0XzAsYyksdi5lbmQ9Uy5NYXRoLm1heCh2LmVuZCx1KSx0PXYpKTt0fHwodD1uZXcgbU5lLHQuc3RhcnRfMD1jLHQuZW5kPXUscmYoQSx0KSxlZSh0Lm5vZGVzLGQpKX1mb3Iocz1lLmxheWVycyxfPTAseD1uZXcgVChyKTt4Lmk8eC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHY9YShDKHgpLDU3OCksbz1uZXcgb2koZSksby5pZF8wPV8rKyxSZShzLmFycmF5LG8pLG09bmV3IFQodi5ub2Rlcyk7bS5pPG0udGhpcyQwMS5hcnJheS5sZW5ndGg7KWQ9YShDKG0pLDEwKSxodChkLG8pLGQuaWRfMD0wO2ZvcihmPW5ldyBUKGUubGF5ZXJsZXNzTm9kZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihkPWEoQyhmKSwxMCksZC5pZF8wPT0wKWZvcihFPWdOZShkLGUpO0UubWFwXzAuc2l6ZV8xKCkhPTA7KXk9YShFLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpLm5leHRfMSgpLDEwKSxFLm1hcF8wLnJlbW92ZV8wKHkpIT1udWxsLGZ0KEUsZ05lKHksZSkpO2ZvcihpPW5ldyBwdChzLDApO2kuaTxpLnRoaXMkMDFfMC5zaXplXzEoKTspKHJuKGkuaTxpLnRoaXMkMDFfMC5zaXplXzEoKSksYShpLnRoaXMkMDFfMC5nZXRfMChpLmxhc3Q9aS5pKyspLDMwKSkubm9kZXMuYXJyYXkubGVuZ3RoPT0wJiZFYShpKTtlLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aD0wLG4uZG9uZV8xKCl9ZnVuY3Rpb24gaE5lKCl7fXAoMTQwNywxLFd0LGhOZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLE1uKE1uKE1uKG5ldyBIciwoeHQoKSxqbCksKGt0KCksZDkpKSxPdSxTZiksSm8sdmYpfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtoZG4oYShuLDM2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAybGF5ZXJzIiwiSW50ZXJhY3RpdmVMYXllcmVyIiwxNDA3KTtmdW5jdGlvbiBtTmUoKXt0aGlzLm5vZGVzPW5ldyBRfXAoNTc4LDEsezU3ODoxfSxtTmUpLGwuZW5kPTAsbC5zdGFydF8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAybGF5ZXJzIiwiSW50ZXJhY3RpdmVMYXllcmVyL0xheWVyU3BhbiIsNTc4KTtmdW5jdGlvbiB5TmUoKXt5TmU9Rix2TmU9TW4oTW4oTW4obmV3IEhyLCh4dCgpLGpsKSwoa3QoKSxXcCkpLE91LFNmKSxKbyx2Zil9ZnVuY3Rpb24gbWRuKGUsbixyKXt2YXIgdCxvLGkscyx1O2ZvcihyLmJlZ2luKCJMb25nZXN0IHBhdGggbGF5ZXJpbmciLDEpLGUubGF5ZXJlZEdyYXBoPW4sdT1lLmxheWVyZWRHcmFwaC5sYXllcmxlc3NOb2RlcyxlLm5vZGVIZWlnaHRzPUIoaG4sa24sMjgsdS5hcnJheS5sZW5ndGgsMTUsMSksdD0wLHM9bmV3IFQodSk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKHMpLDEwKSxvLmlkXzA9dCxlLm5vZGVIZWlnaHRzW3RdPS0xLCsrdDtmb3IoaT1uZXcgVCh1KTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTApLHdOZShlLG8pO3UuYXJyYXkubGVuZ3RoPTAsZS5sYXllcmVkR3JhcGg9bnVsbCxlLm5vZGVIZWlnaHRzPW51bGwsci5kb25lXzEoKX1mdW5jdGlvbiB5ZG4oZSxuLHIpe3ZhciB0LG87Zm9yKG89ZS5sYXllcmVkR3JhcGgubGF5ZXJzLHQ9by5hcnJheS5sZW5ndGg7dDxyO3QrKylBMShvLDAsbmV3IG9pKGUubGF5ZXJlZEdyYXBoKSk7aHQobixhKGxlKG8sby5hcnJheS5sZW5ndGgtciksMzApKSxlLm5vZGVIZWlnaHRzW24uaWRfMF09cn1mdW5jdGlvbiB3TmUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO2lmKG89ZS5ub2RlSGVpZ2h0c1tuLmlkXzBdLG8+PTApcmV0dXJuIG87Zm9yKGk9MSx1PW5ldyBUKG4ucG9ydHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocz1hKEModSksMTIpLHQ9bmV3IFQocy5vdXRnb2luZ0VkZ2VzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTgpLF89ci50YXJnZXQub3duZXIsbiE9XyYmKGM9d05lKGUsXyksaT1TLk1hdGgubWF4KGksYysxKSk7cmV0dXJuIHlkbihlLG4saSksaX1mdW5jdGlvbiBFTmUoKXt5TmUoKX1wKDE0MDMsMSxXdCxFTmUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDM2KSx2TmV9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe21kbih0aGlzLGEobiwzNikscil9O3ZhciB2TmU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAybGF5ZXJzIiwiTG9uZ2VzdFBhdGhMYXllcmVyIiwxNDAzKTtmdW5jdGlvbiBTTmUoKXtTTmU9RixiTmU9TW4oTW4oTW4obmV3IEhyLCh4dCgpLGpsKSwoa3QoKSxXcCkpLE91LFNmKSxKbyx2Zil9ZnVuY3Rpb24gd2RuKGUsbixyKXt2YXIgdCxvLGkscyx1O2ZvcihyLmJlZ2luKCJMb25nZXN0IHBhdGggdG8gc291cmNlIGxheWVyaW5nIiwxKSxlLmxheWVyZWRHcmFwaD1uLHU9ZS5sYXllcmVkR3JhcGgubGF5ZXJsZXNzTm9kZXMsZS5ub2RlSGVpZ2h0cz1CKGhuLGtuLDI4LHUuYXJyYXkubGVuZ3RoLDE1LDEpLHQ9MCxzPW5ldyBUKHUpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhzKSwxMCksby5pZF8wPXQsZS5ub2RlSGVpZ2h0c1t0XT0tMSwrK3Q7Zm9yKGk9bmV3IFQodSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEwKSxDTmUoZSxvKTt1LmFycmF5Lmxlbmd0aD0wLGUubGF5ZXJlZEdyYXBoPW51bGwsZS5ub2RlSGVpZ2h0cz1udWxsLHIuZG9uZV8xKCl9ZnVuY3Rpb24gRWRuKGUsbixyKXt2YXIgdCxvO2ZvcihvPWUubGF5ZXJlZEdyYXBoLmxheWVycyx0PW8uYXJyYXkubGVuZ3RoO3Q8cjt0KyspQTEobyxvLmFycmF5Lmxlbmd0aCxuZXcgb2koZS5sYXllcmVkR3JhcGgpKTtodChuLChBZShyLTEsby5hcnJheS5sZW5ndGgpLGEoby5hcnJheVtyLTFdLDMwKSkpLGUubm9kZUhlaWdodHNbbi5pZF8wXT1yfWZ1bmN0aW9uIENOZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87aWYobz1lLm5vZGVIZWlnaHRzW24uaWRfMF0sbz49MClyZXR1cm4gbztmb3IoaT0xLHU9bmV3IFQobi5wb3J0cyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihzPWEoQyh1KSwxMiksdD1uZXcgVChzLmluY29taW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxOCksXz1yLnNvdXJjZS5vd25lcixuIT1fJiYoYz1DTmUoZSxfKSxpPVMuTWF0aC5tYXgoaSxjKzEpKTtyZXR1cm4gRWRuKGUsbixpKSxpfWZ1bmN0aW9uIFROZSgpe1NOZSgpfXAoMTQxMiwxLFd0LFROZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLGJOZX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7d2RuKHRoaXMsYShuLDM2KSxyKX07dmFyIGJOZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJMb25nZXN0UGF0aFNvdXJjZUxheWVyZXIiLDE0MTIpO2Z1bmN0aW9uIElOZSgpe0lOZT1GLF9LPWpzZShKKDEpLEooNCkpLGNLPWpzZShKKDEpLEooMikpfWZ1bmN0aW9uIHZkbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztmb3IoaD1uZXcgUSx4PVRJKHQpLHY9biplLmF2Z1NpemUsZj0wLHk9MCxpPW5ldyBCcixzPW5ldyBCcix1PW5ldyBRLEE9MCxrPTAsbT0wLEU9MCxfPTAsZD0wO3gubWFwXzAuc2l6ZV8xKCkhPTA7KWM9VGRuKHgsbyxzKSxjJiYoeC5tYXBfMC5yZW1vdmVfMChjKSE9bnVsbCxSZSh1LmFycmF5LGMpLGkubWFwXzAucHV0KGMsaSkseT1lLm91dERlZ3JlZVtjLmlkXzBdLEErPWUubm9ybVNpemVbYy5pZF8wXS15KmUuZHVtbXlTaXplLGY9ZS5pbkRlZ3JlZVtjLmlkXzBdLGsrPWYqZS5kdW1teVNpemUsZCs9eSplLmR1bW15U2l6ZSxFKz1lLm5vcm1TaXplW2MuaWRfMF0pLCghY3x8eC5tYXBfMC5zaXplXzEoKT09MHx8QT49diYmZS5ub3JtU2l6ZVtjLmlkXzBdPnkqZS5kdW1teVNpemV8fGs+PXIqdikmJihSZShoLmFycmF5LHUpLHU9bmV3IFEsZnQocyxpKSxpLm1hcF8wLmNsZWFyXzAoKSxfLT1kLG09Uy5NYXRoLm1heChtLF8qZS5kdW1teVNpemUrRSksXys9ayxBPWssaz0wLGQ9MCxFPTApO3JldHVybiBuZXcgWnIobSxoKX1mdW5jdGlvbiB4TmUoZSl7dmFyIG4scix0O2Zvcih0PTAscj1uZXcgWGUoUWUoZS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocik7KW49YSh0bihyKSwxOCksbi5zb3VyY2Uub3duZXI9PW4udGFyZ2V0Lm93bmVyfHwrK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gU2RuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2Zvcih1PU51KGUuYXJyYXkubGVuZ3RoKSxvPW5ldyBUKGUpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHQ9YShDKG8pLDEwKSxzPW5ldyBCcixpPVJyKHQpLHI9bmV3IFhlKFFlKGkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHIpOyluPWEodG4ociksMTgpLG4uc291cmNlLm93bmVyPT1uLnRhcmdldC5vd25lcnx8WXIocyxuLnRhcmdldC5vd25lcik7UmUodS5hcnJheSxzKX1yZXR1cm4gdX1mdW5jdGlvbiBDZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam4sU3I7Zm9yKHIuYmVnaW4oIk1pbldpZHRoIGxheWVyaW5nIiwxKSxtPW4ubGF5ZXJzLG5lPW4ubGF5ZXJsZXNzTm9kZXMsU3I9YSh3KG4sKG9lKCksblkpKSwxNykudmFsdWVfMCx1PWEodyhuLHJZKSwxNykudmFsdWVfMCxlLmR1bW15U2l6ZT1SKCQodyhuLHFsKSkpLGUubWluaW11bU5vZGVTaXplPWhyLE09bmV3IFQobmUpO00uaTxNLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylBPWEoQyhNKSwxMCksQS50eXBlXzA9PShXZSgpLGtyKSYmKERlPUEuc2l6ZV8wLnlfMCxlLm1pbmltdW1Ob2RlU2l6ZT1TLk1hdGgubWluKGUubWluaW11bU5vZGVTaXplLERlKSk7Zm9yKGUubWluaW11bU5vZGVTaXplPVMuTWF0aC5tYXgoMSxlLm1pbmltdW1Ob2RlU2l6ZSksdmU9bmUuYXJyYXkubGVuZ3RoLGUuaW5EZWdyZWU9QihobixrbiwyOCx2ZSwxNSwxKSxlLm91dERlZ3JlZT1CKGhuLGtuLDI4LHZlLDE1LDEpLGUubm9ybVNpemU9QihjdCxYdCwyOCx2ZSwxNSwxKSxfPTAsZS5hdmdTaXplPTAsSD1uZXcgVChuZSk7SC5pPEgudGhpcyQwMS5hcnJheS5sZW5ndGg7KUE9YShDKEgpLDEwKSxBLmlkXzA9XysrLGUuaW5EZWdyZWVbQS5pZF8wXT14TmUodHQoQSkpLGUub3V0RGVncmVlW0EuaWRfMF09eE5lKFJyKEEpKSxlLm5vcm1TaXplW0EuaWRfMF09QS5zaXplXzAueV8wL2UubWluaW11bU5vZGVTaXplLGUuYXZnU2l6ZSs9ZS5ub3JtU2l6ZVtBLmlkXzBdO2ZvcihlLmR1bW15U2l6ZS89ZS5taW5pbXVtTm9kZVNpemUsZS5hdmdTaXplLz12ZSxxPVNkbihuZSksRHIobmUsSEIobmV3IE5OZShlKSkpLEU9aHIseT1xbixzPW51bGwsam49U3Isbm49U3IsaT11LG89dSxTcjwwJiYoam49YShfSy5sb3dlckJvdW5kLmVuZHBvaW50XzAoKSwxNykudmFsdWVfMCxubj1hKF9LLnVwcGVyQm91bmQuZW5kcG9pbnRfMCgpLDE3KS52YWx1ZV8wKSx1PDAmJihpPWEoY0subG93ZXJCb3VuZC5lbmRwb2ludF8wKCksMTcpLnZhbHVlXzAsbz1hKGNLLnVwcGVyQm91bmQuZW5kcG9pbnRfMCgpLDE3KS52YWx1ZV8wKSxGZT1qbjtGZTw9bm47RmUrKylmb3IodD1pO3Q8PW87dCsrKXdlPXZkbihlLEZlLHQsbmUscSkseD1SKCQod2UuZmlyc3QpKSxoPWEod2Uuc2Vjb25kLDE1KSx2PWguc2l6ZV8xKCksKHg8RXx8eD09RSYmdjx5KSYmKEU9eCx5PXYscz1oKTtmb3IoZj1zLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOyl7Zm9yKGQ9YShmLm5leHRfMSgpLDE1KSxjPW5ldyBvaShuKSxrPWQuaXRlcmF0b3JfMCgpO2suaGFzTmV4dF8wKCk7KUE9YShrLm5leHRfMSgpLDEwKSxodChBLGMpO1JlKG0uYXJyYXksYyl9T0MobSksbmUuYXJyYXkubGVuZ3RoPTAsci5kb25lXzEoKX1mdW5jdGlvbiBUZG4oZSxuLHIpe3ZhciB0LG87Zm9yKG89ZS5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOylpZih0PWEoby5uZXh0XzEoKSwxMCksckMocixhKGxlKG4sdC5pZF8wKSwxNikpKXJldHVybiB0O3JldHVybiBudWxsfWZ1bmN0aW9uIFBOZSgpe0lOZSgpfXAoMTQxMCwxLFd0LFBOZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLE1uKE1uKE1uKG5ldyBIciwoeHQoKSxqbCksKGt0KCksV3ApKSxPdSxTZiksSm8sdmYpfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtDZG4odGhpcyxhKG4sMzYpLHIpfSxsLmF2Z1NpemU9MCxsLmR1bW15U2l6ZT0wLGwubWluaW11bU5vZGVTaXplPTA7dmFyIGNLLF9LO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wMmxheWVycyIsIk1pbldpZHRoTGF5ZXJlciIsMTQxMCk7ZnVuY3Rpb24gYmRuKGUsbixyKXt2YXIgdCxvO3JldHVybiB0PWUudGhpcyQwMS5vdXREZWdyZWVbbi5pZF8wXSxvPWUudGhpcyQwMS5vdXREZWdyZWVbci5pZF8wXSx0PG8/LTE6dD09bz8wOjF9ZnVuY3Rpb24gTk5lKGUpe3RoaXMudGhpcyQwMT1lfXAoMTQxMSwxLE5uLE5OZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gYmRuKHRoaXMsYShuLDEwKSxhKHIsMTApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJNaW5XaWR0aExheWVyZXIvTWluT3V0Z29pbmdFZGdlc0NvbXBhcmF0b3IiLDE0MTEpO2Z1bmN0aW9uIEFOZSgpe0FOZT1GLE9OZT1NbihNbihNbihuZXcgSHIsKHh0KCksamwpLChrdCgpLFdwKSksT3UsU2YpLEpvLHZmKX1mdW5jdGlvbiBJZG4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihlLm5vZGVWaXNpdGVkPT1udWxsfHxlLm5vZGVWaXNpdGVkLmxlbmd0aDxuLmFycmF5Lmxlbmd0aD9lLm5vZGVWaXNpdGVkPUIoeWEseHUsMjgsbi5hcnJheS5sZW5ndGgsMTYsMSk6WjIoZS5ub2RlVmlzaXRlZCksZS5jb21wb25lbnROb2Rlcz1uZXcgUSx0PTAscz1uZXcgVChuKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMocyksMTApLG8uaWRfMD10Kys7Zm9yKHI9bmV3IHByLGk9bmV3IFQobik7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KW89YShDKGkpLDEwKSxlLm5vZGVWaXNpdGVkW28uaWRfMF18fChMTmUoZSxvKSxyLnNpemVfMD09MHx8KHJuKHIuc2l6ZV8wIT0wKSxhKHIuaGVhZGVyLm5leHRfMC52YWx1ZV8wLDE1KSkuc2l6ZV8xKCk8ZS5jb21wb25lbnROb2Rlcy5hcnJheS5sZW5ndGg/THAocixlLmNvbXBvbmVudE5vZGVzKTpNdChyLGUuY29tcG9uZW50Tm9kZXMpLGUuY29tcG9uZW50Tm9kZXM9bmV3IFEpO3JldHVybiByfWZ1bmN0aW9uIExOZShlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKGUubm9kZVZpc2l0ZWRbbi5pZF8wXT0hMCxlZShlLmNvbXBvbmVudE5vZGVzLG4pLHM9bmV3IFQobi5wb3J0cyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihpPWEoQyhzKSwxMiksdD1uZXcgTHMoaS5jb25uZWN0ZWRFZGdlcyk7eG8odC5maXJzdEl0ZXJhdG9yKXx8eG8odC5zZWNvbmRJdGVyYXRvcik7KXI9YSh4byh0LmZpcnN0SXRlcmF0b3IpP0ModC5maXJzdEl0ZXJhdG9yKTpDKHQuc2Vjb25kSXRlcmF0b3IpLDE4KSxvPXhkbihpLHIpLm93bmVyLGUubm9kZVZpc2l0ZWRbby5pZF8wXXx8TE5lKGUsbyl9ZnVuY3Rpb24geGRuKGUsbil7aWYobi5zb3VyY2U9PWUpcmV0dXJuIG4udGFyZ2V0O2lmKG4udGFyZ2V0PT1lKXJldHVybiBuLnNvdXJjZTt0aHJvdyBiKG5ldyBHZSgiSW5wdXQgZWRnZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBpbnB1dCBwb3J0LiIpKX1mdW5jdGlvbiBQZG4oZSl7dmFyIG4scix0LG8saSxzLHUsYztmb3IoYz1uZXcgc24sbj1uZXcgV2sscz1lLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylvPWEocy5uZXh0XzEoKSwxMCksdT1GMShWQyhuZXcgUl8sbyksbiksZGkoYy5oYXNoQ29kZU1hcCxvLHUpO2ZvcihpPWUuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KWZvcihvPWEoaS5uZXh0XzEoKSwxMCksdD1uZXcgWGUoUWUoUnIobykudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylyPWEodG4odCksMTgpLCF6dChyKSYmRmwoQmwoJGwoemwoR2wobmV3IEVsLFMuTWF0aC5tYXgoMSxhKHcociwob2UoKSxwWSkpLDE3KS52YWx1ZV8wKSksMSksYShLZShjLHIuc291cmNlLm93bmVyKSwxMjUpKSxhKEtlKGMsci50YXJnZXQub3duZXIpLDEyNSkpKTtyZXR1cm4gbn1mdW5jdGlvbiBOZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseDtpZihyLmJlZ2luKCJOZXR3b3JrIHNpbXBsZXggbGF5ZXJpbmciLDEpLGUubGF5ZXJlZEdyYXBoPW4seD1hKHcobiwob2UoKSxKRSkpLDE3KS52YWx1ZV8wKjQsdj1lLmxheWVyZWRHcmFwaC5sYXllcmxlc3NOb2Rlcyx2LmFycmF5Lmxlbmd0aDwxKXtyLmRvbmVfMSgpO3JldHVybn1mb3IoaT1JZG4oZSx2KSxFPW51bGwsbz1kbihpLDApO28uY3VycmVudE5vZGUhPW8udGhpcyQwMS50YWlsOyl7Zm9yKHQ9YSh1bihvKSwxNSksdT14KktyKFMuTWF0aC5zcXJ0KHQuc2l6ZV8xKCkpKSxzPVBkbih0KSxqayh6SChibm4oJEgocWsocyksdSksRSksITApLHIuc3ViVGFzaygxKSksaD1lLmxheWVyZWRHcmFwaC5sYXllcnMseT1uZXcgVChzLm5vZGVzKTt5Lmk8eS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihtPWEoQyh5KSwxMjUpO2guYXJyYXkubGVuZ3RoPD1tLmxheWVyOylBMShoLGguYXJyYXkubGVuZ3RoLG5ldyBvaShlLmxheWVyZWRHcmFwaCkpO2Q9YShtLm9yaWdpbl8wLDEwKSxodChkLGEobGUoaCxtLmxheWVyKSwzMCkpfWlmKGkuc2l6ZV8wPjEpZm9yKEU9QihobixrbiwyOCxlLmxheWVyZWRHcmFwaC5sYXllcnMuYXJyYXkubGVuZ3RoLDE1LDEpLGY9MCxfPW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDMwKSxFW2YrK109Yy5ub2Rlcy5hcnJheS5sZW5ndGh9di5hcnJheS5sZW5ndGg9MCxlLmNvbXBvbmVudE5vZGVzPW51bGwsZS5sYXllcmVkR3JhcGg9bnVsbCxlLm5vZGVWaXNpdGVkPW51bGwsci5kb25lXzEoKX1mdW5jdGlvbiBrTmUoKXtBTmUoKX1wKDE0MDIsMSxXdCxrTmUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDM2KSxPTmV9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe05kbih0aGlzLGEobiwzNikscil9O3ZhciBPTmU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAybGF5ZXJzIiwiTmV0d29ya1NpbXBsZXhMYXllcmVyIiwxNDAyKTtmdW5jdGlvbiBBZG4oZSl7dmFyIG4scjtmb3IoZS5pbkRlZ3JlZT1CKGhuLGtuLDI4LGUuc29ydGVkTGF5ZXJsZXNzTm9kZXMuYXJyYXkubGVuZ3RoLDE1LDEpLGUub3V0RGVncmVlPUIoaG4sa24sMjgsZS5zb3J0ZWRMYXllcmxlc3NOb2Rlcy5hcnJheS5sZW5ndGgsMTUsMSkscj1uZXcgVChlLnNvcnRlZExheWVybGVzc05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTApLGUuaW5EZWdyZWVbbi5pZF8wXT1adShuZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSxlLm91dERlZ3JlZVtuLmlkXzBdPVp1KG5ldyBYZShRZShScihuKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpfWZ1bmN0aW9uIExkbihlKXt2YXIgbixyO2ZvcihlLm5vcm1TaXplPUIoY3QsWHQsMjgsZS5zb3J0ZWRMYXllcmxlc3NOb2Rlcy5hcnJheS5sZW5ndGgsMTUsMSkscj1uZXcgVChlLnNvcnRlZExheWVybGVzc05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTApLGUubm9ybVNpemVbbi5pZF8wXT1uLnNpemVfMC55XzAvZS5taW5pbXVtTm9kZVNpemV9ZnVuY3Rpb24ga2RuKGUpe3ZhciBuLHIsdDtmb3IodD1lLmN1cnJlbnRHcmFwaC5sYXllcmxlc3NOb2RlcyxlLnNvcnRlZExheWVybGVzc05vZGVzPSh2bih0KSxuZXcgUWkodCkpLHI9bmV3IFQodCk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDEwKSxuLmlkXzA9UmRuKG4pLnZhbHVlXzA7TmUoKSxEcihlLnNvcnRlZExheWVybGVzc05vZGVzLG5ldyBETmUpfWZ1bmN0aW9uIE9kbihlKXt2YXIgbixyLHQsbyxpLHM7Zm9yKG89MCxlLnN1Y2Nlc3NvcnM9bmV3IFEsbj1uZXcgQnIscz1uZXcgVChlLnNvcnRlZExheWVybGVzc05vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihpPWEoQyhzKSwxMCksaS5pZF8wPW8sdD1uZXcgWGUoUWUoUnIoaSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylyPWEodG4odCksMTgpLFlyKG4sci50YXJnZXQub3duZXIpO24ubWFwXzAucmVtb3ZlXzAoaSkhPW51bGwsZWUoZS5zdWNjZXNzb3JzLG5ldyBuRShuKSksbi5tYXBfMC5jbGVhcl8wKCksKytvfX1mdW5jdGlvbiBNTmUoZSl7dmFyIG4scjtyZXR1cm4gbj1lLndpZHRoQ3VycmVudC1lLm91dERlZ3JlZVtlLnNlbGVjdGVkTm9kZS5pZF8wXSplLmR1bW15U2l6ZStlLm5vcm1TaXplW2Uuc2VsZWN0ZWROb2RlLmlkXzBdPmUubWF4V2lkdGgscj1lLndpZHRoVXArZS5pbkRlZ3JlZVtlLnNlbGVjdGVkTm9kZS5pZF8wXSplLmR1bW15U2l6ZT5lLm1heFdpZHRoKmUudXBwZXJMYXllckluZmx1ZW5jZSplLmR1bW15U2l6ZSxufHxyfWZ1bmN0aW9uIE1kbihlKXt2YXIgbixyLHQ7Zm9yKG49MCx0PW5ldyBUKGUuY3VycmVudEdyYXBoLmxheWVybGVzc05vZGVzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTApLG4rPVp1KG5ldyBYZShRZShScihyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpO3JldHVybiBuL2UuY3VycmVudEdyYXBoLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aH1mdW5jdGlvbiBSZG4oZSl7dmFyIG4scix0LG8saTtmb3Iobj1adShuZXcgWGUoUWUoUnIoZSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpKSxvPW5ldyBYZShRZSh0dChlKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSwxOCkscj10LnNvdXJjZS5vd25lcixpPVp1KG5ldyBYZShRZShScihyKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpLG49Uy5NYXRoLm1heChuLGkpO3JldHVybiBKKG4pfWZ1bmN0aW9uIERkbihlKXt2YXIgbixyLHQ7Zm9yKHI9bmV3IFQoZS5zb3J0ZWRMYXllcmxlc3NOb2Rlcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDEwKSxuLnR5cGVfMD09KFdlKCksa3IpJiYodD1uLnNpemVfMC55XzAsZS5taW5pbXVtTm9kZVNpemU9Uy5NYXRoLm1pbihlLm1pbmltdW1Ob2RlU2l6ZSx0KSxlLm1heGltdW1Ob2RlU2l6ZT1TLk1hdGgubWF4KGUubWF4aW11bU5vZGVTaXplLHQpKX1mdW5jdGlvbiBGZG4oZSxuLHIpe3ZhciB0O2lmKHIuYmVnaW4oIlN0cmV0Y2hXaWR0aCBsYXllcmluZyIsMSksbi5sYXllcmxlc3NOb2Rlcy5hcnJheS5sZW5ndGg9PTApe3IuZG9uZV8xKCk7cmV0dXJufWZvcihlLmN1cnJlbnRHcmFwaD1uLGUud2lkdGhDdXJyZW50PTAsZS53aWR0aFVwPTAsZS5taW5pbXVtTm9kZVNpemU9aHIsZS5tYXhpbXVtTm9kZVNpemU9VnIsZS5kdW1teVNpemU9UigkKHcobiwob2UoKSxxbCkpKSksa2RuKGUpLE9kbihlKSxBZG4oZSksRGRuKGUpLExkbihlKSxlLm1pbmltdW1Ob2RlU2l6ZT1TLk1hdGgubWF4KDEsZS5taW5pbXVtTm9kZVNpemUpLGUubWF4aW11bU5vZGVTaXplPVMuTWF0aC5tYXgoMSxlLm1heGltdW1Ob2RlU2l6ZSksZS5kdW1teVNpemU9ZS5kdW1teVNpemUvZS5taW5pbXVtTm9kZVNpemUsZS5tYXhXaWR0aD1lLm1heGltdW1Ob2RlU2l6ZS9lLm1pbmltdW1Ob2RlU2l6ZSxlLnVwcGVyTGF5ZXJJbmZsdWVuY2U9TWRuKGUpLHQ9bmV3IG9pKGUuY3VycmVudEdyYXBoKSxlZShlLmN1cnJlbnRHcmFwaC5sYXllcnMsdCksZS50ZW1wTGF5ZXJsZXNzTm9kZXM9djEoZS5zb3J0ZWRMYXllcmxlc3NOb2RlcyksZS5yZW1haW5pbmdPdXRHb2luZz1aSShlLm91dERlZ3JlZSxlLm91dERlZ3JlZS5sZW5ndGgpO2UudGVtcExheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aCE9MDspZS5zZWxlY3RlZE5vZGU9emRuKGUpLCFlLnNlbGVjdGVkTm9kZXx8TU5lKGUpJiZlLmFscmVhZHlQbGFjZWROb2Rlcy5tYXBfMC5zaXplXzEoKSE9MD8oJGRuKGUsdCksdD1uZXcgb2koZS5jdXJyZW50R3JhcGgpLGVlKGUuY3VycmVudEdyYXBoLmxheWVycyx0KSxmdChlLmFscmVhZHlQbGFjZWRJbk90aGVyTGF5ZXJzLGUuYWxyZWFkeVBsYWNlZE5vZGVzKSxlLmFscmVhZHlQbGFjZWROb2Rlcy5tYXBfMC5jbGVhcl8wKCksZS53aWR0aEN1cnJlbnQ9ZS53aWR0aFVwLGUud2lkdGhVcD0wKTpNTmUoZSk/KGUuY3VycmVudEdyYXBoLmxheWVycy5hcnJheS5sZW5ndGg9MCx0PW5ldyBvaShlLmN1cnJlbnRHcmFwaCksZWUoZS5jdXJyZW50R3JhcGgubGF5ZXJzLHQpLGUud2lkdGhDdXJyZW50PTAsZS53aWR0aFVwPTAsZS5hbHJlYWR5UGxhY2VkTm9kZXMubWFwXzAuY2xlYXJfMCgpLGUuYWxyZWFkeVBsYWNlZEluT3RoZXJMYXllcnMubWFwXzAuY2xlYXJfMCgpLCsrZS5tYXhXaWR0aCxlLnRlbXBMYXllcmxlc3NOb2Rlcz12MShlLnNvcnRlZExheWVybGVzc05vZGVzKSxlLnJlbWFpbmluZ091dEdvaW5nPVpJKGUub3V0RGVncmVlLGUub3V0RGVncmVlLmxlbmd0aCkpOihodChlLnNlbGVjdGVkTm9kZSx0KSxQaShlLnRlbXBMYXllcmxlc3NOb2RlcyxlLnNlbGVjdGVkTm9kZSksWXIoZS5hbHJlYWR5UGxhY2VkTm9kZXMsZS5zZWxlY3RlZE5vZGUpLGUud2lkdGhDdXJyZW50PWUud2lkdGhDdXJyZW50LWUub3V0RGVncmVlW2Uuc2VsZWN0ZWROb2RlLmlkXzBdKmUuZHVtbXlTaXplK2Uubm9ybVNpemVbZS5zZWxlY3RlZE5vZGUuaWRfMF0sZS53aWR0aFVwKz1lLmluRGVncmVlW2Uuc2VsZWN0ZWROb2RlLmlkXzBdKmUuZHVtbXlTaXplKTtuLmxheWVybGVzc05vZGVzLmFycmF5Lmxlbmd0aD0wLE9DKG4ubGF5ZXJzKSxyLmRvbmVfMSgpfWZ1bmN0aW9uIHpkbihlKXt2YXIgbixyO2ZvcihyPW5ldyBUKGUudGVtcExheWVybGVzc05vZGVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYobj1hKEMociksMTApLGUucmVtYWluaW5nT3V0R29pbmdbbi5pZF8wXTw9MClyZXR1cm4gbjtyZXR1cm4gbnVsbH1mdW5jdGlvbiAkZG4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihpPW5ldyBUKG4ubm9kZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobz1hKEMoaSksMTApLHQ9bmV3IFhlKFFlKHR0KG8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSxzPXIuc291cmNlLm93bmVyLmlkXzAsZS5yZW1haW5pbmdPdXRHb2luZ1tzXT1lLnJlbWFpbmluZ091dEdvaW5nW3NdLTF9ZnVuY3Rpb24gUk5lKCl7dGhpcy5hbHJlYWR5UGxhY2VkTm9kZXM9bmV3IEJyLHRoaXMuYWxyZWFkeVBsYWNlZEluT3RoZXJMYXllcnM9bmV3IEJyfXAoMTQwOCwxLFd0LFJOZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzYpLE1uKE1uKE1uKG5ldyBIciwoeHQoKSxqbCksKGt0KCksV3ApKSxPdSxTZiksSm8sdmYpfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtGZG4odGhpcyxhKG4sMzYpLHIpfSxsLmR1bW15U2l6ZT0wLGwubWF4V2lkdGg9MCxsLm1heGltdW1Ob2RlU2l6ZT0wLGwubWluaW11bU5vZGVTaXplPTAsbC51cHBlckxheWVySW5mbHVlbmNlPTAsbC53aWR0aEN1cnJlbnQ9MCxsLndpZHRoVXA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJTdHJldGNoV2lkdGhMYXllcmVyIiwxNDA4KTtmdW5jdGlvbiBCZG4oZSxuKXtyZXR1cm4gZS5pZF8wPG4uaWRfMD8xOmUuaWRfMD5uLmlkXzA/LTE6MH1mdW5jdGlvbiBETmUoKXt9cCgxNDA5LDEsTm4sRE5lKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBCZG4oYShuLDEwKSxhKHIsMTApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDJsYXllcnMiLCJTdHJldGNoV2lkdGhMYXllcmVyLzEiLDE0MDkpO2Z1bmN0aW9uIEdkbihlLG4scil7cmV0dXJuIGU9PShhZCgpLFdQKT9uZXcgbkFlOmZhKG4sMSkhPTA/bmV3IENLKHIubGVuZ3RoKTpuZXcgQ0FlKHIubGVuZ3RoKX1mdW5jdGlvbiBIZG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3IoXz1lLm5vZGVQb3NpdGlvbnNbbi5sYXllci5pZF8wXVtuLmlkXzBdKzEsYz1uLmxheWVyLm5vZGVzLmFycmF5Lmxlbmd0aCsxLHU9bmV3IFQoZS5pbkxheWVyUG9ydHMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHM9YShDKHUpLDEyKSxmPTAsaT0wLG89UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsW25ldyBEeShzKSxuZXcgTWgocyldKSkpO19uKG8pOyl0PWEodG4obyksMTIpLHQub3duZXIubGF5ZXI9PW4ubGF5ZXImJihmKz1xZG4oZSx0Lm93bmVyKSsxLCsraSk7cj1mL2ksZD1zLnNpZGUsZD09KHJlKCkscWUpP3I8Xz9lLnBvcnRCYXJ5Y2VudGVyW3MuaWRfMF09ZS5taW5CYXJ5Y2VudGVyLXI6ZS5wb3J0QmFyeWNlbnRlcltzLmlkXzBdPWUubWF4QmFyeWNlbnRlcisoYy1yKTpkPT1qZSYmKHI8Xz9lLnBvcnRCYXJ5Y2VudGVyW3MuaWRfMF09ZS5tYXhCYXJ5Y2VudGVyK3I6ZS5wb3J0QmFyeWNlbnRlcltzLmlkXzBdPWUubWluQmFyeWNlbnRlci0oYy1yKSl9fWZ1bmN0aW9uIGRLKGUsbixyKXt2YXIgdCxvO2Zvcih0PTAsbz0wO288bi5sZW5ndGg7bysrKXQrPWUuY2FsY3VsYXRlUG9ydFJhbmtzKG5bb10sdCxyKX1mdW5jdGlvbiBVZG4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYztmb3Iobz0hMSxpPSExLHU9bmV3IFQodC5wb3J0cyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDEyKSxEKHcocywoSygpLFFuKSkpPT09RChyKSYmKHMub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGg9PTA/cy5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD09MHx8KG89ITApOmk9ITApO3JldHVybiBjPTAsbyYmb15pP2M9ci5zaWRlPT0ocmUoKSxVZSk/LWUubm9kZVBvc2l0aW9uc1t0LmxheWVyLmlkXzBdW3QuaWRfMF06bi1lLm5vZGVQb3NpdGlvbnNbdC5sYXllci5pZF8wXVt0LmlkXzBdOmkmJm9eaT9jPWUubm9kZVBvc2l0aW9uc1t0LmxheWVyLmlkXzBdW3QuaWRfMF0rMTpvJiZpJiYoYz1yLnNpZGU9PShyZSgpLFVlKT8wOm4vMiksY31mdW5jdGlvbiBmSyhlLG4scil7ZS5pbkxheWVyUG9ydHMuYXJyYXkubGVuZ3RoPTAsamRuKGUsbixyKSxlLmluTGF5ZXJQb3J0cy5hcnJheS5sZW5ndGg9PTB8fEhkbihlLG4pfWZ1bmN0aW9uIHBLKGUsbixyKXtfbShhKHcobiwob2UoKSx4cikpLDEwMSkpfHwoZksoZSxuLCRjKG4scikpLGZLKGUsbiwkYyhuLChyZSgpLGxuKSkpLGZLKGUsbiwkYyhuLFVlKSksTmUoKSxEcihuLnBvcnRzLG5ldyAkTmUoZSkpKX1mdW5jdGlvbiBGTmUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG07aWYoWWRuKGUsbixyKSxpPW5bcl0sbT10PyhyZSgpLGplKToocmUoKSxxZSksV2RuKG4ubGVuZ3RoLHIsdCkpe2ZvcihvPW5bdD9yLTE6cisxXSxkSyhlLG8sdD8ocXQoKSxwaSk6KHF0KCksaWEpKSxjPWksZD0wLGg9Yy5sZW5ndGg7ZDxoOysrZClzPWNbZF0scEsoZSxzLG0pO2ZvcihkSyhlLGksdD8ocXQoKSxpYSk6KHF0KCkscGkpKSx1PW8sXz0wLGY9dS5sZW5ndGg7XzxmOysrXylzPXVbX10scy5uZXN0ZWRHcmFwaHx8cEsoZSxzLEJUKG0pKX1lbHNlIGZvcih1PWksXz0wLGY9dS5sZW5ndGg7XzxmOysrXylzPXVbX10scEsoZSxzLG0pO3JldHVybiExfWZ1bmN0aW9uIFdkbihlLG4scil7cmV0dXJuIHI/biE9MDpuIT1lLTF9ZnVuY3Rpb24gamRuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtO2UubWluQmFyeWNlbnRlcj0wLGUubWF4QmFyeWNlbnRlcj0wLHQ9MipuLmxheWVyLm5vZGVzLmFycmF5Lmxlbmd0aCsxO2U6Zm9yKGY9ci5pdGVyYXRvcl8wKCk7Zi5oYXNOZXh0XzAoKTspe2lmKGQ9YShmLm5leHRfMSgpLDEyKSx1PWQuc2lkZT09KHJlKCksVWUpfHxkLnNpZGU9PWxuLG09MCx1KXtpZihoPWEodyhkLChLKCksb2EpKSwxMCksIWgpY29udGludWU7bSs9VWRuKGUsdCxkLGgpfWVsc2V7Zm9yKF89bmV3IFQoZC5vdXRnb2luZ0VkZ2VzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoYz1hKEMoXyksMTgpLG89Yy50YXJnZXQsby5vd25lci5sYXllcj09bi5sYXllcil7ZWUoZS5pbkxheWVyUG9ydHMsZCk7Y29udGludWUgZX1lbHNlIG0rPWUucG9ydFJhbmtzW28uaWRfMF07Zm9yKHM9bmV3IFQoZC5pbmNvbWluZ0VkZ2VzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoaT1hKEMocyksMTgpLG89aS5zb3VyY2Usby5vd25lci5sYXllcj09bi5sYXllcil7ZWUoZS5pbkxheWVyUG9ydHMsZCk7Y29udGludWUgZX1lbHNlIG0tPWUucG9ydFJhbmtzW28uaWRfMF19ZC5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCtkLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPjA/KGUucG9ydEJhcnljZW50ZXJbZC5pZF8wXT1tLyhkLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK2Qub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgpLGUubWluQmFyeWNlbnRlcj1TLk1hdGgubWluKGUubWluQmFyeWNlbnRlcixlLnBvcnRCYXJ5Y2VudGVyW2QuaWRfMF0pLGUubWF4QmFyeWNlbnRlcj1TLk1hdGgubWF4KGUubWF4QmFyeWNlbnRlcixlLnBvcnRCYXJ5Y2VudGVyW2QuaWRfMF0pKTp1JiYoZS5wb3J0QmFyeWNlbnRlcltkLmlkXzBdPW0pfX1mdW5jdGlvbiBWZG4oZSxuLHIpe3ZhciB0LG8saSxzO3JldHVybiBpPW4uc2lkZSxzPXIuc2lkZSxpIT1zP2kub3JkaW5hbC1zLm9yZGluYWw6KHQ9ZS5wb3J0QmFyeWNlbnRlcltuLmlkXzBdLG89ZS5wb3J0QmFyeWNlbnRlcltyLmlkXzBdLHQ9PTAmJm89PTA/MDp0PT0wPy0xOm89PTA/MTppcih0LG8pKX1mdW5jdGlvbiBxZG4oZSxuKXtyZXR1cm4gZS5ub2RlUG9zaXRpb25zW24ubGF5ZXIuaWRfMF1bbi5pZF8wXX1mdW5jdGlvbiBZZG4oZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1uW3JdLHQ9MDt0PG8ubGVuZ3RoO3QrKylpPW9bdF0sZS5ub2RlUG9zaXRpb25zW2kubGF5ZXIuaWRfMF1baS5pZF8wXT10fWZ1bmN0aW9uIHpOZShlKXt0aGlzLmluTGF5ZXJQb3J0cz1uZXcgUSx0aGlzLm5vZGVQb3NpdGlvbnM9QihobixYLDUzLGUsMCwyKX1wKDQxMywxLHFGKSxsLmluaXRBdEVkZ2VMZXZlbD1mdW5jdGlvbihuLHIsdCxvLGkscyl7fSxsLmRpc3RyaWJ1dGVQb3J0c1doaWxlU3dlZXBpbmc9ZnVuY3Rpb24obixyLHQpe3JldHVybiBGTmUodGhpcyxuLHIsdCl9LGwuaW5pdEFmdGVyVHJhdmVyc2FsPWZ1bmN0aW9uKCl7dGhpcy5wb3J0UmFua3M9QihwcCx5aWUsMjgsdGhpcy5uUG9ydHMsMTUsMSksdGhpcy5wb3J0QmFyeWNlbnRlcj1CKHBwLHlpZSwyOCx0aGlzLm5Qb3J0cywxNSwxKX0sbC5pbml0QXRMYXllckxldmVsPWZ1bmN0aW9uKG4scil7dGhpcy5ub2RlUG9zaXRpb25zW25dPUIoaG4sa24sMjgscltuXS5sZW5ndGgsMTUsMSl9LGwuaW5pdEF0Tm9kZUxldmVsPWZ1bmN0aW9uKG4scix0KXt2YXIgbztvPXRbbl1bcl0sby5pZF8wPXIsdGhpcy5ub2RlUG9zaXRpb25zW25dW3JdPXJ9LGwuaW5pdEF0UG9ydExldmVsPWZ1bmN0aW9uKG4scix0LG8pe2EobGUob1tuXVtyXS5wb3J0cyx0KSwxMikuaWRfMD10aGlzLm5Qb3J0cysrfSxsLm1heEJhcnljZW50ZXI9MCxsLm1pbkJhcnljZW50ZXI9MCxsLm5Qb3J0cz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiQWJzdHJhY3RCYXJ5Y2VudGVyUG9ydERpc3RyaWJ1dG9yIiw0MTMpO2Z1bmN0aW9uICROZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTY5OCwxLE5uLCROZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gVmRuKHRoaXMuJCRvdXRlcl8wLGEobiwxMiksYShyLDEyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJBYnN0cmFjdEJhcnljZW50ZXJQb3J0RGlzdHJpYnV0b3IvbGFtYmRhJDAkVHlwZSIsMTY5OCk7ZnVuY3Rpb24gZ0soZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZjtpZighZS5iYXJ5Y2VudGVyU3RhdGVbbi5sYXllci5pZF8wXVtuLmlkXzBdLnZpc2l0ZWQpe2ZvcihlLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0udmlzaXRlZD0hMCxlLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0uZGVncmVlPTAsZS5iYXJ5Y2VudGVyU3RhdGVbbi5sYXllci5pZF8wXVtuLmlkXzBdLnN1bW1lZFdlaWdodD0wLGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5iYXJ5Y2VudGVyPW51bGwsZD1uZXcgVChuLnBvcnRzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKF89YShDKGQpLDEyKSxmPXI/bmV3IER5KF8pOm5ldyBNaChfKSxjPWYuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDEyKSxzPXUub3duZXIscy5sYXllcj09bi5sYXllcj9zIT1uJiYoZ0soZSxzLHIpLGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5kZWdyZWUrPWUuYmFyeWNlbnRlclN0YXRlW3MubGF5ZXIuaWRfMF1bcy5pZF8wXS5kZWdyZWUsZS5iYXJ5Y2VudGVyU3RhdGVbbi5sYXllci5pZF8wXVtuLmlkXzBdLnN1bW1lZFdlaWdodCs9ZS5iYXJ5Y2VudGVyU3RhdGVbcy5sYXllci5pZF8wXVtzLmlkXzBdLnN1bW1lZFdlaWdodCk6KGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5zdW1tZWRXZWlnaHQrPWUucG9ydFJhbmtzW3UuaWRfMF0sKytlLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0uZGVncmVlKTtpZihpPWEodyhuLChLKCksS1YpKSwxNSksaSlmb3Iobz1pLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSwxMCksbi5sYXllcj09dC5sYXllciYmKGdLKGUsdCxyKSxlLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0uZGVncmVlKz1lLmJhcnljZW50ZXJTdGF0ZVt0LmxheWVyLmlkXzBdW3QuaWRfMF0uZGVncmVlLGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5zdW1tZWRXZWlnaHQrPWUuYmFyeWNlbnRlclN0YXRlW3QubGF5ZXIuaWRfMF1bdC5pZF8wXS5zdW1tZWRXZWlnaHQpO2UuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5kZWdyZWU+MCYmKGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXS5zdW1tZWRXZWlnaHQrPWZhKGUucmFuZG9tXzAsMjQpKkpTKi4wNzAwMDAwMDAyOTgwMjMyMi0uMDM1MDAwMDAwMTQ5MDExNjEsZS5iYXJ5Y2VudGVyU3RhdGVbbi5sYXllci5pZF8wXVtuLmlkXzBdLmJhcnljZW50ZXI9ZS5iYXJ5Y2VudGVyU3RhdGVbbi5sYXllci5pZF8wXVtuLmlkXzBdLnN1bW1lZFdlaWdodC9lLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0uZGVncmVlKX19ZnVuY3Rpb24gQk5lKGUsbixyKXt2YXIgdCxvLGk7Zm9yKGk9bmV3IFQobik7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKGkpLDEwKSxlLmJhcnljZW50ZXJTdGF0ZVt0LmxheWVyLmlkXzBdW3QuaWRfMF0udmlzaXRlZD0hMTtmb3Iobz1uZXcgVChuKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTApLGdLKGUsdCxyKX1mdW5jdGlvbiBHTmUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2lmKHIpZm9yKHQ9LTEsZD1uZXcgcHQobiwwKTtkLmk8ZC50aGlzJDAxXzAuc2l6ZV8xKCk7KXtpZih1PShybihkLmk8ZC50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoZC50aGlzJDAxXzAuZ2V0XzAoZC5sYXN0PWQuaSsrKSwxMCkpLGY9ZS5iYXJ5Y2VudGVyU3RhdGVbdS5sYXllci5pZF8wXVt1LmlkXzBdLmJhcnljZW50ZXIsZj09bnVsbCl7Zm9yKHM9dCsxLGk9bmV3IHB0KG4sZC5pKTtpLmk8aS50aGlzJDAxXzAuc2l6ZV8xKCk7KWlmKGg9WGRuKGUsKHJuKGkuaTxpLnRoaXMkMDFfMC5zaXplXzEoKSksYShpLnRoaXMkMDFfMC5nZXRfMChpLmxhc3Q9aS5pKyspLDEwKSkpLmJhcnljZW50ZXIsaCE9bnVsbCl7cz0oVmUoaCksaCk7YnJlYWt9Zj0odCtzKS8yLGUuYmFyeWNlbnRlclN0YXRlW3UubGF5ZXIuaWRfMF1bdS5pZF8wXS5iYXJ5Y2VudGVyPWYsZS5iYXJ5Y2VudGVyU3RhdGVbdS5sYXllci5pZF8wXVt1LmlkXzBdLnN1bW1lZFdlaWdodD0oVmUoZiksZiksZS5iYXJ5Y2VudGVyU3RhdGVbdS5sYXllci5pZF8wXVt1LmlkXzBdLmRlZ3JlZT0xfXQ9KFZlKGYpLGYpfWVsc2V7Zm9yKG89MCxfPW5ldyBUKG4pO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhfKSwxMCksZS5iYXJ5Y2VudGVyU3RhdGVbdS5sYXllci5pZF8wXVt1LmlkXzBdLmJhcnljZW50ZXIhPW51bGwmJihvPVMuTWF0aC5tYXgobyxSKGUuYmFyeWNlbnRlclN0YXRlW3UubGF5ZXIuaWRfMF1bdS5pZF8wXS5iYXJ5Y2VudGVyKSkpO2ZvcihvKz0yLGM9bmV3IFQobik7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDEwKSxlLmJhcnljZW50ZXJTdGF0ZVt1LmxheWVyLmlkXzBdW3UuaWRfMF0uYmFyeWNlbnRlcj09bnVsbCYmKGY9ZmEoZS5yYW5kb21fMCwyNCkqSlMqby0xLGUuYmFyeWNlbnRlclN0YXRlW3UubGF5ZXIuaWRfMF1bdS5pZF8wXS5iYXJ5Y2VudGVyPWYsZS5iYXJ5Y2VudGVyU3RhdGVbdS5sYXllci5pZF8wXVt1LmlkXzBdLnN1bW1lZFdlaWdodD1mLGUuYmFyeWNlbnRlclN0YXRlW3UubGF5ZXIuaWRfMF1bdS5pZF8wXS5kZWdyZWU9MSl9fWZ1bmN0aW9uIEtkbihlLG4scil7dmFyIHQsbztyZXR1cm4gdD1lLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0sbz1lLmJhcnljZW50ZXJTdGF0ZVtyLmxheWVyLmlkXzBdW3IuaWRfMF0sdC5iYXJ5Y2VudGVyIT1udWxsJiZvLmJhcnljZW50ZXIhPW51bGw/TzUodC5iYXJ5Y2VudGVyLG8uYmFyeWNlbnRlcik6dC5iYXJ5Y2VudGVyIT1udWxsPy0xOm8uYmFyeWNlbnRlciE9bnVsbD8xOjB9ZnVuY3Rpb24gSE5lKGUsbil7dmFyIHIsdDtmb3IodD1uZXcgVChuKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTApLGUuYmFyeWNlbnRlclN0YXRlW3IubGF5ZXIuaWRfMF1bci5pZF8wXS5iYXJ5Y2VudGVyPWhHKGUucmFuZG9tXzApLGUuYmFyeWNlbnRlclN0YXRlW3IubGF5ZXIuaWRfMF1bci5pZF8wXS5zdW1tZWRXZWlnaHQ9UihlLmJhcnljZW50ZXJTdGF0ZVtyLmxheWVyLmlkXzBdW3IuaWRfMF0uYmFyeWNlbnRlciksZS5iYXJ5Y2VudGVyU3RhdGVbci5sYXllci5pZF8wXVtyLmlkXzBdLmRlZ3JlZT0xfWZ1bmN0aW9uIFVOZShlLG4pe3JldHVybiBlPzA6Uy5NYXRoLm1heCgwLG4tMSl9ZnVuY3Rpb24gWGRuKGUsbil7cmV0dXJuIGUuYmFyeWNlbnRlclN0YXRlW24ubGF5ZXIuaWRfMF1bbi5pZF8wXX1mdW5jdGlvbiBoSyhlLG4scil7dGhpcy5iYXJ5Y2VudGVyU3RhdGVDb21wYXJhdG9yPW5ldyBWTmUodGhpcyksdGhpcy5jb25zdHJhaW50UmVzb2x2ZXI9ZSx0aGlzLnJhbmRvbV8wPW4sdGhpcy5wb3J0RGlzdHJpYnV0b3I9cn1wKDgzMiwxLFpTLGhLKSxsLmluaXRBdEVkZ2VMZXZlbD1mdW5jdGlvbihuLHIsdCxvLGkscyl7fSxsLmluaXRBdE5vZGVMZXZlbD1mdW5jdGlvbihuLHIsdCl7fSxsLmluaXRBdFBvcnRMZXZlbD1mdW5jdGlvbihuLHIsdCxvKXt9LGwuYWx3YXlzSW1wcm92ZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pbml0QWZ0ZXJUcmF2ZXJzYWw9ZnVuY3Rpb24oKXt0aGlzLmJhcnljZW50ZXJTdGF0ZT10aGlzLmNvbnN0cmFpbnRSZXNvbHZlci5iYXJ5Y2VudGVyU3RhdGVzLHRoaXMucG9ydFJhbmtzPXRoaXMucG9ydERpc3RyaWJ1dG9yLnBvcnRSYW5rc30sbC5pbml0QXRMYXllckxldmVsPWZ1bmN0aW9uKG4scil7cltuXVswXS5sYXllci5pZF8wPW59LGwuaXNEZXRlcm1pbmlzdGljPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwubWluaW1pemVDcm9zc2luZ3NfMD1mdW5jdGlvbihuLHIsdCxvKXt0P0hOZSh0aGlzLG4pOihCTmUodGhpcyxuLG8pLEdOZSh0aGlzLG4scikpLG4uYXJyYXkubGVuZ3RoPjEmJihhZShpZSh3KFN0KChBZSgwLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbMF0sMTApKSksKG9lKCksUTEpKSkpP2JBZShuLHRoaXMuYmFyeWNlbnRlclN0YXRlQ29tcGFyYXRvcixhKHRoaXMsNjY5KSk6KE5lKCksRHIobix0aGlzLmJhcnljZW50ZXJTdGF0ZUNvbXBhcmF0b3IpKSxZTmUodGhpcy5jb25zdHJhaW50UmVzb2x2ZXIsbikpfSxsLm1pbmltaXplQ3Jvc3NpbmdzPWZ1bmN0aW9uKG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmO2ZvcihyIT1VTmUodCxuLmxlbmd0aCkmJihzPW5bci0odD8xOi0xKV0sZEsodGhpcy5wb3J0RGlzdHJpYnV0b3Iscyx0PyhxdCgpLHBpKToocXQoKSxpYSkpKSxpPW5bcl1bMF0sZj0hb3x8aS50eXBlXzA9PShXZSgpLEZyKSxkPVRzKG5bcl0pLHRoaXMubWluaW1pemVDcm9zc2luZ3NfMChkLGYsITEsdCksdT0wLF89bmV3IFQoZCk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDEwKSxuW3JdW3UrK109YztyZXR1cm4hMX0sbC5zZXRGaXJzdExheWVyT3JkZXI9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscyx1O2Zvcih1PVVOZShyLG4ubGVuZ3RoKSxzPVRzKG5bdV0pLHRoaXMubWluaW1pemVDcm9zc2luZ3NfMChzLCExLCEwLHIpLHQ9MCxpPW5ldyBUKHMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxMCksblt1XVt0KytdPW87cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiQmFyeWNlbnRlckhldXJpc3RpYyIsODMyKTtmdW5jdGlvbiBXTmUoZSl7dGhpcy5ub2RlPWV9cCg2NjcsMSx7NjY3OjF9LFdOZSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIkJhcnljZW50ZXJTdGF0ZSBbbm9kZT0iK3RoaXMubm9kZSsiLCBzdW1tZWRXZWlnaHQ9Iit0aGlzLnN1bW1lZFdlaWdodCsiLCBkZWdyZWU9Iit0aGlzLmRlZ3JlZSsiLCBiYXJ5Y2VudGVyPSIrdGhpcy5iYXJ5Y2VudGVyKyIsIHZpc2l0ZWQ9Iit0aGlzLnZpc2l0ZWQrIl0ifSxsLmRlZ3JlZT0wLGwuc3VtbWVkV2VpZ2h0PTAsbC52aXNpdGVkPSExO3ZhciBqTmU9Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJCYXJ5Y2VudGVySGV1cmlzdGljL0JhcnljZW50ZXJTdGF0ZSIsNjY3KTtmdW5jdGlvbiBWTmUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE4NjUsMSxObixWTmUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIEtkbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiQmFyeWNlbnRlckhldXJpc3RpYy9sYW1iZGEkMCRUeXBlIiwxODY1KTtmdW5jdGlvbiBKZG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG07Zm9yKHU9bmV3IFQobik7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHUpLDIzOSksaS5vdXRnb2luZ0NvbnN0cmFpbnRzPW51bGwsaS5pbmNvbWluZ0NvbnN0cmFpbnRzQ291bnQ9MDtmb3IoYz1udWxsLHM9bmV3IFQobik7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKGk9YShDKHMpLDIzOSksZj1pLm5vZGVzWzBdLCEociYmZi50eXBlXzAhPShXZSgpLGtyKSkpe2ZvcihtPWEodyhmLChLKCksV2gpKSwxNSkuaXRlcmF0b3JfMCgpO20uaGFzTmV4dF8wKCk7KWg9YShtLm5leHRfMSgpLDEwKSwoIXJ8fGgudHlwZV8wPT0oV2UoKSxrcikpJiYoKCFpLm91dGdvaW5nQ29uc3RyYWludHMmJihpLm91dGdvaW5nQ29uc3RyYWludHM9bmV3IFEpLGkub3V0Z29pbmdDb25zdHJhaW50cykuYWRkXzIoZS5jb25zdHJhaW50R3JvdXBzW2gubGF5ZXIuaWRfMF1baC5pZF8wXSksKytlLmNvbnN0cmFpbnRHcm91cHNbaC5sYXllci5pZF8wXVtoLmlkXzBdLmluY29taW5nQ29uc3RyYWludHNDb3VudCk7aWYoIXImJmYudHlwZV8wPT0oV2UoKSxrcikpe2lmKGMpZm9yKGQ9YShabihlLmxheW91dFVuaXRzLGMpLDIxKS5pdGVyYXRvcl8wKCk7ZC5oYXNOZXh0XzAoKTspZm9yKF89YShkLm5leHRfMSgpLDEwKSxvPWEoWm4oZS5sYXlvdXRVbml0cyxmKSwyMSkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDEwKSxlZm4oZS5jb25zdHJhaW50R3JvdXBzW18ubGF5ZXIuaWRfMF1bXy5pZF8wXSkuYWRkXzIoZS5jb25zdHJhaW50R3JvdXBzW3QubGF5ZXIuaWRfMF1bdC5pZF8wXSksKytlLmNvbnN0cmFpbnRHcm91cHNbdC5sYXllci5pZF8wXVt0LmlkXzBdLmluY29taW5nQ29uc3RyYWludHNDb3VudDtjPWZ9fX1mdW5jdGlvbiBaZG4oZSl7dmFyIG4scix0LG8saSxzLHUsYztmb3Iobj1udWxsLHQ9bmV3IFQoZSk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDIzOSksUihNcyhyLnRoaXMkMDEsci5ub2Rlc1swXSkuYmFyeWNlbnRlciksci5pbmNvbWluZ0NvbnN0cmFpbnRzPW51bGwsci5vdXRnb2luZ0NvbnN0cmFpbnRzJiZyLm91dGdvaW5nQ29uc3RyYWludHMuc2l6ZV8xKCk+MCYmci5pbmNvbWluZ0NvbnN0cmFpbnRzQ291bnQ9PTAmJighbiYmKG49bmV3IFEpLFJlKG4uYXJyYXkscikpO2lmKG4pZm9yKDtuLmFycmF5Lmxlbmd0aCE9MDspe2lmKHI9YShNYyhuLDApLDIzOSksci5pbmNvbWluZ0NvbnN0cmFpbnRzJiZyLmluY29taW5nQ29uc3RyYWludHMuYXJyYXkubGVuZ3RoPjApe2ZvcihpPSghci5pbmNvbWluZ0NvbnN0cmFpbnRzJiYoci5pbmNvbWluZ0NvbnN0cmFpbnRzPW5ldyBRKSxuZXcgVChyLmluY29taW5nQ29uc3RyYWludHMpKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYobz1hKEMoaSksMjM5KSxTQyhNcyhvLnRoaXMkMDEsby5ub2Rlc1swXSkuYmFyeWNlbnRlcik9PVNDKE1zKHIudGhpcyQwMSxyLm5vZGVzWzBdKS5iYXJ5Y2VudGVyKSl7aWYoZm8oZSxvLDApPmZvKGUsciwwKSlyZXR1cm4gbmV3IFpyKG8scil9ZWxzZSBpZihSKE1zKG8udGhpcyQwMSxvLm5vZGVzWzBdKS5iYXJ5Y2VudGVyKT5SKE1zKHIudGhpcyQwMSxyLm5vZGVzWzBdKS5iYXJ5Y2VudGVyKSlyZXR1cm4gbmV3IFpyKG8scil9Zm9yKHU9KCFyLm91dGdvaW5nQ29uc3RyYWludHMmJihyLm91dGdvaW5nQ29uc3RyYWludHM9bmV3IFEpLHIub3V0Z29pbmdDb25zdHJhaW50cykuaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDIzOSksYz0oIXMuaW5jb21pbmdDb25zdHJhaW50cyYmKHMuaW5jb21pbmdDb25zdHJhaW50cz1uZXcgUSkscy5pbmNvbWluZ0NvbnN0cmFpbnRzKSxkZigwLGMuYXJyYXkubGVuZ3RoKSxvRShjLmFycmF5LDAscikscy5pbmNvbWluZ0NvbnN0cmFpbnRzQ291bnQ9PWMuYXJyYXkubGVuZ3RoJiZSZShuLmFycmF5LHMpfXJldHVybiBudWxsfWZ1bmN0aW9uIFFkbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF87Zm9yKHM9bmV3IEpOZShlLG4sciksYz1uZXcgcHQodCwwKSxvPSExO2MuaTxjLnRoaXMkMDFfMC5zaXplXzEoKTspdT0ocm4oYy5pPGMudGhpcyQwMV8wLnNpemVfMSgpKSxhKGMudGhpcyQwMV8wLmdldF8wKGMubGFzdD1jLmkrKyksMjM5KSksdT09bnx8dT09cj9FYShjKTohbyYmUihNcyh1LnRoaXMkMDEsdS5ub2Rlc1swXSkuYmFyeWNlbnRlcik+UihNcyhzLnRoaXMkMDEscy5ub2Rlc1swXSkuYmFyeWNlbnRlcik/KHJuKGMuaT4wKSxjLnRoaXMkMDEuZ2V0XzAoYy5sYXN0PS0tYy5pKSxyZihjLHMpLG89ITApOnUub3V0Z29pbmdDb25zdHJhaW50cyYmdS5vdXRnb2luZ0NvbnN0cmFpbnRzLnNpemVfMSgpPjAmJihpPSghdS5vdXRnb2luZ0NvbnN0cmFpbnRzJiYodS5vdXRnb2luZ0NvbnN0cmFpbnRzPW5ldyBRKSx1Lm91dGdvaW5nQ29uc3RyYWludHMpLnJlbW92ZV8xKG4pLF89KCF1Lm91dGdvaW5nQ29uc3RyYWludHMmJih1Lm91dGdvaW5nQ29uc3RyYWludHM9bmV3IFEpLHUub3V0Z29pbmdDb25zdHJhaW50cykucmVtb3ZlXzEociksKGl8fF8pJiYoKCF1Lm91dGdvaW5nQ29uc3RyYWludHMmJih1Lm91dGdvaW5nQ29uc3RyYWludHM9bmV3IFEpLHUub3V0Z29pbmdDb25zdHJhaW50cykuYWRkXzIocyksKytzLmluY29taW5nQ29uc3RyYWludHNDb3VudCkpO298fFJlKHQuYXJyYXkscyl9ZnVuY3Rpb24gcU5lKGUsbixyKXt2YXIgdCxvLGk7dD1uLmxheWVyLmlkXzAsaT1uLmlkXzAsZS5jb25zdHJhaW50R3JvdXBzW3RdW2ldPW5ldyBYTmUoZSxuKSxyJiYoZS5iYXJ5Y2VudGVyU3RhdGVzW3RdW2ldPW5ldyBXTmUobiksbz1hKHcobiwoSygpLFgxKSksMTApLG8mJmJlKGUubGF5b3V0VW5pdHMsbyxuKSl9ZnVuY3Rpb24gWU5lKGUsbil7ZS5jb25zdHJhaW50c0JldHdlZW5Ob25EdW1taWVzJiYoS05lKGUsbiwhMCksTHIobmV3IFNlKG51bGwsbmV3IHhlKG4sMTYpKSxuZXcgUU5lKGUpKSksS05lKGUsbiwhMSl9ZnVuY3Rpb24gS05lKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGk9bmV3IF9pKG4uYXJyYXkubGVuZ3RoKSxfPW5ldyBUKG4pO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyhfKSwxMCksZWUoaSxlLmNvbnN0cmFpbnRHcm91cHNbcy5sYXllci5pZF8wXVtzLmlkXzBdKTtmb3IoSmRuKGUsaSxyKSxmPW51bGw7Zj1aZG4oaSk7KVFkbihlLGEoZi5maXJzdCwyMzkpLGEoZi5zZWNvbmQsMjM5KSxpKTtmb3Iobi5hcnJheS5sZW5ndGg9MCxvPW5ldyBUKGkpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksMjM5KSx1PXQubm9kZXMsYz0wLGQ9dS5sZW5ndGg7YzxkOysrYylzPXVbY10sUmUobi5hcnJheSxzKSxlLmJhcnljZW50ZXJTdGF0ZXNbcy5sYXllci5pZF8wXVtzLmlkXzBdLmJhcnljZW50ZXI9TXModC50aGlzJDAxLHQubm9kZXNbMF0pLmJhcnljZW50ZXJ9ZnVuY3Rpb24gTXMoZSxuKXtyZXR1cm4gZS5iYXJ5Y2VudGVyU3RhdGVzW24ubGF5ZXIuaWRfMF1bbi5pZF8wXX1mdW5jdGlvbiBtSyhlKXtlLmxlbmd0aD4wJiZlWzBdLmxlbmd0aD4wJiYodGhpcy5jb25zdHJhaW50c0JldHdlZW5Ob25EdW1taWVzPWFlKGllKHcoU3QoZVswXVswXSksKEsoKSxlcSkpKSkpLHRoaXMuYmFyeWNlbnRlclN0YXRlcz1CKGpOZSxYLDIxMTcsZS5sZW5ndGgsMCwyKSx0aGlzLmNvbnN0cmFpbnRHcm91cHM9QihaTmUsWCwyMTE4LGUubGVuZ3RoLDAsMiksdGhpcy5sYXlvdXRVbml0cz1uZXcgbnNlfXAoODMxLDEsWlMsbUspLGwuaW5pdEFmdGVyVHJhdmVyc2FsPWZ1bmN0aW9uKCl7fSxsLmluaXRBdEVkZ2VMZXZlbD1mdW5jdGlvbihuLHIsdCxvLGkscyl7fSxsLmluaXRBdFBvcnRMZXZlbD1mdW5jdGlvbihuLHIsdCxvKXt9LGwuaW5pdEF0TGF5ZXJMZXZlbD1mdW5jdGlvbihuLHIpe3RoaXMuYmFyeWNlbnRlclN0YXRlc1tuXT1CKGpOZSx7MzoxLDQ6MSw1OjEsMjExNzoxfSw2NjcscltuXS5sZW5ndGgsMCwxKSx0aGlzLmNvbnN0cmFpbnRHcm91cHNbbl09QihaTmUsezM6MSw0OjEsNToxLDIxMTg6MX0sMjM5LHJbbl0ubGVuZ3RoLDAsMSl9LGwuaW5pdEF0Tm9kZUxldmVsPWZ1bmN0aW9uKG4scix0KXtxTmUodGhpcyx0W25dW3JdLCEwKX0sbC5jb25zdHJhaW50c0JldHdlZW5Ob25EdW1taWVzPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiRm9yc3RlckNvbnN0cmFpbnRSZXNvbHZlciIsODMxKTtmdW5jdGlvbiBlZm4oZSl7cmV0dXJuIWUub3V0Z29pbmdDb25zdHJhaW50cyYmKGUub3V0Z29pbmdDb25zdHJhaW50cz1uZXcgUSksZS5vdXRnb2luZ0NvbnN0cmFpbnRzfWZ1bmN0aW9uIGk3KGUsbil7dmFyIHIsdCxvLGk7Zm9yKHQ9ZS5ub2RlcyxvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxNcyhlLnRoaXMkMDEscikuYmFyeWNlbnRlcj1ufWZ1bmN0aW9uIFhOZShlLG4pe3RoaXMudGhpcyQwMT1lLHRoaXMubm9kZXM9UChJKFJ1LDEpLEljLDEwLDAsW25dKX1mdW5jdGlvbiBKTmUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3IodGhpcy50aGlzJDAxPWUsdT1uLm5vZGVzLmxlbmd0aCxjPXIubm9kZXMubGVuZ3RoLHRoaXMubm9kZXM9QihSdSxJYywxMCx1K2MsMCwxKSxzPTA7czx1O3MrKyl0aGlzLm5vZGVzW3NdPW4ubm9kZXNbc107Zm9yKGk9MDtpPGM7aSsrKXRoaXMubm9kZXNbdStpXT1yLm5vZGVzW2ldO2lmKG4ub3V0Z29pbmdDb25zdHJhaW50cyl7aWYodGhpcy5vdXRnb2luZ0NvbnN0cmFpbnRzPWNDKG4ub3V0Z29pbmdDb25zdHJhaW50cyksdGhpcy5vdXRnb2luZ0NvbnN0cmFpbnRzLnJlbW92ZV8xKHIpLHIub3V0Z29pbmdDb25zdHJhaW50cylmb3Iobz1yLm91dGdvaW5nQ29uc3RyYWludHMuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDIzOSksdCE9biYmKHRoaXMub3V0Z29pbmdDb25zdHJhaW50cy5jb250YWlucyh0KT8tLXQuaW5jb21pbmdDb25zdHJhaW50c0NvdW50OnRoaXMub3V0Z29pbmdDb25zdHJhaW50cy5hZGRfMih0KSl9ZWxzZSByLm91dGdvaW5nQ29uc3RyYWludHMmJih0aGlzLm91dGdvaW5nQ29uc3RyYWludHM9Y0Moci5vdXRnb2luZ0NvbnN0cmFpbnRzKSx0aGlzLm91dGdvaW5nQ29uc3RyYWludHMucmVtb3ZlXzEobikpO3RoaXMuc3VtbWVkV2VpZ2h0PW4uc3VtbWVkV2VpZ2h0K3Iuc3VtbWVkV2VpZ2h0LHRoaXMuZGVncmVlPW4uZGVncmVlK3IuZGVncmVlLHRoaXMuZGVncmVlPjA/aTcodGhpcyx0aGlzLnN1bW1lZFdlaWdodC90aGlzLmRlZ3JlZSk6TXMobi50aGlzJDAxLG4ubm9kZXNbMF0pLmJhcnljZW50ZXIhPW51bGwmJk1zKHIudGhpcyQwMSxyLm5vZGVzWzBdKS5iYXJ5Y2VudGVyIT1udWxsP2k3KHRoaXMsKFIoTXMobi50aGlzJDAxLG4ubm9kZXNbMF0pLmJhcnljZW50ZXIpK1IoTXMoci50aGlzJDAxLHIubm9kZXNbMF0pLmJhcnljZW50ZXIpKS8yKTpNcyhuLnRoaXMkMDEsbi5ub2Rlc1swXSkuYmFyeWNlbnRlciE9bnVsbD9pNyh0aGlzLE1zKG4udGhpcyQwMSxuLm5vZGVzWzBdKS5iYXJ5Y2VudGVyKTpNcyhyLnRoaXMkMDEsci5ub2Rlc1swXSkuYmFyeWNlbnRlciE9bnVsbCYmaTcodGhpcyxNcyhyLnRoaXMkMDEsci5ub2Rlc1swXSkuYmFyeWNlbnRlcil9cCgyMzksMSx7MjM5OjF9LFhOZSxKTmUpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuLHI7Zm9yKHI9bmV3IEMwLHIuc3RyaW5nKz0iWyIsbj0wO248dGhpcy5ub2Rlcy5sZW5ndGg7bisrKU9uKHIsZTJlKHRoaXMubm9kZXNbbl0pKSxNcyh0aGlzLnRoaXMkMDEsdGhpcy5ub2Rlc1swXSkuYmFyeWNlbnRlciE9bnVsbCYmT24oT24oKHIuc3RyaW5nKz0iPCIsciksbFplKE1zKHRoaXMudGhpcyQwMSx0aGlzLm5vZGVzWzBdKS5iYXJ5Y2VudGVyKSksIj4iKSxuPHRoaXMubm9kZXMubGVuZ3RoLTEmJihyLnN0cmluZys9IiwgIik7cmV0dXJuKHIuc3RyaW5nKz0iXSIscikuc3RyaW5nfSxsLmRlZ3JlZT0wLGwuaW5jb21pbmdDb25zdHJhaW50c0NvdW50PTAsbC5zdW1tZWRXZWlnaHQ9MDt2YXIgWk5lPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiRm9yc3RlckNvbnN0cmFpbnRSZXNvbHZlci9Db25zdHJhaW50R3JvdXAiLDIzOSk7ZnVuY3Rpb24gUU5lKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxODYwLDEsSmUsUU5lKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtxTmUodGhpcy4kJG91dGVyXzAsYShuLDEwKSwhMSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiRm9yc3RlckNvbnN0cmFpbnRSZXNvbHZlci9sYW1iZGEkMCRUeXBlIiwxODYwKTtmdW5jdGlvbiBuZm4oZSxuKXtlLmJlc3ROb2RlQW5kUG9ydE9yZGVyPW59ZnVuY3Rpb24gcmZuKGUsbil7ZS5jdXJyZW50bHlCZXN0Tm9kZUFuZFBvcnRPcmRlcj1ufWZ1bmN0aW9uIGVBZShlLG4scil7dmFyIHQsbyxpLHM7dGhpcy5sR3JhcGg9ZSx0aGlzLmN1cnJlbnROb2RlT3JkZXI9YlcoZSksdGhpcy5wYXJlbnRfMD10aGlzLmxHcmFwaC5wYXJlbnROb2RlLHRoaXMuaGFzUGFyZW50PSEhdGhpcy5wYXJlbnRfMCx0aGlzLnBhcmVudEdyYXBoRGF0YT10aGlzLmhhc1BhcmVudD9hKGxlKHIsU3QodGhpcy5wYXJlbnRfMCkuaWRfMCksMjE5KTpudWxsLG89YSh3KGUsKEsoKSxpaSkpLDIxKSx0aGlzLmhhc0V4dGVybmFsUG9ydHM9by5jb250YWlucygoVnQoKSxubCkpLHRoaXMuY2hpbGRHcmFwaHM9bmV3IFEsdGhpcy5jcm9zc2luZ3NDb3VudGVyPW5ldyBNQWUodGhpcy5jdXJyZW50Tm9kZU9yZGVyKSxzPWEodyh0aGlzLmxHcmFwaCxWaCksMjM0KSx0aGlzLnBvcnREaXN0cmlidXRvcj1HZG4obixzLHRoaXMuY3VycmVudE5vZGVPcmRlciksdGhpcy5sYXllclN3ZWVwVHlwZURlY2lkZXI9bmV3IHlBZSh0aGlzKSxpPVRzKFAoSShxM2UsMSksTWUsMjMwLDAsW3RoaXMsdGhpcy5jcm9zc2luZ3NDb3VudGVyLHRoaXMubGF5ZXJTd2VlcFR5cGVEZWNpZGVyLHRoaXMucG9ydERpc3RyaWJ1dG9yXSkpLG49PShhZCgpLGozKSYmIWFlKGllKHcoZSwob2UoKSxRMSkpKSk/KHQ9bmV3IG1LKHRoaXMuY3VycmVudE5vZGVPcmRlciksUmUoaS5hcnJheSx0KSx0aGlzLmNyb3NzTWluaW1pemVyPW5ldyBoSyh0LHMsYSh0aGlzLnBvcnREaXN0cmlidXRvciw0MTMpKSk6bj09ajMmJmFlKGllKHcoZSwob2UoKSxRMSkpKSk/KHQ9bmV3IG1LKHRoaXMuY3VycmVudE5vZGVPcmRlciksUmUoaS5hcnJheSx0KSx0aGlzLmNyb3NzTWluaW1pemVyPW5ldyBUQWUodCxzLGEodGhpcy5wb3J0RGlzdHJpYnV0b3IsNDEzKSkpOnRoaXMuY3Jvc3NNaW5pbWl6ZXI9bmV3IFgzZShuLHRoaXMpLGVlKGksdGhpcy5jcm9zc01pbmltaXplciksVjNlKGksdGhpcy5jdXJyZW50Tm9kZU9yZGVyKSx0aGlzLnVzZUJvdHRvbVVwPVRmbih0aGlzLmxheWVyU3dlZXBUeXBlRGVjaWRlcil9cCgyMTksMSx7MjE5OjEsMjMwOjF9LGVBZSksbC5pbml0QXRFZGdlTGV2ZWw9ZnVuY3Rpb24obixyLHQsbyxpLHMpe30sbC5pbml0QXRMYXllckxldmVsPWZ1bmN0aW9uKG4scil7fSxsLmluaXRBZnRlclRyYXZlcnNhbD1mdW5jdGlvbigpe3RoaXMucG9ydFBvc2l0aW9ucz1CKGhuLGtuLDI4LHRoaXMublBvcnRzLDE1LDEpfSxsLmluaXRBdE5vZGVMZXZlbD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtpPXRbbl1bcl0sbz1pLm5lc3RlZEdyYXBoLG8mJmVlKHRoaXMuY2hpbGRHcmFwaHMsbyl9LGwuaW5pdEF0UG9ydExldmVsPWZ1bmN0aW9uKG4scix0LG8peysrdGhpcy5uUG9ydHN9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiByMGUodGhpcy5jdXJyZW50Tm9kZU9yZGVyLG5ldyBCcil9LGwuaGFzRXh0ZXJuYWxQb3J0cz0hMSxsLmhhc1BhcmVudD0hMSxsLm5Qb3J0cz0wLGwudXNlQm90dG9tVXA9ITEsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJHcmFwaEluZm9Ib2xkZXIiLDIxOSk7ZnVuY3Rpb24gdGZuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaDtmb3IoZj10PyhyZSgpLGplKToocmUoKSxxZSksbz0hMSxjPW5bcl0sXz0wLGQ9Yy5sZW5ndGg7XzxkOysrXyl1PWNbX10sIV9tKGEodyh1LChvZSgpLHhyKSksMTAxKSkmJihzPXUubmVzdGVkR3JhcGgsaD0hQW8odSxmKS5pc0VtcHR5KCkmJiEhcyxoJiYoaT1iVyhzKSxlLmhpZXJhcmNoaWNhbENyb3NzaW5nc0NvdW50ZXI9bmV3IGVWKGksdD8wOmkubGVuZ3RoLTEpKSxvPW98b2ZuKGUsdSxmLGgpKTtyZXR1cm4gb31mdW5jdGlvbiBvZm4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQ7Yz1BbyhuLHIpLChyPT0ocmUoKSxsbil8fHI9PWplKSYmKGM9cWEoYykpLHM9ITE7ZG8gZm9yKG89ITEsaT0wO2k8Yy5zaXplXzEoKS0xO2krKylfPWEoYy5nZXRfMChpKSwxMiksdT1hKGMuZ2V0XzAoaSsxKSwxMiksaWZuKGUsXyx1LHQpJiYocz0hMCxmNyhlLmNyb3NzaW5nc0NvdW50ZXIsYShjLmdldF8wKGkpLDEyKSxhKGMuZ2V0XzAoaSsxKSwxMikpLGQ9YShjLmdldF8wKGkrMSksMTIpLGMuc2V0XzIoaSsxLGEoYy5nZXRfMChpKSwxMikpLGMuc2V0XzIoaSxkKSxvPSEwKTt3aGlsZShvKTtyZXR1cm4gc31mdW5jdGlvbiBpZm4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYztyZXR1cm4gcz1SQWUoZS5jcm9zc2luZ3NDb3VudGVyLG4sciksdT1hKHMuZmlyc3QsMTcpLnZhbHVlXzAsaT1hKHMuc2Vjb25kLDE3KS52YWx1ZV8wLHQmJihjPWEodyhuLChLKCksb2EpKSwxMCksbz1hKHcocixvYSksMTApLGMmJm8mJihGM2UoZS5oaWVyYXJjaGljYWxDcm9zc2luZ3NDb3VudGVyLGMsbyksdSs9ZS5oaWVyYXJjaGljYWxDcm9zc2luZ3NDb3VudGVyLnVwcGVyTG93ZXJDcm9zc2luZ3MsaSs9ZS5oaWVyYXJjaGljYWxDcm9zc2luZ3NDb3VudGVyLmxvd2VyVXBwZXJDcm9zc2luZ3MpKSx1Pml9ZnVuY3Rpb24gbkFlKCl7fXAoMTkwNSwxLFpTLG5BZSksbC5pbml0QXRFZGdlTGV2ZWw9ZnVuY3Rpb24obixyLHQsbyxpLHMpe30sbC5pbml0QXRMYXllckxldmVsPWZ1bmN0aW9uKG4scil7fSxsLmluaXRBdFBvcnRMZXZlbD1mdW5jdGlvbihuLHIsdCxvKXt9LGwuZGlzdHJpYnV0ZVBvcnRzV2hpbGVTd2VlcGluZz1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIHQmJnI+MD9jNyh0aGlzLmNyb3NzaW5nc0NvdW50ZXIsbltyLTFdLG5bcl0pOiF0JiZyPG4ubGVuZ3RoLTE/YzcodGhpcy5jcm9zc2luZ3NDb3VudGVyLG5bcl0sbltyKzFdKTpfNyh0aGlzLmNyb3NzaW5nc0NvdW50ZXIsbltyXSx0PyhyZSgpLGplKToocmUoKSxxZSkpLHRmbih0aGlzLG4scix0KX0sbC5pbml0QWZ0ZXJUcmF2ZXJzYWw9ZnVuY3Rpb24oKXt0aGlzLnBvcnRQb3M9QihobixrbiwyOCx0aGlzLm5Qb3J0cywxNSwxKSx0aGlzLmNyb3NzaW5nc0NvdW50ZXI9bmV3IHEzKHRoaXMucG9ydFBvcyl9LGwuaW5pdEF0Tm9kZUxldmVsPWZ1bmN0aW9uKG4scix0KXt2YXIgbztvPXRbbl1bcl0sdGhpcy5uUG9ydHMrPW8ucG9ydHMuYXJyYXkubGVuZ3RofSxsLm5Qb3J0cz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiR3JlZWR5UG9ydERpc3RyaWJ1dG9yIiwxOTA1KTtmdW5jdGlvbiByQWUoKXtyQWU9RixvQWU9V2koTW4oTW4obmV3IEhyLCh4dCgpLEpvKSwoa3QoKSxMNCkpLHJpLEk0KSxobyxBNCl9ZnVuY3Rpb24gYWZuKGUpe3ZhciBuO3JldHVybiBuPVVOKG9BZSksYSh3KGUsKEsoKSxpaSkpLDIxKS5jb250YWlucygoVnQoKSxudykpJiZNbihuLCh4dCgpLEpvKSwoa3QoKSxNNCkpLG59ZnVuY3Rpb24gbGZuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtzd2l0Y2goZS50eXBlXzAub3JkaW5hbCl7Y2FzZSAxOmlmKHQ9YSh3KGUsKEsoKSxRbikpLDE4KSxyPWEodyh0LG5xKSw3NSkscj9hZShpZSh3KHQsT3MpKSkmJihyPUNUKHIpKTpyPW5ldyBqaSxfPWEodyhlLGRzKSwxMiksXyl7aWYoZD1rbyhQKEkob3QsMSksWCw4LDAsW18ub3duZXIucG9zLF8ucG9zLF8uYW5jaG9yXSkpLG48PWQueF8wKXJldHVybiBkLnlfMDticihyLGQsci5oZWFkZXIsci5oZWFkZXIubmV4dF8wKX1pZihmPWEodyhlLHZsKSwxMiksZil7aWYoaD1rbyhQKEkob3QsMSksWCw4LDAsW2Yub3duZXIucG9zLGYucG9zLGYuYW5jaG9yXSkpLGgueF8wPD1uKXJldHVybiBoLnlfMDticihyLGgsci50YWlsLnByZXYsci50YWlsKX1pZihyLnNpemVfMD49Mil7Zm9yKGM9ZG4ociwwKSxzPWEodW4oYyksOCksdT1hKHVuKGMpLDgpO3UueF8wPG4mJmMuY3VycmVudE5vZGUhPWMudGhpcyQwMS50YWlsOylzPXUsdT1hKHVuKGMpLDgpO3JldHVybiBzLnlfMCsobi1zLnhfMCkvKHUueF8wLXMueF8wKSoodS55XzAtcy55XzApfWJyZWFrO2Nhc2UgMzpzd2l0Y2goaT1hKHcoYShsZShlLnBvcnRzLDApLDEyKSwoSygpLFFuKSksMTIpLG89aS5vd25lcixpLnNpZGUub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBvLnBvcy55XzA7Y2FzZSAzOnJldHVybiBvLnBvcy55XzArby5zaXplXzAueV8wfX1yZXR1cm4gelcoZSkueV8wfWZ1bmN0aW9uIHNmbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4O2ZvcihuLmJlZ2luKCJJbnRlcmFjdGl2ZSBjcm9zc2luZyBtaW5pbWl6YXRpb24iLDEpLHM9MCxpPW5ldyBUKGUubGF5ZXJzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMoaSksMzApLHQuaWRfMD1zKys7Zm9yKGg9YlcoZSksdj1uZXcgQ0soaC5sZW5ndGgpLFYzZShuZXcgZWEoUChJKHEzZSwxKSxNZSwyMzAsMCxbdl0pKSxoKSxFPTAscz0wLG89bmV3IFQoZS5sYXllcnMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHQ9YShDKG8pLDMwKSxyPTAsZj0wLGQ9bmV3IFQodC5ub2Rlcyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihjPWEoQyhkKSwxMCksYy5wb3MueF8wPjAmJihyKz1jLnBvcy54XzArYy5zaXplXzAueF8wLzIsKytmKSx5PW5ldyBUKGMucG9ydHMpO3kuaTx5LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyltPWEoQyh5KSwxMiksbS5pZF8wPUUrKztmb3IoZj4wJiYoci89ZikseD1CKGN0LFh0LDI4LHQubm9kZXMuYXJyYXkubGVuZ3RoLDE1LDEpLHU9MCxfPW5ldyBUKHQubm9kZXMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSwxMCksYy5pZF8wPXUrKyx4W2MuaWRfMF09bGZuKGMsciksYy50eXBlXzA9PShXZSgpLGl0KSYmaihjLChLKCkscnEpLHhbYy5pZF8wXSk7TmUoKSxEcih0Lm5vZGVzLG5ldyBpQWUoeCkpLEZOZSh2LGgscywhMCksKytzfW4uZG9uZV8xKCl9ZnVuY3Rpb24gdEFlKCl7ckFlKCl9cCgxNDIxLDEsV3QsdEFlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGFmbihhKG4sMzYpKX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7c2ZuKGEobiwzNikscil9O3ZhciBvQWU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJJbnRlcmFjdGl2ZUNyb3NzaW5nTWluaW1pemVyIiwxNDIxKTtmdW5jdGlvbiB1Zm4oZSxuLHIpe3ZhciB0LG8saTtpZih0PWlyKGUudmFsJHBvczJbbi5pZF8wXSxlLnZhbCRwb3MyW3IuaWRfMF0pLHQ9PTApe2lmKG89YSh3KG4sKEsoKSxXaCkpLDE1KSxpPWEodyhyLFdoKSwxNSksby5jb250YWlucyhyKSlyZXR1cm4tMTtpZihpLmNvbnRhaW5zKG4pKXJldHVybiAxfXJldHVybiB0fWZ1bmN0aW9uIGlBZShlKXt0aGlzLnZhbCRwb3MyPWV9cCgxNDIyLDEsTm4saUFlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiB1Zm4odGhpcyxhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiSW50ZXJhY3RpdmVDcm9zc2luZ01pbmltaXplci8xIiwxNDIyKTtmdW5jdGlvbiB5Sygpe3lLPUYsY0FlPWh1KEZSZShNbihNbihuZXcgSHIsKHh0KCksSm8pLChrdCgpLEw0KSkscmksSTQpLGhvKSxBNCl9ZnVuY3Rpb24gY2ZuKGUsbil7dmFyIHIsdCxvLGk7aWYoa1FlKGUucmFuZG9tXzAsZS5yYW5kb21TZWVkKSxlLmdyYXBoc1dob3NlTm9kZU9yZGVyQ2hhbmdlZC5tYXBfMC5jbGVhcl8wKCksUigkKHcobi5sR3JhcGgsKG9lKCkseVApKSkpIT0wfHxSKCQodyhuLmxHcmFwaCx5UCkpKSE9MClmb3Iocj1tcCxEKHcobi5sR3JhcGgsRHUpKSE9PUQoKGZ1KCksVmMpKSYmaihuLmxHcmFwaCwoSygpLEQwKSwoemUoKSwhMCkpLGk9YSh3KG4ubEdyYXBoLEpFKSwxNykudmFsdWVfMCxvPTA7bzxpJiYodD1tZm4oZSxuKSwhKHQ8ciYmKHI9dCxzQWUoZSkscj09MCkpKTtvKyspO2Vsc2UgZm9yKHI9cW4sRCh3KG4ubEdyYXBoLER1KSkhPT1EKChmdSgpLFZjKSkmJmoobi5sR3JhcGgsKEsoKSxEMCksKHplKCksITApKSxpPWEodyhuLmxHcmFwaCxKRSksMTcpLnZhbHVlXzAsbz0wO288aSYmKHQ9bEFlKGUsbiksISh0PHImJihyPXQsc0FlKGUpLHI9PTApKSk7bysrKTt9ZnVuY3Rpb24gVVAoZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKHU9MCxpPW5ldyBBcCxJMChpLG4pO2kuaGVhZCE9aS50YWlsOylmb3Iocz1hKG1oKGkpLDIxOSksdSs9T0FlKHMuY3Jvc3NpbmdzQ291bnRlcixzLmN1cnJlbnROb2RlT3JkZXIpLG89bmV3IFQocy5jaGlsZEdyYXBocyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDM2KSxyPWEobGUoZS5ncmFwaEluZm9Ib2xkZXJzLHQuaWRfMCksMjE5KSxyLnVzZUJvdHRvbVVwfHwodSs9VVAoZSxyKSk7cmV0dXJuIHV9ZnVuY3Rpb24gd0soZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3IoZj0wLGk9bmV3IEFwLEkwKGksbik7aS5oZWFkIT1pLnRhaWw7KWZvcihjPWEobWgoaSksMjE5KSxfPTAsZD1hKHcobi5sR3JhcGgsKG9lKCksRHUpKSwyODQpLHM9UigkKHcobi5sR3JhcGgseVApKSksdT1SKCQodyhuLmxHcmFwaCx6cSkpKSxkIT0oZnUoKSxWYykmJihfKz1zKl9mbihjLmN1cnJlbnROb2RlT3JkZXIsZCksXys9dSpkZm4oYy5jdXJyZW50Tm9kZU9yZGVyKSksZis9T0FlKGMuY3Jvc3NpbmdzQ291bnRlcixjLmN1cnJlbnROb2RlT3JkZXIpK18sbz1uZXcgVChjLmNoaWxkR3JhcGhzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMzYpLHI9YShsZShlLmdyYXBoSW5mb0hvbGRlcnMsdC5pZF8wKSwyMTkpLHIudXNlQm90dG9tVXB8fChmKz1VUChlLHIpKTtyZXR1cm4gZn1mdW5jdGlvbiBfZm4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKF89LTEsZD0wLHM9ZSx1PTAsYz1zLmxlbmd0aDt1PGM7Kyt1KXtmb3IoaT1zW3VdLHI9bmV3IG1iZShfPT0tMT9lWzBdOmVbX10sbiwoWkUoKSxNUCkpLHQ9MDt0PGkubGVuZ3RoO3QrKylmb3Iobz10KzE7bzxpLmxlbmd0aDtvKyspX3IoaVt0XSwoSygpLHJyKSkmJl9yKGlbb10scnIpJiZwYmUocixpW3RdLGlbb10pPjAmJisrZDsrK199cmV0dXJuIGR9ZnVuY3Rpb24gZGZuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2ZvcihoPS0xLG09MCxfPWUsZD0wLGY9Xy5sZW5ndGg7ZDxmOysrZCl7Zm9yKGM9X1tkXSxpPWMscz0wLHU9aS5sZW5ndGg7czx1Oysrcylmb3Iobz1pW3NdLG49bmV3IENiZShoPT0tMT9lWzBdOmVbaF0sYSh3KFN0KG8pLChvZSgpLER1KSksMjg0KSxDQ2UobyksYWUoaWUodyhTdChvKSxtTykpKSkscj0wO3I8by5wb3J0cy5hcnJheS5sZW5ndGg7cisrKWZvcih0PXIrMTt0PG8ucG9ydHMuYXJyYXkubGVuZ3RoO3QrKyl2YmUobixhKGxlKG8ucG9ydHMsciksMTIpLGEobGUoby5wb3J0cyx0KSwxMikpPjAmJisrbTsrK2h9cmV0dXJuIG19ZnVuY3Rpb24gZmZuKGUsbil7cmV0dXJuIGU/bi0xOjB9ZnVuY3Rpb24gYUFlKGUsbil7cmV0dXJuIGU/MDpuLTF9ZnVuY3Rpb24gcGZuKGUsbil7dmFyIHIsdCxvLGkscyx1O2ZvcihlLmdyYXBoSW5mb0hvbGRlcnM9bmV3IFEsZS5yYW5kb21fMD1hKHcobiwoSygpLFZoKSksMjM0KSxlLnJhbmRvbVNlZWQ9TFFlKGUucmFuZG9tXzApLGk9bmV3IHByLG89VHMoUChJKHp3ZSwxKSxwaWUsMzYsMCxbbl0pKSxzPTA7czxvLmFycmF5Lmxlbmd0aDspdD0oQWUocyxvLmFycmF5Lmxlbmd0aCksYShvLmFycmF5W3NdLDM2KSksdC5pZF8wPXMrKyxyPW5ldyBlQWUodCxlLmNyb3NzTWluVHlwZSxlLmdyYXBoSW5mb0hvbGRlcnMpLHFyKG8sci5jaGlsZEdyYXBocyksZWUoZS5ncmFwaEluZm9Ib2xkZXJzLHIpLHIudXNlQm90dG9tVXAmJih1PWRuKGksMCksUkModSxyKSk7cmV0dXJuIGUuZ3JhcGhzV2hvc2VOb2RlT3JkZXJDaGFuZ2VkPW5ldyBCcixpfWZ1bmN0aW9uIGdmbihlLG4pe3ZhciByLHQ7Zm9yKHQ9ZG4oZSwwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDIxOSksci5jdXJyZW50Tm9kZU9yZGVyLmxlbmd0aD4wJiYobi5hY2NlcHQociksci5oYXNQYXJlbnQmJndmbihyKSl9ZnVuY3Rpb24gaGZuKGUsbil7dmFyIHIsdDtmb3IodD1mYShlLnJhbmRvbV8wLDEpIT0wLHI9ITA7cjspcj0hMSxyPW4uY3Jvc3NNaW5pbWl6ZXIuc2V0Rmlyc3RMYXllck9yZGVyKG4uY3VycmVudE5vZGVPcmRlcix0KSxyPXJ8VzMoZSxuLHQsITEpLHQ9IXQ7RUsoZSl9ZnVuY3Rpb24gbWZuKGUsbil7dmFyIHIsdCxvLGk7aWYobz1mYShlLnJhbmRvbV8wLDEpIT0wLHQ9d0soZSxuKSx0PT0wJiZhZShpZSh3KG4ubEdyYXBoLChLKCksRDApKSkpKXJldHVybiAwOyFhZShpZSh3KG4ubEdyYXBoLChLKCksRDApKSkpJiYhYWUoaWUodyhuLmxHcmFwaCxRcCkpKXx8RCh3KG4ubEdyYXBoLChvZSgpLER1KSkpPT09RCgoZnUoKSxWYykpP24uY3Jvc3NNaW5pbWl6ZXIuc2V0Rmlyc3RMYXllck9yZGVyKG4uY3VycmVudE5vZGVPcmRlcixvKTpvPWFlKGllKHcobi5sR3JhcGgsRDApKSksVzMoZSxuLG8sITApLGFlKGllKHcobi5sR3JhcGgsUXApKSkmJmoobi5sR3JhcGgsUXAsKHplKCksITEpKSxhZShpZSh3KG4ubEdyYXBoLEQwKSkpJiYoaihuLmxHcmFwaCxEMCwoemUoKSwhMSkpLGoobi5sR3JhcGgsUXAsITApKSxyPXdLKGUsbik7ZG97aWYoRUsoZSkscj09MClyZXR1cm4gMDtvPSFvLGk9cixXMyhlLG4sbywhMSkscj13SyhlLG4pfXdoaWxlKGk+cik7cmV0dXJuIGl9ZnVuY3Rpb24gbEFlKGUsbil7dmFyIHIsdCxvLGk7aWYobz1mYShlLnJhbmRvbV8wLDEpIT0wLHQ9VVAoZSxuKSx0PT0wJiZhZShpZSh3KG4ubEdyYXBoLChLKCksRDApKSkpKXJldHVybiAwOyFhZShpZSh3KG4ubEdyYXBoLChLKCksRDApKSkpJiYhYWUoaWUodyhuLmxHcmFwaCxRcCkpKXx8RCh3KG4ubEdyYXBoLChvZSgpLER1KSkpPT09RCgoZnUoKSxWYykpP24uY3Jvc3NNaW5pbWl6ZXIuc2V0Rmlyc3RMYXllck9yZGVyKG4uY3VycmVudE5vZGVPcmRlcixvKTpvPWFlKGllKHcobi5sR3JhcGgsRDApKSksVzMoZSxuLG8sITApLGFlKGllKHcobi5sR3JhcGgsUXApKSkmJmoobi5sR3JhcGgsUXAsKHplKCksITEpKSxhZShpZSh3KG4ubEdyYXBoLEQwKSkpJiYoaihuLmxHcmFwaCxEMCwoemUoKSwhMSkpLGoobi5sR3JhcGgsUXAsITApKSxyPVVQKGUsbik7ZG97aWYoRUsoZSkscj09MClyZXR1cm4gMDtvPSFvLGk9cixXMyhlLG4sbywhMSkscj1VUChlLG4pfXdoaWxlKGk+cik7cmV0dXJuIGl9ZnVuY3Rpb24geWZuKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYoci5iZWdpbigiTWluaW1pemUgQ3Jvc3NpbmdzICIrZS5jcm9zc01pblR5cGUsMSksdD1uLmxheWVycy5hcnJheS5sZW5ndGg9PTB8fCFQeShKbihuZXcgU2UobnVsbCxuZXcgeGUobi5sYXllcnMsMTYpKSxuZXcgYnkobmV3IG1BZSkpKS50cnlBZHZhbmNlKChNXygpLEloKSksYz1uLmxheWVycy5hcnJheS5sZW5ndGg9PTEmJmEobGUobi5sYXllcnMsMCksMzApLm5vZGVzLmFycmF5Lmxlbmd0aD09MSxpPUQodyhuLChvZSgpLE5mKSkpPT09RCgocGMoKSxRYykpLHR8fGMmJiFpKXtyLmRvbmVfMSgpO3JldHVybn1vPXBmbihlLG4pLHM9KHU9YShWYShvLDApLDIxOSksdS5jcm9zc01pbmltaXplci5pc0RldGVybWluaXN0aWMoKT91LmNyb3NzTWluaW1pemVyLmFsd2F5c0ltcHJvdmVzKCk/bmV3IGRBZShlKTpuZXcgZkFlKGUpOm5ldyBfQWUoZSkpLGdmbihvLHMpLHZmbihlKSxyLmRvbmVfMSgpfWZ1bmN0aW9uIHNBZShlKXt2YXIgbixyO2ZvcihyPWUuZ3JhcGhzV2hvc2VOb2RlT3JkZXJDaGFuZ2VkLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KW49YShyLm5leHRfMSgpLDIxOSksbmZuKG4sbmV3IExBZShuLmN1cnJlbnRseUJlc3ROb2RlQW5kUG9ydE9yZGVyKSl9ZnVuY3Rpb24gRUsoZSl7dmFyIG4scjtmb3Iocj1lLmdyYXBoc1dob3NlTm9kZU9yZGVyQ2hhbmdlZC5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtyLmhhc05leHRfMCgpOyluPWEoci5uZXh0XzEoKSwyMTkpLHJmbihuLG5ldyBrQWUobi5jdXJyZW50Tm9kZU9yZGVyKSl9ZnVuY3Rpb24gd2ZuKGUpe3ZhciBuO2UuaGFzRXh0ZXJuYWxQb3J0cyYmKG49ZS5jcm9zc01pbmltaXplci5pc0RldGVybWluaXN0aWMoKT9lLmN1cnJlbnRseUJlc3ROb2RlQW5kUG9ydE9yZGVyOmUuYmVzdE5vZGVBbmRQb3J0T3JkZXIsdksobi5ub2RlT3JkZXIsZS5wYXJlbnRfMCwhMCksdksobi5ub2RlT3JkZXIsZS5wYXJlbnRfMCwhMSksaihlLnBhcmVudF8wLChvZSgpLHhyKSwoZHQoKSxvMSkpKX1mdW5jdGlvbiBFZm4oZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKHM9bHYoZSxyKSx1PUIoUnUsSWMsMTAsbi5sZW5ndGgsMCwxKSx0PTAsaT1zLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSwxMiksYWUoaWUodyhvLChLKCksQTMpKSkpJiYodVt0KytdPWEodyhvLG9hKSwxMCkpO2lmKHQ8bi5sZW5ndGgpdGhyb3cgYihuZXcgcm8oIkV4cGVjdGVkICIrbi5sZW5ndGgrIiBoaWVyYXJjaGljYWwgcG9ydHMsIGJ1dCBmb3VuZCBvbmx5ICIrdCsiLiIpKTtyZXR1cm4gdX1mdW5jdGlvbiB2SyhlLG4scil7dmFyIHQsbyxpLHMsdSxjO2lmKHQ9ZmZuKHIsZS5sZW5ndGgpLHM9ZVt0XSxpPWFBZShyLHMubGVuZ3RoKSxzW2ldLnR5cGVfMD09KFdlKCksRnIpKWZvcihjPW4ucG9ydHMsbz0wO288Yy5hcnJheS5sZW5ndGg7bysrKXU9KEFlKG8sYy5hcnJheS5sZW5ndGgpLGEoYy5hcnJheVtvXSwxMikpLChyP3Uuc2lkZT09KHJlKCkscWUpOnUuc2lkZT09KHJlKCksamUpKSYmYWUoaWUodyh1LChLKCksQTMpKSkpJiYoS2EoYyxvLGEodyhzW2ldLChLKCksUW4pKSwxMikpLGkrPXI/MTotMSl9ZnVuY3Rpb24gdUFlKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHk7Zm9yKG89ITEscz1uLHU9MCxjPXMubGVuZ3RoO3U8YzsrK3UpaT1zW3VdLGFlKCh6ZSgpLCEhaS5uZXN0ZWRHcmFwaCkpJiYhYShsZShlLmdyYXBoSW5mb0hvbGRlcnMsaS5uZXN0ZWRHcmFwaC5pZF8wKSwyMTkpLnVzZUJvdHRvbVVwJiYobz1vfChfPWkubmVzdGVkR3JhcGgsZD1hKGxlKGUuZ3JhcGhJbmZvSG9sZGVycyxfLmlkXzApLDIxOSksZj1kLmN1cnJlbnROb2RlT3JkZXIsaD1hQWUocixmLmxlbmd0aCksbT1mW2hdWzBdLG0udHlwZV8wPT0oV2UoKSxGcik/ZltoXT1FZm4oaSxmW2hdLHI/KHJlKCksamUpOihyZSgpLHFlKSk6ZC5jcm9zc01pbmltaXplci5zZXRGaXJzdExheWVyT3JkZXIoZixyKSx5PVczKGUsZCxyLHQpLHZLKGQuY3VycmVudE5vZGVPcmRlcixkLnBhcmVudF8wLHIpLHkpKTtyZXR1cm4gb31mdW5jdGlvbiBXMyhlLG4scix0KXt2YXIgbyxpLHMsdSxjO2ZvcihjPW4uY3VycmVudE5vZGVPcmRlcix1PWMubGVuZ3RoLHM9bi5wb3J0RGlzdHJpYnV0b3IuZGlzdHJpYnV0ZVBvcnRzV2hpbGVTd2VlcGluZyhjLHI/MDp1LTEsciksbz1jW3I/MDp1LTFdLHM9c3x1QWUoZSxvLHIsdCksaT1yPzE6dS0yO3I/aTx1Omk+PTA7aSs9cj8xOi0xKXM9c3xuLmNyb3NzTWluaW1pemVyLm1pbmltaXplQ3Jvc3NpbmdzKGMsaSxyLHQmJiFhZShpZSh3KG4ubEdyYXBoLChLKCksRDApKSkpJiYhYWUoaWUodyhuLmxHcmFwaCwoSygpLFFwKSkpKSkscz1zfG4ucG9ydERpc3RyaWJ1dG9yLmRpc3RyaWJ1dGVQb3J0c1doaWxlU3dlZXBpbmcoYyxpLHIpLHM9c3x1QWUoZSxjW2ldLHIsdCk7cmV0dXJuIFlyKGUuZ3JhcGhzV2hvc2VOb2RlT3JkZXJDaGFuZ2VkLG4pLHN9ZnVuY3Rpb24gdmZuKGUpe3ZhciBuLHIsdDtmb3IodD1uZXcgVChlLmdyYXBoSW5mb0hvbGRlcnMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwyMTkpLG49ci5jcm9zc01pbmltaXplci5pc0RldGVybWluaXN0aWMoKT9yLmN1cnJlbnRseUJlc3ROb2RlQW5kUG9ydE9yZGVyOnIuYmVzdE5vZGVBbmRQb3J0T3JkZXIsbiYmQWZuKG4sci5sR3JhcGgpfWZ1bmN0aW9uIGE3KGUpe3lLKCksdGhpcy5jcm9zc01pblR5cGU9ZX1wKDUxNCwxLHs1MTQ6MSwxMDY6MSw0NzoxfSxhNyksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBhKG4sMzYpLHI9VU4oY0FlKSxNbihyLCh4dCgpLEpvKSwoa3QoKSxNNCkpLHJ9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe3lmbih0aGlzLGEobiwzNikscil9LGwucmFuZG9tU2VlZD0wO3ZhciBjQWU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJMYXllclN3ZWVwQ3Jvc3NpbmdNaW5pbWl6ZXIiLDUxNCk7ZnVuY3Rpb24gX0FlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNDE4LDEsSmUsX0FlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtjZm4odGhpcy4kJG91dGVyXzAsYShuLDIxOSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlciIsIkxheWVyU3dlZXBDcm9zc2luZ01pbmltaXplci8wbWV0aG9kcmVmJGNvbXBhcmVEaWZmZXJlbnRSYW5kb21pemVkTGF5b3V0cyRUeXBlIiwxNDE4KTtmdW5jdGlvbiBkQWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE0MTksMSxKZSxkQWUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2hmbih0aGlzLiQkb3V0ZXJfMCxhKG4sMjE5KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiTGF5ZXJTd2VlcENyb3NzaW5nTWluaW1pemVyLzFtZXRob2RyZWYkbWluaW1pemVDcm9zc2luZ3NOb0NvdW50ZXIkVHlwZSIsMTQxOSk7ZnVuY3Rpb24gZkFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNDIwLDEsSmUsZkFlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtsQWUodGhpcy4kJG91dGVyXzAsYShuLDIxOSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlciIsIkxheWVyU3dlZXBDcm9zc2luZ01pbmltaXplci8ybWV0aG9kcmVmJG1pbmltaXplQ3Jvc3NpbmdzV2l0aENvdW50ZXIkVHlwZSIsMTQyMCk7ZnVuY3Rpb24gYWQoKXthZD1GLGozPW5ldyBsNygiQkFSWUNFTlRFUiIsMCksYXY9bmV3IGw3KCJPTkVfU0lERURfR1JFRURZX1NXSVRDSCIsMSksV1A9bmV3IGw3KCJUV09fU0lERURfR1JFRURZX1NXSVRDSCIsMil9ZnVuY3Rpb24gbDcoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBTZm4oZSl7cmV0dXJuIGFkKCksd24oKGdBZSgpLGhBZSksZSl9ZnVuY3Rpb24gQ2ZuKCl7cmV0dXJuIGFkKCksUChJKHBBZSwxKSxXLDQ2NCwwLFtqMyxhdixXUF0pfXAoNDY0LDIyLHszOjEsMzQ6MSwyMjoxLDQ2NDoxfSxsNyk7dmFyIGozLGF2LFdQLHBBZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJMYXllclN3ZWVwQ3Jvc3NpbmdNaW5pbWl6ZXIvQ3Jvc3NNaW5UeXBlIiw0NjQsZ24sQ2ZuLFNmbik7ZnVuY3Rpb24gZ0FlKCl7Z0FlPUYsaEFlPXluKChhZCgpLFAoSShwQWUsMSksVyw0NjQsMCxbajMsYXYsV1BdKSkpfXZhciBoQWU7ZnVuY3Rpb24gbUFlKCl7fXAoMTQxNywxLEluLG1BZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHlLKCksYShuLDMwKS5ub2Rlcy5hcnJheS5sZW5ndGg9PTB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiTGF5ZXJTd2VlcENyb3NzaW5nTWluaW1pemVyL2xhbWJkYSQwJFR5cGUiLDE0MTcpO2Z1bmN0aW9uIFNLKGUsbixyKXt2YXIgdDt0PWUubm9kZUluZm9bci5sYXllci5pZF8wXVtyLmlkXzBdLHQuaGllcmFyY2hpY2FsSW5mbHVlbmNlKz1uLmhpZXJhcmNoaWNhbEluZmx1ZW5jZSx0LnJhbmRvbUluZmx1ZW5jZSs9bi5yYW5kb21JbmZsdWVuY2UsdC5jb25uZWN0ZWRFZGdlcys9bi5jb25uZWN0ZWRFZGdlcywrK3QuY29ubmVjdGVkRWRnZXN9ZnVuY3Rpb24gVGZuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlO2lmKHI9UigkKHcoZS5ncmFwaERhdGEubEdyYXBoLChvZSgpLEdxKSkpKSxyPC0xfHwhZS5ncmFwaERhdGEuaGFzUGFyZW50fHxfbShhKHcoZS5ncmFwaERhdGEucGFyZW50XzAseHIpLDEwMSkpfHxBbyhlLmdyYXBoRGF0YS5wYXJlbnRfMCwocmUoKSxxZSkpLnNpemVfMSgpPDImJkFvKGUuZ3JhcGhEYXRhLnBhcmVudF8wLGplKS5zaXplXzEoKTwyKXJldHVybiEwO2lmKGUuZ3JhcGhEYXRhLmNyb3NzTWluaW1pemVyLmlzRGV0ZXJtaW5pc3RpYygpKXJldHVybiExO2ZvcihIPTAsTT0wLGs9bmV3IFEsYz1lLmdyYXBoRGF0YS5jdXJyZW50Tm9kZU9yZGVyLF89MCxkPWMubGVuZ3RoO188ZDsrK18pe2Zvcih1PWNbX10saD11LG09MCxFPWgubGVuZ3RoO208RTsrK20pe2lmKGY9aFttXSxmLnR5cGVfMD09KFdlKCksdGkpKXtSZShrLmFycmF5LGYpO2NvbnRpbnVlfWZvcih0PWUubm9kZUluZm9bZi5sYXllci5pZF8wXVtmLmlkXzBdLGYudHlwZV8wPT1Gcj8odC5oaWVyYXJjaGljYWxJbmZsdWVuY2U9MSxhKHcoZiwoSygpLFFuKSksMTIpLnNpZGU9PShyZSgpLHFlKSYmKE0rPXQuY29ubmVjdGVkRWRnZXMpKTood2U9QW8oZiwocmUoKSxqZSkpLHdlLmlzRW1wdHkoKXx8IW81KHdlLG5ldyBTQWUpP3QucmFuZG9tSW5mbHVlbmNlPTE6KG89QW8oZixxZSksKG8uaXNFbXB0eSgpfHwhbzUobyxuZXcgdkFlKSkmJihIKz10LmNvbm5lY3RlZEVkZ2VzKSkpLHM9bmV3IFhlKFFlKFJyKGYpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihzKTspaT1hKHRuKHMpLDE4KSxIKz10LnJhbmRvbUluZmx1ZW5jZSxNKz10LmhpZXJhcmNoaWNhbEluZmx1ZW5jZSx2ZT1pLnRhcmdldC5vd25lcixTSyhlLHQsdmUpO2Zvcih4PU5hKFAoSSh4YSwxKSxNZSwyMCwwLFtBbyhmLChyZSgpLFVlKSksQW8oZixsbildKSksbmU9bmV3IFhlKG5ldyBGeih4LnZhbCRpbnB1dHMxLmxlbmd0aCx4LnZhbCRpbnB1dHMxKSk7X24obmUpOylxPWEodG4obmUpLDEyKSxBPWEodyhxLChLKCksb2EpKSwxMCksQSYmKEgrPXQucmFuZG9tSW5mbHVlbmNlLE0rPXQuaGllcmFyY2hpY2FsSW5mbHVlbmNlLFNLKGUsdCxBKSl9Zm9yKHk9bmV3IFQoayk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihmPWEoQyh5KSwxMCksdD1lLm5vZGVJbmZvW2YubGF5ZXIuaWRfMF1bZi5pZF8wXSxzPW5ldyBYZShRZShScihmKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24ocyk7KWk9YSh0bihzKSwxOCksSCs9dC5yYW5kb21JbmZsdWVuY2UsTSs9dC5oaWVyYXJjaGljYWxJbmZsdWVuY2UsdmU9aS50YXJnZXQub3duZXIsU0soZSx0LHZlKTtrLmFycmF5Lmxlbmd0aD0wfXJldHVybiBuPUgrTSx2PW49PTA/aHI6KEgtTSkvbix2Pj1yfWZ1bmN0aW9uIHlBZShlKXt0aGlzLmdyYXBoRGF0YT1lLHRoaXMubm9kZUluZm89QihFQWUsWCwyMDQzLGUuY3VycmVudE5vZGVPcmRlci5sZW5ndGgsMCwyKX1wKDE4NjIsMSxaUyx5QWUpLGwuaW5pdEFmdGVyVHJhdmVyc2FsPWZ1bmN0aW9uKCl7fSxsLmluaXRBdEVkZ2VMZXZlbD1mdW5jdGlvbihuLHIsdCxvLGkscyl7fSxsLmluaXRBdFBvcnRMZXZlbD1mdW5jdGlvbihuLHIsdCxvKXt9LGwuaW5pdEF0TGF5ZXJMZXZlbD1mdW5jdGlvbihuLHIpe3Jbbl1bMF0ubGF5ZXIuaWRfMD1uLHRoaXMubm9kZUluZm9bbl09QihFQWUsezM6MSw0OjEsNToxLDIwNDM6MX0sNjY4LHJbbl0ubGVuZ3RoLDAsMSl9LGwuaW5pdEF0Tm9kZUxldmVsPWZ1bmN0aW9uKG4scix0KXt2YXIgbztvPXRbbl1bcl0sby5pZF8wPXIsVHIodGhpcy5ub2RlSW5mb1tuXSxyLG5ldyB3QWUpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlciIsIkxheWVyU3dlZXBUeXBlRGVjaWRlciIsMTg2Mik7ZnVuY3Rpb24gd0FlKCl7fXAoNjY4LDEsezY2ODoxfSx3QWUpLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJOb2RlSW5mbyBbY29ubmVjdGVkRWRnZXM9Iit0aGlzLmNvbm5lY3RlZEVkZ2VzKyIsIGhpZXJhcmNoaWNhbEluZmx1ZW5jZT0iK3RoaXMuaGllcmFyY2hpY2FsSW5mbHVlbmNlKyIsIHJhbmRvbUluZmx1ZW5jZT0iK3RoaXMucmFuZG9tSW5mbHVlbmNlKyJdIn0sbC5jb25uZWN0ZWRFZGdlcz0wLGwuaGllcmFyY2hpY2FsSW5mbHVlbmNlPTAsbC5yYW5kb21JbmZsdWVuY2U9MDt2YXIgRUFlPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiTGF5ZXJTd2VlcFR5cGVEZWNpZGVyL05vZGVJbmZvIiw2NjgpO2Z1bmN0aW9uIHZBZSgpe31wKDE4NjMsMSxKcyx2QWUpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gQ0UobmV3IExzKGEobiwxMikuY29ubmVjdGVkRWRnZXMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBDRShuZXcgTHMoYShuLDEyKS5jb25uZWN0ZWRFZGdlcykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlciIsIkxheWVyU3dlZXBUeXBlRGVjaWRlci9sYW1iZGEkMCRUeXBlIiwxODYzKTtmdW5jdGlvbiBTQWUoKXt9cCgxODY0LDEsSnMsU0FlKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIENFKG5ldyBMcyhhKG4sMTIpLmNvbm5lY3RlZEVkZ2VzKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gQ0UobmV3IExzKGEobiwxMikuY29ubmVjdGVkRWRnZXMpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJMYXllclN3ZWVwVHlwZURlY2lkZXIvbGFtYmRhJDEkVHlwZSIsMTg2NCk7ZnVuY3Rpb24gQ0FlKGUpe3pOZS5jYWxsKHRoaXMsZSl9cCgxOTA2LDQxMyxxRixDQWUpLGwuY2FsY3VsYXRlUG9ydFJhbmtzPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGg7c3dpdGNoKGQ9dGhpcy5wb3J0UmFua3MsdC5vcmRpbmFsKXtjYXNlIDE6e2ZvcihvPTAsaT0wLF89bmV3IFQobi5wb3J0cyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKF8pLDEyKSx1LmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoIT0wJiYoKytvLHUuc2lkZT09KHJlKCksVWUpJiYrK2kpO2ZvcihzPXIraSxoPXIrbyxjPVUxKG4sKHF0KCksaWEpKS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMTIpLHUuc2lkZT09KHJlKCksVWUpPyhkW3UuaWRfMF09cywtLXMpOihkW3UuaWRfMF09aCwtLWgpO3JldHVybiBvfWNhc2UgMjp7Zm9yKGY9MCxjPVUxKG4sKHF0KCkscGkpKS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMTIpLCsrZixkW3UuaWRfMF09citmO3JldHVybiBmfWRlZmF1bHQ6dGhyb3cgYihuZXcgVEMpfX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJMYXllclRvdGFsUG9ydERpc3RyaWJ1dG9yIiwxOTA2KTtmdW5jdGlvbiBiZm4oZSxuLHIpe3ZhciB0LG8saTtyZXR1cm4gdD1lLmJhcnljZW50ZXJTdGF0ZVtuLmxheWVyLmlkXzBdW24uaWRfMF0sbz1lLmJhcnljZW50ZXJTdGF0ZVtyLmxheWVyLmlkXzBdW3IuaWRfMF0sdC5iYXJ5Y2VudGVyIT1udWxsJiZvLmJhcnljZW50ZXIhPW51bGw/KGk9TzUodC5iYXJ5Y2VudGVyLG8uYmFyeWNlbnRlciksaTwwP1YzKGUsbixyKTppPjAmJlYzKGUscixuKSxpKTp0LmJhcnljZW50ZXIhPW51bGw/KFYzKGUsbixyKSwtMSk6by5iYXJ5Y2VudGVyIT1udWxsPyhWMyhlLHIsbiksMSk6MH1mdW5jdGlvbiBJZm4oZSxuLHIpe2lmKHlpKGUuYmlnZ2VyVGhhbixuKSl7aWYoc3MoYShLZShlLmJpZ2dlclRoYW4sbiksNDkpLHIpKXJldHVybiAxfWVsc2UgQm4oZS5iaWdnZXJUaGFuLG4sbmV3IEJyKTtpZih5aShlLmJpZ2dlclRoYW4scikpe2lmKHNzKGEoS2UoZS5iaWdnZXJUaGFuLHIpLDQ5KSxuKSlyZXR1cm4tMX1lbHNlIEJuKGUuYmlnZ2VyVGhhbixyLG5ldyBCcik7aWYoeWkoZS5zbWFsbGVyVGhhbixuKSl7aWYoc3MoYShLZShlLnNtYWxsZXJUaGFuLG4pLDQ5KSxyKSlyZXR1cm4tMX1lbHNlIEJuKGUuc21hbGxlclRoYW4sbixuZXcgQnIpO2lmKHlpKGUuc21hbGxlclRoYW4scikpe2lmKHNzKGEoS2UoZS5zbWFsbGVyVGhhbixyKSw0OSksbikpcmV0dXJuIDF9ZWxzZSBCbihlLnNtYWxsZXJUaGFuLHIsbmV3IEJyKTtyZXR1cm4gMH1mdW5jdGlvbiB4Zm4oZSxuLHIpe3ZhciB0LG87cmV0dXJuIHQ9SWZuKGUsbixyKSx0IT0wP3Q6X3IobiwoSygpLHJyKSkmJl9yKHIscnIpPyhvPXFvKGEodyhuLHJyKSwxNykudmFsdWVfMCxhKHcocixyciksMTcpLnZhbHVlXzApLG88MD9WMyhlLG4scik6bz4wJiZWMyhlLHIsbiksbyk6YmZuKGUsbixyKX1mdW5jdGlvbiBWMyhlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IodD1hKEtlKGUuYmlnZ2VyVGhhbixuKSw0OSksaT1hKEtlKGUuYmlnZ2VyVGhhbixyKSw0OSksbz1hKEtlKGUuc21hbGxlclRoYW4sbiksNDkpLHM9YShLZShlLnNtYWxsZXJUaGFuLHIpLDQ5KSx0Lm1hcF8wLnB1dChyLHQpLHMubWFwXzAucHV0KG4scyksZD1pLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KV89YShkLm5leHRfMSgpLDEwKSx0Lm1hcF8wLnB1dChfLHQpLFlyKGEoS2UoZS5zbWFsbGVyVGhhbixfKSw0OSksbiksZnQoYShLZShlLnNtYWxsZXJUaGFuLF8pLDQ5KSxvKTtmb3IoYz1vLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KXU9YShjLm5leHRfMSgpLDEwKSxzLm1hcF8wLnB1dCh1LHMpLFlyKGEoS2UoZS5iaWdnZXJUaGFuLHUpLDQ5KSxyKSxmdChhKEtlKGUuYmlnZ2VyVGhhbix1KSw0OSksaSl9ZnVuY3Rpb24gVEFlKGUsbixyKXtoSy5jYWxsKHRoaXMsZSxuLHIpLHRoaXMuYmlnZ2VyVGhhbj1uZXcgc24sdGhpcy5zbWFsbGVyVGhhbj1uZXcgc24sdGhpcy5iYXJ5Y2VudGVyU3RhdGVDb21wYXJhdG9yPW5ldyBJQWUodGhpcyl9ZnVuY3Rpb24gYkFlKGUsbixyKXt2YXIgdCxvLGk7Zm9yKHQ9MTt0PGUuYXJyYXkubGVuZ3RoO3QrKyl7Zm9yKGk9KEFlKHQsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVt0XSwxMCkpLG89dDtvPjAmJm4uY29tcGFyZV8xKChBZShvLTEsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtvLTFdLDEwKSksaSk+MDspS2EoZSxvLChBZShvLTEsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtvLTFdLDEwKSkpLC0tbztBZShvLGUuYXJyYXkubGVuZ3RoKSxlLmFycmF5W29dPWl9ci5iaWdnZXJUaGFuPW5ldyBzbixyLnNtYWxsZXJUaGFuPW5ldyBzbn1wKDY2OSw4MzIsezY2OToxLDIzMDoxfSxUQWUpLGwubWluaW1pemVDcm9zc2luZ3NfMD1mdW5jdGlvbihuLHIsdCxvKXt0P0hOZSh0aGlzLG4pOihCTmUodGhpcyxuLG8pLEdOZSh0aGlzLG4scikpLG4uYXJyYXkubGVuZ3RoPjEmJihhZShpZSh3KFN0KChBZSgwLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbMF0sMTApKSksKG9lKCksUTEpKSkpP2JBZShuLHRoaXMuYmFyeWNlbnRlclN0YXRlQ29tcGFyYXRvcix0aGlzKTooTmUoKSxEcihuLHRoaXMuYmFyeWNlbnRlclN0YXRlQ29tcGFyYXRvcikpLGFlKGllKHcoU3QoKEFlKDAsbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVswXSwxMCkpKSxRMSkpKXx8WU5lKHRoaXMuY29uc3RyYWludFJlc29sdmVyLG4pKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJNb2RlbE9yZGVyQmFyeWNlbnRlckhldXJpc3RpYyIsNjY5KTtmdW5jdGlvbiBJQWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE4NjYsMSxObixJQWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHhmbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTApLGEociwxMCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiTW9kZWxPcmRlckJhcnljZW50ZXJIZXVyaXN0aWMvbGFtYmRhJDAkVHlwZSIsMTg2Nik7ZnVuY3Rpb24geEFlKCl7eEFlPUYsTkFlPWh1KEZSZShNbihNbihuZXcgSHIsKHh0KCksSm8pLChrdCgpLEw0KSkscmksSTQpLGhvKSxBNCl9ZnVuY3Rpb24gUGZuKGUpe2UuYmVnaW4oIk5vIGNyb3NzaW5nIG1pbmltaXphdGlvbiIsMSksZS5kb25lXzEoKX1mdW5jdGlvbiBQQWUoKXt4QWUoKX1wKDE0MjMsMSxXdCxQQWUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gYShuLDM2KSxyPVVOKE5BZSksTW4ociwoeHQoKSxKbyksKGt0KCksTTQpKSxyfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtQZm4oKGEobiwzNikscikpfTt2YXIgTkFlO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiTm9Dcm9zc2luZ01pbmltaXplciIsMTQyMyk7ZnVuY3Rpb24gQ0soZSl7ek5lLmNhbGwodGhpcyxlKX1wKDgwOSw0MTMscUYsQ0spLGwuY2FsY3VsYXRlUG9ydFJhbmtzPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbSx5O3N3aXRjaChoPXRoaXMucG9ydFJhbmtzLHQub3JkaW5hbCl7Y2FzZSAxOntmb3IoaT0wLHM9MCxmPW5ldyBUKG4ucG9ydHMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylfPWEoQyhmKSwxMiksXy5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCE9MCYmKCsraSxfLnNpZGU9PShyZSgpLFVlKSYmKytzKTtmb3Iobz0xLyhpKzEpLHU9citzKm8seT1yKzEtbyxkPVUxKG4sKHF0KCksaWEpKS5pdGVyYXRvcl8wKCk7ZC5oYXNOZXh0XzAoKTspXz1hKGQubmV4dF8xKCksMTIpLF8uc2lkZT09KHJlKCksVWUpPyhoW18uaWRfMF09dSx1LT1vKTooaFtfLmlkXzBdPXkseS09byk7YnJlYWt9Y2FzZSAyOntmb3IoYz0wLGY9bmV3IFQobi5wb3J0cyk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGYpLDEyKSxfLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoPT0wfHwrK2M7Zm9yKG89MS8oYysxKSxtPXIrbyxkPVUxKG4sKHF0KCkscGkpKS5pdGVyYXRvcl8wKCk7ZC5oYXNOZXh0XzAoKTspXz1hKGQubmV4dF8xKCksMTIpLGhbXy5pZF8wXT1tLG0rPW87YnJlYWt9ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiUG9ydCB0eXBlIGlzIHVuZGVmaW5lZCIpKX1yZXR1cm4gMX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIiLCJOb2RlUmVsYXRpdmVQb3J0RGlzdHJpYnV0b3IiLDgwOSk7ZnVuY3Rpb24gTmZuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihvPWEodyhlLChLKCksWDEpKSwxMCksdD1lLnBvcnRzLHI9KEFlKDAsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVswXSwxMikpLHM9bmV3IFQoby5wb3J0cyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKGk9YShDKHMpLDEyKSxEKGkpPT09RCh3KHIsUW4pKSl7aS5zaWRlPT0ocmUoKSxVZSkmJmUuaWRfMD5vLmlkXzA/KFhyKGksbG4pLGkuZXhwbGljaXRseVN1cHBsaWVkUG9ydEFuY2hvciYmKHU9aS5zaXplXzAueV8wLG49aS5hbmNob3IueV8wLGkuYW5jaG9yLnlfMD11LW4pKTppLnNpZGU9PWxuJiZvLmlkXzA+ZS5pZF8wJiYoWHIoaSxVZSksaS5leHBsaWNpdGx5U3VwcGxpZWRQb3J0QW5jaG9yJiYodT1pLnNpemVfMC55XzAsbj1pLmFuY2hvci55XzAsaS5hbmNob3IueV8wPS0odS1uKSkpO2JyZWFrfXJldHVybiBvfWZ1bmN0aW9uIEFBZShlKXt2YXIgbixyO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7Zm9yKHI9QihSdSxYLDE5OSxlLmxlbmd0aCwwLDIpLG49MDtuPHIubGVuZ3RoO24rKylyW25dPWEocVplKGVbbl0sZVtuXS5sZW5ndGgpLDE5OSk7cmV0dXJuIHJ9ZnVuY3Rpb24gQWZuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IoZD1uZXcgUSxoPW5ldyBCcixzPW4ubGF5ZXJzLG89MDtvPHMuYXJyYXkubGVuZ3RoO28rKyl7Zm9yKF89KEFlKG8scy5hcnJheS5sZW5ndGgpLGEocy5hcnJheVtvXSwzMCkpLm5vZGVzLGQuYXJyYXkubGVuZ3RoPTAsaT0wO2k8Xy5hcnJheS5sZW5ndGg7aSsrKXU9ZS5ub2RlT3JkZXJbb11baV0sdS5pZF8wPWksdS50eXBlXzA9PShXZSgpLHRpKSYmUmUoZC5hcnJheSx1KSxLYShhKGxlKG4ubGF5ZXJzLG8pLDMwKS5ub2RlcyxpLHUpLHUucG9ydHMuYXJyYXkubGVuZ3RoPTAscXIodS5wb3J0cyxhKGEobGUoZS5wb3J0T3JkZXJzLG8pLDE1KS5nZXRfMChpKSwxNikpLF9tKGEodyh1LChvZSgpLHhyKSksMTAxKSl8fGoodSx4ciwoZHQoKSxvMSkpO2Zvcih0PW5ldyBUKGQpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxMCksZj1OZm4ociksaC5tYXBfMC5wdXQoZixoKSxoLm1hcF8wLnB1dChyLGgpfWZvcihjPWgubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7Yy5oYXNOZXh0XzAoKTspdT1hKGMubmV4dF8xKCksMTApLE5lKCksRHIodS5wb3J0cywoR3koKSxLaikpLHUucG9ydFNpZGVzQ2FjaGVkPSEwLEZXKHUpfWZ1bmN0aW9uIExBZShlKXt0aGlzLm5vZGVPcmRlcj1BQWUoZS5ub2RlT3JkZXIpLHRoaXMucG9ydE9yZGVycz1uZXcgUWkoZS5wb3J0T3JkZXJzKX1mdW5jdGlvbiBrQWUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfO2Zvcih0aGlzLm5vZGVPcmRlcj1BQWUoZSksdGhpcy5wb3J0T3JkZXJzPW5ldyBRLHI9ZSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KWZvcihuPXJbdF0saT1uZXcgUSxlZSh0aGlzLnBvcnRPcmRlcnMsaSksdT1uLGM9MCxfPXUubGVuZ3RoO2M8XzsrK2Mpcz11W2NdLGVlKGksbmV3IFFpKHMucG9ydHMpKX1wKDgyMiwxLHt9LExBZSxrQWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyIiwiU3dlZXBDb3B5Iiw4MjIpO2Z1bmN0aW9uIE9BZShlLG4pe3ZhciByLHQ7aWYobi5sZW5ndGg9PTApcmV0dXJuIDA7Zm9yKHI9dTcoZS5jcm9zc2luZ0NvdW50ZXIsblswXSwocmUoKSxqZSkpLHIrPXU3KGUuY3Jvc3NpbmdDb3VudGVyLG5bbi5sZW5ndGgtMV0scWUpLHQ9MDt0PG4ubGVuZ3RoO3QrKylyKz1MZm4oZSx0LG4pO3JldHVybiByfWZ1bmN0aW9uIExmbihlLG4scil7dmFyIHQsbyxpO3JldHVybiBpPTAsdD1yW25dLG48ci5sZW5ndGgtMSYmKG89cltuKzFdLGUuaGFzSHlwZXJFZGdlc0Vhc3RPZkluZGV4W25dPyhpPVZmbihlLmh5cGVyZWRnZUNyb3NzaW5nc0NvdW50ZXIsdCxvKSxpKz11NyhlLmNyb3NzaW5nQ291bnRlcix0LChyZSgpLHFlKSksaSs9dTcoZS5jcm9zc2luZ0NvdW50ZXIsbyxqZSkpOmk9TWZuKGUuY3Jvc3NpbmdDb3VudGVyLHQsbykpLGUuaGFzTm9ydGhTb3V0aFBvcnRzW25dJiYoaSs9RGZuKGUuY3Jvc3NpbmdDb3VudGVyLHQpKSxpfWZ1bmN0aW9uIE1BZShlKXt0aGlzLmluTGF5ZXJFZGdlQ291bnRzPUIoaG4sa24sMjgsZS5sZW5ndGgsMTUsMSksdGhpcy5oYXNOb3J0aFNvdXRoUG9ydHM9Qih5YSx4dSwyOCxlLmxlbmd0aCwxNiwxKSx0aGlzLmhhc0h5cGVyRWRnZXNFYXN0T2ZJbmRleD1CKHlhLHh1LDI4LGUubGVuZ3RoLDE2LDEpLHRoaXMublBvcnRzPTB9cCgxODYxLDEsWlMsTUFlKSxsLmluaXRBdExheWVyTGV2ZWw9ZnVuY3Rpb24obixyKXt9LGwuaW5pdEFmdGVyVHJhdmVyc2FsPWZ1bmN0aW9uKCl7dmFyIG47bj1CKGhuLGtuLDI4LHRoaXMublBvcnRzLDE1LDEpLHRoaXMuaHlwZXJlZGdlQ3Jvc3NpbmdzQ291bnRlcj1uZXcgWUFlKG4pLHRoaXMuY3Jvc3NpbmdDb3VudGVyPW5ldyBxMyhuKX0sbC5pbml0QXRFZGdlTGV2ZWw9ZnVuY3Rpb24obixyLHQsbyxpLHMpe3ZhciB1O3U9YShsZShzW25dW3JdLnBvcnRzLHQpLDEyKSxpLnNvdXJjZT09dSYmaS5zb3VyY2Uub3duZXIubGF5ZXI9PWkudGFyZ2V0Lm93bmVyLmxheWVyJiYrK3RoaXMuaW5MYXllckVkZ2VDb3VudHNbbl19LGwuaW5pdEF0Tm9kZUxldmVsPWZ1bmN0aW9uKG4scix0KXt2YXIgbztvPXRbbl1bcl0sdGhpcy5oYXNOb3J0aFNvdXRoUG9ydHNbbl09dGhpcy5oYXNOb3J0aFNvdXRoUG9ydHNbbl18by50eXBlXzA9PShXZSgpLHRpKX0sbC5pbml0QXRQb3J0TGV2ZWw9ZnVuY3Rpb24obixyLHQsbyl7dmFyIGk7aT1hKGxlKG9bbl1bcl0ucG9ydHMsdCksMTIpLGkuaWRfMD10aGlzLm5Qb3J0cysrLGkub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgraS5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xJiYoaS5zaWRlPT0ocmUoKSxxZSk/dGhpcy5oYXNIeXBlckVkZ2VzRWFzdE9mSW5kZXhbbl09ITA6aS5zaWRlPT1qZSYmbj4wJiYodGhpcy5oYXNIeXBlckVkZ2VzRWFzdE9mSW5kZXhbbi0xXT0hMCkpfSxsLm5Qb3J0cz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyLmNvdW50aW5nIiwiQWxsQ3Jvc3NpbmdzQ291bnRlciIsMTg2MSk7ZnVuY3Rpb24gVEsoZSxuKXt2YXIgcjtmb3IoKytlLnNpemVfMCwrK2UubnVtc1BlckluZGV4W25dLHI9bisxO3I8ZS5iaW5hcnlTdW1zLmxlbmd0aDspKytlLmJpbmFyeVN1bXNbcl0scis9ciYtcn1mdW5jdGlvbiBzNyhlKXtlLmJpbmFyeVN1bXM9QihobixrbiwyOCxlLm1heE51bSsxLDE1LDEpLGUubnVtc1BlckluZGV4PUIoaG4sa24sMjgsZS5tYXhOdW0sMTUsMSksZS5zaXplXzA9MH1mdW5jdGlvbiBiSyhlLG4pe3ZhciByLHQ7Zm9yKHI9bix0PTA7cj4wOyl0Kz1lLmJpbmFyeVN1bXNbcl0sci09ciYtcjtyZXR1cm4gdH1mdW5jdGlvbiBJSyhlLG4pe3ZhciByLHQ7aWYodD1lLm51bXNQZXJJbmRleFtuXSx0IT0wKWZvcihlLm51bXNQZXJJbmRleFtuXT0wLGUuc2l6ZV8wLT10LHI9bisxO3I8ZS5iaW5hcnlTdW1zLmxlbmd0aDspZS5iaW5hcnlTdW1zW3JdLT10LHIrPXImLXJ9ZnVuY3Rpb24galAoZSl7dGhpcy5tYXhOdW09ZSx0aGlzLmJpbmFyeVN1bXM9QihobixrbiwyOCxlKzEsMTUsMSksdGhpcy5udW1zUGVySW5kZXg9QihobixrbiwyOCxlLDE1LDEpLHRoaXMuc2l6ZV8wPTB9cCg1OTUsMSx7fSxqUCksbC5tYXhOdW09MCxsLnNpemVfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyLmNvdW50aW5nIiwiQmluYXJ5SW5kZXhlZFRyZWUiLDU5NSk7ZnVuY3Rpb24gbHYoZSxuKXtzd2l0Y2gobi5vcmRpbmFsKXtjYXNlIDI6Y2FzZSAxOnJldHVybiBBbyhlLG4pO2Nhc2UgMzpjYXNlIDQ6cmV0dXJuIHFhKEFvKGUsbikpfXJldHVybiBOZSgpLE5lKCksT3R9ZnVuY3Rpb24gcHcoKXtwdz1GLGtLPShyZSgpLGplKSxWUD1xZX1mdW5jdGlvbiBrZm4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoO2ZvcihoPW5ldyBGYyhuZXcgR0FlKGUpKSx1PVAoSShSdSwxKSxJYywxMCwwLFtuLHJdKSxjPTAsXz11Lmxlbmd0aDtjPF87KytjKWZvcihzPXVbY10sZj1sdihzLHQpLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOylmb3IoZD1hKGYubmV4dF8xKCksMTIpLGk9bmV3IExzKGQuY29ubmVjdGVkRWRnZXMpO3hvKGkuZmlyc3RJdGVyYXRvcil8fHhvKGkuc2Vjb25kSXRlcmF0b3IpOylvPWEoeG8oaS5maXJzdEl0ZXJhdG9yKT9DKGkuZmlyc3RJdGVyYXRvcik6QyhpLnNlY29uZEl0ZXJhdG9yKSwxOCksenQobyl8fChoLm1hcF8wLnB1dChkLCh6ZSgpLFMwKSk9PW51bGwsekFlKG8pJiZCQyhoLGQ9PW8uc291cmNlP28udGFyZ2V0Om8uc291cmNlKSk7cmV0dXJuIHZuKGgpLG5ldyBRaShoKX1mdW5jdGlvbiBPZm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfO2ZvcihfPW5ldyBGYyhuZXcgSEFlKGUpKSxzPVAoSShvMmUsMSksZ2llLDEyLDAsW24scl0pLHU9MCxjPXMubGVuZ3RoO3U8YzsrK3UpZm9yKGk9c1t1XSxfLm1hcF8wLnB1dChpLCh6ZSgpLFMwKSk9PW51bGwsbz1uZXcgTHMoaS5jb25uZWN0ZWRFZGdlcyk7eG8oby5maXJzdEl0ZXJhdG9yKXx8eG8oby5zZWNvbmRJdGVyYXRvcik7KXQ9YSh4byhvLmZpcnN0SXRlcmF0b3IpP0Moby5maXJzdEl0ZXJhdG9yKTpDKG8uc2Vjb25kSXRlcmF0b3IpLDE4KSx0LnNvdXJjZT09dC50YXJnZXR8fEJDKF8saT09dC5zb3VyY2U/dC50YXJnZXQ6dC5zb3VyY2UpO3JldHVybiB2bihfKSxuZXcgUWkoXyl9ZnVuY3Rpb24gTWZuKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1GQWUoZSxuLHIpLGUuaW5kZXhUcmVlPW5ldyBqUCh0LmFycmF5Lmxlbmd0aCkseEsoZSx0KX1mdW5jdGlvbiBSQWUoZSxuLHIpe3ZhciB0LG8saTtyZXR1cm4gbz1PZm4oZSxuLHIpLGk9eEsoZSxvKSxzNyhlLmluZGV4VHJlZSksZjcoZSxuLHIpLE5lKCksRHIobyxuZXcgJEFlKGUpKSx0PXhLKGUsbyksczcoZS5pbmRleFRyZWUpLGY3KGUscixuKSxuZXcgWnIoSihpKSxKKHQpKX1mdW5jdGlvbiB4SyhlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3Iocj0wLHU9bmV3IFQobik7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iocz1hKEModSksMTIpLElLKGUuaW5kZXhUcmVlLGUucG9ydFBvc2l0aW9uc1tzLmlkXzBdKSxvPW5ldyBMcyhzLmNvbm5lY3RlZEVkZ2VzKTt4byhvLmZpcnN0SXRlcmF0b3IpfHx4byhvLnNlY29uZEl0ZXJhdG9yKTspdD1hKHhvKG8uZmlyc3RJdGVyYXRvcik/QyhvLmZpcnN0SXRlcmF0b3IpOkMoby5zZWNvbmRJdGVyYXRvciksMTgpLGk9TEsoZSxzPT10LnNvdXJjZT90LnRhcmdldDp0LnNvdXJjZSksaT5lLnBvcnRQb3NpdGlvbnNbcy5pZF8wXSYmKHIrPWJLKGUuaW5kZXhUcmVlLGkpLEkwKGUuZW5kcyxKKGkpKSk7Zm9yKDshWTIoZS5lbmRzKTspVEsoZS5pbmRleFRyZWUsYShtaChlLmVuZHMpLDE3KS52YWx1ZV8wKX1yZXR1cm4gcn1mdW5jdGlvbiBEQWUoZSxuLHIsdCl7dmFyIG8saSxzO3JldHVybiBpPWtmbihlLG4scix0KSxzPVBLKGUsaSksZDcoZSxuLHIsdCksczcoZS5pbmRleFRyZWUpLE5lKCksRHIoaSxuZXcgQkFlKGUpKSxvPVBLKGUsaSksZDcoZSxyLG4sdCksczcoZS5pbmRleFRyZWUpLG5ldyBacihKKHMpLEoobykpfWZ1bmN0aW9uIFBLKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKHI9MCxjPW5ldyBUKG4pO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHU9YShDKGMpLDEyKSxJSyhlLmluZGV4VHJlZSxlLnBvcnRQb3NpdGlvbnNbdS5pZF8wXSkscz0wLG89bmV3IExzKHUuY29ubmVjdGVkRWRnZXMpO3hvKG8uZmlyc3RJdGVyYXRvcil8fHhvKG8uc2Vjb25kSXRlcmF0b3IpOyl0PWEoeG8oby5maXJzdEl0ZXJhdG9yKT9DKG8uZmlyc3RJdGVyYXRvcik6QyhvLnNlY29uZEl0ZXJhdG9yKSwxOCksekFlKHQpPyhpPUxLKGUsdT09dC5zb3VyY2U/dC50YXJnZXQ6dC5zb3VyY2UpLGk+ZS5wb3J0UG9zaXRpb25zW3UuaWRfMF0mJihyKz1iSyhlLmluZGV4VHJlZSxpKSxJMChlLmVuZHMsSihpKSkpKTorK3M7Zm9yKHIrPWUuaW5kZXhUcmVlLnNpemVfMCpzOyFZMihlLmVuZHMpOylUSyhlLmluZGV4VHJlZSxhKG1oKGUuZW5kcyksMTcpLnZhbHVlXzApfXJldHVybiByfWZ1bmN0aW9uIHU3KGUsbixyKXt2YXIgdDtyZXR1cm4gdD1fNyhlLG4sciksUEsoZSx0KX1mdW5jdGlvbiBSZm4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKHI9MCxkPW5ldyBRLHU9bmV3IFQobik7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtzd2l0Y2gocz1hKEModSksMTIpLElLKGUuaW5kZXhUcmVlLGUucG9ydFBvc2l0aW9uc1tzLmlkXzBdKSxkLmFycmF5Lmxlbmd0aD0wLHMub3duZXIudHlwZV8wLm9yZGluYWwpe2Nhc2UgMDp0PWEodyhzLChLKCksb2EpKSwxMCksd2kodC5wb3J0cyxuZXcgVUFlKGQpKTticmVhaztjYXNlIDE6UFFlKHh5KEpuKG5ldyBTZShudWxsLG5ldyB4ZShzLm93bmVyLnBvcnRzLDE2KSksbmV3IFdBZShzKSkpLG5ldyBWQWUoZCkpO2JyZWFrO2Nhc2UgMzpvPWEodyhzLChLKCksUW4pKSwxMiksZWUoZCxuZXcgWnIobyxKKHMuaW5jb21pbmdFZGdlcy5hcnJheS5sZW5ndGgrcy5vdXRnb2luZ0VkZ2VzLmFycmF5Lmxlbmd0aCkpKX1mb3IoXz1uZXcgVChkKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksNDIpLGk9TEsoZSxhKGMuZmlyc3QsMTIpKSxpPmUucG9ydFBvc2l0aW9uc1tzLmlkXzBdJiYocis9YksoZS5pbmRleFRyZWUsaSkqYShjLnNlY29uZCwxNykudmFsdWVfMCxJMChlLmVuZHMsSihpKSkpO2Zvcig7IVkyKGUuZW5kcyk7KVRLKGUuaW5kZXhUcmVlLGEobWgoZS5lbmRzKSwxNykudmFsdWVfMCl9cmV0dXJuIHJ9ZnVuY3Rpb24gRGZuKGUsbil7dmFyIHI7cmV0dXJuIHI9RmZuKGUsbiksZS5pbmRleFRyZWU9bmV3IGpQKHIuYXJyYXkubGVuZ3RoKSxSZm4oZSxyKX1mdW5jdGlvbiBOSyhlLG4scix0LG8pe3ZhciBpLHMsdTtmb3Iocz1vO24uaGVhZCE9bi50YWlsOylpPWEobWgobiksMTApLHU9YShBbyhpLHQpLmdldF8wKDApLDEyKSxlLnBvcnRQb3NpdGlvbnNbdS5pZF8wXT1zKyssUmUoci5hcnJheSx1KTtyZXR1cm4gc31mdW5jdGlvbiBjNyhlLG4scil7dmFyIHQ7dD1GQWUoZSxuLHIpLGUuaW5kZXhUcmVlPW5ldyBqUCh0LmFycmF5Lmxlbmd0aCl9ZnVuY3Rpb24gRkFlKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1uZXcgUSxBSyhlLG4sdCwocmUoKSxxZSksITAsITEpLEFLKGUscix0LGplLCExLCExKSx0fWZ1bmN0aW9uIF83KGUsbixyKXt2YXIgdDtyZXR1cm4gdD1uZXcgUSxBSyhlLG4sdCxyLCEwLCEwKSxlLmluZGV4VHJlZT1uZXcgalAodC5hcnJheS5sZW5ndGgpLHR9ZnVuY3Rpb24gQUsoZSxuLHIsdCxvLGkpe3ZhciBzLHUsYyxfLGQsZjtmb3IoXz1yLmFycmF5Lmxlbmd0aCxpJiYoZS5ub2RlQ2FyZGluYWxpdGllcz1CKGhuLGtuLDI4LG4ubGVuZ3RoLDE1LDEpKSxzPW8/MDpuLmxlbmd0aC0xO28/czxuLmxlbmd0aDpzPj0wO3MrPW8/MTotMSl7Zm9yKHU9bltzXSxjPXQ9PShyZSgpLHFlKT9vP0FvKHUsdCk6cWEoQW8odSx0KSk6bz9xYShBbyh1LHQpKTpBbyh1LHQpLGkmJihlLm5vZGVDYXJkaW5hbGl0aWVzW3UuaWRfMF09Yy5zaXplXzEoKSksZj1jLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOylkPWEoZi5uZXh0XzEoKSwxMiksZS5wb3J0UG9zaXRpb25zW2QuaWRfMF09XysrO3FyKHIsYyl9fWZ1bmN0aW9uIEZmbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihkPW5ldyBRLGY9bmV3IEFwLGk9bnVsbCxvPTAsdD0wO3Q8bi5sZW5ndGg7Kyt0KXN3aXRjaChyPW5bdF0semZuKGkscikmJihvPU5LKGUsZixkLFZQLG8pKSxfcihyLChLKCksWDEpKSYmKGk9YSh3KHIsWDEpLDEwKSksci50eXBlXzAub3JkaW5hbCl7Y2FzZSAwOmZvcihjPUJ6KGloKEFvKHIsKHJlKCksVWUpKSxuZXcgT0spKTtONihjKTspcz1hKHB6KGMpLDEyKSxlLnBvcnRQb3NpdGlvbnNbcy5pZF8wXT1vKyssUmUoZC5hcnJheSxzKTtmb3Iobz1OSyhlLGYsZCxWUCxvKSxfPUJ6KGloKEFvKHIsbG4pLG5ldyBPSykpO042KF8pOylzPWEocHooXyksMTIpLGUucG9ydFBvc2l0aW9uc1tzLmlkXzBdPW8rKyxSZShkLmFycmF5LHMpO2JyZWFrO2Nhc2UgMzpBbyhyLGtLKS5pc0VtcHR5KCl8fChzPWEoQW8ocixrSykuZ2V0XzAoMCksMTIpLGUucG9ydFBvc2l0aW9uc1tzLmlkXzBdPW8rKyxSZShkLmFycmF5LHMpKSxBbyhyLFZQKS5pc0VtcHR5KCl8fEkwKGYscik7YnJlYWs7Y2FzZSAxOmZvcih1PUFvKHIsKHJlKCksamUpKS5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMTIpLGUucG9ydFBvc2l0aW9uc1tzLmlkXzBdPW8rKyxSZShkLmFycmF5LHMpO0FvKHIscWUpLmZvckVhY2hfMChuZXcgcUFlKGYscikpfXJldHVybiBOSyhlLGYsZCxWUCxvKSxkfWZ1bmN0aW9uIHpBZShlKXt2YXIgbixyO3JldHVybiBuPWUuc291cmNlLm93bmVyLmxheWVyLHI9ZS50YXJnZXQub3duZXIubGF5ZXIsbj09cn1mdW5jdGlvbiB6Zm4oZSxuKXt2YXIgcjtyZXR1cm4hZXx8ZT09bnx8IV9yKG4sKEsoKSxYMSkpPyExOihyPWEodyhuLChLKCksWDEpKSwxMCksciE9ZSl9ZnVuY3Rpb24gJGZuKGUsbixyKXtyZXR1cm4gcW8oZS5wb3J0UG9zaXRpb25zW24uaWRfMF0sZS5wb3J0UG9zaXRpb25zW3IuaWRfMF0pfWZ1bmN0aW9uIEJmbihlLG4scil7cmV0dXJuIHFvKGUucG9ydFBvc2l0aW9uc1tuLmlkXzBdLGUucG9ydFBvc2l0aW9uc1tyLmlkXzBdKX1mdW5jdGlvbiBHZm4oZSxuLHIpe3JldHVybiBxbyhlLnBvcnRQb3NpdGlvbnNbbi5pZF8wXSxlLnBvcnRQb3NpdGlvbnNbci5pZF8wXSl9ZnVuY3Rpb24gSGZuKGUsbixyKXtyZXR1cm4gcW8oZS5wb3J0UG9zaXRpb25zW24uaWRfMF0sZS5wb3J0UG9zaXRpb25zW3IuaWRfMF0pfWZ1bmN0aW9uIExLKGUsbil7cmV0dXJuIGUucG9ydFBvc2l0aW9uc1tuLmlkXzBdfWZ1bmN0aW9uIGQ3KGUsbixyLHQpe3ZhciBvLGkscyx1O2Zvcih1PWx2KG4sdCkscz11Lml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylvPWEocy5uZXh0XzEoKSwxMiksZS5wb3J0UG9zaXRpb25zW28uaWRfMF09ZS5wb3J0UG9zaXRpb25zW28uaWRfMF0rZS5ub2RlQ2FyZGluYWxpdGllc1tyLmlkXzBdO2Zvcih1PWx2KHIsdCksaT11Lml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSwxMiksZS5wb3J0UG9zaXRpb25zW28uaWRfMF09ZS5wb3J0UG9zaXRpb25zW28uaWRfMF0tZS5ub2RlQ2FyZGluYWxpdGllc1tuLmlkXzBdfWZ1bmN0aW9uIGY3KGUsbixyKXt2YXIgdDt0PWUucG9ydFBvc2l0aW9uc1tuLmlkXzBdLGUucG9ydFBvc2l0aW9uc1tuLmlkXzBdPWUucG9ydFBvc2l0aW9uc1tyLmlkXzBdLGUucG9ydFBvc2l0aW9uc1tyLmlkXzBdPXR9ZnVuY3Rpb24gcTMoZSl7cHcoKSx0aGlzLnBvcnRQb3NpdGlvbnM9ZSx0aGlzLmVuZHM9bmV3IEFwfWZ1bmN0aW9uIFVmbihlLG4pe3JldHVybiBwdygpLGVlKGUsbmV3IFpyKG4sSihuLmluY29taW5nRWRnZXMuYXJyYXkubGVuZ3RoK24ub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgpKSl9ZnVuY3Rpb24gV2ZuKGUsbil7cmV0dXJuIHB3KCksbiE9ZX1mdW5jdGlvbiBqZm4oZSxuKXtyZXR1cm4gcHcoKSxlZShlLG5ldyBacihuLEoobi5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aCtuLm91dGdvaW5nRWRnZXMuYXJyYXkubGVuZ3RoKSkpfXAoNTMyLDEse30scTMpO3ZhciBrSyxWUDtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkNyb3NzaW5nc0NvdW50ZXIiLDUzMik7ZnVuY3Rpb24gJEFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxOTUwLDEsTm4sJEFlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiAkZm4odGhpcy4kJG91dGVyXzAsYShuLDEyKSxhKHIsMTIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkNyb3NzaW5nc0NvdW50ZXIvbGFtYmRhJDAkVHlwZSIsMTk1MCk7ZnVuY3Rpb24gQkFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxOTUxLDEsTm4sQkFlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBCZm4odGhpcy4kJG91dGVyXzAsYShuLDEyKSxhKHIsMTIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkNyb3NzaW5nc0NvdW50ZXIvbGFtYmRhJDEkVHlwZSIsMTk1MSk7ZnVuY3Rpb24gR0FlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxOTUyLDEsTm4sR0FlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBHZm4odGhpcy4kJG91dGVyXzAsYShuLDEyKSxhKHIsMTIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkNyb3NzaW5nc0NvdW50ZXIvbGFtYmRhJDIkVHlwZSIsMTk1Mik7ZnVuY3Rpb24gSEFlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxOTUzLDEsTm4sSEFlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBIZm4odGhpcy4kJG91dGVyXzAsYShuLDEyKSxhKHIsMTIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkNyb3NzaW5nc0NvdW50ZXIvbGFtYmRhJDMkVHlwZSIsMTk1Myk7ZnVuY3Rpb24gVUFlKGUpe3RoaXMudGFyZ2V0c0FuZERlZ3JlZXNfMD1lfXAoMTk1NCwxLEplLFVBZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7VWZuKHRoaXMudGFyZ2V0c0FuZERlZ3JlZXNfMCxhKG4sMTIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIuY291bnRpbmciLCJDcm9zc2luZ3NDb3VudGVyL2xhbWJkYSQ0JFR5cGUiLDE5NTQpO2Z1bmN0aW9uIFdBZShlKXt0aGlzLnBvcnRfMD1lfXAoMTk1NSwxLEluLFdBZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFdmbih0aGlzLnBvcnRfMCxhKG4sMTIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIuY291bnRpbmciLCJDcm9zc2luZ3NDb3VudGVyL2xhbWJkYSQ1JFR5cGUiLDE5NTUpO2Z1bmN0aW9uIGpBZShlLG4pe2pmbihlLnRhcmdldHNBbmREZWdyZWVzXzAsYShuLDEyKSl9ZnVuY3Rpb24gVkFlKGUpe3RoaXMudGFyZ2V0c0FuZERlZ3JlZXNfMD1lfXAoMTk1NiwxLEplLFZBZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7akFlKHRoaXMsbil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyLmNvdW50aW5nIiwiQ3Jvc3NpbmdzQ291bnRlci9sYW1iZGEkNiRUeXBlIiwxOTU2KTtmdW5jdGlvbiBxQWUoZSxuKXt0aGlzLnN0YWNrXzA9ZSx0aGlzLmN1cnJlbnRfMT1ufXAoMTk1NywxLEplLHFBZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7dmFyIHI7cHcoKSxJMCh0aGlzLnN0YWNrXzAsKHI9dGhpcy5jdXJyZW50XzEsYShuLDEyKSxyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wM29yZGVyLmNvdW50aW5nIiwiQ3Jvc3NpbmdzQ291bnRlci9sYW1iZGEkNyRUeXBlIiwxOTU3KTtmdW5jdGlvbiBPSygpe31wKDgzOSwxLEpzLE9LKSxsLmFwcGx5XzE9ZnVuY3Rpb24obil7cmV0dXJuIHB3KCksX3IoYShuLDEyKSwoSygpLG9hKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gcHcoKSxfcihhKG4sMTIpLChLKCksb2EpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIuY291bnRpbmciLCJDcm9zc2luZ3NDb3VudGVyL2xhbWJkYSQ4JFR5cGUiLDgzOSk7ZnVuY3Rpb24gVmZuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyLGNhLGNvLFdhLEpnLHAwLHRzLG9zLHAxLE1tLGRfLFJtLHZ1LFl1LCRkLERtLFpnLFN1LGcxLFRjLExZZSxYb2UsQmQsQlMsREYsRm0sR1MsZ3AsSFMsRkYsa1llO2ZvcihYb2U9MCxqbj1uLGNvPTAscDA9am4ubGVuZ3RoO2NvPHAwOysrY28pZm9yKEZlPWpuW2NvXSxZdT1uZXcgVChGZS5wb3J0cyk7WXUuaTxZdS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2Zvcih2dT1hKEMoWXUpLDEyKSxEbT0wLHU9bmV3IFQodnUub3V0Z29pbmdFZGdlcyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDE4KSxGZS5sYXllciE9cy50YXJnZXQub3duZXIubGF5ZXImJisrRG07RG0+MCYmKGUucG9ydFBvc1t2dS5pZF8wXT1Yb2UrKyl9Zm9yKEdTPTAsU3I9cixXYT0wLHRzPVNyLmxlbmd0aDtXYTx0czsrK1dhKXtmb3IoRmU9U3JbV2FdLG9zPTAsWXU9bmV3IFQoRmUucG9ydHMpO1l1Lmk8WXUudGhpcyQwMS5hcnJheS5sZW5ndGgmJih2dT1hKEMoWXUpLDEyKSx2dS5zaWRlPT0ocmUoKSxVZSkpOylmb3IodT1uZXcgVCh2dS5pbmNvbWluZ0VkZ2VzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYocz1hKEModSksMTgpLEZlLmxheWVyIT1zLnNvdXJjZS5vd25lci5sYXllcil7KytvczticmVha31mb3IoTW09MCxaZz1uZXcgcHQoRmUucG9ydHMsRmUucG9ydHMuYXJyYXkubGVuZ3RoKTtaZy5pPjA7KXtmb3IodnU9KHJuKFpnLmk+MCksYShaZy50aGlzJDAxLmdldF8wKFpnLmxhc3Q9LS1aZy5pKSwxMikpLERtPTAsdT1uZXcgVCh2dS5pbmNvbWluZ0VkZ2VzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTgpLEZlLmxheWVyIT1zLnNvdXJjZS5vd25lci5sYXllciYmKytEbTtEbT4wJiYodnUuc2lkZT09KHJlKCksVWUpPyhlLnBvcnRQb3NbdnUuaWRfMF09R1MsKytHUyk6KGUucG9ydFBvc1t2dS5pZF8wXT1HUytvcytNbSwrK01tKSl9R1MrPU1tfWZvcigkZD1uZXcgc24seT1uZXcgbHUsbm49bixjYT0wLEpnPW5uLmxlbmd0aDtjYTxKZzsrK2NhKWZvcihGZT1ubltjYV0sREY9bmV3IFQoRmUucG9ydHMpO0RGLmk8REYudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihCUz1hKEMoREYpLDEyKSx1PW5ldyBUKEJTLm91dGdvaW5nRWRnZXMpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihzPWEoQyh1KSwxOCksSFM9cy50YXJnZXQsRmUubGF5ZXIhPUhTLm93bmVyLmxheWVyKWlmKEJkPWEoX28oanQoJGQuaGFzaENvZGVNYXAsQlMpKSw0NzgpLGdwPWEoX28oanQoJGQuaGFzaENvZGVNYXAsSFMpKSw0NzgpLCFCZCYmIWdwKW09bmV3IEtBZSx5Lm1hcF8wLnB1dChtLHkpLGVlKG0uZWRnZXMscyksZWUobS5wb3J0cyxCUyksZGkoJGQuaGFzaENvZGVNYXAsQlMsbSksZWUobS5wb3J0cyxIUyksZGkoJGQuaGFzaENvZGVNYXAsSFMsbSk7ZWxzZSBpZighQmQpZWUoZ3AuZWRnZXMscyksZWUoZ3AucG9ydHMsQlMpLGRpKCRkLmhhc2hDb2RlTWFwLEJTLGdwKTtlbHNlIGlmKCFncCllZShCZC5lZGdlcyxzKSxlZShCZC5wb3J0cyxIUyksZGkoJGQuaGFzaENvZGVNYXAsSFMsQmQpO2Vsc2UgaWYoQmQ9PWdwKWVlKEJkLmVkZ2VzLHMpO2Vsc2V7Zm9yKGVlKEJkLmVkZ2VzLHMpLFJtPW5ldyBUKGdwLnBvcnRzKTtSbS5pPFJtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylkXz1hKEMoUm0pLDEyKSxkaSgkZC5oYXNoQ29kZU1hcCxkXyxCZCk7cXIoQmQuZWRnZXMsZ3AuZWRnZXMpLHFyKEJkLnBvcnRzLGdwLnBvcnRzKSx5Lm1hcF8wLnJlbW92ZV8wKGdwKSE9bnVsbH1mb3IoRT1hKEkyKHksQihZZm4sezM6MSw0OjEsNToxLDIwNDU6MX0sNDc4LHkubWFwXzAuc2l6ZV8xKCksMCwxKSksMjA0NSksRGU9blswXS5sYXllcixMWWU9clswXS5sYXllcixkPUUsZj0wLGg9ZC5sZW5ndGg7ZjxoOysrZilmb3IoXz1kW2ZdLF8udXBwZXJMZWZ0PVhvZSxfLnVwcGVyUmlnaHQ9R1MsWXU9bmV3IFQoXy5wb3J0cyk7WXUuaTxZdS50aGlzJDAxLmFycmF5Lmxlbmd0aDspdnU9YShDKFl1KSwxMiksU3U9ZS5wb3J0UG9zW3Z1LmlkXzBdLHZ1Lm93bmVyLmxheWVyPT1EZT8oU3U8Xy51cHBlckxlZnQmJihfLnVwcGVyTGVmdD1TdSksU3U+Xy5sb3dlckxlZnQmJihfLmxvd2VyTGVmdD1TdSkpOnZ1Lm93bmVyLmxheWVyPT1MWWUmJihTdTxfLnVwcGVyUmlnaHQmJihfLnVwcGVyUmlnaHQ9U3UpLFN1Pl8ubG93ZXJSaWdodCYmKF8ubG93ZXJSaWdodD1TdSkpO2ZvcihfeShFLDAsRS5sZW5ndGgsbnVsbCksRm09QihobixrbiwyOCxFLmxlbmd0aCwxNSwxKSx0PUIoaG4sa24sMjgsR1MrMSwxNSwxKSx4PTA7eDxFLmxlbmd0aDt4KyspRm1beF09RVt4XS51cHBlclJpZ2h0LHRbRm1beF1dPTE7Zm9yKGk9MCxBPTA7QTx0Lmxlbmd0aDtBKyspdFtBXT09MT90W0FdPWk6LS1pO2ZvcihnMT0wLGs9MDtrPEZtLmxlbmd0aDtrKyspRm1ba10rPXRbRm1ba11dLGcxPVMuTWF0aC5tYXgoZzEsRm1ba10rMSk7Zm9yKGM9MTtjPGcxOyljKj0yO2ZvcihrWWU9MipjLTEsYy09MSxGRj1CKGhuLGtuLDI4LGtZZSwxNSwxKSxvPTAsdmU9MDt2ZTxGbS5sZW5ndGg7dmUrKylmb3IobmU9Rm1bdmVdK2MsKytGRltuZV07bmU+MDspbmUlMj4wJiYobys9RkZbbmUrMV0pLG5lPShuZS0xKS8yfDAsKytGRltuZV07Zm9yKHdlPUIoWEFlLE1lLDM3NCxFLmxlbmd0aCoyLDAsMSksTT0wO008RS5sZW5ndGg7TSsrKXdlWzIqTV09bmV3IHFQKEVbTV0sRVtNXS51cHBlckxlZnQsRVtNXS5sb3dlckxlZnQsKHN2KCksY3YpKSx3ZVsyKk0rMV09bmV3IHFQKEVbTV0sRVtNXS5sb3dlckxlZnQsRVtNXS51cHBlckxlZnQsdXYpO2ZvcihfeSh3ZSwwLHdlLmxlbmd0aCxudWxsKSxwMT0wLEg9MDtIPHdlLmxlbmd0aDtIKyspc3dpdGNoKHdlW0hdLnR5cGVfMC5vcmRpbmFsKXtjYXNlIDA6KytwMTticmVhaztjYXNlIDE6LS1wMSxvKz1wMX1mb3IoVGM9QihYQWUsTWUsMzc0LEUubGVuZ3RoKjIsMCwxKSxxPTA7cTxFLmxlbmd0aDtxKyspVGNbMipxXT1uZXcgcVAoRVtxXSxFW3FdLnVwcGVyUmlnaHQsRVtxXS5sb3dlclJpZ2h0LChzdigpLGN2KSksVGNbMipxKzFdPW5ldyBxUChFW3FdLEVbcV0ubG93ZXJSaWdodCxFW3FdLnVwcGVyUmlnaHQsdXYpO2ZvcihfeShUYywwLFRjLmxlbmd0aCxudWxsKSxwMT0wLHY9MDt2PFRjLmxlbmd0aDt2Kyspc3dpdGNoKFRjW3ZdLnR5cGVfMC5vcmRpbmFsKXtjYXNlIDA6KytwMTticmVhaztjYXNlIDE6LS1wMSxvKz1wMX1yZXR1cm4gb31mdW5jdGlvbiBZQWUoZSl7dGhpcy5wb3J0UG9zPWV9cCgxOTQ5LDEse30sWUFlKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkh5cGVyZWRnZUNyb3NzaW5nc0NvdW50ZXIiLDE5NDkpO2Z1bmN0aW9uIHFmbihlLG4pe3JldHVybiBlLnVwcGVyTGVmdDxuLnVwcGVyTGVmdD8tMTplLnVwcGVyTGVmdD5uLnVwcGVyTGVmdD8xOmUudXBwZXJSaWdodDxuLnVwcGVyUmlnaHQ/LTE6ZS51cHBlclJpZ2h0Pm4udXBwZXJSaWdodD8xOnVyKGUpLXVyKG4pfWZ1bmN0aW9uIEtBZSgpe3RoaXMuZWRnZXM9bmV3IFEsdGhpcy5wb3J0cz1uZXcgUX1wKDQ3OCwxLHszNDoxLDQ3ODoxfSxLQWUpLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIHFmbih0aGlzLGEobiw0NzgpKX0sbC5sb3dlckxlZnQ9MCxsLmxvd2VyUmlnaHQ9MCxsLnVwcGVyTGVmdD0wLGwudXBwZXJSaWdodD0wO3ZhciBZZm49Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnAzb3JkZXIuY291bnRpbmciLCJIeXBlcmVkZ2VDcm9zc2luZ3NDb3VudGVyL0h5cGVyZWRnZSIsNDc4KTtmdW5jdGlvbiBLZm4oZSxuKXtyZXR1cm4gZS5wb3NpdGlvbjxuLnBvc2l0aW9uPy0xOmUucG9zaXRpb24+bi5wb3NpdGlvbj8xOmUub3Bwb3NpdGVQb3NpdGlvbjxuLm9wcG9zaXRlUG9zaXRpb24/LTE6ZS5vcHBvc2l0ZVBvc2l0aW9uPm4ub3Bwb3NpdGVQb3NpdGlvbj8xOmUuaHlwZXJlZGdlIT1uLmh5cGVyZWRnZT91cihlLmh5cGVyZWRnZSktdXIobi5oeXBlcmVkZ2UpOmUudHlwZV8wPT0oc3YoKSxjdikmJm4udHlwZV8wPT11dj8tMTplLnR5cGVfMD09dXYmJm4udHlwZV8wPT1jdj8xOjB9ZnVuY3Rpb24gcVAoZSxuLHIsdCl7dGhpcy5oeXBlcmVkZ2U9ZSx0aGlzLnBvc2l0aW9uPW4sdGhpcy5vcHBvc2l0ZVBvc2l0aW9uPXIsdGhpcy50eXBlXzA9dH1wKDM3NCwxLHszNDoxLDM3NDoxfSxxUCksbC5jb21wYXJlVG9fMD1mdW5jdGlvbihuKXtyZXR1cm4gS2ZuKHRoaXMsYShuLDM3NCkpfSxsLm9wcG9zaXRlUG9zaXRpb249MCxsLnBvc2l0aW9uPTA7dmFyIFhBZT1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkh5cGVyZWRnZUNyb3NzaW5nc0NvdW50ZXIvSHlwZXJlZGdlQ29ybmVyIiwzNzQpO2Z1bmN0aW9uIHN2KCl7c3Y9Rixjdj1uZXcgTUsoIlVQUEVSIiwwKSx1dj1uZXcgTUsoIkxPV0VSIiwxKX1mdW5jdGlvbiBNSyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFhmbihlKXtyZXR1cm4gc3YoKSx3bigoWkFlKCksUUFlKSxlKX1mdW5jdGlvbiBKZm4oKXtyZXR1cm4gc3YoKSxQKEkoSkFlLDEpLFcsNTMxLDAsW2N2LHV2XSl9cCg1MzEsMjIsezM6MSwzNDoxLDIyOjEsNTMxOjF9LE1LKTt2YXIgdXYsY3YsSkFlPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDNvcmRlci5jb3VudGluZyIsIkh5cGVyZWRnZUNyb3NzaW5nc0NvdW50ZXIvSHlwZXJlZGdlQ29ybmVyL1R5cGUiLDUzMSxnbixKZm4sWGZuKTtmdW5jdGlvbiBaQWUoKXtaQWU9RixRQWU9eW4oKHN2KCksUChJKEpBZSwxKSxXLDUzMSwwLFtjdix1dl0pKSl9dmFyIFFBZTtmdW5jdGlvbiBlTGUoKXtlTGU9RixyTGU9TW4obmV3IEhyLCh4dCgpLGhvKSwoa3QoKSxQRSkpfWZ1bmN0aW9uIFpmbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihyPVZyLHU9KFdlKCksa3IpLG89bmV3IFQobi5ub2Rlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDEwKSxpPXQudHlwZV8wLGkhPWtyJiYocz0kKHcodCwoSygpLHJxKSkpLHM9PW51bGw/KHI9Uy5NYXRoLm1heChyLDApLHQucG9zLnlfMD1yK0tZKGUuc3BhY2luZ3MsaSx1KSk6dC5wb3MueV8wPShWZShzKSxzKSksYz1LWShlLnNwYWNpbmdzLGksdSksdC5wb3MueV8wPHIrYyt0Lm1hcmdpbi50b3BfMCYmKHQucG9zLnlfMD1yK2MrdC5tYXJnaW4udG9wXzApLHI9dC5wb3MueV8wK3Quc2l6ZV8wLnlfMCt0Lm1hcmdpbi5ib3R0b20sdT1pfWZ1bmN0aW9uIFFmbihlLG4scil7dmFyIHQsbztmb3Ioci5iZWdpbigiSW50ZXJhY3RpdmUgbm9kZSBwbGFjZW1lbnQiLDEpLGUuc3BhY2luZ3M9YSh3KG4sKEsoKSxlZykpLDMxMiksbz1uZXcgVChuLmxheWVycyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDMwKSxaZm4oZSx0KTtyLmRvbmVfMSgpfWZ1bmN0aW9uIG5MZSgpe2VMZSgpfXAoMTQyNSwxLFd0LG5MZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKHcoYShuLDM2KSwoSygpLGlpKSksMjEpLmNvbnRhaW5zKChWdCgpLG5sKSk/ckxlOm51bGx9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe1Fmbih0aGlzLGEobiwzNikscil9O3ZhciByTGU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJJbnRlcmFjdGl2ZU5vZGVQbGFjZXIiLDE0MjUpO2Z1bmN0aW9uIHRMZSgpe3RMZT1GLGFMZT1NbihuZXcgSHIsKHh0KCksaG8pLChrdCgpLFBFKSksWVA9bmV3IHZyKCJsaW5lYXJTZWdtZW50cy5pbnB1dFByaW8iLEooMCkpLEtQPW5ldyB2cigibGluZWFyU2VnbWVudHMub3V0cHV0UHJpbyIsSigwKSl9ZnVuY3Rpb24gZXBuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lO3Q9UigkKHcobiwob2UoKSxsWSkpKSksSD1hKHcobixKRSksMTcpLnZhbHVlXzAsaD00LG89MyxxPTIwL0gsbT0hMSxjPTAscz1xbjtkb3tmb3IoaT1jIT0xLGY9YyE9MCxuZT0wLHY9ZS5saW5lYXJTZWdtZW50cyxBPTAsTT12Lmxlbmd0aDtBPE07KytBKXk9dltBXSx5LnJlZlNlZ21lbnQ9bnVsbCxucG4oZSx5LGksZix0KSxuZSs9Uy5NYXRoLmFicyh5LmRlZmxlY3Rpb24pO2RvIHU9b3BuKGUsbik7d2hpbGUodSk7Zm9yKEU9ZS5saW5lYXJTZWdtZW50cyx4PTAsaz1FLmxlbmd0aDt4PGs7Kyt4KWlmKHk9RVt4XSxyPVJLKHkpLmRlZmxlY3Rpb24sciE9MClmb3IoZD1uZXcgVCh5Lm5vZGVzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspXz1hKEMoZCksMTApLF8ucG9zLnlfMCs9cjtjPT0wfHxjPT0xPygtLWgsaDw9MCYmKG5lPHN8fC1oPkgpPyhjPTIscz1xbik6Yz09MD8oYz0xLHM9bmUpOihjPTAscz1uZSkpOihtPW5lPj1zfHxzLW5lPHEscz1uZSxtJiYtLW8pfXdoaWxlKCEobSYmbzw9MCkpfWZ1bmN0aW9uIG5wbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscTtmb3IocT0wLG09MCxmPW5ldyBUKG4ubm9kZXMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGQ9YShDKGYpLDEwKSxoPTAsdT0wLGM9cj9hKHcoZCxZUCksMTcpLnZhbHVlXzA6YnQseD10P2EodyhkLEtQKSwxNykudmFsdWVfMDpidCxfPVMuTWF0aC5tYXgoYyx4KSxrPW5ldyBUKGQucG9ydHMpO2suaTxrLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoQT1hKEMoayksMTIpLE09ZC5wb3MueV8wK0EucG9zLnlfMCtBLmFuY2hvci55XzAsdClmb3Iocz1uZXcgVChBLm91dGdvaW5nRWRnZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxOCksRT1pLnRhcmdldCx5PUUub3duZXIsbiE9ZS5saW5lYXJTZWdtZW50c1t5LmlkXzBdJiYodj1TLk1hdGgubWF4KGEodyh5LFlQKSwxNykudmFsdWVfMCxhKHcoeSxLUCksMTcpLnZhbHVlXzApLEg9YSh3KGksKG9lKCksWWgpKSwxNykudmFsdWVfMCxIPj1fJiZIPj12JiYoaCs9eS5wb3MueV8wK0UucG9zLnlfMCtFLmFuY2hvci55XzAtTSwrK3UpKTtpZihyKWZvcihzPW5ldyBUKEEuaW5jb21pbmdFZGdlcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDE4KSxFPWkuc291cmNlLHk9RS5vd25lcixuIT1lLmxpbmVhclNlZ21lbnRzW3kuaWRfMF0mJih2PVMuTWF0aC5tYXgoYSh3KHksWVApLDE3KS52YWx1ZV8wLGEodyh5LEtQKSwxNykudmFsdWVfMCksSD1hKHcoaSwob2UoKSxZaCkpLDE3KS52YWx1ZV8wLEg+PV8mJkg+PXYmJihoKz15LnBvcy55XzArRS5wb3MueV8wK0UuYW5jaG9yLnlfMC1NLCsrdSkpfXU+MCYmKHErPWgvdSwrK20pfW0+MD8obi5kZWZsZWN0aW9uPW8qcS9tLG4ud2VpZ2h0PW0pOihuLmRlZmxlY3Rpb249MCxuLndlaWdodD0wKX1mdW5jdGlvbiBycG4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBO2ZvcihtPW4uYXJyYXkubGVuZ3RoLGg9MCxmPW5ldyBUKGUubGF5ZXJzKTtmLmk8Zi50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYoZD1hKEMoZiksMzApLHg9ZC5ub2Rlcyx4LmFycmF5Lmxlbmd0aCE9MCl7Zm9yKHY9bmV3IFQoeCksXz0wLEE9bnVsbCxvPWEoQyh2KSwxMCksaT1udWxsO287KXtpZihpPWEobGUobixvLmlkXzApLDI2MSksaS5pbmRleEluTGFzdExheWVyPj0wKXtmb3IoYz1udWxsLHU9bmV3IHB0KGQubm9kZXMsXysxKTt1Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCkmJihzPShybih1Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCkpLGEodS50aGlzJDAxXzAuZ2V0XzAodS5sYXN0PXUuaSsrKSwxMCkpLGM9YShsZShuLHMuaWRfMCksMjYxKSwhKGMubGFzdExheWVyPT1pLmxhc3RMYXllciYmYy5pbmRleEluTGFzdExheWVyPGkuaW5kZXhJbkxhc3RMYXllcikpOyljPW51bGw7YyYmKEEmJihLYSh0LG8uaWRfMCxKKGEobGUodCxvLmlkXzApLDE3KS52YWx1ZV8wLTEpKSxhKGxlKHIsQS5pZF8wKSwxNSkucmVtb3ZlXzEoaSkpLGk9dXBuKGksbyxtKyspLFJlKG4uYXJyYXksaSksZWUocixuZXcgUSksQT8oYShsZShyLEEuaWRfMCksMTUpLmFkZF8yKGkpLGVlKHQsSigxKSkpOmVlKHQsSigwKSkpfXk9bnVsbCx2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aCYmKHk9YShDKHYpLDEwKSxFPWEobGUobix5LmlkXzApLDI2MSksYShsZShyLG8uaWRfMCksMTUpLmFkZF8yKEUpLEthKHQseS5pZF8wLEooYShsZSh0LHkuaWRfMCksMTcpLnZhbHVlXzArMSkpKSxpLmxhc3RMYXllcj1oLGkuaW5kZXhJbkxhc3RMYXllcj1fKyssQT1vLG89eX0rK2h9fWZ1bmN0aW9uIHRwbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEU7Zm9yKHU9QihobixrbiwyOCxuLmxheWVycy5hcnJheS5sZW5ndGgsMTUsMSksXz1CKGk5LFcsMjczLG4ubGF5ZXJzLmFycmF5Lmxlbmd0aCwwLDEpLGM9QihSdSxJYywxMCxuLmxheWVycy5hcnJheS5sZW5ndGgsMCwxKSxmPWUubGluZWFyU2VnbWVudHMsaD0wLG09Zi5sZW5ndGg7aDxtOysraCl7Zm9yKGQ9ZltoXSxFPTAscz1uZXcgVChkLm5vZGVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMocyksMTApLHQ9Slcoby5sYXllciksKyt1W3RdLHk9UigkKHcobiwob2UoKSxxbCkpKSksdVt0XT4wJiZjW3RdJiYoeT1zZyhlLnNwYWNpbmdzLGNbdF0sbykpLEU9Uy5NYXRoLm1heChFLG8ubGF5ZXIuc2l6ZV8wLnlfMCt5KTtmb3IoaT1uZXcgVChkLm5vZGVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTApLG8ucG9zLnlfMD1FK28ubWFyZ2luLnRvcF8wLHI9by5sYXllcixyLnNpemVfMC55XzA9RStvLm1hcmdpbi50b3BfMCtvLnNpemVfMC55XzArby5tYXJnaW4uYm90dG9tLF9bZm8oci5vd25lci5sYXllcnMsciwwKV09by50eXBlXzAsY1tmbyhyLm93bmVyLmxheWVycyxyLDApXT1vfX1mdW5jdGlvbiBvTGUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7aWYobz1uLnR5cGVfMCxuLmlkXzA+PTApcmV0dXJuITE7aWYobi5pZF8wPXIuaWRfMCxlZShyLm5vZGVzLG4pLG89PShXZSgpLGl0KXx8bz09dGkpe2ZvcihzPW5ldyBUKG4ucG9ydHMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaT1hKEMocyksMTIpLGQ9KHQ9bmV3IFQobmV3IE1oKGkpLnRoaXMkMDEub3V0Z29pbmdFZGdlcyksbmV3IFhXKHQpKTt4byhkLnZhbCRlZGdlc0l0ZXIyKTspaWYoXz1hKEMoZC52YWwkZWRnZXNJdGVyMiksMTgpLnRhcmdldCx1PV8ub3duZXIsYz11LnR5cGVfMCxuLmxheWVyIT11LmxheWVyJiYoYz09aXR8fGM9PXRpKSYmb0xlKGUsdSxyKSlyZXR1cm4hMH1yZXR1cm4hMH1mdW5jdGlvbiBvcG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2ZvcihyPSExLGQ9UigkKHcobiwob2UoKSxvZCkpKSkseT1nMCpkLG89bmV3IFQobi5sYXllcnMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IodD1hKEMobyksMzApLF89bmV3IFQodC5ub2RlcyksaT1hKEMoXyksMTApLGY9UksoZS5saW5lYXJTZWdtZW50c1tpLmlkXzBdKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoXyksMTApLGg9UksoZS5saW5lYXJTZWdtZW50c1t1LmlkXzBdKSxmIT1oJiYobT1zZyhlLnNwYWNpbmdzLGksdSkscz1pLnBvcy55XzAraS5zaXplXzAueV8wK2kubWFyZ2luLmJvdHRvbStmLmRlZmxlY3Rpb24rbSxjPXUucG9zLnlfMC11Lm1hcmdpbi50b3BfMCtoLmRlZmxlY3Rpb24scz5jK3kmJihFPWYud2VpZ2h0K2gud2VpZ2h0LGguZGVmbGVjdGlvbj0oaC53ZWlnaHQqaC5kZWZsZWN0aW9uK2Yud2VpZ2h0KmYuZGVmbGVjdGlvbikvRSxoLndlaWdodD1FLGYucmVmU2VnbWVudD1oLHI9ITApKSxpPXUsZj1oO3JldHVybiByfWZ1bmN0aW9uIGlwbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZTtmb3Ioaz1lLmxpbmVhclNlZ21lbnRzLE09MCxIPWsubGVuZ3RoO008SDsrK00pe2ZvcihBPWtbTV0sXz1xbixkPXFuLHk9bmV3IFQoQS5ub2Rlcyk7eS5pPHkudGhpcyQwMS5hcnJheS5sZW5ndGg7KWg9YShDKHkpLDEwKSxzPWgubGF5ZXI/Zm8oaC5sYXllci5ub2RlcyxoLDApOi0xLHM+MD8oZj1hKGxlKGgubGF5ZXIubm9kZXMscy0xKSwxMCksdmU9c2coZS5zcGFjaW5ncyxoLGYpLHY9aC5wb3MueV8wLWgubWFyZ2luLnRvcF8wLShmLnBvcy55XzArZi5zaXplXzAueV8wK2YubWFyZ2luLmJvdHRvbSt2ZSkpOnY9aC5wb3MueV8wLWgubWFyZ2luLnRvcF8wLF89Uy5NYXRoLm1pbih2LF8pLHM8aC5sYXllci5ub2Rlcy5hcnJheS5sZW5ndGgtMT8oZj1hKGxlKGgubGF5ZXIubm9kZXMscysxKSwxMCksdmU9c2coZS5zcGFjaW5ncyxoLGYpLHg9Zi5wb3MueV8wLWYubWFyZ2luLnRvcF8wLShoLnBvcy55XzAraC5zaXplXzAueV8wK2gubWFyZ2luLmJvdHRvbSt2ZSkpOng9MipoLnBvcy55XzAsZD1TLk1hdGgubWluKHgsZCk7Zm9yKGM9cW4saT0hMSxvPWEobGUoQS5ub2RlcywwKSwxMCksRGU9bmV3IFQoby5wb3J0cyk7RGUuaTxEZS50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHdlPWEoQyhEZSksMTIpLEU9by5wb3MueV8wK3dlLnBvcy55XzArd2UuYW5jaG9yLnlfMCx0PW5ldyBUKHdlLmluY29taW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxOCkscT1yLnNvdXJjZSxuPXEub3duZXIucG9zLnlfMCtxLnBvcy55XzArcS5hbmNob3IueV8wLUUsUy5NYXRoLmFicyhuKTxTLk1hdGguYWJzKGMpJiZTLk1hdGguYWJzKG4pPChuPDA/XzpkKSYmKGM9bixpPSEwKTtmb3IodT1hKGxlKEEubm9kZXMsQS5ub2Rlcy5hcnJheS5sZW5ndGgtMSksMTApLG5lPW5ldyBUKHUucG9ydHMpO25lLmk8bmUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihxPWEoQyhuZSksMTIpLEU9dS5wb3MueV8wK3EucG9zLnlfMCtxLmFuY2hvci55XzAsdD1uZXcgVChxLm91dGdvaW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxOCksd2U9ci50YXJnZXQsbj13ZS5vd25lci5wb3MueV8wK3dlLnBvcy55XzArd2UuYW5jaG9yLnlfMC1FLFMuTWF0aC5hYnMobik8Uy5NYXRoLmFicyhjKSYmUy5NYXRoLmFicyhuKTwobjwwP186ZCkmJihjPW4saT0hMCk7aWYoaSYmYyE9MClmb3IobT1uZXcgVChBLm5vZGVzKTttLmk8bS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaD1hKEMobSksMTApLGgucG9zLnlfMCs9Y319ZnVuY3Rpb24gYXBuKGUsbixyKXtyLmJlZ2luKCJMaW5lYXIgc2VnbWVudHMgbm9kZSBwbGFjZW1lbnQiLDEpLGUuc3BhY2luZ3M9YSh3KG4sKEsoKSxlZykpLDMxMiksbHBuKGUsbiksdHBuKGUsbiksZXBuKGUsbiksaXBuKGUpLGUubGluZWFyU2VnbWVudHM9bnVsbCxlLnNwYWNpbmdzPW51bGwsci5kb25lXzEoKX1mdW5jdGlvbiBscG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam4sU3IsY2EsY287Zm9yKFNyPW5ldyBRLHk9bmV3IFQobi5sYXllcnMpO3kuaTx5LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaD1hKEMoeSksMzApLEg9bmV3IFQoaC5ub2Rlcyk7SC5pPEgudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoTT1hKEMoSCksMTApLE0uaWRfMD0tMSxmPWJ0LHZlPWJ0LERlPW5ldyBUKE0ucG9ydHMpO0RlLmk8RGUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3Iod2U9YShDKERlKSwxMiksbz1uZXcgVCh3ZS5pbmNvbWluZ0VkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEMobyksMTgpLEZlPWEodyhyLChvZSgpLFloKSksMTcpLnZhbHVlXzAsZj1TLk1hdGgubWF4KGYsRmUpO2Zvcih0PW5ldyBUKHdlLm91dGdvaW5nRWRnZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxOCksRmU9YSh3KHIsKG9lKCksWWgpKSwxNykudmFsdWVfMCx2ZT1TLk1hdGgubWF4KHZlLEZlKX1qKE0sWVAsSihmKSksaihNLEtQLEoodmUpKX1mb3IoeD0wLG09bmV3IFQobi5sYXllcnMpO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaD1hKEMobSksMzApLEg9bmV3IFQoaC5ub2Rlcyk7SC5pPEgudGhpcyQwMS5hcnJheS5sZW5ndGg7KU09YShDKEgpLDEwKSxNLmlkXzA8MCYmKGpuPW5ldyBESyxqbi5pZF8wPXgrKyxvTGUoZSxNLGpuKSxSZShTci5hcnJheSxqbikpO2ZvcihuZT1OdShTci5hcnJheS5sZW5ndGgpLGQ9TnUoU3IuYXJyYXkubGVuZ3RoKSxzPTA7czxTci5hcnJheS5sZW5ndGg7cysrKWVlKG5lLG5ldyBRKSxlZShkLEooMCkpO2ZvcihycG4obixTcixuZSxkKSxjYT1hKElzKFNyLEIobExlLHdpZSwyNjEsU3IuYXJyYXkubGVuZ3RoLDAsMSkpLDg1NCkscT1hKElzKG5lLEIoamEsVWQsMTUsbmUuYXJyYXkubGVuZ3RoLDAsMSkpLDE5OCksXz1CKGhuLGtuLDI4LGQuYXJyYXkubGVuZ3RoLDE1LDEpLHU9MDt1PF8ubGVuZ3RoO3UrKylfW3VdPShBZSh1LGQuYXJyYXkubGVuZ3RoKSxhKGQuYXJyYXlbdV0sMTcpKS52YWx1ZV8wO2ZvcihBPTAsaz1uZXcgUSxjPTA7YzxjYS5sZW5ndGg7YysrKV9bY109PTAmJlJlKGsuYXJyYXksY2FbY10pO2Zvcih2PUIoaG4sa24sMjgsY2EubGVuZ3RoLDE1LDEpO2suYXJyYXkubGVuZ3RoIT0wOylmb3Ioam49YShNYyhrLDApLDI2MSksdltqbi5pZF8wXT1BKys7IXFbam4uaWRfMF0uaXNFbXB0eSgpOyljbz1hKHFbam4uaWRfMF0ucmVtb3ZlXzIoMCksMjYxKSwtLV9bY28uaWRfMF0sX1tjby5pZF8wXT09MCYmUmUoay5hcnJheSxjbyk7Zm9yKGUubGluZWFyU2VnbWVudHM9QihsTGUsd2llLDI2MSxjYS5sZW5ndGgsMCwxKSxpPTA7aTxjYS5sZW5ndGg7aSsrKWZvcihFPWNhW2ldLG5uPXZbaV0sZS5saW5lYXJTZWdtZW50c1tubl09RSxFLmlkXzA9bm4sSD1uZXcgVChFLm5vZGVzKTtILmk8SC50aGlzJDAxLmFycmF5Lmxlbmd0aDspTT1hKEMoSCksMTApLE0uaWRfMD1ubjtyZXR1cm4gZS5saW5lYXJTZWdtZW50c31mdW5jdGlvbiBpTGUoKXt0TGUoKX1wKDE0MjYsMSxXdCxpTGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYSh3KGEobiwzNiksKEsoKSxpaSkpLDIxKS5jb250YWlucygoVnQoKSxubCkpP2FMZTpudWxsfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXthcG4odGhpcyxhKG4sMzYpLHIpfTt2YXIgYUxlLFlQLEtQO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTGluZWFyU2VnbWVudHNOb2RlUGxhY2VyIiwxNDI2KTtmdW5jdGlvbiBzcG4oZSxuKXtyZXR1cm4gZS5pZF8wLW4uaWRfMH1mdW5jdGlvbiBSSyhlKXt2YXIgbjtmb3Iobj1lO24ucmVmU2VnbWVudDspbj1uLnJlZlNlZ21lbnQ7cmV0dXJuIG59ZnVuY3Rpb24gdXBuKGUsbixyKXt2YXIgdCxvLGkscztmb3Iocz1mbyhlLm5vZGVzLG4sMCksaT1uZXcgREssaS5pZF8wPXIsdD1uZXcgcHQoZS5ub2RlcyxzKTt0Lmk8dC50aGlzJDAxXzAuc2l6ZV8xKCk7KW89KHJuKHQuaTx0LnRoaXMkMDFfMC5zaXplXzEoKSksYSh0LnRoaXMkMDFfMC5nZXRfMCh0Lmxhc3Q9dC5pKyspLDEwKSksby5pZF8wPXIsZWUoaS5ub2RlcyxvKSxFYSh0KTtyZXR1cm4gaX1mdW5jdGlvbiBESygpe3RoaXMubm9kZXM9bmV3IFF9cCgyNjEsMSx7MzQ6MSwyNjE6MX0sREspLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIHNwbih0aGlzLGEobiwyNjEpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDI2MSk/KHI9YShuLDI2MSksdGhpcy5pZF8wPT1yLmlkXzApOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZF8wfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4ibHMiK20wKHRoaXMubm9kZXMpfSxsLmRlZmxlY3Rpb249MCxsLmlkXzA9MCxsLmluZGV4SW5MYXN0TGF5ZXI9LTEsbC5sYXN0TGF5ZXI9LTEsbC53ZWlnaHQ9MDt2YXIgbExlPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTGluZWFyU2VnbWVudHNOb2RlUGxhY2VyL0xpbmVhclNlZ21lbnQiLDI2MSk7ZnVuY3Rpb24gTWEoKXtNYT1GLGRMZT1NbihuZXcgSHIsKHh0KCksaG8pLChrdCgpLFBFKSl9ZnVuY3Rpb24gY3BuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7Zm9yKHQ9bmV3IFQoZS5sR3JhcGgubGF5ZXJzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHI9YShDKHQpLDMwKSxpPW5ldyBUKHIubm9kZXMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihvPWEoQyhpKSwxMCksbT1lLm5vZGVSZXBzW28uaWRfMF0sXz1tLmhlYWQubGF5ZXIsYz1tLnRhaWwubGF5ZXIsby5wb3MueV8wPV8seD1jLV8tby5zaXplXzAueV8wLG49cDcobyksaD0oUmYoKSwoby5wcm9wZXJ0eU1hcD9vLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5jb250YWluc0tleSgob2UoKSxuZCkpP2Y9YSh3KG8sbmQpLDIwMyk6Zj1hKHcoU3QobyksS0UpLDIwMyksZiksbiYmKGg9PWxnfHxoPT1hZykmJihvLnNpemVfMC55XzArPXgpLG4mJihoPT16T3x8aD09bGd8fGg9PWFnKSl7Zm9yKEU9bmV3IFQoby5wb3J0cyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXk9YShDKEUpLDEyKSwocmUoKSx2aSkuY29udGFpbnMoeS5zaWRlKSYmKGQ9YShLZShlLnBvcnRNYXAseSksMTI1KSx5LnBvcy55XzA9ZC5sYXllci1fKTtmb3IodT1uZXcgVChvLmxhYmVscyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDcyKSx2PWEodyhvLGVkKSwyMSksdi5jb250YWlucygocWYoKSxUbCkpP3MucG9zLnlfMCs9eDp2LmNvbnRhaW5zKEd1KSYmKHMucG9zLnlfMCs9eC8yKTsoaD09bGd8fGg9PWFnKSYmQW8obywocmUoKSxsbikpLmZvckVhY2hfMChuZXcga0xlKHgpKX19ZnVuY3Rpb24gX3BuKGUpe3ZhciBuLHI7Zm9yKHI9bmV3IFQoZS5sR3JhcGgubGF5ZXJzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMzApLGJwbihlLG4pO0xyKEpuKE5vKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLmxHcmFwaC5sYXllcnMsMTYpKSxuZXcgTExlKSxuZXcgVUxlKSxuZXcgV0xlKSxuZXcgakxlKGUpKX1mdW5jdGlvbiBzTGUoZSxuLHIsdCl7dmFyIG8saSxzO2lmKHM9VFcobixyKSxSZSh0LmFycmF5LG4pLGUubm9kZVN0YXRlW3MuaWRfMF09PS0xfHxlLm5vZGVTdGF0ZVtzLmlkXzBdPT0yfHxlLmNyb3NzaW5nW24uaWRfMF0pcmV0dXJuIHQ7Zm9yKGUubm9kZVN0YXRlW3MuaWRfMF09LTEsaT1uZXcgWGUoUWUoaWMocykudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylpZihvPWEodG4oaSksMTgpLCEoISghenQobykmJiEoIXp0KG8pJiZvLnNvdXJjZS5vd25lci5sYXllcj09by50YXJnZXQub3duZXIubGF5ZXIpKXx8bz09bikpcmV0dXJuIHNMZShlLG8scyx0KTtyZXR1cm4gdH1mdW5jdGlvbiBGSyhlLG4pe3JldHVybiBlPT0oV2UoKSxrcikmJm49PWtyPzQ6ZT09a3J8fG49PWtyPzg6MzJ9ZnVuY3Rpb24gdUxlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlO3JldHVybiBrPWUuZWRnZVJlcHNbKEFlKDAsbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVswXSwxOCkpLmlkXzBdLG5lPWUuZWRnZVJlcHNbKEFlKDEsbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVsxXSwxOCkpLmlkXzBdLGsubGVmdC50YXJnZXQubGF5ZXItay5sZWZ0LmRlbHRhLShrLnJpZ2h0LnRhcmdldC5sYXllci1rLnJpZ2h0LmRlbHRhKT09MCYmbmUubGVmdC50YXJnZXQubGF5ZXItbmUubGVmdC5kZWx0YS0obmUucmlnaHQudGFyZ2V0LmxheWVyLW5lLnJpZ2h0LmRlbHRhKT09MHx8KHg9ay5yaWdodC50YXJnZXQub3JpZ2luXzAsIUwoeCwxMCkpPyExOih2PWEoeCwxMCksSD1lLm5vZGVSZXBzW3YuaWRfMF0scT12LmxheWVyP2ZvKHYubGF5ZXIubm9kZXMsdiwwKTotMSxpPWhyLHE+MCYmKG89YShsZSh2LmxheWVyLm5vZGVzLHEtMSksMTApLHM9ZS5ub2RlUmVwc1tvLmlkXzBdLHZlPVMuTWF0aC5jZWlsKHNnKGUuc3BhY2luZ3Msbyx2KSksaT1ILmhlYWQubGF5ZXItdi5tYXJnaW4udG9wXzAtKHMuaGVhZC5sYXllcitvLnNpemVfMC55XzArby5tYXJnaW4uYm90dG9tKS12ZSksXz1ocixxPHYubGF5ZXIubm9kZXMuYXJyYXkubGVuZ3RoLTEmJihjPWEobGUodi5sYXllci5ub2RlcyxxKzEpLDEwKSxkPWUubm9kZVJlcHNbYy5pZF8wXSx2ZT1TLk1hdGguY2VpbChzZyhlLnNwYWNpbmdzLGMsdikpLF89ZC5oZWFkLmxheWVyLWMubWFyZ2luLnRvcF8wLShILmhlYWQubGF5ZXIrdi5zaXplXzAueV8wK3YubWFyZ2luLmJvdHRvbSktdmUpLHImJihicygpLGtsKFFzKSxTLk1hdGguYWJzKGktXyk8PVFzfHxpPT1ffHxpc05hTihpKSYmaXNOYU4oXykpPyEwOih0PWc3KGsubGVmdCksdT0tZzcoay5yaWdodCksZj0tZzcobmUubGVmdCksQT1nNyhuZS5yaWdodCksRT1rLmxlZnQudGFyZ2V0LmxheWVyLWsubGVmdC5kZWx0YS0oay5yaWdodC50YXJnZXQubGF5ZXItay5yaWdodC5kZWx0YSk+MCYmbmUubGVmdC50YXJnZXQubGF5ZXItbmUubGVmdC5kZWx0YS0obmUucmlnaHQudGFyZ2V0LmxheWVyLW5lLnJpZ2h0LmRlbHRhKTwwLHk9ay5sZWZ0LnRhcmdldC5sYXllci1rLmxlZnQuZGVsdGEtKGsucmlnaHQudGFyZ2V0LmxheWVyLWsucmlnaHQuZGVsdGEpPDAmJm5lLmxlZnQudGFyZ2V0LmxheWVyLW5lLmxlZnQuZGVsdGEtKG5lLnJpZ2h0LnRhcmdldC5sYXllci1uZS5yaWdodC5kZWx0YSk+MCxtPWsubGVmdC50YXJnZXQubGF5ZXIray5yaWdodC5kZWx0YTxuZS5yaWdodC50YXJnZXQubGF5ZXIrbmUubGVmdC5kZWx0YSxoPWsubGVmdC50YXJnZXQubGF5ZXIray5yaWdodC5kZWx0YT5uZS5yaWdodC50YXJnZXQubGF5ZXIrbmUubGVmdC5kZWx0YSxNPTAsIUUmJiF5JiYoaD9pK2Y+MD9NPWY6Xy10PjAmJihNPXQpOm0mJihpK3U+MD9NPXU6Xy1BPjAmJihNPUEpKSksSC5oZWFkLmxheWVyKz1NLEguaXNGbGV4aWJsZSYmKEgudGFpbC5sYXllcis9TSksITEpKX1mdW5jdGlvbiBkcG4oZSxuLHIpe3JldHVybiBCbihlLnBvcnRNYXAscixuKX1mdW5jdGlvbiBmcG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYztzPW4uc291cmNlLm93bmVyLnR5cGVfMCE9KFdlKCksa3IpLGM9cz9uLnRhcmdldDpuLnNvdXJjZSxyPUtpbihuLGMpLm93bmVyLG89YShLZShlLnBvcnRNYXAsYyksMTI1KSx0PWUubm9kZVJlcHNbci5pZF8wXS5oZWFkLFF3ZShjLm93bmVyKTwoci5sYXllcj9mbyhyLmxheWVyLm5vZGVzLHIsMCk6LTEpPyhpPW8sdT10KTooaT10LHU9byksRmwoQmwoJGwoR2woemwobmV3IEVsLDApLDQpLGkpLHUpKX1mdW5jdGlvbiBwcG4oZSxuKXt2YXIgcix0LG8saTtmb3IoaT1BbyhuLChyZSgpLGxuKSkuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KXQ9YShpLm5leHRfMSgpLDEyKSxyPWEodyh0LChLKCksb2EpKSwxMCksciYmRmwoQmwoJGwoR2woemwobmV3IEVsLDApLC4xKSxlLm5vZGVSZXBzW24uaWRfMF0udGFpbCksZS5ub2RlUmVwc1tyLmlkXzBdLmhlYWQpKTtmb3Iobz1BbyhuLFVlKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMTIpLHI9YSh3KHQsKEsoKSxvYSkpLDEwKSxyJiZGbChCbCgkbChHbCh6bChuZXcgRWwsMCksLjEpLGUubm9kZVJlcHNbci5pZF8wXS50YWlsKSxlLm5vZGVSZXBzW24uaWRfMF0uaGVhZCkpfWZ1bmN0aW9uIGdwbihlLG4pe3JldHVybiBlLm5vZGVTdGF0ZVtuLmlkXzBdPUlwbihuKX1mdW5jdGlvbiBocG4oZSxuKXtyZXR1cm4gZS5ub2RlU3RhdGVbbi5pZF8wXT09Mn1mdW5jdGlvbiBtcG4oZSxuLHIpe3ZhciB0LG8saTtmb3Iobz1uZXcgWGUoUWUoaWMocikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKG8pOyl0PWEodG4obyksMTgpLCF6dCh0KSYmISghenQodCkmJnQuc291cmNlLm93bmVyLmxheWVyPT10LnRhcmdldC5vd25lci5sYXllcikmJihpPXNMZShlLHQscixuZXcgaExlKSxpLmFycmF5Lmxlbmd0aD4xJiZSZShuLmFycmF5LGkpKX1mdW5jdGlvbiB5cG4oZSxuLHIpe3JldHVybiB3cG4oZSxuLHIpLHJ9ZnVuY3Rpb24gd3BuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IoXz1uZXcgUSxjPW5ldyBUKG4ubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocz1hKEMoYyksMTApLGg9QW8ocywocmUoKSxxZSkpLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylmb3IoZj1hKGgubmV4dF8xKCksMTIpLG89bmV3IFQoZi5vdXRnb2luZ0VkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTgpLCEoIXp0KHQpJiZ0LnNvdXJjZS5vd25lci5sYXllcj09dC50YXJnZXQub3duZXIubGF5ZXJ8fHp0KHQpfHx0LnRhcmdldC5vd25lci5sYXllciE9cikmJlJlKF8uYXJyYXksdCk7Zm9yKHU9cWEoci5ub2RlcykuaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KWZvcihzPWEodS5uZXh0XzEoKSwxMCksaD1BbyhzLChyZSgpLGplKSkuaXRlcmF0b3JfMCgpO2guaGFzTmV4dF8wKCk7KWZvcihmPWEoaC5uZXh0XzEoKSwxMiksbz1uZXcgVChmLmluY29taW5nRWRnZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZih0PWEoQyhvKSwxOCksISghenQodCkmJnQuc291cmNlLm93bmVyLmxheWVyPT10LnRhcmdldC5vd25lci5sYXllcnx8enQodCl8fHQuc291cmNlLm93bmVyLmxheWVyIT1uKSYmXy5hcnJheS5sZW5ndGghPTApe2ZvcihkPW5ldyBwdChfLF8uYXJyYXkubGVuZ3RoKSxpPShybihkLmk+MCksYShkLnRoaXMkMDEuZ2V0XzAoZC5sYXN0PS0tZC5pKSwxOCkpO2khPXQmJmQuaT4wOyllLmNyb3NzaW5nW2kuaWRfMF09ITAsZS5jcm9zc2luZ1t0LmlkXzBdPSEwLGk9KHJuKGQuaT4wKSxhKGQudGhpcyQwMS5nZXRfMChkLmxhc3Q9LS1kLmkpLDE4KSk7ZC5pPjAmJkVhKGQpfX1mdW5jdGlvbiBFcG4oZSl7dmFyIG4scix0LG87Zm9yKHI9bmV3IHByLGZ0KHIsZS50d29QYXRocyksdD1uZXcgUEc7ci5zaXplXzAhPTA7KW49YShyLnNpemVfMD09MD9udWxsOihybihyLnNpemVfMCE9MCksWmEocixyLmhlYWRlci5uZXh0XzApKSw1MTUpLG89dUxlKGUsbiwhMCksbyYmZWUodC5hcnJheUxpc3Qsbik7Zm9yKDt0LmFycmF5TGlzdC5hcnJheS5sZW5ndGghPTA7KW49YShGX2UodCksNTE1KSx1TGUoZSxuLCExKX1mdW5jdGlvbiB2cG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZjtmb3IoZS5ub2RlU3RhdGU9QihobixrbiwyOCxlLm5vZGVDb3VudCwxNSwxKSxlLnR3b1BhdGhzPW5ldyBRLExyKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLmxHcmFwaC5sYXllcnMsMTYpKSxuZXcgT0xlKSxuZXcgTUxlKGUpKSxlLmNyb3NzaW5nPUIoeWEseHUsMjgsZS5lZGdlQ291bnQsMTYsMSksR0MobmV3IFNlKG51bGwsbmV3IHhlKGUubEdyYXBoLmxheWVycywxNikpLG5ldyBITGUoZSkpLHQ9KGY9bmV3IFEsTHIoSm4oTm8obmV3IFNlKG51bGwsbmV3IHhlKGUubEdyYXBoLmxheWVycywxNikpLG5ldyBGTGUpLG5ldyB6TGUoZSkpLG5ldyAkTGUoZSxmKSksZiksYz1uZXcgVCh0KTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYodT1hKEMoYyksNTE1KSwhKHUuYXJyYXkubGVuZ3RoPD0xKSl7aWYodS5hcnJheS5sZW5ndGg9PTIpe1Jwbih1KSxwNygoQWUoMCx1LmFycmF5Lmxlbmd0aCksYSh1LmFycmF5WzBdLDE4KSkudGFyZ2V0Lm93bmVyKXx8ZWUoZS50d29QYXRocyx1KTtjb250aW51ZX1pZighKE1wbih1KXx8T3BuKHUsbmV3IERMZSkpKWZvcihfPW5ldyBUKHUpLG89bnVsbDtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMoXyksMTgpLHI9ZS5lZGdlUmVwc1tuLmlkXzBdLCFvfHxfLmk+PV8udGhpcyQwMS5hcnJheS5sZW5ndGg/ZD1GSygoV2UoKSxrciksaXQpOmQ9RksoKFdlKCksaXQpLGl0KSxkKj0yLGk9ci5sZWZ0LndlaWdodCxyLmxlZnQud2VpZ2h0PVMuTWF0aC5tYXgoaSxpKyhkLWkpKSxzPXIucmlnaHQud2VpZ2h0LHIucmlnaHQud2VpZ2h0PVMuTWF0aC5tYXgocyxzKyhkLXMpKSxvPW59fWZ1bmN0aW9uIFNwbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2ZvcihlLm5HcmFwaD1uZXcgV2ssXz0wLG89MCxzPW5ldyBUKGUubEdyYXBoLmxheWVycyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihpPWEoQyhzKSwzMCksYz1uZXcgVChpLm5vZGVzKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2Zvcih1PWEoQyhjKSwxMCksdS5pZF8wPV8rKyx0PW5ldyBYZShRZShScih1KS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXI9YSh0bih0KSwxOCksci5pZF8wPW8rKztmb3Iobj1wNyh1KSxoPW5ldyBUKHUucG9ydHMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmPWEoQyhoKSwxMiksbiYmKHk9Zi5hbmNob3IueV8wLHkhPVMuTWF0aC5mbG9vcih5KSYmKGQ9eS1JXyhIbyhTLk1hdGgucm91bmQoeSkpKSxmLmFuY2hvci55XzAtPWQpKSxtPWYucG9zLnlfMCtmLmFuY2hvci55XzAsbSE9Uy5NYXRoLmZsb29yKG0pJiYoZD1tLUlfKEhvKFMuTWF0aC5yb3VuZChtKSkpLGYucG9zLnlfMC09ZCl9ZS5ub2RlQ291bnQ9XyxlLmVkZ2VDb3VudD1vLGUubm9kZVJlcHM9QihrcG4sTWUsNDEyLF8sMCwxKSxlLmVkZ2VSZXBzPUIoTHBuLE1lLDY1NSxvLDAsMSksZS5mbGV4aWJsZVdoZXJlU3BhY2VQZXJtaXRzRWRnZXMubWFwXzAuY2xlYXJfMCgpfWZ1bmN0aW9uIENwbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmO2lmKHIuYmVnaW4oIk5ldHdvcmsgc2ltcGxleCBub2RlIHBsYWNlbWVudCIsMSksZS5sR3JhcGg9bixlLnNwYWNpbmdzPWEodyhuLChLKCksZWcpKSwzMTIpLFNwbihlKSxfcG4oZSksTHIoTm8obmV3IFNlKG51bGwsbmV3IHhlKGUubEdyYXBoLmxheWVycywxNikpLG5ldyBUTGUpLG5ldyBiTGUoZSkpLExyKEpuKE5vKEpuKE5vKG5ldyBTZShudWxsLG5ldyB4ZShlLmxHcmFwaC5sYXllcnMsMTYpKSxuZXcgVkxlKSxuZXcgcUxlKSxuZXcgWUxlKSxuZXcgS0xlKSxuZXcgQ0xlKGUpKSxhZShpZSh3KGUubEdyYXBoLChvZSgpLFlFKSkpKSYmKHM9ci5zdWJUYXNrKDEpLHMuYmVnaW4oIlN0cmFpZ2h0IEVkZ2VzIFByZS1Qcm9jZXNzaW5nIiwxKSx2cG4oZSkscy5kb25lXzEoKSkscG5uKGUubkdyYXBoKSxpPWEodyhuLEpFKSwxNykudmFsdWVfMCplLm5HcmFwaC5ub2Rlcy5hcnJheS5sZW5ndGgsamsoekgoJEgocWsoZS5uR3JhcGgpLGkpLCExKSxyLnN1YlRhc2soMSkpLGUuZmxleGlibGVXaGVyZVNwYWNlUGVybWl0c0VkZ2VzLm1hcF8wLnNpemVfMSgpIT0wKXtmb3Iocz1yLnN1YlRhc2soMSkscy5iZWdpbigiRmxleGlibGUgV2hlcmUgU3BhY2UgUHJvY2Vzc2luZyIsMSksdT1hKHZhKGJoKHBvKG5ldyBTZShudWxsLG5ldyB4ZShlLm5HcmFwaC5ub2RlcywxNikpLG5ldyBJTGUpLG5ldyBmTGUpKSwxNykudmFsdWVfMCxjPWEodmEoY2YocG8obmV3IFNlKG51bGwsbmV3IHhlKGUubkdyYXBoLm5vZGVzLDE2KSksbmV3IHhMZSksbmV3IHBMZSkpLDE3KS52YWx1ZV8wLF89Yy11LGQ9RjEobmV3IFJfLGUubkdyYXBoKSxmPUYxKG5ldyBSXyxlLm5HcmFwaCksRmwoQmwoJGwoemwoR2wobmV3IEVsLDJlNCksXyksZCksZikpLExyKEpuKEpuKHpCKGUubm9kZVJlcHMpLG5ldyBQTGUpLG5ldyBOTGUpLG5ldyBBTGUodSxkLF8sZikpLG89ZS5mbGV4aWJsZVdoZXJlU3BhY2VQZXJtaXRzRWRnZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7by5oYXNOZXh0XzAoKTspdD1hKG8ubmV4dF8xKCksMjE4KSx0LndlaWdodD0xO2prKHpIKCRIKHFrKGUubkdyYXBoKSxpKSwhMSkscy5zdWJUYXNrKDEpKSxzLmRvbmVfMSgpfWFlKGllKHcobixZRSkpKSYmKHM9ci5zdWJUYXNrKDEpLHMuYmVnaW4oIlN0cmFpZ2h0IEVkZ2VzIFBvc3QtUHJvY2Vzc2luZyIsMSksRXBuKGUpLHMuZG9uZV8xKCkpLGNwbihlKSxlLmxHcmFwaD1udWxsLGUubkdyYXBoPW51bGwsZS5ub2RlUmVwcz1udWxsLGUuZWRnZVJlcHM9bnVsbCxaaShlLnBvcnRNYXApLGUubm9kZVN0YXRlPW51bGwsZS5jcm9zc2luZz1udWxsLGUudHdvUGF0aHM9bnVsbCxlLmZsZXhpYmxlV2hlcmVTcGFjZVBlcm1pdHNFZGdlcy5tYXBfMC5jbGVhcl8wKCksci5kb25lXzEoKX1mdW5jdGlvbiBUcG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7cj1GMShuZXcgUl8sZS5uR3JhcGgpLF89ZS5ub2RlUmVwc1tuLnNvdXJjZS5vd25lci5pZF8wXSxtPWUubm9kZVJlcHNbbi50YXJnZXQub3duZXIuaWRfMF0sYz1uLnNvdXJjZSxoPW4udGFyZ2V0LHU9Yy5hbmNob3IueV8wLGY9aC5hbmNob3IueV8wLF8uaXNGbGV4aWJsZXx8KHUrPWMucG9zLnlfMCksbS5pc0ZsZXhpYmxlfHwoZis9aC5wb3MueV8wKSxkPUtyKFMuTWF0aC5tYXgoMCx1LWYpKSxzPUtyKFMuTWF0aC5tYXgoMCxmLXUpKSx5PShFPVMuTWF0aC5tYXgoMSxhKHcobiwob2UoKSxZaCkpLDE3KS52YWx1ZV8wKSx2PUZLKG4uc291cmNlLm93bmVyLnR5cGVfMCxuLnRhcmdldC5vd25lci50eXBlXzApLEUqdiksbz1GbChCbCgkbCh6bChHbChuZXcgRWwseSkscyksciksYShLZShlLnBvcnRNYXAsbi5zb3VyY2UpLDEyNSkpKSxpPUZsKEJsKCRsKHpsKEdsKG5ldyBFbCx5KSxkKSxyKSxhKEtlKGUucG9ydE1hcCxuLnRhcmdldCksMTI1KSkpLHQ9bmV3IGdMZShvLGkpLGUuZWRnZVJlcHNbbi5pZF8wXT10fWZ1bmN0aW9uIGJwbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEU7Zm9yKG89bnVsbCx0PW5ldyBUKG4ubm9kZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxMCkscDcocik/aT0odT1GMShWQyhuZXcgUl8sciksZS5uR3JhcGgpLGM9RjEoVkMobmV3IFJfLHIpLGUubkdyYXBoKSxfPW5ldyB6SyhyLCEwLHUsYyksZD1yLnNpemVfMC55XzAsZj0oUmYoKSwoci5wcm9wZXJ0eU1hcD9yLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5jb250YWluc0tleSgob2UoKSxuZCkpP2g9YSh3KHIsbmQpLDIwMyk6aD1hKHcoU3QociksS0UpLDIwMyksaCksbT0xZTQsZj09YWcmJihtPTEpLHk9RmwoQmwoJGwoemwoR2wobmV3IEVsLG0pLEtyKFMuTWF0aC5jZWlsKGQpKSksdSksYykpLGY9PWxnJiZZcihlLmZsZXhpYmxlV2hlcmVTcGFjZVBlcm1pdHNFZGdlcyx5KSxjTGUoZSxxYShBbyhyLChyZSgpLGplKSkpLF8pLGNMZShlLEFvKHIscWUpLF8pLF8pOmk9KEU9RjEoVkMobmV3IFJfLHIpLGUubkdyYXBoKSxMcihKbihuZXcgU2UobnVsbCxuZXcgeGUoci5wb3J0cywxNikpLG5ldyB2TGUpLG5ldyBTTGUoZSxFKSksbmV3IHpLKHIsITEsRSxFKSksZS5ub2RlUmVwc1tyLmlkXzBdPWksbyYmKHM9by5vcmlnaW5fMC5tYXJnaW4uYm90dG9tK3NnKGUuc3BhY2luZ3Msby5vcmlnaW5fMCxyKStyLm1hcmdpbi50b3BfMCxvLmlzRmxleGlibGV8fChzKz1vLm9yaWdpbl8wLnNpemVfMC55XzApLEZsKEJsKCRsKEdsKHpsKG5ldyBFbCxLcihTLk1hdGguY2VpbChzKSkpLDApLG8udGFpbCksaS5oZWFkKSkpLG89aX1mdW5jdGlvbiBjTGUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7aWYoIUptKG4pKXtmb3IoYz1SKCQoemYoci5vcmlnaW5fMCwob2UoKSxYRSkpKSksXz1hKHpmKHIub3JpZ2luXzAsRjMpLDE0MCksIV8mJihfPW5ldyB2RSksdD1yLmhlYWQsbz1udWxsLHU9bi5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMTIpLGQ9MCxvPyhkPWMsZCs9by5zaXplXzAueV8wKTpkPV8udG9wXzAsaT1GMShWQyhuZXcgUl8scyksZS5uR3JhcGgpLEJuKGUucG9ydE1hcCxzLGkpLEZsKEJsKCRsKHpsKEdsKG5ldyBFbCwwKSxLcihTLk1hdGguY2VpbChkKSkpLHQpLGkpKSxvPXMsdD1pO0ZsKEJsKCRsKHpsKEdsKG5ldyBFbCwwKSxLcihTLk1hdGguY2VpbChfLmJvdHRvbStvLnNpemVfMC55XzApKSksdCksci50YWlsKSl9fWZ1bmN0aW9uIF9MZSgpe01hKCksdGhpcy5wb3J0TWFwPW5ldyBzbix0aGlzLmZsZXhpYmxlV2hlcmVTcGFjZVBlcm1pdHNFZGdlcz1uZXcgQnJ9ZnVuY3Rpb24gSXBuKGUpe3ZhciBuLHIsdCxvO2ZvcihuPTAscj0wLG89bmV3IFQoZS5wb3J0cyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHQ9YShDKG8pLDEyKSxuPVNuKE50KG4sWTFlKEpuKG5ldyBTZShudWxsLG5ldyB4ZSh0LmluY29taW5nRWRnZXMsMTYpKSxuZXcgQkxlKSkpKSxyPVNuKE50KHIsWTFlKEpuKG5ldyBTZShudWxsLG5ldyB4ZSh0Lm91dGdvaW5nRWRnZXMsMTYpKSxuZXcgR0xlKSkpKSxuPjF8fHI+MSlyZXR1cm4gMjtyZXR1cm4gbityPT0xPzI6MH1mdW5jdGlvbiBwNyhlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF87cmV0dXJuIShlLnR5cGVfMCE9KFdlKCksa3IpfHxlLnBvcnRzLmFycmF5Lmxlbmd0aDw9MXx8KGk9YSh3KGUsKG9lKCkseHIpKSwxMDEpLGk9PShkdCgpLGFpKSl8fChvPShSZigpLChlLnByb3BlcnR5TWFwP2UucHJvcGVydHlNYXA6KE5lKCksTmUoKSxrdSkpLmNvbnRhaW5zS2V5KG5kKT90PWEodyhlLG5kKSwyMDMpOnQ9YSh3KFN0KGUpLEtFKSwyMDMpLHQpLG89PURQKXx8IShvPT1sZ3x8bz09YWcpJiYocz1SKCQoemYoZSxYRSkpKSxuPWEodyhlLEYzKSwxNDApLCFuJiYobj1uZXcgUlcocyxzLHMscykpLF89QW8oZSwocmUoKSxqZSkpLGM9bi50b3BfMCtuLmJvdHRvbSsoXy5zaXplXzEoKS0xKSpzLGM+ZS5zaXplXzAueV8wfHwocj1BbyhlLHFlKSx1PW4udG9wXzArbi5ib3R0b20rKHIuc2l6ZV8xKCktMSkqcyx1PmUuc2l6ZV8wLnlfMCkpKX1mdW5jdGlvbiB4cG4oZSl7cmV0dXJuIE1hKCksIXp0KGUpJiYhKCF6dChlKSYmZS5zb3VyY2Uub3duZXIubGF5ZXI9PWUudGFyZ2V0Lm93bmVyLmxheWVyKX1mdW5jdGlvbiBQcG4oZSl7cmV0dXJuIE1hKCksKHJlKCksdmkpLmNvbnRhaW5zKGUuc2lkZSl9ZnVuY3Rpb24gTnBuKGUsbixyLHQsbyl7TWEoKSxGbChCbCgkbCh6bChHbChuZXcgRWwsMCksby50YWlsLmxheWVyLWUpLG4pLG8udGFpbCkpLEZsKEJsKCRsKHpsKEdsKG5ldyBFbCwwKSxyLW8uaGVhZC5sYXllciksby5oZWFkKSx0KSl9ZnVuY3Rpb24gQXBuKGUsbil7cmV0dXJuIE1hKCksbi5wb3MueV8wKz1lfWZ1bmN0aW9uIGc3KGUpe3JldHVybiBTLk1hdGguYWJzKGUuc291cmNlLmxheWVyLWUudGFyZ2V0LmxheWVyKS1lLmRlbHRhfXAoMTQyOCwxLFd0LF9MZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKHcoYShuLDM2KSwoSygpLGlpKSksMjEpLmNvbnRhaW5zKChWdCgpLG5sKSk/ZExlOm51bGx9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0Nwbih0aGlzLGEobiwzNikscil9LGwuZWRnZUNvdW50PTAsbC5ub2RlQ291bnQ9MDt2YXIgZExlO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIiLDE0MjgpO2Z1bmN0aW9uIGZMZSgpe31wKDE0NDcsMSxObixmTGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHFvKGEobiwxNykudmFsdWVfMCxhKHIsMTcpLnZhbHVlXzApfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvMG1ldGhvZHJlZiRjb21wYXJlJFR5cGUiLDE0NDcpO2Z1bmN0aW9uIHBMZSgpe31wKDE0NDksMSxObixwTGUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHFvKGEobiwxNykudmFsdWVfMCxhKHIsMTcpLnZhbHVlXzApfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvMW1ldGhvZHJlZiRjb21wYXJlJFR5cGUiLDE0NDkpO2Z1bmN0aW9uIGdMZShlLG4pe3RoaXMubGVmdD1lLHRoaXMucmlnaHQ9bn1wKDY1NSwxLHs2NTU6MX0sZ0xlKTt2YXIgTHBuPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvRWRnZVJlcCIsNjU1KTtmdW5jdGlvbiB6SyhlLG4scix0KXt0aGlzLm9yaWdpbl8wPWUsdGhpcy5pc0ZsZXhpYmxlPW4sdGhpcy5oZWFkPXIsdGhpcy50YWlsPXR9cCg0MTIsMSx7NDEyOjF9LHpLKSxsLmlzRmxleGlibGU9ITE7dmFyIGtwbj1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL05vZGVSZXAiLDQxMik7ZnVuY3Rpb24gT3BuKGUsbil7dmFyIHI7cmV0dXJuIGUuYXJyYXkubGVuZ3RoPT0wPyExOihyPXBQZSgoQWUoMCxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzBdLDE4KSkuc291cmNlLm93bmVyKSxNYSgpLHI9PShSZigpLGxnKXx8cj09YWc/ITA6TXAocG8obmV3IFNlKG51bGwsbmV3IHhlKGUsMTYpKSxuZXcgd0xlKSxuZXcgRUxlKG4pKSl9ZnVuY3Rpb24gTXBuKGUpe3JldHVybiBlLmFycmF5Lmxlbmd0aD09MD8hMTooQWUoMCxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzBdLDE4KSkuc291cmNlLm93bmVyLnR5cGVfMD09KFdlKCksaXQpPyEwOk1wKHBvKG5ldyBTZShudWxsLG5ldyB4ZShlLDE2KSksbmV3IG1MZSksbmV3IHlMZSl9ZnVuY3Rpb24gUnBuKGUpe3ZhciBuLHI7aWYoZS5hcnJheS5sZW5ndGghPTIpdGhyb3cgYihuZXcgcm8oIk9yZGVyIG9ubHkgYWxsb3dlZCBmb3IgdHdvIHBhdGhzLiIpKTtuPShBZSgwLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbMF0sMTgpKSxyPShBZSgxLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbMV0sMTgpKSxuLnRhcmdldC5vd25lciE9ci5zb3VyY2Uub3duZXImJihlLmFycmF5Lmxlbmd0aD0wLFJlKGUuYXJyYXksciksUmUoZS5hcnJheSxuKSl9ZnVuY3Rpb24gaExlKCl7US5jYWxsKHRoaXMpfXAoNTE1LDEzLHszOjEsNDoxLDIwOjEsMzE6MSw1NjoxLDEzOjEsMTY6MSwxNToxLDU5OjEsNTE1OjF9LGhMZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9QYXRoIiw1MTUpO2Z1bmN0aW9uIG1MZSgpe31wKDE0MjksMSx7fSxtTGUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDE4KS50YXJnZXQub3duZXIudHlwZV8wfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL1BhdGgvbGFtYmRhJDAkVHlwZSIsMTQyOSk7ZnVuY3Rpb24geUxlKCl7fXAoMTQzMCwxLEluLHlMZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNzMpPT0oV2UoKSxpdCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvUGF0aC9sYW1iZGEkMSRUeXBlIiwxNDMwKTtmdW5jdGlvbiB3TGUoKXt9cCgxNDMxLDEse30sd0xlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxOCkudGFyZ2V0Lm93bmVyfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL1BhdGgvbGFtYmRhJDIkVHlwZSIsMTQzMSk7ZnVuY3Rpb24gRUxlKGUpe3RoaXMucF8wPWV9cCgxNDMyLDEsSW4sRUxlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gUkxlKHBQZShhKG4sMTApKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvUGF0aC9sYW1iZGEkMyRUeXBlIiwxNDMyKTtmdW5jdGlvbiB2TGUoKXt9cCgxNDMzLDEsSW4sdkxlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gUHBuKGEobiwxMikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQwJFR5cGUiLDE0MzMpO2Z1bmN0aW9uIFNMZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5zaW5nbGVOb2RlXzE9bn1wKDE0MzQsMSxKZSxTTGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Rwbih0aGlzLiQkb3V0ZXJfMCx0aGlzLnNpbmdsZU5vZGVfMSxhKG4sMTIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMSRUeXBlIiwxNDM0KTtmdW5jdGlvbiBDTGUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDE0NDMsMSxKZSxDTGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Zwbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTgpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMTAkVHlwZSIsMTQ0Myk7ZnVuY3Rpb24gVExlKCl7fXAoMTQ0NCwxLHt9LFRMZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBNYSgpLG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDExJFR5cGUiLDE0NDQpO2Z1bmN0aW9uIGJMZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTQ0NSwxLEplLGJMZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7cHBuKHRoaXMuJCRvdXRlcl8wLGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQxMiRUeXBlIiwxNDQ1KTtmdW5jdGlvbiBJTGUoKXt9cCgxNDQ2LDEse30sSUxlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksSihhKG4sMTI1KS5sYXllcil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDEzJFR5cGUiLDE0NDYpO2Z1bmN0aW9uIHhMZSgpe31wKDE0NDgsMSx7fSx4TGUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gTWEoKSxKKGEobiwxMjUpLmxheWVyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMTUkVHlwZSIsMTQ0OCk7ZnVuY3Rpb24gUExlKCl7fXAoMTQ1MCwxLEluLFBMZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksYShuLDQxMikub3JpZ2luXzAudHlwZV8wPT0oV2UoKSxrcil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDE3JFR5cGUiLDE0NTApO2Z1bmN0aW9uIE5MZSgpe31wKDE0NTEsMSxJbixOTGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBNYSgpLGEobiw0MTIpLm9yaWdpbl8wLnBvcnRzLmFycmF5Lmxlbmd0aD4xfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQxOCRUeXBlIiwxNDUxKTtmdW5jdGlvbiBBTGUoZSxuLHIsdCl7dGhpcy5taW5MYXllcl8wPWUsdGhpcy5nbG9iYWxTb3VyY2VfMT1uLHRoaXMudXNlZExheWVyc18yPXIsdGhpcy5nbG9iYWxTaW5rXzM9dH1wKDE0NTIsMSxKZSxBTGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe05wbih0aGlzLm1pbkxheWVyXzAsdGhpcy5nbG9iYWxTb3VyY2VfMSx0aGlzLnVzZWRMYXllcnNfMix0aGlzLmdsb2JhbFNpbmtfMyxhKG4sNDEyKSl9LGwubWluTGF5ZXJfMD0wLGwudXNlZExheWVyc18yPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMTkkVHlwZSIsMTQ1Mik7ZnVuY3Rpb24gTExlKCl7fXAoMTQzNSwxLHt9LExMZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBNYSgpLG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDIkVHlwZSIsMTQzNSk7ZnVuY3Rpb24ga0xlKGUpe3RoaXMuc2l6ZURlbHRhXzA9ZX1wKDE0NTMsMSxKZSxrTGUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0Fwbih0aGlzLnNpemVEZWx0YV8wLGEobiwxMikpfSxsLnNpemVEZWx0YV8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMjAkVHlwZSIsMTQ1Myk7ZnVuY3Rpb24gT0xlKCl7fXAoMTQ1NCwxLHt9LE9MZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBNYSgpLG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDIxJFR5cGUiLDE0NTQpO2Z1bmN0aW9uIE1MZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTQ1NSwxLEplLE1MZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7Z3BuKHRoaXMuJCRvdXRlcl8wLGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQyMiRUeXBlIiwxNDU1KTtmdW5jdGlvbiBSTGUoZSl7cmV0dXJuIE1hKCksZlBlKGEoZSwyMDMpKX1mdW5jdGlvbiBETGUoKXt9cCgxNDU2LDEsSW4sRExlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gUkxlKG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQyMyRUeXBlIiwxNDU2KTtmdW5jdGlvbiBGTGUoKXt9cCgxNDU3LDEse30sRkxlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksbmV3IFNlKG51bGwsbmV3IHhlKGEobiwzMCkubm9kZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMjQkVHlwZSIsMTQ1Nyk7ZnVuY3Rpb24gekxlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNDU4LDEsSW4sekxlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gaHBuKHRoaXMuJCRvdXRlcl8wLGEobiwxMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQyNSRUeXBlIiwxNDU4KTtmdW5jdGlvbiAkTGUoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMucGF0aHNfMT1ufXAoMTQ1OSwxLEplLCRMZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7bXBuKHRoaXMuJCRvdXRlcl8wLHRoaXMucGF0aHNfMSxhKG4sMTApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMjYkVHlwZSIsMTQ1OSk7ZnVuY3Rpb24gQkxlKCl7fXAoMTQ2MCwxLEluLEJMZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksIXp0KGEobiwxOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQyNyRUeXBlIiwxNDYwKTtmdW5jdGlvbiBHTGUoKXt9cCgxNDYxLDEsSW4sR0xlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTWEoKSwhenQoYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDI4JFR5cGUiLDE0NjEpO2Z1bmN0aW9uIEhMZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTQ2MiwxLHt9LEhMZSksbC5hcHBseV8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIHlwbih0aGlzLiQkb3V0ZXJfMCxhKG4sMzApLGEociwzMCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIk5ldHdvcmtTaW1wbGV4UGxhY2VyL2xhbWJkYSQyOSRUeXBlIiwxNDYyKTtmdW5jdGlvbiBVTGUoKXt9cCgxNDM2LDEse30sVUxlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksbmV3IFNlKG51bGwsbmV3IE8xKG5ldyBYZShRZShScihhKG4sMTApKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkMyRUeXBlIiwxNDM2KTtmdW5jdGlvbiBXTGUoKXt9cCgxNDM3LDEsSW4sV0xlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTWEoKSx4cG4oYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDQkVHlwZSIsMTQzNyk7ZnVuY3Rpb24gakxlKGUpe3RoaXMuJCRvdXRlcl8wPWV9cCgxNDM4LDEsSmUsakxlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtUcG4odGhpcy4kJG91dGVyXzAsYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDUkVHlwZSIsMTQzOCk7ZnVuY3Rpb24gVkxlKCl7fXAoMTQzOSwxLHt9LFZMZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBNYSgpLG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMzApLm5vZGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDYkVHlwZSIsMTQzOSk7ZnVuY3Rpb24gcUxlKCl7fXAoMTQ0MCwxLEluLHFMZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksYShuLDEwKS50eXBlXzA9PShXZSgpLGtyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkNyRUeXBlIiwxNDQwKTtmdW5jdGlvbiBZTGUoKXt9cCgxNDQxLDEse30sWUxlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE1hKCksbmV3IFNlKG51bGwsbmV3IE8xKG5ldyBYZShRZShpYyhhKG4sMTApKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMiLCJOZXR3b3JrU2ltcGxleFBsYWNlci9sYW1iZGEkOCRUeXBlIiwxNDQxKTtmdW5jdGlvbiBLTGUoKXt9cCgxNDQyLDEsSW4sS0xlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTWEoKSxYaW4oYShuLDE4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzIiwiTmV0d29ya1NpbXBsZXhQbGFjZXIvbGFtYmRhJDkkVHlwZSIsMTQ0Mik7ZnVuY3Rpb24gWExlKCl7WExlPUYsWkxlPU1uKG5ldyBIciwoeHQoKSxobyksKGt0KCksUEUpKX1mdW5jdGlvbiBEcG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3Iobi5iZWdpbigiU2ltcGxlIG5vZGUgcGxhY2VtZW50IiwxKSxmPWEodyhlLChLKCksZWcpKSwzMTIpLHU9MCxpPW5ldyBUKGUubGF5ZXJzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2Zvcih0PWEoQyhpKSwzMCkscz10LnNpemVfMCxzLnlfMD0wLHI9bnVsbCxfPW5ldyBUKHQubm9kZXMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyljPWEoQyhfKSwxMCksciYmKHMueV8wKz1ZWShjLHIsZi5ub2RlVHlwZVNwYWNpbmdPcHRpb25zVmVydGljYWwpKSxzLnlfMCs9Yy5tYXJnaW4udG9wXzArYy5zaXplXzAueV8wK2MubWFyZ2luLmJvdHRvbSxyPWM7dT1TLk1hdGgubWF4KHUscy55XzApfWZvcihvPW5ldyBUKGUubGF5ZXJzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9YShDKG8pLDMwKSxzPXQuc2l6ZV8wLGQ9KHUtcy55XzApLzIscj1udWxsLF89bmV3IFQodC5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDEwKSxyJiYoZCs9WVkoYyxyLGYubm9kZVR5cGVTcGFjaW5nT3B0aW9uc1ZlcnRpY2FsKSksZCs9Yy5tYXJnaW4udG9wXzAsYy5wb3MueV8wPWQsZCs9Yy5zaXplXzAueV8wK2MubWFyZ2luLmJvdHRvbSxyPWM7bi5kb25lXzEoKX1mdW5jdGlvbiBKTGUoKXtYTGUoKX1wKDE0MjQsMSxXdCxKTGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYSh3KGEobiwzNiksKEsoKSxpaSkpLDIxKS5jb250YWlucygoVnQoKSxubCkpP1pMZTpudWxsfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtEcG4oYShuLDM2KSxyKX07dmFyIFpMZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2RlcyIsIlNpbXBsZU5vZGVQbGFjZXIiLDE0MjQpO2Z1bmN0aW9uIEZwbihlLG4scil7dmFyIHQsbztyZXR1cm4gdD1SKGUueV8wW24ub3duZXIuaWRfMF0pK1IoZS5pbm5lclNoaWZ0W24ub3duZXIuaWRfMF0pK24ucG9zLnlfMCtuLmFuY2hvci55XzAsbz1SKGUueV8wW3Iub3duZXIuaWRfMF0pK1IoZS5pbm5lclNoaWZ0W3Iub3duZXIuaWRfMF0pK3IucG9zLnlfMCtyLmFuY2hvci55XzAsby10fWZ1bmN0aW9uIHpwbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmO289cixkPW4saT1kO2RvIGk9ZS5hbGlnbl8wW2kuaWRfMF0sdT0oZj1lLnJvb3RbaS5pZF8wXSxSKGUueV8wW2YuaWRfMF0pK1IoZS5pbm5lclNoaWZ0W2kuaWRfMF0pLWkubWFyZ2luLnRvcF8wKSxjPUdwbihpLHQpLGMmJihzPShfPWUucm9vdFtjLmlkXzBdLFIoZS55XzBbXy5pZF8wXSkrUihlLmlubmVyU2hpZnRbYy5pZF8wXSkrYy5zaXplXzAueV8wK2MubWFyZ2luLmJvdHRvbSksbz1TLk1hdGgubWluKG8sdS0ocytzZyhlLnNwYWNpbmdzLGksYykpKSk7d2hpbGUoZCE9aSk7cmV0dXJuIG99ZnVuY3Rpb24gJHBuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGY7bz1yLGQ9bixpPWQ7ZG8gaT1lLmFsaWduXzBbaS5pZF8wXSxzPShmPWUucm9vdFtpLmlkXzBdLFIoZS55XzBbZi5pZF8wXSkrUihlLmlubmVyU2hpZnRbaS5pZF8wXSkraS5zaXplXzAueV8wK2kubWFyZ2luLmJvdHRvbSksYz1CcG4oaSx0KSxjJiYodT0oXz1lLnJvb3RbYy5pZF8wXSxSKGUueV8wW18uaWRfMF0pK1IoZS5pbm5lclNoaWZ0W2MuaWRfMF0pLWMubWFyZ2luLnRvcF8wKSxvPVMuTWF0aC5taW4obyx1LShzK3NnKGUuc3BhY2luZ3MsaSxjKSkpKTt3aGlsZShkIT1pKTtyZXR1cm4gb31mdW5jdGlvbiBCcG4oZSxuKXt2YXIgcix0O3JldHVybiByPWUubGF5ZXIsdD1uLm5vZGVJbmRleFtlLmlkXzBdLHQ8ci5ub2Rlcy5hcnJheS5sZW5ndGgtMT9hKGxlKHIubm9kZXMsdCsxKSwxMCk6bnVsbH1mdW5jdGlvbiBHcG4oZSxuKXt2YXIgcix0O3JldHVybiByPWUubGF5ZXIsdD1uLm5vZGVJbmRleFtlLmlkXzBdLHQ+MD9hKGxlKHIubm9kZXMsdC0xKSwxMCk6bnVsbH1mdW5jdGlvbiBoNyhlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihvPWhyLHQ9VnIscj1uZXcgVChlLmxheWVyZWRHcmFwaC5sYXllcnMpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iobj1hKEMociksMzApLHM9bmV3IFQobi5ub2Rlcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDEwKSxjPVIoZS55XzBbaS5pZF8wXSksdT1jK1IoZS5ibG9ja1NpemVbZS5yb290W2kuaWRfMF0uaWRfMF0pLG89Uy5NYXRoLm1pbihvLGMpLHQ9Uy5NYXRoLm1heCh0LHUpO3JldHVybiB0LW99ZnVuY3Rpb24gUUxlKGUsbixyKXt2YXIgdCxvO3Q9bjtkbyBvPVIoZS55XzBbdC5pZF8wXSkrcixlLnlfMFt0LmlkXzBdPW8sdD1lLmFsaWduXzBbdC5pZF8wXTt3aGlsZSh0IT1uKX1mdW5jdGlvbiB1ZyhlLG4scix0KXt0aGlzLmxheWVyZWRHcmFwaD1lLHRoaXMuc3BhY2luZ3M9YSh3KGUsKEsoKSxlZykpLDMxMiksdGhpcy5yb290PUIoUnUsSWMsMTAsbiwwLDEpLHRoaXMuYmxvY2tTaXplPUIoJHIsWCwzNDUsbiw3LDEpLHRoaXMuYWxpZ25fMD1CKFJ1LEljLDEwLG4sMCwxKSx0aGlzLmlubmVyU2hpZnQ9QigkcixYLDM0NSxuLDcsMSksdGhpcy5zaW5rPUIoUnUsSWMsMTAsbiwwLDEpLHRoaXMuc2hpZnRfMD1CKCRyLFgsMzQ1LG4sNywxKSx0aGlzLnlfMD1CKCRyLFgsMzQ1LG4sNywxKSx0aGlzLnN1PUIoQXIsWCw0ODUsbiw4LDEpLExDKHRoaXMuc3UsKHplKCksITEpKSx0aGlzLm9kPUIoQXIsWCw0ODUsbiw4LDEpLExDKHRoaXMub2QsITApLHRoaXMudmRpcj1yLHRoaXMuaGRpcj10fXAoMTg1LDEsezE4NToxfSx1ZyksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49IiIsdGhpcy5oZGlyPT0ocHUoKSxsZCk/bis9IlJJR0hUIjp0aGlzLmhkaXI9PXFjJiYobis9IkxFRlQiKSx0aGlzLnZkaXI9PShScygpLFlfKT9uKz0iRE9XTiI6dGhpcy52ZGlyPT1Ecz9uKz0iVVAiOm4rPSJCQUxBTkNFRCIsbn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMuYmsiLCJCS0FsaWduZWRMYXlvdXQiLDE4NSk7ZnVuY3Rpb24gcHUoKXtwdT1GLGxkPW5ldyAkSygiUklHSFQiLDApLHFjPW5ldyAkSygiTEVGVCIsMSl9ZnVuY3Rpb24gJEsoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBIcG4oZSl7cmV0dXJuIHB1KCksd24oKG42ZSgpLHI2ZSksZSl9ZnVuY3Rpb24gVXBuKCl7cmV0dXJuIHB1KCksUChJKGU2ZSwxKSxXLDUyMywwLFtsZCxxY10pfXAoNTIzLDIyLHszOjEsMzQ6MSwyMjoxLDUyMzoxfSwkSyk7dmFyIHFjLGxkLGU2ZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMuYmsiLCJCS0FsaWduZWRMYXlvdXQvSERpcmVjdGlvbiIsNTIzLGduLFVwbixIcG4pO2Z1bmN0aW9uIG42ZSgpe242ZT1GLHI2ZT15bigocHUoKSxQKEkoZTZlLDEpLFcsNTIzLDAsW2xkLHFjXSkpKX12YXIgcjZlO2Z1bmN0aW9uIFJzKCl7UnM9RixZXz1uZXcgQksoIkRPV04iLDApLERzPW5ldyBCSygiVVAiLDEpfWZ1bmN0aW9uIEJLKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gV3BuKGUpe3JldHVybiBScygpLHduKChvNmUoKSxpNmUpLGUpfWZ1bmN0aW9uIGpwbigpe3JldHVybiBScygpLFAoSSh0NmUsMSksVyw1MjIsMCxbWV8sRHNdKX1wKDUyMiwyMix7MzoxLDM0OjEsMjI6MSw1MjI6MX0sQkspO3ZhciBZXyxEcyx0NmU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzLmJrIiwiQktBbGlnbmVkTGF5b3V0L1ZEaXJlY3Rpb24iLDUyMixnbixqcG4sV3BuKTtmdW5jdGlvbiBvNmUoKXtvNmU9RixpNmU9eW4oKFJzKCksUChJKHQ2ZSwxKSxXLDUyMiwwLFtZXyxEc10pKSl9dmFyIGk2ZTtmdW5jdGlvbiBWcG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihuPWc2ZShlKSxkPSh1PW5ldyBrXyhuKS50aGlzJDAxLmVudHJ5U2V0XzAoKS5pdGVyYXRvcl8wKCksbmV3IEtJKHUpKTtkLnZhbCRvdXRlckl0ZXIyLmhhc05leHRfMCgpOyl7Zm9yKF89KG89YShkLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKG8uZ2V0S2V5KCksMTApKSxmPTAsaD0wLGY9Xy5tYXJnaW4udG9wXzAsaD1fLnNpemVfMC55XzArXy5tYXJnaW4uYm90dG9tLGUuaW5uZXJTaGlmdFtfLmlkXzBdPTAscj1fOyhpPWUuYWxpZ25fMFtyLmlkXzBdKSE9XzspdD1lZ24ocixpKSxjPTAsZS5oZGlyPT0ocHUoKSxxYyk/Yz10LnRhcmdldC5wb3MueV8wK3QudGFyZ2V0LmFuY2hvci55XzAtdC5zb3VyY2UucG9zLnlfMC10LnNvdXJjZS5hbmNob3IueV8wOmM9dC5zb3VyY2UucG9zLnlfMCt0LnNvdXJjZS5hbmNob3IueV8wLXQudGFyZ2V0LnBvcy55XzAtdC50YXJnZXQuYW5jaG9yLnlfMCxzPVIoZS5pbm5lclNoaWZ0W3IuaWRfMF0pK2MsZS5pbm5lclNoaWZ0W2kuaWRfMF09cyxmPVMuTWF0aC5tYXgoZixpLm1hcmdpbi50b3BfMC1zKSxoPVMuTWF0aC5tYXgoaCxzK2kuc2l6ZV8wLnlfMCtpLm1hcmdpbi5ib3R0b20pLHI9aTtyPV87ZG8gZS5pbm5lclNoaWZ0W3IuaWRfMF09UihlLmlubmVyU2hpZnRbci5pZF8wXSkrZixyPWUuYWxpZ25fMFtyLmlkXzBdO3doaWxlKHIhPV8pO2UuYmxvY2tTaXplW18uaWRfMF09ZitofX1mdW5jdGlvbiBxcG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxIO2Zvcih1PW5ldyBUKGUubGF5ZXJlZEdyYXBoLmxheWVycyk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihpPWEoQyh1KSwzMCksaz1uZXcgVChpLm5vZGVzKTtrLmk8ay50aGlzJDAxLmFycmF5Lmxlbmd0aDspQT1hKEMoayksMTApLG4ucm9vdFtBLmlkXzBdPUEsbi5hbGlnbl8wW0EuaWRfMF09QSxuLmlubmVyU2hpZnRbQS5pZF8wXT0wO2ZvcihjPWUubGF5ZXJlZEdyYXBoLmxheWVycyxuLmhkaXI9PShwdSgpLHFjKSYmKGM9cWEoYykpLHM9Yy5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspZm9yKGk9YShzLm5leHRfMSgpLDMwKSxtPS0xLGg9aS5ub2RlcyxuLnZkaXI9PShScygpLERzKSYmKG09cW4saD1xYShoKSksSD1oLml0ZXJhdG9yXzAoKTtILmhhc05leHRfMCgpOylpZihNPWEoSC5uZXh0XzEoKSwxMCksZj1udWxsLG4uaGRpcj09cWM/Zj1hKGxlKGUubmkucmlnaHROZWlnaGJvcnMsTS5pZF8wKSwxNSk6Zj1hKGxlKGUubmkubGVmdE5laWdoYm9ycyxNLmlkXzApLDE1KSxmLnNpemVfMSgpPjApaWYodD1mLnNpemVfMSgpLF89S3IoUy5NYXRoLmZsb29yKCh0KzEpLzIpKS0xLG89S3IoUy5NYXRoLmNlaWwoKHQrMSkvMikpLTEsbi52ZGlyPT1Ecylmb3IoZD1vO2Q+PV87ZC0tKW4uYWxpZ25fMFtNLmlkXzBdPT1NJiYoRT1hKGYuZ2V0XzAoZCksNDIpLHk9YShFLmZpcnN0LDEwKSwhc3MocixFLnNlY29uZCkmJm0+ZS5uaS5ub2RlSW5kZXhbeS5pZF8wXSYmKG4uYWxpZ25fMFt5LmlkXzBdPU0sbi5yb290W00uaWRfMF09bi5yb290W3kuaWRfMF0sbi5hbGlnbl8wW00uaWRfMF09bi5yb290W00uaWRfMF0sbi5vZFtuLnJvb3RbTS5pZF8wXS5pZF8wXT0oemUoKSwhIShhZShuLm9kW24ucm9vdFtNLmlkXzBdLmlkXzBdKSZNLnR5cGVfMD09KFdlKCksaXQpKSksbT1lLm5pLm5vZGVJbmRleFt5LmlkXzBdKSk7ZWxzZSBmb3IoZD1fO2Q8PW87ZCsrKW4uYWxpZ25fMFtNLmlkXzBdPT1NJiYoeD1hKGYuZ2V0XzAoZCksNDIpLHY9YSh4LmZpcnN0LDEwKSwhc3Mocix4LnNlY29uZCkmJm08ZS5uaS5ub2RlSW5kZXhbdi5pZF8wXSYmKG4uYWxpZ25fMFt2LmlkXzBdPU0sbi5yb290W00uaWRfMF09bi5yb290W3YuaWRfMF0sbi5hbGlnbl8wW00uaWRfMF09bi5yb290W00uaWRfMF0sbi5vZFtuLnJvb3RbTS5pZF8wXS5pZF8wXT0oemUoKSwhIShhZShuLm9kW24ucm9vdFtNLmlkXzBdLmlkXzBdKSZNLnR5cGVfMD09KFdlKCksaXQpKSksbT1lLm5pLm5vZGVJbmRleFt2LmlkXzBdKSl9ZnVuY3Rpb24gYTZlKGUsbil7dGhpcy5sYXllcmVkR3JhcGg9ZSx0aGlzLm5pPW59cCgxNjk5LDEse30sYTZlKSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2Rlcy5iayIsIkJLQWxpZ25lciIsMTY5OSk7ZnVuY3Rpb24gbDZlKGUsbil7dmFyIHI7cmV0dXJuIHI9YShLZShlLnNpbmtOb2RlcyxuKSw0NjcpLHJ8fChyPW5ldyBkNmUsci5ub2RlPW4sQm4oZS5zaW5rTm9kZXMsci5ub2RlLHIpKSxyfWZ1bmN0aW9uIFlwbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGg7Zm9yKG89bmV3IFQoZS5sYXllcmVkR3JhcGgubGF5ZXJzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHI9YShDKG8pLDMwKSxjPW5ldyBUKHIubm9kZXMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwxMCksbi5zaW5rW3UuaWRfMF09dSxuLnNoaWZ0XzBbdS5pZF8wXT1uLnZkaXI9PShScygpLERzKT9Wcjpocjtmb3IoWmkoZS5zaW5rTm9kZXMpLHM9ZS5sYXllcmVkR3JhcGgubGF5ZXJzLG4uaGRpcj09KHB1KCkscWMpJiYocz1xYShzKSksc2duKGUudGhyZXNoU3RyYXRlZ3ksbixlLm5pKSxMQyhuLnlfMCxudWxsKSxpPXMuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KWZvcihyPWEoaS5uZXh0XzEoKSwzMCksXz1yLm5vZGVzLG4udmRpcj09KFJzKCksRHMpJiYoXz1xYShfKSksaD1fLml0ZXJhdG9yXzAoKTtoLmhhc05leHRfMCgpOylmPWEoaC5uZXh0XzEoKSwxMCksbi5yb290W2YuaWRfMF09PWYmJnM2ZShlLGYsbik7Zm9yKEtwbihlLG4pLHQ9cy5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspZm9yKHI9YSh0Lm5leHRfMSgpLDMwKSxoPW5ldyBUKHIubm9kZXMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmPWEoQyhoKSwxMCksbi55XzBbZi5pZF8wXT1uLnlfMFtuLnJvb3RbZi5pZF8wXS5pZF8wXSxmPT1uLnJvb3RbZi5pZF8wXSYmKGQ9UihuLnNoaWZ0XzBbbi5zaW5rW2YuaWRfMF0uaWRfMF0pLChuLnZkaXI9PShScygpLERzKSYmZD5Wcnx8bi52ZGlyPT1ZXyYmZDxocikmJihuLnlfMFtmLmlkXzBdPVIobi55XzBbZi5pZF8wXSkrZCkpO2UudGhyZXNoU3RyYXRlZ3kucG9zdFByb2Nlc3MoKX1mdW5jdGlvbiBzNmUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2lmKHIueV8wW24uaWRfMF09PW51bGwpe3U9ITAsci55XzBbbi5pZF8wXT0wLHM9bixFPXIudmRpcj09KFJzKCksWV8pP1ZyOmhyO2RvIG89ZS5uaS5ub2RlSW5kZXhbcy5pZF8wXSxpPXMubGF5ZXIubm9kZXMuYXJyYXkubGVuZ3RoLHIudmRpcj09WV8mJm8+MHx8ci52ZGlyPT1EcyYmbzxpLTE/KGM9bnVsbCxfPW51bGwsci52ZGlyPT1Ecz9jPWEobGUocy5sYXllci5ub2RlcyxvKzEpLDEwKTpjPWEobGUocy5sYXllci5ub2RlcyxvLTEpLDEwKSxfPXIucm9vdFtjLmlkXzBdLHM2ZShlLF8sciksRT1lLnRocmVzaFN0cmF0ZWd5LmNhbGN1bGF0ZVRocmVzaG9sZChFLG4scyksci5zaW5rW24uaWRfMF09PW4mJihyLnNpbmtbbi5pZF8wXT1yLnNpbmtbXy5pZF8wXSksci5zaW5rW24uaWRfMF09PXIuc2lua1tfLmlkXzBdPyh5PXNnKGUuc3BhY2luZ3MscyxjKSxyLnZkaXI9PURzPyh0PVIoci55XzBbbi5pZF8wXSksZj1SKHIueV8wW18uaWRfMF0pK1Ioci5pbm5lclNoaWZ0W2MuaWRfMF0pLWMubWFyZ2luLnRvcF8wLXktcy5tYXJnaW4uYm90dG9tLXMuc2l6ZV8wLnlfMC1SKHIuaW5uZXJTaGlmdFtzLmlkXzBdKSx1Pyh1PSExLHIueV8wW24uaWRfMF09Uy5NYXRoLm1pbihmLEUpKTpyLnlfMFtuLmlkXzBdPVMuTWF0aC5taW4odCxTLk1hdGgubWluKGYsRSkpKToodD1SKHIueV8wW24uaWRfMF0pLGY9UihyLnlfMFtfLmlkXzBdKStSKHIuaW5uZXJTaGlmdFtjLmlkXzBdKStjLnNpemVfMC55XzArYy5tYXJnaW4uYm90dG9tK3krcy5tYXJnaW4udG9wXzAtUihyLmlubmVyU2hpZnRbcy5pZF8wXSksdT8odT0hMSxyLnlfMFtuLmlkXzBdPVMuTWF0aC5tYXgoZixFKSk6ci55XzBbbi5pZF8wXT1TLk1hdGgubWF4KHQsUy5NYXRoLm1heChmLEUpKSkpOih5PVIoJCh3KGUubGF5ZXJlZEdyYXBoLChvZSgpLG9kKSkpKSxtPWw2ZShlLHIuc2lua1tuLmlkXzBdKSxkPWw2ZShlLHIuc2lua1tfLmlkXzBdKSxyLnZkaXI9PURzPyhoPVIoci55XzBbbi5pZF8wXSkrUihyLmlubmVyU2hpZnRbcy5pZF8wXSkrcy5zaXplXzAueV8wK3MubWFyZ2luLmJvdHRvbSt5LShSKHIueV8wW18uaWRfMF0pK1Ioci5pbm5lclNoaWZ0W2MuaWRfMF0pLWMubWFyZ2luLnRvcF8wKSxfNmUobSxkLGgpKTooaD1SKHIueV8wW24uaWRfMF0pK1Ioci5pbm5lclNoaWZ0W3MuaWRfMF0pLXMubWFyZ2luLnRvcF8wLVIoci55XzBbXy5pZF8wXSktUihyLmlubmVyU2hpZnRbYy5pZF8wXSktYy5zaXplXzAueV8wLWMubWFyZ2luLmJvdHRvbS15LF82ZShtLGQsaCkpKSk6RT1lLnRocmVzaFN0cmF0ZWd5LmNhbGN1bGF0ZVRocmVzaG9sZChFLG4scykscz1yLmFsaWduXzBbcy5pZF8wXTt3aGlsZShzIT1uKTthZ24oZS50aHJlc2hTdHJhdGVneSxuKX19ZnVuY3Rpb24gS3BuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2ZvcihkPW5ldyBwcix1PShfPW5ldyB0YyhlLnNpbmtOb2RlcykudGhpcyQwMS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyB0ZihfKSk7dS52YWwkb3V0ZXJJdGVyMi5oYXNOZXh0XzAoKTspaT0obz1hKHUudmFsJG91dGVySXRlcjIubmV4dF8xKCksNDQpLGEoby5nZXRWYWx1ZSgpLDQ2NykpLGkuaW5kZWdyZWU9PTAmJmJyKGQsaSxkLnRhaWwucHJldixkLnRhaWwpO2Zvcig7ZC5zaXplXzAhPTA7KWZvcihpPWEoZC5zaXplXzA9PTA/bnVsbDoocm4oZC5zaXplXzAhPTApLFphKGQsZC5oZWFkZXIubmV4dF8wKSksNDY3KSxpLmNsYXNzU2hpZnQ9PW51bGwmJihpLmNsYXNzU2hpZnQ9MCksdD1uZXcgVChpLm91dGdvaW5nKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksNjYzKSxyLnRhcmdldC5jbGFzc1NoaWZ0PT1udWxsP3IudGFyZ2V0LmNsYXNzU2hpZnQ9UihpLmNsYXNzU2hpZnQpK3Iuc2VwYXJhdGlvbjpuLnZkaXI9PShScygpLFlfKT9yLnRhcmdldC5jbGFzc1NoaWZ0PVMuTWF0aC5taW4oUihyLnRhcmdldC5jbGFzc1NoaWZ0KSxSKGkuY2xhc3NTaGlmdCkrci5zZXBhcmF0aW9uKTpyLnRhcmdldC5jbGFzc1NoaWZ0PVMuTWF0aC5tYXgoUihyLnRhcmdldC5jbGFzc1NoaWZ0KSxSKGkuY2xhc3NTaGlmdCkrci5zZXBhcmF0aW9uKSwtLXIudGFyZ2V0LmluZGVncmVlLHIudGFyZ2V0LmluZGVncmVlPT0wJiZMbihkLHIudGFyZ2V0KTtmb3Iocz0oYz1uZXcgdGMoZS5zaW5rTm9kZXMpLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgdGYoYykpO3MudmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KWk9KG89YShzLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKG8uZ2V0VmFsdWUoKSw0NjcpKSxuLnNoaWZ0XzBbaS5ub2RlLmlkXzBdPWkuY2xhc3NTaGlmdH1mdW5jdGlvbiB1NmUoZSxuKXt0aGlzLnNpbmtOb2Rlcz1uZXcgc24sdGhpcy5sYXllcmVkR3JhcGg9ZSx0aGlzLm5pPW4sdGhpcy5zcGFjaW5ncz1hKHcoZSwoSygpLGVnKSksMzEyKSxEKHcoZSwob2UoKSxhWSkpKT09PUQoKGIzKCksb1ApKT90aGlzLnRocmVzaFN0cmF0ZWd5PW5ldyBUNmU6dGhpcy50aHJlc2hTdHJhdGVneT1uZXcgRTZlfXAoMTcwMiwxLHt9LHU2ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMuYmsiLCJCS0NvbXBhY3RvciIsMTcwMik7ZnVuY3Rpb24gYzZlKCl7fXAoNjYzLDEsezY2MzoxfSxjNmUpLGwuc2VwYXJhdGlvbj0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzLmJrIiwiQktDb21wYWN0b3IvQ2xhc3NFZGdlIiw2NjMpO2Z1bmN0aW9uIF82ZShlLG4scil7dmFyIHQ7dD1uZXcgYzZlLHQudGFyZ2V0PW4sdC5zZXBhcmF0aW9uPXIsKytuLmluZGVncmVlLGVlKGUub3V0Z29pbmcsdCl9ZnVuY3Rpb24gZDZlKCl7dGhpcy5vdXRnb2luZz1uZXcgUX1wKDQ2NywxLHs0Njc6MX0sZDZlKSxsLmNsYXNzU2hpZnQ9bnVsbCxsLmluZGVncmVlPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMuYmsiLCJCS0NvbXBhY3Rvci9DbGFzc05vZGUiLDQ2Nyk7ZnVuY3Rpb24gbTcoKXttNz1GLGg2ZT1NbihuZXcgSHIsKHh0KCksaG8pLChrdCgpLFBFKSl9ZnVuY3Rpb24gZjZlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7Zm9yKG89ITAscz1uZXcgVChlLmxheWVycyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoaT1hKEMocyksMzApLF89VnIsZD1udWxsLGM9bmV3IFQoaS5ub2Rlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWlmKHU9YShDKGMpLDEwKSxmPVIobi55XzBbdS5pZF8wXSkrUihuLmlubmVyU2hpZnRbdS5pZF8wXSktdS5tYXJnaW4udG9wXzAsdD1SKG4ueV8wW3UuaWRfMF0pK1Iobi5pbm5lclNoaWZ0W3UuaWRfMF0pK3Uuc2l6ZV8wLnlfMCt1Lm1hcmdpbi5ib3R0b20sZj5fJiZ0Pl8pZD11LF89UihuLnlfMFt1LmlkXzBdKStSKG4uaW5uZXJTaGlmdFt1LmlkXzBdKSt1LnNpemVfMC55XzArdS5tYXJnaW4uYm90dG9tO2Vsc2V7bz0hMSxyLmlzTG9nZ2luZ0VuYWJsZWQoKSYmci5sb2dfMCgiYmsgbm9kZSBwbGFjZW1lbnQgYnJlYWtzIG9uICIrdSsiIHdoaWNoIHNob3VsZCBoYXZlIGJlZW4gYWZ0ZXIgIitkKTticmVha31pZighbylicmVha31yZXR1cm4gci5pc0xvZ2dpbmdFbmFibGVkKCkmJnIubG9nXzAobisiIGlzIGZlYXNpYmxlOiAiK28pLG99ZnVuY3Rpb24gWHBuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlO2ZvcihrPW4uYXJyYXkubGVuZ3RoLG89bmV3IHVnKGUubEdyYXBoLHIsbnVsbCxudWxsKSx2ZT1CKGN0LFh0LDI4LGssMTUsMSksRT1CKGN0LFh0LDI4LGssMTUsMSkseT1CKGN0LFh0LDI4LGssMTUsMSksdj0wLHU9MDt1PGs7dSsrKUVbdV09cW4seVt1XT1idDtmb3IoYz0wO2M8aztjKyspZm9yKHQ9KEFlKGMsbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVtjXSwxODUpKSx2ZVtjXT1oNyh0KSx2ZVt2XT52ZVtjXSYmKHY9YyksZj1uZXcgVChlLmxHcmFwaC5sYXllcnMpO2YuaTxmLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoZD1hKEMoZiksMzApLEE9bmV3IFQoZC5ub2Rlcyk7QS5pPEEudGhpcyQwMS5hcnJheS5sZW5ndGg7KXg9YShDKEEpLDEwKSxxPVIodC55XzBbeC5pZF8wXSkrUih0LmlubmVyU2hpZnRbeC5pZF8wXSksRVtjXT1TLk1hdGgubWluKEVbY10scSkseVtjXT1TLk1hdGgubWF4KHlbY10scSt4LnNpemVfMC55XzApO2ZvcihuZT1CKGN0LFh0LDI4LGssMTUsMSksXz0wO188aztfKyspKEFlKF8sbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVtfXSwxODUpKS52ZGlyPT0oUnMoKSxZXyk/bmVbX109RVt2XS1FW19dOm5lW19dPXlbdl0teVtfXTtmb3IoaT1CKGN0LFh0LDI4LGssMTUsMSksbT1uZXcgVChlLmxHcmFwaC5sYXllcnMpO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaD1hKEMobSksMzApLEg9bmV3IFQoaC5ub2Rlcyk7SC5pPEgudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoTT1hKEMoSCksMTApLHM9MDtzPGs7cysrKWlbc109UigoQWUocyxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W3NdLDE4NSkpLnlfMFtNLmlkXzBdKStSKChBZShzLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbc10sMTg1KSkuaW5uZXJTaGlmdFtNLmlkXzBdKStuZVtzXTttZGUoaSxEaWUoUUkucHJvdG90eXBlLmNvbXBhcmVfMCxRSSxbXSkpLG8ueV8wW00uaWRfMF09KGlbMV0raVsyXSkvMixvLmlubmVyU2hpZnRbTS5pZF8wXT0wfXJldHVybiBvfWZ1bmN0aW9uIEdLKGUsbixyLHQpe3ZhciBvLGkscztpZihuLnR5cGVfMD09KFdlKCksaXQpKXtmb3IoaT1uZXcgWGUoUWUodHQobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylpZihvPWEodG4oaSksMTgpLHM9by5zb3VyY2Uub3duZXIudHlwZV8wLHM9PWl0JiZlLm5pLmxheWVySW5kZXhbby5zb3VyY2Uub3duZXIubGF5ZXIuaWRfMF09PXQmJmUubmkubGF5ZXJJbmRleFtuLmxheWVyLmlkXzBdPT1yKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIEpwbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztpZihFPW4ubGF5ZXJzLmFycmF5Lmxlbmd0aCwhKEU8Mykpe2ZvcihtPUIoaG4sa24sMjgsRSwxNSwxKSxmPTAsZD1uZXcgVChuLmxheWVycyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDMwKSxtW2YrK109Xy5ub2Rlcy5hcnJheS5sZW5ndGg7Zm9yKGg9bmV3IHB0KG4ubGF5ZXJzLDIpLHQ9MTt0PEUtMTt0KyspZm9yKHI9KHJuKGguaTxoLnRoaXMkMDFfMC5zaXplXzEoKSksYShoLnRoaXMkMDFfMC5nZXRfMChoLmxhc3Q9aC5pKyspLDMwKSkseT1uZXcgVChyLm5vZGVzKSxpPTAsdT0wLGM9MDtjPG1bdCsxXTtjKyspaWYoaz1hKEMoeSksMTApLGM9PW1bdCsxXS0xfHxHSyhlLGssdCsxLHQpKXtmb3Iocz1tW3RdLTEsR0soZSxrLHQrMSx0KSYmKHM9ZS5uaS5ub2RlSW5kZXhbYShhKGEobGUoZS5uaS5sZWZ0TmVpZ2hib3JzLGsuaWRfMCksMTUpLmdldF8wKDApLDQyKS5maXJzdCwxMCkuaWRfMF0pO3U8PWM7KXtpZihBPWEobGUoci5ub2Rlcyx1KSwxMCksIUdLKGUsQSx0KzEsdCkpZm9yKHg9YShsZShlLm5pLmxlZnROZWlnaGJvcnMsQS5pZF8wKSwxNSkuaXRlcmF0b3JfMCgpO3guaGFzTmV4dF8wKCk7KXY9YSh4Lm5leHRfMSgpLDQyKSxvPWUubmkubm9kZUluZGV4W2Eodi5maXJzdCwxMCkuaWRfMF0sKG88aXx8bz5zKSYmWXIoZS5tYXJrZWRFZGdlcyxhKHYuc2Vjb25kLDE4KSk7Kyt1fWk9c319fWZ1bmN0aW9uIFpwbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscTtzd2l0Y2goci5iZWdpbigiQnJhbmRlcyAmIEtvZXBmIG5vZGUgcGxhY2VtZW50IiwxKSxlLmxHcmFwaD1uLGUubmk9cmduKG4pLHQ9YSh3KG4sKG9lKCksYk8pKSwyODEpLG09YWUoaWUodyhuLFlFKSkpLGUucHJvZHVjZUJhbGFuY2VkTGF5b3V0PXQ9PShJMygpLGlQKSYmIW18fHQ9PWVPLEpwbihlLG4pLEg9bnVsbCxxPW51bGwseD1udWxsLEE9bnVsbCx2PShQYSg0LCJpbml0aWFsQXJyYXlTaXplIiksbmV3IF9pKDQpKSxhKHcobixiTyksMjgxKS5vcmRpbmFsKXtjYXNlIDM6eD1uZXcgdWcobixlLm5pLm5vZGVDb3VudCwoUnMoKSxZXyksKHB1KCkscWMpKSxSZSh2LmFycmF5LHgpO2JyZWFrO2Nhc2UgMTpBPW5ldyB1ZyhuLGUubmkubm9kZUNvdW50LChScygpLERzKSwocHUoKSxxYykpLFJlKHYuYXJyYXksQSk7YnJlYWs7Y2FzZSA0Okg9bmV3IHVnKG4sZS5uaS5ub2RlQ291bnQsKFJzKCksWV8pLChwdSgpLGxkKSksUmUodi5hcnJheSxIKTticmVhaztjYXNlIDI6cT1uZXcgdWcobixlLm5pLm5vZGVDb3VudCwoUnMoKSxEcyksKHB1KCksbGQpKSxSZSh2LmFycmF5LHEpO2JyZWFrO2RlZmF1bHQ6eD1uZXcgdWcobixlLm5pLm5vZGVDb3VudCwoUnMoKSxZXyksKHB1KCkscWMpKSxBPW5ldyB1ZyhuLGUubmkubm9kZUNvdW50LERzLHFjKSxIPW5ldyB1ZyhuLGUubmkubm9kZUNvdW50LFlfLGxkKSxxPW5ldyB1ZyhuLGUubmkubm9kZUNvdW50LERzLGxkKSxSZSh2LmFycmF5LEgpLFJlKHYuYXJyYXkscSksUmUodi5hcnJheSx4KSxSZSh2LmFycmF5LEEpfWZvcihvPW5ldyBhNmUobixlLm5pKSx1PW5ldyBUKHYpO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyh1KSwxODUpLHFwbihvLGksZS5tYXJrZWRFZGdlcyksVnBuKGkpO2ZvcihoPW5ldyB1NmUobixlLm5pKSxjPW5ldyBUKHYpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhjKSwxODUpLFlwbihoLGkpO2lmKHIuaXNMb2dnaW5nRW5hYmxlZCgpKWZvcihfPW5ldyBUKHYpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhfKSwxODUpLHIubG9nXzAoaSsiIHNpemUgaXMgIitoNyhpKSk7aWYoZj1udWxsLGUucHJvZHVjZUJhbGFuY2VkTGF5b3V0JiYoZD1YcG4oZSx2LGUubmkubm9kZUNvdW50KSxmNmUobixkLHIpJiYoZj1kKSksIWYpZm9yKF89bmV3IFQodik7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKF8pLDE4NSksZjZlKG4saSxyKSYmKCFmfHxoNyhmKT5oNyhpKSkmJihmPWkpO2ZvcighZiYmKGY9KEFlKDAsdi5hcnJheS5sZW5ndGgpLGEodi5hcnJheVswXSwxODUpKSksRT1uZXcgVChuLmxheWVycyk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih5PWEoQyhFKSwzMCksTT1uZXcgVCh5Lm5vZGVzKTtNLmk8TS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaz1hKEMoTSksMTApLGsucG9zLnlfMD1SKGYueV8wW2suaWRfMF0pK1IoZi5pbm5lclNoaWZ0W2suaWRfMF0pO2ZvcihyLmlzTG9nZ2luZ0VuYWJsZWQoKSYmKHIubG9nXzAoIkNob3NlbiBub2RlIHBsYWNlbWVudDogIitmKSxyLmxvZ18wKCJCbG9ja3M6ICIrZzZlKGYpKSxyLmxvZ18wKCJDbGFzc2VzOiAiK1FwbihmLHIpKSxyLmxvZ18wKCJNYXJrZWQgZWRnZXM6ICIrZS5tYXJrZWRFZGdlcykpLHM9bmV3IFQodik7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDE4NSksaS5yb290PW51bGwsaS5ibG9ja1NpemU9bnVsbCxpLmFsaWduXzA9bnVsbCxpLmlubmVyU2hpZnQ9bnVsbCxpLnNpbms9bnVsbCxpLnNoaWZ0XzA9bnVsbCxpLnlfMD1udWxsO25nbihlLm5pKSxlLm1hcmtlZEVkZ2VzLm1hcF8wLmNsZWFyXzAoKSxyLmRvbmVfMSgpfWZ1bmN0aW9uIHA2ZSgpe203KCksdGhpcy5tYXJrZWRFZGdlcz1uZXcgQnJ9ZnVuY3Rpb24gZzZlKGUpe203KCk7dmFyIG4scix0LG8saSxzLHU7Zm9yKHI9bmV3IERjLG89bmV3IFQoZS5sYXllcmVkR3JhcGgubGF5ZXJzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHQ9YShDKG8pLDMwKSxzPW5ldyBUKHQubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMCksdT1lLnJvb3RbaS5pZF8wXSxuPWEoeHMocix1KSwxNSksbnx8KG49bmV3IFEsUmMocix1LG4pKSxuLmFkZF8yKGkpO3JldHVybiByfWZ1bmN0aW9uIFFwbihlLG4pe3ZhciByLHQsbyxpLHMsdTtmb3IodD1uZXcgRGMscz1USShuZXcgZWEoZS5yb290KSksaT1zLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KXtpZihvPWEoaS5uZXh0XzEoKSwxMCksIW8pe24ubG9nXzAoIlRoZXJlIGFyZSBubyBjbGFzc2VzIGluIGEgYmFsYW5jZWQgbGF5b3V0LiIpO2JyZWFrfXU9ZS5zaW5rW28uaWRfMF0scj1hKHhzKHQsdSksMTUpLHJ8fChyPW5ldyBRLFJjKHQsdSxyKSksci5hZGRfMihvKX1yZXR1cm4gdH1mdW5jdGlvbiBlZ24oZSxuKXttNygpO3ZhciByLHQ7Zm9yKHQ9bmV3IFhlKFFlKGljKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspaWYocj1hKHRuKHQpLDE4KSxyLnRhcmdldC5vd25lcj09bnx8ci5zb3VyY2Uub3duZXI9PW4pcmV0dXJuIHI7cmV0dXJuIG51bGx9cCgxNDI3LDEsV3QscDZlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEodyhhKG4sMzYpLChLKCksaWkpKSwyMSkuY29udGFpbnMoKFZ0KCksbmwpKT9oNmU6bnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7WnBuKHRoaXMsYShuLDM2KSxyKX0sbC5wcm9kdWNlQmFsYW5jZWRMYXlvdXQ9ITE7dmFyIGg2ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2Rlcy5iayIsIkJLTm9kZVBsYWNlciIsMTQyNyk7ZnVuY3Rpb24gbmduKGUpe2UubGF5ZXJJbmRleD1udWxsLGUubm9kZUluZGV4PW51bGwsX2YoZS5sZWZ0TmVpZ2hib3JzLmFycmF5LDApLF9mKGUucmlnaHROZWlnaGJvcnMuYXJyYXksMCksZS5uZWlnaGJvckNvbXBhcmF0b3I9bnVsbH1mdW5jdGlvbiBtNmUoKXt9ZnVuY3Rpb24gcmduKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGY9bmV3IG02ZSxmLm5vZGVDb3VudD0wLHM9bmV3IFQoZS5sYXllcnMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwzMCksZi5ub2RlQ291bnQrPWkubm9kZXMuYXJyYXkubGVuZ3RoO2Zvcih0PTAsbz0wLGYubGF5ZXJJbmRleD1CKGhuLGtuLDI4LGUubGF5ZXJzLmFycmF5Lmxlbmd0aCwxNSwxKSxfPTAsZD0wLGYubm9kZUluZGV4PUIoaG4sa24sMjgsZi5ub2RlQ291bnQsMTUsMSkscj1uZXcgVChlLmxheWVycyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihuPWEoQyhyKSwzMCksbi5pZF8wPXQrKyxmLmxheWVySW5kZXhbbi5pZF8wXT1vKyssZD0wLGM9bmV3IFQobi5ub2Rlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDEwKSx1LmlkXzA9XysrLGYubm9kZUluZGV4W3UuaWRfMF09ZCsrO3JldHVybiBmLm5laWdoYm9yQ29tcGFyYXRvcj1uZXcgeTZlKGYpLGYubGVmdE5laWdoYm9ycz1OdShmLm5vZGVDb3VudCksdGduKGYsZSksZi5yaWdodE5laWdoYm9ycz1OdShmLm5vZGVDb3VudCksb2duKGYsZSksZn1mdW5jdGlvbiB0Z24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKHM9bmV3IFQobi5sYXllcnMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaT1hKEMocyksMzApLF89bmV3IFQoaS5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoYz1hKEMoXyksMTApLGQ9bmV3IFEsdT0wLHQ9bmV3IFhlKFFlKHR0KGMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSwhKHp0KHIpfHwhenQocikmJnIuc291cmNlLm93bmVyLmxheWVyPT1yLnRhcmdldC5vd25lci5sYXllcikmJihvPWEodyhyLChvZSgpLFloKSksMTcpLnZhbHVlXzAsbz51JiYodT1vLGQuYXJyYXkubGVuZ3RoPTApLG89PXUmJmVlKGQsbmV3IFpyKHIuc291cmNlLm93bmVyLHIpKSk7TmUoKSxEcihkLGUubmVpZ2hib3JDb21wYXJhdG9yKSxBMShlLmxlZnROZWlnaGJvcnMsYy5pZF8wLGQpfX1mdW5jdGlvbiBvZ24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7Zm9yKHM9bmV3IFQobi5sYXllcnMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaT1hKEMocyksMzApLF89bmV3IFQoaS5ub2Rlcyk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoYz1hKEMoXyksMTApLGQ9bmV3IFEsdT0wLHQ9bmV3IFhlKFFlKFJyKGMpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDE4KSwhKHp0KHIpfHwhenQocikmJnIuc291cmNlLm93bmVyLmxheWVyPT1yLnRhcmdldC5vd25lci5sYXllcikmJihvPWEodyhyLChvZSgpLFloKSksMTcpLnZhbHVlXzAsbz51JiYodT1vLGQuYXJyYXkubGVuZ3RoPTApLG89PXUmJmVlKGQsbmV3IFpyKHIudGFyZ2V0Lm93bmVyLHIpKSk7TmUoKSxEcihkLGUubmVpZ2hib3JDb21wYXJhdG9yKSxBMShlLnJpZ2h0TmVpZ2hib3JzLGMuaWRfMCxkKX19cCgxNzAwLDEse30sbTZlKSxsLm5vZGVDb3VudD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzLmJrIiwiTmVpZ2hib3Job29kSW5mb3JtYXRpb24iLDE3MDApO2Z1bmN0aW9uIGlnbihlLG4scil7dmFyIHQ7cmV0dXJuIHQ9ZS50aGlzJDAxLm5vZGVJbmRleFthKG4uZmlyc3QsMTApLmlkXzBdLWUudGhpcyQwMS5ub2RlSW5kZXhbYShyLmZpcnN0LDEwKS5pZF8wXSxLcihJQyh0KSl9ZnVuY3Rpb24geTZlKGUpe3RoaXMudGhpcyQwMT1lfXAoMTcwMSwxLE5uLHk2ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gaWduKHRoaXMsYShuLDQyKSxhKHIsNDIpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2Rlcy5iayIsIk5laWdoYm9yaG9vZEluZm9ybWF0aW9uL05laWdoYm9yQ29tcGFyYXRvciIsMTcwMSk7ZnVuY3Rpb24gYWduKGUsbil7WXIoZS5ibG9ja0ZpbmlzaGVkLG4pfWZ1bmN0aW9uIGxnbihlLG4pe2lmKGUuc291cmNlLm93bmVyPT1uKXJldHVybiBlLnRhcmdldC5vd25lcjtpZihlLnRhcmdldC5vd25lcj09bilyZXR1cm4gZS5zb3VyY2Uub3duZXI7dGhyb3cgYihuZXcgR2UoIk5vZGUgIituKyIgaXMgbmVpdGhlciBzb3VyY2Ugbm9yIHRhcmdldCBvZiBlZGdlICIrZSkpfWZ1bmN0aW9uIHNnbihlLG4scil7ZS5iYWw9bixlLm5pPXIsZS5ibG9ja0ZpbmlzaGVkLm1hcF8wLmNsZWFyXzAoKSxrYShlLnBvc3RQcm9jZXNzYWJsZXNRdWV1ZSksX2YoZS5wb3N0UHJvY2Vzc2FibGVzU3RhY2suYXJyYXlMaXN0LmFycmF5LDApfWZ1bmN0aW9uIHc2ZSgpe3RoaXMuYmxvY2tGaW5pc2hlZD1uZXcgQnIsdGhpcy5wb3N0UHJvY2Vzc2FibGVzUXVldWU9bmV3IHByLHRoaXMucG9zdFByb2Nlc3NhYmxlc1N0YWNrPW5ldyBQR31wKDgyMywxLHt9KSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2Rlcy5iayIsIlRocmVzaG9sZFN0cmF0ZWd5Iiw4MjMpO2Z1bmN0aW9uIEU2ZSgpe3c2ZS5jYWxsKHRoaXMpfXAoMTgyNSw4MjMse30sRTZlKSxsLmNhbGN1bGF0ZVRocmVzaG9sZD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIHRoaXMuYmFsLnZkaXI9PShScygpLERzKT9ocjpWcn0sbC5wb3N0UHJvY2Vzcz1mdW5jdGlvbigpe30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA0bm9kZXMuYmsiLCJUaHJlc2hvbGRTdHJhdGVneS9OdWxsVGhyZXNob2xkU3RyYXRlZ3kiLDE4MjUpO2Z1bmN0aW9uIHY2ZShlLG4pe3RoaXMuZnJlZT1lLHRoaXMuaXNSb290PW59cCg1ODcsMSx7NTg3OjF9LHY2ZSksbC5oYXNFZGdlcz0hMSxsLmlzUm9vdD0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDRub2Rlcy5iayIsIlRocmVzaG9sZFN0cmF0ZWd5L1Bvc3Rwcm9jZXNzYWJsZSIsNTg3KTtmdW5jdGlvbiB5NyhlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtyZXR1cm4gdD1lLmJhbC52ZGlyPT0oUnMoKSxEcyk/aHI6VnIsdT1TNmUoZSxuZXcgdjZlKG4scikpLCF1LmVkZ2UmJnUuaGFzRWRnZXM/KExuKGUucG9zdFByb2Nlc3NhYmxlc1F1ZXVlLHUpLHQpOnUuZWRnZT8obz11LmVkZ2Uuc291cmNlLGM9dS5lZGdlLnRhcmdldCxyPyhfPWUuYmFsLmhkaXI9PShwdSgpLGxkKT9jOm8saT1lLmJhbC5oZGlyPT1sZD9vOmMscz1lLmJhbC5yb290W2kub3duZXIuaWRfMF0sZD1SKGUuYmFsLnlfMFtzLmlkXzBdKStSKGUuYmFsLmlubmVyU2hpZnRbaS5vd25lci5pZF8wXSkraS5wb3MueV8wK2kuYW5jaG9yLnlfMC1SKGUuYmFsLmlubmVyU2hpZnRbXy5vd25lci5pZF8wXSktXy5wb3MueV8wLV8uYW5jaG9yLnlfMCk6KF89ZS5iYWwuaGRpcj09KHB1KCkscWMpP2M6byxpPWUuYmFsLmhkaXI9PXFjP286YyxkPVIoZS5iYWwueV8wW2UuYmFsLnJvb3RbaS5vd25lci5pZF8wXS5pZF8wXSkrUihlLmJhbC5pbm5lclNoaWZ0W2kub3duZXIuaWRfMF0pK2kucG9zLnlfMCtpLmFuY2hvci55XzAtUihlLmJhbC5pbm5lclNoaWZ0W18ub3duZXIuaWRfMF0pLV8ucG9zLnlfMC1fLmFuY2hvci55XzApLGUuYmFsLnN1W2UuYmFsLnJvb3Rbby5vd25lci5pZF8wXS5pZF8wXT0oemUoKSwhMCksZS5iYWwuc3VbZS5iYWwucm9vdFtjLm93bmVyLmlkXzBdLmlkXzBdPSEwLGQpOnR9ZnVuY3Rpb24gUzZlKGUsbil7dmFyIHIsdCxvLGkscztmb3Iobi5pc1Jvb3Q/bz1lLmJhbC5oZGlyPT0ocHUoKSxsZCk/dHQobi5mcmVlKTpScihuLmZyZWUpOm89ZS5iYWwuaGRpcj09KHB1KCkscWMpP3R0KG4uZnJlZSk6UnIobi5mcmVlKSxpPSExLHQ9bmV3IFhlKFFlKG8udmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylpZihyPWEodG4odCksMTgpLHM9YWUoZS5iYWwub2RbZS5iYWwucm9vdFtuLmZyZWUuaWRfMF0uaWRfMF0pLCEoIXMmJiF6dChyKSYmci5zb3VyY2Uub3duZXIubGF5ZXI9PXIudGFyZ2V0Lm93bmVyLmxheWVyKSYmIShhZShlLmJhbC5zdVtlLmJhbC5yb290W24uZnJlZS5pZF8wXS5pZF8wXSl8fGFlKGUuYmFsLnN1W2UuYmFsLnJvb3Rbbi5mcmVlLmlkXzBdLmlkXzBdKSkmJihpPSEwLHNzKGUuYmxvY2tGaW5pc2hlZCxlLmJhbC5yb290W2xnbihyLG4uZnJlZSkuaWRfMF0pKSlyZXR1cm4gbi5oYXNFZGdlcz0hMCxuLmVkZ2U9cixuO3JldHVybiBuLmhhc0VkZ2VzPWksbi5lZGdlPW51bGwsbn1mdW5jdGlvbiBDNmUoZSxuKXt2YXIgcix0LG8saSxzO3JldHVybiBpPW4uZWRnZSxpLnNvdXJjZS5vd25lcj09bi5mcmVlP3M9aS50YXJnZXQ6cz1pLnNvdXJjZSxpLnNvdXJjZS5vd25lcj09bi5mcmVlP3Q9aS5zb3VyY2U6dD1pLnRhcmdldCxvPUZwbihlLmJhbCxzLHQpLG8+MCYmbzxtcD8ocj16cG4oZS5iYWwsdC5vd25lcixvLGUubmkpLFFMZShlLmJhbCx0Lm93bmVyLC1yKSxyPjApOm88MCYmLW88bXA/KHI9JHBuKGUuYmFsLHQub3duZXIsLW8sZS5uaSksUUxlKGUuYmFsLHQub3duZXIscikscj4wKTohMX1mdW5jdGlvbiBUNmUoKXt3NmUuY2FsbCh0aGlzKX1wKDE4MjYsODIzLHt9LFQ2ZSksbC5jYWxjdWxhdGVUaHJlc2hvbGQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztyZXR1cm4gaT1yPT10LG89dGhpcy5iYWwuYWxpZ25fMFt0LmlkXzBdPT1yLGl8fG8/KHM9bix0aGlzLmJhbC5oZGlyPT0ocHUoKSxsZCk/KGkmJihzPXk3KHRoaXMsciwhMCkpLCFpc05hTihzKSYmIWlzRmluaXRlKHMpJiZvJiYocz15Nyh0aGlzLHQsITEpKSk6KGkmJihzPXk3KHRoaXMsciwhMCkpLCFpc05hTihzKSYmIWlzRmluaXRlKHMpJiZvJiYocz15Nyh0aGlzLHQsITEpKSkscyk6bn0sbC5wb3N0UHJvY2Vzcz1mdW5jdGlvbigpe2Zvcih2YXIgbixyLHQsbyxpO3RoaXMucG9zdFByb2Nlc3NhYmxlc1F1ZXVlLnNpemVfMCE9MDspaT1hKGJRZSh0aGlzLnBvc3RQcm9jZXNzYWJsZXNRdWV1ZSksNTg3KSxvPVM2ZSh0aGlzLGkpLG8uZWRnZSYmKG49by5lZGdlLHQ9YWUodGhpcy5iYWwub2RbdGhpcy5iYWwucm9vdFtpLmZyZWUuaWRfMF0uaWRfMF0pLCEoIXQmJiF6dChuKSYmbi5zb3VyY2Uub3duZXIubGF5ZXI9PW4udGFyZ2V0Lm93bmVyLmxheWVyKSYmKHI9QzZlKHRoaXMsaSkscnx8JFFlKHRoaXMucG9zdFByb2Nlc3NhYmxlc1N0YWNrLGkpKSk7Zm9yKDt0aGlzLnBvc3RQcm9jZXNzYWJsZXNTdGFjay5hcnJheUxpc3QuYXJyYXkubGVuZ3RoIT0wOylDNmUodGhpcyxhKEZfZSh0aGlzLnBvc3RQcm9jZXNzYWJsZXNTdGFjayksNTg3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNG5vZGVzLmJrIiwiVGhyZXNob2xkU3RyYXRlZ3kvU2ltcGxlVGhyZXNob2xkU3RyYXRlZ3kiLDE4MjYpO2Z1bmN0aW9uIGI2ZSgpe2I2ZT1GLHc3PW5ldyBRMihtUil9ZnVuY3Rpb24gSTZlKGUpe3N3aXRjaChlLmVkZ2VSb3V0aW5nU3RyYXRlZ3kub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBuZXcgejZlO2Nhc2UgMzpyZXR1cm4gbmV3IHg1ZTtkZWZhdWx0OnJldHVybiBuZXcgTjZlfX1mdW5jdGlvbiB4NmUoKXt9ZnVuY3Rpb24gdWduKGUpe2I2ZSgpO3ZhciBuO3JldHVybiBGMGUodzcsZSl8fChuPW5ldyB4NmUsbi5lZGdlUm91dGluZ1N0cmF0ZWd5PWUsSkIodzcsZSxuKSksYShadCh3NyxlKSw2NDUpfXAoNjQ1LDEsezY0NToxLDE4ODoxLDE5NjoxfSx4NmUpLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gSTZlKHRoaXMpfSxsLmNyZWF0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIEk2ZSh0aGlzKX07dmFyIHc3O2coIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzIiwiRWRnZVJvdXRlckZhY3RvcnkiLDY0NSk7ZnVuY3Rpb24gUDZlKCl7UDZlPUYsTzZlPU1uKG5ldyBIciwoeHQoKSxyaSksKGt0KCksa2opKSxISz1NbihuZXcgSHIsSm8sYjQpLFI2ZT1XaShNbihuZXcgSHIsSm8sTzQpLGhvLGs0KSxrNmU9V2koTW4oTW4obmV3IEhyLEpvLHhqKSxyaSxQaiksaG8sTmopLEQ2ZT1odShodShMdihXaShNbihuZXcgSHIsamwsRjQpLGhvLEQ0KSxyaSksUjQpLHo0KSxNNmU9V2kobmV3IEhyLGhvLE9qKSxBNmU9V2koTW4oTW4oTW4obmV3IEhyLE91LHg0KSxyaSxONCkscmksenkpLGhvLFA0KSxMNmU9V2koTW4oTW4obmV3IEhyLHJpLHp5KSxyaSxUNCksaG8sQzQpfWZ1bmN0aW9uIGNnbihlKXt2YXIgbixyO3JldHVybiByPWEodyhlLChLKCksaWkpKSwyMSksbj1uZXcgSHIsci5jb250YWlucygoVnQoKSxCRSkpJiYoUmEobixPNmUpLFJhKG4sSEspKSwoci5jb250YWlucyhudyl8fGFlKGllKHcoZSwob2UoKSxUTykpKSkpJiYoUmEobixISyksci5jb250YWlucyhYcCkmJlJhKG4sUjZlKSksci5jb250YWlucyhubCkmJlJhKG4sazZlKSxyLmNvbnRhaW5zKEdFKSYmUmEobixENmUpLHIuY29udGFpbnMobFApJiZSYShuLE02ZSksci5jb250YWlucyhReSkmJlJhKG4sQTZlKSxyLmNvbnRhaW5zKGV3KSYmUmEobixMNmUpLG59ZnVuY3Rpb24gX2duKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O24uYmVnaW4oIk9ydGhvZ29uYWwgZWRnZSByb3V0aW5nIiwxKSxfPVIoJCh3KGUsKG9lKCksb2cpKSkpLHI9UigkKHcoZSxyZykpKSx0PVIoJCh3KGUscV8pKSksaD1uZXcgYjcoMCxyKSx2PTAscz1uZXcgcHQoZS5sYXllcnMsMCksdT1udWxsLGQ9bnVsbCxjPW51bGwsZj1udWxsO2RvIGQ9cy5pPHMudGhpcyQwMV8wLnNpemVfMSgpPyhybihzLmk8cy50aGlzJDAxXzAuc2l6ZV8xKCkpLGEocy50aGlzJDAxXzAuZ2V0XzAocy5sYXN0PXMuaSsrKSwzMCkpOm51bGwsZj1kP2Qubm9kZXM6bnVsbCx1JiYoTlcodSx2KSx2Kz11LnNpemVfMC54XzApLEU9dT92K3Q6dix5PVlLKGgsZSxjLGYsRSksbz0hdXx8cEkoYywoWFAoKSxZMykpLGk9IWR8fHBJKGYsKFhQKCksWTMpKSx5PjA/KG09KHktMSkqcix1JiYobSs9dCksZCYmKG0rPXQpLG08XyYmIW8mJiFpJiYobT1fKSx2Kz1tKTohbyYmIWkmJih2Kz1fKSx1PWQsYz1mO3doaWxlKGQpO2Uuc2l6ZV8wLnhfMD12LG4uZG9uZV8xKCl9ZnVuY3Rpb24gTjZlKCl7UDZlKCl9cCgxNDg1LDEsV3QsTjZlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGNnbihhKG4sMzYpKX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7X2duKGEobiwzNikscil9O3ZhciBBNmUsTDZlLGs2ZSxPNmUsTTZlLEhLLFI2ZSxENmU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMiLCJPcnRob2dvbmFsRWRnZVJvdXRlciIsMTQ4NSk7ZnVuY3Rpb24gWFAoKXtYUD1GLFkzPW5ldyBXNmUsJDZlPU1uKG5ldyBIciwoeHQoKSxKbyksKGt0KCksYjQpKSxINmU9V2koTW4obmV3IEhyLEpvLE80KSxobyxrNCksVTZlPWh1KGh1KEx2KFdpKE1uKG5ldyBIcixqbCxGNCksaG8sRDQpLHJpKSxSNCksejQpLEI2ZT1XaShNbihNbihNbihuZXcgSHIsT3UseDQpLHJpLE40KSxyaSx6eSksaG8sUDQpLEc2ZT1XaShNbihNbihuZXcgSHIscmksenkpLHJpLFQ0KSxobyxDNCl9ZnVuY3Rpb24gZGduKGUsbixyLHQsbyl7dmFyIGksczsoIXp0KG4pJiZuLnNvdXJjZS5vd25lci5sYXllcj09bi50YXJnZXQub3duZXIubGF5ZXJ8fCF4RGUoa28oUChJKG90LDEpLFgsOCwwLFtvLm93bmVyLnBvcyxvLnBvcyxvLmFuY2hvcl0pKSxyKSkmJiF6dChuKSYmKG4uc291cmNlPT1vP1ptKG4uYmVuZFBvaW50cywwLG5ldyBSdChyKSk6TG4obi5iZW5kUG9pbnRzLG5ldyBSdChyKSksdCYmIXNzKGUuY3JlYXRlZEp1bmN0aW9uUG9pbnRzLHIpJiYocz1hKHcobiwob2UoKSxpbykpLDc1KSxzfHwocz1uZXcgamksaihuLGlvLHMpKSxpPW5ldyBSdChyKSxicihzLGkscy50YWlsLnByZXYscy50YWlsKSxZcihlLmNyZWF0ZWRKdW5jdGlvblBvaW50cyxpKSkpfWZ1bmN0aW9uIEY2ZShlKXt2YXIgbixyLHQsbyxpLHMsdTtmb3Iobj0wLHQ9bmV3IFQoZS5ub2Rlcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihyPWEoQyh0KSwxMCksaT1uZXcgWGUoUWUoUnIocikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGkpOylvPWEodG4oaSksMTgpLGU9PW8udGFyZ2V0Lm93bmVyLmxheWVyJiZvLnNvdXJjZS5zaWRlPT0ocmUoKSxqZSkmJihzPUFzKG8uc291cmNlKS55XzAsdT1BcyhvLnRhcmdldCkueV8wLG49Uy5NYXRoLm1heChuLFMuTWF0aC5hYnModS1zKSkpO3JldHVybiBufWZ1bmN0aW9uIGZnbihlKXt2YXIgbixyO3JldHVybiByPWEodyhlLChLKCksaWkpKSwyMSksbj1VTigkNmUpLHIuY29udGFpbnMoKFZ0KCksWHApKSYmUmEobixINmUpLHIuY29udGFpbnMoR0UpJiZSYShuLFU2ZSksci5jb250YWlucyhReSkmJlJhKG4sQjZlKSxyLmNvbnRhaW5zKGV3KSYmUmEobixHNmUpLG59ZnVuY3Rpb24gcGduKGUpe3ZhciBuLHI7aWYoZS50eXBlXzA9PShXZSgpLGl0KSl7Zm9yKHI9bmV3IFhlKFFlKGljKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspaWYobj1hKHRuKHIpLDE4KSwhenQobikmJm4uc291cmNlLm93bmVyLmxheWVyPT1uLnRhcmdldC5vd25lci5sYXllcilyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBnZ24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTTtmb3Ioci5iZWdpbigiUG9seWxpbmUgZWRnZSByb3V0aW5nIiwxKSx2PVIoJCh3KG4sKG9lKCksanEpKSkpLG09UigkKHcobixvZykpKSxvPVIoJCh3KG4scmcpKSksdD1TLk1hdGgubWluKDEsby9tKSxrPTAsYz0wLG4ubGF5ZXJzLmFycmF5Lmxlbmd0aCE9MCYmKE09RjZlKGEobGUobi5sYXllcnMsMCksMzApKSxrPS40KnQqTSksdT1uZXcgcHQobi5sYXllcnMsMCk7dS5pPHUudGhpcyQwMV8wLnNpemVfMSgpOyl7Zm9yKHM9KHJuKHUuaTx1LnRoaXMkMDFfMC5zaXplXzEoKSksYSh1LnRoaXMkMDFfMC5nZXRfMCh1Lmxhc3Q9dS5pKyspLDMwKSksaT1wSShzLFkzKSxpJiZrPjAmJihrLT1tKSxOVyhzLGspLGQ9MCxoPW5ldyBUKHMubm9kZXMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGY9YShDKGgpLDEwKSxfPTAsRT1uZXcgWGUoUWUoUnIoZikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKEUpOyl5PWEodG4oRSksMTgpLHg9QXMoeS5zb3VyY2UpLnlfMCxBPUFzKHkudGFyZ2V0KS55XzAscz09eS50YXJnZXQub3duZXIubGF5ZXImJiF6dCh5KSYmKGhnbih5LGssLjQqdCpTLk1hdGguYWJzKHgtQSkpLHkuc291cmNlLnNpZGU9PShyZSgpLGplKSYmKHg9MCxBPTApKSxfPVMuTWF0aC5tYXgoXyxTLk1hdGguYWJzKEEteCkpO3N3aXRjaChmLnR5cGVfMC5vcmRpbmFsKXtjYXNlIDA6Y2FzZSA0OmNhc2UgMTpjYXNlIDM6Y2FzZSA1Om1nbihlLGYsayx2KX1kPVMuTWF0aC5tYXgoZCxfKX11Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCkmJihNPUY2ZSgocm4odS5pPHUudGhpcyQwMV8wLnNpemVfMSgpKSxhKHUudGhpcyQwMV8wLmdldF8wKHUubGFzdD11LmkrKyksMzApKSksZD1TLk1hdGgubWF4KGQsTSkscm4odS5pPjApLHUudGhpcyQwMS5nZXRfMCh1Lmxhc3Q9LS11LmkpKSxjPS40KnQqZCwhaSYmdS5pPHUudGhpcyQwMV8wLnNpemVfMSgpJiYoYys9bSksays9cy5zaXplXzAueF8wK2N9ZS5jcmVhdGVkSnVuY3Rpb25Qb2ludHMubWFwXzAuY2xlYXJfMCgpLG4uc2l6ZV8wLnhfMD1rLHIuZG9uZV8xKCl9ZnVuY3Rpb24gaGduKGUsbixyKXt2YXIgdCxvLGkscyx1O3M9ZS5zb3VyY2UsdT1lLnRhcmdldCxpPWtvKFAoSShvdCwxKSxYLDgsMCxbcy5vd25lci5wb3Mscy5wb3Mscy5hbmNob3JdKSkueV8wLG89KGkra28oUChJKG90LDEpLFgsOCwwLFt1Lm93bmVyLnBvcyx1LnBvcyx1LmFuY2hvcl0pKS55XzApLzIsdD1udWxsLHMuc2lkZT09KHJlKCkscWUpP3Q9bmV3IFkobitzLm93bmVyLmxheWVyLnNpemVfMC54XzArcixvKTp0PW5ldyBZKG4tcixvKSxabShlLmJlbmRQb2ludHMsMCx0KX1mdW5jdGlvbiBtZ24oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3IoZD1yK24ubGF5ZXIuc2l6ZV8wLnhfMCxtPW5ldyBUKG4ucG9ydHMpO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoaD1hKEMobSksMTIpLG89a28oUChJKG90LDEpLFgsOCwwLFtoLm93bmVyLnBvcyxoLnBvcyxoLmFuY2hvcl0pKSxuLnR5cGVfMD09KFdlKCksdGkpJiYodT1hKHcoaCwoSygpLFFuKSksMTIpLG8ueF8wPWtvKFAoSShvdCwxKSxYLDgsMCxbdS5vd25lci5wb3MsdS5wb3MsdS5hbmNob3JdKSkueF8wLG4ucG9zLnhfMD1vLnhfMCkscz1uZXcgWSgwLG8ueV8wKSxoLnNpZGU9PShyZSgpLHFlKSlzLnhfMD1kO2Vsc2UgaWYoaC5zaWRlPT1qZSlzLnhfMD1yO2Vsc2UgY29udGludWU7aWYoeT1TLk1hdGguYWJzKG8ueF8wLXMueF8wKSwhKHk8PXQmJiFwZ24obikpKWZvcihpPWgub3V0Z29pbmdFZGdlcy5hcnJheS5sZW5ndGgraC5pbmNvbWluZ0VkZ2VzLmFycmF5Lmxlbmd0aD4xLF89bmV3IExzKGguY29ubmVjdGVkRWRnZXMpO3hvKF8uZmlyc3RJdGVyYXRvcil8fHhvKF8uc2Vjb25kSXRlcmF0b3IpOyljPWEoeG8oXy5maXJzdEl0ZXJhdG9yKT9DKF8uZmlyc3RJdGVyYXRvcik6QyhfLnNlY29uZEl0ZXJhdG9yKSwxOCksZj1jLnNvdXJjZT09aD9jLnRhcmdldDpjLnNvdXJjZSxTLk1hdGguYWJzKGtvKFAoSShvdCwxKSxYLDgsMCxbZi5vd25lci5wb3MsZi5wb3MsZi5hbmNob3JdKSkueV8wLXMueV8wKT4xJiZkZ24oZSxjLHMsaSxoKX19ZnVuY3Rpb24gejZlKCl7WFAoKSx0aGlzLmNyZWF0ZWRKdW5jdGlvblBvaW50cz1uZXcgQnJ9cCgxNDc4LDEsV3QsejZlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGZnbihhKG4sMzYpKX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7Z2duKHRoaXMsYShuLDM2KSxyKX07dmFyICQ2ZSxCNmUsRzZlLEg2ZSxZMyxVNmU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMiLCJQb2x5bGluZUVkZ2VSb3V0ZXIiLDE0NzgpO2Z1bmN0aW9uIFVLKGUpe3ZhciBuO3JldHVybiBuPWEodyhlLChLKCksRG8pKSw2NCksZS50eXBlXzA9PShXZSgpLEZyKSYmKG49PShyZSgpLGplKXx8bj09cWUpfWZ1bmN0aW9uIFc2ZSgpe31wKDE0NzksMSxKcyxXNmUpLGwuYXBwbHlfMT1mdW5jdGlvbihuKXtyZXR1cm4gVUsoYShuLDEwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gVUsoYShuLDEwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzIiwiUG9seWxpbmVFZGdlUm91dGVyLzEiLDE0NzkpO2Z1bmN0aW9uIHlnbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztmb3Ioaz1Lc2UoZSksYz1uZXcgUSxpPWUuYXJyYXkubGVuZ3RoLF89aS0xLGQ9aSsxO2subWFwXzAuc2l6ZV8xKCkhPTA7KXtmb3IoO3Iuc2l6ZV8wIT0wOyl4PShybihyLnNpemVfMCE9MCksYShaYShyLHIuaGVhZGVyLm5leHRfMCksMTE4KSksay5tYXBfMC5yZW1vdmVfMCh4KSE9bnVsbCx4Lm1hcms9Xy0tLFdLKHgsbixyLHQpO2Zvcig7bi5zaXplXzAhPTA7KUE9KHJuKG4uc2l6ZV8wIT0wKSxhKFphKG4sbi5oZWFkZXIubmV4dF8wKSwxMTgpKSxrLm1hcF8wLnJlbW92ZV8wKEEpIT1udWxsLEEubWFyaz1kKyssV0soQSxuLHIsdCk7Zm9yKHU9YnQsRT1rLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO0UuaGFzTmV4dF8wKCk7KXtpZih5PWEoRS5uZXh0XzEoKSwxMTgpLCF0JiZ5LmNyaXRpY2FsT3V0RGVwV2VpZ2h0PjAmJnkuY3JpdGljYWxJbkRlcFdlaWdodDw9MCl7Yy5hcnJheS5sZW5ndGg9MCxSZShjLmFycmF5LHkpO2JyZWFrfW09eS5vdXREZXBXZWlnaHQteS5pbkRlcFdlaWdodCxtPj11JiYobT51JiYoYy5hcnJheS5sZW5ndGg9MCx1PW0pLFJlKGMuYXJyYXkseSkpfWMuYXJyYXkubGVuZ3RoIT0wJiYocz1hKGxlKGMsaXgobyxjLmFycmF5Lmxlbmd0aCkpLDExOCksay5tYXBfMC5yZW1vdmVfMChzKSE9bnVsbCxzLm1hcms9ZCsrLFdLKHMsbixyLHQpLGMuYXJyYXkubGVuZ3RoPTApfWZvcih2PWUuYXJyYXkubGVuZ3RoKzEsaD1uZXcgVChlKTtoLmk8aC50aGlzJDAxLmFycmF5Lmxlbmd0aDspZj1hKEMoaCksMTE4KSxmLm1hcms8aSYmKGYubWFyaz1mLm1hcmsrdil9ZnVuY3Rpb24gajZlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXztmb3IoaT1uZXcgUSxfPW5ldyBwcixzPW5ldyBwcix3Z24oZSxfLHMsbikseWduKGUsXyxzLG4sciksYz1uZXcgVChlKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspZm9yKHU9YShDKGMpLDExOCksbz1uZXcgVCh1Lm91dGdvaW5nU2VnbWVudERlcGVuZGVuY2llcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDEzMiksKCFufHx0LnR5cGVfMD09KGZzKCksJDApKSYmdS5tYXJrPnQudGFyZ2V0Lm1hcmsmJlJlKGkuYXJyYXksdCk7cmV0dXJuIGl9ZnVuY3Rpb24gd2duKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkO2Zvcih1PS0xLGQ9bmV3IFQoZSk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDExOCksXy5tYXJrPXUtLSxvPVNuKHl4KHd4KEpuKG5ldyBTZShudWxsLG5ldyB4ZShfLmluY29taW5nU2VnbWVudERlcGVuZGVuY2llcywxNikpLG5ldyBWNmUpLG5ldyBxNmUpKS5zdW0pLGk9U24oeXgod3goSm4obmV3IFNlKG51bGwsbmV3IHhlKF8ub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzLDE2KSksbmV3IFk2ZSksbmV3IEs2ZSkpLnN1bSkscz1vLGM9aSx0fHwocz1Tbih5eCh3eChuZXcgU2UobnVsbCxuZXcgeGUoXy5pbmNvbWluZ1NlZ21lbnREZXBlbmRlbmNpZXMsMTYpKSxuZXcgWDZlKSkuc3VtKSxjPVNuKHl4KHd4KG5ldyBTZShudWxsLG5ldyB4ZShfLm91dGdvaW5nU2VnbWVudERlcGVuZGVuY2llcywxNikpLG5ldyBKNmUpKS5zdW0pKSxfLmluRGVwV2VpZ2h0PXMsXy5jcml0aWNhbEluRGVwV2VpZ2h0PW8sXy5vdXREZXBXZWlnaHQ9YyxfLmNyaXRpY2FsT3V0RGVwV2VpZ2h0PWksYz09MD9icihyLF8sci50YWlsLnByZXYsci50YWlsKTpzPT0wJiZicihuLF8sbi50YWlsLnByZXYsbi50YWlsKX1mdW5jdGlvbiBXSyhlLG4scix0KXt2YXIgbyxpLHMsdSxjO2ZvcihzPW5ldyBUKGUub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMocyksMTMyKSwoIXR8fG8udHlwZV8wPT0oZnMoKSwkMCkpJiYoYz1vLnRhcmdldCxjLm1hcms8MCYmby53ZWlnaHQ+MCYmKEU3KGMsYy5pbkRlcFdlaWdodC1vLndlaWdodCksby50eXBlXzA9PShmcygpLCQwKSYmdmduKGMsYy5jcml0aWNhbEluRGVwV2VpZ2h0LW8ud2VpZ2h0KSxjLmluRGVwV2VpZ2h0PD0wJiZjLm91dERlcFdlaWdodD4wJiZicihuLGMsbi50YWlsLnByZXYsbi50YWlsKSkpO2ZvcihpPW5ldyBUKGUuaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTMyKSwoIXR8fG8udHlwZV8wPT0oZnMoKSwkMCkpJiYodT1vLnNvdXJjZSx1Lm1hcms8MCYmby53ZWlnaHQ+MCYmKFpQKHUsdS5vdXREZXBXZWlnaHQtby53ZWlnaHQpLG8udHlwZV8wPT0oZnMoKSwkMCkmJlNnbih1LHUuY3JpdGljYWxPdXREZXBXZWlnaHQtby53ZWlnaHQpLHUub3V0RGVwV2VpZ2h0PD0wJiZ1LmluRGVwV2VpZ2h0PjAmJmJyKHIsdSxyLnRhaWwucHJldixyLnRhaWwpKSl9ZnVuY3Rpb24gVjZlKCl7fXAoMTg3MiwxLEluLFY2ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMzIpLnR5cGVfMD09KGZzKCksJDApfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5vcnRob2dvbmFsIiwiSHlwZXJFZGdlQ3ljbGVEZXRlY3Rvci9sYW1iZGEkMCRUeXBlIiwxODcyKTtmdW5jdGlvbiBxNmUoKXt9cCgxODczLDEse30scTZlKSxsLmFwcGx5QXNJbnQ9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMzIpLndlaWdodH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZUN5Y2xlRGV0ZWN0b3IvbGFtYmRhJDEkVHlwZSIsMTg3Myk7ZnVuY3Rpb24gWTZlKCl7fXAoMTg3NCwxLEluLFk2ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMzIpLnR5cGVfMD09KGZzKCksJDApfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5vcnRob2dvbmFsIiwiSHlwZXJFZGdlQ3ljbGVEZXRlY3Rvci9sYW1iZGEkMiRUeXBlIiwxODc0KTtmdW5jdGlvbiBLNmUoKXt9cCgxODc1LDEse30sSzZlKSxsLmFwcGx5QXNJbnQ9ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMzIpLndlaWdodH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZUN5Y2xlRGV0ZWN0b3IvbGFtYmRhJDMkVHlwZSIsMTg3NSk7ZnVuY3Rpb24gWDZlKCl7fXAoMTg3NiwxLHt9LFg2ZSksbC5hcHBseUFzSW50PWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMTMyKS53ZWlnaHR9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJIeXBlckVkZ2VDeWNsZURldGVjdG9yL2xhbWJkYSQ0JFR5cGUiLDE4NzYpO2Z1bmN0aW9uIEo2ZSgpe31wKDE4NzcsMSx7fSxKNmUpLGwuYXBwbHlBc0ludD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEzMikud2VpZ2h0fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5vcnRob2dvbmFsIiwiSHlwZXJFZGdlQ3ljbGVEZXRlY3Rvci9sYW1iZGEkNSRUeXBlIiwxODc3KTtmdW5jdGlvbiBaNmUoZSxuLHIpe3ZhciB0LG8saTtmb3Ioci5wdXQobixlKSxlZShlLnBvcnRzLG4pLGk9ZS5yb3V0aW5nU3RyYXRlZ3kuZ2V0UG9ydFBvc2l0aW9uT25IeXBlck5vZGUobiksbi5zaWRlPT1lLnJvdXRpbmdTdHJhdGVneS5nZXRTb3VyY2VQb3J0U2lkZSgpP2U1ZShlLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLGkpOmU1ZShlLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLGkpLEpQKGUpLG89UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsW25ldyBEeShuKSxuZXcgTWgobildKSkpO19uKG8pOyl0PWEodG4obyksMTIpLHIuY29udGFpbnNLZXkodCl8fFo2ZShlLHQscil9ZnVuY3Rpb24gRWduKGUsbil7cmV0dXJuIGUubWFyay1uLm1hcmt9ZnVuY3Rpb24gSlAoZSl7ZS5zdGFydFBvc2l0aW9uPU5hTixlLmVuZFBvc2l0aW9uPU5hTixRNmUoZSxlLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSxRNmUoZSxlLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKX1mdW5jdGlvbiBRNmUoZSxuKXtuLnNpemVfMCE9MCYmKGlzTmFOKGUuc3RhcnRQb3NpdGlvbik/ZS5zdGFydFBvc2l0aW9uPVIoKHJuKG4uc2l6ZV8wIT0wKSwkKG4uaGVhZGVyLm5leHRfMC52YWx1ZV8wKSkpOmUuc3RhcnRQb3NpdGlvbj1TLk1hdGgubWluKGUuc3RhcnRQb3NpdGlvbixSKChybihuLnNpemVfMCE9MCksJChuLmhlYWRlci5uZXh0XzAudmFsdWVfMCkpKSksaXNOYU4oZS5lbmRQb3NpdGlvbik/ZS5lbmRQb3NpdGlvbj1SKChybihuLnNpemVfMCE9MCksJChuLnRhaWwucHJldi52YWx1ZV8wKSkpOmUuZW5kUG9zaXRpb249Uy5NYXRoLm1heChlLmVuZFBvc2l0aW9uLFIoKHJuKG4uc2l6ZV8wIT0wKSwkKG4udGFpbC5wcmV2LnZhbHVlXzApKSkpKX1mdW5jdGlvbiB2Z24oZSxuKXtlLmNyaXRpY2FsSW5EZXBXZWlnaHQ9bn1mdW5jdGlvbiBTZ24oZSxuKXtlLmNyaXRpY2FsT3V0RGVwV2VpZ2h0PW59ZnVuY3Rpb24gRTcoZSxuKXtlLmluRGVwV2VpZ2h0PW59ZnVuY3Rpb24gWlAoZSxuKXtlLm91dERlcFdlaWdodD1ufWZ1bmN0aW9uIGpLKGUsbil7ZS5yb3V0aW5nU2xvdD1ufWZ1bmN0aW9uIENnbihlLG4pe2Uuc3BsaXRQYXJ0bmVyPW59ZnVuY3Rpb24gVGduKGUsbil7Zm9yKGUuc3BsaXRQYXJ0bmVyPW5ldyBLMyhlLnJvdXRpbmdTdHJhdGVneSksQ2duKGUuc3BsaXRQYXJ0bmVyLGUpLGZ0KGUuc3BsaXRQYXJ0bmVyLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLGUub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMpLGthKGUub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMpLExuKGUub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsbiksTG4oZS5zcGxpdFBhcnRuZXIuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsbiksSlAoZSksSlAoZS5zcGxpdFBhcnRuZXIpO2UuaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzLmFycmF5Lmxlbmd0aCE9MDspbjVlKGEobGUoZS5pbmNvbWluZ1NlZ21lbnREZXBlbmRlbmNpZXMsMCksMTMyKSk7Zm9yKDtlLm91dGdvaW5nU2VnbWVudERlcGVuZGVuY2llcy5hcnJheS5sZW5ndGghPTA7KW41ZShhKGxlKGUub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzLDApLDEzMikpO3JldHVybiBlLnNwbGl0UGFydG5lcn1mdW5jdGlvbiBLMyhlKXt0aGlzLnBvcnRzPW5ldyBRLHRoaXMuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXM9bmV3IHByLHRoaXMub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXM9bmV3IHByLHRoaXMub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzPW5ldyBRLHRoaXMuaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzPW5ldyBRLHRoaXMucm91dGluZ1N0cmF0ZWd5PWV9ZnVuY3Rpb24gZTVlKGUsbil7dmFyIHIsdDtmb3Iocj1kbihlLDApO3IuY3VycmVudE5vZGUhPXIudGhpcyQwMS50YWlsOyl7aWYodD1TQygkKHVuKHIpKSksdD09bilyZXR1cm47aWYodD5uKXtkX2Uocik7YnJlYWt9fVJDKHIsbil9cCgxMTgsMSx7MzQ6MSwxMTg6MX0sSzMpLGwuY29tcGFyZVRvXzA9ZnVuY3Rpb24obil7cmV0dXJuIEVnbih0aGlzLGEobiwxMTgpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gTChuLDExOCk/KHI9YShuLDExOCksdGhpcy5tYXJrPT1yLm1hcmspOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXJrfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbztmb3Iobj1uZXcgTGEoInsiKSxvPW5ldyBUKHRoaXMucG9ydHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMikscj1fMyh0Lm93bmVyKSxyPT1udWxsJiYocj0ibiIrUXdlKHQub3duZXIpKSxuLnN0cmluZys9IiIrcixvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aCYmKG4uc3RyaW5nKz0iLCIpO3JldHVybiBuLnN0cmluZys9In0iLG4uc3RyaW5nfSxsLmNyaXRpY2FsSW5EZXBXZWlnaHQ9MCxsLmNyaXRpY2FsT3V0RGVwV2VpZ2h0PTAsbC5lbmRQb3NpdGlvbj1OYU4sbC5pbkRlcFdlaWdodD0wLGwubWFyaz0wLGwub3V0RGVwV2VpZ2h0PTAsbC5yb3V0aW5nU2xvdD0wLGwuc3RhcnRQb3NpdGlvbj1OYU4sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnQiLDExOCk7ZnVuY3Rpb24gbjVlKGUpe3Y3KGUsbnVsbCksUzcoZSxudWxsKX1mdW5jdGlvbiB2NyhlLG4pe2Uuc291cmNlJiZQaShlLnNvdXJjZS5vdXRnb2luZ1NlZ21lbnREZXBlbmRlbmNpZXMsZSksZS5zb3VyY2U9bixlLnNvdXJjZSYmZWUoZS5zb3VyY2Uub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzLGUpfWZ1bmN0aW9uIFM3KGUsbil7ZS50YXJnZXQmJlBpKGUudGFyZ2V0LmluY29taW5nU2VnbWVudERlcGVuZGVuY2llcyxlKSxlLnRhcmdldD1uLGUudGFyZ2V0JiZlZShlLnRhcmdldC5pbmNvbWluZ1NlZ21lbnREZXBlbmRlbmNpZXMsZSl9ZnVuY3Rpb24gS18oZSxuLHIsdCl7dGhpcy50eXBlXzA9ZSx0aGlzLndlaWdodD10LHY3KHRoaXMsbiksUzcodGhpcyxyKX1wKDEzMiwxLHsxMzI6MX0sS18pLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNvdXJjZSsiLT4iK3RoaXMudGFyZ2V0KyIgKCIrcUtlKHRoaXMudHlwZV8wKSsiKSJ9LGwud2VpZ2h0PTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnREZXBlbmRlbmN5IiwxMzIpO2Z1bmN0aW9uIGZzKCl7ZnM9RixCZj1uZXcgVksoIlJFR1VMQVIiLDApLCQwPW5ldyBWSygiQ1JJVElDQUwiLDEpfWZ1bmN0aW9uIFZLKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gYmduKGUpe3JldHVybiBmcygpLHduKCh0NWUoKSxvNWUpLGUpfWZ1bmN0aW9uIElnbigpe3JldHVybiBmcygpLFAoSShyNWUsMSksVyw1MjgsMCxbQmYsJDBdKX1wKDUyOCwyMix7MzoxLDM0OjEsMjI6MSw1Mjg6MX0sVkspO3ZhciAkMCxCZixyNWU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJIeXBlckVkZ2VTZWdtZW50RGVwZW5kZW5jeS9EZXBlbmRlbmN5VHlwZSIsNTI4LGduLElnbixiZ24pO2Z1bmN0aW9uIHQ1ZSgpe3Q1ZT1GLG81ZT15bigoZnMoKSxQKEkocjVlLDEpLFcsNTI4LDAsW0JmLCQwXSkpKX12YXIgbzVlO2Z1bmN0aW9uIHhnbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKGk9cixyPHQpZm9yKGg9KG09bmV3IEszKGUucm91dGluZ1N0cmF0ZWd5KSx5PW5ldyBLMyhlLnJvdXRpbmdTdHJhdGVneSksZnQobS5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyxlLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSxtLnNwbGl0Qnk9ZS5zcGxpdEJ5LG0uc3BsaXRQYXJ0bmVyPXksSlAobSksZnQoeS5vdXRnb2luZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyxlLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSx5LnNwbGl0UGFydG5lcj1tLEpQKHkpLG5ldyBacihtLHkpKSxmPWEoaC5maXJzdCwxMTgpLGQ9YShoLnNlY29uZCwxMTgpLG89KEFlKGksbi5hcnJheS5sZW5ndGgpLGEobi5hcnJheVtpXSwzMzkpKSxzPWE1ZShlLGYsZCxvKSxfPXIrMTtfPD10O18rKyl1PShBZShfLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbX10sMzM5KSksYz1hNWUoZSxmLGQsdSksTGduKHUsYyxvLHMpJiYobz11LHM9YyxpPV8pO3JldHVybiBpfWZ1bmN0aW9uIFBnbihlLG4scil7dmFyIHQsbyxpLHMsdSxjO2ZvcihpPS0xLHU9LTEscz0wO3M8bi5hcnJheS5sZW5ndGgmJihvPShBZShzLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbc10sMzM5KSksIShvLnN0YXJ0UG9zaXRpb24+ZS5lbmRQb3NpdGlvbikpO3MrKylvLmVuZFBvc2l0aW9uPj1lLnN0YXJ0UG9zaXRpb24mJihpPDAmJihpPXMpLHU9cyk7cmV0dXJuIGM9KGUuc3RhcnRQb3NpdGlvbitlLmVuZFBvc2l0aW9uKS8yLGk+PTAmJih0PXhnbihlLG4saSx1KSxjPURnbigoQWUodCxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5W3RdLDMzOSkpKSxSZ24obix0LHIpKSxjfWZ1bmN0aW9uIGk1ZShlLG4pe3JldHVybiBjZyhlLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLG4uc3RhcnRQb3NpdGlvbixuLmVuZFBvc2l0aW9uKStjZyhuLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLGUuc3RhcnRQb3NpdGlvbixlLmVuZFBvc2l0aW9uKX1mdW5jdGlvbiBOZ24oZSl7dmFyIG4scix0LG8saSxzLHU7Zm9yKGk9bmV3IGx1LHI9bmV3IFQoZSk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDEzMikscz1uLnNvdXJjZSx1PW4udGFyZ2V0LCEoaS5tYXBfMC5jb250YWluc0tleShzKXx8aS5tYXBfMC5jb250YWluc0tleSh1KSkmJihvPXMsdD11LHMuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wK3Mub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wPjImJnUuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wK3Uub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wPD0yJiYobz11LHQ9cyksaS5tYXBfMC5wdXQobyxpKSxvLnNwbGl0Qnk9dCk7cmV0dXJuIGl9ZnVuY3Rpb24gQWduKGUsbil7dmFyIHIsdCxvLGkscztmb3Iocj1uZXcgUSxvPU5vKG5ldyBTZShudWxsLG5ldyB4ZShlLDE2KSksbmV3IF81ZSksaT1ObyhuZXcgU2UobnVsbCxuZXcgeGUoZSwxNikpLG5ldyBkNWUpLHM9d2VuKHllbih1Zih3WGUoUChJKHhlbiwxKSxNZSw4NDgsMCxbbyxpXSkpLG5ldyBmNWUpKSksdD0xO3Q8cy5sZW5ndGg7dCsrKXNbdF0tc1t0LTFdPj0yKm4mJmVlKHIsbmV3IFQ3KHNbdC0xXStuLHNbdF0tbikpO3JldHVybiByfWZ1bmN0aW9uIExnbihlLG4scix0KXtpZihuLmNyb3NzaW5nczx0LmNyb3NzaW5ncylyZXR1cm4hMDtpZihuLmNyb3NzaW5ncz09dC5jcm9zc2luZ3Mpe2lmKG4uZGVwZW5kZW5jaWVzPHQuZGVwZW5kZW5jaWVzKXJldHVybiEwO2lmKG4uZGVwZW5kZW5jaWVzPT10LmRlcGVuZGVuY2llcyYmZS5zaXplXzA+ci5zaXplXzApcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24ga2duKGUsbixyLHQsbyl7dmFyIGk7aT1QZ24obyxyLHQpLGVlKG4sVGduKG8saSkpLE1nbihlLG8sbil9ZnVuY3Rpb24gYTVlKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXztmb3Iobz0odC5zdGFydFBvc2l0aW9uK3QuZW5kUG9zaXRpb24pLzIsa2Eobi5vdXRnb2luZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyksTG4obi5vdXRnb2luZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyxvKSxrYShyLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSxMbihyLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLG8pLF89bmV3IHM1ZSx1PW5ldyBUKGUuaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEModSksMTMyKSxjPWkuc291cmNlLEM3KF8sbixjKSxDNyhfLHIsYyk7Zm9yKHM9bmV3IFQoZS5vdXRnb2luZ1NlZ21lbnREZXBlbmRlbmNpZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxMzIpLGM9aS50YXJnZXQsQzcoXyxuLGMpLEM3KF8scixjKTtyZXR1cm4gXy5kZXBlbmRlbmNpZXMrPTIsXy5jcm9zc2luZ3MrPWk1ZShuLGUuc3BsaXRCeSksXy5jcm9zc2luZ3MrPWk1ZShlLnNwbGl0QnksciksX31mdW5jdGlvbiBPZ24oZSxuLHIsdCl7dmFyIG8saTtuLmFycmF5Lmxlbmd0aCE9MCYmKG89QWduKHIsdCksaT1OZ24obiksTHIoRXgobmV3IFNlKG51bGwsbmV3IHhlKGksMSkpLG5ldyB1NWUpLG5ldyBjNWUoZSxyLG8sdCkpKX1mdW5jdGlvbiBDNyhlLG4scil7dmFyIHQsbzt0PWNnKG4ub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsci5zdGFydFBvc2l0aW9uLHIuZW5kUG9zaXRpb24pK2NnKHIuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsbi5zdGFydFBvc2l0aW9uLG4uZW5kUG9zaXRpb24pLG89Y2coci5vdXRnb2luZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyxuLnN0YXJ0UG9zaXRpb24sbi5lbmRQb3NpdGlvbikrY2cobi5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyxyLnN0YXJ0UG9zaXRpb24sci5lbmRQb3NpdGlvbiksdD09bz90PjAmJihlLmRlcGVuZGVuY2llcys9MixlLmNyb3NzaW5ncys9dCk6KGUuZGVwZW5kZW5jaWVzKz0xLGUuY3Jvc3NpbmdzKz1TLk1hdGgubWluKHQsbykpfWZ1bmN0aW9uIE1nbihlLG4scil7dmFyIHQsbyxpLHM7Zm9yKGk9bi5zcGxpdEJ5LHM9bi5zcGxpdFBhcnRuZXIsbmV3IEtfKChmcygpLCQwKSxuLGksMSksbmV3IEtfKCQwLGkscywxKSxvPW5ldyBUKHIpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMTgpLHQhPWkmJnQhPW4mJnQhPXMmJihxSyhlLnJvdXRpbmdHZW5lcmF0b3IsdCxuKSxxSyhlLnJvdXRpbmdHZW5lcmF0b3IsdCxzKSl9ZnVuY3Rpb24gUmduKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXztjPShBZShuLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbbl0sMzM5KSksTWMoZSxuKSxjLnNpemVfMC8yPj1yJiYodD1uLF89KGMuc3RhcnRQb3NpdGlvbitjLmVuZFBvc2l0aW9uKS8yLHM9Xy1yLGMuc3RhcnRQb3NpdGlvbjw9Xy1yJiYobz1uZXcgVDcoYy5zdGFydFBvc2l0aW9uLHMpLEExKGUsdCsrLG8pKSx1PV8rcix1PD1jLmVuZFBvc2l0aW9uJiYoaT1uZXcgVDcodSxjLmVuZFBvc2l0aW9uKSxkZih0LGUuYXJyYXkubGVuZ3RoKSxvRShlLmFycmF5LHQsaSkpKX1mdW5jdGlvbiBsNWUoZSl7dGhpcy5yb3V0aW5nR2VuZXJhdG9yPWV9ZnVuY3Rpb24gRGduKGUpe3JldHVybihlLnN0YXJ0UG9zaXRpb24rZS5lbmRQb3NpdGlvbikvMn1mdW5jdGlvbiBGZ24oZSxuKXtyZXR1cm4gaXIoZS5lbmRQb3NpdGlvbi1lLnN0YXJ0UG9zaXRpb24sbi5lbmRQb3NpdGlvbi1uLnN0YXJ0UG9zaXRpb24pfXAoMTg3OCwxLHt9LGw1ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnRTcGxpdHRlciIsMTg3OCk7ZnVuY3Rpb24gczVlKCl7dGhpcy5kZXBlbmRlbmNpZXM9MCx0aGlzLmNyb3NzaW5ncz0wfXAoMTg3OSwxLHt9LHM1ZSksbC5jcm9zc2luZ3M9MCxsLmRlcGVuZGVuY2llcz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJIeXBlckVkZ2VTZWdtZW50U3BsaXR0ZXIvQXJlYVJhdGluZyIsMTg3OSk7ZnVuY3Rpb24gVDcoZSxuKXt0aGlzLnN0YXJ0UG9zaXRpb249ZSx0aGlzLmVuZFBvc2l0aW9uPW4sdGhpcy5zaXplXzA9bi1lfXAoMzM5LDEsezMzOToxfSxUNyksbC5lbmRQb3NpdGlvbj0wLGwuc2l6ZV8wPTAsbC5zdGFydFBvc2l0aW9uPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnRTcGxpdHRlci9GcmVlQXJlYSIsMzM5KTtmdW5jdGlvbiB1NWUoKXt9cCgxODgwLDEsTm4sdTVlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBGZ24oYShuLDExOCksYShyLDExOCkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJIeXBlckVkZ2VTZWdtZW50U3BsaXR0ZXIvbGFtYmRhJDAkVHlwZSIsMTg4MCk7ZnVuY3Rpb24gYzVlKGUsbixyLHQpe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5zZWdtZW50c18xPW4sdGhpcy5mcmVlQXJlYXNfMj1yLHRoaXMuY3JpdGljYWxDb25mbGljdFRocmVzaG9sZF8zPXR9cCgxODgxLDEsSmUsYzVlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtrZ24odGhpcy4kJG91dGVyXzAsdGhpcy5zZWdtZW50c18xLHRoaXMuZnJlZUFyZWFzXzIsdGhpcy5jcml0aWNhbENvbmZsaWN0VGhyZXNob2xkXzMsYShuLDExOCkpfSxsLmNyaXRpY2FsQ29uZmxpY3RUaHJlc2hvbGRfMz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJIeXBlckVkZ2VTZWdtZW50U3BsaXR0ZXIvbGFtYmRhJDEkVHlwZSIsMTg4MSk7ZnVuY3Rpb24gXzVlKCl7fXAoMTg4MiwxLHt9LF81ZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2UobnVsbCxuZXcgeGUoYShuLDExOCkuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnRTcGxpdHRlci9sYW1iZGEkMiRUeXBlIiwxODgyKTtmdW5jdGlvbiBkNWUoKXt9cCgxODgzLDEse30sZDVlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZShhKG4sMTE4KS5vdXRnb2luZ0Nvbm5lY3Rpb25Db29yZGluYXRlcywxNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5vcnRob2dvbmFsIiwiSHlwZXJFZGdlU2VnbWVudFNwbGl0dGVyL2xhbWJkYSQzJFR5cGUiLDE4ODMpO2Z1bmN0aW9uIGY1ZSgpe31wKDE4ODQsMSx7fSxmNWUpLGwuYXBwbHlBc0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gUigkKG4pKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIkh5cGVyRWRnZVNlZ21lbnRTcGxpdHRlci9sYW1iZGEkNCRUeXBlIiwxODg0KTtmdW5jdGlvbiBwNWUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpZih0PTAsbi5zaXplXzAhPTAmJnIuc2l6ZV8wIT0wKXtpPWRuKG4sMCkscz1kbihyLDApLHU9UigkKHVuKGkpKSksYz1SKCQodW4ocykpKSxvPSEwO2Rve2lmKHU+Yy1lLmNyaXRpY2FsQ29uZmxpY3RUaHJlc2hvbGQmJnU8YytlLmNyaXRpY2FsQ29uZmxpY3RUaHJlc2hvbGQpcmV0dXJuLTE7dT5jLWUuY29uZmxpY3RUaHJlc2hvbGQmJnU8YytlLmNvbmZsaWN0VGhyZXNob2xkJiYrK3QsdTw9YyYmaS5jdXJyZW50Tm9kZSE9aS50aGlzJDAxLnRhaWw/dT1SKCQodW4oaSkpKTpjPD11JiZzLmN1cnJlbnROb2RlIT1zLnRoaXMkMDEudGFpbD9jPVIoJCh1bihzKSkpOm89ITF9d2hpbGUobyl9cmV0dXJuIHR9ZnVuY3Rpb24gcUsoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7cmV0dXJuIFMuTWF0aC5hYnMobi5zdGFydFBvc2l0aW9uLW4uZW5kUG9zaXRpb24pPFpzfHxTLk1hdGguYWJzKHIuc3RhcnRQb3NpdGlvbi1yLmVuZFBvc2l0aW9uKTxacz8wOih0PXA1ZShlLG4ub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsci5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcyksbz1wNWUoZSxyLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLG4uaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMpLGk9dD09LTF8fG89PS0xLHM9MCxpPyh0PT0tMSYmKG5ldyBLXygoZnMoKSwkMCkscixuLDEpLCsrcyksbz09LTEmJihuZXcgS18oKGZzKCksJDApLG4sciwxKSwrK3MpKToodT1jZyhuLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLHIuc3RhcnRQb3NpdGlvbixyLmVuZFBvc2l0aW9uKSx1Kz1jZyhyLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLG4uc3RhcnRQb3NpdGlvbixuLmVuZFBvc2l0aW9uKSxjPWNnKHIub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsbi5zdGFydFBvc2l0aW9uLG4uZW5kUG9zaXRpb24pLGMrPWNnKG4uaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsci5zdGFydFBvc2l0aW9uLHIuZW5kUG9zaXRpb24pLF89dCsxNip1LGQ9bysxNipjLF88ZD9uZXcgS18oKGZzKCksQmYpLG4scixkLV8pOl8+ZD9uZXcgS18oKGZzKCksQmYpLHIsbixfLWQpOl8+MCYmZD4wJiYobmV3IEtfKChmcygpLEJmKSxuLHIsMCksbmV3IEtfKEJmLHIsbiwwKSkpLHMpfWZ1bmN0aW9uIGc1ZShlLG4scix0LG8pe3ZhciBpLHMsdSxjLF87aWYobilmb3IodT1uLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOylmb3Iocz1hKHUubmV4dF8xKCksMTApLF89JFcocywocXQoKSxwaSkscikuaXRlcmF0b3JfMCgpO18uaGFzTmV4dF8wKCk7KWM9YShfLm5leHRfMSgpLDEyKSxpPWEoX28oanQoby5oYXNoQ29kZU1hcCxjKSksMTE4KSxpfHwoaT1uZXcgSzMoZS5yb3V0aW5nU3RyYXRlZ3kpLFJlKHQuYXJyYXksaSksWjZlKGksYyxvKSl9ZnVuY3Rpb24gaDVlKGUpe3ZhciBuLHIsdCxvLGk7aWYobz1hKFRvKFVHKFdHKGUpKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksdD1tcCxvLnNpemVfMSgpPj0yKWZvcihyPW8uaXRlcmF0b3JfMCgpLG49JChyLm5leHRfMSgpKTtyLmhhc05leHRfMCgpOylpPW4sbj0kKHIubmV4dF8xKCkpLHQ9Uy5NYXRoLm1pbih0LChWZShuKSxuLShWZShpKSxpKSkpO3JldHVybiB0fWZ1bmN0aW9uIFlLKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7Zm9yKGY9bmV3IHNuLHM9bmV3IFEsZzVlKGUscixlLnJvdXRpbmdTdHJhdGVneS5nZXRTb3VyY2VQb3J0U2lkZSgpLHMsZiksZzVlKGUsdCxlLnJvdXRpbmdTdHJhdGVneS5nZXRUYXJnZXRQb3J0U2lkZSgpLHMsZiksZS5jcml0aWNhbENvbmZsaWN0VGhyZXNob2xkPS4yKihFPWg1ZShObyhuZXcgU2UobnVsbCxuZXcgeGUocywxNikpLG5ldyB5NWUpKSx2PWg1ZShObyhuZXcgU2UobnVsbCxuZXcgeGUocywxNikpLG5ldyB3NWUpKSxTLk1hdGgubWluKEUsdikpLGk9MCx1PTA7dTxzLmFycmF5Lmxlbmd0aC0xO3UrKylmb3IoYz0oQWUodSxzLmFycmF5Lmxlbmd0aCksYShzLmFycmF5W3VdLDExOCkpLHk9dSsxO3k8cy5hcnJheS5sZW5ndGg7eSsrKWkrPXFLKGUsYywoQWUoeSxzLmFycmF5Lmxlbmd0aCksYShzLmFycmF5W3ldLDExOCkpKTtmb3IoaD1hKHcobiwoSygpLFZoKSksMjM0KSxpPj0yJiYoeD1qNmUocywhMCxoKSwhZS5zZWdtZW50U3BsaXR0ZXImJihlLnNlZ21lbnRTcGxpdHRlcj1uZXcgbDVlKGUpKSxPZ24oZS5zZWdtZW50U3BsaXR0ZXIseCxzLGUuY3JpdGljYWxDb25mbGljdFRocmVzaG9sZCkpLG01ZShzLGgpLHpnbihzKSxtPS0xLGQ9bmV3IFQocyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDExOCksIShTLk1hdGguYWJzKF8uc3RhcnRQb3NpdGlvbi1fLmVuZFBvc2l0aW9uKTxacykmJihtPVMuTWF0aC5tYXgobSxfLnJvdXRpbmdTbG90KSxlLnJvdXRpbmdTdHJhdGVneS5jYWxjdWxhdGVCZW5kUG9pbnRzKF8sbyxlLmVkZ2VTcGFjaW5nKSk7cmV0dXJuIGUucm91dGluZ1N0cmF0ZWd5LmNyZWF0ZWRKdW5jdGlvblBvaW50cy5tYXBfMC5jbGVhcl8wKCksbSsxfWZ1bmN0aW9uIGI3KGUsbil7dGhpcy5yb3V0aW5nU3RyYXRlZ3k9JGduKGUpLHRoaXMuZWRnZVNwYWNpbmc9bix0aGlzLmNvbmZsaWN0VGhyZXNob2xkPS41Km59ZnVuY3Rpb24gbTVlKGUsbil7dmFyIHIsdCxvLGkscztmb3Iocj1qNmUoZSwhMSxuKSxvPW5ldyBUKHIpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxMzIpLHQud2VpZ2h0PT0wPyh2Nyh0LG51bGwpLFM3KHQsbnVsbCkpOihpPXQuc291cmNlLHM9dC50YXJnZXQsdjcodCxzKSxTNyh0LGkpKX1mdW5jdGlvbiBjZyhlLG4scil7dmFyIHQsbyxpO2Zvcih0PTAsaT1kbihlLDApO2kuY3VycmVudE5vZGUhPWkudGhpcyQwMS50YWlsJiYobz1SKCQodW4oaSkpKSwhKG8+cikpOylvPj1uJiYrK3Q7cmV0dXJuIHR9ZnVuY3Rpb24gemduKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkO2ZvcihfPW5ldyBRLHU9bmV3IFEscz1uZXcgVChlKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMocyksMTE4KSxFNyhvLG8uaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzLmFycmF5Lmxlbmd0aCksWlAobyxvLm91dGdvaW5nU2VnbWVudERlcGVuZGVuY2llcy5hcnJheS5sZW5ndGgpLG8uaW5EZXBXZWlnaHQ9PTAmJlJlKF8uYXJyYXksbyksby5vdXREZXBXZWlnaHQ9PTAmJm8uaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wPT0wJiZSZSh1LmFycmF5LG8pO2Zvcih0PS0xO18uYXJyYXkubGVuZ3RoIT0wOylmb3Iobz1hKE1jKF8sMCksMTE4KSxyPW5ldyBUKG8ub3V0Z29pbmdTZWdtZW50RGVwZW5kZW5jaWVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTMyKSxkPW4udGFyZ2V0LGpLKGQsUy5NYXRoLm1heChkLnJvdXRpbmdTbG90LG8ucm91dGluZ1Nsb3QrMSkpLHQ9Uy5NYXRoLm1heCh0LGQucm91dGluZ1Nsb3QpLEU3KGQsZC5pbkRlcFdlaWdodC0xKSxkLmluRGVwV2VpZ2h0PT0wJiZSZShfLmFycmF5LGQpO2lmKHQ+LTEpe2ZvcihpPW5ldyBUKHUpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxMTgpLG8ucm91dGluZ1Nsb3Q9dDtmb3IoO3UuYXJyYXkubGVuZ3RoIT0wOylmb3Iobz1hKE1jKHUsMCksMTE4KSxyPW5ldyBUKG8uaW5jb21pbmdTZWdtZW50RGVwZW5kZW5jaWVzKTtyLmk8ci50aGlzJDAxLmFycmF5Lmxlbmd0aDspbj1hKEMociksMTMyKSxjPW4uc291cmNlLCEoYy5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcy5zaXplXzA+MCkmJihqSyhjLFMuTWF0aC5taW4oYy5yb3V0aW5nU2xvdCxvLnJvdXRpbmdTbG90LTEpKSxaUChjLGMub3V0RGVwV2VpZ2h0LTEpLGMub3V0RGVwV2VpZ2h0PT0wJiZSZSh1LmFycmF5LGMpKX19cCg2NjQsMSx7fSxiNyksbC5jb25mbGljdFRocmVzaG9sZD0wLGwuY3JpdGljYWxDb25mbGljdFRocmVzaG9sZD0wLGwuZWRnZVNwYWNpbmc9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5vcnRob2dvbmFsIiwiT3J0aG9nb25hbFJvdXRpbmdHZW5lcmF0b3IiLDY2NCk7ZnVuY3Rpb24geTVlKCl7fXAoMTcwMywxLHt9LHk1ZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgU2UobnVsbCxuZXcgeGUoYShuLDExOCkuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMsMTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMub3J0aG9nb25hbCIsIk9ydGhvZ29uYWxSb3V0aW5nR2VuZXJhdG9yL2xhbWJkYSQwJFR5cGUiLDE3MDMpO2Z1bmN0aW9uIHc1ZSgpe31wKDE3MDQsMSx7fSx3NWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKGEobiwxMTgpLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLDE2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwiLCJPcnRob2dvbmFsUm91dGluZ0dlbmVyYXRvci9sYW1iZGEkMSRUeXBlIiwxNzA0KTtmdW5jdGlvbiBzZChlLG4scix0LG8pe3ZhciBpLHMsdSxjLF87dT1vP3QueV8wOnQueF8wLCFzcyhlLmNyZWF0ZWRKdW5jdGlvblBvaW50cyx0KSYmKF89dT5yLnN0YXJ0UG9zaXRpb24mJnU8ci5lbmRQb3NpdGlvbixjPSExLHIuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMuc2l6ZV8wIT0wJiZyLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzLnNpemVfMCE9MCYmKGM9Y3woUy5NYXRoLmFicyh1LVIoJCh5eShyLmluY29taW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSkpKTxacyYmUy5NYXRoLmFicyh1LVIoJCh5eShyLm91dGdvaW5nQ29ubmVjdGlvbkNvb3JkaW5hdGVzKSkpKTxacyksYz1jfChTLk1hdGguYWJzKHUtUigkKFJsKHIuaW5jb21pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMpKSkpPFpzJiZTLk1hdGguYWJzKHUtUigkKFJsKHIub3V0Z29pbmdDb25uZWN0aW9uQ29vcmRpbmF0ZXMpKSkpPFpzKSksKF98fGMpJiYocz1hKHcobiwob2UoKSxpbykpLDc1KSxzfHwocz1uZXcgamksaihuLGlvLHMpKSxpPW5ldyBSdCh0KSxicihzLGkscy50YWlsLnByZXYscy50YWlsKSxZcihlLmNyZWF0ZWRKdW5jdGlvblBvaW50cyxpKSkpfWZ1bmN0aW9uIEtLKCl7dGhpcy5jcmVhdGVkSnVuY3Rpb25Qb2ludHM9bmV3IEJyfWZ1bmN0aW9uICRnbihlKXtzd2l0Y2goZSl7Y2FzZSAwOnJldHVybiBuZXcgUzVlO2Nhc2UgMTpyZXR1cm4gbmV3IEU1ZTtjYXNlIDI6cmV0dXJuIG5ldyB2NWU7ZGVmYXVsdDp0aHJvdyBiKG5ldyBUQyl9fXAoNjcwLDEse30pLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwuZGlyZWN0aW9uIiwiQmFzZVJvdXRpbmdEaXJlY3Rpb25TdHJhdGVneSIsNjcwKTtmdW5jdGlvbiBFNWUoKXtLSy5jYWxsKHRoaXMpfXAoMTg3MCw2NzAse30sRTVlKSxsLmNhbGN1bGF0ZUJlbmRQb2ludHM9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2lmKCEobi5zcGxpdFBhcnRuZXImJiFuLnNwbGl0QnkpKWZvcihmPXIrbi5yb3V0aW5nU2xvdCp0LGQ9bmV3IFQobi5wb3J0cyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihfPWEoQyhkKSwxMiksaD1rbyhQKEkob3QsMSksWCw4LDAsW18ub3duZXIucG9zLF8ucG9zLF8uYW5jaG9yXSkpLnhfMCxjPW5ldyBUKF8ub3V0Z29pbmdFZGdlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDE4KSx6dCh1KXx8KEU9dS50YXJnZXQsdj1rbyhQKEkob3QsMSksWCw4LDAsW0Uub3duZXIucG9zLEUucG9zLEUuYW5jaG9yXSkpLnhfMCxTLk1hdGguYWJzKGgtdik+WnMmJihzPWYsaT1uLG89bmV3IFkoaCxzKSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMSksbT1uLnNwbGl0UGFydG5lcixtJiYoeT1SKCQoVmEobS5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcywwKSkpLG89bmV3IFkoeSxzKSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMSkscz1yK20ucm91dGluZ1Nsb3QqdCxpPW0sbz1uZXcgWSh5LHMpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCExKSksbz1uZXcgWSh2LHMpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCExKSkpfSxsLmdldFBvcnRQb3NpdGlvbk9uSHlwZXJOb2RlPWZ1bmN0aW9uKG4pe3JldHVybiBuLm93bmVyLnBvcy54XzArbi5wb3MueF8wK24uYW5jaG9yLnhfMH0sbC5nZXRTb3VyY2VQb3J0U2lkZT1mdW5jdGlvbigpe3JldHVybiByZSgpLGxufSxsLmdldFRhcmdldFBvcnRTaWRlPWZ1bmN0aW9uKCl7cmV0dXJuIHJlKCksVWV9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwuZGlyZWN0aW9uIiwiTm9ydGhUb1NvdXRoUm91dGluZ1N0cmF0ZWd5IiwxODcwKTtmdW5jdGlvbiB2NWUoKXtLSy5jYWxsKHRoaXMpfXAoMTg3MSw2NzAse30sdjVlKSxsLmNhbGN1bGF0ZUJlbmRQb2ludHM9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2lmKCEobi5zcGxpdFBhcnRuZXImJiFuLnNwbGl0QnkpKWZvcihmPXItbi5yb3V0aW5nU2xvdCp0LGQ9bmV3IFQobi5wb3J0cyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihfPWEoQyhkKSwxMiksaD1rbyhQKEkob3QsMSksWCw4LDAsW18ub3duZXIucG9zLF8ucG9zLF8uYW5jaG9yXSkpLnhfMCxjPW5ldyBUKF8ub3V0Z29pbmdFZGdlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDE4KSx6dCh1KXx8KEU9dS50YXJnZXQsdj1rbyhQKEkob3QsMSksWCw4LDAsW0Uub3duZXIucG9zLEUucG9zLEUuYW5jaG9yXSkpLnhfMCxTLk1hdGguYWJzKGgtdik+WnMmJihzPWYsaT1uLG89bmV3IFkoaCxzKSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMSksbT1uLnNwbGl0UGFydG5lcixtJiYoeT1SKCQoVmEobS5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcywwKSkpLG89bmV3IFkoeSxzKSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMSkscz1yLW0ucm91dGluZ1Nsb3QqdCxpPW0sbz1uZXcgWSh5LHMpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCExKSksbz1uZXcgWSh2LHMpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCExKSkpfSxsLmdldFBvcnRQb3NpdGlvbk9uSHlwZXJOb2RlPWZ1bmN0aW9uKG4pe3JldHVybiBuLm93bmVyLnBvcy54XzArbi5wb3MueF8wK24uYW5jaG9yLnhfMH0sbC5nZXRTb3VyY2VQb3J0U2lkZT1mdW5jdGlvbigpe3JldHVybiByZSgpLFVlfSxsLmdldFRhcmdldFBvcnRTaWRlPWZ1bmN0aW9uKCl7cmV0dXJuIHJlKCksbG59LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwuZGlyZWN0aW9uIiwiU291dGhUb05vcnRoUm91dGluZ1N0cmF0ZWd5IiwxODcxKTtmdW5jdGlvbiBTNWUoKXtLSy5jYWxsKHRoaXMpfXAoMTg2OSw2NzAse30sUzVlKSxsLmNhbGN1bGF0ZUJlbmRQb2ludHM9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2lmKCEobi5zcGxpdFBhcnRuZXImJiFuLnNwbGl0QnkpKWZvcihmPXIrbi5yb3V0aW5nU2xvdCp0LGQ9bmV3IFQobi5wb3J0cyk7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihfPWEoQyhkKSwxMiksaD1rbyhQKEkob3QsMSksWCw4LDAsW18ub3duZXIucG9zLF8ucG9zLF8uYW5jaG9yXSkpLnlfMCxjPW5ldyBUKF8ub3V0Z29pbmdFZGdlcyk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDE4KSx6dCh1KXx8KEU9dS50YXJnZXQsdj1rbyhQKEkob3QsMSksWCw4LDAsW0Uub3duZXIucG9zLEUucG9zLEUuYW5jaG9yXSkpLnlfMCxTLk1hdGguYWJzKGgtdik+WnMmJihzPWYsaT1uLG89bmV3IFkocyxoKSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMCksbT1uLnNwbGl0UGFydG5lcixtJiYoeT1SKCQoVmEobS5pbmNvbWluZ0Nvbm5lY3Rpb25Db29yZGluYXRlcywwKSkpLG89bmV3IFkocyx5KSxMbih1LmJlbmRQb2ludHMsbyksc2QodGhpcyx1LGksbywhMCkscz1yK20ucm91dGluZ1Nsb3QqdCxpPW0sbz1uZXcgWShzLHkpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCEwKSksbz1uZXcgWShzLHYpLExuKHUuYmVuZFBvaW50cyxvKSxzZCh0aGlzLHUsaSxvLCEwKSkpfSxsLmdldFBvcnRQb3NpdGlvbk9uSHlwZXJOb2RlPWZ1bmN0aW9uKG4pe3JldHVybiBuLm93bmVyLnBvcy55XzArbi5wb3MueV8wK24uYW5jaG9yLnlfMH0sbC5nZXRTb3VyY2VQb3J0U2lkZT1mdW5jdGlvbigpe3JldHVybiByZSgpLHFlfSxsLmdldFRhcmdldFBvcnRTaWRlPWZ1bmN0aW9uKCl7cmV0dXJuIHJlKCksamV9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLm9ydGhvZ29uYWwuZGlyZWN0aW9uIiwiV2VzdFRvRWFzdFJvdXRpbmdTdHJhdGVneSIsMTg2OSk7ZnVuY3Rpb24gQmduKGUsbil7dmFyIHIsdCxvLGkscztpZihuPDIqZS5kaW1OVUJTKXRocm93IGIobmV3IEdlKCJUaGUga25vdCB2ZWN0b3IgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byB0aW1lIHRoZSBkaW1lbnNpb24gZWxlbWVudHMuIikpO2ZvcihlLm1heEtub3Q9MSxvPTA7bzxlLmRpbU5VQlM7bysrKWVlKGUua25vdFZlY3RvciwwKTtmb3Iocz1uKzEtMiplLmRpbU5VQlMscj1zLGk9MTtpPHM7aSsrKWVlKGUua25vdFZlY3RvcixpL3IpO2lmKGUuaXNDbGFtcGVkKWZvcih0PTA7dDxlLmRpbU5VQlM7dCsrKWVlKGUua25vdFZlY3RvciwxKX1mdW5jdGlvbiBDNWUoZSl7dmFyIG4scjtmb3IoZS5pc0Jlemllcnx8VWduKGUpLHI9bmV3IGppLG49bmV3IFQoZS5jb250cm9sUG9pbnRzKSxDKG4pO24uaTxuLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylMbihyLGEoQyhuKSw0MTgpLmNwKTtyZXR1cm4gcm4oci5zaXplXzAhPTApLFphKHIsci50YWlsLnByZXYpLHJ9ZnVuY3Rpb24gR2duKGUsbil7dmFyIHIsdCxvLGk7Zm9yKGk9bmV3IHB0KGUua25vdFZlY3RvciwwKSxyPTA7aS5pPGkudGhpcyQwMV8wLnNpemVfMSgpOyl7aWYodD1SKChybihpLmk8aS50aGlzJDAxXzAuc2l6ZV8xKCkpLCQoaS50aGlzJDAxXzAuZ2V0XzAoaS5sYXN0PWkuaSsrKSkpKSxvPXQtbixvPnA2KXJldHVybiByO28+LTFlLTYmJisrcn1yZXR1cm4gcn1mdW5jdGlvbiBIZ24oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQsZixoLG0seTtmb3IoaD1HZ24oZSxyKSxjPTA7YzxuO2MrKyl7Zm9yKHJmKG8sciksbT1uZXcgUSx5PShybih0Lmk8dC50aGlzJDAxXzAuc2l6ZV8xKCkpLGEodC50aGlzJDAxXzAuZ2V0XzAodC5sYXN0PXQuaSsrKSw0MTgpKSxkPWgrYztkPGUuZGltTlVCUztkKyspdT15LHk9KHJuKHQuaTx0LnRoaXMkMDFfMC5zaXplXzEoKSksYSh0LnRoaXMkMDFfMC5nZXRfMCh0Lmxhc3Q9dC5pKyspLDQxOCkpLGVlKG0sbmV3IFQ1ZSh1LHkscikpO2ZvcihmPWgrYztmPGUuZGltTlVCUztmKyspcm4odC5pPjApLHQudGhpcyQwMS5nZXRfMCh0Lmxhc3Q9LS10LmkpLGY+aCtjJiZFYSh0KTtmb3Iocz1uZXcgVChtKTtzLmk8cy50aGlzJDAxLmFycmF5Lmxlbmd0aDspaT1hKEMocyksNDE4KSxyZih0LGkpO2lmKGM8bi0xKWZvcihfPWgrYztfPGUuZGltTlVCUztfKyspcm4odC5pPjApLHQudGhpcyQwMS5nZXRfMCh0Lmxhc3Q9LS10LmkpfX1mdW5jdGlvbiBVZ24oZSl7dmFyIG4scix0LG8saSxzO2lmKG89bmV3IHB0KGUua25vdFZlY3RvciwwKSx0PW5ldyBwdChlLmNvbnRyb2xQb2ludHMsMCksZS5pc0NsYW1wZWQpZm9yKHI9MDtyPGUuZGltTlVCUztyKyspcm4oby5pPG8udGhpcyQwMV8wLnNpemVfMSgpKSxvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspO2Vsc2UgZm9yKHI9MDtyPGUuZGltTlVCUy0xO3IrKylybihvLmk8by50aGlzJDAxXzAuc2l6ZV8xKCkpLG8udGhpcyQwMV8wLmdldF8wKG8ubGFzdD1vLmkrKyksRWEobyk7Zm9yKG49Uigocm4oby5pPG8udGhpcyQwMV8wLnNpemVfMSgpKSwkKG8udGhpcyQwMV8wLmdldF8wKG8ubGFzdD1vLmkrKykpKSk7ZS5tYXhLbm90LW4+cDY7KXtmb3IoaT1uLHM9MDtTLk1hdGguYWJzKG4taSk8cDY7KSsrcyxuPVIoKHJuKG8uaTxvLnRoaXMkMDFfMC5zaXplXzEoKSksJChvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspKSkpLHJuKHQuaTx0LnRoaXMkMDFfMC5zaXplXzEoKSksdC50aGlzJDAxXzAuZ2V0XzAodC5sYXN0PXQuaSsrKTtzPGUuZGltTlVCUyYmKHJuKG8uaT4wKSxvLnRoaXMkMDEuZ2V0XzAoby5sYXN0PS0tby5pKSxIZ24oZSxlLmRpbU5VQlMtcyxpLHQsbykscm4oby5pPG8udGhpcyQwMV8wLnNpemVfMSgpKSxvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspKSxybih0Lmk+MCksdC50aGlzJDAxLmdldF8wKHQubGFzdD0tLXQuaSl9aWYoIWUuaXNDbGFtcGVkKWZvcihyPTA7cjxlLmRpbU5VQlMtMTtyKyspcm4oby5pPG8udGhpcyQwMV8wLnNpemVfMSgpKSxvLnRoaXMkMDFfMC5nZXRfMChvLmxhc3Q9by5pKyspLEVhKG8pO2UuaXNDbGFtcGVkPSEwLGUuaXNCZXppZXI9ITB9ZnVuY3Rpb24gWEsoZSl7dmFyIG4scix0LG8saSxzO2Zvcih0aGlzLmtub3RWZWN0b3I9bmV3IFEsdGhpcy5jb250cm9sUG9pbnRzPW5ldyBRLHI9ZS5zaXplXzAtMTtyPDM7cisrKVptKGUsMCxhKFZhKGUsMCksOCkpO2lmKGUuc2l6ZV8wPDQpdGhyb3cgYihuZXcgR2UoIkF0IChsZWFzdCBkaW1lbnNpb24gKyAxKSBjb250cm9sIHBvaW50cyBhcmUgbmVjZXNzYXJ5ISIpKTtmb3IodGhpcy5kaW1OVUJTPTMsdGhpcy5pc0NsYW1wZWQ9ITAsdGhpcy5pc0Jlemllcj0hMSxCZ24odGhpcyxlLnNpemVfMCt0aGlzLmRpbU5VQlMtMSkscz1uZXcgUSxpPW5ldyBUKHRoaXMua25vdFZlY3Rvciksbj0wO248dGhpcy5kaW1OVUJTLTE7bisrKWVlKHMsJChDKGkpKSk7Zm9yKG89ZG4oZSwwKTtvLmN1cnJlbnROb2RlIT1vLnRoaXMkMDEudGFpbDspdD1hKHVuKG8pLDgpLGVlKHMsJChDKGkpKSksZWUodGhpcy5jb250cm9sUG9pbnRzLG5ldyBiNWUodCxzKSksQWUoMCxzLmFycmF5Lmxlbmd0aCkscy5hcnJheS5zcGxpY2UoMCwxKX1wKDgyOCwxLHt9LFhLKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbTAodGhpcy5jb250cm9sUG9pbnRzKX0sbC5kaW1OVUJTPTAsbC5pc0Jlemllcj0hMSxsLmlzQ2xhbXBlZD0hMSxsLm1heEtub3Q9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5zcGxpbmVzIiwiTnViU3BsaW5lIiw4MjgpO2Z1bmN0aW9uIFdnbihlLG4pe2UuY3A9bn1mdW5jdGlvbiBqZ24oZSxuKXtlLnBvbGFyQ29vcmRpbmF0ZT1ufWZ1bmN0aW9uIFQ1ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IoaT1SKCQoZS5wb2xhckNvb3JkaW5hdGUuaXRlcmF0b3JfMCgpLm5leHRfMSgpKSksXz1SKCQoUktlKG4ucG9sYXJDb29yZGluYXRlKSkpLHQ9eXUoQ3QoZS5jcCksXy1yKSxvPXl1KEN0KG4uY3ApLHItaSksZD1Lbih0LG8pLHl1KGQsMS8oXy1pKSksdGhpcy5jcD1kLHRoaXMucG9sYXJDb29yZGluYXRlPW5ldyBRLHU9ITAscz1lLnBvbGFyQ29vcmRpbmF0ZS5pdGVyYXRvcl8wKCkscy5uZXh0XzEoKTtzLmhhc05leHRfMCgpOyljPVIoJChzLm5leHRfMSgpKSksdSYmYy1yPnA2JiYodGhpcy5wb2xhckNvb3JkaW5hdGUuYWRkXzIociksdT0hMSksdGhpcy5wb2xhckNvb3JkaW5hdGUuYWRkXzIoYyk7dSYmdGhpcy5wb2xhckNvb3JkaW5hdGUuYWRkXzIocil9ZnVuY3Rpb24gYjVlKGUsbil7V2duKHRoaXMsbmV3IFkoZS54XzAsZS55XzApKSxqZ24odGhpcyxjQyhuKSl9cCg0MTgsMSx7NDE4OjF9LFQ1ZSxiNWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLnNwbGluZXMiLCJOdWJTcGxpbmUvUG9sYXJDUCIsNDE4KTtmdW5jdGlvbiBfdigpe192PUYsUDVlPU1uKFdpKG5ldyBIciwoeHQoKSxobyksKGt0KCksYmopKSxKbyxiNCksazVlPWh1KGh1KEx2KFdpKE1uKG5ldyBIcixqbCxGNCksaG8sRDQpLHJpKSxSNCksejQpLE41ZT1XaShNbihNbihNbihuZXcgSHIsT3UseDQpLHJpLE40KSxyaSx6eSksaG8sUDQpLEw1ZT1NbihNbihuZXcgSHIsSm8sTzQpLGhvLGs0KSxBNWU9V2koTW4oTW4obmV3IEhyLHJpLHp5KSxyaSxUNCksaG8sQzQpfWZ1bmN0aW9uIFZnbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtpZihlLmxlZnRQb3J0c0xheWVyLm1hcF8wLmNsZWFyXzAoKSxlLnJpZ2h0UG9ydHNMYXllci5tYXBfMC5jbGVhcl8wKCksZS5lZGdlc1JlbWFpbmluZ0xheWVyLmFycmF5Lmxlbmd0aD0wLGUuc3BsaW5lU2VnbWVudHNMYXllci5hcnJheS5sZW5ndGg9MCxlLnNlbGZMb29wc0xheWVyLm1hcF8wLmNsZWFyXzAoKSxuKWZvcihzPW5ldyBUKG4ubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoaT1hKEMocyksMTApLGY9JGMoaSwocmUoKSxxZSkpLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOylmb3IoZD1hKGYubmV4dF8xKCksMTIpLFlyKGUubGVmdFBvcnRzTGF5ZXIsZCksbz1uZXcgVChkLm91dGdvaW5nRWRnZXMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxOCksIXp0KHQpJiYoZWUoZS5lZGdlc1JlbWFpbmluZ0xheWVyLHQpLEk1ZShlLHQpLHU9dC5zb3VyY2Uub3duZXIudHlwZV8wLCh1PT0oV2UoKSxrcil8fHU9PXRpfHx1PT1Gcnx8dT09TnMpJiZlZShlLnN0YXJ0RWRnZXMsdCksbT10LnRhcmdldCxoPW0ub3duZXIubGF5ZXIsaD09cj9ZcihlLnJpZ2h0UG9ydHNMYXllcixtKTpoPT1uP1lyKGUubGVmdFBvcnRzTGF5ZXIsbSk6UGkoZS5lZGdlc1JlbWFpbmluZ0xheWVyLHQpKTtpZihyKWZvcihzPW5ldyBUKHIubm9kZXMpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKGk9YShDKHMpLDEwKSxfPW5ldyBUKGkucG9ydHMpO18uaTxfLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3IoYz1hKEMoXyksMTIpLG89bmV3IFQoYy5vdXRnb2luZ0VkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTgpLHp0KHQpJiZZcihlLnNlbGZMb29wc0xheWVyLHQpO2ZvcihmPSRjKGksKHJlKCksamUpKS5pdGVyYXRvcl8wKCk7Zi5oYXNOZXh0XzAoKTspZm9yKGQ9YShmLm5leHRfMSgpLDEyKSxZcihlLnJpZ2h0UG9ydHNMYXllcixkKSxvPW5ldyBUKGQub3V0Z29pbmdFZGdlcyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE4KSwhenQodCkmJihlZShlLmVkZ2VzUmVtYWluaW5nTGF5ZXIsdCksSTVlKGUsdCksdT10LnNvdXJjZS5vd25lci50eXBlXzAsKHU9PShXZSgpLGtyKXx8dT09dGl8fHU9PUZyfHx1PT1OcykmJmVlKGUuc3RhcnRFZGdlcyx0KSxtPXQudGFyZ2V0LGg9bS5vd25lci5sYXllcixoPT1yP1lyKGUucmlnaHRQb3J0c0xheWVyLG0pOmg9PW4/WXIoZS5sZWZ0UG9ydHNMYXllcixtKTpQaShlLmVkZ2VzUmVtYWluaW5nTGF5ZXIsdCkpfX1mdW5jdGlvbiBxZ24oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoO2ZvcihjPTAsZD1uZXcgVChlLm5vZGVzKTtkLmk8ZC50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihfPWEoQyhkKSwxMCksdT0wLGk9bmV3IFhlKFFlKHR0KF8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspbz1hKHRuKGkpLDE4KSxmPUFzKG8uc291cmNlKS55XzAsaD1BcyhvLnRhcmdldCkueV8wLHU9Uy5NYXRoLm1heCh1LFMuTWF0aC5hYnMoaC1mKSk7Yz1TLk1hdGgubWF4KGMsdSl9cmV0dXJuIHM9dCpTLk1hdGgubWluKDEsbi9yKSpjLHN9ZnVuY3Rpb24gWWduKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7aWYoIShlLmh5cGVyRWRnZVRvcFlQb3M+bi5oeXBlckVkZ2VCb3R0b21ZUG9zfHxuLmh5cGVyRWRnZVRvcFlQb3M+ZS5oeXBlckVkZ2VCb3R0b21ZUG9zKSl7Zm9yKHI9MCx0PTAscz1lLnJpZ2h0UG9ydHMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspbz1hKHMubmV4dF8xKCksMTIpLFA3KGtvKFAoSShvdCwxKSxYLDgsMCxbby5vd25lci5wb3Msby5wb3Msby5hbmNob3JdKSkueV8wLG4uaHlwZXJFZGdlVG9wWVBvcyxuLmh5cGVyRWRnZUJvdHRvbVlQb3MpJiYrK3I7Zm9yKHU9ZS5sZWZ0UG9ydHMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7dS5oYXNOZXh0XzAoKTspbz1hKHUubmV4dF8xKCksMTIpLFA3KGtvKFAoSShvdCwxKSxYLDgsMCxbby5vd25lci5wb3Msby5wb3Msby5hbmNob3JdKSkueV8wLG4uaHlwZXJFZGdlVG9wWVBvcyxuLmh5cGVyRWRnZUJvdHRvbVlQb3MpJiYtLXI7Zm9yKGM9bi5yaWdodFBvcnRzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KW89YShjLm5leHRfMSgpLDEyKSxQNyhrbyhQKEkob3QsMSksWCw4LDAsW28ub3duZXIucG9zLG8ucG9zLG8uYW5jaG9yXSkpLnlfMCxlLmh5cGVyRWRnZVRvcFlQb3MsZS5oeXBlckVkZ2VCb3R0b21ZUG9zKSYmKyt0O2ZvcihpPW4ubGVmdFBvcnRzLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDEyKSxQNyhrbyhQKEkob3QsMSksWCw4LDAsW28ub3duZXIucG9zLG8ucG9zLG8uYW5jaG9yXSkpLnlfMCxlLmh5cGVyRWRnZVRvcFlQb3MsZS5oeXBlckVkZ2VCb3R0b21ZUG9zKSYmLS10O3I8dD9uZXcgUVAoZSxuLHQtcik6dDxyP25ldyBRUChuLGUsci10KToobmV3IFFQKG4sZSwwKSxuZXcgUVAoZSxuLDApKX19ZnVuY3Rpb24gS2duKGUpe3ZhciBuLHIsdCxvO2ZvcihJNyhlLGUubGVmdFBvcnRzTGF5ZXIsZS5yaWdodFBvcnRzTGF5ZXIsKHVkKCksQjApLCEwLGUuZWRnZXNSZW1haW5pbmdMYXllcixlLnNwbGluZVNlZ21lbnRzTGF5ZXIpLEk3KGUsZS5sZWZ0UG9ydHNMYXllcixlLnJpZ2h0UG9ydHNMYXllcixCMCwhMSxlLmVkZ2VzUmVtYWluaW5nTGF5ZXIsZS5zcGxpbmVTZWdtZW50c0xheWVyKSxJNyhlLGUubGVmdFBvcnRzTGF5ZXIsZS5yaWdodFBvcnRzTGF5ZXIsX2csITAsZS5lZGdlc1JlbWFpbmluZ0xheWVyLGUuc3BsaW5lU2VnbWVudHNMYXllciksSTcoZSxlLmxlZnRQb3J0c0xheWVyLGUucmlnaHRQb3J0c0xheWVyLF9nLCExLGUuZWRnZXNSZW1haW5pbmdMYXllcixlLnNwbGluZVNlZ21lbnRzTGF5ZXIpLFhnbihlLGUuZWRnZXNSZW1haW5pbmdMYXllcixlLmxlZnRQb3J0c0xheWVyLGUucmlnaHRQb3J0c0xheWVyLGUuc3BsaW5lU2VnbWVudHNMYXllciksdD1uZXcgcHQoZS5zcGxpbmVTZWdtZW50c0xheWVyLDApO3QuaTx0LnRoaXMkMDFfMC5zaXplXzEoKTspZm9yKG49KHJuKHQuaTx0LnRoaXMkMDFfMC5zaXplXzEoKSksYSh0LnRoaXMkMDFfMC5nZXRfMCh0Lmxhc3Q9dC5pKyspLDEzMSkpLG89bmV3IHB0KGUuc3BsaW5lU2VnbWVudHNMYXllcix0LmkpO28uaTxvLnRoaXMkMDFfMC5zaXplXzEoKTspcj0ocm4oby5pPG8udGhpcyQwMV8wLnNpemVfMSgpKSxhKG8udGhpcyQwMV8wLmdldF8wKG8ubGFzdD1vLmkrKyksMTMxKSksWWduKG4scik7dGhuKGUuc3BsaW5lU2VnbWVudHNMYXllcixhKHcoZS5sR3JhcGgsKEsoKSxWaCkpLDIzNCkpLG9obihlLnNwbGluZVNlZ21lbnRzTGF5ZXIpfWZ1bmN0aW9uIFhnbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmO2ZvcihzPW5ldyBUKG4pO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7aWYoaT1hKEMocyksMTgpLGM9aS5zb3VyY2Usci5tYXBfMC5jb250YWluc0tleShjKSlfPSh1ZCgpLEIwKTtlbHNlIGlmKHQubWFwXzAuY29udGFpbnNLZXkoYykpXz0odWQoKSxfZyk7ZWxzZSB0aHJvdyBiKG5ldyBHZSgiU291cmNlIHBvcnQgbXVzdCBiZSBpbiBvbmUgb2YgdGhlIHBvcnQgc2V0cy4iKSk7aWYoZD1pLnRhcmdldCxyLm1hcF8wLmNvbnRhaW5zS2V5KGQpKWY9KHVkKCksQjApO2Vsc2UgaWYodC5tYXBfMC5jb250YWluc0tleShkKSlmPSh1ZCgpLF9nKTtlbHNlIHRocm93IGIobmV3IEdlKCJUYXJnZXQgcG9ydCBtdXN0IGJlIGluIG9uZSBvZiB0aGUgcG9ydCBzZXRzLiIpKTt1PW5ldyBVNWUoaSxfLGYpLEJuKGUuZWRnZVRvU2VnbWVudE1hcCxpLHUpLFJlKG8uYXJyYXksdSl9fWZ1bmN0aW9uIEk3KGUsbixyLHQsbyxpLHMpe3ZhciB1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2ZvcihoPW51bGwsdD09KHVkKCksQjApP2g9bjp0PT1fZyYmKGg9ciksRT1oLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO0UuaGFzTmV4dF8wKCk7KXtmb3IoeT1hKEUubmV4dF8xKCksMTIpLHY9a28oUChJKG90LDEpLFgsOCwwLFt5Lm93bmVyLnBvcyx5LnBvcyx5LmFuY2hvcl0pKS55XzAsaz1uZXcgQnIsdT1uZXcgQnIsXz1uZXcgTHMoeS5jb25uZWN0ZWRFZGdlcyk7eG8oXy5maXJzdEl0ZXJhdG9yKXx8eG8oXy5zZWNvbmRJdGVyYXRvcik7KWlmKGM9YSh4byhfLmZpcnN0SXRlcmF0b3IpP0MoXy5maXJzdEl0ZXJhdG9yKTpDKF8uc2Vjb25kSXRlcmF0b3IpLDE4KSxhZShpZSh3KGMsKEsoKSxPcykpKSk9PW8mJmZvKGksYywwKSE9LTEpe2lmKGMudGFyZ2V0PT15P3g9Yy5zb3VyY2U6eD1jLnRhcmdldCxBPWtvKFAoSShvdCwxKSxYLDgsMCxbeC5vd25lci5wb3MseC5wb3MseC5hbmNob3JdKSkueV8wLFMuTWF0aC5hYnMoQS12KTwuMiljb250aW51ZTtBPHY/bi5tYXBfMC5jb250YWluc0tleSh4KT9ZcihrLG5ldyBacihCMCxjKSk6WXIoayxuZXcgWnIoX2csYykpOm4ubWFwXzAuY29udGFpbnNLZXkoeCk/WXIodSxuZXcgWnIoQjAsYykpOllyKHUsbmV3IFpyKF9nLGMpKX1pZihrLm1hcF8wLnNpemVfMSgpPjEpZm9yKG09bmV3IFFLKHksayx0KSxFdChrLG5ldyB6NWUoZSxtKSksUmUocy5hcnJheSxtKSxmPWsubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7Zi5oYXNOZXh0XzAoKTspZD1hKGYubmV4dF8xKCksNDIpLFBpKGksZC5zZWNvbmQpO2lmKHUubWFwXzAuc2l6ZV8xKCk+MSlmb3IobT1uZXcgUUsoeSx1LHQpLEV0KHUsbmV3ICQ1ZShlLG0pKSxSZShzLmFycmF5LG0pLGY9dS5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtmLmhhc05leHRfMCgpOylkPWEoZi5uZXh0XzEoKSw0MiksUGkoaSxkLnNlY29uZCl9fWZ1bmN0aW9uIEk1ZShlLG4pe3ZhciByLHQsbztvPW4udGFyZ2V0Lm93bmVyLHQ9by50eXBlXzAsISh0PT0oV2UoKSxrcil8fHQ9PU5zKSYmKHI9bmV3IFhlKFFlKFJyKG8pLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSxfbihyKSYmQm4oZS5zdWNjZXNzaW5nRWRnZSxuLGEodG4ociksMTgpKSl9ZnVuY3Rpb24gSmduKGUsbil7dmFyIHIsdDt0PW5ldyBRLHI9bjtkbyBSZSh0LmFycmF5LHIpLHI9YShLZShlLnN1Y2Nlc3NpbmdFZGdlLHIpLDE4KTt3aGlsZShyKTtyZXR1cm4gdH1mdW5jdGlvbiBaZ24oZSl7dmFyIG4scjtyZXR1cm4gbj1uZXcgSHIsUmEobixQNWUpLHI9YSh3KGUsKEsoKSxpaSkpLDIxKSxyLmNvbnRhaW5zKChWdCgpLEdFKSkmJlJhKG4sazVlKSxyLmNvbnRhaW5zKFF5KSYmUmEobixONWUpLHIuY29udGFpbnMoWHApJiZSYShuLEw1ZSksci5jb250YWlucyhldykmJlJhKG4sQTVlKSxufWZ1bmN0aW9uIFFnbihlLG4pe3ZhciByLHQsbyxpLHM7cz1uZXcgUSxyPW47ZG8gaT1hKEtlKGUuZWRnZVRvU2VnbWVudE1hcCxyKSwxMzEpLGkuc291cmNlUG9ydD1yLnNvdXJjZSxpLnRhcmdldFBvcnQ9ci50YXJnZXQsUmUocy5hcnJheSxpKSxyPWEoS2UoZS5zdWNjZXNzaW5nRWRnZSxyKSwxOCk7d2hpbGUocik7cmV0dXJuIHQ9KEFlKDAscy5hcnJheS5sZW5ndGgpLGEocy5hcnJheVswXSwxMzEpKSx0LmluaXRpYWxTZWdtZW50PSEwLHQuc291cmNlTm9kZT1hKHQuZWRnZXMubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCkubmV4dF8xKCksMTgpLnNvdXJjZS5vd25lcixvPWEobGUocyxzLmFycmF5Lmxlbmd0aC0xKSwxMzEpLG8ubGFzdFNlZ21lbnQ9ITAsby50YXJnZXROb2RlPWEoby5lZGdlcy5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSwxOCkudGFyZ2V0Lm93bmVyLHN9ZnVuY3Rpb24gZWhuKGUsbixyKXtyZXR1cm4gQm4oZS5lZGdlVG9TZWdtZW50TWFwLGEoci5zZWNvbmQsMTgpLG4pfWZ1bmN0aW9uIG5obihlLG4scil7cmV0dXJuIEJuKGUuZWRnZVRvU2VnbWVudE1hcCxhKHIuc2Vjb25kLDE4KSxuKX1mdW5jdGlvbiByaG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm47aWYoci5iZWdpbigiU3BsaW5lIGVkZ2Ugcm91dGluZyIsMSksbi5sYXllcnMuYXJyYXkubGVuZ3RoPT0wKXtuLnNpemVfMC54XzA9MCxyLmRvbmVfMSgpO3JldHVybn1BPVIoJCh3KG4sKG9lKCksb2cpKSkpLHU9UigkKHcobixxXykpKSxzPVIoJCh3KG4scmcpKSkseD1hKHcobixDTyksMzUwKSx2ZT14PT0oZHcoKSxpdiksbmU9UigkKHcobixxcSkpKSxlLmxHcmFwaD1uLGUuc3RhcnRFZGdlcy5hcnJheS5sZW5ndGg9MCxlLmFsbFNwbGluZVNlZ21lbnRzLmFycmF5Lmxlbmd0aD0wLFppKGUuc3VjY2Vzc2luZ0VkZ2UpLGM9YShsZShuLmxheWVycywwKSwzMCksZD1wSShjLm5vZGVzLChYUCgpLFkzKSkseT1hKGxlKG4ubGF5ZXJzLG4ubGF5ZXJzLmFycmF5Lmxlbmd0aC0xKSwzMCksZj1wSSh5Lm5vZGVzLFkzKSxFPW5ldyBUKG4ubGF5ZXJzKSx2PW51bGwsbm49MDtkb3tmb3Ioaz1FLmk8RS50aGlzJDAxLmFycmF5Lmxlbmd0aD9hKEMoRSksMzApOm51bGwsVmduKGUsdixrKSxLZ24oZSksd2U9QVFlKEllbih3eChKbihuZXcgU2UobnVsbCxuZXcgeGUoZS5zcGxpbmVTZWdtZW50c0xheWVyLDE2KSksbmV3IEQ1ZSksbmV3IEY1ZSkpKSxGZT0wLE09bm4saD0hdnx8ZCYmdj09YyxtPSFrfHxmJiZrPT15LHdlPjA/KF89MCx2JiYoXys9dSksXys9KHdlLTEpKnMsayYmKF8rPXUpLHZlJiZrJiYoXz1TLk1hdGgubWF4KF8scWduKGsscyxBLG5lKSkpLF88QSYmIWgmJiFtJiYoRmU9KEEtXykvMixfPUEpLE0rPV8pOiFoJiYhbSYmKE0rPUEpLGsmJk5XKGssTSkscT1uZXcgVChlLnNwbGluZVNlZ21lbnRzTGF5ZXIpO3EuaTxxLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylIPWEoQyhxKSwxMzEpLEguYm91bmRpbmdCb3gueF8wPW5uLEguYm91bmRpbmdCb3gud2lkdGhfMD1NLW5uLEgueERlbHRhPUZlLEguaXNXZXN0T2ZJbml0aWFsTGF5ZXI9IXY7cXIoZS5hbGxTcGxpbmVTZWdtZW50cyxlLnNwbGluZVNlZ21lbnRzTGF5ZXIpLG5uPU0sayYmKG5uKz1rLnNpemVfMC54XzApLHY9ayxoPW19d2hpbGUoayk7Zm9yKG89bmV3IFQoZS5zdGFydEVkZ2VzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTgpLGk9SmduKGUsdCksaih0LChLKCksbmcpLGkpLERlPVFnbihlLHQpLGoodCxHXyxEZSk7bi5zaXplXzAueF8wPW5uLGUubEdyYXBoPW51bGwsci5kb25lXzEoKX1mdW5jdGlvbiB4NWUoKXtfdigpLHRoaXMuZWRnZXNSZW1haW5pbmdMYXllcj1uZXcgUSx0aGlzLnNwbGluZVNlZ21lbnRzTGF5ZXI9bmV3IFEsdGhpcy5sZWZ0UG9ydHNMYXllcj1uZXcgbHUsdGhpcy5yaWdodFBvcnRzTGF5ZXI9bmV3IGx1LHRoaXMuc2VsZkxvb3BzTGF5ZXI9bmV3IGx1LHRoaXMuc3RhcnRFZGdlcz1uZXcgUSx0aGlzLmFsbFNwbGluZVNlZ21lbnRzPW5ldyBRLHRoaXMuZWRnZVRvU2VnbWVudE1hcD1uZXcgc24sdGhpcy5zdWNjZXNzaW5nRWRnZT1uZXcgc259ZnVuY3Rpb24gdGhuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlO2Zvcih3ZT1uZXcgcHIscT1uZXcgcHIsdj0tMSxjPW5ldyBUKGUpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl7Zm9yKHM9YShDKGMpLDEzMSkscy5tYXJrPXYtLSxkPTAsaz0wLGk9bmV3IFQocy5vdXRnb2luZyk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKGkpLDI3NCksays9dC53ZWlnaHQ7Zm9yKG89bmV3IFQocy5pbmNvbWluZyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDI3NCksZCs9dC53ZWlnaHQ7cy5pbndlaWdodD1kLHMub3V0d2VpZ2h0PWssaz09MD9icihxLHMscS50YWlsLnByZXYscS50YWlsKTpkPT0wJiZicih3ZSxzLHdlLnRhaWwucHJldix3ZS50YWlsKX1mb3IoRmU9VEkoZSksZj1lLmFycmF5Lmxlbmd0aCxFPWYrMSx4PWYtMSxtPW5ldyBRO0ZlLm1hcF8wLnNpemVfMSgpIT0wOyl7Zm9yKDtxLnNpemVfMCE9MDspSD0ocm4ocS5zaXplXzAhPTApLGEoWmEocSxxLmhlYWRlci5uZXh0XzApLDEzMSkpLEZlLm1hcF8wLnJlbW92ZV8wKEgpIT1udWxsLEgubWFyaz14LS0sSksoSCx3ZSxxKTtmb3IoO3dlLnNpemVfMCE9MDspbmU9KHJuKHdlLnNpemVfMCE9MCksYShaYSh3ZSx3ZS5oZWFkZXIubmV4dF8wKSwxMzEpKSxGZS5tYXBfMC5yZW1vdmVfMChuZSkhPW51bGwsbmUubWFyaz1FKyssSksobmUsd2UscSk7Zm9yKHk9YnQsXz1GZS5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOylzPWEoXy5uZXh0XzEoKSwxMzEpLEE9cy5vdXR3ZWlnaHQtcy5pbndlaWdodCxBPj15JiYoQT55JiYobS5hcnJheS5sZW5ndGg9MCx5PUEpLFJlKG0uYXJyYXkscykpO20uYXJyYXkubGVuZ3RoIT0wJiYoaD1hKGxlKG0saXgobixtLmFycmF5Lmxlbmd0aCkpLDEzMSksRmUubWFwXzAucmVtb3ZlXzAoaCkhPW51bGwsaC5tYXJrPUUrKyxKSyhoLHdlLHEpLG0uYXJyYXkubGVuZ3RoPTApfWZvcihNPWUuYXJyYXkubGVuZ3RoKzEsdT1uZXcgVChlKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMTMxKSxzLm1hcms8ZiYmKHMubWFyays9TSk7Zm9yKHZlPW5ldyBUKGUpO3ZlLmk8dmUudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihuZT1hKEModmUpLDEzMSkscj1uZXcgcHQobmUub3V0Z29pbmcsMCk7ci5pPHIudGhpcyQwMV8wLnNpemVfMSgpOyl0PShybihyLmk8ci50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoci50aGlzJDAxXzAuZ2V0XzAoci5sYXN0PXIuaSsrKSwyNzQpKSxEZT10LnRhcmdldCxuZS5tYXJrPkRlLm1hcmsmJihFYShyKSxQaShEZS5pbmNvbWluZyx0KSx0LndlaWdodD4wJiYodC5zb3VyY2U9RGUsZWUoRGUub3V0Z29pbmcsdCksdC50YXJnZXQ9bmUsZWUobmUuaW5jb21pbmcsdCkpKX1mdW5jdGlvbiBvaG4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQ7Zm9yKF89bmV3IHByLHU9bmV3IHByLGk9bmV3IFQoZSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKGkpLDEzMSksdC5yYW5rPTAsdC5pbndlaWdodD10LmluY29taW5nLmFycmF5Lmxlbmd0aCx0Lm91dHdlaWdodD10Lm91dGdvaW5nLmFycmF5Lmxlbmd0aCx0Lmlud2VpZ2h0PT0wJiZicihfLHQsXy50YWlsLnByZXYsXy50YWlsKSx0Lm91dHdlaWdodD09MCYmdC5sZWZ0UG9ydHMubWFwXzAuc2l6ZV8xKCk9PTAmJmJyKHUsdCx1LnRhaWwucHJldix1LnRhaWwpO2ZvcihzPS0xO18uc2l6ZV8wIT0wOylmb3IodD1hKHM1KF8sMCksMTMxKSxyPW5ldyBUKHQub3V0Z29pbmcpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwyNzQpLGQ9bi50YXJnZXQsZC5yYW5rPVMuTWF0aC5tYXgoZC5yYW5rLHQucmFuaysxKSxzPVMuTWF0aC5tYXgocyxkLnJhbmspLC0tZC5pbndlaWdodCxkLmlud2VpZ2h0PT0wJiZicihfLGQsXy50YWlsLnByZXYsXy50YWlsKTtpZihzPi0xKXtmb3Iobz1kbih1LDApO28uY3VycmVudE5vZGUhPW8udGhpcyQwMS50YWlsOyl0PWEodW4obyksMTMxKSx0LnJhbms9cztmb3IoO3Uuc2l6ZV8wIT0wOylmb3IodD1hKHM1KHUsMCksMTMxKSxyPW5ldyBUKHQuaW5jb21pbmcpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwyNzQpLGM9bi5zb3VyY2UsYy5sZWZ0UG9ydHMubWFwXzAuc2l6ZV8xKCk9PTAmJihjLnJhbms9Uy5NYXRoLm1pbihjLnJhbmssdC5yYW5rLTEpLC0tYy5vdXR3ZWlnaHQsYy5vdXR3ZWlnaHQ9PTAmJmJyKHUsYyx1LnRhaWwucHJldix1LnRhaWwpKX19ZnVuY3Rpb24gSksoZSxuLHIpe3ZhciB0LG8saTtmb3IoaT1uZXcgVChlLm91dGdvaW5nKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMoaSksMjc0KSx0LnRhcmdldC5tYXJrPDAmJnQud2VpZ2h0PjAmJih0LnRhcmdldC5pbndlaWdodC09dC53ZWlnaHQsdC50YXJnZXQuaW53ZWlnaHQ8PTAmJnQudGFyZ2V0Lm91dHdlaWdodD4wJiZMbihuLHQudGFyZ2V0KSk7Zm9yKG89bmV3IFQoZS5pbmNvbWluZyk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDI3NCksdC5zb3VyY2UubWFyazwwJiZ0LndlaWdodD4wJiYodC5zb3VyY2Uub3V0d2VpZ2h0LT10LndlaWdodCx0LnNvdXJjZS5vdXR3ZWlnaHQ8PTAmJnQuc291cmNlLmlud2VpZ2h0PjAmJkxuKHIsdC5zb3VyY2UpKX1wKDE0ODAsMSxXdCx4NWUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gWmduKGEobiwzNikpfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtyaG4odGhpcyxhKG4sMzYpLHIpfTt2YXIgUDVlLE41ZSxBNWUsTDVlLGs1ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5zcGxpbmVzIiwiU3BsaW5lRWRnZVJvdXRlciIsMTQ4MCk7ZnVuY3Rpb24gUVAoZSxuLHIpe3RoaXMuc291cmNlPWUsdGhpcy50YXJnZXQ9bix0aGlzLndlaWdodD1yLGVlKGUub3V0Z29pbmcsdGhpcyksZWUobi5pbmNvbWluZyx0aGlzKX1wKDI3NCwxLHsyNzQ6MX0sUVApLGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNvdXJjZSsiIC0+KCIrdGhpcy53ZWlnaHQrIikgIit0aGlzLnRhcmdldH0sbC53ZWlnaHQ9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5zcGxpbmVzIiwiU3BsaW5lRWRnZVJvdXRlci9EZXBlbmRlbmN5IiwyNzQpO2Z1bmN0aW9uIHVkKCl7dWQ9RixCMD1uZXcgWksoIkxFRlQiLDApLF9nPW5ldyBaSygiUklHSFQiLDEpfWZ1bmN0aW9uIFpLKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gaWhuKGUpe3JldHVybiB1ZCgpLHduKChNNWUoKSxSNWUpLGUpfWZ1bmN0aW9uIGFobigpe3JldHVybiB1ZCgpLFAoSShPNWUsMSksVyw0NjUsMCxbQjAsX2ddKX1wKDQ2NSwyMix7MzoxLDM0OjEsMjI6MSw0NjU6MX0sWkspO3ZhciBCMCxfZyxPNWU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubGF5ZXJlZC5wNWVkZ2VzLnNwbGluZXMiLCJTcGxpbmVFZGdlUm91dGVyL1NpZGVUb1Byb2Nlc3MiLDQ2NSxnbixhaG4saWhuKTtmdW5jdGlvbiBNNWUoKXtNNWU9RixSNWU9eW4oKHVkKCksUChJKE81ZSwxKSxXLDQ2NSwwLFtCMCxfZ10pKSl9dmFyIFI1ZTtmdW5jdGlvbiBENWUoKXt9cCgxNDgxLDEsSW4sRDVlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gX3YoKSwhYShuLDEzMSkuaXNTdHJhaWdodH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMuc3BsaW5lcyIsIlNwbGluZUVkZ2VSb3V0ZXIvbGFtYmRhJDAkVHlwZSIsMTQ4MSk7ZnVuY3Rpb24gRjVlKCl7fXAoMTQ4MiwxLHt9LEY1ZSksbC5hcHBseUFzSW50PWZ1bmN0aW9uKG4pe3JldHVybiBfdigpLGEobiwxMzEpLnJhbmsrMX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMuc3BsaW5lcyIsIlNwbGluZUVkZ2VSb3V0ZXIvbGFtYmRhJDEkVHlwZSIsMTQ4Mik7ZnVuY3Rpb24gejVlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLnNlZ18xPW59cCgxNDgzLDEsSmUsejVlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtlaG4odGhpcy4kJG91dGVyXzAsdGhpcy5zZWdfMSxhKG4sNDIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMuc3BsaW5lcyIsIlNwbGluZUVkZ2VSb3V0ZXIvbGFtYmRhJDIkVHlwZSIsMTQ4Myk7ZnVuY3Rpb24gJDVlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLnNlZ18xPW59cCgxNDg0LDEsSmUsJDVlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtuaG4odGhpcy4kJG91dGVyXzAsdGhpcy5zZWdfMSxhKG4sNDIpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5sYXllcmVkLnA1ZWRnZXMuc3BsaW5lcyIsIlNwbGluZUVkZ2VSb3V0ZXIvbGFtYmRhJDMkVHlwZSIsMTQ4NCk7ZnVuY3Rpb24gQjVlKGUpe2UubGVmdFBvcnRzPW5ldyBCcixlLnJpZ2h0UG9ydHM9bmV3IEJyLGUub3V0Z29pbmc9bmV3IFEsZS5pbmNvbWluZz1uZXcgUSxlLmVkZ2VzPW5ldyBCcixlLmJvdW5kaW5nQm94PW5ldyBpbSxlLmVkZ2VJbmZvcm1hdGlvbj1uZXcgc259ZnVuY3Rpb24gRzVlKGUsbil7dmFyIHIsdCxvO1lyKGUuZWRnZXMsbikscj1uZXcgVzVlLEJuKGUuZWRnZUluZm9ybWF0aW9uLG4sciksci5zdGFydFk9eDcobi5zb3VyY2UpLHIuZW5kWT14NyhuLnRhcmdldCksci5ub3JtYWxTb3VyY2VOb2RlPShfdigpLG89bi5zb3VyY2Uub3duZXIudHlwZV8wLG89PShXZSgpLGtyKXx8bz09TnMpLHIubm9ybWFsVGFyZ2V0Tm9kZT0odD1uLnRhcmdldC5vd25lci50eXBlXzAsdD09a3J8fHQ9PU5zKSxyLmludmVydGVkTGVmdD1uLnNvdXJjZS5zaWRlPT0ocmUoKSxqZSksci5pbnZlcnRlZFJpZ2h0PW4udGFyZ2V0LnNpZGU9PXFlfWZ1bmN0aW9uIHg3KGUpe3JldHVybihyZSgpLGtpKS5jb250YWlucyhlLnNpZGUpP1IoJCh3KGUsKEsoKSx0dykpKSk6a28oUChJKG90LDEpLFgsOCwwLFtlLm93bmVyLnBvcyxlLnBvcyxlLmFuY2hvcl0pKS55XzB9ZnVuY3Rpb24gbGhuKGUsbil7cmV0dXJuIGUubWFyay1uLm1hcmt9ZnVuY3Rpb24gSDVlKGUsbixyLHQpe2UuYm91bmRpbmdCb3gueV8wPVMuTWF0aC5taW4obixyKSxlLmJvdW5kaW5nQm94LmhlaWdodD1TLk1hdGgubWF4KG4sdCktZS5ib3VuZGluZ0JveC55XzAsbjxyPyhlLmNlbnRlckNvbnRyb2xQb2ludFk9LjUqKG4rciksZS5oeXBlckVkZ2VUb3BZUG9zPWc2KmUuY2VudGVyQ29udHJvbFBvaW50WSsuOSpuLGUuaHlwZXJFZGdlQm90dG9tWVBvcz1nNiplLmNlbnRlckNvbnRyb2xQb2ludFkrLjkqcik6KGUuY2VudGVyQ29udHJvbFBvaW50WT0uNSoobit0KSxlLmh5cGVyRWRnZVRvcFlQb3M9ZzYqZS5jZW50ZXJDb250cm9sUG9pbnRZKy45KnQsZS5oeXBlckVkZ2VCb3R0b21ZUG9zPWc2KmUuY2VudGVyQ29udHJvbFBvaW50WSsuOSpuKX1mdW5jdGlvbiBVNWUoZSxuLHIpe3ZhciB0LG87QjVlKHRoaXMpLG49PSh1ZCgpLEIwKT9Zcih0aGlzLmxlZnRQb3J0cyxlLnNvdXJjZSk6WXIodGhpcy5yaWdodFBvcnRzLGUuc291cmNlKSxyPT1CMD9Zcih0aGlzLmxlZnRQb3J0cyxlLnRhcmdldCk6WXIodGhpcy5yaWdodFBvcnRzLGUudGFyZ2V0KSxHNWUodGhpcyxlKSx0PXg3KGUuc291cmNlKSxvPXg3KGUudGFyZ2V0KSxINWUodGhpcyx0LG8sbyksdGhpcy5pc1N0cmFpZ2h0PShfdigpLFMuTWF0aC5hYnModC1vKTwuMil9ZnVuY3Rpb24gUUsoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihCNWUodGhpcykscj09KHVkKCksQjApP1lyKHRoaXMubGVmdFBvcnRzLGUpOllyKHRoaXMucmlnaHRQb3J0cyxlKSxkPWhyLF89VnIscz1uLm1hcF8wLmtleVNldF8wKCkuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KW89YShzLm5leHRfMSgpLDQyKSx1PWEoby5maXJzdCw0NjUpLHQ9YShvLnNlY29uZCwxOCksYz10LnNvdXJjZSxjPT1lJiYoYz10LnRhcmdldCksdT09QjA/WXIodGhpcy5sZWZ0UG9ydHMsYyk6WXIodGhpcy5yaWdodFBvcnRzLGMpLGg9KHJlKCksa2kpLmNvbnRhaW5zKGMuc2lkZSk/UigkKHcoYywoSygpLHR3KSkpKTprbyhQKEkob3QsMSksWCw4LDAsW2Mub3duZXIucG9zLGMucG9zLGMuYW5jaG9yXSkpLnlfMCxkPVMuTWF0aC5taW4oZCxoKSxfPVMuTWF0aC5tYXgoXyxoKTtmb3IoZj0ocmUoKSxraSkuY29udGFpbnMoZS5zaWRlKT9SKCQodyhlLChLKCksdHcpKSkpOmtvKFAoSShvdCwxKSxYLDgsMCxbZS5vd25lci5wb3MsZS5wb3MsZS5hbmNob3JdKSkueV8wLEg1ZSh0aGlzLGYsZCxfKSxpPW4ubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCk7aS5oYXNOZXh0XzAoKTspbz1hKGkubmV4dF8xKCksNDIpLEc1ZSh0aGlzLGEoby5zZWNvbmQsMTgpKTt0aGlzLmlzU3RyYWlnaHQ9ITF9cCgxMzEsMSx7MzQ6MSwxMzE6MX0sVTVlLFFLKSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBsaG4odGhpcyxhKG4sMTMxKSl9LGwuY2VudGVyQ29udHJvbFBvaW50WT0wLGwuaGFuZGxlZD0hMSxsLmh5cGVyRWRnZUJvdHRvbVlQb3M9MCxsLmh5cGVyRWRnZVRvcFlQb3M9MCxsLmluaXRpYWxTZWdtZW50PSExLGwuaW52ZXJzZU9yZGVyPSExLGwuaW53ZWlnaHQ9MCxsLmlzU3RyYWlnaHQ9ITEsbC5pc1dlc3RPZkluaXRpYWxMYXllcj0hMSxsLmxhc3RTZWdtZW50PSExLGwubWFyaz0wLGwub3V0d2VpZ2h0PTAsbC5yYW5rPTAsbC54RGVsdGE9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5zcGxpbmVzIiwiU3BsaW5lU2VnbWVudCIsMTMxKTtmdW5jdGlvbiBXNWUoKXt9cCg0NjgsMSx7NDY4OjF9LFc1ZSksbC5lbmRZPTAsbC5pbnZlcnRlZExlZnQ9ITEsbC5pbnZlcnRlZFJpZ2h0PSExLGwubm9ybWFsU291cmNlTm9kZT0hMSxsLm5vcm1hbFRhcmdldE5vZGU9ITEsbC5zdGFydFk9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLmxheWVyZWQucDVlZGdlcy5zcGxpbmVzIiwiU3BsaW5lU2VnbWVudC9FZGdlSW5mb3JtYXRpb24iLDQ2OCk7ZnVuY3Rpb24gUDcoZSxuLHIpe3JldHVybiBTLk1hdGguYWJzKG4tZSk8VmJ8fFMuTWF0aC5hYnMoci1lKTxWYj8hMDpuLWU+VmI/ZS1yPlZiOnItZT5WYn1mdW5jdGlvbiBlWChlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIEVpZTtkZWZhdWx0OmNhc2UgMjpyZXR1cm4gMDtjYXNlIDM6cmV0dXJuIGQ2O2Nhc2UgNDpyZXR1cm4gWUZ9fWZ1bmN0aW9uIGo1ZShlKXt2YXIgbjtuPWEodyhhKFZhKGUubm9kZXMsMCksNDApLChGbygpLExYKSksMTA3KSxqKGUsKGxyKCksaHcpLG5ldyBZKDAsMCkpLFY1ZShuZXcgWDMsZSxuLmxlZnQrbi5yaWdodC1SKCQodyhlLHo3KSkpLG4udG9wXzArbi5ib3R0b20tUigkKHcoZSwkNykpKSl9ZnVuY3Rpb24gblgoZSxuLHIpe3ZhciB0LG8saTtpZighZS52aXNpdGVkW24uaWRfMF0pe2ZvcihlLnZpc2l0ZWRbbi5pZF8wXT0hMCx0PXIsIXQmJih0PW5ldyBYMyksTG4odC5ub2RlcyxuKSxpPWUuaW5jaWRlbmNlW24uaWRfMF0uaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDY1KSxvLnNvdXJjZSE9biYmblgoZSxvLnNvdXJjZSx0KSxvLnRhcmdldCE9biYmblgoZSxvLnRhcmdldCx0KSxMbih0LmVkZ2VzLG8pO3JldHVybiB0fXJldHVybiBudWxsfWZ1bmN0aW9uIHNobihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKG89bi5ub2Rlcy5zaXplXzAsZS5pbmNpZGVuY2U9QihqYSxVZCwxNSxvLDAsMSksZS52aXNpdGVkPUIoeWEseHUsMjgsbywxNiwxKSxzPWRuKG4ubm9kZXMsMCk7cy5jdXJyZW50Tm9kZSE9cy50aGlzJDAxLnRhaWw7KWk9YSh1bihzKSw0MCksZS5pbmNpZGVuY2VbaS5pZF8wXT1uZXcgcHI7Zm9yKHQ9ZG4obi5lZGdlcywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDY1KSxlLmluY2lkZW5jZVtyLnNvdXJjZS5pZF8wXS5hZGRfMihyKSxlLmluY2lkZW5jZVtyLnRhcmdldC5pZF8wXS5hZGRfMihyKX1mdW5jdGlvbiBWNWUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQ7Zm9yKGM9bmV3IFkocix0KSxydChjLGEodyhuLChscigpLGh3KSksOCkpLGQ9ZG4obi5ub2RlcywwKTtkLmN1cnJlbnROb2RlIT1kLnRoaXMkMDEudGFpbDspXz1hKHVuKGQpLDQwKSxLbihfLnBvcyxjKSxMbihlLm5vZGVzLF8pO2Zvcih1PWEoVG8oVUcobmV3IFNlKG51bGwsbmV3IHhlKG4uZWRnZXMsMTYpKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSksMTUpLml0ZXJhdG9yXzAoKTt1Lmhhc05leHRfMCgpOyl7Zm9yKHM9YSh1Lm5leHRfMSgpLDY1KSxpPWRuKHMuYmVuZFBvaW50cywwKTtpLmN1cnJlbnROb2RlIT1pLnRoaXMkMDEudGFpbDspbz1hKHVuKGkpLDgpLG8ueF8wKz1jLnhfMCxvLnlfMCs9Yy55XzA7TG4oZS5lZGdlcyxzKX19ZnVuY3Rpb24gdWhuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uO2lmKGUuYXJyYXkubGVuZ3RoPT0xKXJldHVybiBqNWUoKEFlKDAsZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVswXSwxMjEpKSksQWUoMCxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzBdLDEyMSk7aWYoZS5hcnJheS5sZW5ndGg8PTApcmV0dXJuIG5ldyBYMztmb3IoYz1uZXcgVChlKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspe2ZvcihzPWEoQyhjKSwxMjEpLEE9MCx5PXFuLEU9cW4saD1idCxtPWJ0LHg9ZG4ocy5ub2RlcywwKTt4LmN1cnJlbnROb2RlIT14LnRoaXMkMDEudGFpbDspdj1hKHVuKHgpLDQwKSxBKz1hKHcodiwoRm8oKSxpTikpLDE3KS52YWx1ZV8wLHk9Uy5NYXRoLm1pbih5LHYucG9zLnhfMCksRT1TLk1hdGgubWluKEUsdi5wb3MueV8wKSxoPVMuTWF0aC5tYXgoaCx2LnBvcy54XzArdi5zaXplXzAueF8wKSxtPVMuTWF0aC5tYXgobSx2LnBvcy55XzArdi5zaXplXzAueV8wKTtqKHMsKEZvKCksaU4pLEooQSkpLGoocywobHIoKSxodyksbmV3IFkoeSxFKSksaihzLFozLG5ldyBZKGgsbSkpfWZvcihOZSgpLERyKGUsbmV3IFk1ZSksSD1uZXcgWDMsZ28oSCwoQWUoMCxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5WzBdLDk2KSkpLGY9MCxEZT0wLF89bmV3IFQoZSk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKF8pLDEyMSkscT1ydChDdChhKHcocywobHIoKSxaMykpLDgpKSxhKHcocyxodyksOCkpLGY9Uy5NYXRoLm1heChmLHEueF8wKSxEZSs9cS54XzAqcS55XzA7Zm9yKGY9Uy5NYXRoLm1heChmLFMuTWF0aC5zcXJ0KERlKSpSKCQodyhILChGbygpLGQ4ZSkpKSkpLG5lPVIoJCh3KEgsVTcpKSksRmU9MCxubj0wLGQ9MCxuPW5lLHU9bmV3IFQoZSk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDEyMSkscT1ydChDdChhKHcocywobHIoKSxaMykpLDgpKSxhKHcocyxodyksOCkpLEZlK3EueF8wPmYmJihGZT0wLG5uKz1kK25lLGQ9MCksVjVlKEgscyxGZSxubiksbj1TLk1hdGgubWF4KG4sRmUrcS54XzApLGQ9Uy5NYXRoLm1heChkLHEueV8wKSxGZSs9cS54XzArbmU7Zm9yKE09bmV3IHNuLHI9bmV3IHNuLHdlPW5ldyBUKGUpO3dlLmk8d2UudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcih2ZT1hKEMod2UpLDEyMSksdD1hZShpZSh3KHZlLChGbigpLHhUKSkpKSxrPXZlLnByb3BlcnR5TWFwP3ZlLnByb3BlcnR5TWFwOmt1LGk9ay5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDQ0KSx5aShNLG8uZ2V0S2V5KCkpP0QoYShvLmdldEtleSgpLDE0OSkuZ2V0RGVmYXVsdCgpKSE9PUQoby5nZXRWYWx1ZSgpKSYmKHQmJnlpKHIsby5nZXRLZXkoKSk/KG5jKCksIiIrYShvLmdldEtleSgpLDE0OSkuZ2V0SWQoKSk6KEJuKE0sYShvLmdldEtleSgpLDE0OSksby5nZXRWYWx1ZSgpKSxqKEgsYShvLmdldEtleSgpLDE0OSksby5nZXRWYWx1ZSgpKSx0JiZCbihyLGEoby5nZXRLZXkoKSwxNDkpLG8uZ2V0VmFsdWUoKSkpKTooQm4oTSxhKG8uZ2V0S2V5KCksMTQ5KSxvLmdldFZhbHVlKCkpLGooSCxhKG8uZ2V0S2V5KCksMTQ5KSxvLmdldFZhbHVlKCkpKTtyZXR1cm4gajVlKEgpLEh9ZnVuY3Rpb24gY2huKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztpZihfPWllKHcobiwoRm8oKSx2OGUpKSksXz09bnVsbHx8KFZlKF8pLF8pKXtmb3Ioc2huKGUsbiksbz1uZXcgUSxjPWRuKG4ubm9kZXMsMCk7Yy5jdXJyZW50Tm9kZSE9Yy50aGlzJDAxLnRhaWw7KXM9YSh1bihjKSw0MCkscj1uWChlLHMsbnVsbCksciYmKGdvKHIsbiksUmUoby5hcnJheSxyKSk7aWYoZS5pbmNpZGVuY2U9bnVsbCxlLnZpc2l0ZWQ9bnVsbCxvLmFycmF5Lmxlbmd0aD4xKWZvcih0PW5ldyBUKG8pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmb3Iocj1hKEModCksMTIxKSxpPTAsdT1kbihyLm5vZGVzLDApO3UuY3VycmVudE5vZGUhPXUudGhpcyQwMS50YWlsOylzPWEodW4odSksNDApLHMuaWRfMD1pKys7cmV0dXJuIG99cmV0dXJuIFRzKFAoSShQaG4sMSksZmllLDEyMSwwLFtuXSkpfWZ1bmN0aW9uIHE1ZSgpe31wKDExOTgsMSx7fSxxNWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlIiwiQ29tcG9uZW50c1Byb2Nlc3NvciIsMTE5OCk7ZnVuY3Rpb24gX2huKGUsbil7dmFyIHIsdCxvO3JldHVybiByPWEodyhuLChGbygpLGlOKSksMTcpLnZhbHVlXzAtYSh3KGUsaU4pLDE3KS52YWx1ZV8wLHI9PTA/KHQ9cnQoQ3QoYSh3KGUsKGxyKCksWjMpKSw4KSksYSh3KGUsaHcpLDgpKSxvPXJ0KEN0KGEodyhuLFozKSw4KSksYSh3KG4saHcpLDgpKSxpcih0LnhfMCp0LnlfMCxvLnhfMCpvLnlfMCkpOnJ9ZnVuY3Rpb24gWTVlKCl7fXAoMTE5OSwxLE5uLFk1ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gX2huKGEobiwxMjEpLGEociwxMjEpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIkNvbXBvbmVudHNQcm9jZXNzb3IvMSIsMTE5OSk7ZnVuY3Rpb24gZGhuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE07Zm9yKG89YSh3KGUsKGxyKCkseXYpKSwyNyksXz1xbixkPXFuLHU9YnQsYz1idCxrPWRuKGUubm9kZXMsMCk7ay5jdXJyZW50Tm9kZSE9ay50aGlzJDAxLnRhaWw7KXg9YSh1bihrKSw0MCksbT14LnBvcyx5PXguc2l6ZV8wLF89Uy5NYXRoLm1pbihfLG0ueF8wLXkueF8wLzIpLGQ9Uy5NYXRoLm1pbihkLG0ueV8wLXkueV8wLzIpLHU9Uy5NYXRoLm1heCh1LG0ueF8wK3kueF8wLzIpLGM9Uy5NYXRoLm1heChjLG0ueV8wK3kueV8wLzIpO2ZvcihoPWEoVihvLChGbygpLExYKSksMTA3KSxBPWRuKGUubm9kZXMsMCk7QS5jdXJyZW50Tm9kZSE9QS50aGlzJDAxLnRhaWw7KXg9YSh1bihBKSw0MCksZj13KHgseXYpLEwoZiwyMDcpJiYoaT1hKGYsMjcpLF9sKGkseC5wb3MueF8wLHgucG9zLnlfMCksWlQoaSx4KSk7Zm9yKHY9ZG4oZS5lZGdlcywwKTt2LmN1cnJlbnROb2RlIT12LnRoaXMkMDEudGFpbDspRT1hKHVuKHYpLDY1KSx0PWEodyhFLHl2KSw3NCksdCYmKG49RS5iZW5kUG9pbnRzLHI9RmcodCwhMCwhMCksVlQobixyKSk7TT11LV8rKGgubGVmdCtoLnJpZ2h0KSxzPWMtZCsoaC50b3BfMCtoLmJvdHRvbSksYWUoaWUoVihvLChGbigpLFdmKSkpKXx8d2QobyxNLHMsITEsITEpLG5yKG8sVGcsTS0oaC5sZWZ0K2gucmlnaHQpKSxucihvLENnLHMtKGgudG9wXzAraC5ib3R0b20pKX1mdW5jdGlvbiBmaG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfO2ZvcihzPW5ldyBZZSgoIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSk7cy5jdXJzb3IhPXMudGhpcyQwMV8yLnNpemVfMSgpOylmb3IoaT1hKGVuKHMpLDI3KSxvPW5ldyBYZShRZShFYyhpKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSw3NCksIWxTKHQpJiYhbFModCkmJiFiZCh0KSYmKGM9YShfbyhqdChyLmhhc2hDb2RlTWFwLGkpKSw0MCksXz1hKEtlKHIseW8oYShPKCghdC50YXJnZXRzJiYodC50YXJnZXRzPW5ldyBMZShhbix0LDUsOCkpLHQudGFyZ2V0cyksMCksODQpKSksNDApLGMmJl8mJih1PW5ldyBvWChjLF8pLGoodSwobHIoKSx5diksdCksZ28odSx0KSxMbihjLm91dGdvaW5nRWRnZXMsdSksTG4oXy5pbmNvbWluZ0VkZ2VzLHUpLExuKG4uZWRnZXMsdSkpKX1mdW5jdGlvbiBwaG4oZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKGk9MCxvPW5ldyBZZSgoIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSk7by5jdXJzb3IhPW8udGhpcyQwMV8yLnNpemVfMSgpOyl0PWEoZW4obyksMjcpLHM9IiIsKCF0LmxhYmVscyYmKHQubGFiZWxzPW5ldyBVKFF0LHQsMSw3KSksdC5sYWJlbHMpLnNpemVfMD09MHx8KHM9YShPKCghdC5sYWJlbHMmJih0LmxhYmVscz1uZXcgVShRdCx0LDEsNykpLHQubGFiZWxzKSwwKSwxMzUpLnRleHRfMCksdT1uZXcgTDcoaSsrLG4scyksZ28odSx0KSxqKHUsKGxyKCkseXYpLHQpLHUucG9zLnlfMD10LnlfMCt0LmhlaWdodC8yLHUuc2l6ZV8wLnhfMD1TLk1hdGgubWF4KHQud2lkdGhfMCwxKSx1LnBvcy54XzA9dC54XzArdC53aWR0aF8wLzIsdS5zaXplXzAueV8wPVMuTWF0aC5tYXgodC5oZWlnaHQsMSksTG4obi5ub2Rlcyx1KSxkaShyLmhhc2hDb2RlTWFwLHQsdSl9ZnVuY3Rpb24gZ2huKGUsbixyKXtyZXR1cm4gci5iZWdpbigiVHJlZSBsYXlvdXQiLDEpLHZUKGUuYWxnb3JpdGhtQXNzZW1ibGVyKSxncyhlLmFsZ29yaXRobUFzc2VtYmxlciwoS2goKSxuTiksbk4pLGdzKGUuYWxnb3JpdGhtQXNzZW1ibGVyLGR2LGR2KSxncyhlLmFsZ29yaXRobUFzc2VtYmxlcixmdixmdiksZ3MoZS5hbGdvcml0aG1Bc3NlbWJsZXIscHYscHYpLGUuYWxnb3JpdGhtPUVUKGUuYWxnb3JpdGhtQXNzZW1ibGVyLG4pLGhobihlLG4sci5zdWJUYXNrKDEpKSxyLmRvbmVfMSgpLG59ZnVuY3Rpb24gaGhuKGUsbixyKXt2YXIgdCxvLGk7Zm9yKHQ9ciwhdCYmKHQ9bmV3IGdtKSx0LmJlZ2luKCJMYXlvdXQiLGUuYWxnb3JpdGhtLmFycmF5Lmxlbmd0aCksaT1uZXcgVChlLmFsZ29yaXRobSk7aS5pPGkudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtpZihvPWEoQyhpKSw0NyksdC5pc0NhbmNlbGVkKCkpcmV0dXJuO28ucHJvY2VzcyhuLHQuc3ViVGFzaygxKSl9dC5kb25lXzEoKX1mdW5jdGlvbiBLNWUoKXt0aGlzLmFsZ29yaXRobUFzc2VtYmxlcj1uZXcgQXYoclgpfXAoMTE5NywxLHt9LEs1ZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJNclRyZWUiLDExOTcpO2Z1bmN0aW9uIEtoKCl7S2g9RixuTj1uZXcgZU4oIlAxX1RSRUVJRklDQVRJT04iLDApLGR2PW5ldyBlTigiUDJfTk9ERV9PUkRFUklORyIsMSksZnY9bmV3IGVOKCJQM19OT0RFX1BMQUNFTUVOVCIsMikscHY9bmV3IGVOKCJQNF9FREdFX1JPVVRJTkciLDMpfWZ1bmN0aW9uIFg1ZShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG5ldyBPOGU7Y2FzZSAxOnJldHVybiBuZXcgRjhlO2Nhc2UgMjpyZXR1cm4gbmV3IFk4ZTtjYXNlIDM6cmV0dXJuIG5ldyBYOGU7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgbGF5b3V0IHBoYXNlICIrKGUubmFtZV8wIT1udWxsP2UubmFtZV8wOiIiK2Uub3JkaW5hbCkpKX19ZnVuY3Rpb24gZU4oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBtaG4oZSl7cmV0dXJuIEtoKCksd24oKEo1ZSgpLFo1ZSksZSl9ZnVuY3Rpb24geWhuKCl7cmV0dXJuIEtoKCksUChJKHJYLDEpLFcsNDA1LDAsW25OLGR2LGZ2LHB2XSl9cCg0MDUsMjIsezM6MSwzNDoxLDIyOjEsNDA1OjEsMTg4OjEsMTk2OjF9LGVOKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFg1ZSh0aGlzKX0sbC5jcmVhdGVfMj1mdW5jdGlvbigpe3JldHVybiBYNWUodGhpcyl9O3ZhciBuTixkdixmdixwdixyWD1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJUcmVlTGF5b3V0UGhhc2VzIiw0MDUsZ24seWhuLG1obik7ZnVuY3Rpb24gSjVlKCl7SjVlPUYsWjVlPXluKChLaCgpLFAoSShyWCwxKSxXLDQwNSwwLFtuTixkdixmdixwdl0pKSl9dmFyIFo1ZTtmdW5jdGlvbiBRNWUoKXt0aGlzLmtsYXlUcmVlPW5ldyBLNWUsdGhpcy5jb21wb25lbnRzUHJvY2Vzc29yPW5ldyBxNWV9cCgxMTEyLDIwNSxnXyxRNWUpLGwubGF5b3V0PWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtmb3IoYWUoaWUoVihuLChGbygpLEFYKSkpKXx8VUMoKHQ9bmV3IGFFKChFZCgpLG5ldyB2ZChuKSkpLHQpKSx1PXIuc3ViVGFzayhoNiksdS5iZWdpbigiYnVpbGQgdEdyYXBoIiwxKSxjPShfPW5ldyBYMyxnbyhfLG4pLGooXywobHIoKSx5diksbiksZD1uZXcgc24scGhuKG4sXyxkKSxmaG4obixfLGQpLF8pLHUuZG9uZV8xKCksdT1yLnN1YlRhc2soaDYpLHUuYmVnaW4oIlNwbGl0IGdyYXBoIiwxKSxzPWNobih0aGlzLmNvbXBvbmVudHNQcm9jZXNzb3IsYyksdS5kb25lXzEoKSxpPW5ldyBUKHMpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwxMjEpLGdobih0aGlzLmtsYXlUcmVlLG8sci5zdWJUYXNrKC41OTk5OTk5OTQwMzk1MzU1L3MuYXJyYXkubGVuZ3RoKSk7dT1yLnN1YlRhc2soaDYpLHUuYmVnaW4oIlBhY2sgY29tcG9uZW50cyIsMSksYz11aG4ocyksdS5kb25lXzEoKSx1PXIuc3ViVGFzayhoNiksdS5iZWdpbigiQXBwbHkgbGF5b3V0IHJlc3VsdHMiLDEpLGRobihjKSx1LmRvbmVfMSgpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVMYXlvdXRQcm92aWRlciIsMTExMik7ZnVuY3Rpb24gd2huKGUsbil7dmFyIHIsdCxvO2ZvcihvPW5ldyBRLHQ9ZG4obi5lZGdlcywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDY1KSxyLnRhcmdldC5pZF8wPT1lLmlkXzAmJkQodyhyLnNvdXJjZSwoRm8oKSxndSkpKSE9PUQodyhyLnRhcmdldCxndSkpJiYhTXAobmV3IFNlKG51bGwsbmV3IHhlKG8sMTYpKSxuZXcgc2tlKHIpKSYmUmUoby5hcnJheSxyKTtyZXR1cm4gRHIobyxuZXcgdWtlKSxvfWZ1bmN0aW9uIEVobihlLG4pe3ZhciByLHQsbztmb3Iobz1uZXcgUSx0PWRuKG4uZWRnZXMsMCk7dC5jdXJyZW50Tm9kZSE9dC50aGlzJDAxLnRhaWw7KXI9YSh1bih0KSw2NSksci5zb3VyY2UuaWRfMD09ZS5pZF8wJiYhVGUoci5zb3VyY2UubGFiZWxfMCwiU1VQRVJfUk9PVCIpJiZEKHcoci5zb3VyY2UsKEZvKCksZ3UpKSkhPT1EKHcoci50YXJnZXQsZ3UpKSYmIU1wKG5ldyBTZShudWxsLG5ldyB4ZShvLDE2KSksbmV3IGNrZShyKSkmJlJlKG8uYXJyYXkscik7cmV0dXJuIERyKG8sbmV3IF9rZSksb31mdW5jdGlvbiBndyhlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDQ6cmV0dXJuIG5ldyBZKDAsLTEpO2Nhc2UgMTpyZXR1cm4gbmV3IFkoMSwwKTtjYXNlIDI6cmV0dXJuIG5ldyBZKC0xLDApO2RlZmF1bHQ6cmV0dXJuIG5ldyBZKDAsMSl9fWZ1bmN0aW9uIHRYKGUsbil7dmFyIHIsdCxvLGk7aWYoMDwoTChlLDE2KT9hKGUsMTYpLnNpemVfMSgpOlp1KGUuaXRlcmF0b3JfMCgpKSkpe2lmKG89biwxPG8pe2ZvcigtLW8saT1uZXcgcmtlLHQ9ZS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksNDApLGk9TmEoUChJKHhhLDEpLE1lLDIwLDAsW2ksbmV3IGNjKHIpXSkpO3JldHVybiB0WChpLG8pfWlmKG88MCl7Zm9yKGk9bmV3IHRrZSx0PWUuaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9YSh0Lm5leHRfMSgpLDQwKSxpPU5hKFAoSSh4YSwxKSxNZSwyMCwwLFtpLG5ldyBjYyhyKV0pKTtpZigwPChMKGksMTYpP2EoaSwxNikuc2l6ZV8xKCk6WnUoaS5pdGVyYXRvcl8wKCkpKSlyZXR1cm4gdFgoaSxvKX19cmV0dXJuIGEoaEkoZS5pdGVyYXRvcl8wKCkpLDQwKX1mdW5jdGlvbiB2aG4oZSxuKXt2YXIgcix0LG8saSxzO3JldHVybiByPWd3KGEodyhuLChGbygpLF9kKSksODgpKSxlLmluY29taW5nRWRnZXMuc2l6ZV8wPT0wP251bGw6KHM9YShUbyhwbyhuZXcgU2UobnVsbCxuZXcgeGUoZS5pbmNvbWluZ0VkZ2VzLDE2KSksbmV3IGRrZSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsWyhyYSgpLENvKV0pKSksMTUpLGk9YShUbyhKbihuZXcgU2UobnVsbCxuZXcgeGUobi5ub2RlcywxNikpLG5ldyBpa2UocykpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFtDb10pKSksMTUpLG89JCh2YShjZihwbyhpLnN0cmVhbSgpLG5ldyBha2UocikpLChMMSgpLEwxKCksbmspKSkpLHQ9YSh2YSh4eShKbihpLnN0cmVhbSgpLG5ldyBsa2UocixvKSkpKSw0MCksdCl9ZnVuY3Rpb24gZWtlKGUsbil7cmV0dXJuIGFtKGd3KGEodyhuLChGbygpLF9kKSksODgpKSxuZXcgWShlLnRhcmdldC5wb3MueF8wLWUuc291cmNlLnBvcy54XzAsZS50YXJnZXQucG9zLnlfMC1lLnNvdXJjZS5wb3MueV8wKSk8PTB9ZnVuY3Rpb24gU2huKGUsbil7cmV0dXJuIGFtKG5ldyBZKG4ucG9zLnhfMCtuLnNpemVfMC54XzAvMixuLnBvcy55XzArbi5zaXplXzAueV8wLzIpLGUpfWZ1bmN0aW9uIENobihlLG4scil7cmV0dXJuIGFtKG5ldyBZKHIucG9zLnhfMCtyLnNpemVfMC54XzAvMixyLnBvcy55XzArci5zaXplXzAueV8wLzIpLGUpPT0oVmUobiksbil9ZnVuY3Rpb24gVGhuKGUsbil7cmV0dXJuIFRlKG4uc291cmNlJiZuLnRhcmdldD9YXyhuLnNvdXJjZSkrIi0+IitYXyhuLnRhcmdldCk6ImVfIit1cihuKSxlLnNvdXJjZSYmZS50YXJnZXQ/WF8oZS5zb3VyY2UpKyItPiIrWF8oZS50YXJnZXQpOiJlXyIrdXIoZSkpfWZ1bmN0aW9uIGJobihlLG4pe3JldHVybiBpcihlLnNvdXJjZS5wb3MueF8wLG4uc291cmNlLnBvcy54XzApfWZ1bmN0aW9uIElobihlLG4pe3JldHVybiBUZShuLnNvdXJjZSYmbi50YXJnZXQ/WF8obi5zb3VyY2UpKyItPiIrWF8obi50YXJnZXQpOiJlXyIrdXIobiksZS5zb3VyY2UmJmUudGFyZ2V0P1hfKGUuc291cmNlKSsiLT4iK1hfKGUudGFyZ2V0KToiZV8iK3VyKGUpKX1mdW5jdGlvbiB4aG4oZSxuKXtyZXR1cm4gaXIoZS50YXJnZXQucG9zLnhfMCxuLnRhcmdldC5wb3MueF8wKX1mdW5jdGlvbiBua2UoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfO3U9ci54XzAvMixpPXIueV8wLzIsdD1TLk1hdGguYWJzKG4ueF8wLWUueF8wKSxvPVMuTWF0aC5hYnMobi55XzAtZS55XzApLGM9MSxfPTEsdD51JiYoYz11L3QpLG8+aSYmKF89aS9vKSxzPVMuTWF0aC5taW4oYyxfKSxlLnhfMCs9cyoobi54XzAtZS54XzApLGUueV8wKz1zKihuLnlfMC1lLnlfMCl9ZnVuY3Rpb24gcmtlKCl7fXAoMTg5NCwxLFR1LHJrZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksZHkoKSxmeX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJUcmVlVXRpbC8xIiwxODk0KTtmdW5jdGlvbiB0a2UoKXt9cCgxODk1LDEsVHUsdGtlKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxkeSgpLGZ5fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVVdGlsLzIiLDE4OTUpO2Z1bmN0aW9uIG9rZSgpe31wKDE4ODUsMSxJbixva2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhZShpZSh3KGEobiw0MCksKGxyKCksRzApKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVVdGlsL2xhbWJkYSQwJFR5cGUiLDE4ODUpO2Z1bmN0aW9uIGlrZShlKXt0aGlzLnNvdXJjZXNfMD1lfXAoMTg5MSwxLEluLGlrZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc291cmNlc18wLmNvbnRhaW5zKGEobiw0MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVVdGlsL2xhbWJkYSQxMCRUeXBlIiwxODkxKTtmdW5jdGlvbiBha2UoZSl7dGhpcy5kaXJWZWNfMD1lfXAoMTg5MiwxLHt9LGFrZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBTaG4odGhpcy5kaXJWZWNfMCxhKG4sNDApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJUcmVlVXRpbC9sYW1iZGEkMTEkVHlwZSIsMTg5Mik7ZnVuY3Rpb24gbGtlKGUsbil7dGhpcy5kaXJWZWNfMD1lLHRoaXMubG93ZXN0UGFyZW50UG9zXzE9bn1wKDE4OTMsMSxJbixsa2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBDaG4odGhpcy5kaXJWZWNfMCx0aGlzLmxvd2VzdFBhcmVudFBvc18xLGEobiw0MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVVdGlsL2xhbWJkYSQxMiRUeXBlIiwxODkzKTtmdW5jdGlvbiBza2UoZSl7dGhpcy5lXzA9ZX1wKDE4ODYsMSxJbixza2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBUaG4odGhpcy5lXzAsYShuLDY1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlIiwiVHJlZVV0aWwvbGFtYmRhJDMkVHlwZSIsMTg4Nik7ZnVuY3Rpb24gdWtlKCl7fXAoMTg4NywxLE5uLHVrZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gYmhuKGEobiw2NSksYShyLDY1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJUcmVlVXRpbC9sYW1iZGEkNCRUeXBlIiwxODg3KTtmdW5jdGlvbiBja2UoZSl7dGhpcy5lXzA9ZX1wKDE4ODgsMSxJbixja2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBJaG4odGhpcy5lXzAsYShuLDY1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlIiwiVHJlZVV0aWwvbGFtYmRhJDckVHlwZSIsMTg4OCk7ZnVuY3Rpb24gX2tlKCl7fXAoMTg4OSwxLE5uLF9rZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4geGhuKGEobiw2NSksYShyLDY1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUiLCJUcmVlVXRpbC9sYW1iZGEkOCRUeXBlIiwxODg5KTtmdW5jdGlvbiBka2UoKXt9cCgxODkwLDEse30sZGtlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIGEobiw2NSkuc291cmNlfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZSIsIlRyZWVVdGlsL2xhbWJkYSQ5JFR5cGUiLDE4OTApLHAoNTA4LDEzNyx7MzoxLDUwODoxLDk2OjEsMTM3OjF9KSxsLmlkXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5ncmFwaCIsIlRHcmFwaEVsZW1lbnQiLDUwOCk7ZnVuY3Rpb24gb1goZSxuKXtuZXcgcHIsdGhpcy5iZW5kUG9pbnRzPW5ldyBqaSx0aGlzLnNvdXJjZT1lLHRoaXMudGFyZ2V0PW59cCg2NSw1MDgsezM6MSw2NToxLDUwODoxLDk2OjEsMTM3OjF9LG9YKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zb3VyY2UmJnRoaXMudGFyZ2V0P1hfKHRoaXMuc291cmNlKSsiLT4iK1hfKHRoaXMudGFyZ2V0KToiZV8iK3VyKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5ncmFwaCIsIlRFZGdlIiw2NSk7ZnVuY3Rpb24gWDMoKXt0aGlzLm5vZGVzPW5ldyBwcix0aGlzLmVkZ2VzPW5ldyBwcix0aGlzLm5vZGVzPW5ldyBwcix0aGlzLmVkZ2VzPW5ldyBwcn1wKDEyMSwxMzcsezM6MSwxMjE6MSw5NjoxLDEzNzoxfSxYMyksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtmb3IoaT1udWxsLG89ZG4odGhpcy5ub2RlcywwKTtvLmN1cnJlbnROb2RlIT1vLnRoaXMkMDEudGFpbDspdD1hKHVuKG8pLDQwKSxpKz0odC5sYWJlbF8wPT1udWxsfHx0LmxhYmVsXzAubGVuZ3RoPT0wPyJuXyIrdC5pZF8wOiJuXyIrdC5sYWJlbF8wKStgCmA7Zm9yKHI9ZG4odGhpcy5lZGdlcywwKTtyLmN1cnJlbnROb2RlIT1yLnRoaXMkMDEudGFpbDspbj1hKHVuKHIpLDY1KSxpKz0obi5zb3VyY2UmJm4udGFyZ2V0P1hfKG4uc291cmNlKSsiLT4iK1hfKG4udGFyZ2V0KToiZV8iK3VyKG4pKStgCmA7cmV0dXJuIGl9O3ZhciBQaG49Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuZ3JhcGgiLCJUR3JhcGgiLDEyMSk7cCg2NDMsNTA4LHszOjEsNTA4OjEsNjQzOjEsOTY6MSwxMzc6MX0pLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmdyYXBoIiwiVFNoYXBlIiw2NDMpO2Z1bmN0aW9uIE43KGUpe3ZhciBuLHIsdDtmb3Iobj1uZXcgcHIsdD1kbihlLm91dGdvaW5nRWRnZXMsMCk7dC5jdXJyZW50Tm9kZSE9dC50aGlzJDAxLnRhaWw7KXI9YSh1bih0KSw2NSksTG4obixyLnRhcmdldCk7cmV0dXJuIG59ZnVuY3Rpb24gQTcoZSl7dmFyIG47cmV0dXJuIG49ZS5pbmNvbWluZ0VkZ2VzLG4uc2l6ZV8wPT0wP251bGw6YShWYShuLDApLDY1KS5zb3VyY2V9ZnVuY3Rpb24gWF8oZSl7cmV0dXJuIGUubGFiZWxfMD09bnVsbHx8ZS5sYWJlbF8wLmxlbmd0aD09MD8ibl8iK2UuaWRfMDoibl8iK2UubGFiZWxfMH1mdW5jdGlvbiBMNyhlLG4scil7dGhpcy5pZF8wPWUsdGhpcy5wb3M9bmV3IG10LHRoaXMuc2l6ZV8wPW5ldyBtdCx0aGlzLm91dGdvaW5nRWRnZXM9bmV3IHByLHRoaXMuaW5jb21pbmdFZGdlcz1uZXcgcHIsdGhpcy5ncmFwaF8wPW4sdGhpcy5sYWJlbF8wPXJ9cCg0MCw2NDMsezM6MSw1MDg6MSw0MDoxLDY0MzoxLDk2OjEsMTM3OjF9LEw3KSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gWF8odGhpcyl9O3ZhciByTj1nKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5ncmFwaCIsIlROb2RlIiw0MCk7ZnVuY3Rpb24gY2MoZSl7dGhpcy50aGlzJDAxPWV9cCgyMzYsMSxUdSxjYyksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49ZG4odGhpcy50aGlzJDAxLm91dGdvaW5nRWRnZXMsMCksbmV3IGRnKG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5ncmFwaCIsIlROb2RlLzIiLDIzNik7ZnVuY3Rpb24gZGcoZSl7dGhpcy52YWwkZWRnZXNJdGVyMj1lfXAoMzI5LDEsc3QsZGcpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBhKHVuKHRoaXMudmFsJGVkZ2VzSXRlcjIpLDY1KS50YXJnZXR9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIERDKHRoaXMudmFsJGVkZ2VzSXRlcjIpfSxsLnJlbW92ZT1mdW5jdGlvbigpe2FrKHRoaXMudmFsJGVkZ2VzSXRlcjIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5ncmFwaCIsIlROb2RlLzIvMSIsMzI5KTtmdW5jdGlvbiBOaG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihvPWEodyhlLChGbygpLF9kKSksODgpLGQ9bz09KFdyKCksYW8pfHxvPT1tbz8kczptbyxyPWEoVG8oSm4obmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgU2tlKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksYz1hKFRvKHBvKHIuc3RyZWFtKCksbmV3IENrZShuKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsW0NvXSkpKSwxNSksYy5hZGRBbGwoYShUbyhwbyhyLnN0cmVhbSgpLG5ldyBUa2UobikpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFtDb10pKSksMTYpKSxjLnNvcnRfMChuZXcgYmtlKGQpKSxoPW5ldyBGYyhuZXcgSWtlKG8pKSx0PW5ldyBzbix1PWMuaXRlcmF0b3JfMCgpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDI0MCksXz1hKHMuZmlyc3QsNDApLGFlKGllKHMudGhpcmQpKT8oaC5tYXBfMC5wdXQoXywoemUoKSxTMCkpPT1udWxsLG5ldyBUeShoLm1hcF8wLmhlYWRNYXAoXywhMSkpLm1hcF8wLnNpemVfMSgpPjAmJkJuKHQsXyxhKG5ldyBUeShoLm1hcF8wLmhlYWRNYXAoXywhMSkpLm1hcF8wLmxhc3RLZXkoKSw0MCkpLG5ldyBUeShoLm1hcF8wLnRhaWxNYXAoXywhMCkpLm1hcF8wLnNpemVfMSgpPjEmJkJuKHQsZmtlKGgsXyksXykpOihuZXcgVHkoaC5tYXBfMC5oZWFkTWFwKF8sITEpKS5tYXBfMC5zaXplXzEoKT4wJiYoaT1hKG5ldyBUeShoLm1hcF8wLmhlYWRNYXAoXywhMSkpLm1hcF8wLmxhc3RLZXkoKSw0MCksRChpKT09PUQoX28oanQodC5oYXNoQ29kZU1hcCxfKSkpJiZhKHcoXywobHIoKSxSNykpLDE1KS5hZGRfMihpKSksbmV3IFR5KGgubWFwXzAudGFpbE1hcChfLCEwKSkubWFwXzAuc2l6ZV8xKCk+MSYmKGY9ZmtlKGgsXyksRChfbyhqdCh0Lmhhc2hDb2RlTWFwLGYpKSk9PT1EKF8pJiZhKHcoZiwobHIoKSxSNykpLDE1KS5hZGRfMihfKSksaC5tYXBfMC5yZW1vdmVfMChfKSE9bnVsbCl9ZnVuY3Rpb24gQWhuKGUsbil7dmFyIHIsdDtpZihyPWEodyhlLChscigpLFI3KSksMTUpLCFyfHxyLnNpemVfMSgpPDEpcmV0dXJuIG51bGw7aWYoci5zaXplXzEoKT09MSlyZXR1cm4gYShyLmdldF8wKDApLDQwKTtzd2l0Y2godD1udWxsLG4ub3JkaW5hbCl7Y2FzZSAyOnQ9YSh2YShiaChyLnN0cmVhbSgpLG5ldyB4a2UpKSw0MCk7YnJlYWs7Y2FzZSAxOnQ9YSh2YShjZihyLnN0cmVhbSgpLG5ldyBta2UpKSw0MCk7YnJlYWs7Y2FzZSA0OnQ9YSh2YShiaChyLnN0cmVhbSgpLG5ldyB5a2UpKSw0MCk7YnJlYWs7Y2FzZSAzOnQ9YSh2YShjZihyLnN0cmVhbSgpLG5ldyB3a2UpKSw0MCl9cmV0dXJuIHR9ZnVuY3Rpb24gZmtlKGUsbil7dmFyIHIsdDtpZih0PW5ldyBUeShlLm1hcF8wLnRhaWxNYXAobiwhMCkpLHQubWFwXzAuc2l6ZV8xKCk8PTEpdGhyb3cgYihuZXcgX2gpO3JldHVybiByPXQubWFwXzAua2V5U2V0XzAoKS5pdGVyYXRvcl8wKCksci5uZXh0XzEoKSxhKHIubmV4dF8xKCksNDApfWZ1bmN0aW9uIExobihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtpZihyLmJlZ2luKCJQcm9jZXNzIGNvbXBhY3Rpb24iLDEpLCEhYWUoaWUodyhuLChGbygpLElYKSkpKSl7Zm9yKG89YSh3KG4sX2QpLDg4KSxtPVIoJCh3KG4sVTcpKSksa2huKGUsbixvKSxOaG4obixtLzIvMikseT1uLm5vZGVzLHdfKHksbmV3IGdrZShvKSksXz1kbih5LDApO18uY3VycmVudE5vZGUhPV8udGhpcyQwMS50YWlsOylpZihjPWEodW4oXyksNDApLCFhZShpZSh3KGMsKGxyKCksRzApKSkpKXtpZih0PUFobihjLG8pLEU9dmhuKGMsbiksZj0wLGg9MCx0KXN3aXRjaCh2PXQucG9zLG8ub3JkaW5hbCl7Y2FzZSAyOmY9di54XzAtbS1jLnNpemVfMC54XzAsRS5wb3MueF8wLW0tYy5zaXplXzAueF8wPGYmJihmPUUucG9zLnhfMC1tLWMuc2l6ZV8wLnhfMCksaD1mK2Muc2l6ZV8wLnhfMDticmVhaztjYXNlIDE6Zj12LnhfMCt0LnNpemVfMC54XzArbSxFLnBvcy54XzArbT5mJiYoZj1FLnBvcy54XzArRS5zaXplXzAueF8wK20pLGg9ZitjLnNpemVfMC54XzA7YnJlYWs7Y2FzZSA0OmY9di55XzAtbS1jLnNpemVfMC55XzAsRS5wb3MueV8wLW0tYy5zaXplXzAueV8wPGYmJihmPUUucG9zLnlfMC1tLWMuc2l6ZV8wLnlfMCksaD1mK2Muc2l6ZV8wLnlfMDticmVhaztjYXNlIDM6Zj12LnlfMCt0LnNpemVfMC55XzArbSxFLnBvcy55XzArbT5mJiYoZj1FLnBvcy55XzArRS5zaXplXzAueV8wK20pLGg9ZitjLnNpemVfMC55XzB9ZWxzZSBpZihFKXN3aXRjaChvLm9yZGluYWwpe2Nhc2UgMjpmPUUucG9zLnhfMC1tLWMuc2l6ZV8wLnhfMCxoPWYrYy5zaXplXzAueF8wO2JyZWFrO2Nhc2UgMTpmPUUucG9zLnhfMCtFLnNpemVfMC54XzArbSxoPWYrYy5zaXplXzAueF8wO2JyZWFrO2Nhc2UgNDpmPUUucG9zLnlfMC1tLWMuc2l6ZV8wLnlfMCxoPWYrYy5zaXplXzAueV8wO2JyZWFrO2Nhc2UgMzpmPUUucG9zLnlfMCtFLnNpemVfMC55XzArbSxoPWYrYy5zaXplXzAueV8wfUQodyhuLEg3KSk9PT1EKChodigpLEozKSk/KGk9ZixzPWgsdT14eShKbihuZXcgU2UobnVsbCxuZXcgeGUoZS5sZXZlbHMsMTYpKSxuZXcgaGtlKGkscykpKSx1LnJlZiE9bnVsbD9vPT0oV3IoKSxhbyl8fG89PW1vP2MucG9zLnhfMD1mOmMucG9zLnlfMD1mOihvPT0oV3IoKSxhbyl8fG89PW9sP3U9eHkoSm4oWDFlKG5ldyBTZShudWxsLG5ldyB4ZShlLmxldmVscywxNikpKSxuZXcgRWtlKGkpKSk6dT14eShKbihYMWUobmV3IFNlKG51bGwsbmV3IHhlKGUubGV2ZWxzLDE2KSkpLG5ldyB2a2UoaSkpKSx1LnJlZiE9bnVsbCYmKG89PWFvfHxvPT1tbz9jLnBvcy54XzA9UigkKChybih1LnJlZiE9bnVsbCksYSh1LnJlZiw0MikpLmZpcnN0KSk6Yy5wb3MueV8wPVIoJCgocm4odS5yZWYhPW51bGwpLGEodS5yZWYsNDIpKS5maXJzdCkpKSksdS5yZWYhPW51bGwmJihkPWZvKGUubGV2ZWxzLChybih1LnJlZiE9bnVsbCksdS5yZWYpLDApLGQ+MCYmZCE9YSh3KGMsZ3UpLDE3KS52YWx1ZV8wJiYoaihjLG1YLCh6ZSgpLCEwKSksaihjLGd1LEooZCkpKSkpOm89PShXcigpLGFvKXx8bz09bW8/Yy5wb3MueF8wPWY6Yy5wb3MueV8wPWZ9ci5kb25lXzEoKX19ZnVuY3Rpb24ga2huKGUsbixyKXt2YXIgdCxvLGk7Zm9yKGUubGV2ZWxzPW5ldyBRLGk9ZG4obi5ub2RlcywwKTtpLmN1cnJlbnROb2RlIT1pLnRoaXMkMDEudGFpbDspe2ZvcihvPWEodW4oaSksNDApO2EodyhvLChGbygpLGd1KSksMTcpLnZhbHVlXzA+ZS5sZXZlbHMuYXJyYXkubGVuZ3RoLTE7KWVlKGUubGV2ZWxzLG5ldyBacihtcCxLRikpO3Q9YSh3KG8sZ3UpLDE3KS52YWx1ZV8wLHI9PShXcigpLGFvKXx8cj09bW8/KG8ucG9zLnhfMDxSKCQoYShsZShlLmxldmVscyx0KSw0MikuZmlyc3QpKSYmeFIoYShsZShlLmxldmVscyx0KSw0Miksby5wb3MueF8wKSxvLnBvcy54XzArby5zaXplXzAueF8wPlIoJChhKGxlKGUubGV2ZWxzLHQpLDQyKS5zZWNvbmQpKSYmUFIoYShsZShlLmxldmVscyx0KSw0Miksby5wb3MueF8wK28uc2l6ZV8wLnhfMCkpOihvLnBvcy55XzA8UigkKGEobGUoZS5sZXZlbHMsdCksNDIpLmZpcnN0KSkmJnhSKGEobGUoZS5sZXZlbHMsdCksNDIpLG8ucG9zLnlfMCksby5wb3MueV8wK28uc2l6ZV8wLnlfMD5SKCQoYShsZShlLmxldmVscyx0KSw0Mikuc2Vjb25kKSkmJlBSKGEobGUoZS5sZXZlbHMsdCksNDIpLG8ucG9zLnlfMCtvLnNpemVfMC55XzApKX19ZnVuY3Rpb24gcGtlKCl7fWZ1bmN0aW9uIE9obihlLG4scil7cmV0dXJuIGlyKGFtKGd3KGUpLG5ldyBZKG4ucG9zLnhfMCxuLnBvcy55XzApKSxhbShndyhlKSxuZXcgWShyLnBvcy54XzAsci5wb3MueV8wKSkpfWZ1bmN0aW9uIE1obihlLG4scil7cmV0dXJuIFIoJChyLmZpcnN0KSk8PWUmJlIoJChyLnNlY29uZCkpPj1ufWZ1bmN0aW9uIFJobihlLG4pe3JldHVybiBpcihlLnBvcy54XzArZS5zaXplXzAueF8wLG4ucG9zLnhfMCtuLnNpemVfMC54XzApfWZ1bmN0aW9uIERobihlLG4pe3JldHVybiBpcihlLnBvcy55XzAsbi5wb3MueV8wKX1mdW5jdGlvbiBGaG4oZSxuKXtyZXR1cm4gaXIoZS5wb3MueV8wK2Uuc2l6ZV8wLnlfMCxuLnBvcy55XzArbi5zaXplXzAueV8wKX1mdW5jdGlvbiB6aG4oZSxuKXtyZXR1cm4gUigkKG4uZmlyc3QpKTw9ZX1mdW5jdGlvbiAkaG4oZSxuKXtyZXR1cm4gUigkKG4uZmlyc3QpKT49ZX1mdW5jdGlvbiBCaG4oZSxuKXtyZXR1cm4gbmV3IE5SKG4sRnYoQ3Qobi5wb3MpLGUsZSksKHplKCksITApKX1mdW5jdGlvbiBHaG4oZSxuKXtyZXR1cm4gbmV3IE5SKG4sbWQoQ3Qobi5wb3MpLG4uc2l6ZV8wLnhfMCtlLG4uc2l6ZV8wLnlfMCtlKSwoemUoKSwhMSkpfWZ1bmN0aW9uIEhobihlLG4scil7cmV0dXJuIGlyKGFtKGd3KGUpLEN0KG4uc2Vjb25kKSksYW0oZ3coZSksQ3Qoci5zZWNvbmQpKSl9ZnVuY3Rpb24gVWhuKGUsbixyKXtyZXR1cm4gaXIoYW0oZ3coZSksQ3Qobi5wb3MpKSxhbShndyhlKSxDdChyLnBvcykpKX1mdW5jdGlvbiBXaG4oZSxuKXtyZXR1cm4gaXIoZS5wb3MueF8wLG4ucG9zLnhfMCl9cCgxOTIzLDEsc3IscGtlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtMaG4odGhpcyxhKG4sMTIxKSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3NvciIsMTkyMyk7ZnVuY3Rpb24gZ2tlKGUpe3RoaXMuZGlyXzA9ZX1wKDE5MjQsMSxObixna2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIE9obih0aGlzLmRpcl8wLGEobiw0MCksYShyLDQwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkMCRUeXBlIiwxOTI0KTtmdW5jdGlvbiBoa2UoZSxuKXt0aGlzLmZpbmFsTmV3UG9zXzA9ZSx0aGlzLmZpbmFsTmV3UG9zU2l6ZV8yPW59cCgxOTI1LDEsSW4saGtlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gTWhuKHRoaXMuZmluYWxOZXdQb3NfMCx0aGlzLmZpbmFsTmV3UG9zU2l6ZV8yLGEobiw0MikpfSxsLmZpbmFsTmV3UG9zU2l6ZV8yPTAsbC5maW5hbE5ld1Bvc18wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkMSRUeXBlIiwxOTI1KTtmdW5jdGlvbiBta2UoKXt9cCgxOTM0LDEsTm4sbWtlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBSaG4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQxMCRUeXBlIiwxOTM0KTtmdW5jdGlvbiB5a2UoKXt9cCgxOTM1LDEsTm4seWtlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBEaG4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQxMSRUeXBlIiwxOTM1KTtmdW5jdGlvbiB3a2UoKXt9cCgxOTM2LDEsTm4sd2tlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBGaG4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQxMiRUeXBlIiwxOTM2KTtmdW5jdGlvbiBFa2UoZSl7dGhpcy5maW5hbE5ld1Bvc18wPWV9cCgxOTI2LDEsSW4sRWtlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gemhuKHRoaXMuZmluYWxOZXdQb3NfMCxhKG4sNDIpKX0sbC5maW5hbE5ld1Bvc18wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkMiRUeXBlIiwxOTI2KTtmdW5jdGlvbiB2a2UoZSl7dGhpcy5maW5hbE5ld1Bvc18wPWV9cCgxOTI3LDEsSW4sdmtlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gJGhuKHRoaXMuZmluYWxOZXdQb3NfMCxhKG4sNDIpKX0sbC5maW5hbE5ld1Bvc18wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkMyRUeXBlIiwxOTI3KTtmdW5jdGlvbiBTa2UoKXt9cCgxOTI4LDEsSW4sU2tlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDQwKS5sYWJlbF8wLmluZGV4T2YoIlNVUEVSX1JPT1QiKT09LTF9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkNvbXBhY3Rpb25Qcm9jZXNzb3IvbGFtYmRhJDQkVHlwZSIsMTkyOCk7ZnVuY3Rpb24gQ2tlKGUpe3RoaXMubm9kZU5vZGVTcGFjaW5nXzA9ZX1wKDE5MjksMSx7fSxDa2UpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gQmhuKHRoaXMubm9kZU5vZGVTcGFjaW5nXzAsYShuLDQwKSl9LGwubm9kZU5vZGVTcGFjaW5nXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQ1JFR5cGUiLDE5MjkpO2Z1bmN0aW9uIFRrZShlKXt0aGlzLm5vZGVOb2RlU3BhY2luZ18wPWV9cCgxOTMwLDEse30sVGtlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEdobih0aGlzLm5vZGVOb2RlU3BhY2luZ18wLGEobiw0MCkpfSxsLm5vZGVOb2RlU3BhY2luZ18wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkNiRUeXBlIiwxOTMwKTtmdW5jdGlvbiBia2UoZSl7dGhpcy5yaWdodF8wPWV9cCgxOTMxLDEsTm4sYmtlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBIaG4odGhpcy5yaWdodF8wLGEobiwyNDApLGEociwyNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQ3JFR5cGUiLDE5MzEpO2Z1bmN0aW9uIElrZShlKXt0aGlzLmRfMD1lfXAoMTkzMiwxLE5uLElrZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gVWhuKHRoaXMuZF8wLGEobiw0MCksYShyLDQwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiQ29tcGFjdGlvblByb2Nlc3Nvci9sYW1iZGEkOCRUeXBlIiwxOTMyKTtmdW5jdGlvbiB4a2UoKXt9cCgxOTMzLDEsTm4seGtlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBXaG4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJDb21wYWN0aW9uUHJvY2Vzc29yL2xhbWJkYSQ5JFR5cGUiLDE5MzMpO2Z1bmN0aW9uIGpobihlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2lmKG4uYmVnaW4oIlByb2Nlc3MgZGlyZWN0aW9ucyIsMSkscj1hKHcoZSwoRm8oKSxfZCkpLDg4KSxyIT0oV3IoKSwkcykpZm9yKG89ZG4oZS5ub2RlcywwKTtvLmN1cnJlbnROb2RlIT1vLnRoaXMkMDEudGFpbDspe3N3aXRjaCh0PWEodW4obyksNDApLHU9YSh3KHQsKGxyKCksUTMpKSwxNykudmFsdWVfMCxjPWEodyh0LGVUKSwxNykudmFsdWVfMCxyLm9yZGluYWwpe2Nhc2UgNDpjKj0tMTticmVhaztjYXNlIDE6aT11LHU9YyxjPWk7YnJlYWs7Y2FzZSAyOnM9dSx1PS1jLGM9c31qKHQsUTMsSih1KSksaih0LGVULEooYykpfW4uZG9uZV8xKCl9ZnVuY3Rpb24gUGtlKCl7fXAoMTkyMSwxLHNyLFBrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7amhuKGEobiwxMjEpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJEaXJlY3Rpb25Qcm9jZXNzb3IiLDE5MjEpO2Z1bmN0aW9uIE5rZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztpZihuLnNpemVfMCE9MCl7Zm9yKG09bmV3IHByLHU9bnVsbCx5PW51bGwsdD1LcihTLk1hdGguZmxvb3IoUy5NYXRoLmxvZyhuLnNpemVfMCkqUy5NYXRoLkxPRzEwRSkrMSksYz0wLGs9ZG4obiwwKTtrLmN1cnJlbnROb2RlIT1rLnRoaXMkMDEudGFpbDspZm9yKHg9YSh1bihrKSw0MCksRCh5KSE9PUQodyh4LChscigpLG12KSkpJiYoeT14bih3KHgsbXYpKSxjPTApLHkhPW51bGw/dT15K0xrZShjKyssdCk6dT1Ma2UoYysrLHQpLGooeCxtdix1KSx2PShvPWRuKG5ldyBjYyh4KS50aGlzJDAxLm91dGdvaW5nRWRnZXMsMCksbmV3IGRnKG8pKTtEQyh2LnZhbCRlZGdlc0l0ZXIyKTspRT1hKHVuKHYudmFsJGVkZ2VzSXRlcjIpLDY1KS50YXJnZXQsYnIobSxFLG0udGFpbC5wcmV2LG0udGFpbCksaihFLG12LHUpO2ZvcihoPW5ldyBzbixzPTA7czx1Lmxlbmd0aC10O3MrKylmb3IoQT1kbihuLDApO0EuY3VycmVudE5vZGUhPUEudGhpcyQwMS50YWlsOyl4PWEodW4oQSksNDApLF89WWEoeG4odyh4LChscigpLG12KSkpLDAscysxKSxyPShfPT1udWxsP19vKGp0KGguaGFzaENvZGVNYXAsbnVsbCkpOnJFKGguc3RyaW5nTWFwLF8pKSE9bnVsbD9hKF89PW51bGw/X28oanQoaC5oYXNoQ29kZU1hcCxudWxsKSk6ckUoaC5zdHJpbmdNYXAsXyksMTcpLnZhbHVlXzArMToxLHRvKGgsXyxKKHIpKTtmb3IoZj1uZXcgTF8obmV3IEFfKGgpLnRoaXMkMDEpO2YuaGFzTmV4dDspZD1OMShmKSxpPUooS2UoZS5nbG9EZXNjTWFwLGQuZ2V0S2V5KCkpIT1udWxsP2EoS2UoZS5nbG9EZXNjTWFwLGQuZ2V0S2V5KCkpLDE3KS52YWx1ZV8wOjApLHRvKGUuZ2xvRGVzY01hcCx4bihkLmdldEtleSgpKSxKKGEoZC5nZXRWYWx1ZSgpLDE3KS52YWx1ZV8wK2kudmFsdWVfMCkpLGk9YShLZShlLmdsb0Zhbk1hcCxkLmdldEtleSgpKSwxNyksKCFpfHxpLnZhbHVlXzA8YShkLmdldFZhbHVlKCksMTcpLnZhbHVlXzApJiZ0byhlLmdsb0Zhbk1hcCx4bihkLmdldEtleSgpKSxhKGQuZ2V0VmFsdWUoKSwxNykpO05rZShlLG0pfX1mdW5jdGlvbiBWaG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7Zm9yKHIuYmVnaW4oIlByb2Nlc3NvciBjb21wdXRlIGZhbm91dCIsMSksWmkoZS5nbG9GYW5NYXApLFppKGUuZ2xvRGVzY01hcCksdT1udWxsLGk9ZG4obi5ub2RlcywwKTshdSYmaS5jdXJyZW50Tm9kZSE9aS50aGlzJDAxLnRhaWw7KV89YSh1bihpKSw0MCksYWUoaWUodyhfLChscigpLEcwKSkpKSYmKHU9Xyk7Zm9yKGM9bmV3IHByLGJyKGMsdSxjLnRhaWwucHJldixjLnRhaWwpLE5rZShlLGMpLGQ9ZG4obi5ub2RlcywwKTtkLmN1cnJlbnROb2RlIT1kLnRoaXMkMDEudGFpbDspXz1hKHVuKGQpLDQwKSxzPXhuKHcoXywobHIoKSxtdikpKSxvPW5pKGUuZ2xvRmFuTWFwLHMpIT1udWxsP2EobmkoZS5nbG9GYW5NYXAscyksMTcpLnZhbHVlXzA6MCxqKF8sRjcsSihvKSksdD0xKyhuaShlLmdsb0Rlc2NNYXAscykhPW51bGw/YShuaShlLmdsb0Rlc2NNYXAscyksMTcpLnZhbHVlXzA6MCksaihfLHlYLEoodCkpO3IuZG9uZV8xKCl9ZnVuY3Rpb24gQWtlKCl7dGhpcy5nbG9GYW5NYXA9bmV3IHNuLHRoaXMuZ2xvRGVzY01hcD1uZXcgc259ZnVuY3Rpb24gTGtlKGUsbil7dmFyIHI7Zm9yKHI9ZSsiIjtyLmxlbmd0aDxuOylyPSIwIityO3JldHVybiByfXAoMTkxMywxLHNyLEFrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7VmhuKHRoaXMsYShuLDEyMSkscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkZhblByb2Nlc3NvciIsMTkxMyk7ZnVuY3Rpb24gcWhuKGUsbil7bi5iZWdpbigiUHJvY2VzcyBncmFwaCBib3VuZHMiLDEpLGooZSwobHIoKSx6NyksekMoTWsodWYobmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgT2tlKSkpKSxqKGUsJDcsekMoTWsodWYobmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgTWtlKSkpKSxqKGUsd1gsekMoT2sodWYobmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgUmtlKSkpKSxqKGUsRVgsekMoT2sodWYobmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgRGtlKSkpKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIGtrZSgpe31mdW5jdGlvbiBZaG4oZSl7cmV0dXJuIGUucG9zLnhfMCtlLnNpemVfMC54XzB9ZnVuY3Rpb24gS2huKGUpe3JldHVybiBlLnBvcy55XzArZS5zaXplXzAueV8wfXAoMTkzNywxLHNyLGtrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cWhuKGEobiwxMjEpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJHcmFwaEJvdW5kc1Byb2Nlc3NvciIsMTkzNyk7ZnVuY3Rpb24gT2tlKCl7fXAoMTkzOCwxLHt9LE9rZSksbC5hcHBseUFzRG91YmxlPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sNDApLnBvcy54XzB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkdyYXBoQm91bmRzUHJvY2Vzc29yL2xhbWJkYSQwJFR5cGUiLDE5MzgpO2Z1bmN0aW9uIE1rZSgpe31wKDE5MzksMSx7fSxNa2UpLGwuYXBwbHlBc0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDQwKS5wb3MueV8wfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJHcmFwaEJvdW5kc1Byb2Nlc3Nvci9sYW1iZGEkMSRUeXBlIiwxOTM5KTtmdW5jdGlvbiBSa2UoKXt9cCgxOTQwLDEse30sUmtlKSxsLmFwcGx5QXNEb3VibGU9ZnVuY3Rpb24obil7cmV0dXJuIFlobihhKG4sNDApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiR3JhcGhCb3VuZHNQcm9jZXNzb3IvbGFtYmRhJDIkVHlwZSIsMTk0MCk7ZnVuY3Rpb24gRGtlKCl7fXAoMTk0MSwxLHt9LERrZSksbC5hcHBseUFzRG91YmxlPWZ1bmN0aW9uKG4pe3JldHVybiBLaG4oYShuLDQwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkdyYXBoQm91bmRzUHJvY2Vzc29yL2xhbWJkYSQzJFR5cGUiLDE5NDEpO2Z1bmN0aW9uIGd2KCl7Z3Y9RixrNz1uZXcgY2QoIlJPT1RfUFJPQyIsMCksc1g9bmV3IGNkKCJGQU5fUFJPQyIsMSksZFg9bmV3IGNkKCJMRVZFTF9QUk9DIiwyKSxmWD1uZXcgY2QoIk5FSUdIQk9SU19QUk9DIiwzKSxfWD1uZXcgY2QoIkxFVkVMX0hFSUdIVCIsNCksbFg9bmV3IGNkKCJESVJFQ1RJT05fUFJPQyIsNSkscFg9bmV3IGNkKCJOT0RFX1BPU0lUSU9OX1BST0MiLDYpLGlYPW5ldyBjZCgiQ09NUEFDVElPTl9QUk9DIiw3KSxjWD1uZXcgY2QoIkxFVkVMX0NPT1JEUyIsOCksdVg9bmV3IGNkKCJHUkFQSF9CT1VORFNfUFJPQyIsOSksYVg9bmV3IGNkKCJERVRSRUVJRllJTkdfUFJPQyIsMTApfWZ1bmN0aW9uIGNkKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gWGhuKGUpe3JldHVybiBndigpLHduKCh6a2UoKSwka2UpLGUpfWZ1bmN0aW9uIEZrZSgpe3JldHVybiBndigpLFAoSShKaG4sMSksVywyNjIsMCxbazcsc1gsZFgsZlgsX1gsbFgscFgsaVgsY1gsdVgsYVhdKX1wKDI2MiwyMix7MzoxLDM0OjEsMjI6MSwyNjI6MSwxOTY6MX0sY2QpLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG5ldyBKa2U7Y2FzZSAxOnJldHVybiBuZXcgQWtlO2Nhc2UgMjpyZXR1cm4gbmV3IGprZTtjYXNlIDM6cmV0dXJuIG5ldyBZa2U7Y2FzZSA0OnJldHVybiBuZXcgSGtlO2Nhc2UgODpyZXR1cm4gbmV3IEJrZTtjYXNlIDU6cmV0dXJuIG5ldyBQa2U7Y2FzZSA2OnJldHVybiBuZXcgWGtlO2Nhc2UgNzpyZXR1cm4gbmV3IHBrZTtjYXNlIDk6cmV0dXJuIG5ldyBra2U7Y2FzZSAxMDpyZXR1cm4gbmV3IFprZTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJObyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBsYXlvdXQgcHJvY2Vzc29yICIrKHRoaXMubmFtZV8wIT1udWxsP3RoaXMubmFtZV8wOiIiK3RoaXMub3JkaW5hbCkpKX19O3ZhciBpWCxhWCxsWCxzWCx1WCxjWCxfWCxkWCxmWCxwWCxrNyxKaG49Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkludGVybWVkaWF0ZVByb2Nlc3NvclN0cmF0ZWd5IiwyNjIsZ24sRmtlLFhobik7ZnVuY3Rpb24gemtlKCl7emtlPUYsJGtlPXluKEZrZSgpKX12YXIgJGtlO2Z1bmN0aW9uIFpobihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKG4uYmVnaW4oIlByb2Nlc3NvciBkZXRlcm1pbmUgdGhlIGNvb3JkcyBmb3IgZWFjaCBsZXZlbCIsMSksdD1uZXcgUSxzPWRuKGUubm9kZXMsMCk7cy5jdXJyZW50Tm9kZSE9cy50aGlzJDAxLnRhaWw7KXtmb3Iobz1hKHVuKHMpLDQwKTthKHcobywoRm8oKSxndSkpLDE3KS52YWx1ZV8wPnQuYXJyYXkubGVuZ3RoLTE7KWVlKHQsbmV3IFpyKG1wLEtGKSk7cj1hKHcobyxndSksMTcpLnZhbHVlXzAsZGMoYSh3KGUsX2QpLDg4KSk/KG8ucG9zLnhfMDxSKCQoKEFlKHIsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtyXSw0MikpLmZpcnN0KSkmJnhSKChBZShyLHQuYXJyYXkubGVuZ3RoKSxhKHQuYXJyYXlbcl0sNDIpKSxvLnBvcy54XzApLG8ucG9zLnhfMCtvLnNpemVfMC54XzA+UigkKChBZShyLHQuYXJyYXkubGVuZ3RoKSxhKHQuYXJyYXlbcl0sNDIpKS5zZWNvbmQpKSYmUFIoKEFlKHIsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtyXSw0MikpLG8ucG9zLnhfMCtvLnNpemVfMC54XzApKTooby5wb3MueV8wPFIoJCgoQWUocix0LmFycmF5Lmxlbmd0aCksYSh0LmFycmF5W3JdLDQyKSkuZmlyc3QpKSYmeFIoKEFlKHIsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtyXSw0MikpLG8ucG9zLnlfMCksby5wb3MueV8wK28uc2l6ZV8wLnlfMD5SKCQoKEFlKHIsdC5hcnJheS5sZW5ndGgpLGEodC5hcnJheVtyXSw0MikpLnNlY29uZCkpJiZQUigoQWUocix0LmFycmF5Lmxlbmd0aCksYSh0LmFycmF5W3JdLDQyKSksby5wb3MueV8wK28uc2l6ZV8wLnlfMCkpfWZvcihpPWRuKGUubm9kZXMsMCk7aS5jdXJyZW50Tm9kZSE9aS50aGlzJDAxLnRhaWw7KW89YSh1bihpKSw0MCkscj1hKHcobywoRm8oKSxndSkpLDE3KS52YWx1ZV8wLGoobywobHIoKSxwcyksJCgoQWUocix0LmFycmF5Lmxlbmd0aCksYSh0LmFycmF5W3JdLDQyKSkuZmlyc3QpKSxqKG8sWWwsJCgoQWUocix0LmFycmF5Lmxlbmd0aCksYSh0LmFycmF5W3JdLDQyKSkuc2Vjb25kKSk7bi5kb25lXzEoKX1mdW5jdGlvbiBCa2UoKXt9cCgxOTIwLDEsc3IsQmtlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtaaG4oYShuLDEyMSkscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkxldmVsQ29vcmRpbmF0ZXNQcm9jZXNzb3IiLDE5MjApO2Z1bmN0aW9uIFFobihlLG4scil7dmFyIHQsbyxpO2ZvcihyLmJlZ2luKCJQcm9jZXNzb3IgZGV0ZXJtaW5lIHRoZSBoZWlnaHQgZm9yIGVhY2ggbGV2ZWwiLDEpLGUubnVtYmVyT2ZOb2Rlcz1uLm5vZGVzLnNpemVfMD09MD8xOm4ubm9kZXMuc2l6ZV8wLG89bnVsbCx0PWRuKG4ubm9kZXMsMCk7IW8mJnQuY3VycmVudE5vZGUhPXQudGhpcyQwMS50YWlsOylpPWEodW4odCksNDApLGFlKGllKHcoaSwobHIoKSxHMCkpKSkmJihvPWkpO28mJkdrZShlLFRzKFAoSShyTiwxKSxxYiw0MCwwLFtvXSkpLHIsYSh3KG4sKEZvKCksX2QpKSw4OCkpLHIuZG9uZV8xKCl9ZnVuY3Rpb24gR2tlKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXztpZighSm0obikpe2lmKF89ci5zdWJUYXNrKChMKG4sMTYpP2EobiwxNikuc2l6ZV8xKCk6WnUobi5pdGVyYXRvcl8wKCkpKS9lLm51bWJlck9mTm9kZXN8MCksXy5iZWdpbigiU2V0IG5laWdoYm9ycyBpbiBsZXZlbCIsMSksYz1uZXcgVWtlLHU9MCx0PT0oV3IoKSxhbyl8fHQ9PW1vKWZvcihzPW4uaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KW89YShzLm5leHRfMSgpLDQwKSxjPU5hKFAoSSh4YSwxKSxNZSwyMCwwLFtjLG5ldyBjYyhvKV0pKSx1PG8uc2l6ZV8wLnhfMCYmKHU9by5zaXplXzAueF8wKTtlbHNlIGZvcihzPW4uaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KW89YShzLm5leHRfMSgpLDQwKSxjPU5hKFAoSSh4YSwxKSxNZSwyMCwwLFtjLG5ldyBjYyhvKV0pKSx1PG8uc2l6ZV8wLnlfMCYmKHU9by5zaXplXzAueV8wKTtmb3IoaT1uLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOylvPWEoaS5uZXh0XzEoKSw0MCksaihvLChscigpLG9OKSx1KTtfLmRvbmVfMSgpLEdrZShlLGMscix0KX19ZnVuY3Rpb24gSGtlKCl7fXAoMTkxOCwxLHNyLEhrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7UWhuKHRoaXMsYShuLDEyMSkscil9LGwubnVtYmVyT2ZOb2Rlcz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIkxldmVsSGVpZ2h0UHJvY2Vzc29yIiwxOTE4KTtmdW5jdGlvbiBVa2UoKXt9cCgxOTE5LDEsVHUsVWtlKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxkeSgpLGZ5fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJMZXZlbEhlaWdodFByb2Nlc3Nvci8xIiwxOTE5KTtmdW5jdGlvbiBlbW4oZSxuLHIpe3ZhciB0LG8saSxzO2ZvcihyLmJlZ2luKCJQcm9jZXNzb3IgY29tcHV0ZSBmYW5vdXQiLDEpLG89YShUbyhKbihuZXcgU2UobnVsbCxuZXcgeGUobi5ub2RlcywxNikpLG5ldyBWa2UpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxDbyldKSkpLDE1KSxXa2UoZSxvLDApLHM9ZG4obi5ub2RlcywwKTtzLmN1cnJlbnROb2RlIT1zLnRoaXMkMDEudGFpbDspaT1hKHVuKHMpLDQwKSx0PUtlKGUuZ2xvTGV2ZWxNYXAsSihpLmlkXzApKSE9bnVsbD9hKEtlKGUuZ2xvTGV2ZWxNYXAsSihpLmlkXzApKSwxNykudmFsdWVfMDowLGooaSwoRm8oKSxndSksSih0KSk7ci5kb25lXzEoKX1mdW5jdGlvbiBXa2UoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpZighbi5pc0VtcHR5KCkpe2ZvcihvPW5ldyBwcixjPW4uaXRlcmF0b3JfMCgpO2MuaGFzTmV4dF8wKCk7KWZvcih1PWEoYy5uZXh0XzEoKSw0MCksQm4oZS5nbG9MZXZlbE1hcCxKKHUuaWRfMCksSihyKSkscz0odD1kbihuZXcgY2ModSkudGhpcyQwMS5vdXRnb2luZ0VkZ2VzLDApLG5ldyBkZyh0KSk7REMocy52YWwkZWRnZXNJdGVyMik7KWk9YSh1bihzLnZhbCRlZGdlc0l0ZXIyKSw2NSkudGFyZ2V0LGJyKG8saSxvLnRhaWwucHJldixvLnRhaWwpO1drZShlLG8scisxKX19ZnVuY3Rpb24gamtlKCl7dGhpcy5nbG9MZXZlbE1hcD1uZXcgc259cCgxOTE0LDEsc3IsamtlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtlbW4odGhpcyxhKG4sMTIxKSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiTGV2ZWxQcm9jZXNzb3IiLDE5MTQpO2Z1bmN0aW9uIFZrZSgpe31wKDE5MTUsMSxJbixWa2UpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhZShpZSh3KGEobiw0MCksKGxyKCksRzApKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJMZXZlbFByb2Nlc3Nvci9sYW1iZGEkMCRUeXBlIiwxOTE1KTtmdW5jdGlvbiBubW4oZSxuLHIpe3ZhciB0LG8saTtmb3Ioci5iZWdpbigiUHJvY2Vzc29yIHNldCBuZWlnaGJvcnMiLDEpLGUubnVtYmVyT2ZOb2Rlcz1uLm5vZGVzLnNpemVfMD09MD8xOm4ubm9kZXMuc2l6ZV8wLG89bnVsbCx0PWRuKG4ubm9kZXMsMCk7IW8mJnQuY3VycmVudE5vZGUhPXQudGhpcyQwMS50YWlsOylpPWEodW4odCksNDApLGFlKGllKHcoaSwobHIoKSxHMCkpKSkmJihvPWkpO28mJnFrZShlLG5ldyBjYyhvKSxyKSxyLmRvbmVfMSgpfWZ1bmN0aW9uIHFrZShlLG4scil7dmFyIHQsbyxpLHMsdTtpZighSm0obikpe2Zvcih1PXIuc3ViVGFzaygoTChuLDE2KT9hKG4sMTYpLnNpemVfMSgpOlp1KG4uaXRlcmF0b3JfMCgpKSkvZS5udW1iZXJPZk5vZGVzfDApLHUuYmVnaW4oIlNldCBuZWlnaGJvcnMgaW4gbGV2ZWwiLDEpLHM9bmV3IEtrZSxpPW51bGwsbz1uLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PWEoby5uZXh0XzEoKSw0MCkscz1OYShQKEkoeGEsMSksTWUsMjAsMCxbcyxuZXcgY2ModCldKSksaSYmKGooaSwobHIoKSxuOGUpLHQpLGoodCxCNyxpKSxBNyh0KT09QTcoaSkmJihqKGksRzcsdCksaih0LHROLGkpKSksaT10O3UuZG9uZV8xKCkscWtlKGUscyxyKX19ZnVuY3Rpb24gWWtlKCl7fXAoMTkxNiwxLHNyLFlrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7bm1uKHRoaXMsYShuLDEyMSkscil9LGwubnVtYmVyT2ZOb2Rlcz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIk5laWdoYm9yc1Byb2Nlc3NvciIsMTkxNik7ZnVuY3Rpb24gS2tlKCl7fXAoMTkxNywxLFR1LEtrZSksbC5mb3JFYWNoXzA9ZnVuY3Rpb24obil7RXQodGhpcyxuKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksZHkoKSxmeX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUuaW50ZXJtZWRpYXRlIiwiTmVpZ2hib3JzUHJvY2Vzc29yLzEiLDE5MTcpO2Z1bmN0aW9uIHJtbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihyLmJlZ2luKCJQcm9jZXNzb3Igc2V0IGNvb3JkaW5hdGVzIiwxKSxlLm51bWJlck9mTm9kZXM9bi5ub2Rlcy5zaXplXzA9PTA/MTpuLm5vZGVzLnNpemVfMCxfPW51bGwsdD1kbihuLm5vZGVzLDApOyFfJiZ0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspZj1hKHVuKHQpLDQwKSxhZShpZSh3KGYsKGxyKCksRzApKSkpJiYoXz1mLGM9Zi5wb3MsYy54XzA9YSh3KGYsUTMpLDE3KS52YWx1ZV8wLGMueV8wPWEodyhmLGVUKSwxNykudmFsdWVfMCk7dT1ONyhfKSxkPTE7ZG8gdT10bW4oKG89dSxyLnN1YlRhc2soZCksbykpLGQ9dS5zaXplXzAvZS5udW1iZXJPZk5vZGVzfDA7d2hpbGUodS5zaXplXzAhPTApO2ZvcihzPWRuKG4ubm9kZXMsMCk7cy5jdXJyZW50Tm9kZSE9cy50aGlzJDAxLnRhaWw7KWk9YSh1bihzKSw0MCkscnQoaS5wb3MsbmV3IFkoaS5zaXplXzAueF8wLzIsaS5zaXplXzAueV8wLzIpKTtyLmRvbmVfMSgpfWZ1bmN0aW9uIHRtbihlKXt2YXIgbixyLHQsbztpZihlLnNpemVfMCE9MCl7Zm9yKG49bmV3IHByLG89ZG4oZSwwKTtvLmN1cnJlbnROb2RlIT1vLnRoaXMkMDEudGFpbDspdD1hKHVuKG8pLDQwKSxmdChuLE43KHQpKSxyPXQucG9zLHIueF8wPWEodyh0LChscigpLFEzKSksMTcpLnZhbHVlXzAsci55XzA9YSh3KHQsZVQpLDE3KS52YWx1ZV8wO3JldHVybiBufXJldHVybiBuZXcgcHJ9ZnVuY3Rpb24gWGtlKCl7fXAoMTkyMiwxLHNyLFhrZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7cm1uKHRoaXMsYShuLDEyMSkscil9LGwubnVtYmVyT2ZOb2Rlcz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIk5vZGVQb3NpdGlvblByb2Nlc3NvciIsMTkyMik7ZnVuY3Rpb24gb21uKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXztmb3Ioci5iZWdpbigiRmluZCByb290cyIsMSksZS5yb290cy5hcnJheS5sZW5ndGg9MCxvPWRuKG4ubm9kZXMsMCk7by5jdXJyZW50Tm9kZSE9by50aGlzJDAxLnRhaWw7KXQ9YSh1bihvKSw0MCksdC5pbmNvbWluZ0VkZ2VzLnNpemVfMD09MCYmKGoodCwobHIoKSxHMCksKHplKCksITApKSxlZShlLnJvb3RzLHQpKTtzd2l0Y2goZS5yb290cy5hcnJheS5sZW5ndGgpe2Nhc2UgMDppPW5ldyBMNygwLG4sIkRVTU1ZX1JPT1QiKSxqKGksKGxyKCksRzApLCh6ZSgpLCEwKSksaihpLEQ3LCEwKSxMbihuLm5vZGVzLGkpO2JyZWFrO2Nhc2UgMTpicmVhaztkZWZhdWx0OmZvcihzPW5ldyBMNygwLG4sIlNVUEVSX1JPT1QiKSxjPW5ldyBUKGUucm9vdHMpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSw0MCksXz1uZXcgb1gocyx1KSxqKF8sKGxyKCksRDcpLCh6ZSgpLCEwKSksTG4ocy5ncmFwaF8wLmVkZ2VzLF8pLExuKHMub3V0Z29pbmdFZGdlcyxfKSxMbih1LmluY29taW5nRWRnZXMsXyksaih1LEcwLCExKTtqKHMsKGxyKCksRzApLCh6ZSgpLCEwKSksaihzLEQ3LCEwKSxMbihuLm5vZGVzLHMpfXIuZG9uZV8xKCl9ZnVuY3Rpb24gSmtlKCl7dGhpcy5yb290cz1uZXcgUX1wKDE5MTIsMSxzcixKa2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe29tbih0aGlzLGEobiwxMjEpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5pbnRlcm1lZGlhdGUiLCJSb290UHJvY2Vzc29yIiwxOTEyKTtmdW5jdGlvbiBpbW4oZSxuKXt2YXIgcix0LG87Zm9yKG4uYmVnaW4oIlVudHJlZWlmeSIsMSkscj1hKHcoZSwobHIoKSx2WCkpLDE1KSxvPXIuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9YShvLm5leHRfMSgpLDY1KSxMbih0LnNvdXJjZS5vdXRnb2luZ0VkZ2VzLHQpLExuKHQudGFyZ2V0LmluY29taW5nRWRnZXMsdCk7bi5kb25lXzEoKX1mdW5jdGlvbiBaa2UoKXt9cCgxOTQyLDEsc3IsWmtlKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtpbW4oYShuLDEyMSkscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLmludGVybWVkaWF0ZSIsIlVudHJlZWlmeWVyIiwxOTQyKTtmdW5jdGlvbiBodigpe2h2PUYsZ1g9bmV3IE83KCJOT05FIiwwKSxNNz1uZXcgTzcoIk1JRERMRV9UT19NSURETEUiLDEpLEozPW5ldyBPNygiQVZPSURfT1ZFUkxBUCIsMil9ZnVuY3Rpb24gTzcoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBhbW4oZSl7cmV0dXJuIGh2KCksd24oKFFrZSgpLGU4ZSksZSl9ZnVuY3Rpb24gbG1uKCl7cmV0dXJuIGh2KCksUChJKGhYLDEpLFcsMzkyLDAsW2dYLE03LEozXSl9cCgzOTIsMjIsezM6MSwzNDoxLDIyOjEsMzkyOjF9LE83KTt2YXIgSjMsTTcsZ1gsaFg9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLm9wdGlvbnMiLCJFZGdlUm91dGluZ01vZGUiLDM5MixnbixsbW4sYW1uKTtmdW5jdGlvbiBRa2UoKXtRa2U9RixlOGU9eW4oKGh2KCksUChJKGhYLDEpLFcsMzkyLDAsW2dYLE03LEozXSkpKX12YXIgZThlO2Z1bmN0aW9uIGxyKCl7bHI9Rix5dj1uZXcgdHIoIm9yaWdpbiIpLG5ldyB2cigiREVQVEgiLEooMCkpLEY3PW5ldyB2cigiRkFOIixKKDApKSx5WD1uZXcgdnIoIkRFU0NFTkRBTlRTIixKKDApKSxHMD1uZXcgdnIoIlJPT1QiLCh6ZSgpLCExKSksQjc9bmV3IHZyKCJMRUZUTkVJR0hCT1IiLG51bGwpLG44ZT1uZXcgdnIoIlJJR0hUTkVJR0hCT1IiLG51bGwpLHROPW5ldyB2cigiTEVGVFNJQkxJTkciLG51bGwpLEc3PW5ldyB2cigiUklHSFRTSUJMSU5HIixudWxsKSxENz1uZXcgdnIoIkRVTU1ZIiwhMSksbmV3IHZyKCJMRVZFTCIsSigwKSksdlg9bmV3IHZyKCJSRU1PVkFCTEVfRURHRVMiLG5ldyBwciksUTM9bmV3IHZyKCJYQ09PUiIsSigwKSksZVQ9bmV3IHZyKCJZQ09PUiIsSigwKSksb049bmV3IHZyKCJMRVZFTEhFSUdIVCIsMCkscHM9bmV3IHZyKCJMRVZFTE1JTiIsMCksWWw9bmV3IHZyKCJMRVZFTE1BWCIsMCksejc9bmV3IHZyKCJHUkFQSF9YTUlOIiwwKSwkNz1uZXcgdnIoIkdSQVBIX1lNSU4iLDApLHdYPW5ldyB2cigiR1JBUEhfWE1BWCIsMCksRVg9bmV3IHZyKCJHUkFQSF9ZTUFYIiwwKSxtWD1uZXcgdnIoIkNPTVBBQ1RfTEVWRUxfQVNDRU5TSU9OIiwhMSksUjc9bmV3IHZyKCJDT01QQUNUX0NPTlNUUkFJTlRTIixuZXcgUSksbXY9bmV3IHZyKCJJRCIsIiIpLHd2PW5ldyB2cigiUE9TSVRJT04iLEooMCkpLFljPW5ldyB2cigiUFJFTElNIiwwKSxtdz1uZXcgdnIoIk1PRElGSUVSIiwwKSxodz1uZXcgdHIoImJvdW5kaW5nQm94LnVwTGVmdCIpLFozPW5ldyB0cigiYm91bmRpbmdCb3gubG93UmlnaHQiKX12YXIgWjMsaHcsUjcsbVgseVgsRDcsRjcsd1gsejcsRVgsJDcsbXYsQjcsdE4sb04sWWwscHMsbXcseXYsd3YsWWMsdlgsbjhlLEc3LEcwLFEzLGVUO2Z1bmN0aW9uIFNYKCl7U1g9Rix0OGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLmNvbXBhY3Rpb24iLCh6ZSgpLCExKSksbzhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5lZGdlRW5kVGV4dHVyZUxlbmd0aCIsNyksSigwKSxzOGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLnRyZWVMZXZlbCIsSigwKSksYThlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5wb3NpdGlvbkNvbnN0cmFpbnQiLEooLTEpKSxiWD0oRXYoKSxWNyksdThlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS53ZWlnaHRpbmciLGJYKSxDWD0oaHYoKSxKMyksaThlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5lZGdlUm91dGluZ01vZGUiLENYKSxUWD0oc04oKSxxNyksbDhlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5zZWFyY2hPcmRlciIsVFgpfWZ1bmN0aW9uIHI4ZSgpe1NYKCl9cCg4NjIsMSxwbCxyOGUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUuY29tcGFjdGlvbiIpLCIiKSwiUG9zaXRpb24gQ29uc3RyYWludCIpLCJUdXJucyBvbiBUcmVlIGNvbXBhY3Rpb24gd2hpY2ggZGVjcmVhc2VzIHRoZSBzaXplIG9mIHRoZSB3aG9sZSB0cmVlIGJ5IHBsYWNpbmcgbm9kZXMgb2YgbXVsdGlwbGUgbGV2ZWxzIGluIG9uZSBsYXJnZSBsZXZlbCIpLCh6ZSgpLCExKSksKEpjKCksbnQpKSxBciksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUuZWRnZUVuZFRleHR1cmVMZW5ndGgiKSwiIiksIkVkZ2UgRW5kIFRleHR1cmUgTGVuZ3RoIiksIlNob3VsZCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgdGV4dHVyZSBhdCB0aGUgZW5kIG9mIGFuIGVkZ2UuIFRoaXMgdmFsdWUgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgRWRnZSBSb3V0aW5nLiIpLDcpLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS50cmVlTGV2ZWwiKSwiIiksIlRyZWUgTGV2ZWwiKSwiVGhlIGluZGV4IGZvciB0aGUgdHJlZSBsZXZlbCB0aGUgbm9kZSBpcyBpbiIpLEooMCkpLGJvKSx2dCksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5wb3NpdGlvbkNvbnN0cmFpbnQiKSwiIiksIlBvc2l0aW9uIENvbnN0cmFpbnQiKSwiV2hlbiBzZXQgdG8gYSBwb3NpdGl2ZSBudW1iZXIgdGhpcyBvcHRpb24gd2lsbCBmb3JjZSB0aGUgYWxnb3JpdGhtIHRvIHBsYWNlIHRoZSBub2RlIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gd2l0aGluIHRoZSB0cmVlcyBsYXllciBpZiB3ZWlnaHRpbmcgaXMgc2V0IHRvIGNvbnN0cmFpbnQiKSxKKC0xKSksYm8pLHZ0KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLndlaWdodGluZyIpLCIiKSwiV2VpZ2h0aW5nIG9mIE5vZGVzIiksIldoaWNoIHdlaWdodGluZyB0byB1c2Ugd2hlbiBjb21wdXRpbmcgYSBub2RlIG9yZGVyLiIpLGJYKSxtciksRlgpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUuZWRnZVJvdXRpbmdNb2RlIiksIiIpLCJFZGdlIFJvdXRpbmcgTW9kZSIpLCJDaG9vc2VzIGFuIEVkZ2UgUm91dGluZyBhbGdvcml0aG0uIiksQ1gpLG1yKSxoWCksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5zZWFyY2hPcmRlciIpLCIiKSwiU2VhcmNoIE9yZGVyIiksIldoaWNoIHNlYXJjaCBvcmRlciB0byB1c2Ugd2hlbiBjb21wdXRpbmcgYSBzcGFubmluZyB0cmVlLiIpLFRYKSxtciksQlgpLEVlKE9lKSkpKSxjOGUoKG5ldyBfOGUsbikpfTt2YXIgdDhlLG84ZSxpOGUsQ1gsYThlLGw4ZSxUWCxzOGUsdThlLGJYO2coIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLm9wdGlvbnMiLCJNclRyZWVNZXRhRGF0YVByb3ZpZGVyIiw4NjIpO2Z1bmN0aW9uIEZvKCl7Rm89RixrWD1uZXcgVzEoMjApLExYPW5ldyB5dCgoRm4oKSxaYyksa1gpLFU3PW5ldyB5dCh0MSwyMCksTVg9bmV3IHl0KEdRLDMpLGQ4ZT1uZXcgeXQoU2csVW0pLGlOPW5ldyB5dChMVCxKKDEpKSx2OGU9bmV3IHl0KHBSLCh6ZSgpLCEwKSkseFg9eFQsUFg9KFdyKCksQnMpLF9kPW5ldyB5dChuMSxQWCksZjhlPU5ULHA4ZT1hUixoOGU9cjEsbThlPVdmLHk4ZT14Zyx3OGU9VzAsZzhlPUlnLEFYPUFULEU4ZT1qZixEWD0oU1goKSx1OGUpLE9YPWw4ZSxUOGU9SXcsYjhlPWlBLEM4ZT1rVCxTOGU9b0EsUlg9KHBtKCksS2YpLG5ldyB5dCh1bSxSWCksZmc9YThlLEg3PWk4ZSxndT1zOGUsSVg9dDhlLE5YPW84ZX1mdW5jdGlvbiBjOGUoZSl7aGQoZSxuZXcgSl8oalooak4oZ2QoZGQocGQoZmQobmV3IFpfLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiksIkVMSyBNci4gVHJlZSIpLCJUcmVlLWJhc2VkIGFsZ29yaXRobSBwcm92aWRlZCBieSB0aGUgRWNsaXBzZSBMYXlvdXQgS2VybmVsLiBDb21wdXRlcyBhIHNwYW5uaW5nIHRyZWUgb2YgdGhlIGlucHV0IGdyYXBoIGFuZCBhcnJhbmdlcyBhbGwgbm9kZXMgYWNjb3JkaW5nIHRvIHRoZSByZXN1bHRpbmcgcGFyZW50LWNoaWxkcmVuIGhpZXJhcmNoeS4gSSBwaXR5IHRoZSBmb29sIHdobyBkb2Vzbid0IHVzZSBNci4gVHJlZSBMYXlvdXQuIiksbmV3IEk4ZSksIm9yZy5lY2xpcHNlLmVsay50cmVlIiksRWUoKEh3KCksYUQpKSkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsucGFkZGluZyIsa1gpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLm5vZGVOb2RlIiwyMCksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuZWRnZU5vZGUiLDMpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5hc3BlY3RSYXRpbyIsVW0pLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5wcmlvcml0eSIsSigxKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLnNlcGFyYXRlQ29ubmVjdGVkQ29tcG9uZW50cyIsKHplKCksITApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsuZGVidWdNb2RlIix0ZSh4WCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5kaXJlY3Rpb24iLFBYKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsuaW50ZXJhY3RpdmUiLHRlKGY4ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5pbnRlcmFjdGl2ZUxheW91dCIsdGUocDhlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmNvbnN0cmFpbnRzIix0ZShoOGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuZml4ZWRHcmFwaFNpemUiLHRlKG04ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5taW5pbXVtIix0ZSh5OGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUub3B0aW9ucyIsdGUodzhlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVMYWJlbHMucGxhY2VtZW50Iix0ZShnOGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsub21pdE5vZGVNaWNyb0xheW91dCIsdGUoQVgpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsucG9ydExhYmVscy5wbGFjZW1lbnQiLHRlKEU4ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUud2VpZ2h0aW5nIix0ZShEWCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUuc2VhcmNoT3JkZXIiLHRlKE9YKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd25MYXlvdXQiLHRlKFQ4ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLnNjYWxlRmFjdG9yIix0ZShiOGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5oaWVyYXJjaGljYWxOb2RlV2lkdGgiLHRlKEM4ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZSIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVBc3BlY3RSYXRpbyIsdGUoUzhlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24ubm9kZVR5cGUiLFJYKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLnBvc2l0aW9uQ29uc3RyYWludCIsdGUoZmcpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLmVkZ2VSb3V0aW5nTW9kZSIsdGUoSDcpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLnRyZWVMZXZlbCIsdGUoZ3UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5tcnRyZWUiLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlLmNvbXBhY3Rpb24iLHRlKElYKSksWihlLCJvcmcuZWNsaXBzZS5lbGsubXJ0cmVlIiwib3JnLmVjbGlwc2UuZWxrLm1ydHJlZS5lZGdlRW5kVGV4dHVyZUxlbmd0aCIsdGUoTlgpKX1mdW5jdGlvbiBfOGUoKXtGbygpfXAoMTAwNiwxLHBsLF84ZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe2M4ZShuKX07dmFyIGQ4ZSxJWCx4WCxfZCxQWCxOWCxINyxmOGUscDhlLGc4ZSxoOGUsbThlLHk4ZSx3OGUsQVgsTFgsa1gsRThlLGZnLGlOLE9YLHY4ZSxNWCxVNyxTOGUsQzhlLFQ4ZSxSWCxiOGUsZ3UsRFg7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUub3B0aW9ucyIsIk1yVHJlZU9wdGlvbnMiLDEwMDYpO2Z1bmN0aW9uIEk4ZSgpe31wKDEwMDcsMSx7fSxJOGUpLGwuY3JlYXRlXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgUTVlLG59LGwuZGVzdHJveT1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLm9wdGlvbnMiLCJNclRyZWVPcHRpb25zL01ydHJlZUZhY3RvcnkiLDEwMDcpO2Z1bmN0aW9uIEV2KCl7RXY9RixWNz1uZXcgYU4oIk1PREVMX09SREVSIiwwKSxsTj1uZXcgYU4oIkRFU0NFTkRBTlRTIiwxKSxqNz1uZXcgYU4oIkZBTiIsMiksVzc9bmV3IGFOKCJDT05TVFJBSU5UIiwzKX1mdW5jdGlvbiBhTihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHNtbihlKXtyZXR1cm4gRXYoKSx3bigoeDhlKCksUDhlKSxlKX1mdW5jdGlvbiB1bW4oKXtyZXR1cm4gRXYoKSxQKEkoRlgsMSksVywzNTMsMCxbVjcsbE4sajcsVzddKX1wKDM1MywyMix7MzoxLDM0OjEsMjI6MSwzNTM6MX0sYU4pO3ZhciBXNyxsTixqNyxWNyxGWD1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUub3B0aW9ucyIsIk9yZGVyV2VpZ2h0aW5nIiwzNTMsZ24sdW1uLHNtbik7ZnVuY3Rpb24geDhlKCl7eDhlPUYsUDhlPXluKChFdigpLFAoSShGWCwxKSxXLDM1MywwLFtWNyxsTixqNyxXN10pKSl9dmFyIFA4ZTtmdW5jdGlvbiBzTigpe3NOPUYscTc9bmV3IHpYKCJERlMiLDApLCRYPW5ldyB6WCgiQkZTIiwxKX1mdW5jdGlvbiB6WChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGNtbihlKXtyZXR1cm4gc04oKSx3bigoTjhlKCksQThlKSxlKX1mdW5jdGlvbiBfbW4oKXtyZXR1cm4gc04oKSxQKEkoQlgsMSksVyw0MzMsMCxbcTcsJFhdKX1wKDQzMywyMix7MzoxLDM0OjEsMjI6MSw0MzM6MX0selgpO3ZhciAkWCxxNyxCWD1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUub3B0aW9ucyIsIlRyZWVpZnlpbmdPcmRlciIsNDMzLGduLF9tbixjbW4pO2Z1bmN0aW9uIE44ZSgpe044ZT1GLEE4ZT15bigoc04oKSxQKEkoQlgsMSksVyw0MzMsMCxbcTcsJFhdKSkpfXZhciBBOGU7ZnVuY3Rpb24gTDhlKCl7TDhlPUYsTThlPVdpKG5ldyBIciwoS2goKSxmdiksKGd2KCksYVgpKX1mdW5jdGlvbiBkbW4oZSxuKXt2YXIgcix0LG8saSxzO3Q9bmV3IHByLGJyKHQsbix0LnRhaWwucHJldix0LnRhaWwpO2RvIGZvcihyPShybih0LnNpemVfMCE9MCksYShaYSh0LHQuaGVhZGVyLm5leHRfMCksNDApKSxlLnZpc2l0ZWRbci5pZF8wXT0xLGk9ZG4oci5vdXRnb2luZ0VkZ2VzLDApO2kuY3VycmVudE5vZGUhPWkudGhpcyQwMS50YWlsOylvPWEodW4oaSksNjUpLHM9by50YXJnZXQsZS52aXNpdGVkW3MuaWRfMF09PTE/TG4oZS5lbGltaW5hdGVkLG8pOmUudmlzaXRlZFtzLmlkXzBdPT0yP2UudmlzaXRlZFtzLmlkXzBdPTE6YnIodCxzLHQudGFpbC5wcmV2LHQudGFpbCk7d2hpbGUodC5zaXplXzAhPTApfWZ1bmN0aW9uIGZtbihlLG4pe3ZhciByLHQsbyxpLHM7Zm9yKHM9YSh3KG4sKEZvKCksT1gpKSw0MzMpLGk9ZG4obi5ub2RlcywwKTtpLmN1cnJlbnROb2RlIT1pLnRoaXMkMDEudGFpbDspaWYobz1hKHVuKGkpLDQwKSxlLnZpc2l0ZWRbby5pZF8wXT09MCl7c3dpdGNoKHMub3JkaW5hbCl7Y2FzZSAwOms4ZShlLG8pO2JyZWFrO2Nhc2UgMTpkbW4oZSxvKX1lLnZpc2l0ZWRbby5pZF8wXT0yfWZvcih0PWRuKGUuZWxpbWluYXRlZCwwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDY1KSxZZChyLnNvdXJjZS5vdXRnb2luZ0VkZ2VzLHIsITApLFlkKHIudGFyZ2V0LmluY29taW5nRWRnZXMsciwhMCk7aihuLChscigpLHZYKSxlLmVsaW1pbmF0ZWQpfWZ1bmN0aW9uIGs4ZShlLG4pe3ZhciByLHQsbztmb3IoZS52aXNpdGVkW24uaWRfMF09MSx0PWRuKG4ub3V0Z29pbmdFZGdlcywwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDY1KSxvPXIudGFyZ2V0LGUudmlzaXRlZFtvLmlkXzBdPT0xP0xuKGUuZWxpbWluYXRlZCxyKTplLnZpc2l0ZWRbby5pZF8wXT09Mj9lLnZpc2l0ZWRbby5pZF8wXT0xOms4ZShlLG8pfWZ1bmN0aW9uIHBtbihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPW4ubm9kZXMuc2l6ZV8wLGUuZWxpbWluYXRlZD1uZXcgcHIsZS52aXNpdGVkPUIoaG4sa24sMjgsaSwxNSwxKSxyPTAsbz1kbihuLm5vZGVzLDApO28uY3VycmVudE5vZGUhPW8udGhpcyQwMS50YWlsOyl0PWEodW4obyksNDApLHQuaWRfMD1yKyt9ZnVuY3Rpb24gZ21uKGUsbixyKXtyLmJlZ2luKCJERlMgVHJlZWlmeWluZyBwaGFzZSIsMSkscG1uKGUsbiksZm1uKGUsbiksZS5lbGltaW5hdGVkPW51bGwsZS52aXNpdGVkPW51bGwsci5kb25lXzEoKX1mdW5jdGlvbiBPOGUoKXtMOGUoKX1wKDE0ODYsMSxXdCxPOGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEyMSksTThlfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtnbW4odGhpcyxhKG4sMTIxKSxyKX07dmFyIE04ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wMXRyZWVpZnkiLCJERlNUcmVlaWZ5ZXIiLDE0ODYpO2Z1bmN0aW9uIFhoKCl7WGg9Rix6OGU9aHUoaHUoaHUoTHYobmV3IEhyLChLaCgpLGR2KSksKGd2KCksazcpKSxzWCksZFgpfWZ1bmN0aW9uIFI4ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZTtmb3Ioci5iZWdpbigiUHJvY2Vzc29yIGFycmFuZ2UgbGV2ZWwiLDEpLERlPWEoVG8oSm4obmV3IFNlKG51bGwsbmV3IHhlKG4sMTYpKSxuZXcgRzhlKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksZD1hKFRvKEpuKG5ldyBTZShudWxsLG5ldyB4ZShuLDE2KSksbmV3IEg4ZShuKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsW0NvXSkpKSwxNSkseT1hKFRvKEpuKG5ldyBTZShudWxsLG5ldyB4ZShuLDE2KSksbmV3IFU4ZShuKSksbmEobmV3IEdpLG5ldyBCaSxuZXcgSGksUChJKG9vLDEpLFcsMTA4LDAsW0NvXSkpKSwxNSksRT1CKHJOLHFiLDQwLG4uc2l6ZV8xKCksMCwxKSxzPTA7czxkLnNpemVfMSgpO3MrKylvPWEoZC5nZXRfMChzKSw0MCksd2U9YSh3KG8sKEZvKCksZmcpKSwxNykudmFsdWVfMCx3ZT49MCYmd2U8ZC5zaXplXzEoKSYmIUVbd2VdJiYoRVt3ZV09byxkLnJlbW92ZV8yKHMpLC0tcyk7Zm9yKHU9MDt1PGQuc2l6ZV8xKCk7dSsrKWZvcihvPWEoZC5nZXRfMCh1KSw0MCksd2U9YSh3KG8sKEZvKCksZmcpKSwxNykudmFsdWVfMCxoPTA7O2grKyl7aWYobT13ZStoLG08RS5sZW5ndGgmJm0+PTAmJiFFW21dKXtFW21dPW8sZC5yZW1vdmVfMih1KSwtLXU7YnJlYWt9aWYobT13ZS1oLG08RS5sZW5ndGgmJm0+PTAmJiFFW21dKXtFW21dPW8sZC5yZW1vdmVfMih1KSwtLXU7YnJlYWt9fWZvcih5LnNvcnRfMChuZXcgVzhlKSxjPUUubGVuZ3RoLTE7Yz49MDtjLS0pIUVbY10mJiF5LmlzRW1wdHkoKSYmKEVbY109YSh5LmdldF8wKDApLDQwKSx5LnJlbW92ZV8yKDApKTtmb3IoXz0wO188RS5sZW5ndGg7XysrKSFFW19dJiYhRGUuaXNFbXB0eSgpJiYoRVtfXT1hKERlLmdldF8wKDApLDQwKSxEZS5yZW1vdmVfMigwKSk7Zm9yKGk9MDtpPEUubGVuZ3RoO2krKylqKEVbaV0sKGxyKCksd3YpLEooaSkpO2ZvcihmPWEoUGVuKEpuKG5ldyBTZShudWxsLG5ldyB4ZShuLDE2KSksbmV3IGo4ZSkpLDUzNCkscT1mLG5lPTAsdmU9cS5sZW5ndGg7bmU8dmU7KytuZSl7Zm9yKEg9cVtuZV0sdD1ONyhIKSxSOGUoZSx0LHIuc3ViVGFzaygxL2YubGVuZ3RofDApKSxOZSgpLHdfKHQsbmV3IHVEKChscigpLHd2KSkpLHY9bmV3IHByLE09ZG4odCwwKTtNLmN1cnJlbnROb2RlIT1NLnRoaXMkMDEudGFpbDspZm9yKGs9YSh1bihNKSw0MCksQT1kbihILm91dGdvaW5nRWRnZXMsMCk7QS5jdXJyZW50Tm9kZSE9QS50aGlzJDAxLnRhaWw7KXg9YSh1bihBKSw2NSkseC50YXJnZXQ9PWsmJmJyKHYseCx2LnRhaWwucHJldix2LnRhaWwpO2thKEgub3V0Z29pbmdFZGdlcyksZnQoSC5vdXRnb2luZ0VkZ2VzLHYpfXIuZG9uZV8xKCl9ZnVuY3Rpb24gRDhlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxO2ZvcihyLmJlZ2luKCJQcm9jZXNzb3IgYXJyYW5nZSBsZXZlbCIsMSksaD0obHIoKSxGNyksZS53ZWlnaHRpbmc9PShFdigpLGxOKSYmKGg9eVgpLGQ9MCxOZSgpLG4uc29ydF8wKG5ldyB1RChoKSksaT1uLnNpemVfMSgpLHU9bi5saXN0SXRlcmF0b3JfMShuLnNpemVfMSgpKSxfPSEwO18mJnUuaGFzUHJldmlvdXMoKTspQT1hKHUucHJldmlvdXNfMCgpLDQwKSxhKHcoQSxoKSwxNykudmFsdWVfMD09MD8tLWk6Xz0hMTtpZihxPW4uc3ViTGlzdCgwLGkpLHM9bmV3IGlrKHEpLHE9bi5zdWJMaXN0KGksbi5zaXplXzEoKSksYz1uZXcgaWsocSkscy5zaXplXzA9PTApZm9yKEU9ZG4oYywwKTtFLmN1cnJlbnROb2RlIT1FLnRoaXMkMDEudGFpbDspeT1hKHVuKEUpLDQwKSxqKHksd3YsSihkKyspKTtlbHNlIGZvcihmPXMuc2l6ZV8wLEg9ZG4ocywwKTtILmN1cnJlbnROb2RlIT1ILnRoaXMkMDEudGFpbDspe2ZvcihNPWEodW4oSCksNDApLGooTSx3dixKKGQrKykpLHQ9TjcoTSksRDhlKGUsdCxyLnN1YlRhc2soMS9mfDApKSx3Xyh0LEhCKG5ldyB1RCh3dikpKSxtPW5ldyBwcixrPWRuKHQsMCk7ay5jdXJyZW50Tm9kZSE9ay50aGlzJDAxLnRhaWw7KWZvcihBPWEodW4oayksNDApLHg9ZG4oTS5vdXRnb2luZ0VkZ2VzLDApO3guY3VycmVudE5vZGUhPXgudGhpcyQwMS50YWlsOyl2PWEodW4oeCksNjUpLHYudGFyZ2V0PT1BJiZicihtLHYsbS50YWlsLnByZXYsbS50YWlsKTtmb3Ioa2EoTS5vdXRnb2luZ0VkZ2VzKSxmdChNLm91dGdvaW5nRWRnZXMsbSksdT1kbihjLGMuc2l6ZV8wKSxvPU0ub3V0Z29pbmdFZGdlcy5zaXplXzAsXz0hMDswPG8mJl8mJnUuaGFzUHJldmlvdXMoKTspQT1hKHUucHJldmlvdXNfMCgpLDQwKSxhKHcoQSxoKSwxNykudmFsdWVfMD09MD8oaihBLHd2LEooZCsrKSksLS1vLHUucmVtb3ZlKCkpOl89ITF9ci5kb25lXzEoKX1mdW5jdGlvbiBobW4oZSxuLHIpe3ZhciB0O3IuYmVnaW4oIlByb2Nlc3NvciBhcnJhbmdlIG5vZGUiLDEpLGFlKGllKHcobiwoRm8oKSx4WCkpKSksdD1hKHZhKHh5KEpuKG5ldyBTZShudWxsLG5ldyB4ZShuLm5vZGVzLDE2KSksbmV3IEI4ZSkpKSw0MCksZS53ZWlnaHRpbmc9YSh3KG4sRFgpLDM1MyksZS53ZWlnaHRpbmc9PShFdigpLGo3KXx8ZS53ZWlnaHRpbmc9PWxOP0Q4ZShlLG5ldyBlYShQKEkock4sMSkscWIsNDAsMCxbdF0pKSxyLnN1YlRhc2soMSkpOmUud2VpZ2h0aW5nPT1XNyYmUjhlKGUsbmV3IGVhKFAoSShyTiwxKSxxYiw0MCwwLFt0XSkpLHIuc3ViVGFzaygxKSksci5kb25lXzEoKX1mdW5jdGlvbiBGOGUoKXtYaCgpfWZ1bmN0aW9uIG1tbihlLG4pe3JldHVybiBYaCgpLGEodyhuLChGbygpLGZnKSksMTcpLnZhbHVlXzA8ZS5zaXplXzEoKSYmYSh3KG4sZmcpLDE3KS52YWx1ZV8wPj0wfWZ1bmN0aW9uIHltbihlLG4pe3JldHVybiBYaCgpLGEodyhuLChGbygpLGZnKSksMTcpLnZhbHVlXzA+PWUuc2l6ZV8xKCl9ZnVuY3Rpb24gd21uKGUsbil7cmV0dXJuIFhoKCksLXFvKGEodyhlLChGbygpLGZnKSksMTcpLnZhbHVlXzAsYSh3KG4sZmcpLDE3KS52YWx1ZV8wKX1wKDE0ODcsMSxXdCxGOGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEyMSksejhlfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtobW4odGhpcyxhKG4sMTIxKSxyKX07dmFyIHo4ZTtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wMm9yZGVyIiwiTm9kZU9yZGVyZXIiLDE0ODcpO2Z1bmN0aW9uICQ4ZShlKXtyZXR1cm4gWGgoKSxCKHJOLHFiLDQwLGUsMCwxKX1mdW5jdGlvbiBFbW4oKXt9cCgxNDk0LDEse30sRW1uKSxsLmFwcGx5XzI9ZnVuY3Rpb24obil7cmV0dXJuICQ4ZShuKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDJvcmRlciIsIk5vZGVPcmRlcmVyLzBtZXRob2RyZWYkbGFtYmRhJDYkVHlwZSIsMTQ5NCk7ZnVuY3Rpb24gQjhlKCl7fXAoMTQ4OCwxLEluLEI4ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFhoKCksYWUoaWUodyhhKG4sNDApLChscigpLEcwKSkpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDJvcmRlciIsIk5vZGVPcmRlcmVyL2xhbWJkYSQwJFR5cGUiLDE0ODgpO2Z1bmN0aW9uIEc4ZSgpe31wKDE0ODksMSxJbixHOGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBYaCgpLGEodyhhKG4sNDApLChGbygpLGZnKSksMTcpLnZhbHVlXzA8MH0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDJvcmRlciIsIk5vZGVPcmRlcmVyL2xhbWJkYSQxJFR5cGUiLDE0ODkpO2Z1bmN0aW9uIEg4ZShlKXt0aGlzLmN1cnJlbnRMZXZlbF8wPWV9cCgxNDkwLDEsSW4sSDhlKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gbW1uKHRoaXMuY3VycmVudExldmVsXzAsYShuLDQwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnAyb3JkZXIiLCJOb2RlT3JkZXJlci9sYW1iZGEkMiRUeXBlIiwxNDkwKTtmdW5jdGlvbiBVOGUoZSl7dGhpcy5jdXJyZW50TGV2ZWxfMD1lfXAoMTQ5MSwxLEluLFU4ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHltbih0aGlzLmN1cnJlbnRMZXZlbF8wLGEobiw0MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wMm9yZGVyIiwiTm9kZU9yZGVyZXIvbGFtYmRhJDMkVHlwZSIsMTQ5MSk7ZnVuY3Rpb24gVzhlKCl7fXAoMTQ5MiwxLE5uLFc4ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gd21uKGEobiw0MCksYShyLDQwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDJvcmRlciIsIk5vZGVPcmRlcmVyL2xhbWJkYSQ0JFR5cGUiLDE0OTIpO2Z1bmN0aW9uIGo4ZSgpe31wKDE0OTMsMSxJbixqOGUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBYaCgpLGEodyhhKG4sNDApLChscigpLEY3KSksMTcpLnZhbHVlXzAhPTB9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnAyb3JkZXIiLCJOb2RlT3JkZXJlci9sYW1iZGEkNSRUeXBlIiwxNDkzKTtmdW5jdGlvbiBWOGUoKXtWOGU9RixLOGU9aHUoaHUoTHYoaHUoaHUoTHYoTW4obmV3IEhyLChLaCgpLGR2KSwoZ3YoKSxrNykpLGZ2KSxfWCksZlgpLHB2KSxsWCkscFgpfWZ1bmN0aW9uIHZtbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO2ZvcihmPWEoaEkoKHM9ZG4obmV3IGNjKG4pLnRoaXMkMDEub3V0Z29pbmdFZGdlcywwKSxuZXcgZGcocykpKSw0MCkseT1mP2EodyhmLChscigpLEI3KSksNDApOm51bGwsbz0xO2YmJnk7KXtmb3IoYz0wLE09MCxyPWYsdD15LHU9MDt1PG87dSsrKXI9QTcociksdD1BNyh0KSxNKz1SKCQodyhyLChscigpLG13KSkpKSxjKz1SKCQodyh0LG13KSkpO2lmKGs9UigkKHcoeSwobHIoKSxZYykpKSksQT1SKCQodyhmLFljKSkpLGg9R1goZSxmLHkpLG09aytjK2Uuc3BhY2luZytoLUEtTSwwPG0pe2ZvcihfPW4sZD0wO18mJl8hPXQ7KSsrZCxfPWEodyhfLHROKSw0MCk7aWYoXylmb3IoeD1tL2QsXz1uO18hPXQ7KXY9UigkKHcoXyxZYykpKSttLGooXyxZYyx2KSxFPVIoJCh3KF8sbXcpKSkrbSxqKF8sbXcsRSksbS09eCxfPWEodyhfLHROKSw0MCk7ZWxzZSByZXR1cm59KytvLGYub3V0Z29pbmdFZGdlcy5zaXplXzA9PTA/Zj10WChuZXcgY2Mobiksbyk6Zj1hKGhJKChpPWRuKG5ldyBjYyhmKS50aGlzJDAxLm91dGdvaW5nRWRnZXMsMCksbmV3IGRnKGkpKSksNDApLHk9Zj9hKHcoZixCNyksNDApOm51bGx9fWZ1bmN0aW9uIHE4ZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmO2lmKGoobiwobHIoKSxtdyksMCksYz1hKHcobix0TiksNDApLG4ub3V0Z29pbmdFZGdlcy5zaXplXzA9PTApYz8oZD1SKCQodyhjLFljKSkpK2Uuc3BhY2luZytHWChlLGMsbiksaihuLFljLGQpKTpqKG4sWWMsMCk7ZWxzZXtmb3IodD0oaT1kbihuZXcgY2MobikudGhpcyQwMS5vdXRnb2luZ0VkZ2VzLDApLG5ldyBkZyhpKSk7REModC52YWwkZWRnZXNJdGVyMik7KXI9YSh1bih0LnZhbCRlZGdlc0l0ZXIyKSw2NSkudGFyZ2V0LHE4ZShlLHIpO3U9YShoSSgocz1kbihuZXcgY2MobikudGhpcyQwMS5vdXRnb2luZ0VkZ2VzLDApLG5ldyBkZyhzKSkpLDQwKSxmPWEoVUtlKChvPWRuKG5ldyBjYyhuKS50aGlzJDAxLm91dGdvaW5nRWRnZXMsMCksbmV3IGRnKG8pKSksNDApLF89KFIoJCh3KGYsWWMpKSkrUigkKHcodSxZYykpKSkvMixjPyhkPVIoJCh3KGMsWWMpKSkrZS5zcGFjaW5nK0dYKGUsYyxuKSxqKG4sWWMsZCksaihuLG13LFIoJCh3KG4sWWMpKSktXyksdm1uKGUsbikpOmoobixZYyxfKX19ZnVuY3Rpb24gR1goZSxuLHIpe3ZhciB0O3JldHVybiB0PTAsbiYmKEFnKGUuZGlyZWN0aW9uKT90Kz1uLnNpemVfMC54XzAvMjp0Kz1uLnNpemVfMC55XzAvMiksciYmKEFnKGUuZGlyZWN0aW9uKT90Kz1yLnNpemVfMC54XzAvMjp0Kz1yLnNpemVfMC55XzAvMiksdH1mdW5jdGlvbiBTbW4oZSxuLHIpe3ZhciB0LG8saSxzO2ZvcihyLmJlZ2luKCJQcm9jZXNzb3Igb3JkZXIgbm9kZXMiLDIpLGUuc3BhY2luZz1SKCQodyhuLChGbygpLFU3KSkpKSxlLmRpcmVjdGlvbj1hKHcobixfZCksODgpLGUuZGlyZWN0aW9uPT0oV3IoKSxCcykmJihlLmRpcmVjdGlvbj0kcyxqKG4sX2QsZS5kaXJlY3Rpb24pKSxvPW5ldyBwcixzPWRuKG4ubm9kZXMsMCk7cy5jdXJyZW50Tm9kZSE9cy50aGlzJDAxLnRhaWw7KWk9YSh1bihzKSw0MCksYWUoaWUodyhpLChscigpLEcwKSkpKSYmYnIobyxpLG8udGFpbC5wcmV2LG8udGFpbCk7dD0ocm4oby5zaXplXzAhPTApLGEoby5oZWFkZXIubmV4dF8wLnZhbHVlXzAsNDApKSxxOGUoZSx0KSxyLndvcmtlZCgxKSxIWChlLHQsMC1SKCQodyh0LChscigpLG9OKSkpKS8yLDApLHIud29ya2VkKDEpLHIuZG9uZV8xKCl9ZnVuY3Rpb24gSFgoZSxuLHIsdCl7dmFyIG8saSxzO24mJihpPVIoJCh3KG4sKGxyKCksWWMpKSkpK3Qscz1yK1IoJCh3KG4sb04pKSkvMixqKG4sUTMsSihTbihIbyhTLk1hdGgucm91bmQoaSkpKSkpLGoobixlVCxKKFNuKEhvKFMuTWF0aC5yb3VuZChzKSkpKSksbi5vdXRnb2luZ0VkZ2VzLnNpemVfMD09MHx8SFgoZSxhKGhJKChvPWRuKG5ldyBjYyhuKS50aGlzJDAxLm91dGdvaW5nRWRnZXMsMCksbmV3IGRnKG8pKSksNDApLHIrUigkKHcobixvTikpKStlLnNwYWNpbmcsdCtSKCQodyhuLG13KSkpKSx3KG4sRzcpIT1udWxsJiZIWChlLGEodyhuLEc3KSw0MCkscix0KSl9ZnVuY3Rpb24gWThlKCl7VjhlKCl9cCgxNDk1LDEsV3QsWThlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwxMjEpLEs4ZX0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7U21uKHRoaXMsYShuLDEyMSkscil9LGwuc3BhY2luZz0wO3ZhciBLOGU7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDNwbGFjZSIsIk5vZGVQbGFjZXIiLDE0OTUpO2Z1bmN0aW9uIF9jKCl7X2M9RixKOGU9aHUoaHUoaHUoTHYobmV3IEhyLChLaCgpLHB2KSksKGd2KCksY1gpKSxpWCksdVgpfWZ1bmN0aW9uIENtbihlLG4scix0LG8saSxzKXt2YXIgdSxjLF8sZCxmLGgsbSx5O3JldHVybiBoPWEodC5maXJzdCwxNykudmFsdWVfMCxtPWEodC5zZWNvbmQsMTcpLnZhbHVlXzAsZj1lLnNvdXJjZSx5PWUudGFyZ2V0LHU9MCxkPTAsbj09KFdyKCksYW8pfHxuPT1tbz8oZD16QyhHMWUodWYocG8obmV3IFNlKG51bGwsbmV3IHhlKHIubm9kZXMsMTYpKSxuZXcgaDllKSxuZXcgUThlKSkpLGYucG9zLnlfMCtmLnNpemVfMC55XzAvMj5kPyhfPSsrbSx1PVIoJCh2YShjZihwbyhuZXcgU2UobnVsbCxuZXcgeGUoci5ub2RlcywxNikpLG5ldyBtOWUobyxfKSksbmV3IGU5ZSkpKSkpOihjPSsraCx1PVIoJCh2YShiaChwbyhuZXcgU2UobnVsbCxuZXcgeGUoci5ub2RlcywxNikpLG5ldyB5OWUobyxjKSksbmV3IG45ZSkpKSkpKTooZD16QyhHMWUodWYocG8obmV3IFNlKG51bGwsbmV3IHhlKHIubm9kZXMsMTYpKSxuZXcgYTllKSxuZXcgcjllKSkpLGYucG9zLnhfMCtmLnNpemVfMC54XzAvMj5kPyhfPSsrbSx1PVIoJCh2YShjZihwbyhuZXcgU2UobnVsbCxuZXcgeGUoci5ub2RlcywxNikpLG5ldyBsOWUobyxfKSksbmV3IHQ5ZSkpKSkpOihjPSsraCx1PVIoJCh2YShiaChwbyhuZXcgU2UobnVsbCxuZXcgeGUoci5ub2RlcywxNikpLG5ldyBzOWUobyxjKSksbmV3IG85ZSkpKSkpKSxuPT1hbz8oTXQoZS5iZW5kUG9pbnRzLG5ldyBZKFIoJCh3KGYsKGxyKCkscHMpKSkpLW8sdSkpLE10KGUuYmVuZFBvaW50cyxuZXcgWSh5LnBvcy54XzAreS5zaXplXzAueF8wK28raSx1KSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHkucG9zLnhfMCt5LnNpemVfMC54XzArbytpLHkucG9zLnlfMCt5LnNpemVfMC55XzAvMikpLE10KGUuYmVuZFBvaW50cyxuZXcgWSh5LnBvcy54XzAreS5zaXplXzAueF8wLHkucG9zLnlfMCt5LnNpemVfMC55XzAvMikpKTpuPT1tbz8oTXQoZS5iZW5kUG9pbnRzLG5ldyBZKFIoJCh3KGYsKGxyKCksWWwpKSkpK28sZi5wb3MueV8wK2Yuc2l6ZV8wLnlfMC8yKSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKGYucG9zLnhfMCtmLnNpemVfMC54XzArbyx1KSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHkucG9zLnhfMC1vLWksdSkpLE10KGUuYmVuZFBvaW50cyxuZXcgWSh5LnBvcy54XzAtby1pLHkucG9zLnlfMCt5LnNpemVfMC55XzAvMikpLE10KGUuYmVuZFBvaW50cyxuZXcgWSh5LnBvcy54XzAseS5wb3MueV8wK3kuc2l6ZV8wLnlfMC8yKSkpOm49PW9sPyhNdChlLmJlbmRQb2ludHMsbmV3IFkodSxSKCQodyhmLChscigpLHBzKSkpKS1vKSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHUseS5wb3MueV8wK3kuc2l6ZV8wLnlfMCtvK2kpKSxNdChlLmJlbmRQb2ludHMsbmV3IFkoeS5wb3MueF8wK3kuc2l6ZV8wLnhfMC8yLHkucG9zLnlfMCt5LnNpemVfMC55XzArbytpKSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHkucG9zLnhfMCt5LnNpemVfMC54XzAvMix5LnBvcy55XzAreS5zaXplXzAueV8wK28pKSk6KGUuYmVuZFBvaW50cy5zaXplXzA9PTB8fChhKFJsKGUuYmVuZFBvaW50cyksOCkueV8wPVIoJCh3KGYsKGxyKCksWWwpKSkpK28qYShzLnNlY29uZCwxNykudmFsdWVfMCksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHUsUigkKHcoZiwobHIoKSxZbCkpKSkrbyphKHMuc2Vjb25kLDE3KS52YWx1ZV8wKSksTXQoZS5iZW5kUG9pbnRzLG5ldyBZKHUseS5wb3MueV8wLW8qYShzLmZpcnN0LDE3KS52YWx1ZV8wLWkpKSksbmV3IFpyKEooaCksSihtKSl9ZnVuY3Rpb24gVG1uKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHk7Zm9yKGY9ZG4oZS5ub2RlcywwKTtmLmN1cnJlbnROb2RlIT1mLnRoaXMkMDEudGFpbDspaWYoZD1hKHVuKGYpLDQwKSwhVGUoZC5sYWJlbF8wLCJTVVBFUl9ST09UIikpZm9yKGk9YShUbyhuZXcgU2UobnVsbCxuZXcgeGUod2huKGQsZSksMTYpKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbKHJhKCksQ28pXSkpKSwxNSksbj09KFdyKCksYW8pfHxuPT1tbz9pLnNvcnRfMChuZXcgXzllKTppLnNvcnRfMChuZXcgZjllKSx5PWkuc2l6ZV8xKCksbz0wO288eTtvKyspcz15PT0xPy41OigxK28pLyh5KzEpLG49PWFvPyhfPVIoJCh3KGQsKGxyKCksWWwpKSkpLGQucG9zLnhfMCtkLnNpemVfMC54XzArdDxfP010KGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyxuZXcgWShfK3IsZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCpzKSk6YShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLnNpemVfMD4wJiYodT1hKFJsKGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyksOCkueF8wLGg9ZC5wb3MueF8wK2Quc2l6ZV8wLnhfMC8yLGM9YShSbChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMpLDgpLnlfMCxtPWQucG9zLnlfMCtkLnNpemVfMC55XzAvMix0PjAmJlMuTWF0aC5hYnMoYy1tKS8oUy5NYXRoLmFicyh1LWgpLzQwKT41MCYmKG0+Yz9NdChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMsbmV3IFkoZC5wb3MueF8wK2Quc2l6ZV8wLnhfMCt0LzUuMyxkLnBvcy55XzArZC5zaXplXzAueV8wKnMtdC8yKSk6TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzArdC81LjMsZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCpzK3QvMikpKSksTXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzAsZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCpzKSkpOm49PW1vPyhfPVIoJCh3KGQsKGxyKCkscHMpKSkpLGQucG9zLnhfMC10Pl8/TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKF8tcixkLnBvcy55XzArZC5zaXplXzAueV8wKnMpKTphKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMuc2l6ZV8wPjAmJih1PWEoUmwoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzKSw4KS54XzAsaD1kLnBvcy54XzArZC5zaXplXzAueF8wLzIsYz1hKFJsKGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyksOCkueV8wLG09ZC5wb3MueV8wK2Quc2l6ZV8wLnlfMC8yLHQ+MCYmUy5NYXRoLmFicyhjLW0pLyhTLk1hdGguYWJzKHUtaCkvNDApPjUwJiYobT5jP010KGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyxuZXcgWShkLnBvcy54XzAtdC81LjMsZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCpzLXQvMikpOk10KGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyxuZXcgWShkLnBvcy54XzAtdC81LjMsZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCpzK3QvMikpKSksTXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCxkLnBvcy55XzArZC5zaXplXzAueV8wKnMpKSk6bj09b2w/KF89UigkKHcoZCwobHIoKSxZbCkpKSksZC5wb3MueV8wK2Quc2l6ZV8wLnlfMCt0PF8/TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzAqcyxfK3IpKTphKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMuc2l6ZV8wPjAmJih1PWEoUmwoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzKSw4KS54XzAsaD1kLnBvcy54XzArZC5zaXplXzAueF8wLzIsYz1hKFJsKGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyksOCkueV8wLG09ZC5wb3MueV8wK2Quc2l6ZV8wLnlfMC8yLHQ+MCYmUy5NYXRoLmFicyh1LWgpLyhTLk1hdGguYWJzKGMtbSkvNDApPjUwJiYoaD51P010KGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyxuZXcgWShkLnBvcy54XzArZC5zaXplXzAueF8wKnMtdC8yLGQucG9zLnlfMCt0LzUuMytkLnNpemVfMC55XzApKTpNdChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMsbmV3IFkoZC5wb3MueF8wK2Quc2l6ZV8wLnhfMCpzK3QvMixkLnBvcy55XzArdC81LjMrZC5zaXplXzAueV8wKSkpKSxNdChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMsbmV3IFkoZC5wb3MueF8wK2Quc2l6ZV8wLnhfMCpzLGQucG9zLnlfMCtkLnNpemVfMC55XzApKSk6KF89UigkKHcoZCwobHIoKSxwcykpKSksZWtlKGEoaS5nZXRfMChvKSw2NSksZSk/TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzAqcyxhKFJsKGEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cyksOCkueV8wKSk6ZC5wb3MueV8wLXQ+Xz9NdChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMsbmV3IFkoZC5wb3MueF8wK2Quc2l6ZV8wLnhfMCpzLF8tcikpOmEoaS5nZXRfMChvKSw2NSkuYmVuZFBvaW50cy5zaXplXzA+MCYmKHU9YShSbChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMpLDgpLnhfMCxoPWQucG9zLnhfMCtkLnNpemVfMC54XzAvMixjPWEoUmwoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzKSw4KS55XzAsbT1kLnBvcy55XzArZC5zaXplXzAueV8wLzIsdD4wJiZTLk1hdGguYWJzKHUtaCkvKFMuTWF0aC5hYnMoYy1tKS80MCk+NTAmJihoPnU/TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzAqcy10LzIsZC5wb3MueV8wLXQvNS4zKSk6TXQoYShpLmdldF8wKG8pLDY1KS5iZW5kUG9pbnRzLG5ldyBZKGQucG9zLnhfMCtkLnNpemVfMC54XzAqcyt0LzIsZC5wb3MueV8wLXQvNS4zKSkpKSxNdChhKGkuZ2V0XzAobyksNjUpLmJlbmRQb2ludHMsbmV3IFkoZC5wb3MueF8wK2Quc2l6ZV8wLnhfMCpzLGQucG9zLnlfMCkpKX1mdW5jdGlvbiBibW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2Zvcih1PWRuKGUubm9kZXMsMCk7dS5jdXJyZW50Tm9kZSE9dS50aGlzJDAxLnRhaWw7KWlmKHM9YSh1bih1KSw0MCksIVRlKHMubGFiZWxfMCwiU1VQRVJfUk9PVCIpKWZvcihfPUVobihzLGUpLG49PShXcigpLGFvKXx8bj09bW8/RHIoXyxuZXcgdTllKTpEcihfLG5ldyBjOWUpLGM9Xy5hcnJheS5sZW5ndGgsdD0wO3Q8Yzt0KyspZD0oQWUodCxfLmFycmF5Lmxlbmd0aCksYShfLmFycmF5W3RdLDY1KSkudGFyZ2V0LFRlKGQubGFiZWxfMCwibjExIiksIShhZShpZSh3KHMsKGxyKCksbVgpKSkpJiYhZWtlKChBZSh0LF8uYXJyYXkubGVuZ3RoKSxhKF8uYXJyYXlbdF0sNjUpKSxlKSkmJihvPWM9PTE/LjU6KHQrMSkvKGMrMSksbj09YW8/KGk9UigkKHcocyxwcykpKSxoPXMucG9zLnlfMCtzLnNpemVfMC55XzAqbyxMcCgoQWUodCxfLmFycmF5Lmxlbmd0aCksYShfLmFycmF5W3RdLDY1KSkuYmVuZFBvaW50cyxuZXcgWShTLk1hdGgubWluKGkscy5wb3MueF8wLXIpLGgpKSxMcCgoQWUodCxfLmFycmF5Lmxlbmd0aCksYShfLmFycmF5W3RdLDY1KSkuYmVuZFBvaW50cyxuZXcgWShzLnBvcy54XzAsaCkpKTpuPT1tbz8oaT1SKCQodyhzLFlsKSkpK3IsaD1zLnBvcy55XzArcy5zaXplXzAueV8wKm8sTHAoKEFlKHQsXy5hcnJheS5sZW5ndGgpLGEoXy5hcnJheVt0XSw2NSkpLmJlbmRQb2ludHMsbmV3IFkoaSxoKSksTHAoKEFlKHQsXy5hcnJheS5sZW5ndGgpLGEoXy5hcnJheVt0XSw2NSkpLmJlbmRQb2ludHMsbmV3IFkocy5wb3MueF8wK3Muc2l6ZV8wLnhfMCxoKSkpOm49PW9sPyhpPVIoJCh3KHMscHMpKSksZj1zLnBvcy54XzArcy5zaXplXzAueF8wKm8sTHAoKEFlKHQsXy5hcnJheS5sZW5ndGgpLGEoXy5hcnJheVt0XSw2NSkpLmJlbmRQb2ludHMsbmV3IFkoZixTLk1hdGgubWluKHMucG9zLnlfMC1yLGkpKSksTHAoKEFlKHQsXy5hcnJheS5sZW5ndGgpLGEoXy5hcnJheVt0XSw2NSkpLmJlbmRQb2ludHMsbmV3IFkoZixzLnBvcy55XzApKSk6KGk9UigkKHcocyxZbCkpKStyLGY9cy5wb3MueF8wK3Muc2l6ZV8wLnhfMCpvLExwKChBZSh0LF8uYXJyYXkubGVuZ3RoKSxhKF8uYXJyYXlbdF0sNjUpKS5iZW5kUG9pbnRzLG5ldyBZKGYsaSkpLExwKChBZSh0LF8uYXJyYXkubGVuZ3RoKSxhKF8uYXJyYXlbdF0sNjUpKS5iZW5kUG9pbnRzLG5ldyBZKGYscy5wb3MueV8wK3Muc2l6ZV8wLnlfMCkpKSl9ZnVuY3Rpb24gSW1uKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyO2Zvcih3ZT0wLERlPTAsbmU9bmV3IHNuLEg9YSh2YShjZihwbyhuZXcgU2UobnVsbCxuZXcgeGUoZS5ub2RlcywxNikpLG5ldyBpOWUpLG5ldyBaOGUpKSwxNykudmFsdWVfMCsxLHZlPUIoaG4sa24sMjgsSCwxNSwxKSx2PUIoaG4sa24sMjgsSCwxNSwxKSxFPTA7RTxIO0UrKyl2ZVtFXT0wLHZbRV09MDtmb3IoYz1hKFRvKFVHKG5ldyBTZShudWxsLG5ldyB4ZShlLmVkZ2VzLDE2KSkpLG5hKG5ldyBHaSxuZXcgQmksbmV3IEhpLFAoSShvbywxKSxXLDEwOCwwLFsocmEoKSxDbyldKSkpLDE1KSxkPWMuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KWlmKF89YShkLm5leHRfMSgpLDY1KSxubj1hKHcoXy5zb3VyY2UsKEZvKCksZ3UpKSwxNykudmFsdWVfMCxTcj1hKHcoXy50YXJnZXQsZ3UpLDE3KS52YWx1ZV8wLE09U3Itbm4sTT4xKWZvcih1PW5uKzE7dTxTcjt1Kyspe2lmKGY9dSxxPWEoVG8oSm4obmV3IFNlKG51bGwsbmV3IHhlKGUubm9kZXMsMTYpKSxuZXcgZDllKGYpKSxuYShuZXcgR2ksbmV3IEJpLG5ldyBIaSxQKEkob28sMSksVywxMDgsMCxbQ29dKSkpLDE1KSx5PTAsbj09KFdyKCksYW8pfHxuPT1tbyl7Zm9yKHEuc29ydF8wKG5ldyBwOWUpLHk9MDt5PHEuc2l6ZV8xKCkmJih4PSh1LW5uKS8oU3Itbm4pLCEoYShxLmdldF8wKHkpLDQwKS5wb3MueV8wPl8uc291cmNlLnBvcy55XzAqKDEteCkrXy50YXJnZXQucG9zLnlfMCp4KSk7eSsrKTtpZihxLnNpemVfMSgpPjAmJihqbj1fLmJlbmRQb2ludHMuc2l6ZV8wPT0wP0N0KF8uc291cmNlLnBvcyk6YShSbChfLmJlbmRQb2ludHMpLDgpLGs9S24oQ3QoYShxLmdldF8wKHEuc2l6ZV8xKCktMSksNDApLnBvcyksYShxLmdldF8wKHEuc2l6ZV8xKCktMSksNDApLnNpemVfMCksaD1LbihDdChhKHEuZ2V0XzAoMCksNDApLnBvcyksYShxLmdldF8wKDApLDQwKS5zaXplXzApLHk+PXEuc2l6ZV8xKCktMSYmam4ueV8wPmsueV8wJiZfLnRhcmdldC5wb3MueV8wPmsueV8wfHx5PD0wJiZqbi55XzA8aC54XzAmJl8udGFyZ2V0LnBvcy55XzA8aC55XzApKWNvbnRpbnVlfWVsc2V7Zm9yKHEuc29ydF8wKG5ldyBnOWUpLHk9MDt5PHEuc2l6ZV8xKCkmJih4PSh1LW5uKS8oU3Itbm4pLCEoYShxLmdldF8wKHkpLDQwKS5wb3MueF8wPl8uc291cmNlLnBvcy54XzAqKDEteCkrXy50YXJnZXQucG9zLnhfMCp4KSk7eSsrKTtpZihxLnNpemVfMSgpPjAmJihqbj1fLmJlbmRQb2ludHMuc2l6ZV8wPT0wP0N0KF8uc291cmNlLnBvcyk6YShSbChfLmJlbmRQb2ludHMpLDgpLGs9S24oQ3QoYShxLmdldF8wKHEuc2l6ZV8xKCktMSksNDApLnBvcyksYShxLmdldF8wKHEuc2l6ZV8xKCktMSksNDApLnNpemVfMCksaD1LbihDdChhKHEuZ2V0XzAoMCksNDApLnBvcyksYShxLmdldF8wKDApLDQwKS5zaXplXzApLHk+PXEuc2l6ZV8xKCktMSYmam4ueF8wPmsueF8wJiZfLnRhcmdldC5wb3MueF8wPmsueF8wfHx5PD0wJiZqbi54XzA8aC54XzAmJl8udGFyZ2V0LnBvcy54XzA8aC54XzApKWNvbnRpbnVlfW89bmV3IG10LGk9bmV3IG10LExuKF8uYmVuZFBvaW50cyxvKSxMbihfLmJlbmRQb2ludHMsaSkscz1uZXcgTlIobyxpLF8pLEE9bHMoT2wodSwzMiksZXQoeSxVdCkpLHlpKG5lLGVjKEEpKT8obT1hKEtlKG5lLGVjKEEpKSw2NzUpLExuKG0uYmVuZFBvaW50cyxzKSxkYyhtLmQpP3dfKG0uYmVuZFBvaW50cyxuZXcgdjllKTp3XyhtLmJlbmRQb2ludHMsbmV3IFM5ZSksdzllKG0pKToobT1uZXcgRTllKHk9PTA/bnVsbDphKHEuZ2V0XzAoeS0xKSw0MCkseT09cS5zaXplXzEoKT9udWxsOmEocS5nZXRfMCh5KSw0MCkscyxlKSxCbihuZSxlYyhBKSxtKSksbj09YW98fG49PW1vPyhtLm9uRmlyc3ROb2RlU2lkZSYmbS5uZWlnaGJvclR3by5wb3MueV8wPD1SKCQodyhlLChscigpLCQ3KSkpKSYmKyt3ZSxtLm9uTGFzdE5vZGVTaWRlJiZtLm5laWdoYm9yT25lLnBvcy55XzArbS5uZWlnaGJvck9uZS5zaXplXzAueV8wPj1SKCQodyhlLChscigpLEVYKSkpKSYmKytEZSk6KG0ub25GaXJzdE5vZGVTaWRlJiZtLm5laWdoYm9yVHdvLnBvcy54XzA8PVIoJCh3KGUsKGxyKCksejcpKSkpJiYrK3dlLG0ub25MYXN0Tm9kZVNpZGUmJm0ubmVpZ2hib3JPbmUucG9zLnhfMCttLm5laWdoYm9yT25lLnNpemVfMC54XzA+PVIoJCh3KGUsKGxyKCksd1gpKSkpJiYrK0RlKX1lbHNlIE09PTA/VVgoXyk6TTwwJiYoKyt2ZVtubl0sKyt2W1NyXSxGZT1DbW4oXyxuLGUsbmV3IFpyKEood2UpLEooRGUpKSxyLHQsbmV3IFpyKEoodltTcl0pLEoodmVbbm5dKSkpLHdlPWEoRmUuZmlyc3QsMTcpLnZhbHVlXzAsRGU9YShGZS5zZWNvbmQsMTcpLnZhbHVlXzApfWZ1bmN0aW9uIHhtbihlKXt2YXIgbixyO2ZvcihyPWRuKGUuZWRnZXMsMCk7ci5jdXJyZW50Tm9kZSE9ci50aGlzJDAxLnRhaWw7KW49YSh1bihyKSw2NSksVVgobil9ZnVuY3Rpb24gVVgoZSl7dmFyIG4scix0LG8saTtuPWUuYmVuZFBvaW50cyxyPWUuc291cmNlLG89ZS50YXJnZXQsdD1uZXcgWShyLnBvcy54XzArci5zaXplXzAueF8wLzIsci5wb3MueV8wK3Iuc2l6ZV8wLnlfMC8yKSxpPW5ldyBZKG8ucG9zLnhfMCtvLnNpemVfMC54XzAvMixvLnBvcy55XzArby5zaXplXzAueV8wLzIpLGJyKG4sdCxuLmhlYWRlcixuLmhlYWRlci5uZXh0XzApLGJyKG4saSxuLnRhaWwucHJldixuLnRhaWwpLG5rZSh0LGEoVmEobiwxKSw4KSxlLnNvdXJjZS5zaXplXzApLG5rZShpLGEoVmEobixuLnNpemVfMC0yKSw4KSxlLnRhcmdldC5zaXplXzApfWZ1bmN0aW9uIFBtbihlLG4pe3ZhciByLHQsbyxpLHMsdTtpZihuLmJlZ2luKCJFZGdlIHJvdXRpbmciLDEpLG89YSh3KGUsKEZvKCksSDcpKSwzOTIpLG89PShodigpLE03KSl4bW4oZSk7ZWxzZSBpZihvPT1KMylmb3IoYSh2YSh4eShKbihuZXcgU2UobnVsbCxuZXcgeGUoZS5ub2RlcywxNikpLG5ldyBva2UpKSksNDApLGk9UigkKHcoZSxNWCkpKSxzPVIoJCh3KGUsTlgpKSksdT1hKHcoZSxfZCksODgpLGJtbihlLHUsaSksSW1uKGUsdSxpLHMpLFRtbihlLHUsaSxzKSx0PWRuKGUuZWRnZXMsMCk7dC5jdXJyZW50Tm9kZSE9dC50aGlzJDAxLnRhaWw7KXI9YSh1bih0KSw2NSksci5iZW5kUG9pbnRzLnNpemVfMDwyJiZVWChyKTtuLmRvbmVfMSgpfWZ1bmN0aW9uIFg4ZSgpe19jKCl9ZnVuY3Rpb24gTm1uKGUpe3JldHVybiBfYygpLGUucG9zLnhfMCtlLnNpemVfMC54XzAvMn1mdW5jdGlvbiBBbW4oZSxuLHIpe3JldHVybiBfYygpLHIucG9zLnhfMCtyLnNpemVfMC54XzArZSpufWZ1bmN0aW9uIExtbihlLG4scil7cmV0dXJuIF9jKCksci5wb3MueF8wLWUqbn1mdW5jdGlvbiBrbW4oZSxuKXtyZXR1cm4gX2MoKSxpcigoZS5iZW5kUG9pbnRzLnNpemVfMD09MD9uZXcgWShlLnRhcmdldC5wb3MueF8wLGUudGFyZ2V0LnBvcy55XzApOmEoeXkoZS5iZW5kUG9pbnRzKSw4KSkueV8wLChuLmJlbmRQb2ludHMuc2l6ZV8wPT0wP25ldyBZKG4udGFyZ2V0LnBvcy54XzAsbi50YXJnZXQucG9zLnlfMCk6YSh5eShuLmJlbmRQb2ludHMpLDgpKS55XzApfWZ1bmN0aW9uIE9tbihlLG4pe3JldHVybiBfYygpLGlyKChlLmJlbmRQb2ludHMuc2l6ZV8wPT0wP25ldyBZKGUudGFyZ2V0LnBvcy54XzAsZS50YXJnZXQucG9zLnlfMCk6YSh5eShlLmJlbmRQb2ludHMpLDgpKS54XzAsKG4uYmVuZFBvaW50cy5zaXplXzA9PTA/bmV3IFkobi50YXJnZXQucG9zLnhfMCxuLnRhcmdldC5wb3MueV8wKTphKHl5KG4uYmVuZFBvaW50cyksOCkpLnhfMCl9ZnVuY3Rpb24gTW1uKGUsbil7cmV0dXJuIF9jKCksaXIoKGUuYmVuZFBvaW50cy5zaXplXzA9PTA/bmV3IFkoZS5zb3VyY2UucG9zLnhfMCxlLnNvdXJjZS5wb3MueV8wKTphKFJsKGUuYmVuZFBvaW50cyksOCkpLnlfMCwobi5iZW5kUG9pbnRzLnNpemVfMD09MD9uZXcgWShuLnNvdXJjZS5wb3MueF8wLG4uc291cmNlLnBvcy55XzApOmEoUmwobi5iZW5kUG9pbnRzKSw4KSkueV8wKX1mdW5jdGlvbiBSbW4oZSxuKXtyZXR1cm4gX2MoKSxhKHcobiwoRm8oKSxndSkpLDE3KS52YWx1ZV8wPT1lfWZ1bmN0aW9uIERtbihlLG4pe3JldHVybiBfYygpLGlyKChlLmJlbmRQb2ludHMuc2l6ZV8wPT0wP25ldyBZKGUuc291cmNlLnBvcy54XzAsZS5zb3VyY2UucG9zLnlfMCk6YShSbChlLmJlbmRQb2ludHMpLDgpKS54XzAsKG4uYmVuZFBvaW50cy5zaXplXzA9PTA/bmV3IFkobi5zb3VyY2UucG9zLnhfMCxuLnNvdXJjZS5wb3MueV8wKTphKFJsKG4uYmVuZFBvaW50cyksOCkpLnhfMCl9ZnVuY3Rpb24gRm1uKGUsbil7cmV0dXJuIF9jKCksaXIoZS5wb3MueV8wLG4ucG9zLnlfMCl9ZnVuY3Rpb24gem1uKGUsbil7cmV0dXJuIF9jKCksaXIoZS5wb3MueF8wLG4ucG9zLnhfMCl9ZnVuY3Rpb24gJG1uKGUpe3JldHVybiBfYygpLGUucG9zLnlfMCtlLnNpemVfMC55XzAvMn1mdW5jdGlvbiBCbW4oZSxuLHIpe3JldHVybiBfYygpLHIucG9zLnlfMCtyLnNpemVfMC55XzArZSpufWZ1bmN0aW9uIEdtbihlLG4scil7cmV0dXJuIF9jKCksci5wb3MueV8wLWUqbn1wKDE0OTYsMSxXdCxYOGUpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDEyMSksSjhlfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtQbW4oYShuLDEyMSkscil9O3ZhciBKOGUsSG1uPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyIiwxNDk2KTtmdW5jdGlvbiBaOGUoKXt9cCgxNDk4LDEsTm4sWjhlKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBxbyhhKG4sMTcpLnZhbHVlXzAsYShyLDE3KS52YWx1ZV8wKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci8wbWV0aG9kcmVmJGNvbXBhcmUkVHlwZSIsMTQ5OCk7ZnVuY3Rpb24gUThlKCl7fXAoMTUwMywxLHt9LFE4ZSksbC5hcHBseUFzRG91YmxlPWZ1bmN0aW9uKG4pe3JldHVybiBSKCQobikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci8xbWV0aG9kcmVmJGRvdWJsZVZhbHVlJFR5cGUiLDE1MDMpO2Z1bmN0aW9uIGU5ZSgpe31wKDE1MDUsMSxObixlOWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIGlyKFIoJChuKSksUigkKHIpKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIkVkZ2VSb3V0ZXIvMm1ldGhvZHJlZiRjb21wYXJlJFR5cGUiLDE1MDUpO2Z1bmN0aW9uIG45ZSgpe31wKDE1MDcsMSxObixuOWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIGlyKFIoJChuKSksUigkKHIpKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIkVkZ2VSb3V0ZXIvM21ldGhvZHJlZiRjb21wYXJlJFR5cGUiLDE1MDcpO2Z1bmN0aW9uIHI5ZSgpe31wKDE1MDksMSx7fSxyOWUpLGwuYXBwbHlBc0RvdWJsZT1mdW5jdGlvbihuKXtyZXR1cm4gUigkKG4pKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIkVkZ2VSb3V0ZXIvNG1ldGhvZHJlZiRkb3VibGVWYWx1ZSRUeXBlIiwxNTA5KTtmdW5jdGlvbiB0OWUoKXt9cCgxNTExLDEsTm4sdDllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBpcihSKCQobikpLFIoJChyKSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyLzVtZXRob2RyZWYkY29tcGFyZSRUeXBlIiwxNTExKTtmdW5jdGlvbiBvOWUoKXt9cCgxNTEzLDEsTm4sbzllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBpcihSKCQobikpLFIoJChyKSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyLzZtZXRob2RyZWYkY29tcGFyZSRUeXBlIiwxNTEzKTtmdW5jdGlvbiBpOWUoKXt9cCgxNDk3LDEse30saTllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIF9jKCksYSh3KGEobiw0MCksKEZvKCksZ3UpKSwxNyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyL2xhbWJkYSQwJFR5cGUiLDE0OTcpO2Z1bmN0aW9uIGE5ZSgpe31wKDE1MDgsMSx7fSxhOWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gTm1uKGEobiw0MCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkMTEkVHlwZSIsMTUwOCk7ZnVuY3Rpb24gbDllKGUsbil7dGhpcy5ub2RlQmVuZHBvaW50UGFkZGluZ18wPWUsdGhpcy5maW5hbFNpZGVUd29FZGdlc18yPW59cCgxNTEwLDEse30sbDllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEFtbih0aGlzLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzAsdGhpcy5maW5hbFNpZGVUd29FZGdlc18yLGEobiw0MCkpfSxsLmZpbmFsU2lkZVR3b0VkZ2VzXzI9MCxsLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkMTMkVHlwZSIsMTUxMCk7ZnVuY3Rpb24gczllKGUsbil7dGhpcy5ub2RlQmVuZHBvaW50UGFkZGluZ18wPWUsdGhpcy5maW5hbFNpZGVPbmVFZGdlc18yPW59cCgxNTEyLDEse30sczllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIExtbih0aGlzLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzAsdGhpcy5maW5hbFNpZGVPbmVFZGdlc18yLGEobiw0MCkpfSxsLmZpbmFsU2lkZU9uZUVkZ2VzXzI9MCxsLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkMTUkVHlwZSIsMTUxMik7ZnVuY3Rpb24gdTllKCl7fXAoMTUxNCwxLE5uLHU5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4ga21uKGEobiw2NSksYShyLDY1KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIkVkZ2VSb3V0ZXIvbGFtYmRhJDE3JFR5cGUiLDE1MTQpO2Z1bmN0aW9uIGM5ZSgpe31wKDE1MTUsMSxObixjOWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIE9tbihhKG4sNjUpLGEociw2NSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyL2xhbWJkYSQxOCRUeXBlIiwxNTE1KTtmdW5jdGlvbiBfOWUoKXt9cCgxNTE2LDEsTm4sXzllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBNbW4oYShuLDY1KSxhKHIsNjUpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkMTkkVHlwZSIsMTUxNik7ZnVuY3Rpb24gZDllKGUpe3RoaXMuZmluYWxDdXJsZXZlbF8wPWV9cCgxNDk5LDEsSW4sZDllKSxsLnRlc3RfMD1mdW5jdGlvbihuKXtyZXR1cm4gUm1uKHRoaXMuZmluYWxDdXJsZXZlbF8wLGEobiw0MCkpfSxsLmZpbmFsQ3VybGV2ZWxfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyL2xhbWJkYSQyJFR5cGUiLDE0OTkpO2Z1bmN0aW9uIGY5ZSgpe31wKDE1MTcsMSxObixmOWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIERtbihhKG4sNjUpLGEociw2NSkpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyL2xhbWJkYSQyMCRUeXBlIiwxNTE3KTtmdW5jdGlvbiBwOWUoKXt9cCgxNTAwLDEsTm4scDllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiBGbW4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkMyRUeXBlIiwxNTAwKTtmdW5jdGlvbiBnOWUoKXt9cCgxNTAxLDEsTm4sZzllKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiB6bW4oYShuLDQwKSxhKHIsNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkNCRUeXBlIiwxNTAxKTtmdW5jdGlvbiBoOWUoKXt9cCgxNTAyLDEse30saDllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuICRtbihhKG4sNDApKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIkVkZ2VSb3V0ZXIvbGFtYmRhJDUkVHlwZSIsMTUwMik7ZnVuY3Rpb24gbTllKGUsbil7dGhpcy5ub2RlQmVuZHBvaW50UGFkZGluZ18wPWUsdGhpcy5maW5hbFNpZGVUd29FZGdlc18yPW59cCgxNTA0LDEse30sbTllKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIEJtbih0aGlzLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzAsdGhpcy5maW5hbFNpZGVUd29FZGdlc18yLGEobiw0MCkpfSxsLmZpbmFsU2lkZVR3b0VkZ2VzXzI9MCxsLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiRWRnZVJvdXRlci9sYW1iZGEkNyRUeXBlIiwxNTA0KTtmdW5jdGlvbiB5OWUoZSxuKXt0aGlzLm5vZGVCZW5kcG9pbnRQYWRkaW5nXzA9ZSx0aGlzLmZpbmFsU2lkZU9uZUVkZ2VzXzI9bn1wKDE1MDYsMSx7fSx5OWUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gR21uKHRoaXMubm9kZUJlbmRwb2ludFBhZGRpbmdfMCx0aGlzLmZpbmFsU2lkZU9uZUVkZ2VzXzIsYShuLDQwKSl9LGwuZmluYWxTaWRlT25lRWRnZXNfMj0wLGwubm9kZUJlbmRwb2ludFBhZGRpbmdfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJFZGdlUm91dGVyL2xhbWJkYSQ5JFR5cGUiLDE1MDYpO2Z1bmN0aW9uIHc5ZShlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihpPTAsbz1lLmJlbmRQb2ludHMuc2l6ZV8wLGM9ZG4oZS5iZW5kUG9pbnRzLDApO2MuY3VycmVudE5vZGUhPWMudGhpcyQwMS50YWlsOyl7aWYodT1hKHVuKGMpLDI0MCkscz0oaSsxKS8obysxKSwhZS5uZWlnaGJvck9uZSYmIWUubmVpZ2hib3JUd28pcmV0dXJuO2UubmVpZ2hib3JPbmUmJiFlLm5laWdoYm9yVHdvPyhlLm9uTGFzdE5vZGVTaWRlPSEwLGUuZD09KFdyKCksYW8pPyh0PWUubmVpZ2hib3JPbmUucG9zLnlfMCtlLm5laWdoYm9yT25lLnNpemVfMC55XzArZS5ub2RlQmVuZHBvaW50UGFkZGluZyooaSsxKSxuPW5ldyBZKFIoJCh3KGUubmVpZ2hib3JPbmUsKGxyKCksWWwpKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkscj1uZXcgWShSKCQodyhlLm5laWdoYm9yT25lLHBzKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkpOmUuZD09bW8/KHQ9ZS5uZWlnaGJvck9uZS5wb3MueV8wK2UubmVpZ2hib3JPbmUuc2l6ZV8wLnlfMCtlLm5vZGVCZW5kcG9pbnRQYWRkaW5nKihpKzEpLG49bmV3IFkoUigkKHcoZS5uZWlnaGJvck9uZSwobHIoKSxwcykpKSktZS5ub2RlQmVuZHBvaW50UGFkZGluZyx0KSxyPW5ldyBZKFIoJCh3KGUubmVpZ2hib3JPbmUsWWwpKSkrZS5ub2RlQmVuZHBvaW50UGFkZGluZyx0KSk6ZS5kPT1vbD8odD1lLm5laWdoYm9yT25lLnBvcy54XzArZS5uZWlnaGJvck9uZS5zaXplXzAueF8wK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcqKGkrMSksbj1uZXcgWSh0LFIoJCh3KGUubmVpZ2hib3JPbmUsKGxyKCksWWwpKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcpLHI9bmV3IFkodCxSKCQodyhlLm5laWdoYm9yT25lLHBzKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcpKToodD1lLm5laWdoYm9yT25lLnBvcy54XzArZS5uZWlnaGJvck9uZS5zaXplXzAueF8wK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcqKGkrMSksbj1uZXcgWSh0LFIoJCh3KGUubmVpZ2hib3JPbmUsKGxyKCkscHMpKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcpLHI9bmV3IFkodCxSKCQodyhlLm5laWdoYm9yT25lLFlsKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcpKSk6ZS5uZWlnaGJvck9uZSYmZS5uZWlnaGJvclR3bz9lLmQ9PShXcigpLGFvKT8odD1lLm5laWdoYm9yVHdvLnBvcy55XzAqcysoZS5uZWlnaGJvck9uZS5wb3MueV8wK2UubmVpZ2hib3JPbmUuc2l6ZV8wLnlfMCkqKDEtcyksbj1uZXcgWShSKCQodyhlLm5laWdoYm9yT25lLChscigpLFlsKSkpKStlLm5vZGVCZW5kcG9pbnRQYWRkaW5nLHQpLHI9bmV3IFkoUigkKHcoZS5uZWlnaGJvck9uZSxwcykpKS1lLm5vZGVCZW5kcG9pbnRQYWRkaW5nLHQpKTplLmQ9PW1vPyh0PWUubmVpZ2hib3JUd28ucG9zLnlfMCpzKyhlLm5laWdoYm9yT25lLnBvcy55XzArZS5uZWlnaGJvck9uZS5zaXplXzAueV8wKSooMS1zKSxuPW5ldyBZKFIoJCh3KGUubmVpZ2hib3JPbmUsKGxyKCkscHMpKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkscj1uZXcgWShSKCQodyhlLm5laWdoYm9yT25lLFlsKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkpOmUuZD09b2w/KHQ9ZS5uZWlnaGJvclR3by5wb3MueF8wKnMrKGUubmVpZ2hib3JPbmUucG9zLnhfMCtlLm5laWdoYm9yT25lLnNpemVfMC54XzApKigxLXMpLG49bmV3IFkodCxSKCQodyhlLm5laWdoYm9yT25lLChscigpLFlsKSkpKStlLm5vZGVCZW5kcG9pbnRQYWRkaW5nKSxyPW5ldyBZKHQsUigkKHcoZS5uZWlnaGJvck9uZSxwcykpKS1lLm5vZGVCZW5kcG9pbnRQYWRkaW5nKSk6KHQ9ZS5uZWlnaGJvclR3by5wb3MueF8wKnMrKGUubmVpZ2hib3JPbmUucG9zLnhfMCtlLm5laWdoYm9yT25lLnNpemVfMC54XzApKigxLXMpLG49bmV3IFkodCxSKCQodyhlLm5laWdoYm9yT25lLChscigpLHBzKSkpKS1lLm5vZGVCZW5kcG9pbnRQYWRkaW5nKSxyPW5ldyBZKHQsUigkKHcoZS5uZWlnaGJvck9uZSxZbCkpKStlLm5vZGVCZW5kcG9pbnRQYWRkaW5nKSk6KGUub25GaXJzdE5vZGVTaWRlPSEwLGUuZD09KFdyKCksYW8pPyh0PWUubmVpZ2hib3JUd28ucG9zLnlfMC1lLm5vZGVCZW5kcG9pbnRQYWRkaW5nKihpKzEpLG49bmV3IFkoUigkKHcoZS5uZWlnaGJvclR3bywobHIoKSxZbCkpKSkrZS5ub2RlQmVuZHBvaW50UGFkZGluZyx0KSxyPW5ldyBZKFIoJCh3KGUubmVpZ2hib3JUd28scHMpKSktZS5ub2RlQmVuZHBvaW50UGFkZGluZyx0KSk6ZS5kPT1tbz8odD1lLm5laWdoYm9yVHdvLnBvcy55XzAtZS5ub2RlQmVuZHBvaW50UGFkZGluZyooaSsxKSxuPW5ldyBZKFIoJCh3KGUubmVpZ2hib3JUd28sKGxyKCkscHMpKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkscj1uZXcgWShSKCQodyhlLm5laWdoYm9yVHdvLFlsKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcsdCkpOmUuZD09b2w/KHQ9ZS5uZWlnaGJvclR3by5wb3MueF8wLWUubm9kZUJlbmRwb2ludFBhZGRpbmcqKGkrMSksbj1uZXcgWSh0LFIoJCh3KGUubmVpZ2hib3JUd28sKGxyKCksWWwpKSkpK2Uubm9kZUJlbmRwb2ludFBhZGRpbmcpLHI9bmV3IFkodCxSKCQodyhlLm5laWdoYm9yVHdvLHBzKSkpLWUubm9kZUJlbmRwb2ludFBhZGRpbmcpKToodD1lLm5laWdoYm9yVHdvLnBvcy54XzAtZS5ub2RlQmVuZHBvaW50UGFkZGluZyooaSsxKSxuPW5ldyBZKHQsUigkKHcoZS5uZWlnaGJvclR3bywobHIoKSxwcykpKSktZS5ub2RlQmVuZHBvaW50UGFkZGluZykscj1uZXcgWSh0LFIoJCh3KGUubmVpZ2hib3JUd28sWWwpKSkrZS5ub2RlQmVuZHBvaW50UGFkZGluZykpKSxhKHUuZmlyc3QsOCkueF8wPW4ueF8wLGEodS5maXJzdCw4KS55XzA9bi55XzAsdS5zZWNvbmQueF8wPXIueF8wLHUuc2Vjb25kLnlfMD1yLnlfMCwrK2l9fWZ1bmN0aW9uIEU5ZShlLG4scix0KXt2YXIgbzt0aGlzLm5laWdoYm9yT25lPWUsdGhpcy5uZWlnaGJvclR3bz1uLG89bmV3IHByLGJyKG8scixvLnRhaWwucHJldixvLnRhaWwpLHRoaXMuYmVuZFBvaW50cz1vLHRoaXMuZD1hKHcodCwoRm8oKSxfZCkpLDg4KSx0aGlzLm5vZGVCZW5kcG9pbnRQYWRkaW5nPVIoJCh3KHQsTVgpKSksdzllKHRoaXMpfWZ1bmN0aW9uIFVtbihlLG4pe3JldHVybiBpcihhKGUudGhpcmQsNjUpLnRhcmdldC5wb3MueV8wLGEobi50aGlyZCw2NSkudGFyZ2V0LnBvcy55XzApfWZ1bmN0aW9uIFdtbihlLG4pe3JldHVybiBpcihhKGUudGhpcmQsNjUpLnRhcmdldC5wb3MueF8wLGEobi50aGlyZCw2NSkudGFyZ2V0LnBvcy54XzApfXAoNjc1LDEsezY3NToxfSxFOWUpLGwubm9kZUJlbmRwb2ludFBhZGRpbmc9MCxsLm9uRmlyc3ROb2RlU2lkZT0hMSxsLm9uTGFzdE5vZGVTaWRlPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcubXJ0cmVlLnA0cm91dGUiLCJNdWx0aUxldmVsRWRnZU5vZGVOb2RlR2FwIiw2NzUpO2Z1bmN0aW9uIHY5ZSgpe31wKDE5NDMsMSxObix2OWUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIFVtbihhKG4sMjQwKSxhKHIsMjQwKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5tcnRyZWUucDRyb3V0ZSIsIk11bHRpTGV2ZWxFZGdlTm9kZU5vZGVHYXAvbGFtYmRhJDAkVHlwZSIsMTk0Myk7ZnVuY3Rpb24gUzllKCl7fXAoMTk0NCwxLE5uLFM5ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gV21uKGEobiwyNDApLGEociwyNDApKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLm1ydHJlZS5wNHJvdXRlIiwiTXVsdGlMZXZlbEVkZ2VOb2RlTm9kZUdhcC9sYW1iZGEkMSRUeXBlIiwxOTQ0KTtmdW5jdGlvbiBwZygpe3BnPUYsZ2c9bmV3IHRyKCJyb290Iil9dmFyIGdnO2Z1bmN0aW9uIHVOKCl7dU49RixjTj1uZXcgV1goIlAxX05PREVfUExBQ0VNRU5UIiwwKSxoZz1uZXcgV1goIlAyX0VER0VfUk9VVElORyIsMSl9ZnVuY3Rpb24gQzllKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMDpyZXR1cm4gbmV3IEFPZTtjYXNlIDE6cmV0dXJuIG5ldyBST2U7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgbGF5b3V0IHByb2Nlc3NvciAiKyhlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWwpKSl9fWZ1bmN0aW9uIFdYKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gam1uKGUpe3JldHVybiB1TigpLHduKChUOWUoKSxiOWUpLGUpfWZ1bmN0aW9uIFZtbigpe3JldHVybiB1TigpLFAoSShqWCwxKSxXLDUwMSwwLFtjTixoZ10pfXAoNTAxLDIyLHszOjEsMzQ6MSwyMjoxLDUwMToxLDE4ODoxLDE5NjoxfSxXWCksbC5jcmVhdGVfMT1mdW5jdGlvbigpe3JldHVybiBDOWUodGhpcyl9LGwuY3JlYXRlXzI9ZnVuY3Rpb24oKXtyZXR1cm4gQzllKHRoaXMpfTt2YXIgY04saGcsalg9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsIiwiUmFkaWFsTGF5b3V0UGhhc2VzIiw1MDEsZ24sVm1uLGptbik7ZnVuY3Rpb24gVDllKCl7VDllPUYsYjllPXluKCh1TigpLFAoSShqWCwxKSxXLDUwMSwwLFtjTixoZ10pKSl9dmFyIGI5ZTtmdW5jdGlvbiBJOWUoZSxuKXt2YXIgcix0O3JldHVybiB2VChlLmFsZ29yaXRobUFzc2VtYmxlciksZ3MoZS5hbGdvcml0aG1Bc3NlbWJsZXIsKHVOKCksY04pLGNOKSxncyhlLmFsZ29yaXRobUFzc2VtYmxlcixoZyxoZyksdD1uZXcgSHIsTW4odCxoZywoZE4oKSxaNykpLEQoVihuLChIMCgpLHRNKSkpIT09RCgoclQoKSxoTikpJiZNbih0LGhnLEs3KSxhZShpZShWKG4sc0opKSkmJk1uKHQsaGcsUTcpLE1uKHQsaGcsWDcpLGFlKGllKFYobixjSikpKSYmV2kodCxoZyxKNyksR1ooZS5hbGdvcml0aG1Bc3NlbWJsZXIsdCkscj1FVChlLmFsZ29yaXRobUFzc2VtYmxlcixuKSxyfWZ1bmN0aW9uIHg5ZSgpe3RoaXMuYWxnb3JpdGhtQXNzZW1ibGVyPW5ldyBBdihqWCl9cCgxMTEzLDIwNSxnXyx4OWUpLGwubGF5b3V0PWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHMsdSxjO2lmKHQ9STllKHRoaXMsbiksci5iZWdpbigiUmFkaWFsIGxheW91dCIsdC5hcnJheS5sZW5ndGgpLGFlKGllKFYobiwoSDAoKSxhSikpKSl8fFVDKChvPW5ldyBhRSgoRWQoKSxuZXcgdmQobikpKSxvKSksYz1xbW4obiksbnIobiwocGcoKSxnZyksYyksIWMpdGhyb3cgYihuZXcgR2UoIlRoZSBnaXZlbiBncmFwaCBpcyBub3QgYSB0cmVlISIpKTtmb3IoaT1SKCQoVihuLHlOKSkpLGk9PTAmJihpPVA5ZShuKSksbnIobix5TixpKSx1PW5ldyBUKEk5ZSh0aGlzLG4pKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksNDcpLHMucHJvY2VzcyhuLHIuc3ViVGFzaygxKSk7ci5kb25lXzEoKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwiLCJSYWRpYWxMYXlvdXRQcm92aWRlciIsMTExMyk7ZnVuY3Rpb24gUDllKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihzPTAscj1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDI3KSx1PW4ud2lkdGhfMCxvPW4uaGVpZ2h0LHQ9Uy5NYXRoLnNxcnQodSp1K28qbykscz1TLk1hdGgubWF4KHQscyksaT1QOWUobikscz1TLk1hdGgubWF4KGkscyk7cmV0dXJuIHN9ZnVuY3Rpb24gcW1uKGUpe3ZhciBuLHIsdDtmb3Iocj1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspaWYobj1hKGVuKHIpLDI3KSx0PW9iKG4pLCFfbihuZXcgWGUoUWUodC52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSkpKXJldHVybiBuO3JldHVybiBudWxsfWZ1bmN0aW9uIE45ZShlKXt2YXIgbjtyZXR1cm4gbj1MOWUoZSksbj9OOWUobik6ZX1mdW5jdGlvbiBZbW4oZSl7dmFyIG4scix0LG87Zm9yKG89bmV3IEJyLHQ9bmV3IFQoZSk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDI3KSxuPUttbihyKSxmdChvLG4pO3JldHVybiBvfWZ1bmN0aW9uIFk3KGUpe3ZhciBuLHIsdCxvO2ZvcihvPW5ldyBRLHQ9ZS5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspcj1hKHQubmV4dF8xKCksMjcpLG49R2YocikscXIobyxuKTtyZXR1cm4gb31mdW5jdGlvbiBBOWUoZSl7dmFyIG4scix0LG87aWYodD0wLG89R2YoZSksby5hcnJheS5sZW5ndGg9PTApcmV0dXJuIDE7Zm9yKHI9bmV3IFQobyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDI3KSx0Kz1BOWUobik7cmV0dXJuIHR9ZnVuY3Rpb24gS21uKGUpe3ZhciBuLHIsdCxvLGkscztmb3IoaT1uZXcgQnIsbj1uZXcgbkUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpLG89bmV3IFhlKFFlKEVjKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihvKTspdD1hKHRuKG8pLDc0KSxMKE8oKCF0LnNvdXJjZXMmJih0LnNvdXJjZXM9bmV3IExlKGFuLHQsNCw3KSksdC5zb3VyY2VzKSwwKSwxOTMpfHwocz15byhhKE8oKCF0LnRhcmdldHMmJih0LnRhcmdldHM9bmV3IExlKGFuLHQsNSw4KSksdC50YXJnZXRzKSwwKSw4NCkpLG4ubWFwXzAuY29udGFpbnNLZXkocyl8fChyPWkubWFwXzAucHV0KHMsaSkscj09bnVsbCkpO3JldHVybiBpfWZ1bmN0aW9uIEdmKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKG89bmV3IFEsbj1uZXcgbkUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpLHQ9bmV3IFhlKFFlKEVjKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbih0KTspcj1hKHRuKHQpLDc0KSxMKE8oKCFyLnNvdXJjZXMmJihyLnNvdXJjZXM9bmV3IExlKGFuLHIsNCw3KSksci5zb3VyY2VzKSwwKSwxOTMpfHwoaT15byhhKE8oKCFyLnRhcmdldHMmJihyLnRhcmdldHM9bmV3IExlKGFuLHIsNSw4KSksci50YXJnZXRzKSwwKSw4NCkpLG4ubWFwXzAuY29udGFpbnNLZXkoaSl8fFJlKG8uYXJyYXksaSkpO3JldHVybiBvfWZ1bmN0aW9uIEw5ZShlKXt2YXIgbixyO3JldHVybiByPW9iKGUpLEptKHIpP251bGw6KG49KHZuKHIpLGEoR2xlKG5ldyBYZShRZShyLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksNzQpKSx5byhhKE8oKCFuLnNvdXJjZXMmJihuLnNvdXJjZXM9bmV3IExlKGFuLG4sNCw3KSksbi5zb3VyY2VzKSwwKSw4NCkpKX1mdW5jdGlvbiBYbW4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZjtyZXR1cm4gcz1hKFYociwoRm4oKSxsbSkpLDgpLGM9cy54XzAsZD1zLnlfMCtlLG89Uy5NYXRoLmF0YW4yKGQsYyksbzwwJiYobys9aF8pLG8rPW4sbz5oXyYmKG8tPWhfKSx1PWEoVih0LGxtKSw4KSxfPXUueF8wLGY9dS55XzArZSxpPVMuTWF0aC5hdGFuMihmLF8pLGk8MCYmKGkrPWhfKSxpKz1uLGk+aF8mJihpLT1oXyksYnMoKSxrbCgxZS0xMCksUy5NYXRoLmFicyhvLWkpPD0xZS0xMHx8bz09aXx8aXNOYU4obykmJmlzTmFOKGkpPzA6bzxpPy0xOm8+aT8xOkMxKGlzTmFOKG8pLGlzTmFOKGkpKX1mdW5jdGlvbiBfTihlKXt0aGlzLm5vZGVPZmZzZXRZXzA9MCx0aGlzLnJhZGlhbE9mZnNldF8yPWV9cCg1NTYsMSxObixfTiksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gWG1uKHRoaXMubm9kZU9mZnNldFlfMCx0aGlzLnJhZGlhbE9mZnNldF8yLGEobiwyNyksYShyLDI3KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sbC5ub2RlT2Zmc2V0WV8wPTAsbC5yYWRpYWxPZmZzZXRfMj0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsIiwiUmFkaWFsVXRpbC9sYW1iZGEkMCRUeXBlIiw1NTYpO2Z1bmN0aW9uIEptbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZTtmb3Iobi5iZWdpbigiQ2FsY3VsYXRlIEdyYXBoIFNpemUiLDEpLG4ubG9nR3JhcGgoZSwiQmVmb3JlIiksZj1tcCxoPW1wLF89WEYsZD1YRixFPW5ldyBZZSgoIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSk7RS5jdXJzb3IhPUUudGhpcyQwMV8yLnNpemVfMSgpOyltPWEoZW4oRSksMjcpLEE9bS54XzAsaz1tLnlfMCx3ZT1tLndpZHRoXzAsdT1tLmhlaWdodCxjPWEoVihtLChGbigpLGJ3KSksMTQwKSxmPVMuTWF0aC5taW4oZixBLWMubGVmdCksaD1TLk1hdGgubWluKGgsay1jLnRvcF8wKSxfPVMuTWF0aC5tYXgoXyxBK3dlK2MucmlnaHQpLGQ9Uy5NYXRoLm1heChkLGsrdStjLmJvdHRvbSk7Zm9yKHg9YShWKGUsKEZuKCksWmMpKSwxMDcpLHY9bmV3IFkoZi14LmxlZnQsaC14LnRvcF8wKSx2ZT1fLWYrKHgubGVmdCt4LnJpZ2h0KSxzPWQtaCsoeC50b3BfMCt4LmJvdHRvbSksYWUoaWUoVihlLChIMCgpLGlKKSkpKSYmKE09YShWKGUsKHBnKCksZ2cpKSwyNyksSD1hKFYoTSxidyksMTQwKSxxPU0ueF8wK00ud2lkdGhfMC8yKyhILmxlZnQrSC5yaWdodCkvMi12LnhfMCxuZT1NLnlfMCtNLmhlaWdodC8yKyhILnRvcF8wK0guYm90dG9tKS8yLXYueV8wLG89dmUtcSxpPXMtbmUsbzx2ZS8yPyhyPW8tcSx2ZSs9cix2LnhfMC09cik6KHI9cS1vLHZlKz1yKSxpPHMvMj8odD1pLW5lLHMrPXQsdi55XzAtPXQpOih0PW5lLWkscys9dCkpLHk9bmV3IFllKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pKTt5LmN1cnNvciE9eS50aGlzJDAxXzIuc2l6ZV8xKCk7KW09YShlbih5KSwyNyksQ2kobSxtLnhfMC12LnhfMCksVGkobSxtLnlfMC12LnlfMCk7YWUoaWUoVihlLFdmKSkpfHwoVGQoZSx2ZSksQ2QoZSxzKSksbnIoZSxUZyx2ZS0oeC5sZWZ0K3gucmlnaHQpKSxucihlLENnLHMtKHgudG9wXzAreC5ib3R0b20pKSxuLmxvZ0dyYXBoKGUsIkFmdGVyIil9ZnVuY3Rpb24gazllKCl7fXAoMTM5NSwxLHNyLGs5ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7Sm1uKGEobiwyNykscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLmludGVybWVkaWF0ZSIsIkNhbGN1bGF0ZUdyYXBoU2l6ZSIsMTM5NSk7ZnVuY3Rpb24gWm1uKGUpe3ZhciBuLHIsdCxvLGkscyx1O2ZvcihzPWEoVihlLChwZygpLGdnKSksMjcpLHQ9bmV3IFllKCghcy5vdXRnb2luZ0VkZ2VzJiYocy5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixzLDcsNCkpLHMub3V0Z29pbmdFZGdlcykpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDc0KSx1PW5ldyBZKGEoTygoIXIuc2VjdGlvbnMmJihyLnNlY3Rpb25zPW5ldyBVKGdyLHIsNiw2KSksci5zZWN0aW9ucyksMCksMTY2KS5zdGFydFgsYShPKCghci5zZWN0aW9ucyYmKHIuc2VjdGlvbnM9bmV3IFUoZ3Isciw2LDYpKSxyLnNlY3Rpb25zKSwwKSwxNjYpLnN0YXJ0WSksaT1uZXcgWShhKE8oKCFyLnNlY3Rpb25zJiYoci5zZWN0aW9ucz1uZXcgVShncixyLDYsNikpLHIuc2VjdGlvbnMpLDApLDE2NikuZW5kWCxhKE8oKCFyLnNlY3Rpb25zJiYoci5zZWN0aW9ucz1uZXcgVShncixyLDYsNikpLHIuc2VjdGlvbnMpLDApLDE2NikuZW5kWSksbz1uZXcgWShpLnhfMC11LnhfMCxpLnlfMC11LnlfMCksbj1TLk1hdGguYXRhbjIoby55XzAsby54XzApLGEoTygoIXIudGFyZ2V0cyYmKHIudGFyZ2V0cz1uZXcgTGUoYW4sciw1LDgpKSxyLnRhcmdldHMpLDApLDg0KS5zZXRQcm9wZXJ0eSgoSDAoKSxvTSksbil9ZnVuY3Rpb24gTzllKCl7fXAoMTM5NiwxLHNyLE85ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7Wm1uKGEobiwyNykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5pbnRlcm1lZGlhdGUiLCJFZGdlQW5nbGVDYWxjdWxhdG9yIiwxMzk2KTtmdW5jdGlvbiBkTigpe2ROPUYsWjc9bmV3IG5UKCJPVkVSTEFQX1JFTU9WQUwiLDApLEs3PW5ldyBuVCgiQ09NUEFDVElPTiIsMSksUTc9bmV3IG5UKCJST1RBVElPTiIsMiksWDc9bmV3IG5UKCJHUkFQSF9TSVpFX0NBTENVTEFUSU9OIiwzKSxKNz1uZXcgblQoIk9VVEdPSU5HX0VER0VfQU5HTEVTIiw0KX1mdW5jdGlvbiBuVChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFFtbihlKXtyZXR1cm4gZE4oKSx3bigoUjllKCksRDllKSxlKX1mdW5jdGlvbiBleW4oKXtyZXR1cm4gZE4oKSxQKEkoTTllLDEpLFcsMzY4LDAsW1o3LEs3LFE3LFg3LEo3XSl9cCgzNjgsMjIsezM6MSwzNDoxLDIyOjEsMzY4OjEsMTk2OjF9LG5UKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgSjllO2Nhc2UgMTpyZXR1cm4gbmV3IEg5ZTtjYXNlIDI6cmV0dXJuIG5ldyBaOWU7Y2FzZSAzOnJldHVybiBuZXcgazllO2Nhc2UgNDpyZXR1cm4gbmV3IE85ZTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJObyBpbXBsZW1lbnRhdGlvbiBpcyBhdmFpbGFibGUgZm9yIHRoZSBsYXlvdXQgcHJvY2Vzc29yICIrKHRoaXMubmFtZV8wIT1udWxsP3RoaXMubmFtZV8wOiIiK3RoaXMub3JkaW5hbCkpKX19O3ZhciBLNyxYNyxKNyxaNyxRNyxNOWU9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLmludGVybWVkaWF0ZSIsIkludGVybWVkaWF0ZVByb2Nlc3NvclN0cmF0ZWd5IiwzNjgsZ24sZXluLFFtbik7ZnVuY3Rpb24gUjllKCl7UjllPUYsRDllPXluKChkTigpLFAoSShNOWUsMSksVywzNjgsMCxbWjcsSzcsUTcsWDcsSjddKSkpfXZhciBEOWU7ZnVuY3Rpb24gZk4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihpPW4uaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89YShpLm5leHRfMSgpLDI3KSxkPW8ueF8wK28ud2lkdGhfMC8yLGg9by55XzArby5oZWlnaHQvMixjPWUucm9vdF8wLHM9Yy54XzArYy53aWR0aF8wLzIsdT1jLnlfMCtjLmhlaWdodC8yLF89ZC1zLGY9aC11LHQ9Uy5NYXRoLnNxcnQoXypfK2YqZiksXyo9ZS5jb21wYWN0aW9uU3RlcC90LGYqPWUuY29tcGFjdGlvblN0ZXAvdCxyPyhkLT1fLGgtPWYpOihkKz1fLGgrPWYpLENpKG8sZC1vLndpZHRoXzAvMiksVGkobyxoLW8uaGVpZ2h0LzIpfWZ1bmN0aW9uIHBOKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkO3JldHVybiB1PW4ueF8wLWUuc3BhY2luZy8yLGM9ci54XzAtZS5zcGFjaW5nLzIsXz1uLnlfMC1lLnNwYWNpbmcvMixkPXIueV8wLWUuc3BhY2luZy8yLGk9bi53aWR0aF8wK2Uuc3BhY2luZyxzPXIud2lkdGhfMCtlLnNwYWNpbmcsdD1uLmhlaWdodCtlLnNwYWNpbmcsbz1yLmhlaWdodCtlLnNwYWNpbmcsdTxjK3MmJmM8dSYmXzxkK28mJmQ8X3x8Yzx1K2kmJnU8YyYmZDxfK3QmJl88ZHx8dTxjK3MmJmM8dSYmXzxkJiZkPF8rdD8hMDpjPHUraSYmdTxjJiZfPGQrbyYmZDxffWZ1bmN0aW9uIFZYKGUsbil7dmFyIHIsdDtpZih0PSExLG4uc2l6ZV8xKCk8MilyZXR1cm4hMTtmb3Iocj0wO3I8bi5zaXplXzEoKTtyKyspcjxuLnNpemVfMSgpLTE/dD10fHBOKGUsYShuLmdldF8wKHIpLDI3KSxhKG4uZ2V0XzAocisxKSwyNykpOnQ9dHxwTihlLGEobi5nZXRfMChyKSwyNyksYShuLmdldF8wKDApLDI3KSk7cmV0dXJuIHR9ZnVuY3Rpb24gRjllKGUsbil7ZS5jb21wYWN0aW9uU3RlcD1ufWZ1bmN0aW9uIG55bihlLG4pe2Uucm9vdF8wPW59ZnVuY3Rpb24gcVgoZSxuKXtlLnNwYWNpbmc9bn1wKDY1MywxLHt9KSxsLmNvbXBhY3Rpb25TdGVwPTEsbC5zcGFjaW5nPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwuaW50ZXJtZWRpYXRlLmNvbXBhY3Rpb24iLCJBYnN0cmFjdFJhZGl1c0V4dGVuc2lvbkNvbXBhY3Rpb24iLDY1Myk7ZnVuY3Rpb24gcnluKGUsbil7dmFyIHIsdCxvO2Zvcih0PW5ldyBUKG4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihyPWEoQyh0KSwyNyksYmUoZS5sZWZ0Q29udG91cixyLHIpLGJlKGUucmlnaHRDb250b3VyLHIsciksbz1HZihyKSxvLmFycmF5Lmxlbmd0aCE9MClmb3IoZS5zb3J0ZXImJmUuc29ydGVyLnNvcnRfMShvKSxiZShlLmxlZnRDb250b3VyLHIsKEFlKDAsby5hcnJheS5sZW5ndGgpLGEoby5hcnJheVswXSwyNykpKSxiZShlLnJpZ2h0Q29udG91cixyLGEobGUobyxvLmFycmF5Lmxlbmd0aC0xKSwyNykpO1k3KG8pLmFycmF5Lmxlbmd0aCE9MDspbz1ZNyhvKSxlLnNvcnRlciYmZS5zb3J0ZXIuc29ydF8xKG8pLGJlKGUubGVmdENvbnRvdXIsciwoQWUoMCxvLmFycmF5Lmxlbmd0aCksYShvLmFycmF5WzBdLDI3KSkpLGJlKGUucmlnaHRDb250b3VyLHIsYShsZShvLG8uYXJyYXkubGVuZ3RoLTEpLDI3KSl9ZnVuY3Rpb24gejllKGUsbixyLHQpe3ZhciBvLGkscztmb3Iobz1hKFpuKHQ/ZS5sZWZ0Q29udG91cjplLnJpZ2h0Q29udG91cixuKSwyMSkscz1vLml0ZXJhdG9yXzAoKTtzLmhhc05leHRfMCgpOylpZihpPWEocy5uZXh0XzEoKSwyNykscE4oZSxyLGkpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uICQ5ZShlLG4scix0LG8pe3ZhciBpLHMsdTtmb3IoaT1COWUoZSxuLHIsdCxvKSx1PSExOyFpOylmTihlLG8sITApLHU9ITAsaT1COWUoZSxuLHIsdCxvKTt1JiZmTihlLG8sITEpLHM9WTcobykscy5hcnJheS5sZW5ndGghPTAmJihlLnNvcnRlciYmZS5zb3J0ZXIuc29ydF8xKHMpLCQ5ZShlLG8scix0LHMpKX1mdW5jdGlvbiBCOWUoZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQ7aWYoZS5zb3J0ZXImJmUuc29ydGVyLnNvcnRfMShvKSxpPWEoby5nZXRfMCgwKSwyNyksejllKGUscixpLCExKXx8KHM9YShvLmdldF8wKG8uc2l6ZV8xKCktMSksMjcpLHo5ZShlLHQscywhMCkpfHxWWChlLG8pKXJldHVybiEwO2ZvcihkPW8uaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KWZvcihfPWEoZC5uZXh0XzEoKSwyNyksYz1uLml0ZXJhdG9yXzAoKTtjLmhhc05leHRfMCgpOylpZih1PWEoYy5uZXh0XzEoKSwyNykscE4oZSxfLHUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEc5ZSgpe3RoaXMubGVmdENvbnRvdXI9bmV3IEUxLHRoaXMucmlnaHRDb250b3VyPW5ldyBFMX1wKDE4MzQsNjUzLHt9LEc5ZSksbC5jb21wYWN0XzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2Zvcih0aGlzLnJvb3Q9YShWKG4sKHBnKCksZ2cpKSwyNyksbnluKHRoaXMsdGhpcy5yb290KSx0aGlzLnNvcnRlcj1hTShhKFYobiwoSDAoKSx0VCkpLDMwMCkpLF89YShWKG4sck0pLDE3KSxfJiZGOWUodGhpcyxfLnZhbHVlXzApLGM9JChWKG4sKEZuKCksdDEpKSkscVgodGhpcywoVmUoYyksYykpLGQ9R2YodGhpcy5yb290KSx0aGlzLnNvcnRlciYmdGhpcy5zb3J0ZXIuc29ydF8xKGQpLHJ5bih0aGlzLGQpLHU9bmV3IGVhKFAoSShVbiwxKSx2aWUsMjcsMCxbdGhpcy5yb290XSkpLHQ9MDt0PDI7dCsrKWZvcihyPTA7cjxkLmFycmF5Lmxlbmd0aDtyKyspaT1uZXcgZWEoUChJKFVuLDEpLHZpZSwyNywwLFsoQWUocixkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W3JdLDI3KSldKSkscz1yPGQuYXJyYXkubGVuZ3RoLTE/KEFlKHIrMSxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W3IrMV0sMjcpKTooQWUoMCxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5WzBdLDI3KSksbz1yPT0wP2EobGUoZCxkLmFycmF5Lmxlbmd0aC0xKSwyNyk6KEFlKHItMSxkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W3ItMV0sMjcpKSwkOWUodGhpcywoQWUocixkLmFycmF5Lmxlbmd0aCksYShkLmFycmF5W3JdLDI3KSx1KSxvLHMsaSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiQW5udWx1c1dlZGdlQ29tcGFjdGlvbiIsMTgzNCk7ZnVuY3Rpb24gdHluKGUsbil7dmFyIHI7bi5iZWdpbigiR2VuZXJhbCBDb21wYWN0b3IiLDEpLHI9X3luKGEoVihlLChIMCgpLHRNKSksMzkzKSksci5jb21wYWN0XzAoZSl9ZnVuY3Rpb24gSDllKCl7fXAoMTM5MywxLHNyLEg5ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7dHluKGEobiwyNykscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiR2VuZXJhbENvbXBhY3RvciIsMTM5Myk7ZnVuY3Rpb24gVTllKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXztyZXR1cm4gYz1uLnhfMCxfPW4ueV8wLHQ9ZS5yb290XzAsbz10LnhfMCxpPXQueV8wLHM9Yy1vLHU9Xy1pLHI9Uy5NYXRoLnNxcnQocypzK3UqdSkscn1mdW5jdGlvbiBXOWUoZSxuKXt2YXIgcix0LG87aWYobi5hcnJheS5sZW5ndGghPTApe2ZvcihyPWo5ZShlLG4pLG89ITE7IXI7KWZOKGUsbiwhMCksbz0hMCxyPWo5ZShlLG4pO28mJmZOKGUsbiwhMSksdD1ZNyhuKSxlLnNvcnRlciYmZS5zb3J0ZXIuc29ydF8xKHQpLGUubGFzdFJhZGl1cz1VOWUoZSwoQWUoMCxuLmFycmF5Lmxlbmd0aCksYShuLmFycmF5WzBdLDI3KSkpLFc5ZShlLHQpfX1mdW5jdGlvbiBqOWUoZSxuKXt2YXIgcix0LG87aWYoVlgoZSxuKSlyZXR1cm4hMDtmb3IodD1uZXcgVChuKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspaWYocj1hKEModCksMjcpLG89TDllKHIpLHBOKGUscixvKXx8VTllKGUsciktZS5zcGFjaW5nPD1lLmxhc3RSYWRpdXMpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gVjllKCl7fXAoMTgzMyw2NTMse30sVjllKSxsLmNvbXBhY3RfMD1mdW5jdGlvbihuKXt2YXIgcix0LG8saTt0PWEoVihuLChwZygpLGdnKSksMjcpLHRoaXMucm9vdF8wPXQsdGhpcy5zb3J0ZXI9YU0oYShWKG4sKEgwKCksdFQpKSwzMDApKSxpPWEoVihuLHJNKSwxNyksaSYmRjllKHRoaXMsaS52YWx1ZV8wKSxvPSQoVihuLChGbigpLHQxKSkpLHFYKHRoaXMsKFZlKG8pLG8pKSxyPUdmKHQpLHRoaXMuc29ydGVyJiZ0aGlzLnNvcnRlci5zb3J0XzEociksVzllKHRoaXMscil9LGwubGFzdFJhZGl1cz0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLmludGVybWVkaWF0ZS5jb21wYWN0aW9uIiwiUmFkaWFsQ29tcGFjdGlvbiIsMTgzMyk7ZnVuY3Rpb24gb3luKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7cmV0dXJuIGY9ZS5yb290LnhfMCtlLnJvb3Qud2lkdGhfMC8yLGg9ZS5yb290LnhfMCtlLnJvb3Qud2lkdGhfMC8yLHk9bi54XzArbi53aWR0aF8wLzIsdj1uLnlfMCtuLmhlaWdodC8yLHU9bmV3IFkoeSx2KSxfPWEoVihuLChGbigpLGxtKSksOCksXy54XzA9Xy54XzArZixfLnlfMD1fLnlfMCtoLGk9KHUueV8wLV8ueV8wKS8odS54XzAtXy54XzApLHQ9dS55XzAtaSp1LnhfMCxFPXIueF8wK3Iud2lkdGhfMC8yLHg9ci55XzArci5oZWlnaHQvMixjPW5ldyBZKEUseCksZD1hKFYocixsbSksOCksZC54XzA9ZC54XzArZixkLnlfMD1kLnlfMCtoLHM9KGMueV8wLWQueV8wKS8oYy54XzAtZC54XzApLG89Yy55XzAtcypjLnhfMCxtPSh0LW8pLyhzLWkpLF8ueF8wPG0mJnUueF8wPG18fG08Xy54XzAmJm08dS54XzA/ITE6IShkLnhfMDxtJiZjLnhfMDxtfHxtPGQueF8wJiZtPGMueF8wKX1mdW5jdGlvbiBxOWUoKXt9cCgxODQyLDEse30scTllKSxsLmV2YWx1YXRlPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdTtmb3IodGhpcy5yb290PW4scj0wLHU9R2Yobiksbz0wLHM9bmV3IFQodSk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihpPWEoQyhzKSwyNyksKytvLHQ9bzt0PHUuYXJyYXkubGVuZ3RoO3QrKylveW4odGhpcyxpLChBZSh0LHUuYXJyYXkubGVuZ3RoKSxhKHUuYXJyYXlbdF0sMjcpKSkmJihyKz0xKTtyZXR1cm4gcn0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwuaW50ZXJtZWRpYXRlLm9wdGltaXphdGlvbiIsIkNyb3NzaW5nTWluaW1pemF0aW9uUG9zaXRpb24iLDE4NDIpO2Z1bmN0aW9uIFk5ZSgpe31wKDE4NDAsMSx7fSxZOWUpLGwuZXZhbHVhdGU9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7Zm9yKG89MCx0PW5ldyBYZShRZShFYyhuKS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24odCk7KXI9YSh0bih0KSw3NCksYz15byhhKE8oKCFyLnRhcmdldHMmJihyLnRhcmdldHM9bmV3IExlKGFuLHIsNSw4KSksci50YXJnZXRzKSwwKSw4NCkpLGQ9Yy54XzArYy53aWR0aF8wLzIsZj1jLnlfMCtjLmhlaWdodC8yLGk9bi54XzArbi53aWR0aF8wLzIscz1uLnlfMCtuLmhlaWdodC8yLGg9bmV3IG10LGgueF8wPWQtaSxoLnlfMD1mLXMsdT1uZXcgWShoLnhfMCxoLnlfMCksU3codSxuLndpZHRoXzAsbi5oZWlnaHQpLGgueF8wLT11LnhfMCxoLnlfMC09dS55XzAsaT1kLWgueF8wLHM9Zi1oLnlfMCxfPW5ldyBZKGgueF8wLGgueV8wKSxTdyhfLGMud2lkdGhfMCxjLmhlaWdodCksaC54XzAtPV8ueF8wLGgueV8wLT1fLnlfMCxkPWkraC54XzAsZj1zK2gueV8wLG09ZC1pLHk9Zi1zLG8rPVMuTWF0aC5zcXJ0KG0qbSt5KnkpO3JldHVybiBvfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5pbnRlcm1lZGlhdGUub3B0aW1pemF0aW9uIiwiRWRnZUxlbmd0aE9wdGltaXphdGlvbiIsMTg0MCk7ZnVuY3Rpb24gSzllKCl7fXAoMTg0MSwxLHt9LEs5ZSksbC5ldmFsdWF0ZT1mdW5jdGlvbihuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihvPTAsdD1uZXcgWGUoUWUoRWMobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylyPWEodG4odCksNzQpLGM9eW8oYShPKCghci50YXJnZXRzJiYoci50YXJnZXRzPW5ldyBMZShhbixyLDUsOCkpLHIudGFyZ2V0cyksMCksODQpKSxfPWMueF8wK2Mud2lkdGhfMC8yLGQ9Yy55XzArYy5oZWlnaHQvMixpPWEoVihjLChGbigpLGxtKSksOCkscz1uLnhfMCtpLnhfMCtuLndpZHRoXzAvMix1PW4ueV8wK2kueV8wK24uaGVpZ2h0LGY9Xy1zLGg9ZC11LG8rPVMuTWF0aC5zcXJ0KGYqZitoKmgpO3JldHVybiBvfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5pbnRlcm1lZGlhdGUub3B0aW1pemF0aW9uIiwiRWRnZUxlbmd0aFBvc2l0aW9uT3B0aW1pemF0aW9uIiwxODQxKTtmdW5jdGlvbiBYOWUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmU7aWYoci5hcnJheS5sZW5ndGghPTApe2Zvcih5PW5ldyBRLG09bmV3IFQocik7bS5pPG0udGhpcyQwMS5hcnJheS5sZW5ndGg7KWg9YShDKG0pLDI3KSxlZSh5LG5ldyBZKGgueF8wLGgueV8wKSk7Zm9yKHQubG9nR3JhcGgobiwiQmVmb3JlIHJlbW92aW5nIG92ZXJsYXBzIik7VlgoZSxyKTspZk4oZSxyLCExKTtpZih0LmxvZ0dyYXBoKG4sIkFmdGVyIHJlbW92aW5nIG92ZXJsYXBzIiksdT0wLGM9MCxvPW51bGwsci5hcnJheS5sZW5ndGghPTAmJihvPShBZSgwLHIuYXJyYXkubGVuZ3RoKSxhKHIuYXJyYXlbMF0sMjcpKSx1PW8ueF8wLShBZSgwLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMF0sOCkpLnhfMCxjPW8ueV8wLShBZSgwLHkuYXJyYXkubGVuZ3RoKSxhKHkuYXJyYXlbMF0sOCkpLnlfMCkscz1TLk1hdGguc3FydCh1KnUrYypjKSxmPVltbihyKSxpPTEsZi5tYXBfMC5zaXplXzEoKSE9MCl7Zm9yKGQ9Zi5tYXBfMC5rZXlTZXRfMCgpLml0ZXJhdG9yXzAoKTtkLmhhc05leHRfMCgpOylfPWEoZC5uZXh0XzEoKSwyNyksRT1lLnJvb3RfMCx2PUUueF8wK0Uud2lkdGhfMC8yLHg9RS55XzArRS5oZWlnaHQvMixBPV8ueF8wK18ud2lkdGhfMC8yLGs9Xy55XzArXy5oZWlnaHQvMixNPUEtdixIPWsteCxxPVMuTWF0aC5zcXJ0KE0qTStIKkgpLG5lPU0vcSx2ZT1IL3EsQ2koXyxfLnhfMCtuZSpzKSxUaShfLF8ueV8wK3ZlKnMpO3QubG9nR3JhcGgobiwiQ2hpbGQgbW92ZW1lbnQgIitpKSwrK2l9ZS5zb3J0ZXImJmUuc29ydGVyLnNvcnRfMShuZXcgUWkoZikpLFg5ZShlLG4sbmV3IFFpKGYpLHQpfX1mdW5jdGlvbiBpeW4oZSxuLHIpe3ZhciB0LG8saTtyLmJlZ2luKCJSZW1vdmUgb3ZlcmxhcHMiLDEpLHIubG9nR3JhcGgobiwiQmVmb3JlIiksdD1hKFYobiwocGcoKSxnZykpLDI3KSxlLnJvb3RfMD10LGUuc29ydGVyPWFNKGEoVihuLChIMCgpLHRUKSksMzAwKSksbz0kKFYobiwoRm4oKSx0MSkpKSxxWChlLChWZShvKSxvKSksaT1HZih0KSxYOWUoZSxuLGksciksci5sb2dHcmFwaChuLCJBZnRlciIpfWZ1bmN0aW9uIEo5ZSgpe31wKDEzOTIsNjUzLHNyLEo5ZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7aXluKHRoaXMsYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwuaW50ZXJtZWRpYXRlLm92ZXJsYXBzIiwiUmFkaXVzRXh0ZW5zaW9uT3ZlcmxhcFJlbW92YWwiLDEzOTIpO2Z1bmN0aW9uIGF5bihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtmb3IoZj1SKCQoVihlLChIMCgpLG9NKSkpKSxhZShpZShWKGUsdUopKSkmJihkPWEoVihlLChwZygpLGdnKSksMjcpLGk9YShPKGRuZShhKE8oKCFkLm91dGdvaW5nRWRnZXMmJihkLm91dGdvaW5nRWRnZXM9bmV3IExlKE1yLGQsNyw0KSksZC5vdXRnb2luZ0VkZ2VzKSwoIWQub3V0Z29pbmdFZGdlcyYmKGQub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZCw3LDQpKSxkLm91dGdvaW5nRWRnZXMpLnNpemVfMC0xKSw3NCkpLDApLDI3KSx0PWEoTyhkbmUoYShPKCghZC5vdXRnb2luZ0VkZ2VzJiYoZC5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixkLDcsNCkpLGQub3V0Z29pbmdFZGdlcyksMCksNzQpKSwwKSwyNykscz1uZXcgWShpLnhfMCtpLndpZHRoXzAvMixpLnlfMCtpLmhlaWdodC8yKSxvPW5ldyBZKHQueF8wK3Qud2lkdGhfMC8yLHQueV8wK3QuaGVpZ2h0LzIpLHI9ZixyPD0wJiYocis9aF8pLGg9Uy5NYXRoLmFjb3MoKHMueF8wKm8ueF8wK3MueV8wKm8ueV8wKS8oUy5NYXRoLnNxcnQocy54XzAqcy54XzArcy55XzAqcy55XzApKlMuTWF0aC5zcXJ0KG8ueF8wKm8ueF8wK28ueV8wKm8ueV8wKSkpLGg8PTAmJihoKz1oXyksbj1TLk1hdGguYXRhbjIocy55XzAscy54XzApLG48PTAmJihuKz1oXyksZj1ZRi0obi1yK2gvMikpLGM9bmV3IFllKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pKTtjLmN1cnNvciE9Yy50aGlzJDAxXzIuc2l6ZV8xKCk7KXU9YShlbihjKSwyNyksXz1uZXcgWSh1LnhfMCt1LndpZHRoXzAvMix1LnlfMCt1LmhlaWdodC8yKSxtPV8ueF8wKlMuTWF0aC5jb3MoZiktXy55XzAqUy5NYXRoLnNpbihmKSxfLnlfMD1fLnhfMCpTLk1hdGguc2luKGYpK18ueV8wKlMuTWF0aC5jb3MoZiksXy54XzA9bSxfbCh1LF8ueF8wLXUud2lkdGhfMC8yLF8ueV8wLXUuaGVpZ2h0LzIpfWZ1bmN0aW9uIGx5bihlLG4pe24uYmVnaW4oIkdlbmVyYWwgJ1JvdGF0b3IiLDEpLGF5bihlKX1mdW5jdGlvbiBaOWUoKXt9cCgxMzk0LDEsc3IsWjllKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtseW4oYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwuaW50ZXJtZWRpYXRlLnJvdGF0aW9uIiwiR2VuZXJhbFJvdGF0b3IiLDEzOTQpO2Z1bmN0aW9uIGdOKCl7Z049RixLWD1uZXcgWVgoIkxFQUZfTlVNQkVSIiwwKSxlTT1uZXcgWVgoIk5PREVfU0laRSIsMSl9ZnVuY3Rpb24gc3luKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMDpyZXR1cm4gbmV3IExPZTtjYXNlIDE6cmV0dXJuIG5ldyBPT2U7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgbGF5b3V0IG9wdGlvbiAiKyhlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWwpKSl9fWZ1bmN0aW9uIFlYKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gdXluKGUpe3JldHVybiBnTigpLHduKChROWUoKSxlT2UpLGUpfWZ1bmN0aW9uIGN5bigpe3JldHVybiBnTigpLFAoSShYWCwxKSxXLDQzNCwwLFtLWCxlTV0pfXAoNDM0LDIyLHszOjEsMzQ6MSwyMjoxLDQzNDoxfSxZWCk7dmFyIEtYLGVNLFhYPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5vcHRpb25zIiwiQW5udWx1c1dlZGdlQ3JpdGVyaWEiLDQzNCxnbixjeW4sdXluKTtmdW5jdGlvbiBROWUoKXtROWU9RixlT2U9eW4oKGdOKCksUChJKFhYLDEpLFcsNDM0LDAsW0tYLGVNXSkpKX12YXIgZU9lO2Z1bmN0aW9uIHJUKCl7clQ9RixoTj1uZXcgbk0oIk5PTkUiLDApLEpYPW5ldyBuTSgiUkFESUFMX0NPTVBBQ1RJT04iLDEpLFpYPW5ldyBuTSgiV0VER0VfQ09NUEFDVElPTiIsMil9ZnVuY3Rpb24gX3luKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMTpyZXR1cm4gbmV3IFY5ZTtjYXNlIDI6cmV0dXJuIG5ldyBHOWU7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgbGF5b3V0IG9wdGlvbiAiKyhlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWwpKSl9fWZ1bmN0aW9uIG5NKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZHluKGUpe3JldHVybiByVCgpLHduKChuT2UoKSxyT2UpLGUpfWZ1bmN0aW9uIGZ5bigpe3JldHVybiByVCgpLFAoSShRWCwxKSxXLDM5MywwLFtoTixKWCxaWF0pfXAoMzkzLDIyLHszOjEsMzQ6MSwyMjoxLDM5MzoxfSxuTSk7dmFyIGhOLEpYLFpYLFFYPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5vcHRpb25zIiwiQ29tcGFjdGlvblN0cmF0ZWd5IiwzOTMsZ24sZnluLGR5bik7ZnVuY3Rpb24gbk9lKCl7bk9lPUYsck9lPXluKChyVCgpLFAoSShRWCwxKSxXLDM5MywwLFtoTixKWCxaWF0pKSl9dmFyIHJPZTtmdW5jdGlvbiBlSigpe2VKPUYsb09lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5jZW50ZXJPblJvb3QiLCh6ZSgpLCExKSksc09lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5vcmRlcklkIixKKDApKSx1T2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJhZGl1cyIsMCksY09lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGUiLCExKSxuSj0oclQoKSxoTiksYU9lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5jb21wYWN0b3IiLG5KKSxKKDApLGlPZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwuY29tcGFjdGlvblN0ZXBTaXplIixKKDEpKSx0Sj0odk4oKSxzTSkscE9lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5zb3J0ZXIiLHRKKSxvSj0oZ04oKSxlTSksZ09lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC53ZWRnZUNyaXRlcmlhIixvSikscko9KHdOKCksaU0pLGxPZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwub3B0aW1pemF0aW9uQ3JpdGVyaWEiLHJKKSxmT2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJvdGF0aW9uLnRhcmdldEFuZ2xlIiwwKSxfT2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJvdGF0aW9uLmNvbXB1dGVBZGRpdGlvbmFsV2VkZ2VTcGFjZSIsITEpLGRPZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwucm90YXRpb24ub3V0Z29pbmdFZGdlQW5nbGVzIiwhMSl9ZnVuY3Rpb24gdE9lKCl7ZUooKX1wKDg2MywxLHBsLHRPZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe19lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5jZW50ZXJPblJvb3QiKSwiIiksIkNlbnRlciBPbiBSb290IiksIkNlbnRlcnMgdGhlIGxheW91dCBvbiB0aGUgcm9vdCBvZiB0aGUgdHJlZSBpLmUuIHNvIHRoYXQgdGhlIGNlbnRyYWwgbm9kZSBpcyBhbHNvIHRoZSBjZW50ZXIgbm9kZSBvZiB0aGUgZmluYWwgbGF5b3V0LiBUaGlzIGludHJvZHVjZXMgYWRkaXRpb25hbCB3aGl0ZXNwYWNlLiIpLCh6ZSgpLCExKSksKEpjKCksbnQpKSxBciksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwub3JkZXJJZCIpLCIiKSwiT3JkZXIgSUQiKSwiVGhlIGlkIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhbiBvcmRlciBmb3Igbm9kZXMgb2Ygb25lIHJhZGl1cy4gVGhpcyBjYW4gYmUgdXNlZCB0byBzb3J0IHRoZW0gaW4gdGhlIGxheWVyIGFjY29yZGluZ2x5LiIpLEooMCkpLGJvKSx2dCksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yYWRpdXMiKSwiIiksIlJhZGl1cyIpLCJUaGUgcmFkaXVzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGluaXRpYWwgcmFkaXVzIGZvciB0aGUgcmFkaWFsIGxheW91dGVyLiIpLDApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGUiKSwiIiksIlJvdGF0ZSIpLCJUaGUgcm90YXRlIG9wdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgYSByb3RhdGlvbiBvZiB0aGUgbGF5b3V0IHNob3VsZCBiZSBwZXJmb3JtZWQuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5jb21wYWN0b3IiKSwiIiksIkNvbXBhY3Rpb24iKSwiV2l0aCB0aGUgY29tcGFjdGVyIG9wdGlvbiBpdCBjYW4gYmUgZGV0ZXJtaW5lZCBob3cgY29tcGFjdGlvbiBvbiB0aGUgZ3JhcGggaXMgZG9uZS4gSXQgY2FuIGJlIGNob3NlbiBiZXR3ZWVuIG5vbmUsIHRoZSByYWRpYWwgY29tcGFjdGlvbiBvciB0aGUgY29tcGFjdGlvbiBvZiB3ZWRnZXMgc2VwYXJhdGVseS4iKSxuSiksbXIpLFFYKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLmNvbXBhY3Rpb25TdGVwU2l6ZSIpLCIiKSwiQ29tcGFjdGlvbiBTdGVwIFNpemUiKSwiRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHN0ZXBzIHdpdGggd2hpY2ggdGhlIGNvbXBhY3Rpb24gaXMgZG9uZS4gU3RlcCBzaXplIDEgY29ycmVsYXRlcyB0byBhIGNvbXBhY3Rpb24gb2YgMSBwaXhlbCBwZXIgSXRlcmF0aW9uLiIpLEooMSkpLGJvKSx2dCksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwuY29tcGFjdGlvblN0ZXBTaXplIiwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5jb21wYWN0b3IiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5zb3J0ZXIiKSwiIiksIlNvcnRlciIpLCJTb3J0IHRoZSBub2RlcyBwZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc29ydGluZyBhbGdvcml0aG0uIFRoZSBzdHJhdGVnaWVzIGFyZSBub25lLCBieSB0aGUgZ2l2ZW4gb3JkZXIgaWQsIG9yIHNvcnRpbmcgdGhlbSBieSBwb2xhciBjb29yZGluYXRlcy4iKSx0SiksbXIpLHlKKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLndlZGdlQ3JpdGVyaWEiKSwiIiksIkFubnVsdXMgV2VkZ2UgQ3JpdGVyaWEiKSwiRGV0ZXJtaW5lIGhvdyB0aGUgd2VkZ2UgZm9yIHRoZSBub2RlIHBsYWNlbWVudCBpcyBjYWxjdWxhdGVkLiBJdCBjYW4gYmUgY2hvc2VuIGJldHdlZW4gd2VkZ2UgZGV0ZXJtaW5hdGlvbiBieSB0aGUgbnVtYmVyIG9mIGxlYXZlcyBvciBieSB0aGUgbWF4aW11bSBzdW0gb2YgZGlhZ29uYWxzLiIpLG9KKSxtciksWFgpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwub3B0aW1pemF0aW9uQ3JpdGVyaWEiKSwiIiksIlRyYW5zbGF0aW9uIE9wdGltaXphdGlvbiIpLCJGaW5kIHRoZSBvcHRpbWFsIHRyYW5zbGF0aW9uIG9mIHRoZSBub2RlcyBvZiB0aGUgZmlyc3QgcmFkaWkgYWNjb3JkaW5nIHRvIHRoaXMgY3JpdGVyaWEuIEZvciBleGFtcGxlIGVkZ2UgY3Jvc3NpbmdzIGNhbiBiZSBtaW5pbWl6ZWQuIiksckopLG1yKSxnSiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGlvbi50YXJnZXRBbmdsZSIpLCJyb3RhdGlvbiIpLCJUYXJnZXQgQW5nbGUiKSwiVGhlIGFuZ2xlIGluIHJhZGlhbnMgdGhhdCB0aGUgbGF5b3V0IHNob3VsZCBiZSByb3RhdGVkIHRvIGFmdGVyIGxheW91dC4iKSwwKSxQdCksJHIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJvdGF0aW9uLnRhcmdldEFuZ2xlIiwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGUiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGlvbi5jb21wdXRlQWRkaXRpb25hbFdlZGdlU3BhY2UiKSwicm90YXRpb24iKSwiQWRkaXRpb25hbCBXZWRnZSBTcGFjZSIpLCJJZiBzZXQgdG8gdHJ1ZSwgbW9kaWZpZXMgdGhlIHRhcmdldCBhbmdsZSBieSByb3RhdGluZyBmdXJ0aGVyIHN1Y2ggdGhhdCBzcGFjZSBpcyBsZWZ0IGZvciBhbiBlZGdlIHRvIHBhc3MgaW4gYmV0d2VlbiB0aGUgbm9kZXMuIFRoaXMgb3B0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0b3AtZG93biBsYXlvdXQuIiksITEpLG50KSxBciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwucm90YXRpb24uY29tcHV0ZUFkZGl0aW9uYWxXZWRnZVNwYWNlIiwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGUiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5yb3RhdGlvbi5vdXRnb2luZ0VkZ2VBbmdsZXMiKSwicm90YXRpb24iKSwiT3V0Z29pbmcgRWRnZSBBbmdsZXMiKSwiQ2FsY3VsYXRlIHRoZSByZXF1aXJlZCBhbmdsZSBvZiBjb25uZWN0ZWQgbm9kZXMgdG8gbGVhdmUgc3BhY2UgZm9yIGFuIGluY29taW5nIGVkZ2UuIFRoaXMgb3B0aW9uIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0b3AtZG93biBsYXlvdXQuIiksITEpLG50KSxBciksRWUoT2UpKSkpLGhPZSgobmV3IG1PZSxuKSl9O3ZhciBvT2UsaU9lLGFPZSxuSixsT2Usckosc09lLHVPZSxjT2UsX09lLGRPZSxmT2UscE9lLHRKLGdPZSxvSjtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5vcHRpb25zIiwiUmFkaWFsTWV0YURhdGFQcm92aWRlciIsODYzKTtmdW5jdGlvbiBIMCgpe0gwPUYsQ09lPShGbigpLGxtKSxUT2U9dDEsd09lPXIxLEVPZT14Zyx2T2U9VzAseU9lPUlnLGFKPUFULFNPZT1qZixyTT0oZUooKSxpT2UpLHRNPWFPZSxzSj1jT2Usb009Zk9lLHVKPV9PZSxjSj1kT2UsbEo9bE9lLG1OPXNPZSx5Tj11T2UsdFQ9cE9lLF9KPWdPZSxpSj1vT2V9ZnVuY3Rpb24gaE9lKGUpe2hkKGUsbmV3IEpfKGpOKGdkKGRkKHBkKGZkKG5ldyBaXywib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIpLCJFTEsgUmFkaWFsIiksJ0EgcmFkaWFsIGxheW91dCBwcm92aWRlciB3aGljaCBpcyBiYXNlZCBvbiB0aGUgYWxnb3JpdGhtIG9mIFBldGVyIEVhZGVzIHB1Ymxpc2hlZCBpbiAiRHJhd2luZyBmcmVlIHRyZWVzLiIsIHB1Ymxpc2hlZCBieSBJbnRlcm5hdGlvbmFsIEluc3RpdHV0ZSBmb3IgQWR2YW5jZWQgU3R1ZHkgb2YgU29jaWFsIEluZm9ybWF0aW9uIFNjaWVuY2UsIEZ1aml0c3UgTGltaXRlZCBpbiAxOTkxLiBUaGUgcmFkaWFsIGxheW91dGVyIHRha2VzIGEgdHJlZSBhbmQgcGxhY2VzIHRoZSBub2RlcyBpbiByYWRpYWwgb3JkZXIgYXJvdW5kIHRoZSByb290LiBUaGUgbm9kZXMgb2YgdGhlIHNhbWUgdHJlZSBsZXZlbCBhcmUgcGxhY2VkIG9uIHRoZSBzYW1lIHJhZGl1cy4nKSxuZXcgYk9lKSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIpKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLnBvc2l0aW9uIix0ZShDT2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5ub2RlTm9kZSIsdGUoVE9lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmNvbnN0cmFpbnRzIix0ZSh3T2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUubWluaW11bSIsdGUoRU9lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm9wdGlvbnMiLHRlKHZPZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlTGFiZWxzLnBsYWNlbWVudCIsdGUoeU9lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLm9taXROb2RlTWljcm9MYXlvdXQiLHRlKGFKKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMucGxhY2VtZW50Iix0ZShTT2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLmNvbXBhY3Rpb25TdGVwU2l6ZSIsdGUock0pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLmNvbXBhY3RvciIsdGUodE0pKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJvdGF0ZSIsdGUoc0opKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLnJvdGF0aW9uLnRhcmdldEFuZ2xlIix0ZShvTSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwucm90YXRpb24uY29tcHV0ZUFkZGl0aW9uYWxXZWRnZVNwYWNlIix0ZSh1SikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwucm90YXRpb24ub3V0Z29pbmdFZGdlQW5nbGVzIix0ZShjSikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwub3B0aW1pemF0aW9uQ3JpdGVyaWEiLHRlKGxKKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsIiwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbC5vcmRlcklkIix0ZShtTikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwucmFkaXVzIix0ZSh5TikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwuc29ydGVyIix0ZSh0VCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwud2VkZ2VDcml0ZXJpYSIsdGUoX0opKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYWRpYWwiLCJvcmcuZWNsaXBzZS5lbGsucmFkaWFsLmNlbnRlck9uUm9vdCIsdGUoaUopKX1mdW5jdGlvbiBtT2UoKXtIMCgpfXAoMTAwOCwxLHBsLG1PZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe2hPZShuKX07dmFyIGlKLHJNLHRNLHlPZSx3T2UsRU9lLHZPZSxhSixsSixtTixTT2UsQ09lLHlOLHNKLHVKLGNKLG9NLHRULFRPZSxfSjtnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5vcHRpb25zIiwiUmFkaWFsT3B0aW9ucyIsMTAwOCk7ZnVuY3Rpb24gYk9lKCl7fXAoMTAwOSwxLHt9LGJPZSksbC5jcmVhdGVfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPW5ldyB4OWUsbn0sbC5kZXN0cm95PWZ1bmN0aW9uKG4pe30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwub3B0aW9ucyIsIlJhZGlhbE9wdGlvbnMvUmFkaWFsRmFjdG9yeSIsMTAwOSk7ZnVuY3Rpb24gd04oKXt3Tj1GLGlNPW5ldyBFTigiTk9ORSIsMCksZko9bmV3IEVOKCJFREdFX0xFTkdUSCIsMSkscEo9bmV3IEVOKCJFREdFX0xFTkdUSF9CWV9QT1NJVElPTiIsMiksZEo9bmV3IEVOKCJDUk9TU0lOR19NSU5JTUlaQVRJT05fQllfUE9TSVRJT04iLDMpfWZ1bmN0aW9uIHB5bihlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIG5ldyBZOWU7Y2FzZSAyOnJldHVybiBuZXcgSzllO2Nhc2UgMzpyZXR1cm4gbmV3IHE5ZTtjYXNlIDA6cmV0dXJuIG51bGw7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgbGF5b3V0IG9wdGlvbiAiKyhlLm5hbWVfMCE9bnVsbD9lLm5hbWVfMDoiIitlLm9yZGluYWwpKSl9fWZ1bmN0aW9uIEVOKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZ3luKGUpe3JldHVybiB3TigpLHduKChJT2UoKSx4T2UpLGUpfWZ1bmN0aW9uIGh5bigpe3JldHVybiB3TigpLFAoSShnSiwxKSxXLDM1NCwwLFtpTSxmSixwSixkSl0pfXAoMzU0LDIyLHszOjEsMzQ6MSwyMjoxLDM1NDoxfSxFTik7dmFyIGRKLGZKLHBKLGlNLGdKPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5vcHRpb25zIiwiUmFkaWFsVHJhbnNsYXRpb25TdHJhdGVneSIsMzU0LGduLGh5bixneW4pO2Z1bmN0aW9uIElPZSgpe0lPZT1GLHhPZT15bigod04oKSxQKEkoZ0osMSksVywzNTQsMCxbaU0sZkoscEosZEpdKSkpfXZhciB4T2U7ZnVuY3Rpb24gdk4oKXt2Tj1GLHNNPW5ldyBsTSgiTk9ORSIsMCksbUo9bmV3IGxNKCJQT0xBUl9DT09SRElOQVRFIiwxKSxoSj1uZXcgbE0oIklEIiwyKX1mdW5jdGlvbiBhTShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG51bGw7Y2FzZSAxOnJldHVybiBuZXcgQk9lO2Nhc2UgMjpyZXR1cm4gbmV3IEVKO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGxheW91dCBvcHRpb24gIisoZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsKSkpfX1mdW5jdGlvbiBsTShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIG15bihlKXtyZXR1cm4gdk4oKSx3bigoUE9lKCksTk9lKSxlKX1mdW5jdGlvbiB5eW4oKXtyZXR1cm4gdk4oKSxQKEkoeUosMSksVywzMDAsMCxbc00sbUosaEpdKX1wKDMwMCwyMix7MzoxLDM0OjEsMjI6MSwzMDA6MX0sbE0pO3ZhciBoSixzTSxtSix5Sj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwub3B0aW9ucyIsIlNvcnRpbmdTdHJhdGVneSIsMzAwLGduLHl5bixteW4pO2Z1bmN0aW9uIFBPZSgpe1BPZT1GLE5PZT15bigodk4oKSxQKEkoeUosMSksVywzMDAsMCxbc00sbUosaEpdKSkpfXZhciBOT2U7ZnVuY3Rpb24gd0ooZSxuLHIsdCxvLGkpe3ZhciBzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKGg9aSx1PSh0K28pLzIraCx2PXIqUy5NYXRoLmNvcyh1KSx4PXIqUy5NYXRoLnNpbih1KSxBPXYtbi53aWR0aF8wLzIsaz14LW4uaGVpZ2h0LzIsQ2kobixBKSxUaShuLGspLGY9ZS5hbm51bHVzV2VkZ2VDcml0ZXJpYS5jYWxjdWxhdGVXZWRnZVNwYWNlKG4pLEU9MipTLk1hdGguYWNvcyhyL3IrZS5yYWRpdXMpLEU8by10PyhtPUUvZixzPSh0K28tRSkvMik6KG09KG8tdCkvZixzPXQpLHk9R2YobiksZS5zb3J0ZXImJihlLnNvcnRlci5pbml0aWFsaXplXzAoZS5yb290KSxlLnNvcnRlci5zb3J0XzEoeSkpLF89bmV3IFQoeSk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWM9YShDKF8pLDI3KSxkPWUuYW5udWx1c1dlZGdlQ3JpdGVyaWEuY2FsY3VsYXRlV2VkZ2VTcGFjZShjKSx3SihlLGMscitlLnJhZGl1cyxzLHMrbSpkLGkpLHMrPW0qZH1mdW5jdGlvbiB3eW4oZSxuLHIpe3IuYmVnaW4oIkVhZGVzIHJhZGlhbCIsMSksci5sb2dHcmFwaChuLCJBZnRlciIpLGUucm9vdD1hKFYobiwocGcoKSxnZykpLDI3KSxlLnJhZGl1cz1SKCQoVihuLChIMCgpLHlOKSkpKSxlLnNvcnRlcj1hTShhKFYobix0VCksMzAwKSksZS5hbm51bHVzV2VkZ2VDcml0ZXJpYT1zeW4oYShWKG4sX0opLDQzNCkpLGUub3B0aW1pemVyPXB5bihhKFYobixsSiksMzU0KSksRXluKGUpLHIubG9nR3JhcGgobiwiQWZ0ZXIiKX1mdW5jdGlvbiBFeW4oZSl7dmFyIG4scix0LG8saTtpZih0PTAsbz1tcCxlLm9wdGltaXplcilmb3Iobj0wO248MzYwO24rKylyPW4qLjAxNzQ1MzI5MjUxOTk0MzI5NSx3SihlLGUucm9vdCwwLDAsaF8sciksaT1lLm9wdGltaXplci5ldmFsdWF0ZShlLnJvb3QpLGk8byYmKHQ9cixvPWkpO3dKKGUsZS5yb290LDAsMCxoXyx0KX1mdW5jdGlvbiBBT2UoKXt9cCgxNDc2LDEsV3QsQU9lKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNyksbnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7d3luKHRoaXMsYShuLDI3KSxyKX0sbC5yYWRpdXM9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5wMXBvc2l0aW9uIiwiRWFkZXNSYWRpYWwiLDE0NzYpO2Z1bmN0aW9uIExPZSgpe31wKDE4MzgsMSx7fSxMT2UpLGwuY2FsY3VsYXRlV2VkZ2VTcGFjZT1mdW5jdGlvbihuKXtyZXR1cm4gQTllKG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5wMXBvc2l0aW9uLndlZGdlIiwiQW5udWx1c1dlZGdlQnlMZWFmcyIsMTgzOCk7ZnVuY3Rpb24ga09lKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKHU9R2YobiksaT1uLmhlaWdodCxjPW4ud2lkdGhfMCxzPVMuTWF0aC5zcXJ0KGkqaStjKmMpLG89MCx0PW5ldyBUKHUpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwyNyksbys9a09lKGUscik7cmV0dXJuIFMuTWF0aC5tYXgobyxzKX1mdW5jdGlvbiBPT2UoKXt9cCgxODM5LDEse30sT09lKSxsLmNhbGN1bGF0ZVdlZGdlU3BhY2U9ZnVuY3Rpb24obil7cmV0dXJuIGtPZSh0aGlzLG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJhZGlhbC5wMXBvc2l0aW9uLndlZGdlIiwiQW5udWx1c1dlZGdlQnlOb2RlU3BhY2UiLDE4MzkpO2Z1bmN0aW9uIHZ5bihlLG4scil7dmFyIHQ7ci5iZWdpbigiU3RyYWlnaHQgTGluZSBFZGdlIFJvdXRpbmciLDEpLHIubG9nR3JhcGgobiwiQmVmb3JlIiksdD1hKFYobiwocGcoKSxnZykpLDI3KSxNT2UoZSx0KSxyLmxvZ0dyYXBoKG4sIkFmdGVyIil9ZnVuY3Rpb24gTU9lKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtmb3IodD1uZXcgWGUoUWUoRWMobikudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHQpOylyPWEodG4odCksNzQpLEwoTygoIXIuc291cmNlcyYmKHIuc291cmNlcz1uZXcgTGUoYW4sciw0LDcpKSxyLnNvdXJjZXMpLDApLDE5Myl8fChjPXlvKGEoTygoIXIudGFyZ2V0cyYmKHIudGFyZ2V0cz1uZXcgTGUoYW4sciw1LDgpKSxyLnRhcmdldHMpLDApLDg0KSksbFMocil8fChzPW4ueF8wK24ud2lkdGhfMC8yLHU9bi55XzArbi5oZWlnaHQvMixkPWMueF8wK2Mud2lkdGhfMC8yLGY9Yy55XzArYy5oZWlnaHQvMixoPW5ldyBtdCxoLnhfMD1kLXMsaC55XzA9Zi11LGk9bmV3IFkoaC54XzAsaC55XzApLFN3KGksbi53aWR0aF8wLG4uaGVpZ2h0KSxoLnhfMC09aS54XzAsaC55XzAtPWkueV8wLHM9ZC1oLnhfMCx1PWYtaC55XzAsXz1uZXcgWShoLnhfMCxoLnlfMCksU3coXyxjLndpZHRoXzAsYy5oZWlnaHQpLGgueF8wLT1fLnhfMCxoLnlfMC09Xy55XzAsZD1zK2gueF8wLGY9dStoLnlfMCxvPUZnKHIsITAsITApLEZ3KG8scyksencobyx1KSxSdyhvLGQpLER3KG8sZiksTU9lKGUsYykpKX1mdW5jdGlvbiBST2UoKXt9cCgxNDc3LDEsV3QsUk9lKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNyksbnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7dnluKHRoaXMsYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwucDJyb3V0aW5nIiwiU3RyYWlnaHRMaW5lRWRnZVJvdXRlciIsMTQ3Nyk7ZnVuY3Rpb24gRE9lKGUsbil7bi5zb3J0XzAoZS5pZFNvcnRlcil9ZnVuY3Rpb24gRUooKXt0aGlzLmlkU29ydGVyPW5ldyBGT2V9ZnVuY3Rpb24gU3luKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKFYoZSwoSDAoKSxtTikpLDE3KSx0PWEoVihuLG1OKSwxNykscW8oci52YWx1ZV8wLHQudmFsdWVfMCl9cCg4MjYsMSx7fSxFSiksbC5pbml0aWFsaXplXzA9ZnVuY3Rpb24obil7fSxsLnNvcnRfMT1mdW5jdGlvbihuKXtET2UodGhpcyxuKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yYWRpYWwuc29ydGluZyIsIklEU29ydGVyIiw4MjYpO2Z1bmN0aW9uIEZPZSgpe31wKDE4MzcsMSxObixGT2UpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIFN5bihhKG4sMjcpLGEociwyNykpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLnNvcnRpbmciLCJJRFNvcnRlci9sYW1iZGEkMCRUeXBlIiwxODM3KTtmdW5jdGlvbiB6T2UoZSxuKXt2YXIgcjtlLmlkU29ydGVyPW5ldyBFSixyPUdmKG4pLERyKHIsZS5jb21wUmlnaHQpLCRPZShlLHIsMCl9ZnVuY3Rpb24gJE9lKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7Zm9yKG89cixpPTAsdT1uZXcgVChuKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMjcpLG5yKHMsKEgwKCksbU4pLEoobysrKSksYz1HZihzKSx0PVMuTWF0aC5hdGFuMihzLnlfMCtzLmhlaWdodC8yLHMueF8wK3Mud2lkdGhfMC8yKSx0Kz10PDA/aF86MCx0PC43ODUzOTgxNjMzOTc0NDgzfHx0PlNpZT9EcihjLGUuY29tcExlZnQpOnQ8PVNpZSYmdD5DaWU/RHIoYyxlLmNvbXBUb3ApOnQ8PUNpZSYmdD5UaWU/RHIoYyxlLmNvbXBSaWdodCk6dDw9VGllJiZEcihjLGUuY29tcEJvdHRvbSksaT0kT2UoZSxjLGkpO3JldHVybiBvfWZ1bmN0aW9uIEJPZSgpe3RoaXMuY29tcFJpZ2h0PW5ldyBfTigwKSx0aGlzLmNvbXBMZWZ0PW5ldyBfTihZRiksdGhpcy5jb21wVG9wPW5ldyBfTihFaWUpLHRoaXMuY29tcEJvdHRvbT1uZXcgX04oZDYpfXAoMTgzNiwxLHt9LEJPZSksbC5pbml0aWFsaXplXzA9ZnVuY3Rpb24obil7ek9lKHRoaXMsbil9LGwuc29ydF8xPWZ1bmN0aW9uKG4pe3ZhciByO24uaXNFbXB0eSgpfHwodGhpcy5pZFNvcnRlcnx8KHI9TjllKGEobi5nZXRfMCgwKSwyNykpLHpPZSh0aGlzLHIpKSxET2UodGhpcy5pZFNvcnRlcixuKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmFkaWFsLnNvcnRpbmciLCJQb2xhckNvb3JkaW5hdGVTb3J0ZXIiLDE4MzYpO2Z1bmN0aW9uIFNOKCl7U049RixvVD1uZXcgdU0oIlAxX1dJRFRIX0FQUFJPWElNQVRJT04iLDApLENOPW5ldyB1TSgiUDJfUEFDS0lORyIsMSksY009bmV3IHVNKCJQM19XSElURVNQQUNFX0VMSU1JTkFUSU9OIiwyKX1mdW5jdGlvbiB1TShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEN5bihlKXtyZXR1cm4gU04oKSx3bigoR09lKCksSE9lKSxlKX1mdW5jdGlvbiBUeW4oKXtyZXR1cm4gU04oKSxQKEkodkosMSksVyw0NDUsMCxbb1QsQ04sY01dKX1wKDQ0NSwyMix7MzoxLDM0OjEsMjI6MSw0NDU6MX0sdU0pO3ZhciBvVCxDTixjTSx2Sj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZyIsIlJlY3RQYWNraW5nTGF5b3V0UGhhc2VzIiw0NDUsZ24sVHluLEN5bik7ZnVuY3Rpb24gR09lKCl7R09lPUYsSE9lPXluKChTTigpLFAoSSh2SiwxKSxXLDQ0NSwwLFtvVCxDTixjTV0pKSl9dmFyIEhPZTtmdW5jdGlvbiBVT2UoKXt0aGlzLmFsZ29yaXRobUFzc2VtYmxlcj1uZXcgQXYodkopfWZ1bmN0aW9uIGJ5bihlLG4pe3ZhciByLHQ7Zm9yKHQ9bmV3IFllKGUpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDI3KSxfbChyLHIueF8wK24ubGVmdCxyLnlfMCtuLnRvcF8wKX1wKDExMTgsMjA1LGdfLFVPZSksbC5sYXlvdXQ9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlO2lmKHIuYmVnaW4oIlJlY3RhbmdsZSBQYWNraW5nIiwxKSxoPWEoVihuLChGcygpLEN2KSksMTA3KSxfPWFlKGllKFYobixFN2UpKSksZj1SKCQoVihuLFR2KSkpLHdlPWFlKGllKFYobixNSikpKSxNPSghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pLGFlKGllKFYobix3TSkpKXx8VUMoKGk9bmV3IGFFKChFZCgpLG5ldyB2ZChuKSkpLGkpKSx2ZT0hMSx3ZSYmTS5zaXplXzA+PTMpZm9yKHE9YShPKE0sMCksMjcpLG5lPWEoTyhNLDEpLDI3KSxzPTA7cysyPE0uc2l6ZV8wOylpZihIPXEscT1uZSxuZT1hKE8oTSxzKzIpLDI3KSxILmhlaWdodD49cS5oZWlnaHQrbmUuaGVpZ2h0K2Z8fG5lLmhlaWdodD49SC5oZWlnaHQrcS5oZWlnaHQrZil7dmU9ITA7YnJlYWt9ZWxzZSsrcztlbHNlIHZlPSEwO2lmKCF2ZSl7Zm9yKG09TS5zaXplXzAsYz1uZXcgWWUoTSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl1PWEoZW4oYyksMjcpLG5yKHUsKEZuKCksTFQpLEoobSkpLC0tbTtvemUobixuZXcgZ20pLHIuZG9uZV8xKCk7cmV0dXJufWZvcih0PSh2VCh0aGlzLmFsZ29yaXRobUFzc2VtYmxlciksZ3ModGhpcy5hbGdvcml0aG1Bc3NlbWJsZXIsKFNOKCksb1QpLGEoVihuLHpKKSwxODgpKSxncyh0aGlzLmFsZ29yaXRobUFzc2VtYmxlcixDTixhKFYobixrSiksMTg4KSksZ3ModGhpcy5hbGdvcml0aG1Bc3NlbWJsZXIsY00sYShWKG4sUkopLDE4OCkpLEdaKHRoaXMuYWxnb3JpdGhtQXNzZW1ibGVyLChEZT1uZXcgSHIsTW4oRGUsb1QsKFROKCkscE0pKSxNbihEZSxDTixmTSksYWUoaWUoVihuLEFKKSkpJiZNbihEZSxvVCxkTSksRGUpKSxFVCh0aGlzLmFsZ29yaXRobUFzc2VtYmxlcixuKSksZD0xL3QuYXJyYXkubGVuZ3RoLEU9bmV3IFQodCk7RS5pPEUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtpZih5PWEoQyhFKSw0Nyksci5pc0NhbmNlbGVkKCkpcmV0dXJuO3kucHJvY2VzcyhuLHIuc3ViVGFzayhkKSl9Zm9yKHg9MCx2PTAsaz1uZXcgWWUoTSk7ay5jdXJzb3IhPWsudGhpcyQwMV8yLnNpemVfMSgpOylBPWEoZW4oayksMjcpLHg9Uy5NYXRoLm1heCh4LEEueF8wK0Eud2lkdGhfMCksdj1TLk1hdGgubWF4KHYsQS55XzArQS5oZWlnaHQpO2tlZShuLG5ldyBZKFIoJChWKG4sKEZ1KCksSmgpKSkpLFIoJChWKG4seXcpKSkpLG5ldyBZKHgsdikpLGJ5bihNLGgpLF98fHdkKG4sUigkKFYobixKaCkpKSsoaC5sZWZ0K2gucmlnaHQpLFIoJChWKG4seXcpKSkrKGgudG9wXzAraC5ib3R0b20pLCExLCEwKSxhZShpZShWKG4sd00pKSl8fFVDKChvPW5ldyBhRSgoRWQoKSxuZXcgdmQobikpKSxvKSksci5kb25lXzEoKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZyIsIlJlY3RQYWNraW5nTGF5b3V0UHJvdmlkZXIiLDExMTgpO2Z1bmN0aW9uIEl5bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtmb3Iobi5iZWdpbigiSW50ZXJhY3RpdmUgTm9kZSBSZW9yZGVyZXIiLDEpLGQ9KCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbiksdT1uZXcgUSxvPW5ldyBZZShkKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXI9YShlbihvKSwyNyksV3MociwoRnMoKSxpVCkpJiZSZSh1LmFycmF5LHIpO2ZvcihpPW5ldyBUKHUpO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyhpKSwyNyksWkEoZCxyKTtmb3IoTmUoKSxEcih1LG5ldyBqT2UpLHM9bmV3IFQodSk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHMpLDI3KSxfPWEoVihyLChGcygpLGlUKSksMTcpLnZhbHVlXzAsXz1TLk1hdGgubWluKF8sZC5zaXplXzApLGZTKGQsXyxyKTtmb3IoYz0wLHQ9bmV3IFllKGQpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDI3KSxucihyLChGcygpLE5KKSxKKGMpKSwrK2M7bi5kb25lXzEoKX1mdW5jdGlvbiBXT2UoKXt9ZnVuY3Rpb24geHluKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKFYoZSwoRnMoKSxpVCkpLDE3KS52YWx1ZV8wLHQ9YShWKG4saVQpLDE3KS52YWx1ZV8wLHI9PXR8fHI8dD8tMTpyPnQ/MTowfXAoMTUxOCwxLHNyLFdPZSksbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7SXluKGEobiwyNykscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcuaW50ZXJtZWRpYXRlIiwiSW50ZXJhY3RpdmVOb2RlUmVvcmRlcmVyIiwxNTE4KTtmdW5jdGlvbiBqT2UoKXt9cCgxNTE5LDEsTm4sak9lKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiB4eW4oYShuLDI3KSxhKHIsMjcpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLmludGVybWVkaWF0ZSIsIkludGVyYWN0aXZlTm9kZVJlb3JkZXJlci9sYW1iZGEkMCRUeXBlIiwxNTE5KTtmdW5jdGlvbiBUTigpe1ROPUYsZE09bmV3IF9NKCJJTlRFUkFDVElWRV9OT0RFX1JFT1JERVJFUiIsMCkscE09bmV3IF9NKCJNSU5fU0laRV9QUkVfUFJPQ0VTU09SIiwxKSxmTT1uZXcgX00oIk1JTl9TSVpFX1BPU1RfUFJPQ0VTU09SIiwyKX1mdW5jdGlvbiBfTShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIFB5bihlKXtyZXR1cm4gVE4oKSx3bigocU9lKCksWU9lKSxlKX1mdW5jdGlvbiBOeW4oKXtyZXR1cm4gVE4oKSxQKEkoVk9lLDEpLFcsNDU2LDAsW2RNLHBNLGZNXSl9cCg0NTYsMjIsezM6MSwzNDoxLDIyOjEsNDU2OjEsMTk2OjF9LF9NKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgV09lO2Nhc2UgMTpyZXR1cm4gbmV3IFhPZTtjYXNlIDI6cmV0dXJuIG5ldyBLT2V9cmV0dXJuIG51bGx9O3ZhciBkTSxmTSxwTSxWT2U9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcuaW50ZXJtZWRpYXRlIiwiSW50ZXJtZWRpYXRlUHJvY2Vzc29yU3RyYXRlZ3kiLDQ1NixnbixOeW4sUHluKTtmdW5jdGlvbiBxT2UoKXtxT2U9RixZT2U9eW4oKFROKCksUChJKFZPZSwxKSxXLDQ1NiwwLFtkTSxwTSxmTV0pKSl9dmFyIFlPZTtmdW5jdGlvbiBBeW4oZSxuKXtuLmJlZ2luKCJNaW4gU2l6ZSBQb3N0cHJvY2Vzc2luZyIsMSksbnIoZSwoRnUoKSxIZiksUy5NYXRoLm1heChSKCQoVihlLEhmKSkpLFIoJChWKGUsU3YpKSkpKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIEtPZSgpe31wKDE1MjEsMSxzcixLT2UpLGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0F5bihhKG4sMjcpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLmludGVybWVkaWF0ZSIsIk1pblNpemVQb3N0UHJvY2Vzc29yIiwxNTIxKTtmdW5jdGlvbiBMeW4oZSxuKXt2YXIgcjtuLmJlZ2luKCJNaW4gU2l6ZSBQcmVwcm9jZXNzaW5nIiwxKSxyPU5lZShlKSxucihlLChGdSgpLFN2KSxyLnhfMCksbnIoZSxiTixyLnlfMCksbi5kb25lXzEoKX1mdW5jdGlvbiBYT2UoKXt9cCgxNTIwLDEsc3IsWE9lKSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtMeW4oYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5pbnRlcm1lZGlhdGUiLCJNaW5TaXplUHJlUHJvY2Vzc29yIiwxNTIwKTtmdW5jdGlvbiBGdSgpe0Z1PUYsdnY9bmV3IHRyKCJhZGRpdGlvbmFsSGVpZ2h0IikseXc9bmV3IHRyKCJkcmF3aW5nSGVpZ2h0IiksSmg9bmV3IHRyKCJkcmF3aW5nV2lkdGgiKSxiTj1uZXcgdHIoIm1pbkhlaWdodCIpLFN2PW5ldyB0cigibWluV2lkdGgiKSxJTj1uZXcgdHIoInJvd3MiKSxIZj1uZXcgdHIoInRhcmdldFdpZHRoIiksaE09bmV3IHZyKCJtaW5Sb3dJbmNyZWFzZSIsMCksWk9lPW5ldyB2cigibWF4Um93SW5jcmVhc2UiLDApLGdNPW5ldyB2cigibWluUm93RGVjcmVhc2UiLDApLEpPZT1uZXcgdnIoIm1heFJvd0RlY3JlYXNlIiwwKX12YXIgdnYseXcsSmgsSk9lLFpPZSxiTixnTSxoTSxTdixJTixIZjtmdW5jdGlvbiB4Tigpe3hOPUYsQ0o9bmV3IG1NKCJBU1BFQ1RfUkFUSU9fRFJJVkVOIiwwKSx5TT1uZXcgbU0oIk1BWF9TQ0FMRV9EUklWRU4iLDEpLFNKPW5ldyBtTSgiQVJFQV9EUklWRU4iLDIpfWZ1bmN0aW9uIG1NKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24ga3luKGUpe3JldHVybiB4TigpLHduKChRT2UoKSxlN2UpLGUpfWZ1bmN0aW9uIE95bigpe3JldHVybiB4TigpLFAoSShUSiwxKSxXLDM5NCwwLFtDSix5TSxTSl0pfXAoMzk0LDIyLHszOjEsMzQ6MSwyMjoxLDM5NDoxfSxtTSk7dmFyIFNKLENKLHlNLFRKPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLm9wdGlvbnMiLCJPcHRpbWl6YXRpb25Hb2FsIiwzOTQsZ24sT3luLGt5bik7ZnVuY3Rpb24gUU9lKCl7UU9lPUYsZTdlPXluKCh4TigpLFAoSShUSiwxKSxXLDM5NCwwLFtDSix5TSxTSl0pKSl9dmFyIGU3ZTtmdW5jdGlvbiBiSigpe2JKPUYsczdlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnRyeWJveCIsKHplKCksITEpKSxKKC0xKSxyN2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcuY3VycmVudFBvc2l0aW9uIixKKC0xKSksSigtMSksdDdlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLmRlc2lyZWRQb3NpdGlvbiIsSigtMSkpLG83ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5pbk5ld1JvdyIsITEpLFBKPShOTigpLElNKSxkN2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2lkdGhBcHByb3hpbWF0aW9uLnN0cmF0ZWd5IixQSiksZjdlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLndpZHRoQXBwcm94aW1hdGlvbi50YXJnZXRXaWR0aCIsLTEpLHhKPSh4TigpLHlNKSxfN2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2lkdGhBcHByb3hpbWF0aW9uLm9wdGltaXphdGlvbkdvYWwiLHhKKSxjN2U9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2lkdGhBcHByb3hpbWF0aW9uLmxhc3RQbGFjZVNoaWZ0IiwhMCksSUo9KEFOKCksUE0pLGw3ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5wYWNraW5nLnN0cmF0ZWd5IixJSiksYTdlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnBhY2tpbmcuY29tcGFjdGlvbi5yb3dIZWlnaHRSZWV2YWx1YXRpb24iLCExKSxKKDEpLGk3ZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5wYWNraW5nLmNvbXBhY3Rpb24uaXRlcmF0aW9ucyIsSigxKSksdTdlPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLndoaXRlU3BhY2VFbGltaW5hdGlvbi5zdHJhdGVneSIpfWZ1bmN0aW9uIG43ZSgpe2JKKCl9cCg4NjcsMSxwbCxuN2UpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy50cnlib3giKSwiIiksIlRyeSBib3ggbGF5b3V0IGZpcnN0IiksIldoZXRoZXIgb25lIHNob3VsZCBjaGVjayB3aGV0aGVyIHRoZSByZWdpb25zIGFyZSBzdGFja2FibGUgdG8gc2VlIHdoZXRoZXIgYm94IGxheW91dCB3b3VsZCBkbyB0aGUgam9iLiBGb3IgZXhhbXBsZSwgbm9kZXMgd2l0aCB0aGUgc2FtZSBoZWlnaHQgYXJlIG5vdCBzdGFja2FibGUgaW5zaWRlIGEgcm93LiBUaGVyZWZvcmUsIGJveCBsYXlvdXQgd2lsbCBwZXJmb3JtIGJldHRlciBhbmQgZmFzdGVyLiIpLCh6ZSgpLCExKSksKEpjKCksbnQpKSxBciksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5jdXJyZW50UG9zaXRpb24iKSwiIiksIkN1cnJlbnQgcG9zaXRpb24gb2YgYSBub2RlIGluIHRoZSBvcmRlciBvZiBub2RlcyIpLCJUaGUgcmVjdGFuZ2xlcyBhcmUgb3JkZXJlZC4gTm9ybWFsbHkgYWNjb3JkaW5nIHRvIHRoZWlyIGRlZmluaXRpb24gdGhlIHRoZSBtb2RlbC4gVGhpcyBvcHRpb24gc3BlY2lmaWVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIGEgbm9kZS4iKSxKKC0xKSksYm8pLHZ0KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcuZGVzaXJlZFBvc2l0aW9uIiksIiIpLCJEZXNpcmVkIGluZGV4IG9mIG5vZGUiKSwiVGhlIHJlY3RhbmdsZXMgYXJlIG9yZGVyZWQuIE5vcm1hbGx5IGFjY29yZGluZyB0byB0aGVpciBkZWZpbml0aW9uIHRoZSB0aGUgbW9kZWwuIFRoaXMgb3B0aW9uIGFsbG93cyB0byBzcGVjaWZ5IGEgZGVzaXJlZCBwb3NpdGlvbiB0aGF0IGhhcyBwcmVmZXJlbmNlIG92ZXIgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLiIpLEooLTEpKSxibyksdnQpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5pbk5ld1JvdyIpLCIiKSwiSW4gbmV3IFJvdyIpLCJJZiBzZXQgdG8gdHJ1ZSB0aGlzIG5vZGUgYmVnaW5zIGluIGEgbmV3IHJvdy4gQ29uc2VxdWVudGx5IHRoaXMgbm9kZSBjYW5ub3QgYmUgbW92ZWQgaW4gYSBwcmV2aW91cyBsYXllciBkdXJpbmcgY29tcGFjdGlvbi4gV2lkdGggYXBwcm94aW1hdGlvbiBkb2VzIGRvZXMgbm90IHRha2UgdGhpcyBpbnRvIGFjY291bnQuIiksITEpLG50KSxBciksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLndpZHRoQXBwcm94aW1hdGlvbi5zdHJhdGVneSIpLCJ3aWR0aEFwcHJveGltYXRpb24iKSwiV2lkdGggQXBwcm94aW1hdGlvbiBTdHJhdGVneSIpLCJTdHJhdGVneSBmb3IgZmluZGluZyBhbiBpbml0aWFsIHdpZHRoIG9mIHRoZSBkcmF3aW5nLiIpLFBKKSxtciksSEopLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy53aWR0aEFwcHJveGltYXRpb24udGFyZ2V0V2lkdGgiKSwid2lkdGhBcHByb3hpbWF0aW9uIiksIlRhcmdldCBXaWR0aCIpLCJPcHRpb24gdG8gcGxhY2UgdGhlIHJlY3RhbmdsZXMgaW4gdGhlIGdpdmVuIHRhcmdldCB3aWR0aCBpbnN0ZWFkIG9mIGFwcHJveGltYXRpbmcgdGhlIHdpZHRoIHVzaW5nIHRoZSBkZXNpcmVkIGFzcGVjdCByYXRpby4gVGhlIHBhZGRpbmcgaXMgbm90IGluY2x1ZGVkIGluIHRoaXMuIE1lYW5pbmcgYSBkcmF3aW5nIHdpbGwgaGF2ZSB3aWR0aCBvZiB0YXJnZXR3aWR0aCArIGhvcml6b250YWwgcGFkZGluZy4iKSwtMSksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2lkdGhBcHByb3hpbWF0aW9uLm9wdGltaXphdGlvbkdvYWwiKSwid2lkdGhBcHByb3hpbWF0aW9uIiksIk9wdGltaXphdGlvbiBHb2FsIiksIk9wdGltaXphdGlvbiBnb2FsIGZvciBhcHByb3hpbWF0aW9uIG9mIHRoZSBib3VuZGluZyBib3ggZ2l2ZW4gYnkgdGhlIGZpcnN0IGl0ZXJhdGlvbi4gRGV0ZXJtaW5lcyB3aGV0aGVyIGxheW91dCBpcyBzb3J0ZWQgYnkgdGhlIG1heGltdW0gc2NhbGluZywgYXNwZWN0IHJhdGlvLCBvciBhcmVhLiBEZXBlbmRpbmcgb24gdGhlIHN0cmF0ZWd5IHRoZSBhc3BlY3QgcmF0aW8gbWlnaHQgYmUgbmVhcmx5IGlnbm9yZWQuIikseEopLG1yKSxUSiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLndpZHRoQXBwcm94aW1hdGlvbi5sYXN0UGxhY2VTaGlmdCIpLCJ3aWR0aEFwcHJveGltYXRpb24iKSwiU2hpZnQgTGFzdCBQbGFjZWQuIiksIldoZW4gcGxhY2luZyBhIHJlY3RhbmdsZSBiZWhpbmQgb3IgYmVsb3cgdGhlIGxhc3QgcGxhY2VkIHJlY3RhbmdsZSBpbiB0aGUgZmlyc3QgaXRlcmF0aW9uLCBpdCBpcyBzb21ldGltZXMgcG9zc2libGUgdG8gc2hpZnQgdGhlIHJlY3RhbmdsZSBmdXJ0aGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LCByZXN1bHRpbmcgaW4gbGVzcyB3aGl0ZXNwYWNlLiBUcnVlIChkZWZhdWx0KSBlbmFibGVzIHRoZSBzaGlmdCBhbmQgZmFsc2UgZGlzYWJsZXMgaXQuIERpc2FibGluZyB0aGUgc2hpZnQgcHJvZHVjZXMgYSBncmVhdGVyIGFwcHJveGltYXRlZCBhcmVhIGJ5IHRoZSBmaXJzdCBpdGVyYXRpb24gYW5kIGEgbGF5b3V0LCB3aGVuIHVzaW5nIE9OTFkgdGhlIGZpcnN0IGl0ZXJhdGlvbiAoZGVmYXVsdCBub3QgdGhlIGNhc2UpLCB3aGVyZSBpdCBpcyBzb21ldGltZXMgaW1wb3NzaWJsZSB0byBpbXBsZW1lbnQgYSBzaXplIHRyYW5zZm9ybWF0aW9uIG9mIHJlY3RhbmdsZXMgdGhhdCB3aWxsIGZpbGwgdGhlIGJvdW5kaW5nIGJveCBhbmQgZWxpbWluYXRlIGVtcHR5IHNwYWNlcy4iKSwhMCksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcucGFja2luZy5zdHJhdGVneSIpLCJwYWNraW5nIiksIkNvbXBhY3Rpb24gU3RyYXRlZ3kiKSwiU3RyYXRlZ3kgZm9yIGZpbmRpbmcgYW4gaW5pdGlhbCBwbGFjZW1lbnQgb24gbm9kZXMuIiksSUopLG1yKSxWSiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnBhY2tpbmcuY29tcGFjdGlvbi5yb3dIZWlnaHRSZWV2YWx1YXRpb24iKSwicGFja2luZy5jb21wYWN0aW9uIiksIlJvdyBIZWlnaHQgUmVldmFsdWF0aW9uIiksIkR1cmluZyB0aGUgY29tcGFjdGlvbiBzdGVwIHRoZSBoZWlnaHQgb2YgYSByb3cgaXMgbm9ybWFsbHkgbm90IGNoYW5nZWQuIElmIHRoaXMgb3B0aW9ucyBpcyBzZXQsIHRoZSBibG9ja3Mgb2Ygb3RoZXIgcm93cyBtaWdodCBiZSBhZGRlZCBpZiB0aGV5IGV4Y2VlZCB0aGUgcm93IGhlaWdodC4gSWYgdGhpcyBpcyB0aGUgY2FzZSB0aGUgd2hvbGUgcm93IGhhcyB0byBiZSBwYWNrZWQgYWdhaW4gdG8gYmUgb3B0aW1hbCByZWdhcmRpbmcgdGhlIG5ldyByb3cgaGVpZ2h0LiBUaGlzIG9wdGlvbiBzaG91bGQsIHRoZXJlZm9yZSwgYmUgdXNlZCB3aXRoIGNhcmUgc2luY2UgaXQgbWlnaHQgYmUgY29tcHV0YXRpb24gaGVhdnkuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnBhY2tpbmcuY29tcGFjdGlvbi5pdGVyYXRpb25zIiksInBhY2tpbmcuY29tcGFjdGlvbiIpLCJDb21wYWN0aW9uIGl0ZXJhdGlvbnMiKSwiRGVmaW5lcyB0aGUgbnVtYmVyIG9mIGNvbXBhY3Rpb24gaXRlcmF0aW9ucy4gRS5nLiBpZiBzZXQgdG8gMiB0aGUgd2lkdGggaXMgaW5pdGlhbGx5IGFwcHJveGltYXRlZCwgdGhlbiB0aGUgZHJhd2luZyBpcyBjb21wYWN0ZWQgYW5kIGJhc2VkIG9uIHRoZSByZXN1bHRpbmcgZHJhd2luZyB0aGUgdGFyZ2V0IHdpZHRoIGlzIGRlY3JlYXNlZCBvciBpbmNyZWFzZWQgYW5kIGEgc2Vjb25kIGNvbXBhY3Rpb24gc3RlcCBpcyBleGVjdXRlZCBhbmQgdGhlIHJlc3VsdCBjb21wYXJlZCB0byB0aGUgZmlyc3Qgb25lLiBUaGUgYmVzdCBydW4gaXMgdXNlZCBiYXNlZCBvbiB0aGUgc2NhbGUgbWVhc3VyZS4iKSxKKDEpKSxibyksdnQpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy53aGl0ZVNwYWNlRWxpbWluYXRpb24uc3RyYXRlZ3kiKSwid2hpdGVTcGFjZUVsaW1pbmF0aW9uIiksIldoaXRlIFNwYWNlIEFwcHJveGltYXRpb24gU3RyYXRlZ3kiKSwiU3RyYXRlZ3kgZm9yIGV4cGFuZGluZyBub2RlcyBzdWNoIHRoYXQgd2hpdGVzcGFjZSBpbiB0aGUgcGFyZW50IGlzIGVsaW1pbmF0ZWQuIiksbXIpLEpKKSxFZShPZSkpKSkscDdlKChuZXcgZzdlLG4pKX07dmFyIHI3ZSx0N2UsbzdlLGk3ZSxhN2UsbDdlLElKLHM3ZSx1N2UsYzdlLF83ZSx4SixkN2UsUEosZjdlO2coIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcub3B0aW9ucyIsIlJlY3RQYWNraW5nTWV0YURhdGFQcm92aWRlciIsODY3KTtmdW5jdGlvbiBGcygpe0ZzPUYsUE49bmV3IHl0KChGbigpLFNnKSwxLjMpLEU3ZT1uZXcgeXQoV2YsKHplKCksITEpKSxPSj1uZXcgVzEoMTUpLEN2PW5ldyB5dChaYyxPSiksVHY9bmV3IHl0KHQxLDE1KSxoN2U9SVQsdzdlPXIxLHY3ZT14ZyxTN2U9VzAseTdlPUlnLHdNPUFULEM3ZT1qZixGSj0oYkooKSxfN2UpLERKPWM3ZSx2TT1mN2Useko9ZDdlLGtKPWw3ZSxFTT1hN2UsTEo9aTdlLFJKPXU3ZSxBSj1OVCxtN2U9YVIsaVQ9dDdlLE5KPXI3ZSxhVD1vN2UsTUo9czdlfWZ1bmN0aW9uIHA3ZShlKXtoZChlLG5ldyBKXyhnZChkZChwZChmZChuZXcgWl8sIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIpLCJFTEsgUmVjdGFuZ2xlIFBhY2tpbmciKSwiQWxnb3JpdGhtIGZvciBwYWNraW5nIG9mIHVuY29ubmVjdGVkIGJveGVzLCBpLmUuIGdyYXBocyB3aXRob3V0IGVkZ2VzLiBUaGUgZ2l2ZW4gb3JkZXIgb2YgdGhlIGJveGVzIGlzIGFsd2F5cyBwcmVzZXJ2ZWQgYW5kIHRoZSBtYWluIHJlYWRpbmcgZGlyZWN0aW9uIG9mIHRoZSBib3hlcyBpcyBsZWZ0IHRvIHJpZ2h0LiBUaGUgYWxnb3JpdGhtIGlzIGRpdmlkZWQgaW50byB0d28gcGhhc2VzLiBPbmUgcGhhc2UgYXBwcm94aW1hdGVzIHRoZSB3aWR0aCBpbiB3aGljaCB0aGUgcmVjdGFuZ2xlcyBjYW4gYmUgcGxhY2VkLiBUaGUgbmV4dCBwaGFzZSBwbGFjZXMgdGhlIHJlY3RhbmdsZXMgaW4gcm93cyB1c2luZyB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIHdpZHRoIGFzIGJvdW5kaW5nIHdpZHRoIGFuZCBidW5kbGVzIHJlY3RhbmdsZXMgd2l0aCBhIHNpbWlsYXIgaGVpZ2h0IGluIGJsb2Nrcy4gQSBjb21wYWN0aW9uIHN0ZXAgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgZHJhd2luZy4gRmluYWxseSwgdGhlIHJlY3RhbmdsZXMgYXJlIGV4cGFuZGVkIHRvIGZpbGwgdGhlaXIgYm91bmRpbmcgYm94IGFuZCBlbGltaW5hdGUgZW1wdHkgdW51c2VkIHNwYWNlcy4iKSxuZXcgVDdlKSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLmFzcGVjdFJhdGlvIiwxLjMpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmZpeGVkR3JhcGhTaXplIiwoemUoKSwhMSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnBhZGRpbmciLE9KKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLm5vZGVOb2RlIiwxNSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsuY29udGVudEFsaWdubWVudCIsdGUoaDdlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuY29uc3RyYWludHMiLHRlKHc3ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm1pbmltdW0iLHRlKHY3ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm9wdGlvbnMiLHRlKFM3ZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVMYWJlbHMucGxhY2VtZW50Iix0ZSh5N2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5vbWl0Tm9kZU1pY3JvTGF5b3V0Iix0ZSh3TSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMucGxhY2VtZW50Iix0ZShDN2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy53aWR0aEFwcHJveGltYXRpb24ub3B0aW1pemF0aW9uR29hbCIsdGUoRkopKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy53aWR0aEFwcHJveGltYXRpb24ubGFzdFBsYWNlU2hpZnQiLHRlKERKKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2lkdGhBcHByb3hpbWF0aW9uLnRhcmdldFdpZHRoIix0ZSh2TSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLndpZHRoQXBwcm94aW1hdGlvbi5zdHJhdGVneSIsdGUoekopKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5wYWNraW5nLnN0cmF0ZWd5Iix0ZShrSikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnBhY2tpbmcuY29tcGFjdGlvbi5yb3dIZWlnaHRSZWV2YWx1YXRpb24iLHRlKEVNKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcucGFja2luZy5jb21wYWN0aW9uLml0ZXJhdGlvbnMiLHRlKExKKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcud2hpdGVTcGFjZUVsaW1pbmF0aW9uLnN0cmF0ZWd5Iix0ZShSSikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLmludGVyYWN0aXZlIix0ZShBSikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLmludGVyYWN0aXZlTGF5b3V0Iix0ZShtN2UpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZyIsIm9yZy5lY2xpcHNlLmVsay5yZWN0cGFja2luZy5kZXNpcmVkUG9zaXRpb24iLHRlKGlUKSksWihlLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmciLCJvcmcuZWNsaXBzZS5lbGsucmVjdHBhY2tpbmcuY3VycmVudFBvc2l0aW9uIix0ZShOSikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLmluTmV3Um93Iix0ZShhVCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nIiwib3JnLmVjbGlwc2UuZWxrLnJlY3RwYWNraW5nLnRyeWJveCIsdGUoTUopKX1mdW5jdGlvbiBnN2UoKXtGcygpfXAoMTAxNiwxLHBsLGc3ZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe3A3ZShuKX07dmFyIFBOLGg3ZSxOSixpVCxBSixtN2UsYVQseTdlLHc3ZSxFN2UsdjdlLFM3ZSx3TSxMSixFTSxrSixDdixPSixDN2UsVHYsTUosUkosREosRkosekosdk07Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5vcHRpb25zIiwiUmVjdFBhY2tpbmdPcHRpb25zIiwxMDE2KTtmdW5jdGlvbiBUN2UoKXt9cCgxMDE3LDEse30sVDdlKSxsLmNyZWF0ZV8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IFVPZSxufSxsLmRlc3Ryb3k9ZnVuY3Rpb24obil7fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLm9wdGlvbnMiLCJSZWN0UGFja2luZ09wdGlvbnMvUmVjdHBhY2tpbmdGYWN0b3J5IiwxMDE3KTtmdW5jdGlvbiBNeW4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3Iocz1hKE8obiwwKSwyNyksQ2kocywwKSxUaShzLDApLGg9bmV3IFEsUmUoaC5hcnJheSxzKSx1PXMsaT1uZXcgdFooZS5hc3BlY3RSYXRpbyxzLndpZHRoXzAscy5oZWlnaHQsKEl2KCksY1QpKSxtPTE7bTxuLnNpemVfMDttKyspeT1hKE8obixtKSwyNyksYz1TTShlLG1nLHksdSxpLGgsciksXz1TTShlLFpoLHksdSxpLGgsciksZD1TTShlLFB2LHksdSxpLGgsciksZj1TTShlLHh2LHksdSxpLGgsciksbz1EeW4oZSxjLF8sZCxmLHksdSx0KSxDaSh5LG8ubmV4dFhjb29yZGluYXRlKSxUaSh5LG8ubmV4dFljb29yZGluYXRlKSxod24obyxjVCksaT1vLHU9eSxSZShoLmFycmF5LHkpO3JldHVybiBpfWZ1bmN0aW9uIFNNKGUsbixyLHQsbyxpLHMpe3ZhciB1LGMsXyxkLGYsaCxtLHksRTtzd2l0Y2goeT0wLEU9MCxjPW8uZHJhd2luZ1dpZHRoLHU9by5kcmF3aW5nSGVpZ2h0LGQ9ci5oZWlnaHQsbT1yLndpZHRoXzAsbi5vcmRpbmFsKXtjYXNlIDA6eT10LnhfMCt0LndpZHRoXzArcyxlLmxwU2hpZnQ/RT16eW4oeSxpLHQscyk6RT10LnlfMCxoPVMuTWF0aC5tYXgoYyx5K20pLF89Uy5NYXRoLm1heCh1LEUrZCk7YnJlYWs7Y2FzZSAxOkU9dC55XzArdC5oZWlnaHQrcyxlLmxwU2hpZnQ/eT1GeW4oRSxpLHQscyk6eT10LnhfMCxoPVMuTWF0aC5tYXgoYyx5K20pLF89Uy5NYXRoLm1heCh1LEUrZCk7YnJlYWs7Y2FzZSAyOnk9YytzLEU9MCxoPWMrcyttLF89Uy5NYXRoLm1heCh1LGQpO2JyZWFrO2Nhc2UgMzp5PTAsRT11K3MsaD1TLk1hdGgubWF4KGMsbSksXz11K3MrZDticmVhaztkZWZhdWx0OnRocm93IGIobmV3IEdlKCJJbGxlZ2FsUGxhY2VtZW50T3B0aW9uLiIpKX1yZXR1cm4gZj1uZXcgb1ooZS5hc3BlY3RSYXRpbyxoLF8sbix5LEUpLGZ9ZnVuY3Rpb24gUnluKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlO3JldHVybiBzPWUucGxhY2VtZW50T3B0aW9uLGg9bi5wbGFjZW1lbnRPcHRpb24sdT1zPT0oSXYoKSxaaCl8fHM9PXh2LG09aD09Wmh8fGg9PXh2LGM9cz09bWd8fHM9PVB2LHk9aD09bWd8fGg9PVB2LF89cz09bWd8fHM9PVpoLEU9aD09bWd8fGg9PVpoLHUmJm0/ZS5wbGFjZW1lbnRPcHRpb249PXh2P2U6bjpjJiZ5P2UucGxhY2VtZW50T3B0aW9uPT1Qdj9lOm46XyYmRT8ocz09bWc/KGY9ZSxkPW4pOihmPW4sZD1lKSxpPSh2PXIueV8wK3IuaGVpZ2h0LHg9Zi5uZXh0WWNvb3JkaW5hdGUrdC5oZWlnaHQsQT1TLk1hdGgubWF4KHYseCksaz1BLVMuTWF0aC5taW4oci55XzAsZi5uZXh0WWNvb3JkaW5hdGUpLE09Zi5uZXh0WGNvb3JkaW5hdGUrdC53aWR0aF8wLXIueF8wLE0qayksbz0oSD1yLnhfMCtyLndpZHRoXzAscT1kLm5leHRYY29vcmRpbmF0ZSt0LndpZHRoXzAsbmU9Uy5NYXRoLm1heChILHEpLHZlPW5lLVMuTWF0aC5taW4oci54XzAsZC5uZXh0WGNvb3JkaW5hdGUpLHdlPWQubmV4dFljb29yZGluYXRlK3QuaGVpZ2h0LXIueV8wLHZlKndlKSxpPD1vP2UucGxhY2VtZW50T3B0aW9uPT1tZz9lOm46ZS5wbGFjZW1lbnRPcHRpb249PVpoP2U6bik6ZX1mdW5jdGlvbiBEeW4oZSxuLHIsdCxvLGkscyx1KXt2YXIgYyxfLGQsZjtzd2l0Y2goYz1UcyhQKEkobXduLDEpLE1lLDIzOCwwLFtuLHIsdCxvXSkpLGY9bnVsbCxlLmdvYWwub3JkaW5hbCl7Y2FzZSAxOmY9VHMoUChJKCRKLDEpLE1lLDUzNSwwLFtuZXcgYk0sbmV3IENNLG5ldyBUTV0pKTticmVhaztjYXNlIDA6Zj1UcyhQKEkoJEosMSksTWUsNTM1LDAsW25ldyBUTSxuZXcgQ00sbmV3IGJNXSkpO2JyZWFrO2Nhc2UgMjpmPVRzKFAoSSgkSiwxKSxNZSw1MzUsMCxbbmV3IENNLG5ldyBiTSxuZXcgVE1dKSl9Zm9yKGQ9bmV3IFQoZik7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDUzNSksYy5hcnJheS5sZW5ndGg+MSYmKGM9Xy5maWx0ZXJMaXN0KGMsZS5hc3BlY3RSYXRpbyx1KSk7cmV0dXJuIGMuYXJyYXkubGVuZ3RoPT0xP2EobGUoYyxjLmFycmF5Lmxlbmd0aC0xKSwyMzgpOmMuYXJyYXkubGVuZ3RoPT0yP1J5bigoQWUoMCxjLmFycmF5Lmxlbmd0aCksYShjLmFycmF5WzBdLDIzOCkpLChBZSgxLGMuYXJyYXkubGVuZ3RoKSxhKGMuYXJyYXlbMV0sMjM4KSkscyxpKTpudWxsfWZ1bmN0aW9uIGI3ZShlLG4scil7dGhpcy5hc3BlY3RSYXRpbz1lLHRoaXMuZ29hbD1uLHRoaXMubHBTaGlmdD1yfXAoMTcwNSwxLHt9LGI3ZSksbC5hc3BlY3RSYXRpbz0wLGwubHBTaGlmdD0hMSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAxd2lkdGhhcHByb3hpbWF0aW9uIiwiQXJlYUFwcHJveGltYXRpb24iLDE3MDUpO3ZhciAkSj1Dcigib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wMXdpZHRoYXBwcm94aW1hdGlvbiIsIkJlc3RDYW5kaWRhdGVGaWx0ZXIiKTtmdW5jdGlvbiBDTSgpe31wKDY3MywxLHs1MzU6MX0sQ00pLGwuZmlsdGVyTGlzdD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2ZvcihfPW5ldyBRLHM9aHIsYz1uZXcgVChuKTtjLmk8Yy50aGlzJDAxLmFycmF5Lmxlbmd0aDspdT1hKEMoYyksMjM4KSxzPVMuTWF0aC5taW4ocywodS5kcmF3aW5nV2lkdGgrKHQubGVmdCt0LnJpZ2h0KSkqKHUuZHJhd2luZ0hlaWdodCsodC50b3BfMCt0LmJvdHRvbSkpKTtmb3IoaT1uZXcgVChuKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMjM4KSwoby5kcmF3aW5nV2lkdGgrKHQubGVmdCt0LnJpZ2h0KSkqKG8uZHJhd2luZ0hlaWdodCsodC50b3BfMCt0LmJvdHRvbSkpPT1zJiZSZShfLmFycmF5LG8pO3JldHVybiBffSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAxd2lkdGhhcHByb3hpbWF0aW9uIiwiQXJlYUZpbHRlciIsNjczKTtmdW5jdGlvbiBUTSgpe31wKDY3NCwxLHs1MzU6MX0sVE0pLGwuZmlsdGVyTGlzdD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2ZvcihjPW5ldyBRLF89aHIsdT1uZXcgVChuKTt1Lmk8dS50aGlzJDAxLmFycmF5Lmxlbmd0aDspcz1hKEModSksMjM4KSxfPVMuTWF0aC5taW4oXyxTLk1hdGguYWJzKChzLmRyYXdpbmdXaWR0aCsodC5sZWZ0K3QucmlnaHQpKS8ocy5kcmF3aW5nSGVpZ2h0Kyh0LnRvcF8wK3QuYm90dG9tKSktcikpO2ZvcihpPW5ldyBUKG4pO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwyMzgpLFMuTWF0aC5hYnMoKG8uZHJhd2luZ1dpZHRoKyh0LmxlZnQrdC5yaWdodCkpLyhvLmRyYXdpbmdIZWlnaHQrKHQudG9wXzArdC5ib3R0b20pKS1yKT09XyYmUmUoYy5hcnJheSxvKTtyZXR1cm4gY30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wMXdpZHRoYXBwcm94aW1hdGlvbiIsIkFzcGVjdFJhdGlvRmlsdGVyIiw2NzQpO2Z1bmN0aW9uIEZ5bihlLG4scix0KXt2YXIgbyxpLHMsdSxjO2ZvcihvPW51bGwsaT0wLHU9bmV3IFQobik7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDI3KSxjPXMueF8wK3Mud2lkdGhfMCxlPHMueV8wK3MuaGVpZ2h0K3QmJihvP3IueF8wLWM8ci54XzAtaSYmKG89cyk6bz1zLGk9by54XzArby53aWR0aF8wKTtyZXR1cm4gbz9pK3Q6MH1mdW5jdGlvbiB6eW4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYztmb3IoaT1udWxsLG89MCx1PW5ldyBUKG4pO3UuaTx1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylzPWEoQyh1KSwyNyksYz1zLnlfMCtzLmhlaWdodCxlPHMueF8wK3Mud2lkdGhfMCt0JiYoaT9yLnlfMC1jPHIueV8wLW8mJihpPXMpOmk9cyxvPWkueV8wK2kuaGVpZ2h0KTtyZXR1cm4gaT9vK3Q6MH1mdW5jdGlvbiAkeW4oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO24uYmVnaW4oIkdyZWVkeSBXaWR0aCBBcHByb3hpbWF0b3IiLDEpLHI9UigkKFYoZSwoRnMoKSxQTikpKSksYz1hKFYoZSxDdiksMTA3KSxpPWEoVihlLEZKKSwzOTQpLHM9YWUoaWUoVihlLERKKSkpLHU9UigkKFYoZSxUdikpKSxfPSghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pLGlaKF8pLG89bmV3IGI3ZShyLGkscyksdD1NeW4obyxfLHUsYyksbnIoZSwoRnUoKSxIZiksdC5kcmF3aW5nV2lkdGgpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gSTdlKCl7fXAoMTQ2OSwxLFd0LEk3ZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMjcpLG51bGx9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpeyR5bihhKG4sMjcpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAxd2lkdGhhcHByb3hpbWF0aW9uIiwiR3JlZWR5V2lkdGhBcHByb3hpbWF0b3IiLDE0NjkpO2Z1bmN0aW9uIGJNKCl7fXAoNjcyLDEsezUzNToxfSxiTSksbC5maWx0ZXJMaXN0PWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHMsdSxjLF87Zm9yKF89bmV3IFEscz1WcixjPW5ldyBUKG4pO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwyMzgpLHM9Uy5NYXRoLm1heChzLE9OKHUuZHJhd2luZ1dpZHRoKyh0LmxlZnQrdC5yaWdodCksdS5kcmF3aW5nSGVpZ2h0Kyh0LnRvcF8wK3QuYm90dG9tKSx1LmRhcikpO2ZvcihpPW5ldyBUKG4pO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwyMzgpLE9OKG8uZHJhd2luZ1dpZHRoKyh0LmxlZnQrdC5yaWdodCksby5kcmF3aW5nSGVpZ2h0Kyh0LnRvcF8wK3QuYm90dG9tKSxvLmRhcik9PXMmJlJlKF8uYXJyYXksbyk7cmV0dXJuIF99LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcucDF3aWR0aGFwcHJveGltYXRpb24iLCJTY2FsZU1lYXN1cmVGaWx0ZXIiLDY3Mik7ZnVuY3Rpb24gQnluKGUsbil7aWYobi5iZWdpbigiVGFyZ2V0IFdpZHRoIFNldHRlciIsMSksV3MoZSwoRnMoKSx2TSkpKW5yKGUsKEZ1KCksSGYpLCQoVihlLHZNKSkpO2Vsc2UgdGhyb3cgYihuZXcgS2MoIkEgdGFyZ2V0IHdpZHRoIGhhcyB0byBiZSBzZXQgaWYgdGhlIFRhcmdldFdpZHRoV2lkdGhBcHByb3hpbWF0b3Igc2hvdWxkIGJlIHVzZWQuIikpO24uZG9uZV8xKCl9ZnVuY3Rpb24geDdlKCl7fXAoMTQ3MCwxLFd0LHg3ZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMjcpLG51bGx9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe0J5bihhKG4sMjcpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAxd2lkdGhhcHByb3hpbWF0aW9uIiwiVGFyZ2V0V2lkdGhXaWR0aEFwcHJveGltYXRvciIsMTQ3MCk7ZnVuY3Rpb24gTk4oKXtOTj1GLElNPW5ldyBCSigiR1JFRURZIiwwKSxHSj1uZXcgQkooIlRBUkdFVF9XSURUSCIsMSl9ZnVuY3Rpb24gUDdlKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMDpyZXR1cm4gbmV3IEk3ZTtjYXNlIDE6cmV0dXJuIG5ldyB4N2U7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gaXMgYXZhaWxhYmxlIGZvciB0aGUgd2lkdGggYXBwcm94aW1hdG9yICIrKGUubmFtZV8wIT1udWxsP2UubmFtZV8wOiIiK2Uub3JkaW5hbCkpKX19ZnVuY3Rpb24gQkooZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBHeW4oZSl7cmV0dXJuIE5OKCksd24oKE43ZSgpLEE3ZSksZSl9ZnVuY3Rpb24gSHluKCl7cmV0dXJuIE5OKCksUChJKEhKLDEpLFcsNDkxLDAsW0lNLEdKXSl9cCg0OTEsMjIsezM6MSwzNDoxLDIyOjEsNDkxOjEsMTg4OjEsMTk2OjF9LEJKKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFA3ZSh0aGlzKX0sbC5jcmVhdGVfMj1mdW5jdGlvbigpe3JldHVybiBQN2UodGhpcyl9O3ZhciBJTSxHSixISj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wMXdpZHRoYXBwcm94aW1hdGlvbiIsIldpZHRoQXBwcm94aW1hdGlvblN0cmF0ZWd5Iiw0OTEsZ24sSHluLEd5bik7ZnVuY3Rpb24gTjdlKCl7TjdlPUYsQTdlPXluKChOTigpLFAoSShISiwxKSxXLDQ5MSwwLFtJTSxHSl0pKSl9dmFyIEE3ZTtmdW5jdGlvbiBVeW4oZSxuLHIsdCxvKXt2YXIgaSxzO2ZvcihzPSExLGk9YShsZShyLmNoaWxkcmVuLDApLDI3KTtLeW4oZSxuLGksdCxvKSYmKHM9ITAsbHduKHIsaSksci5jaGlsZHJlbi5hcnJheS5sZW5ndGghPTApOylpPWEobGUoci5jaGlsZHJlbiwwKSwyNyk7cmV0dXJuIHIuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0wJiZfVChyLnBhcmVudFJvdyxyKSxzJiZrTihuLnN0YWNrXzApLHN9ZnVuY3Rpb24gV3luKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7Zm9yKEU9ITEsYz0hMSxoPWUrMSx5PShBZShlLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbZV0sMTg2KSksdT15LmNoaWxkcmVuLF89bnVsbCxzPTA7czx5LmNoaWxkcmVuLmFycmF5Lmxlbmd0aDtzKyspaWYoaT0oQWUocyx1LmFycmF5Lmxlbmd0aCksYSh1LmFycmF5W3NdLDE3MikpLCFpLmZpeGVkXzApe2lmKGkuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0wKXtuYygpLF9UKHksaSksLS1zLEU9ITA7Y29udGludWV9aWYoaS5wb3NpdGlvbkZpeGVkfHwoXyYma04oXyksXz1uZXcgclooXz9fLnhfMCtfLndpZHRoXzArdDowLHkueV8wLHQpLHNUKGksXy54XzArXy53aWR0aF8wLHkueV8wKSxlZSh5LnN0YWNrcyxfKSxlWihfLGkpLGkucG9zaXRpb25GaXhlZD0hMCksZD1udWxsLGQ9KHg9bnVsbCxzPHkuY2hpbGRyZW4uYXJyYXkubGVuZ3RoLTE/eD1hKGxlKHkuY2hpbGRyZW4scysxKSwxNzIpOmg8bi5hcnJheS5sZW5ndGgmJihBZShoLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbaF0sMTg2KSkuY2hpbGRyZW4uYXJyYXkubGVuZ3RoIT0wJiYoeD1hKGxlKChBZShoLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbaF0sMTg2KSkuY2hpbGRyZW4sMCksMTcyKSkseCksdj0hMSxkJiYodj0hWW4oZC5wYXJlbnRSb3cseSkpLGQpe2lmKGQuY2hpbGRyZW4uYXJyYXkubGVuZ3RoIT0wJiYhYWUoaWUoYShsZShkLmNoaWxkcmVuLDApLDI3KS5nZXRQcm9wZXJ0eSgoRnMoKSxhVCkpKSkpbFQoaSxyLWkueF8wKSxrTihpLnN0YWNrXzApLEU9RXxVeW4oeSxpLGQscix0KTtlbHNle19UKHksZCk7YnJlYWt9aWYoZC5jaGlsZHJlbi5hcnJheS5sZW5ndGg9PTApZm9yKG4uYXJyYXkubGVuZ3RoPmgmJl9UKChBZShoLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbaF0sMTg2KSksZCksZD1udWxsO24uYXJyYXkubGVuZ3RoPmgmJihBZShoLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbaF0sMTg2KSkuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0wOylQaShuLChBZShoLG4uYXJyYXkubGVuZ3RoKSxuLmFycmF5W2hdKSk7aWYoIWQpey0tcztjb250aW51ZX1pZighYWUoaWUoYShsZShkLmNoaWxkcmVuLDApLDI3KS5nZXRQcm9wZXJ0eSgoRnMoKSxhVCkpKSkmJmp5bihuLHksaSxkLHYscixoLHQpKXtFPSEwO2NvbnRpbnVlfWlmKHYpe2lmKG09eS5oZWlnaHQsZj1kLm1pbkhlaWdodCwhYWUoaWUoYShsZShkLmNoaWxkcmVuLDApLDI3KS5nZXRQcm9wZXJ0eShhVCkpKSYmVnluKG4seSxpLGQscixoLHQsbykpe2lmKEU9ITAsbTxmKXtjPSEwLGQucGFyZW50Um93PXk7YnJlYWt9Y29udGludWV9ZWxzZSBpZihVSih5LGkpKXtpLmZpeGVkXzA9ITAsRT0hMDtjb250aW51ZX19ZWxzZSBpZihVSih5LGkpKXtpLmZpeGVkXzA9ITAsRT0hMDtjb250aW51ZX1pZihFKWNvbnRpbnVlfWlmKFVKKHksaSkpe2kuZml4ZWRfMD0hMCxFPSEwLGQmJihkLnBvc2l0aW9uRml4ZWQ9ITEpO2NvbnRpbnVlfWVsc2Uga04oaS5zdGFja18wKX1yZXR1cm4gbmV3IFpyKCh6ZSgpLCEhRSksISFjKX1mdW5jdGlvbiBqeW4oZSxuLHIsdCxvLGkscyx1KXt2YXIgYyxfLGQsZixoLG07cmV0dXJuIG09ITEsaD1pLXIueF8wLGQ9ci55XzAtbi55XzArKF89YnYocixoLCExKSxfLmhlaWdodCksdC5taW5XaWR0aCt1Pmg/ITE6KGY9KGM9YnYodCxoLCExKSxjLmhlaWdodCksZCt1K2Y8PW4uaGVpZ2h0JiYobFQocixpLXIueF8wKSxyLmZpeGVkXzA9ITAsbFQodCxpLXIueF8wKSxzVCh0LHIueF8wLHIueV8wK3IuaGVpZ2h0K3UpLHQucG9zaXRpb25GaXhlZD0hMCxlWihyLnN0YWNrXzAsdCksbT0hMCxvJiYoTU4obix0KSx0LnBhcmVudFJvdz1uLGUuYXJyYXkubGVuZ3RoPnMmJihfVCgoQWUocyxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5W3NdLDE4NikpLHQpLChBZShzLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbc10sMTg2KSkuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0wJiZNYyhlLHMpKSkpLG0pfWZ1bmN0aW9uIFZ5bihlLG4scix0LG8saSxzLHUpe3ZhciBjLF8sZCxmLGgsbSx5LEUsdix4O2lmKHk9ITEsXz1uWihyLnN0YWNrXzAsbi55XzArbi5oZWlnaHQtci5zdGFja18wLnlfMCksbT10Lm1pbkhlaWdodD5uLmhlaWdodCYmdSx4PW8tKHIuc3RhY2tfMC54XzArXy1zKSxmPShjPWJ2KHQseCwhMSksYy5oZWlnaHQpLG0mJmY+dC5taW5IZWlnaHQpcmV0dXJuITE7aWYobSl7Zm9yKGg9MCx2PW5ldyBUKG4uc3RhY2tzKTt2Lmk8di50aGlzJDAxLmFycmF5Lmxlbmd0aDspRT1hKEModiksMzE1KSxoKz1uWihFLHQubWluSGVpZ2h0KStzO3g9by1ofXJldHVybiB4PHQubWluV2lkdGh8fChkPWk9PWUuYXJyYXkubGVuZ3RoLTEmJng+PShBZShpLGUuYXJyYXkubGVuZ3RoKSxhKGUuYXJyYXlbaV0sMTg2KSkud2lkdGhfMCwhbSYmZj5uLmhlaWdodCYmIWQpPyExOigoZHx8bXx8Zjw9bi5oZWlnaHQpJiYoZCYmZj5uLmhlaWdodD8oci5oZWlnaHQ9ZixsVChyLEs3ZShyLGYpKSk6KFg3ZShyLnN0YWNrXzAsXyksci5maXhlZF8wPSEwKSxsVCh0LG8tKHIueF8wK3Iud2lkdGhfMCkpLHNUKHQsci5zdGFja18wLnhfMCtyLnN0YWNrXzAud2lkdGhfMCxuLnlfMCksTU4obix0KSxlLmFycmF5Lmxlbmd0aD5pJiYoX1QoKEFlKGksZS5hcnJheS5sZW5ndGgpLGEoZS5hcnJheVtpXSwxODYpKSx0KSwoQWUoaSxlLmFycmF5Lmxlbmd0aCksYShlLmFycmF5W2ldLDE4NikpLmNoaWxkcmVuLmFycmF5Lmxlbmd0aD09MCYmTWMoZSxpKSkseT0hMCkseSl9ZnVuY3Rpb24gVUooZSxuKXt2YXIgcix0LG87cmV0dXJuIHQ9ITEscj1uLnN0YWNrXzAud2lkdGhfMCxuLmhlaWdodDxlLmhlaWdodCYmKG89bloobi5zdGFja18wLGUuaGVpZ2h0KSxuLnN0YWNrXzAud2lkdGhfMD5vJiYoWDdlKG4uc3RhY2tfMCxvKSx0PXIhPW4uc3RhY2tfMC53aWR0aF8wKSksdH1mdW5jdGlvbiBxeW4oZSl7dmFyIG4scix0LG8saSxzO2Zvcih0PShYMCgpLGk9bmV3IF9TLGkpLFpUKHQsZSkscj1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDI3KSxzPShvPW5ldyBfUyxvKSxXQShzLHQpLFJnKHMsbi53aWR0aF8wLG4uaGVpZ2h0KSxNdyhzLG4uaWRlbnRpZmllciksX2wocyxuLnhfMCxuLnlfMCkscG4oKCF0LmNoaWxkcmVuJiYodC5jaGlsZHJlbj1uZXcgVShVbix0LDEwLDExKSksdC5jaGlsZHJlbikscyksWlQocyxuKTtyZXR1cm4gdH1mdW5jdGlvbiBMN2UoZSxuLHIpe3ZhciB0O2ZvcihSZyhyLG4ud2lkdGhfMCxuLmhlaWdodCksX2wocixuLnhfMCxuLnlfMCksdD0wO3Q8KCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikuc2l6ZV8wO3QrKylMN2UoZSxhKE8oKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbiksdCksMjcpLGEoTygoIXIuY2hpbGRyZW4mJihyLmNoaWxkcmVuPW5ldyBVKFVuLHIsMTAsMTEpKSxyLmNoaWxkcmVuKSx0KSwyNykpfWZ1bmN0aW9uIGs3ZShlLG4pe25yKGUsKEZ1KCksaE0pLG4ucG90ZW50aWFsUm93V2lkdGhJbmNyZWFzZU1pbiksbnIoZSxaT2Usbi5wb3RlbnRpYWxSb3dXaWR0aEluY3JlYXNlTWF4KSxucihlLGdNLG4ucG90ZW50aWFsUm93V2lkdGhEZWNyZWFzZU1pbiksbnIoZSxKT2Usbi5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4KX1mdW5jdGlvbiBZeW4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2ZvcihyLmJlZ2luKCJDb21wYWN0aW9uIiwxKSwhbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLHQ9UigkKFYobiwoRnMoKSxQTikpKSksZD1SKCQoVihuLFR2KSkpLGg9YShWKG4sQ3YpLDEwNyksbT1uZXcgcUoodCxkKSxpPSQ3ZShtLG4saCksazdlKG4sbSksdT1hKFYobixMSiksMTcpLnZhbHVlXzA7dT4xOyl7aWYobz1xeW4obiksZj1pLnNjYWxlTWVhc3VyZSx5PWEoVihuLEN2KSwxMDcpLEU9UigkKFYobixQTikpKSwoIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKS5zaXplXzA+MSYmUigkKFYobiwoRnUoKSxoTSkpKSkhPWhyJiYoaS5kcmF3aW5nV2lkdGgrKHkubGVmdCt5LnJpZ2h0KSkvKGkuZHJhd2luZ0hlaWdodCsoeS50b3BfMCt5LmJvdHRvbSkpPEU/bnIobywoRnUoKSxIZiksUigkKFYobixIZikpKStSKCQoVihuLGhNKSkpKTooIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKS5zaXplXzA+MSYmUigkKFYobiwoRnUoKSxnTSkpKSkhPWhyJiYoaS5kcmF3aW5nV2lkdGgrKHkubGVmdCt5LnJpZ2h0KSkvKGkuZHJhd2luZ0hlaWdodCsoeS50b3BfMCt5LmJvdHRvbSkpPkUmJm5yKG8sKEZ1KCksSGYpLFMuTWF0aC5tYXgoUigkKFYobixTdikpKSxSKCQoVihvLEhmKSkpLVIoJChWKG4sZ00pKSkpKSxtPW5ldyBxSih0LGQpLGM9JDdlKG0sbyxoKSxfPWMuc2NhbGVNZWFzdXJlLF8+PWYmJl89PV8pe2ZvcihzPTA7czwoIW8uY2hpbGRyZW4mJihvLmNoaWxkcmVuPW5ldyBVKFVuLG8sMTAsMTEpKSxvLmNoaWxkcmVuKS5zaXplXzA7cysrKUw3ZShlLGEoTygoIW8uY2hpbGRyZW4mJihvLmNoaWxkcmVuPW5ldyBVKFVuLG8sMTAsMTEpKSxvLmNoaWxkcmVuKSxzKSwyNyksYShPKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pLHMpLDI3KSk7azdlKG4sbSksZ3duKGksYy5kcmF3aW5nV2lkdGgpLHB3bihpLGMuZHJhd2luZ0hlaWdodCl9LS11fW5yKG4sKEZ1KCkseXcpLGkuZHJhd2luZ0hlaWdodCksbnIobixKaCxpLmRyYXdpbmdXaWR0aCksci5kb25lXzEoKX1mdW5jdGlvbiBPN2UoKXt9cCgxNDcxLDEsV3QsTzdlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNyksbnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7WXluKHRoaXMsYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wMnBhY2tpbmciLCJDb21wYWN0b3IiLDE0NzEpO2Z1bmN0aW9uIE03ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihmPW5ldyBRLGQ9bmV3IGxaKDAsciksaT0wLE1OKGQsbmV3IEFNKDAsMCxkLHIpKSxvPTAsXz1uZXcgWWUoZSk7Xy5jdXJzb3IhPV8udGhpcyQwMV8yLnNpemVfMSgpOyljPWEoZW4oXyksMjcpLHQ9YShsZShkLmNoaWxkcmVuLGQuY2hpbGRyZW4uYXJyYXkubGVuZ3RoLTEpLDE3MiksdT1vK2Mud2lkdGhfMCsoYShsZShkLmNoaWxkcmVuLDApLDE3MikuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0wPzA6ciksKHU+bnx8YWUoaWUoVihjLChGcygpLGFUKSkpKSkmJihvPTAsaSs9ZC5oZWlnaHQrcixSZShmLmFycmF5LGQpLGQ9bmV3IGxaKGksciksdD1uZXcgQU0oMCxkLnlfMCxkLHIpLE1OKGQsdCksbz0wKSx0LmNoaWxkcmVuLmFycmF5Lmxlbmd0aD09MHx8IWFlKGllKFYoeXIoYyksKEZzKCksRU0pKSkpJiYoYy5oZWlnaHQ+PXQuc21hbGxlc3RSZWN0SGVpZ2h0JiZjLmhlaWdodDw9dC5taW5IZWlnaHR8fHQuYXZlcmFnZUhlaWdodCouNTw9Yy5oZWlnaHQmJnQuYXZlcmFnZUhlaWdodCoxLjU+PWMuaGVpZ2h0KT9aSih0LGMpOihzPW5ldyBBTSh0LnhfMCt0LndpZHRoXzArcixkLnlfMCxkLHIpLE1OKGQscyksWkoocyxjKSksbz1jLnhfMCtjLndpZHRoXzA7cmV0dXJuIFJlKGYuYXJyYXksZCksZn1mdW5jdGlvbiBLeW4oZSxuLHIsdCxvKXt2YXIgaSxzLHU7aWYoci5oZWlnaHQ+PW4uc21hbGxlc3RSZWN0SGVpZ2h0JiZyLmhlaWdodDw9bi5taW5IZWlnaHR8fG4uYXZlcmFnZUhlaWdodCouNTw9ci5oZWlnaHQmJm4uYXZlcmFnZUhlaWdodCoxLjU+PXIuaGVpZ2h0KXtpZihzPWEobGUobi5yb3dzXzAsbi5yb3dzXzAuYXJyYXkubGVuZ3RoLTEpLDIwOSkscy54XzArcy53aWR0aF8wK3Iud2lkdGhfMCtvPD10JiYoaT1hKGxlKG4ucm93c18wLG4ucm93c18wLmFycmF5Lmxlbmd0aC0xKSwyMDkpLGkueV8wLWUueV8wK3IuaGVpZ2h0PD1lLmhlaWdodHx8ZS5jaGlsZHJlbi5hcnJheS5sZW5ndGg9PTEpKXJldHVybiBaSihuLHIpLCEwO2lmKG4ueF8wK3Iud2lkdGhfMDw9dCYmKG4ueV8wK24uaGVpZ2h0K3IuaGVpZ2h0K288PWUuaGVpZ2h0fHxlLmNoaWxkcmVuLmFycmF5Lmxlbmd0aD09MSkpcmV0dXJuIGVlKG4uY2hpbGRyZW4sciksdT1hKGxlKG4ucm93c18wLG4ucm93c18wLmFycmF5Lmxlbmd0aC0xKSwyMDkpLGVlKG4ucm93c18wLG5ldyBMTihuLnhfMCx1LnlfMCt1LmhlaWdodCtuLm5vZGVOb2RlU3BhY2luZyxuLm5vZGVOb2RlU3BhY2luZykpLFFKKGEobGUobi5yb3dzXzAsbi5yb3dzXzAuYXJyYXkubGVuZ3RoLTEpLDIwOSkscikscTdlKG4sciksITB9cmV0dXJuITF9ZnVuY3Rpb24gWHluKGUsbil7dmFyIHIsdCxvLGkscyx1O24uYmVnaW4oIk5vIENvbXBhY3Rpb24iLDEpLG89YShWKGUsKEZzKCksQ3YpKSwxMDcpLGk9KCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikscz1Fd24oaSksdT1TLk1hdGgubWF4KHMueF8wLFIoJChWKGUsKEZ1KCksU3YpKSkpLShvLmxlZnQrby5yaWdodCkpLHQ9Uy5NYXRoLm1heChzLnlfMCxSKCQoVihlLGJOKSkpLShvLnRvcF8wK28uYm90dG9tKSkscj10LXMueV8wLG5yKGUsdnYsciksbnIoZSxKaCx1KSxucihlLHl3LHQrciksbi5kb25lXzEoKX1mdW5jdGlvbiBSN2UoKXt9cCgxNDczLDEsV3QsUjdlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNyksbnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7WHluKGEobiwyNykscil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcucDJwYWNraW5nIiwiTm9QbGFjZW1lbnQiLDE0NzMpO2Z1bmN0aW9uIEFOKCl7QU49RixQTT1uZXcgeE0oIkNPTVBBQ1RJT04iLDApLGpKPW5ldyB4TSgiU0lNUExFIiwxKSxXSj1uZXcgeE0oIk5PTkUiLDIpfWZ1bmN0aW9uIEQ3ZShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDA6cmV0dXJuIG5ldyBPN2U7Y2FzZSAxOnJldHVybiBuZXcgQjdlO2Nhc2UgMjpyZXR1cm4gbmV3IFI3ZTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiB4TShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEp5bihlKXtyZXR1cm4gQU4oKSx3bigoRjdlKCksejdlKSxlKX1mdW5jdGlvbiBaeW4oKXtyZXR1cm4gQU4oKSxQKEkoVkosMSksVyw0MzksMCxbUE0sakosV0pdKX1wKDQzOSwyMix7MzoxLDM0OjEsMjI6MSw0Mzk6MSwxODg6MSwxOTY6MX0seE0pLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gRDdlKHRoaXMpfSxsLmNyZWF0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIEQ3ZSh0aGlzKX07dmFyIFBNLFdKLGpKLFZKPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAycGFja2luZyIsIlBhY2tpbmdTdHJhdGVneSIsNDM5LGduLFp5bixKeW4pO2Z1bmN0aW9uIEY3ZSgpe0Y3ZT1GLHo3ZT15bigoQU4oKSxQKEkoVkosMSksVyw0MzksMCxbUE0sakosV0pdKSkpfXZhciB6N2U7ZnVuY3Rpb24gUXluKGUsbil7dmFyIHIsdCxvLGkscztmb3IodD0wLG89MCxyPTAscz1uZXcgVChuLnN0YWNrcyk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDMxNSksa04oaSksdD1TLk1hdGgubWF4KHQsaS5oZWlnaHQpLG8rPWkud2lkdGhfMCsocj4wP2Uubm9kZU5vZGVTcGFjaW5nOjApLCsrcjtuLmhlaWdodD10LG4ud2lkdGhfMD1vfWZ1bmN0aW9uICQ3ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO2ZvcihrPVIoJChWKG4sKEZ1KCksSGYpKSkpLG09UigkKFYobixTdikpKSxoPVIoJChWKG4sYk4pKSksaVooKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikpLHg9TTdlKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pLGssZS5ub2RlTm9kZVNwYWNpbmcpLHY9MDt2PHguYXJyYXkubGVuZ3RoO3YrKylpZihjPShBZSh2LHguYXJyYXkubGVuZ3RoKSxhKHguYXJyYXlbdl0sMTg2KSksdiE9MCYmKHk9KEFlKHYtMSx4LmFycmF5Lmxlbmd0aCksYSh4LmFycmF5W3YtMV0sMTg2KSksck1lKGMseS55XzAreS5oZWlnaHQrZS5ub2RlTm9kZVNwYWNpbmcpKSxFPVd5bih2LHgsayxlLm5vZGVOb2RlU3BhY2luZyxhZShpZShWKG4sKEZzKCksRU0pKSkpKSxhZShpZShFLnNlY29uZCkpKXtmb3IoaT1uZXcgVChjLmNoaWxkcmVuKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTcyKSxvLmZpeGVkXzA9ITEsby5wb3NpdGlvbkZpeGVkPSExLFk3ZShvKTtjLnN0YWNrcz1uZXcgUSxjLndpZHRoXzA9aywtLXZ9ZWxzZSBpZihReW4oZSxjKSx2KzE8eC5hcnJheS5sZW5ndGgmJihlLnBvdGVudGlhbFJvd1dpZHRoSW5jcmVhc2VNYXg9Uy5NYXRoLm1heChjLndpZHRoXzArZS5ub2RlTm9kZVNwYWNpbmcrYShsZSgoQWUodisxLHguYXJyYXkubGVuZ3RoKSxhKHguYXJyYXlbdisxXSwxODYpKS5jaGlsZHJlbiwwKSwxNzIpLndpZHRoXzAtayxlLnBvdGVudGlhbFJvd1dpZHRoRGVjcmVhc2VNYXgpLGUucG90ZW50aWFsUm93V2lkdGhJbmNyZWFzZU1pbj1TLk1hdGgubWluKGMud2lkdGhfMCtlLm5vZGVOb2RlU3BhY2luZythKGxlKChBZSh2KzEseC5hcnJheS5sZW5ndGgpLGEoeC5hcnJheVt2KzFdLDE4NikpLmNoaWxkcmVuLDApLDE3Mikud2lkdGhfMC1rLGUucG90ZW50aWFsUm93V2lkdGhEZWNyZWFzZU1pbiksYy5zdGFja3MuYXJyYXkubGVuZ3RoIT0wJiYoZS5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4PVMuTWF0aC5tYXgoZS5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4LGEobGUoYy5zdGFja3MsYy5zdGFja3MuYXJyYXkubGVuZ3RoLTEpLDMxNSkud2lkdGhfMCsoYy5zdGFja3MuYXJyYXkubGVuZ3RoPD0xPzA6ZS5ub2RlTm9kZVNwYWNpbmcpKSxlLnBvdGVudGlhbFJvd1dpZHRoRGVjcmVhc2VNaW49Uy5NYXRoLm1pbihlLnBvdGVudGlhbFJvd1dpZHRoRGVjcmVhc2VNYXgsYShsZShjLnN0YWNrcyxjLnN0YWNrcy5hcnJheS5sZW5ndGgtMSksMzE1KS53aWR0aF8wKyhjLnN0YWNrcy5hcnJheS5sZW5ndGg8PTE/MDplLm5vZGVOb2RlU3BhY2luZykpKSkseC5hcnJheS5sZW5ndGg9PTEpZm9yKGY9YShsZShjLnN0YWNrcyxjLnN0YWNrcy5hcnJheS5sZW5ndGgtMSksMzE1KSxkPWEobGUoZi5ibG9ja3MsZi5ibG9ja3MuYXJyYXkubGVuZ3RoLTEpLDE3MiksdT1uZXcgVChkLnJvd3NfMCk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDIwOSksZS5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4PVMuTWF0aC5tYXgoZS5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4LGQud2lkdGhfMC1zLndpZHRoXzApLGUucG90ZW50aWFsUm93V2lkdGhEZWNyZWFzZU1pbj1TLk1hdGgubWluKGUucG90ZW50aWFsUm93V2lkdGhEZWNyZWFzZU1pbixkLndpZHRoXzAtcy53aWR0aF8wKSxlLnBvdGVudGlhbFJvd1dpZHRoSW5jcmVhc2VNYXg9Uy5NYXRoLm1heChlLnBvdGVudGlhbFJvd1dpZHRoSW5jcmVhc2VNYXgscy53aWR0aF8wK2Uubm9kZU5vZGVTcGFjaW5nKSxlLnBvdGVudGlhbFJvd1dpZHRoSW5jcmVhc2VNaW49Uy5NYXRoLm1pbihlLnBvdGVudGlhbFJvd1dpZHRoSW5jcmVhc2VNaW4scy53aWR0aF8wK2Uubm9kZU5vZGVTcGFjaW5nKTtyZXR1cm4gQT1uTWUoeCxlLm5vZGVOb2RlU3BhY2luZyksTT1TLk1hdGgubWF4KEEueF8wLG0tKHIubGVmdCtyLnJpZ2h0KSksXz1TLk1hdGgubWF4KEEueV8wLGgtKHIudG9wXzArci5ib3R0b20pKSx0PV8tQS55XzAsbnIobix2dix0KSxucihuLElOLHgpLG5ldyB0WihlLmFzcGVjdFJhdGlvLE0sQS55XzArdCwoSXYoKSxjVCkpfWZ1bmN0aW9uIHFKKGUsbil7dGhpcy5hc3BlY3RSYXRpbz1lLHRoaXMubm9kZU5vZGVTcGFjaW5nPW59cCg4MTAsMSx7fSxxSiksbC5hc3BlY3RSYXRpbz0wLGwubm9kZU5vZGVTcGFjaW5nPTAsbC5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWF4PTAsbC5wb3RlbnRpYWxSb3dXaWR0aERlY3JlYXNlTWluPWhyLGwucG90ZW50aWFsUm93V2lkdGhJbmNyZWFzZU1heD0wLGwucG90ZW50aWFsUm93V2lkdGhJbmNyZWFzZU1pbj1ocixnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAycGFja2luZyIsIlJvd0ZpbGxpbmdBbmRDb21wYWN0aW9uIiw4MTApO2Z1bmN0aW9uIGV3bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2ZvcihuLmJlZ2luKCJObyBDb21wYWN0aW9uIiwxKSxtPVIoJChWKGUsKEZ1KCksSGYpKSkpLHM9UigkKFYoZSwoRnMoKSxUdikpKSksdT1hKFYoZSxDdiksMTA3KSxpWigoIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSksZD1NN2UoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbiksbSxzKSwhZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLF89bmV3IFQoZCk7Xy5pPF8udGhpcyQwMS5hcnJheS5sZW5ndGg7KWZvcihjPWEoQyhfKSwxODYpLG89bmV3IFQoYy5jaGlsZHJlbik7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE3MiksaD1uZXcgcloodC54XzAsdC55XzAsUigkKFYoZSxUdikpKSksZVooaCx0KSxlZShjLnN0YWNrcyxoKTtmPW5NZShkLHMpLHk9Uy5NYXRoLm1heChmLnhfMCxSKCQoVihlLFN2KSkpLSh1LmxlZnQrdS5yaWdodCkpLGk9Uy5NYXRoLm1heChmLnlfMCxSKCQoVihlLGJOKSkpLSh1LnRvcF8wK3UuYm90dG9tKSkscj1pLWYueV8wLG5yKGUsdnYsciksbnIoZSxKaCx5KSxucihlLHl3LGkrciksbnIoZSxJTixkKSxuLmRvbmVfMSgpfWZ1bmN0aW9uIEI3ZSgpe31wKDE0NzIsMSxXdCxCN2UpLGwuZ2V0TGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbj1mdW5jdGlvbihuKXtyZXR1cm4gYShuLDI3KSxudWxsfSxsLnByb2Nlc3M9ZnVuY3Rpb24obixyKXtld24oYShuLDI3KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wMnBhY2tpbmciLCJTaW1wbGVQbGFjZW1lbnQiLDE0NzIpO2Z1bmN0aW9uIEc3ZShlLG4pe3ZhciByO2lmKG4uYmVnaW4oIkVxdWFsIFdoaXRlc3BhY2UgRWxpbWluYXRvciIsMSksV3MoZSwoRnUoKSxJTikpKW53bihhKFYoZSxJTiksMTUpLFIoJChWKGUsSmgpKSksKHI9UigkKFYoZSx2dikpKSxSKCQoVihlLChGcygpLFR2KSkpKSxyKSk7ZWxzZSB0aHJvdyBiKG5ldyBLYygiVGhlIGdyYXBoIGRvZXMgbm90IGNvbnRhaW4gcm93cy4iKSk7bi5kb25lXzEoKX1mdW5jdGlvbiBIN2UoKXt9cCgxNDc0LDEsV3QsSDdlKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwyNyksbnVsbH0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7dGhpcy5wcm9jZXNzXzAoYShuLDI3KSxyKX0sbC5wcm9jZXNzXzA9ZnVuY3Rpb24obixyKXtHN2UobixyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy5wM3doaXRlc3BhY2VlbGltaW5hdGlvbiIsIkVxdWFsV2hpdGVzcGFjZUVsaW1pbmF0b3IiLDE0NzQpO2Z1bmN0aW9uIG53bihlLG4scil7dmFyIHQsbyxpLHM7Zm9yKHQ9ci9lLnNpemVfMSgpLG89MCxzPWUuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDE4Niksck1lKGksaS55XzArdCpvKSx2d24oaSxuLHQpLCsrb31mdW5jdGlvbiBVN2UoKXt9cCgxNDc1LDE0NzQsV3QsVTdlKSxsLnByb2Nlc3NfMD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7ci5iZWdpbigiVG8gQXNwZWN0IFJhdGlvIFdoaXRlc2FwY2UgRWxpbWluYXRvciIsMSksdT1SKCQoVihuLChGdSgpLEpoKSkpKSxzPVIoJChWKG4seXcpKSksaT1SKCQoVihuLChGcygpLFBOKSkpKSx0PVIoJChWKG4sdnYpKSksbz11L3MsbzxpPyh1PXMqaSxucihuLEpoLHUpKToodCs9dS9pLXMsbnIobix2dix0KSxucihuLHl3LHMrdCkpLEc3ZShuLHIpLHIuZG9uZV8xKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcucDN3aGl0ZXNwYWNlZWxpbWluYXRpb24iLCJUb0FzcGVjdHJhdGlvTm9kZUV4cGFuZGVyIiwxNDc1KTtmdW5jdGlvbiBOTSgpe05NPUYsS0o9bmV3IFlKKCJFUVVBTF9CRVRXRUVOX1NUUlVDVFVSRVMiLDApLFhKPW5ldyBZSigiVE9fQVNQRUNUX1JBVElPIiwxKX1mdW5jdGlvbiBXN2UoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgSDdlO2Nhc2UgMTpyZXR1cm4gbmV3IFU3ZTtkZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBZSihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHJ3bihlKXtyZXR1cm4gTk0oKSx3bigoajdlKCksVjdlKSxlKX1mdW5jdGlvbiB0d24oKXtyZXR1cm4gTk0oKSxQKEkoSkosMSksVyw0OTIsMCxbS0osWEpdKX1wKDQ5MiwyMix7MzoxLDM0OjEsMjI6MSw0OTI6MSwxODg6MSwxOTY6MX0sWUopLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gVzdlKHRoaXMpfSxsLmNyZWF0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIFc3ZSh0aGlzKX07dmFyIEtKLFhKLEpKPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnAzd2hpdGVzcGFjZWVsaW1pbmF0aW9uIiwiV2hpdGVTcGFjZUVsaW1pbmF0aW9uU3RyYXRlZ3kiLDQ5Mixnbix0d24scnduKTtmdW5jdGlvbiBqN2UoKXtqN2U9RixWN2U9eW4oKE5NKCksUChJKEpKLDEpLFcsNDkyLDAsW0tKLFhKXSkpKX12YXIgVjdlO2Z1bmN0aW9uIFpKKGUsbil7ZS5yb3dzXzAuYXJyYXkubGVuZ3RoPT0wJiZlZShlLnJvd3NfMCxuZXcgTE4oZS54XzAsZS55XzAsZS5ub2RlTm9kZVNwYWNpbmcpKSxlZShlLmNoaWxkcmVuLG4pLFFKKGEobGUoZS5yb3dzXzAsZS5yb3dzXzAuYXJyYXkubGVuZ3RoLTEpLDIwOSksbikscTdlKGUsbil9ZnVuY3Rpb24gb3duKGUsbixyKXt2YXIgdCxvO2ZvcihvPW5ldyBUKGUuY2hpbGRyZW4pO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwyNyksX2wodCx0LnhfMCtuLHQueV8wK3IpfWZ1bmN0aW9uIHE3ZShlLG4pe3ZhciByLHQsbyxpO2ZvcihpPWEobGUoZS5yb3dzXzAsZS5yb3dzXzAuYXJyYXkubGVuZ3RoLTEpLDIwOSkud2lkdGhfMCxlLnNtYWxsZXN0UmVjdFdpZHRoPVMuTWF0aC5taW4oZS5zbWFsbGVzdFJlY3RXaWR0aCxuLndpZHRoXzApLGUud2lkdGhfMD1TLk1hdGgubWF4KGUud2lkdGhfMCxpKSxlLm1pbldpZHRoPVMuTWF0aC5tYXgoZS5taW5XaWR0aCxuLndpZHRoXzArKGUuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0xPzA6ZS5ub2RlTm9kZVNwYWNpbmcpKSxlLnNtYWxsZXN0UmVjdEhlaWdodD1TLk1hdGgubWluKGUuc21hbGxlc3RSZWN0SGVpZ2h0LG4uaGVpZ2h0KSxlLm1heEhlaWdodCs9bi5oZWlnaHQrKGUuY2hpbGRyZW4uYXJyYXkubGVuZ3RoPT0xPzA6ZS5ub2RlTm9kZVNwYWNpbmcpLGUubWluSGVpZ2h0PVMuTWF0aC5tYXgoZS5taW5IZWlnaHQsbi5oZWlnaHQpLG89ZS5yb3dzXzAuYXJyYXkubGVuZ3RoPjA/KGUucm93c18wLmFycmF5Lmxlbmd0aC0xKSplLm5vZGVOb2RlU3BhY2luZzowLHQ9bmV3IFQoZS5yb3dzXzApO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwyMDkpLG8rPXIuaGVpZ2h0O2UuaGVpZ2h0PW8sZS5hdmVyYWdlSGVpZ2h0PWUubWF4SGVpZ2h0L2UuY2hpbGRyZW4uYXJyYXkubGVuZ3RoLWUubm9kZU5vZGVTcGFjaW5nKigoZS5jaGlsZHJlbi5hcnJheS5sZW5ndGgtMSkvZS5jaGlsZHJlbi5hcnJheS5sZW5ndGgpLGFaKGUucGFyZW50Um93KX1mdW5jdGlvbiBZN2UoZSl7dmFyIG4scix0LG8saSxzLHUsYztmb3IodD0wLHI9MCxjPW5ldyBwcixuPTAsdT1uZXcgVChlLnJvd3NfMCk7dS5pPHUudGhpcyQwMS5hcnJheS5sZW5ndGg7KXM9YShDKHUpLDIwOSkscy5yZWN0cy5hcnJheS5sZW5ndGg9PTA/YnIoYyxzLGMudGFpbC5wcmV2LGMudGFpbCk6KHQ9Uy5NYXRoLm1heCh0LHMud2lkdGhfMCkscis9cy5oZWlnaHQrKG4+MD9lLm5vZGVOb2RlU3BhY2luZzowKSksKytuO2Zvcih5eihlLnJvd3NfMCxjKSxlLmhlaWdodD1yLGUud2lkdGhfMD10LGUubWluV2lkdGg9MCxlLm1pbkhlaWdodD0wLGUubWF4SGVpZ2h0PTAsZS5zbWFsbGVzdFJlY3RIZWlnaHQ9aHIsZS5zbWFsbGVzdFJlY3RXaWR0aD1ocixpPW5ldyBUKGUuY2hpbGRyZW4pO2kuaTxpLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylvPWEoQyhpKSwyNyksZS5zbWFsbGVzdFJlY3RXaWR0aD1TLk1hdGgubWluKGUuc21hbGxlc3RSZWN0V2lkdGgsby53aWR0aF8wKSxlLm1pbldpZHRoPVMuTWF0aC5tYXgoZS5taW5XaWR0aCxvLndpZHRoXzApLGUubWluSGVpZ2h0PVMuTWF0aC5tYXgoZS5taW5IZWlnaHQsby5oZWlnaHQpLGUuc21hbGxlc3RSZWN0SGVpZ2h0PVMuTWF0aC5taW4oZS5zbWFsbGVzdFJlY3RIZWlnaHQsby5oZWlnaHQpLGUubWF4SGVpZ2h0Kz1vLmhlaWdodCtlLm5vZGVOb2RlU3BhY2luZztlLmF2ZXJhZ2VIZWlnaHQ9ZS5tYXhIZWlnaHQvZS5jaGlsZHJlbi5hcnJheS5sZW5ndGgtZS5ub2RlTm9kZVNwYWNpbmcqKChlLmNoaWxkcmVuLmFycmF5Lmxlbmd0aC0xKS9lLmNoaWxkcmVuLmFycmF5Lmxlbmd0aCksYVooZS5wYXJlbnRSb3cpfWZ1bmN0aW9uIGl3bihlLG4scil7dmFyIHQsbyxpLHMsdTtmb3IodT1lLndpZHRoXzArbixlLndpZHRoXzArPW4sZS5oZWlnaHQrPXIsdD1yL2Uucm93c18wLmFycmF5Lmxlbmd0aCxvPTAscz1uZXcgVChlLnJvd3NfMCk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KWk9YShDKHMpLDIwOSksc3duKGksdSx0LG8pLCsrb31mdW5jdGlvbiBLN2UoZSxuKXt2YXIgcix0LG8saSxzO2lmKGUubWF4SGVpZ2h0PD1ufHxhd24oZSxlLm1pbldpZHRoLG4pKXJldHVybiBlLm1pbldpZHRoO2ZvcihpPWUud2lkdGhfMCx0PWUubWluV2lkdGgscz1lLndpZHRoXzAsbz0oaS10KS8yK3Q7dCsxPGk7KXI9YnYoZSxvLCExKSxyLndpZHRoXzA8PW8mJnIuaGVpZ2h0PD1uPyhzPW8saT1vKTp0PW8sbz0oaS10KS8yK3Q7cmV0dXJuIHN9ZnVuY3Rpb24gbFQoZSxuKXt2YXIgcix0LG87cmV0dXJuIG89ZS53aWR0aF8wLHQ9ZS5oZWlnaHQscj1idihlLG4sITApLHIud2lkdGhfMCE9b3x8ci5oZWlnaHQhPXR9ZnVuY3Rpb24gYXduKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1idihlLG4sITEpLHQud2lkdGhfMDw9biYmdC5oZWlnaHQ8PXJ9ZnVuY3Rpb24gYnYoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihpPTAscz1lLnlfMCxvPTAsdD0wLGM9MCxoPTAsZj0wLHImJihlLnJvd3NfMC5hcnJheS5sZW5ndGg9MCxlZShlLnJvd3NfMCxuZXcgTE4oZS54XzAsZS55XzAsZS5ub2RlTm9kZVNwYWNpbmcpKSksdT0wLGQ9bmV3IFQoZS5jaGlsZHJlbik7ZC5pPGQudGhpcyQwMS5hcnJheS5sZW5ndGg7KV89YShDKGQpLDI3KSxpK18ud2lkdGhfMCsodT4wP2Uubm9kZU5vZGVTcGFjaW5nOjApPm4mJmM+MCYmKGk9MCxzKz1jK2Uubm9kZU5vZGVTcGFjaW5nLG89Uy5NYXRoLm1heChvLGgpLHQrPWMrZS5ub2RlTm9kZVNwYWNpbmcsYz0wLGg9MCxyJiYoKytmLGVlKGUucm93c18wLG5ldyBMTihlLnhfMCxzLGUubm9kZU5vZGVTcGFjaW5nKSkpLHU9MCksaCs9Xy53aWR0aF8wKyh1PjA/ZS5ub2RlTm9kZVNwYWNpbmc6MCksYz1TLk1hdGgubWF4KGMsXy5oZWlnaHQpLHImJlFKKGEobGUoZS5yb3dzXzAsZiksMjA5KSxfKSxpKz1fLndpZHRoXzArKHU+MD9lLm5vZGVOb2RlU3BhY2luZzowKSwrK3U7cmV0dXJuIG89Uy5NYXRoLm1heChvLGgpLHQrPWMsciYmKGUud2lkdGhfMD1vLGUuaGVpZ2h0PXQsYVooZS5wYXJlbnRSb3cpKSxuZXcgdGwoZS54XzAsZS55XzAsbyx0KX1mdW5jdGlvbiBsd24oZSxuKXt2YXIgcix0O2ZvcihQaShlLmNoaWxkcmVuLG4pLHQ9bmV3IFQoZS5yb3dzXzApO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpZihyPWEoQyh0KSwyMDkpLGZvKHIucmVjdHMsbiwwKSE9LTEpe1BpKHIucmVjdHMsbiksX3duKHIpLHIucmVjdHMuYXJyYXkubGVuZ3RoPT0wJiZQaShlLnJvd3NfMCxyKTticmVha31ZN2UoZSl9ZnVuY3Rpb24gc1QoZSxuLHIpe3ZhciB0LG87Zm9yKG93bihlLG4tZS54XzAsci1lLnlfMCksbz1uZXcgVChlLnJvd3NfMCk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDIwOSksdXduKHQsdC54XzArbi1lLnhfMCksY3duKHQsdC55XzArci1lLnlfMCk7ZS54XzA9bixlLnlfMD1yfWZ1bmN0aW9uIEFNKGUsbixyLHQpe3RoaXMuY2hpbGRyZW49bmV3IFEsdGhpcy5yb3dzXzA9bmV3IFEsdGhpcy5ub2RlTm9kZVNwYWNpbmc9dCx0aGlzLnBhcmVudFJvdz1yLHRoaXMueF8wPWUsdGhpcy55XzA9bix0aGlzLndpZHRoXzA9MCx0aGlzLmhlaWdodD0wfXAoMTcyLDEsezE3MjoxfSxBTSksbC5hdmVyYWdlSGVpZ2h0PTAsbC5maXhlZF8wPSExLGwuaGVpZ2h0PTAsbC5tYXhIZWlnaHQ9MCxsLm1pbkhlaWdodD0wLGwubWluV2lkdGg9MCxsLm5vZGVOb2RlU3BhY2luZz0wLGwucG9zaXRpb25GaXhlZD0hMSxsLnNtYWxsZXN0UmVjdEhlaWdodD1ocixsLnNtYWxsZXN0UmVjdFdpZHRoPWhyLGwud2lkdGhfMD0wLGwueF8wPTAsbC55XzA9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnJlY3RwYWNraW5nLnV0aWwiLCJCbG9jayIsMTcyKTtmdW5jdGlvbiBRSihlLG4pe3JldHVybiBDaShuLGUueF8wK2Uud2lkdGhfMCsoZS5yZWN0cy5hcnJheS5sZW5ndGg9PTA/MDplLm5vZGVOb2RlU3BhY2luZykpLFRpKG4sZS55XzApLGUuaGVpZ2h0PVMuTWF0aC5tYXgoZS5oZWlnaHQsbi5oZWlnaHQpLGUud2lkdGhfMCs9bi53aWR0aF8wKyhlLnJlY3RzLmFycmF5Lmxlbmd0aD09MD8wOmUubm9kZU5vZGVTcGFjaW5nKSxlZShlLnJlY3RzLG4pLCEwfWZ1bmN0aW9uIHN3bihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmO2ZvcihvPShuLWUud2lkdGhfMCkvZS5yZWN0cy5hcnJheS5sZW5ndGgsaT0wLGUuaGVpZ2h0Kz1yLGUud2lkdGhfMD1uLGY9bmV3IFQoZS5yZWN0cyk7Zi5pPGYudGhpcyQwMS5hcnJheS5sZW5ndGg7KWQ9YShDKGYpLDI3KSxfPWQud2lkdGhfMCxjPWQuaGVpZ2h0LENpKGQsZC54XzAraSpvKSxUaShkLGQueV8wK3QqciksVGQoZCxkLndpZHRoXzArbyksQ2QoZCxlLmhlaWdodCksKytpLHU9ZC53aWR0aF8wLHM9ZC5oZWlnaHQsa2VlKGQsbmV3IFkodSxzKSxuZXcgWShfLGMpKX1mdW5jdGlvbiB1d24oZSxuKXtlLnhfMD1ufWZ1bmN0aW9uIGN3bihlLG4pe2UueV8wPW59ZnVuY3Rpb24gX3duKGUpe3ZhciBuLHIsdCxvO2ZvcihvPTAsbj0wLHQ9bmV3IFQoZS5yZWN0cyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDI3KSxDaShyLGUueF8wK28pLFRpKHIsZS55XzApLG8rPXIud2lkdGhfMCtlLm5vZGVOb2RlU3BhY2luZyxuPVMuTWF0aC5tYXgobixyLmhlaWdodCtlLm5vZGVOb2RlU3BhY2luZyk7ZS53aWR0aF8wPW8tZS5ub2RlTm9kZVNwYWNpbmcsZS5oZWlnaHQ9bi1lLm5vZGVOb2RlU3BhY2luZ31mdW5jdGlvbiBMTihlLG4scil7dGhpcy5yZWN0cz1uZXcgUSx0aGlzLnhfMD1lLHRoaXMueV8wPW4sdGhpcy5ub2RlTm9kZVNwYWNpbmc9cn1wKDIwOSwxLHsyMDk6MX0sTE4pLGwuaGVpZ2h0PTAsbC5ub2RlTm9kZVNwYWNpbmc9MCxsLndpZHRoXzA9MCxsLnhfMD0wLGwueV8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy51dGlsIiwiQmxvY2tSb3ciLDIwOSk7ZnVuY3Rpb24gZVooZSxuKXtuLnN0YWNrXzA9ZSxlLndpZHRoXzA9Uy5NYXRoLm1heChlLndpZHRoXzAsbi53aWR0aF8wKSxlLmhlaWdodCs9bi5oZWlnaHQrKGUuYmxvY2tzLmFycmF5Lmxlbmd0aD09MD8wOmUubm9kZU5vZGVTcGFjaW5nKSxlZShlLmJsb2NrcyxuKX1mdW5jdGlvbiBkd24oZSxuLHIpe3ZhciB0LG8saSxzO2ZvcihzPTAsdD1yL2UuYmxvY2tzLmFycmF5Lmxlbmd0aCxpPW5ldyBUKGUuYmxvY2tzKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMTcyKSxzVChvLG8ueF8wLG8ueV8wK3MqdCksaXduKG8sZS53aWR0aF8wLW8ud2lkdGhfMCtuLHQpLCsrc31mdW5jdGlvbiBmd24oZSl7dmFyIG4scix0O2Zvcih0PTAscj1uZXcgVChlLmJsb2Nrcyk7ci5pPHIudGhpcyQwMS5hcnJheS5sZW5ndGg7KW49YShDKHIpLDE3MiksdD1TLk1hdGgubWF4KHQsbi5taW5XaWR0aCk7cmV0dXJuIHR9ZnVuY3Rpb24gblooZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7aWYoZS5ibG9ja3MuYXJyYXkubGVuZ3RoPT0xKXJldHVybiBLN2UoYShsZShlLmJsb2NrcywwKSwxNzIpLG4pO2ZvcihzPWZ3bihlKSxjPTAsXz1lLndpZHRoXzAsaT1zLGQ9ZS53aWR0aF8wLHU9KF8taSkvMitpO2krMTxfOyl7Zm9yKGM9MCx0PW5ldyBUKGUuYmxvY2tzKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMTcyKSxjKz0obz1idihyLHUsITEpLG8uaGVpZ2h0KTtjPG4/KGQ9dSxfPXUpOmk9dSx1PShfLWkpLzIraX1yZXR1cm4gZH1mdW5jdGlvbiBYN2UoZSxuKXt2YXIgcix0LG8saSxzO2ZvcihzPWUueV8wLG89MCxpPTAsdD1uZXcgVChlLmJsb2Nrcyk7dC5pPHQudGhpcyQwMS5hcnJheS5sZW5ndGg7KXI9YShDKHQpLDE3Miksc1QocixlLnhfMCxzKSxsVChyLG4pLGk9Uy5NYXRoLm1heChpLHIud2lkdGhfMCkscys9ci5oZWlnaHQrZS5ub2RlTm9kZVNwYWNpbmcsbz1zO2Uud2lkdGhfMD1pLGUuaGVpZ2h0PW99ZnVuY3Rpb24gSjdlKGUsbixyKXt2YXIgdCxvLGkscztmb3IoaT1uLWUueF8wLHM9ci1lLnlfMCxvPW5ldyBUKGUuYmxvY2tzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTcyKSxzVCh0LHQueF8wK2ksdC55XzArcyk7ZS54XzA9bixlLnlfMD1yfWZ1bmN0aW9uIGtOKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKHQ9MCxpPTAsbz0wLHI9bmV3IFQoZS5ibG9ja3MpO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwxNzIpLGk9Uy5NYXRoLm1heChpLG4ud2lkdGhfMCksdCs9bi5oZWlnaHQrKG8+MD9lLm5vZGVOb2RlU3BhY2luZzowKSwrK287ZS5oZWlnaHQ9dCxlLndpZHRoXzA9aX1mdW5jdGlvbiByWihlLG4scil7dGhpcy5ibG9ja3M9bmV3IFEsdGhpcy54XzA9ZSx0aGlzLnlfMD1uLHRoaXMubm9kZU5vZGVTcGFjaW5nPXJ9cCgzMTUsMSx7MzE1OjF9LHJaKSxsLmhlaWdodD0wLGwubm9kZU5vZGVTcGFjaW5nPTAsbC53aWR0aF8wPTAsbC54XzA9MCxsLnlfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcudXRpbCIsIkJsb2NrU3RhY2siLDMxNSk7ZnVuY3Rpb24gcHduKGUsbil7ZS5kcmF3aW5nSGVpZ2h0PW4sZS5kcmF3aW5nV2lkdGg+MCYmZS5kcmF3aW5nSGVpZ2h0PjAmJihlLnNjYWxlTWVhc3VyZT1PTihlLmRyYXdpbmdXaWR0aCxlLmRyYXdpbmdIZWlnaHQsZS5kYXIpKX1mdW5jdGlvbiBnd24oZSxuKXtlLmRyYXdpbmdXaWR0aD1uLGUuZHJhd2luZ1dpZHRoPjAmJmUuZHJhd2luZ0hlaWdodD4wJiYoZS5zY2FsZU1lYXN1cmU9T04oZS5kcmF3aW5nV2lkdGgsZS5kcmF3aW5nSGVpZ2h0LGUuZGFyKSl9ZnVuY3Rpb24gaHduKGUsbil7ZS5wbGFjZW1lbnRPcHRpb249bn1mdW5jdGlvbiB0WihlLG4scix0KXtvWi5jYWxsKHRoaXMsZSxuLHIsdCwwLDApfWZ1bmN0aW9uIG9aKGUsbixyLHQsbyxpKXt0aGlzLmRhcj1lLHRoaXMuZHJhd2luZ1dpZHRoPW4sdGhpcy5kcmF3aW5nSGVpZ2h0PXIsdGhpcy5wbGFjZW1lbnRPcHRpb249dCx0aGlzLm5leHRYY29vcmRpbmF0ZT1vLHRoaXMubmV4dFljb29yZGluYXRlPWksdGhpcy5kcmF3aW5nV2lkdGg+MCYmdGhpcy5kcmF3aW5nSGVpZ2h0PjAmJih0aGlzLnNjYWxlTWVhc3VyZT1PTih0aGlzLmRyYXdpbmdXaWR0aCx0aGlzLmRyYXdpbmdIZWlnaHQsdGhpcy5kYXIpKX1wKDIzOCwxLHsyMzg6MX0sdFosb1opLGwuZGFyPTAsbC5kcmF3aW5nSGVpZ2h0PTAsbC5kcmF3aW5nV2lkdGg9MCxsLm5leHRYY29vcmRpbmF0ZT0wLGwubmV4dFljb29yZGluYXRlPTAsbC5zY2FsZU1lYXN1cmU9MDt2YXIgbXduPWcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcudXRpbCIsIkRyYXdpbmdEYXRhIiwyMzgpO2Z1bmN0aW9uIEl2KCl7SXY9RixtZz1uZXcgdVQoIkNBTkRJREFURV9QT1NJVElPTl9MQVNUX1BMQUNFRF9SSUdIVCIsMCksWmg9bmV3IHVUKCJDQU5ESURBVEVfUE9TSVRJT05fTEFTVF9QTEFDRURfQkVMT1ciLDEpLFB2PW5ldyB1VCgiQ0FORElEQVRFX1BPU0lUSU9OX1dIT0xFX0RSQVdJTkdfUklHSFQiLDIpLHh2PW5ldyB1VCgiQ0FORElEQVRFX1BPU0lUSU9OX1dIT0xFX0RSQVdJTkdfQkVMT1ciLDMpLGNUPW5ldyB1VCgiV0hPTEVfRFJBV0lORyIsNCl9ZnVuY3Rpb24gdVQoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiB5d24oZSl7cmV0dXJuIEl2KCksd24oKFE3ZSgpLGVNZSksZSl9ZnVuY3Rpb24gd3duKCl7cmV0dXJuIEl2KCksUChJKFo3ZSwxKSxXLDM3MywwLFttZyxaaCxQdix4dixjVF0pfXAoMzczLDIyLHszOjEsMzQ6MSwyMjoxLDM3MzoxfSx1VCk7dmFyIFpoLG1nLHh2LFB2LGNULFo3ZT1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5yZWN0cGFja2luZy51dGlsIiwiRHJhd2luZ0RhdGFEZXNjcmlwdG9yIiwzNzMsZ24sd3duLHl3bik7ZnVuY3Rpb24gUTdlKCl7UTdlPUYsZU1lPXluKChJdigpLFAoSShaN2UsMSksVywzNzMsMCxbbWcsWmgsUHYseHYsY1RdKSkpfXZhciBlTWU7ZnVuY3Rpb24gRXduKGUpe3ZhciBuLHIsdCxvO2ZvcihyPTAsbj0wLG89bmV3IFllKGUpO28uY3Vyc29yIT1vLnRoaXMkMDFfMi5zaXplXzEoKTspdD1hKGVuKG8pLDI3KSxyPVMuTWF0aC5tYXgodC53aWR0aF8wK3QueF8wLHIpLG49Uy5NYXRoLm1heCh0LmhlaWdodCt0LnlfMCxuKTtyZXR1cm4gbmV3IFkocixuKX1mdW5jdGlvbiBuTWUoZSxuKXt2YXIgcix0LG8saSxzO2Zvcih0PTAsbz0wLHI9MCxzPW5ldyBUKGUpO3MuaTxzLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylpPWEoQyhzKSwxODYpLHQ9Uy5NYXRoLm1heCh0LGkud2lkdGhfMCksbys9aS5oZWlnaHQrKHI+MD9uOjApLCsrcjtyZXR1cm4gbmV3IFkodCxvKX1mdW5jdGlvbiBPTihlLG4scil7cmV0dXJuIFMuTWF0aC5taW4oci9lLDEvbil9ZnVuY3Rpb24gaVooZSl7dmFyIG4scjtmb3Iocj1uZXcgWWUoZSk7ci5jdXJzb3IhPXIudGhpcyQwMV8yLnNpemVfMSgpOyluPWEoZW4ociksMjcpLENpKG4sMCksVGkobiwwKX1mdW5jdGlvbiBNTihlLG4pe2UuaGVpZ2h0PVMuTWF0aC5tYXgoZS5oZWlnaHQsbi5oZWlnaHQpLGUud2lkdGhfMCs9bi53aWR0aF8wKyhlLmNoaWxkcmVuLmFycmF5Lmxlbmd0aD09MD8wOmUubm9kZU5vZGVTcGFjaW5nKSxlZShlLmNoaWxkcmVuLG4pfWZ1bmN0aW9uIHZ3bihlLG4scil7dmFyIHQsbyxpLHMsdSxjO2ZvcihvPW4tZS53aWR0aF8wLGk9by9lLnN0YWNrcy5hcnJheS5sZW5ndGgscz0wLGM9bmV3IFQoZS5zdGFja3MpO2MuaTxjLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl1PWEoQyhjKSwzMTUpLHQ9ZS5oZWlnaHQtdS5oZWlnaHQrcixKN2UodSx1LnhfMCtzKmksdS55XzApLGR3bih1LGksdCksKytzfWZ1bmN0aW9uIGFaKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKGk9MCxvPVZyLHQ9MCxyPW5ldyBUKGUuY2hpbGRyZW4pO3IuaTxyLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyluPWEoQyhyKSwxNzIpLGkrPW4ud2lkdGhfMCsodD4wP2Uubm9kZU5vZGVTcGFjaW5nOjApLG89Uy5NYXRoLm1heChvLG4uaGVpZ2h0KSwrK3Q7ZS53aWR0aF8wPWksZS5oZWlnaHQ9b31mdW5jdGlvbiBfVChlLG4pe3ZhciByLHQsbztmb3IoUGkoZS5jaGlsZHJlbixuKSxlLndpZHRoXzAtPW4ud2lkdGhfMCsoZS5jaGlsZHJlbi5hcnJheS5sZW5ndGg9PTA/MDplLm5vZGVOb2RlU3BhY2luZyksbz1YRix0PW5ldyBUKGUuY2hpbGRyZW4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxNzIpLG89Uy5NYXRoLm1heChvLHIuaGVpZ2h0KTtlLmhlaWdodD1vfWZ1bmN0aW9uIHJNZShlLG4pe3ZhciByLHQsbztmb3Iobz1uLWUueV8wLHQ9bmV3IFQoZS5zdGFja3MpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwzMTUpLEo3ZShyLHIueF8wLHIueV8wK28pO2UueV8wPW59ZnVuY3Rpb24gbFooZSxuKXt0aGlzLmNoaWxkcmVuPW5ldyBRLHRoaXMuc3RhY2tzPW5ldyBRLHRoaXMueV8wPWUsdGhpcy5ub2RlTm9kZVNwYWNpbmc9bn1wKDE4NiwxLHsxODY6MX0sbFopLGwuaGVpZ2h0PTAsbC5ub2RlTm9kZVNwYWNpbmc9MCxsLndpZHRoXzA9MCxsLnlfMD0wLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcucmVjdHBhY2tpbmcudXRpbCIsIlJlY3RSb3ciLDE4Nik7ZnVuY3Rpb24gdE1lKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQTtmb3IoXz1ocixkPWhyLHU9VnIsYz1WcixoPW5ldyBUKG4udmVydGljZXMpO2guaTxoLnRoaXMkMDEuYXJyYXkubGVuZ3RoOylmPWEoQyhoKSw2OCksbz1hKGEoS2UoZS5ub2RlTWFwLGYub3JpZ2luYWxWZXJ0ZXgpLDQyKS5zZWNvbmQsMjcpLF9sKG8sZi5yZWN0LnhfMCxmLnJlY3QueV8wKSxfPVMuTWF0aC5taW4oXyxvLnhfMCksZD1TLk1hdGgubWluKGQsby55XzApLHU9Uy5NYXRoLm1heCh1LG8ueF8wK28ud2lkdGhfMCksYz1TLk1hdGgubWF4KGMsby55XzArby5oZWlnaHQpO2ZvcihtPWEoVihlLmVsa0dyYXBoLChoVCgpLGtNZSkpLDEwNyksd2QoZS5lbGtHcmFwaCx1LV8rKG0ubGVmdCttLnJpZ2h0KSxjLWQrKG0udG9wXzArbS5ib3R0b20pLCEwLCEwKSxMZWUoZS5lbGtHcmFwaCwtXyttLmxlZnQsLWQrbS50b3BfMCksdD1uZXcgWWUoUiRlKGUuZWxrR3JhcGgpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KXI9YShlbih0KSw3NCkscz1GZyhyLCEwLCEwKSx5PVd1KHIpLHY9WjAociksRT1uZXcgWSh5LnhfMCt5LndpZHRoXzAvMix5LnlfMCt5LmhlaWdodC8yKSxpPW5ldyBZKHYueF8wK3Yud2lkdGhfMC8yLHYueV8wK3YuaGVpZ2h0LzIpLHg9cnQobmV3IFkoaS54XzAsaS55XzApLEUpLFN3KHgseS53aWR0aF8wLHkuaGVpZ2h0KSxLbihFLHgpLEE9cnQobmV3IFkoRS54XzAsRS55XzApLGkpLFN3KEEsdi53aWR0aF8wLHYuaGVpZ2h0KSxLbihpLEEpLG5iKHMsRS54XzAsRS55XzApLGViKHMsaS54XzAsaS55XzApfWZ1bmN0aW9uIG9NZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscTtzd2l0Y2goZS5lbGtHcmFwaD1uLGUubm9kZU1hcD1uZXcgc24scj0oRWQoKSxuZXcgdmQoZS5lbGtHcmFwaCkpLHQ9bmV3IE94KHIpLEJIKHQpLGs9eG4oVihlLmVsa0dyYXBoLChoVCgpLHdaKSkpLGM9YShWKGUuZWxrR3JhcGgsJE0pLDMyNCksSD1hKFYoZS5lbGtHcmFwaCxCTSksNDM3KSxzPWEoVihlLmVsa0dyYXBoLGhaKSw0OTApLE09YShWKGUuZWxrR3JhcGgsek0pLDQzOCksZS5zcGFjaW5nTm9kZU5vZGU9UigkKFYoZS5lbGtHcmFwaCxPTWUpKSksdT1lLmNlbnRlckRpc3RhbmNlLGMub3JkaW5hbCl7Y2FzZSAwOnU9ZS5jZW50ZXJEaXN0YW5jZTticmVhaztjYXNlIDE6dT1lLmNpcmNsZVVuZGVybGFwO2JyZWFrO2Nhc2UgMjp1PWUucmVjdGFuZ2xlVW5kZXJsYXA7YnJlYWs7Y2FzZSAzOnU9ZS5pbnZlcnRlZE92ZXJsYXA7YnJlYWs7Y2FzZSA0OnU9ZS5taW5pbXVtUm9vdERpc3RhbmNlO2JyZWFrO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgIisoYy5uYW1lXzAhPW51bGw/Yy5uYW1lXzA6IiIrYy5vcmRpbmFsKSkpfWlmKGUuZ3JhcGhfMD1uZXcgaE1lKHUsSCxzKSxqKGUuZ3JhcGhfMCwoTHkoKSxkRSksaWUoVihlLmVsa0dyYXBoLExNZSkpKSxlLmdyYXBoXzAub3J0aG9nb25hbENvbXBhY3Rpb249YWUoaWUoVihlLmVsa0dyYXBoLG1aKSkpLFVBKGUuZWxrR3JhcGgpLnNpemVfMD09MClyZXR1cm4gZS5ncmFwaF8wO2ZvcihmPW5ldyBZZShVQShlLmVsa0dyYXBoKSk7Zi5jdXJzb3IhPWYudGhpcyQwMV8yLnNpemVfMSgpOyl7Zm9yKGQ9YShlbihmKSwyNyksbT1kLndpZHRoXzAvMixoPWQuaGVpZ2h0LzIscT1uZXcgWShkLnhfMCttLGQueV8wK2gpO3lpKGUubm9kZU1hcCxxKTspbWQocSwoUy5NYXRoLnJhbmRvbSgpLS41KSpacywoUy5NYXRoLnJhbmRvbSgpLS41KSpacyk7RT1hKFYoZCwoRm4oKSxidykpLDE0MCksdj1uZXcgcWdlKHEsbmV3IHRsKHEueF8wLW0tZS5zcGFjaW5nTm9kZU5vZGUvMi1FLmxlZnQscS55XzAtaC1lLnNwYWNpbmdOb2RlTm9kZS8yLUUudG9wXzAsZC53aWR0aF8wK2Uuc3BhY2luZ05vZGVOb2RlKyhFLmxlZnQrRS5yaWdodCksZC5oZWlnaHQrZS5zcGFjaW5nTm9kZU5vZGUrKEUudG9wXzArRS5ib3R0b20pKSksZWUoZS5ncmFwaF8wLnZlcnRpY2VzLHYpLEJuKGUubm9kZU1hcCxxLG5ldyBacih2LGQpKX1zd2l0Y2goTS5vcmRpbmFsKXtjYXNlIDA6aWYoaz09bnVsbCllLmdyYXBoXzAucHJlZmVycmVkUm9vdD1hKGxlKGUuZ3JhcGhfMC52ZXJ0aWNlcywwKSw2OCk7ZWxzZSBmb3IoQT1uZXcgVChlLmdyYXBoXzAudmVydGljZXMpO0EuaTxBLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl2PWEoQyhBKSw2OCkseT1hKGEoS2UoZS5ub2RlTWFwLHYub3JpZ2luYWxWZXJ0ZXgpLDQyKS5zZWNvbmQsMjcpLmdldElkZW50aWZpZXIoKSx5IT1udWxsJiZUZSh5LGspJiYoZS5ncmFwaF8wLnByZWZlcnJlZFJvb3Q9dik7YnJlYWs7Y2FzZSAxOmZvcihvPW5ldyBZKGUuZWxrR3JhcGgud2lkdGhfMCxlLmVsa0dyYXBoLmhlaWdodCksby54XzAqPS41LG8ueV8wKj0uNSxtZChvLGUuZWxrR3JhcGgueF8wLGUuZWxrR3JhcGgueV8wKSxpPWhyLHg9bmV3IFQoZS5ncmFwaF8wLnZlcnRpY2VzKTt4Lmk8eC50aGlzJDAxLmFycmF5Lmxlbmd0aDspdj1hKEMoeCksNjgpLF89VTAodi5vcmlnaW5hbFZlcnRleCxvKSxfPGkmJihpPV8sZS5ncmFwaF8wLnByZWZlcnJlZFJvb3Q9dik7YnJlYWs7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiTm8gaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlIGZvciAiKyhNLm5hbWVfMCE9bnVsbD9NLm5hbWVfMDoiIitNLm9yZGluYWwpKSl9cmV0dXJuIGUuZ3JhcGhfMH1mdW5jdGlvbiBTd24oZSxuKXtyZXR1cm4gUy5NYXRoLm1pbihVMChuLnUsZS5ncmFwaF8wLnByZWZlcnJlZFJvb3QudmVydGV4KSxVMChuLnYsZS5ncmFwaF8wLnByZWZlcnJlZFJvb3QudmVydGV4KSl9ZnVuY3Rpb24gQ3duKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKGEoS2UoZS5ub2RlTWFwLG4udSksNDIpLmZpcnN0LDY4KSx0PWEoYShLZShlLm5vZGVNYXAsbi52KSw0MikuZmlyc3QsNjgpLFUwKG4udSxuLnYpLVUwKG4udSxlUShyLnJlY3QpKS1VMChuLnYsZVEodC5yZWN0KSl9ZnVuY3Rpb24gVHduKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKGEoS2UoZS5ub2RlTWFwLG4udSksNDIpLmZpcnN0LDY4KSx0PWEoYShLZShlLm5vZGVNYXAsbi52KSw0MikuZmlyc3QsNjgpLFZnZShyLHQpfWZ1bmN0aW9uIGJ3bihlLG4pe3ZhciByLHQsbyxpLHMsdTtyZXR1cm4gdD1hKGEoS2UoZS5ub2RlTWFwLG4udSksNDIpLmZpcnN0LDY4KSxvPWEoYShLZShlLm5vZGVNYXAsbi52KSw0MikuZmlyc3QsNjgpLGk9dC5yZWN0LHM9by5yZWN0LHI9JDJuKGkscykscj49MD9yOih1PUR2KHJ0KG5ldyBZKHMueF8wK3Mud2lkdGhfMC8yLHMueV8wK3MuaGVpZ2h0LzIpLG5ldyBZKGkueF8wK2kud2lkdGhfMC8yLGkueV8wK2kuaGVpZ2h0LzIpKSksLShRZ2UoaSxzKS0xKSp1KX1mdW5jdGlvbiBJd24oZSxuKXt2YXIgcix0LG8saTtmb3IoaT1uZXcgc24sbi50RWRnZXM9bnVsbCxuLnRyZWU9bnVsbCx0PW5ldyBUKG4udmVydGljZXMpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSw2OCksbz1hKEtlKGUubm9kZU1hcCxyLm9yaWdpbmFsVmVydGV4KSw0Miksci5vcmlnaW5hbFZlcnRleD1xTihyLnJlY3QpLEJuKGksci5vcmlnaW5hbFZlcnRleCxvKTtlLm5vZGVNYXA9aX1mdW5jdGlvbiBzWigpe3RoaXMuY2VudGVyRGlzdGFuY2U9bmV3IGlNZSx0aGlzLm1pbmltdW1Sb290RGlzdGFuY2U9bmV3IGFNZSh0aGlzKSx0aGlzLmNpcmNsZVVuZGVybGFwPW5ldyBsTWUodGhpcyksdGhpcy5yZWN0YW5nbGVVbmRlcmxhcD1uZXcgc01lKHRoaXMpLHRoaXMuaW52ZXJ0ZWRPdmVybGFwPW5ldyB1TWUodGhpcyl9cCg3NjMsMSx7fSxzWiksbC5zcGFjaW5nTm9kZU5vZGU9MCxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlciIsNzYzKTtmdW5jdGlvbiBpTWUoKXt9cCgxMjA5LDEse30saU1lKSxsLmNvc3Q9ZnVuY3Rpb24obil7cmV0dXJuIFUwKG4udSxuLnYpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkMCRUeXBlIiwxMjA5KTtmdW5jdGlvbiBhTWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEyMTAsMSx7fSxhTWUpLGwuY29zdD1mdW5jdGlvbihuKXtyZXR1cm4gU3duKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkMSRUeXBlIiwxMjEwKTtmdW5jdGlvbiBsTWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEyMTEsMSx7fSxsTWUpLGwuY29zdD1mdW5jdGlvbihuKXtyZXR1cm4gQ3duKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkMiRUeXBlIiwxMjExKTtmdW5jdGlvbiBzTWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEyMTIsMSx7fSxzTWUpLGwuY29zdD1mdW5jdGlvbihuKXtyZXR1cm4gVHduKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkMyRUeXBlIiwxMjEyKTtmdW5jdGlvbiB1TWUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEyMTMsMSx7fSx1TWUpLGwuY29zdD1mdW5jdGlvbihuKXtyZXR1cm4gYnduKHRoaXMuJCRvdXRlcl8wLG4pfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiRWxrR3JhcGhJbXBvcnRlci9sYW1iZGEkNCRUeXBlIiwxMjEzKTtmdW5jdGlvbiBjTWUoKXt0aGlzLmFsZ29yaXRobUFzc2VtYmxlcj1uZXcgQXYoa00pfWZ1bmN0aW9uIHh3bihlLG4scil7cmV0dXJuIFlyKGUsbmV3IFBoKG4ub3JpZ2luYWxWZXJ0ZXgsci5vcmlnaW5hbFZlcnRleCkpfXAoMTExNSwyMDUsZ18sY01lKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seTtmb3IoV3MobiwoaFQoKSxHTikpJiYoeT14bihWKG4sKEhNKCksQVopKSkscz1XTSh2dygpLHkpLHMmJih1PWEoWVQocy5wcm92aWRlclBvb2wpLDIwNSksdS5sYXlvdXQobixyLnN1YlRhc2soMSkpKSksbnIobix6TSwoZlQoKSxCTikpLG5yKG4sJE0sKHBUKCksRk0pKSxucihuLEJNLCh5VCgpLEhOKSksYz1hKFYobiwoSE0oKSx4WikpLDE3KS52YWx1ZV8wLHIuYmVnaW4oIk92ZXJsYXAgcmVtb3ZhbCIsMSksYWUoaWUoVihuLFlNZSkpKSxfPW5ldyBCcixkPW5ldyBfTWUoXyksbz1uZXcgc1osdD1vTWUobyxuKSxmPSEwLGk9MDtpPGMmJmY7KXtpZihhZShpZShWKG4sUFopKSkpe2lmKF8ubWFwXzAuY2xlYXJfMCgpLF90bihuZXcgWWdlKGQpLHQudmVydGljZXMpLF8ubWFwXzAuc2l6ZV8xKCk9PTApYnJlYWs7dC50RWRnZXM9X31mb3IodlQodGhpcy5hbGdvcml0aG1Bc3NlbWJsZXIpLGdzKHRoaXMuYWxnb3JpdGhtQXNzZW1ibGVyLChkVCgpLFJOKSwoTnYoKSxtVCkpLGdzKHRoaXMuYWxnb3JpdGhtQXNzZW1ibGVyLEROLHQudHJlZUNvbnN0cnVjdGlvblN0cmF0ZWd5KSxncyh0aGlzLmFsZ29yaXRobUFzc2VtYmxlcixGTiwoJE4oKSxNTSkpLHRoaXMuYWxnb3JpdGhtPUVUKHRoaXMuYWxnb3JpdGhtQXNzZW1ibGVyLHQpLG09bmV3IFQodGhpcy5hbGdvcml0aG0pO20uaTxtLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyloPWEoQyhtKSw0NyksaC5wcm9jZXNzKHQsci5zdWJUYXNrKDEpKTtJd24obyx0KSxmPWFlKGllKHcodCwoTHkoKSxfVSkpKSksKytpfXRNZShvLHQpLHIuZG9uZV8xKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUiLCJPdmVybGFwUmVtb3ZhbExheW91dFByb3ZpZGVyIiwxMTE1KTtmdW5jdGlvbiBQd24oZSxuLHIpe3h3bihlLm92ZXJsYXBFZGdlc18wLG4scil9ZnVuY3Rpb24gX01lKGUpe3RoaXMub3ZlcmxhcEVkZ2VzXzA9ZX1wKDExMTYsMSx7fSxfTWUpLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUiLCJPdmVybGFwUmVtb3ZhbExheW91dFByb3ZpZGVyL2xhbWJkYSQwJFR5cGUiLDExMTYpO2Z1bmN0aW9uIGRUKCl7ZFQ9RixSTj1uZXcgTE0oIlAxX1NUUlVDVFVSRSIsMCksRE49bmV3IExNKCJQMl9QUk9DRVNTSU5HX09SREVSIiwxKSxGTj1uZXcgTE0oIlAzX0VYRUNVVElPTiIsMil9ZnVuY3Rpb24gTE0oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBOd24oZSl7cmV0dXJuIGRUKCksd24oKGRNZSgpLGZNZSksZSl9ZnVuY3Rpb24gQXduKCl7cmV0dXJuIGRUKCksUChJKGtNLDEpLFcsNDQ0LDAsW1JOLEROLEZOXSl9cCg0NDQsMjIsezM6MSwzNDoxLDIyOjEsNDQ0OjF9LExNKTt2YXIgUk4sRE4sRk4sa009Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUiLCJTUE9yRVBoYXNlcyIsNDQ0LGduLEF3bixOd24pO2Z1bmN0aW9uIGRNZSgpe2RNZT1GLGZNZT15bigoZFQoKSxQKEkoa00sMSksVyw0NDQsMCxbUk4sRE4sRk5dKSkpfXZhciBmTWU7ZnVuY3Rpb24gTHduKGUsbixyKXt2YXIgdCxvO2lmKHZUKGUuYWxnb3JpdGhtQXNzZW1ibGVyKSxncyhlLmFsZ29yaXRobUFzc2VtYmxlciwoZFQoKSxSTiksKE52KCksbVQpKSxncyhlLmFsZ29yaXRobUFzc2VtYmxlcixETixuLnRyZWVDb25zdHJ1Y3Rpb25TdHJhdGVneSksZ3MoZS5hbGdvcml0aG1Bc3NlbWJsZXIsRk4sbi5jb21wYWN0aW9uU3RyYXRlZ3kpLGUuYWxnb3JpdGhtPUVUKGUuYWxnb3JpdGhtQXNzZW1ibGVyLG4pLHIuYmVnaW4oIkNvbXBhY3Rpb24gYnkgc2hyaW5raW5nIGEgdHJlZSIsZS5hbGdvcml0aG0uYXJyYXkubGVuZ3RoKSxuLnZlcnRpY2VzLmFycmF5Lmxlbmd0aD4xKWZvcihvPW5ldyBUKGUuYWxnb3JpdGhtKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksNDcpLHQucHJvY2VzcyhuLHIuc3ViVGFzaygxKSk7ci5kb25lXzEoKX1mdW5jdGlvbiBwTWUoKXt0aGlzLmFsZ29yaXRobUFzc2VtYmxlcj1uZXcgQXYoa00pfXAoMTIxOSwxLHt9LHBNZSksZygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZSIsIlNocmlua1RyZWUiLDEyMTkpO2Z1bmN0aW9uIGdNZSgpe3RoaXMuc2hyaW5rdHJlZT1uZXcgcE1lfXAoMTExNywyMDUsZ18sZ01lKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7V3MobiwoaFQoKSxHTikpJiYodT14bihWKG4sR04pKSxpPVdNKHZ3KCksdSksaSYmKHM9YShZVChpLnByb3ZpZGVyUG9vbCksMjA1KSxzLmxheW91dChuLHIuc3ViVGFzaygxKSkpKSxvPW5ldyBzWix0PW9NZShvLG4pLEx3bih0aGlzLnNocmlua3RyZWUsdCxyLnN1YlRhc2soMSkpLHRNZShvLHQpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlIiwiU2hyaW5rVHJlZUxheW91dFByb3ZpZGVyIiwxMTE3KTtmdW5jdGlvbiBoTWUoZSxuLHIpe3RoaXMudmVydGljZXM9bmV3IFEsdGhpcy5jb3N0RnVuY3Rpb249ZSx0aGlzLnRyZWVDb25zdHJ1Y3Rpb25TdHJhdGVneT1uLHRoaXMuY29tcGFjdGlvblN0cmF0ZWd5PXJ9cCgzMDYsMTM3LHszOjEsMzA2OjEsOTY6MSwxMzc6MX0saE1lKSxsLm9ydGhvZ29uYWxDb21wYWN0aW9uPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUuZ3JhcGgiLCJHcmFwaCIsMzA2KTtmdW5jdGlvbiB6Tigpe3pOPUYsT009bmV3IHlNZX1mdW5jdGlvbiBtTWUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgZlJlO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgIisoZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsKSkpfX1mdW5jdGlvbiB5TWUoKXttbi5jYWxsKHRoaXMsIkRFUFRIX0ZJUlNUIiwwKX1mdW5jdGlvbiBrd24oZSl7cmV0dXJuIHpOKCksd24oKHdNZSgpLEVNZSksZSl9ZnVuY3Rpb24gT3duKCl7cmV0dXJuIHpOKCksUChJKHVaLDEpLFcsNDkwLDAsW09NXSl9cCg0OTAsMjIsezM6MSwzNDoxLDIyOjEsNDkwOjEsMTg4OjEsMTk2OjF9LHlNZSksbC5jcmVhdGVfMT1mdW5jdGlvbigpe3JldHVybiBtTWUodGhpcyl9LGwuY3JlYXRlXzI9ZnVuY3Rpb24oKXtyZXR1cm4gbU1lKHRoaXMpfTt2YXIgT00sdVo9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUub3B0aW9ucyIsIkNvbXBhY3Rpb25TdHJhdGVneSIsNDkwLGduLE93bixrd24pO2Z1bmN0aW9uIHdNZSgpe3dNZT1GLEVNZT15bigoek4oKSxQKEkodVosMSksVyw0OTAsMCxbT01dKSkpfXZhciBFTWU7ZnVuY3Rpb24gJE4oKXskTj1GLE1NPW5ldyB2TWV9ZnVuY3Rpb24gdk1lKCl7bW4uY2FsbCh0aGlzLCJHUk9XX1RSRUUiLDApfWZ1bmN0aW9uIE13bihlKXtyZXR1cm4gJE4oKSx3bigoQ01lKCksVE1lKSxlKX1mdW5jdGlvbiBSd24oKXtyZXR1cm4gJE4oKSxQKEkoU01lLDEpLFcsNTU4LDAsW01NXSl9cCg1NTgsMjIsezM6MSwzNDoxLDIyOjEsNTU4OjEsMTg4OjEsMTk2OjF9LHZNZSksbC5jcmVhdGVfMT1mdW5jdGlvbigpe3JldHVybiBuZXcgRFp9LGwuY3JlYXRlXzI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERafTt2YXIgTU0sU01lPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLm9wdGlvbnMiLCJPdmVybGFwUmVtb3ZhbFN0cmF0ZWd5Iiw1NTgsZ24sUnduLE13bik7ZnVuY3Rpb24gQ01lKCl7Q01lPUYsVE1lPXluKCgkTigpLFAoSShTTWUsMSksVyw1NTgsMCxbTU1dKSkpfXZhciBUTWU7ZnVuY3Rpb24gZlQoKXtmVD1GLFJNPW5ldyBjWigiRklYRUQiLDApLEJOPW5ldyBjWigiQ0VOVEVSX05PREUiLDEpfWZ1bmN0aW9uIGNaKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gRHduKGUpe3JldHVybiBmVCgpLHduKChiTWUoKSxJTWUpLGUpfWZ1bmN0aW9uIEZ3bigpe3JldHVybiBmVCgpLFAoSShfWiwxKSxXLDQzOCwwLFtSTSxCTl0pfXAoNDM4LDIyLHszOjEsMzQ6MSwyMjoxLDQzODoxfSxjWik7dmFyIEJOLFJNLF9aPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLm9wdGlvbnMiLCJSb290U2VsZWN0aW9uIiw0MzgsZ24sRnduLER3bik7ZnVuY3Rpb24gYk1lKCl7Yk1lPUYsSU1lPXluKChmVCgpLFAoSShfWiwxKSxXLDQzOCwwLFtSTSxCTl0pKSl9dmFyIElNZTtmdW5jdGlvbiBwVCgpe3BUPUYsZFo9bmV3IGdUKCJDRU5URVJfRElTVEFOQ0UiLDApLERNPW5ldyBnVCgiQ0lSQ0xFX1VOREVSTEFQIiwxKSxwWj1uZXcgZ1QoIlJFQ1RBTkdMRV9VTkRFUkxBUCIsMiksRk09bmV3IGdUKCJJTlZFUlRFRF9PVkVSTEFQIiwzKSxmWj1uZXcgZ1QoIk1JTklNVU1fUk9PVF9ESVNUQU5DRSIsNCl9ZnVuY3Rpb24gZ1QoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiB6d24oZSl7cmV0dXJuIHBUKCksd24oKHhNZSgpLFBNZSksZSl9ZnVuY3Rpb24gJHduKCl7cmV0dXJuIHBUKCksUChJKGdaLDEpLFcsMzI0LDAsW2RaLERNLHBaLEZNLGZaXSl9cCgzMjQsMjIsezM6MSwzNDoxLDIyOjEsMzI0OjF9LGdUKTt2YXIgZFosRE0sRk0sZloscFosZ1o9Y24oIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUub3B0aW9ucyIsIlNwYW5uaW5nVHJlZUNvc3RGdW5jdGlvbiIsMzI0LGduLCR3bix6d24pO2Z1bmN0aW9uIHhNZSgpe3hNZT1GLFBNZT15bigocFQoKSxQKEkoZ1osMSksVywzMjQsMCxbZFosRE0scFosRk0sZlpdKSkpfXZhciBQTWU7ZnVuY3Rpb24gaFQoKXtoVD1GLEdOPShHTSgpLElaKSxCTT1qTWUsJE09V01lLHdaPUdNZSx6TT1VTWUseVo9bmV3IFcxKDgpLGtNZT1uZXcgeXQoKEZuKCksWmMpLHlaKSxPTWU9bmV3IHl0KHQxLDgpLE1NZT1UWixoWj1GTWUsbVo9ek1lLExNZT1uZXcgeXQoeFQsKHplKCksITEpKX1mdW5jdGlvbiBOTWUoZSl7aGQoZSxuZXcgSl8oZ2QoZGQocGQoZmQobmV3IFpfLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVDb21wYWN0aW9uIiksIkVMSyBTUE9yRSBDb21wYWN0aW9uIiksIlNocmlua1RyZWUgaXMgYSBjb21wYWN0aW9uIGFsZ29yaXRobSB0aGF0IG1haW50YWlucyB0aGUgdG9wb2xvZ3kgb2YgYSBsYXlvdXQuIFRoZSByZWxvY2F0aW9uIG9mIGRpYWdyYW0gZWxlbWVudHMgaXMgYmFzZWQgb24gY29udHJhY3RpbmcgYSBzcGFubmluZyB0cmVlLiIpLG5ldyBSTWUpKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVDb21wYWN0aW9uIiwib3JnLmVjbGlwc2UuZWxrLnVuZGVybHlpbmdMYXlvdXRBbGdvcml0aG0iLHRlKEdOKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVDb21wYWN0aW9uIiwib3JnLmVjbGlwc2UuZWxrLnByb2Nlc3NpbmdPcmRlci50cmVlQ29uc3RydWN0aW9uIix0ZShCTSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlQ29tcGFjdGlvbiIsIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIuc3Bhbm5pbmdUcmVlQ29zdEZ1bmN0aW9uIix0ZSgkTSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlQ29tcGFjdGlvbiIsIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucHJlZmVycmVkUm9vdCIsdGUod1opKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZUNvbXBhY3Rpb24iLCJvcmcuZWNsaXBzZS5lbGsucHJvY2Vzc2luZ09yZGVyLnJvb3RTZWxlY3Rpb24iLHRlKHpNKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVDb21wYWN0aW9uIiwib3JnLmVjbGlwc2UuZWxrLnBhZGRpbmciLHlaKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZUNvbXBhY3Rpb24iLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5ub2RlTm9kZSIsOCksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVDb21wYWN0aW9uIiwib3JnLmVjbGlwc2UuZWxrLnN0cnVjdHVyZS5zdHJ1Y3R1cmVFeHRyYWN0aW9uU3RyYXRlZ3kiLHRlKE1NZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlQ29tcGFjdGlvbiIsIm9yZy5lY2xpcHNlLmVsay5jb21wYWN0aW9uLmNvbXBhY3Rpb25TdHJhdGVneSIsdGUoaFopKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZUNvbXBhY3Rpb24iLCJvcmcuZWNsaXBzZS5lbGsuY29tcGFjdGlvbi5vcnRob2dvbmFsIix0ZShtWikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlQ29tcGFjdGlvbiIsIm9yZy5lY2xpcHNlLmVsay5kZWJ1Z01vZGUiLCh6ZSgpLCExKSl9ZnVuY3Rpb24gQU1lKCl7aFQoKX1wKDEwMTQsMSxwbCxBTWUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtOTWUobil9O3ZhciBoWixtWixMTWUsa01lLHlaLHdaLHpNLCRNLEJNLE9NZSxNTWUsR047Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5vcHRpb25zIiwiU3BvcmVDb21wYWN0aW9uT3B0aW9ucyIsMTAxNCk7ZnVuY3Rpb24gUk1lKCl7fXAoMTAxNSwxLHt9LFJNZSksbC5jcmVhdGVfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPW5ldyBnTWUsbn0sbC5kZXN0cm95PWZ1bmN0aW9uKG4pe30sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5vcHRpb25zIiwiU3BvcmVDb21wYWN0aW9uT3B0aW9ucy9TcG9yZUNvbXBhY3Rpb25GYWN0b3J5IiwxMDE1KTtmdW5jdGlvbiBHTSgpe0dNPUYsSVo9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsudW5kZXJseWluZ0xheW91dEFsZ29yaXRobSIpLGJaPShOdigpLG1UKSxUWj1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zdHJ1Y3R1cmUuc3RydWN0dXJlRXh0cmFjdGlvblN0cmF0ZWd5IixiWiksQ1o9KHlUKCksSE4pLGpNZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIudHJlZUNvbnN0cnVjdGlvbiIsQ1opLFNaPShwVCgpLERNKSxXTWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucHJvY2Vzc2luZ09yZGVyLnNwYW5uaW5nVHJlZUNvc3RGdW5jdGlvbiIsU1opLEdNZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucHJlZmVycmVkUm9vdCIsbnVsbCksdlo9KGZUKCksQk4pLFVNZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucm9vdFNlbGVjdGlvbiIsdlopLEVaPSh6TigpLE9NKSxGTWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuY29tcGFjdGlvbi5jb21wYWN0aW9uU3RyYXRlZ3kiLEVaKSx6TWU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuY29tcGFjdGlvbi5vcnRob2dvbmFsIiwoemUoKSwhMSkpLCRNZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5vdmVybGFwUmVtb3ZhbC5tYXhJdGVyYXRpb25zIixKKDY0KSksQk1lPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm92ZXJsYXBSZW1vdmFsLnJ1blNjYW5saW5lIiwhMCksSE1lPVJNfWZ1bmN0aW9uIERNZSgpe0dNKCl9cCg4NjYsMSxwbCxETWUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay51bmRlcmx5aW5nTGF5b3V0QWxnb3JpdGhtIiksIiIpLCJVbmRlcmx5aW5nIExheW91dCBBbGdvcml0aG0iKSwiQSBsYXlvdXQgYWxnb3JpdGhtIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgZ3JhcGggYmVmb3JlIGl0IGlzIGNvbXBhY3RlZC4gSWYgdGhpcyBpcyBudWxsLCBub3RoaW5nIGlzIGFwcGxpZWQgYmVmb3JlIGNvbXBhY3Rpb24uIiksKEpjKCksd2cpKSxzZSksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zdHJ1Y3R1cmUuc3RydWN0dXJlRXh0cmFjdGlvblN0cmF0ZWd5IiksInN0cnVjdHVyZSIpLCJTdHJ1Y3R1cmUgRXh0cmFjdGlvbiBTdHJhdGVneSIpLCJUaGlzIG9wdGlvbiBkZWZpbmVzIHdoYXQga2luZCBvZiB0cmlhbmd1bGF0aW9uIG9yIG90aGVyIHBhcnRpdGlvbmluZyBvZiB0aGUgcGxhbmUgaXMgYXBwbGllZCB0byB0aGUgdmVydGljZXMuIiksYlopLG1yKSxMWiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnByb2Nlc3NpbmdPcmRlci50cmVlQ29uc3RydWN0aW9uIiksInByb2Nlc3NpbmdPcmRlciIpLCJUcmVlIENvbnN0cnVjdGlvbiBTdHJhdGVneSIpLCJXaGV0aGVyIGEgbWluaW11bSBzcGFubmluZyB0cmVlIG9yIGEgbWF4aW11bSBzcGFubmluZyB0cmVlIHNob3VsZCBiZSBjb25zdHJ1Y3RlZC4iKSxDWiksbXIpLE1aKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucHJvY2Vzc2luZ09yZGVyLnNwYW5uaW5nVHJlZUNvc3RGdW5jdGlvbiIpLCJwcm9jZXNzaW5nT3JkZXIiKSwiQ29zdCBGdW5jdGlvbiBmb3IgU3Bhbm5pbmcgVHJlZSIpLCJUaGUgY29zdCBmdW5jdGlvbiBpcyB1c2VkIGluIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Bhbm5pbmcgdHJlZS4iKSxTWiksbXIpLGdaKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucHJvY2Vzc2luZ09yZGVyLnByZWZlcnJlZFJvb3QiKSwicHJvY2Vzc2luZ09yZGVyIiksIlJvb3Qgbm9kZSBmb3Igc3Bhbm5pbmcgdHJlZSBjb25zdHJ1Y3Rpb24iKSwiVGhlIGlkZW50aWZpZXIgb2YgdGhlIG5vZGUgdGhhdCBpcyBwcmVmZXJyZWQgYXMgdGhlIHJvb3Qgb2YgdGhlIHNwYW5uaW5nIHRyZWUuIElmIHRoaXMgaXMgbnVsbCwgdGhlIGZpcnN0IG5vZGUgaXMgY2hvc2VuLiIpLG51bGwpLHdnKSxzZSksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucHJlZmVycmVkUm9vdCIsIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucm9vdFNlbGVjdGlvbiIsSE1lKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5wcm9jZXNzaW5nT3JkZXIucm9vdFNlbGVjdGlvbiIpLCJwcm9jZXNzaW5nT3JkZXIiKSwiUm9vdCBzZWxlY3Rpb24gZm9yIHNwYW5uaW5nIHRyZWUiKSwiVGhpcyBzZXRzIHRoZSBtZXRob2QgdXNlZCB0byBzZWxlY3QgYSByb290IG5vZGUgZm9yIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSBzcGFubmluZyB0cmVlIiksdlopLG1yKSxfWiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmNvbXBhY3Rpb24uY29tcGFjdGlvblN0cmF0ZWd5IiksImNvbXBhY3Rpb24iKSwiQ29tcGFjdGlvbiBTdHJhdGVneSIpLCJUaGlzIG9wdGlvbiBkZWZpbmVzIGhvdyB0aGUgY29tcGFjdGlvbiBpcyBhcHBsaWVkLiIpLEVaKSxtciksdVopLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5jb21wYWN0aW9uLm9ydGhvZ29uYWwiKSwiY29tcGFjdGlvbiIpLCJPcnRob2dvbmFsIENvbXBhY3Rpb24iKSwiUmVzdHJpY3RzIHRoZSB0cmFuc2xhdGlvbiBvZiBub2RlcyB0byBvcnRob2dvbmFsIGRpcmVjdGlvbnMgaW4gdGhlIGNvbXBhY3Rpb24gcGhhc2UuIiksKHplKCksITEpKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5vdmVybGFwUmVtb3ZhbC5tYXhJdGVyYXRpb25zIiksIm92ZXJsYXBSZW1vdmFsIiksIlVwcGVyIGxpbWl0IGZvciBpdGVyYXRpb25zIG9mIG92ZXJsYXAgcmVtb3ZhbCIpLG51bGwpLEooNjQpKSxibyksdnQpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5vdmVybGFwUmVtb3ZhbC5ydW5TY2FubGluZSIpLCJvdmVybGFwUmVtb3ZhbCIpLCJXaGV0aGVyIHRvIHJ1biBhIHN1cHBsZW1lbnRhcnkgc2NhbmxpbmUgb3ZlcmxhcCBjaGVjay4iKSxudWxsKSwhMCksbnQpLEFyKSxFZShPZSkpKSksVk1lKChuZXcgcU1lLG4pKSxOTWUoKG5ldyBBTWUsbikpfTt2YXIgRk1lLEVaLHpNZSwkTWUsQk1lLEdNZSxITWUsVU1lLHZaLFdNZSxTWixqTWUsQ1osVFosYlosSVo7Zygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5vcHRpb25zIiwiU3BvcmVNZXRhRGF0YVByb3ZpZGVyIiw4NjYpO2Z1bmN0aW9uIEhNKCl7SE09RixBWj0oR00oKSxJWiksTlo9bmV3IFcxKDgpLG5ldyB5dCgoRm4oKSxaYyksTlopLG5ldyB5dCh0MSw4KSxLTWU9VFoseFo9JE1lLFBaPUJNZSxZTWU9bmV3IHl0KHhULCh6ZSgpLCExKSl9ZnVuY3Rpb24gVk1lKGUpe2hkKGUsbmV3IEpfKGdkKGRkKHBkKGZkKG5ldyBaXywib3JnLmVjbGlwc2UuZWxrLnNwb3JlT3ZlcmxhcCIpLCJFTEsgU1BPckUgT3ZlcmxhcCBSZW1vdmFsIiksJ0Egbm9kZSBvdmVybGFwIHJlbW92YWwgYWxnb3JpdGhtIHByb3Bvc2VkIGJ5IE5hY2htYW5zb24gZXQgYWwuIGluICJOb2RlIG92ZXJsYXAgcmVtb3ZhbCBieSBncm93aW5nIGEgdHJlZSIuJyksbmV3IFhNZSkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZU92ZXJsYXAiLCJvcmcuZWNsaXBzZS5lbGsudW5kZXJseWluZ0xheW91dEFsZ29yaXRobSIsdGUoQVopKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZU92ZXJsYXAiLCJvcmcuZWNsaXBzZS5lbGsucGFkZGluZyIsTlopLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlT3ZlcmxhcCIsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLm5vZGVOb2RlIiw4KSxaKGUsIm9yZy5lY2xpcHNlLmVsay5zcG9yZU92ZXJsYXAiLCJvcmcuZWNsaXBzZS5lbGsuc3RydWN0dXJlLnN0cnVjdHVyZUV4dHJhY3Rpb25TdHJhdGVneSIsdGUoS01lKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVPdmVybGFwIiwib3JnLmVjbGlwc2UuZWxrLm92ZXJsYXBSZW1vdmFsLm1heEl0ZXJhdGlvbnMiLHRlKHhaKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuc3BvcmVPdmVybGFwIiwib3JnLmVjbGlwc2UuZWxrLm92ZXJsYXBSZW1vdmFsLnJ1blNjYW5saW5lIix0ZShQWikpLFooZSwib3JnLmVjbGlwc2UuZWxrLnNwb3JlT3ZlcmxhcCIsIm9yZy5lY2xpcHNlLmVsay5kZWJ1Z01vZGUiLCh6ZSgpLCExKSl9ZnVuY3Rpb24gcU1lKCl7SE0oKX1wKDEwMTIsMSxwbCxxTWUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtWTWUobil9O3ZhciBZTWUseFosUFosTlosS01lLEFaO2coIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUub3B0aW9ucyIsIlNwb3JlT3ZlcmxhcFJlbW92YWxPcHRpb25zIiwxMDEyKTtmdW5jdGlvbiBYTWUoKXt9cCgxMDEzLDEse30sWE1lKSxsLmNyZWF0ZV8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IGNNZSxufSxsLmRlc3Ryb3k9ZnVuY3Rpb24obil7fSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLm9wdGlvbnMiLCJTcG9yZU92ZXJsYXBSZW1vdmFsT3B0aW9ucy9TcG9yZU92ZXJsYXBGYWN0b3J5IiwxMDEzKTtmdW5jdGlvbiBOdigpe052PUYsbVQ9bmV3IFpNZX1mdW5jdGlvbiBKTWUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgb1JlO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgIisoZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsKSkpfX1mdW5jdGlvbiBaTWUoKXttbi5jYWxsKHRoaXMsIkRFTEFVTkFZX1RSSUFOR1VMQVRJT04iLDApfWZ1bmN0aW9uIEJ3bihlKXtyZXR1cm4gTnYoKSx3bigoUU1lKCksZVJlKSxlKX1mdW5jdGlvbiBHd24oKXtyZXR1cm4gTnYoKSxQKEkoTFosMSksVyw1MzksMCxbbVRdKX1wKDUzOSwyMix7MzoxLDM0OjEsMjI6MSw1Mzk6MSwxODg6MSwxOTY6MX0sWk1lKSxsLmNyZWF0ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIEpNZSh0aGlzKX0sbC5jcmVhdGVfMj1mdW5jdGlvbigpe3JldHVybiBKTWUodGhpcyl9O3ZhciBtVCxMWj1jbigib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5vcHRpb25zIiwiU3RydWN0dXJlRXh0cmFjdGlvblN0cmF0ZWd5Iiw1MzksZ24sR3duLEJ3bik7ZnVuY3Rpb24gUU1lKCl7UU1lPUYsZVJlPXluKChOdigpLFAoSShMWiwxKSxXLDUzOSwwLFttVF0pKSl9dmFyIGVSZTtmdW5jdGlvbiB5VCgpe3lUPUYsSE49bmV3IGtaKCJNSU5JTVVNX1NQQU5OSU5HX1RSRUUiLDApLE9aPW5ldyBrWigiTUFYSU1VTV9TUEFOTklOR19UUkVFIiwxKX1mdW5jdGlvbiBuUmUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAwOnJldHVybiBuZXcgUlo7Y2FzZSAxOnJldHVybiBuZXcgc1JlO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIk5vIGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZSBmb3IgIisoZS5uYW1lXzAhPW51bGw/ZS5uYW1lXzA6IiIrZS5vcmRpbmFsKSkpfX1mdW5jdGlvbiBrWihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEh3bihlKXtyZXR1cm4geVQoKSx3bigoclJlKCksdFJlKSxlKX1mdW5jdGlvbiBVd24oKXtyZXR1cm4geVQoKSxQKEkoTVosMSksVyw0MzcsMCxbSE4sT1pdKX1wKDQzNywyMix7MzoxLDM0OjEsMjI6MSw0Mzc6MSwxODg6MSwxOTY6MX0sa1opLGwuY3JlYXRlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gblJlKHRoaXMpfSxsLmNyZWF0ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIG5SZSh0aGlzKX07dmFyIE9aLEhOLE1aPWNuKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLm9wdGlvbnMiLCJUcmVlQ29uc3RydWN0aW9uU3RyYXRlZ3kiLDQzNyxnbixVd24sSHduKTtmdW5jdGlvbiByUmUoKXtyUmU9Rix0UmU9eW4oKHlUKCksUChJKE1aLDEpLFcsNDM3LDAsW0hOLE9aXSkpKX12YXIgdFJlO2Z1bmN0aW9uIFd3bihlLG4pe3ZhciByO24uYmVnaW4oIkRlbGF1bmF5IHRyaWFuZ3VsYXRpb24iLDEpLHI9bmV3IFEsd2koZS52ZXJ0aWNlcyxuZXcgaVJlKHIpKSxhZShpZSh3KGUsKEx5KCksZEUpKSkpLGUudEVkZ2VzP2Z0KGUudEVkZ2VzLFRkZShyKSk6ZS50RWRnZXM9VGRlKHIpLG4uZG9uZV8xKCl9ZnVuY3Rpb24gb1JlKCl7fXAoMTQ2MywxLFd0LG9SZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzA2KSxuZXcgSHJ9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe1d3bihhKG4sMzA2KSxyKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5wMXN0cnVjdHVyZSIsIkRlbGF1bmF5VHJpYW5ndWxhdGlvblBoYXNlIiwxNDYzKTtmdW5jdGlvbiBpUmUoZSl7dGhpcy52ZXJ0aWNlc18wPWV9cCgxNDY0LDEsSmUsaVJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtlZSh0aGlzLnZlcnRpY2VzXzAsYShuLDY4KS5vcmlnaW5hbFZlcnRleCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUucDFzdHJ1Y3R1cmUiLCJEZWxhdW5heVRyaWFuZ3VsYXRpb25QaGFzZS9sYW1iZGEkMCRUeXBlIiwxNDY0KTtmdW5jdGlvbiBhUmUoZSxuLHIpe3ZhciB0LG8saTtmb3IoaT1uZXcgVChyLmNoaWxkcmVuKTtpLmk8aS50aGlzJDAxLmFycmF5Lmxlbmd0aDspbz1hKEMoaSksMjI1KSx0PW5ldyBUeChhKEtlKGUubm9kZU1hcCxvLm5vZGUpLDY4KSksZWUobi5jaGlsZHJlbix0KSxhUmUoZSx0LG8pfWZ1bmN0aW9uIGxSZShlLG4scil7dmFyIHQ7WmkoZS5ub2RlTWFwKSx3aShyLnZlcnRpY2VzLG5ldyBjUmUoZSkpLHQ9bmV3IFR4KGEoS2UoZS5ub2RlTWFwLG4ubm9kZSksNjgpKSxhUmUoZSx0LG4pLHIudHJlZT10fWZ1bmN0aW9uIGp3bihlLG4pe3JldHVybiBCbihlLm5vZGVNYXAsbi5vcmlnaW5hbFZlcnRleCxuKX1mdW5jdGlvbiBSWigpe3RoaXMubm9kZU1hcD1uZXcgc259cCg3OTQsMSxXdCxSWiksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzA2KSxuZXcgSHJ9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe3RoaXMucHJvY2Vzc18xKGEobiwzMDYpLHIpfSxsLnByb2Nlc3NfMT1mdW5jdGlvbihuLHIpe3ZhciB0LG8saTtyLmJlZ2luKCJNaW5pbXVtIHNwYW5uaW5nIHRyZWUgY29uc3RydWN0aW9uIiwxKSxuLnByZWZlcnJlZFJvb3Q/bz1uLnByZWZlcnJlZFJvb3Qub3JpZ2luYWxWZXJ0ZXg6bz1hKGxlKG4udmVydGljZXMsMCksNjgpLm9yaWdpbmFsVmVydGV4LGFlKGllKHcobiwoTHkoKSxkRSkpKSk/aT1GayhuLnRFZGdlcyxvLCh0PW4uY29zdEZ1bmN0aW9uLHQpKTppPUZrKG4udEVkZ2VzLG8sbi5jb3N0RnVuY3Rpb24pLGxSZSh0aGlzLGksbiksci5kb25lXzEoKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5wMnByb2Nlc3NpbmdvcmRlciIsIk1pblNUUGhhc2UiLDc5NCk7ZnVuY3Rpb24gc1JlKCl7UlouY2FsbCh0aGlzKX1mdW5jdGlvbiBWd24oZSxuKXtyZXR1cm4tZS5jb3N0RnVuY3Rpb24uY29zdChuKX1wKDE0NjYsNzk0LFd0LHNSZSksbC5wcm9jZXNzXzE9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscztyLmJlZ2luKCJNYXhpbXVtIHNwYW5uaW5nIHRyZWUgY29uc3RydWN0aW9uIiwxKSx0PW5ldyB1UmUobiksbi5wcmVmZXJyZWRSb290P2k9bi5wcmVmZXJyZWRSb290LnZlcnRleDppPWEobGUobi52ZXJ0aWNlcywwKSw2OCkudmVydGV4LGFlKGllKHcobiwoTHkoKSxkRSkpKSk/cz1GayhuLnRFZGdlcyxpLChvPXQsbykpOnM9Rmsobi50RWRnZXMsaSx0KSxsUmUodGhpcyxzLG4pLHIuZG9uZV8xKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUucDJwcm9jZXNzaW5nb3JkZXIiLCJNYXhTVFBoYXNlIiwxNDY2KTtmdW5jdGlvbiB1UmUoZSl7dGhpcy5ncmFwaF8wPWV9cCgxNDY3LDEse30sdVJlKSxsLmNvc3Q9ZnVuY3Rpb24obil7cmV0dXJuIFZ3bih0aGlzLmdyYXBoXzAsbil9LGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUucDJwcm9jZXNzaW5nb3JkZXIiLCJNYXhTVFBoYXNlL2xhbWJkYSQwJFR5cGUiLDE0NjcpO2Z1bmN0aW9uIGNSZShlKXt0aGlzLiQkb3V0ZXJfMD1lfXAoMTQ2NSwxLEplLGNSZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7anduKHRoaXMuJCRvdXRlcl8wLGEobiw2OCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLnAycHJvY2Vzc2luZ29yZGVyIiwiTWluU1RQaGFzZS9sYW1iZGEkMCRUeXBlIiwxNDY1KTtmdW5jdGlvbiBfUmUoZSxuKXtxd24oZSxlLnJvb3QsZS5zdmcpLGEoZS5yb290Lm5vZGUsNjgpLG4mJmEobi5ub2RlLDY4KS5yZWN0fWZ1bmN0aW9uIHF3bihlLG4scil7YShuLm5vZGUsNjgpLHdpKG4uY2hpbGRyZW4sbmV3IEZaKGUscixuKSl9ZnVuY3Rpb24gZFJlKGUsbil7dmFyIHIsdCxvO2Zvcih0PW5ldyBUKG4uY2hpbGRyZW4pO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwyMjUpLG04KGEoci5ub2RlLDY4KSxydChDdChhKG4ubm9kZSw2OCkudmVydGV4KSxhKG4ubm9kZSw2OCkub3JpZ2luYWxWZXJ0ZXgpKSxvPVFnZShhKG4ubm9kZSw2OCkucmVjdCxhKHIubm9kZSw2OCkucmVjdCksbz4xJiYoZS5vdmVybGFwc0V4aXN0ZWQ9ITApLHV0bihhKHIubm9kZSw2OCksS24oQ3QoYShuLm5vZGUsNjgpLnZlcnRleCkseXUocnQoQ3QoYShyLm5vZGUsNjgpLm9yaWdpbmFsVmVydGV4KSxhKG4ubm9kZSw2OCkub3JpZ2luYWxWZXJ0ZXgpLG8pKSksX1JlKGUsbiksZFJlKGUscil9ZnVuY3Rpb24gWXduKGUsbixyLHQpe2Eoci5ub2RlLDY4KSxhKHIubm9kZSw2OCksYSh0Lm5vZGUsNjgpLGEodC5ub2RlLDY4KSxhKHQubm9kZSw2OCksd2kodC5jaGlsZHJlbixuZXcgRlooZSxuLHQpKX1mdW5jdGlvbiBLd24oZSxuLHIpe3IuYmVnaW4oIkdyb3cgVHJlZSIsMSksZS5yb290PW4udHJlZSxhZShpZSh3KG4sKEx5KCksZEUpKSkpPyhlLnN2Zz1uZXcgcXgsX1JlKGUsbnVsbCkpOmUuc3ZnPW5ldyBxeCxlLm92ZXJsYXBzRXhpc3RlZD0hMSxkUmUoZSxuLnRyZWUpLGoobixfVSwoemUoKSwhIWUub3ZlcmxhcHNFeGlzdGVkKSksci5kb25lXzEoKX1mdW5jdGlvbiBEWigpe31wKDc5NiwxLFd0LERaKSxsLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb249ZnVuY3Rpb24obil7cmV0dXJuIGEobiwzMDYpLG5ldyBIcn0sbC5wcm9jZXNzPWZ1bmN0aW9uKG4scil7S3duKHRoaXMsYShuLDMwNikscil9LGwub3ZlcmxhcHNFeGlzdGVkPSExLGcoIm9yZy5lY2xpcHNlLmVsay5hbGcuc3BvcmUucDNleGVjdXRpb24iLCJHcm93VHJlZVBoYXNlIiw3OTYpO2Z1bmN0aW9uIEZaKGUsbixyKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuaW1nXzE9bix0aGlzLnRfMj1yfXAoNzk3LDEsSmUsRlopLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1l3bih0aGlzLiQkb3V0ZXJfMCx0aGlzLmltZ18xLHRoaXMudF8yLGEobiwyMjUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmFsZy5zcG9yZS5wM2V4ZWN1dGlvbiIsIkdyb3dUcmVlUGhhc2UvbGFtYmRhJDAkVHlwZSIsNzk3KTtmdW5jdGlvbiBYd24oZSxuKXt2YXIgcjtyPW5ldyBxeCxhKG4ubm9kZSw2OCksYShuLm5vZGUsNjgpLGEobi5ub2RlLDY4KSx3aShuLmNoaWxkcmVuLG5ldyB6WihlLHIsbikpfWZ1bmN0aW9uIEp3bihlLG4scix0KXt2YXIgbzthKHIubm9kZSw2OCksYShyLm5vZGUsNjgpLGEodC5ub2RlLDY4KSxhKHQubm9kZSw2OCksbz1ydChDdChhKHIubm9kZSw2OCkudmVydGV4KSxhKHQubm9kZSw2OCkudmVydGV4KSxYTihvLGpnZShhKHIubm9kZSw2OCksYSh0Lm5vZGUsNjgpLG8pKSxhKHQubm9kZSw2OCksYSh0Lm5vZGUsNjgpLGEodC5ub2RlLDY4KS52ZXJ0ZXgueF8wK28ueF8wLGEodC5ub2RlLDY4KS52ZXJ0ZXgueV8wK28ueV8wLGEodC5ub2RlLDY4KSx3aSh0LmNoaWxkcmVuLG5ldyB6WihlLG4sdCkpfWZ1bmN0aW9uIFp3bihlLG4scil7dmFyIHQ7ci5iZWdpbigiU2hyaW5raW5nIHRyZWUgY29tcGFjdGlvbiIsMSksYWUoaWUodyhuLChMeSgpLGRFKSkpKT8oWHduKGUsbi50cmVlKSx6Z2Uobi50cmVlLCh0PW4ub3J0aG9nb25hbENvbXBhY3Rpb24sdCkpKTp6Z2Uobi50cmVlLG4ub3J0aG9nb25hbENvbXBhY3Rpb24pLHIuZG9uZV8xKCl9ZnVuY3Rpb24gZlJlKCl7fXAoMTQ2OCwxLFd0LGZSZSksbC5nZXRMYXlvdXRQcm9jZXNzb3JDb25maWd1cmF0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBhKG4sMzA2KSxuZXcgSHJ9LGwucHJvY2Vzcz1mdW5jdGlvbihuLHIpe1p3bih0aGlzLGEobiwzMDYpLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLnAzZXhlY3V0aW9uIiwiU2hyaW5rVHJlZUNvbXBhY3Rpb25QaGFzZSIsMTQ2OCk7ZnVuY3Rpb24gelooZSxuLHIpe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5zdmdfMT1uLHRoaXMudF8yPXJ9cCg3OTUsMSxKZSx6WiksbC5hY2NlcHQ9ZnVuY3Rpb24obil7SnduKHRoaXMuJCRvdXRlcl8wLHRoaXMuc3ZnXzEsdGhpcy50XzIsYShuLDIyNSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuYWxnLnNwb3JlLnAzZXhlY3V0aW9uIiwiU2hyaW5rVHJlZUNvbXBhY3Rpb25QaGFzZS9sYW1iZGEkMCRUeXBlIiw3OTUpO3ZhciAkWj1Dcigib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIklHcmFwaEVsZW1lbnRWaXNpdG9yIik7ZnVuY3Rpb24gUWgoKXtRaD1GLGhSZT1uZXcgeVJlLGdSZT1uZXcgbVJlfWZ1bmN0aW9uIFF3bihlLG4pe3JldHVybiBlZShlLm9wdGlvbkZpbHRlcnMsbiksZX1mdW5jdGlvbiBlMm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztmb3IodT1lLm9wdGlvbkZpbHRlcnMscz0oci5wcm9wZXJ0eU1hcD9yLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDQ0KSx0PSFQeShKbihuZXcgU2UobnVsbCxuZXcgeGUodSwxNikpLG5ldyBieShuZXcgRVJlKG4saSkpKSkudHJ5QWR2YW5jZSgoTV8oKSxJaCkpLHQmJihjPWkuZ2V0VmFsdWUoKSxMKGMsNCkmJihvPW9yZShjKSxvIT1udWxsJiYoYz1vKSksbi5zZXRQcm9wZXJ0eShhKGkuZ2V0S2V5KCksMTQ5KSxjKSl9ZnVuY3Rpb24gVU0oZSxuKXt2YXIgcjtyZXR1cm4gcj1hKEtlKGUuY2xhc3NPcHRpb25NYXAsbiksMTM3KSxyfHwocj1uZXcgaDgsQm4oZS5jbGFzc09wdGlvbk1hcCxuLHIpKSxyfWZ1bmN0aW9uIG4ybihlLG4pe3ZhciByO3JldHVybiByPW5ldyBoOCxuJiZnbyhyLGEoS2UoZS5jbGFzc09wdGlvbk1hcCxLVCksOTYpKSxMKG4sNDIyKSYmZ28ocixhKEtlKGUuY2xhc3NPcHRpb25NYXAsWFQpLDk2KSksTChuLDM2Nik/KGdvKHIsYShLZShlLmNsYXNzT3B0aW9uTWFwLFF0KSw5NikpLHIpOihMKG4sODQpJiZnbyhyLGEoS2UoZS5jbGFzc09wdGlvbk1hcCxhbiksOTYpKSxMKG4sMjA3KT8oZ28ocixhKEtlKGUuY2xhc3NPcHRpb25NYXAsVW4pLDk2KSkscik6TChuLDE5Myk/KGdvKHIsYShLZShlLmNsYXNzT3B0aW9uTWFwLHVhKSw5NikpLHIpOihMKG4sMzI2KSYmZ28ocixhKEtlKGUuY2xhc3NPcHRpb25NYXAsTXIpLDk2KSkscikpfWZ1bmN0aW9uIHBSZSgpe1FoKCksdGhpcy5lbGVtZW50T3B0aW9uTWFwPW5ldyBzbix0aGlzLmNsYXNzT3B0aW9uTWFwPW5ldyBzbix0aGlzLm9wdGlvbkZpbHRlcnM9bmV3IFF9ZnVuY3Rpb24gcjJuKGUsbil7UWgoKTt2YXIgcix0O2lmKHI9ak0odncoKSxuLmdldElkKCkpLHIpe2lmKHQ9ci50YXJnZXRzLEwoZSwyMDcpKXJldHVybiBJdm4oYShlLDI3KSk/JGkodCwoaHMoKSxKcikpfHwkaSh0LE9lKTokaSh0LChocygpLEpyKSk7aWYoTChlLDMyNikpcmV0dXJuICRpKHQsKGhzKCksbXUpKTtpZihMKGUsMTkzKSlyZXR1cm4gJGkodCwoaHMoKSxRXykpO2lmKEwoZSwzNjYpKXJldHVybiAkaSh0LChocygpLFhjKSl9cmV0dXJuITB9ZnVuY3Rpb24gdDJuKGUsbixyKXtyZXR1cm4gUWgoKSxyLmFjY2VwdF8zKGUsYShuLmdldEtleSgpLDE0OSkpfXAoODcyLDEsezUzNjoxfSxwUmUpLGwudmlzaXQ9ZnVuY3Rpb24obil7dmFyIHI7cj1uMm4odGhpcyxuKSxnbyhyLGEoS2UodGhpcy5lbGVtZW50T3B0aW9uTWFwLG4pLDk2KSksZTJuKHRoaXMsbixyKX07dmFyIGdSZSxoUmU7Zygib3JnLmVjbGlwc2UuZWxrLmNvcmUiLCJMYXlvdXRDb25maWd1cmF0b3IiLDg3Mik7dmFyIG8ybj1Dcigib3JnLmVjbGlwc2UuZWxrLmNvcmUiLCJMYXlvdXRDb25maWd1cmF0b3IvSVByb3BlcnR5SG9sZGVyT3B0aW9uRmlsdGVyIik7ZnVuY3Rpb24gbVJlKCl7fXAoOTQ0LDEsezIwMzI6MX0sbVJlKSxsLmFjY2VwdF8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIFFoKCksIW4uaGFzUHJvcGVydHkocil9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlIiwiTGF5b3V0Q29uZmlndXJhdG9yL2xhbWJkYSQwJFR5cGUiLDk0NCk7ZnVuY3Rpb24geVJlKCl7fXAoOTQzLDEsezg0NToxfSx5UmUpLGwuYWNjZXB0XzQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gUWgoKSwhbi5oYXNQcm9wZXJ0eShyKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUiLCJMYXlvdXRDb25maWd1cmF0b3IvbGFtYmRhJDEkVHlwZSIsOTQzKTtmdW5jdGlvbiB3UmUoZSxuKXtyZXR1cm4gcjJuKGUsbil9ZnVuY3Rpb24gaTJuKCl7fXAoOTQ1LDEsezIwMzI6MX0saTJuKSxsLmFjY2VwdF8zPWZ1bmN0aW9uKG4scil7cmV0dXJuIHdSZShuLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZSIsIkxheW91dENvbmZpZ3VyYXRvci9sYW1iZGEkMiRUeXBlIiw5NDUpO2Z1bmN0aW9uIEVSZShlLG4pe3RoaXMuZWxlbWVudF8wPWUsdGhpcy5lbnRyeV8xPW59cCg5NDYsMSxJbixFUmUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiB0Mm4odGhpcy5lbGVtZW50XzAsdGhpcy5lbnRyeV8xLGEobiwyMDMyKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlIiwiTGF5b3V0Q29uZmlndXJhdG9yL2xhbWJkYSQzJFR5cGUiLDk0Nik7ZnVuY3Rpb24gdlJlKGUsbixyKXt2YXIgdCxvLGkscztmb3IoaT0oIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKS5zaXplXzAsbz1uZXcgWWUoKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikpO28uY3Vyc29yIT1vLnRoaXMkMDFfMi5zaXplXzEoKTspdD1hKGVuKG8pLDI3KSwoIXQuY2hpbGRyZW4mJih0LmNoaWxkcmVuPW5ldyBVKFVuLHQsMTAsMTEpKSx0LmNoaWxkcmVuKS5zaXplXzA9PTB8fChpKz12UmUoZSx0LCExKSk7aWYocilmb3Iocz15cihuKTtzOylpKz0oIXMuY2hpbGRyZW4mJihzLmNoaWxkcmVuPW5ldyBVKFVuLHMsMTAsMTEpKSxzLmNoaWxkcmVuKS5zaXplXzAscz15cihzKTtyZXR1cm4gaX1mdW5jdGlvbiBTUmUoZSxuKXt2YXIgcix0LG8saSxzO2ZvcihpPSghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pLnNpemVfMCxvPW5ldyBZZSgoIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKSk7by5jdXJzb3IhPW8udGhpcyQwMV8yLnNpemVfMSgpOyl0PWEoZW4obyksMjcpLEQoVih0LChGbigpLGJnKSkpIT09RCgocGMoKSxLdikpJiYocz1hKFYobixOZyksMTQzKSxyPWEoVih0LE5nKSwxNDMpLChzPT1yfHxzJiZVWihzLHIpKSYmKCF0LmNoaWxkcmVuJiYodC5jaGlsZHJlbj1uZXcgVShVbix0LDEwLDExKSksdC5jaGlsZHJlbikuc2l6ZV8wIT0wJiYoaSs9U1JlKGUsdCkpKTtyZXR1cm4gaX1mdW5jdGlvbiBDUmUoZSl7dmFyIG47RChWKGUsKEZuKCksYmcpKSk9PT1EKChwYygpLHVBKSkmJih5cihlKT8obj1hKFYoeXIoZSksYmcpLDM0NiksbnIoZSxiZyxuKSk6bnIoZSxiZyxLdikpfWZ1bmN0aW9uIFRSZShlLG4scil7dmFyIHQsbztvPWEoWVQobi5wcm92aWRlclBvb2wpLDIwNSk7dHJ5e28ubGF5b3V0KGUsciksR3plKG4ucHJvdmlkZXJQb29sLG8pfWNhdGNoKGkpe3Rocm93IGk9d3IoaSksTChpLDEwMyk/KHQ9aSxiKHQpKTpiKGkpfX1mdW5jdGlvbiBhMm4oZSl7dmFyIG4scix0O2lmKGFlKGllKFYoZSwoRm4oKSxQVCkpKSkpe2Zvcih0PW5ldyBRLHI9bmV3IFhlKFFlKEVjKGUpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspbj1hKHRuKHIpLDc0KSxiZChuKSYmYWUoaWUoVihuLGlSKSkpJiZSZSh0LmFycmF5LG4pO3JldHVybiB0fWVsc2UgcmV0dXJuIE5lKCksTmUoKSxPdH1mdW5jdGlvbiBsMm4oZSxuLHIpe3ZhciB0O3Q9dlJlKGUsbiwhMCksZXplKHIsIlJlY3Vyc2l2ZSBHcmFwaCBMYXlvdXQiLHQpLGJlZShuLFAoSSgkWiwxKSxNZSw1MzYsMCxbbmV3IHpSZV0pKSxXcyhuLChGbigpLE5nKSl8fGJlZShuLFAoSSgkWiwxKSxNZSw1MzYsMCxbbmV3IFZSZV0pKSxCWihlLG4sbnVsbCxyKSxuemUocil9ZnVuY3Rpb24gQlooZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam4sU3IsY2EsY28sV2EsSmcscDAsdHMsb3MscDEsTW0sZF8sUm0sdnUsWXUsJGQsRG0sWmcsU3UsZzEsVGM7aWYodC5pc0NhbmNlbGVkKCl8fGFlKGllKFYobiwoRm4oKSxyQSkpKSkpcmV0dXJuIE5lKCksTmUoKSxPdDtpZihuZT0oIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKS5zaXplXzAhPTAsd2U9YTJuKG4pLHZlPSF3ZS5pc0VtcHR5KCksbmV8fHZlKXtpZihvPWEoVihuLE5nKSwxNDMpLCFvKXRocm93IGIobmV3IEtjKCJSZXNvbHZlZCBhbGdvcml0aG0gaXMgbm90IHNldDsgYXBwbHkgYSBMYXlvdXRBbGdvcml0aG1SZXNvbHZlciBiZWZvcmUgY29tcHV0aW5nIGxheW91dC4iKSk7aWYoWmc9V1oobywoSHcoKSxLQSkpLENSZShuKSwhbmUmJnZlJiYhWmcpcmV0dXJuIE5lKCksTmUoKSxPdDtpZihrPW5ldyBRLEQoVihuLGJnKSk9PT1EKChwYygpLFFjKSkmJihXWihvLHFBKXx8V1oobyxWQSkpKXtpZihhZShpZShWKG4sSXcpKSkpdGhyb3cgYihuZXcgS2MoIlRvcGRvd24gbGF5b3V0IGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggaGllcmFyY2h5IGhhbmRsaW5nLiIpKTtmb3IoSmc9U1JlKGUsbikscDA9bmV3IHByLGZ0KHAwLCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pKTtwMC5zaXplXzAhPTA7KWNvPWEocDAuc2l6ZV8wPT0wP251bGw6KHJuKHAwLnNpemVfMCE9MCksWmEocDAscDAuaGVhZGVyLm5leHRfMCkpLDI3KSxDUmUoY28pLERtPUQoVihjbyxiZykpPT09RChLdiksRG18fFdzKGNvLFR3KSYmIVVaKG8sVihjbyxOZykpPyh2PUJaKGUsY28scix0KSxxcihrLHYpLG5yKGNvLGJnLEt2KSxUemUoY28pKTpmdChwMCwoIWNvLmNoaWxkcmVuJiYoY28uY2hpbGRyZW49bmV3IFUoVW4sY28sMTAsMTEpKSxjby5jaGlsZHJlbikpfWVsc2V7aWYoSmc9KCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikuc2l6ZV8wLGFlKGllKFYobixJdykpKSl7aWYoU3U9dC5zdWJUYXNrKDEpLFN1LmJlZ2luKCJUb3Bkb3duIExheW91dCIsMSksVihuLHVtKT09bnVsbCl0aHJvdyBiKG5ldyBLYyhuLmlkZW50aWZpZXIrIiBoYXMgbm90IGJlZW4gYXNzaWduZWQgYSB0b3AtZG93biBub2RlIHR5cGUuIikpO2lmKGEoVihuLHVtKSwyODApPT0ocG0oKSxLZil8fGEoVihuLHVtKSwyODApPT15QSlmb3IoQT1uZXcgWWUoKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikpO0EuY3Vyc29yIT1BLnRoaXMkMDFfMi5zaXplXzEoKTspeD1hKGVuKEEpLDI3KSxjYT1hKFYoeCxOZyksMTQzKSwoIXguY2hpbGRyZW4mJih4LmNoaWxkcmVuPW5ldyBVKFVuLHgsMTAsMTEpKSx4LmNoaWxkcmVuKS5zaXplXzA+MCYmWVQoY2EucHJvdmlkZXJQb29sKSxWKHgsWVEpIT1udWxsJiYodT1hKFYoeCxZUSksMzQ3KSwkZD11LmdldFNpemVfMCh4KSxSZyh4LFMuTWF0aC5tYXgoeC53aWR0aF8wLCRkLnhfMCksUy5NYXRoLm1heCh4LmhlaWdodCwkZC55XzApKSk7aWYodHM9YShWKG4sWmMpLDEwNyksbT1uLndpZHRoXzAtKHRzLmxlZnQrdHMucmlnaHQpLGg9bi5oZWlnaHQtKHRzLnRvcF8wK3RzLmJvdHRvbSksU3UubG9nXzAoIkF2YWlsYWJsZSBDaGlsZCBBcmVhOiAoIittKyJ8IitoKyIpIiksbnIobixTZyxtL2gpLFRSZShuLG8sdC5zdWJUYXNrKEpnKSksYShWKG4sdW0pLDI4MCk9PXlBJiYoeGVlKG4pLFJnKG4sdHMubGVmdCtSKCQoVihuLFRnKSkpK3RzLnJpZ2h0LHRzLnRvcF8wK1IoJChWKG4sQ2cpKSkrdHMuYm90dG9tKSksU3UubG9nXzAoIkV4ZWN1dGVkIGxheW91dCBhbGdvcml0aG06ICIreG4oVihuLFR3KSkrIiBvbiBub2RlICIrbi5pZGVudGlmaWVyKSxhKFYobix1bSksMjgwKT09S2Ype2lmKG08MHx8aDwwKXRocm93IGIobmV3IEtjKCJUaGUgc2l6ZSBkZWZpbmVkIGJ5IHRoZSBwYXJlbnQgcGFyYWxsZWwgbm9kZSBpcyB0b28gc21hbGwgZm9yIHRoZSBzcGFjZSBwcm92aWRlZCBieSB0aGUgcGFkZGluZ3Mgb2YgdGhlIGNoaWxkIGhpZXJhcmNoaWNhbCBub2RlLiAiK24uaWRlbnRpZmllcikpO2ZvcihXcyhuLFRnKXx8V3MobixDZyl8fHhlZShuKSxFPVIoJChWKG4sVGcpKSkseT1SKCQoVihuLENnKSkpLFN1LmxvZ18wKCJEZXNpcmVkIENoaWxkIEFyZWE6ICgiK0UrInwiK3krIikiKSxwMT1tL0UsTW09aC95LG9zPVMuTWF0aC5taW4ocDEsUy5NYXRoLm1pbihNbSxSKCQoVihuLHJGZSkpKSkpLG5yKG4saUEsb3MpLFN1LmxvZ18wKG4uaWRlbnRpZmllcisiIC0tIExvY2FsIFNjYWxlIEZhY3RvciAoWHxZKTogKCIrcDErInwiK01tKyIpIiksTT1hKFYobixJVCksMjEpLGk9MCxzPTAsb3M8cDEmJihNLmNvbnRhaW5zKChlMSgpLEd2KSk/aT0obS8yLUUqb3MvMikvb3M6TS5jb250YWlucyhIdikmJihpPShtLUUqb3MpL29zKSksb3M8TW0mJihNLmNvbnRhaW5zKChlMSgpLFd2KSk/cz0oaC8yLXkqb3MvMikvb3M6TS5jb250YWlucyhVdikmJihzPShoLXkqb3MpL29zKSksZzE9aSsodHMubGVmdC9vcy10cy5sZWZ0KSxUYz1zKyh0cy50b3BfMC9vcy10cy50b3BfMCksU3UubG9nXzAoIlNoaWZ0OiAoIitnMSsifCIrVGMrIikiKSxXYT1uZXcgWWUoKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikpO1dhLmN1cnNvciE9V2EudGhpcyQwMV8yLnNpemVfMSgpOyljbz1hKGVuKFdhKSwyNyksQ2koY28sY28ueF8wK2cxKSxUaShjbyxjby55XzArVGMpO2ZvcihxPW5ldyBZZSgoIW4uY29udGFpbmVkRWRnZXMmJihuLmNvbnRhaW5lZEVkZ2VzPW5ldyBVKE1yLG4sMTIsMykpLG4uY29udGFpbmVkRWRnZXMpKTtxLmN1cnNvciE9cS50aGlzJDAxXzIuc2l6ZV8xKCk7KXtmb3IoSD1hKGVuKHEpLDc0KSxSbT1uZXcgWWUoKCFILnNlY3Rpb25zJiYoSC5zZWN0aW9ucz1uZXcgVShncixILDYsNikpLEguc2VjdGlvbnMpKTtSbS5jdXJzb3IhPVJtLnRoaXMkMDFfMi5zaXplXzEoKTspZm9yKGRfPWEoZW4oUm0pLDE2NiksbmIoZF8sZF8uc3RhcnRYK2cxLGRfLnN0YXJ0WStUYyksZWIoZF8sZF8uZW5kWCtnMSxkXy5lbmRZK1RjKSxfPW5ldyBZZSgoIWRfLmJlbmRQb2ludHMmJihkXy5iZW5kUG9pbnRzPW5ldyBqcihCYSxkXyw1KSksZF8uYmVuZFBvaW50cykpO18uY3Vyc29yIT1fLnRoaXMkMDFfMi5zaXplXzEoKTspYz1hKGVuKF8pLDM3NyksV1IoYyxjLnhfMCtnMSxjLnlfMCtUYyk7Zm9yKFNyPW5ldyBZZSgoIUgubGFiZWxzJiYoSC5sYWJlbHM9bmV3IFUoUXQsSCwxLDcpKSxILmxhYmVscykpO1NyLmN1cnNvciE9U3IudGhpcyQwMV8yLnNpemVfMSgpOylqbj1hKGVuKFNyKSwxMzUpLF9sKGpuLGpuLnhfMCtnMSxqbi55XzArVGMpO2Zvcihubj1hKFYoSCx5ZCksNzUpLEZlPWRuKG5uLDApO0ZlLmN1cnJlbnROb2RlIT1GZS50aGlzJDAxLnRhaWw7KURlPWEodW4oRmUpLDgpLERlLnhfMCs9ZzEsRGUueV8wKz1UYztucihILHlkLG5uKX19U3UuZG9uZV8xKCl9Zm9yKGY9bmV3IFllKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pKTtmLmN1cnNvciE9Zi50aGlzJDAxXzIuc2l6ZV8xKCk7KWQ9YShlbihmKSwyNyksdj1CWihlLGQscix0KSxxcihrLHYpLFR6ZShkKX1pZih0LmlzQ2FuY2VsZWQoKSlyZXR1cm4gTmUoKSxOZSgpLE90O2ZvcihZdT1uZXcgVChrKTtZdS5pPFl1LnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl2dT1hKEMoWXUpLDc0KSxucih2dSxyQSwoemUoKSwhMCkpO3JldHVybiBhZShpZShWKG4sSXcpKSl8fFRSZShuLG8sdC5zdWJUYXNrKEpnKSksczJuKGspLHZlJiZaZz93ZTooTmUoKSxOZSgpLE90KX1lbHNlIHJldHVybiBOZSgpLE5lKCksT3R9ZnVuY3Rpb24gczJuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGM7Zm9yKHM9bmV3IFQoZSk7cy5pPHMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXtmb3IoaT1hKEMocyksNzQpLHQ9eW8oYShPKCghaS5zb3VyY2VzJiYoaS5zb3VyY2VzPW5ldyBMZShhbixpLDQsNykpLGkuc291cmNlcyksMCksODQpKSx1PXQueF8wLGM9dC55XzAsbz1hKE8oKCFpLnNlY3Rpb25zJiYoaS5zZWN0aW9ucz1uZXcgVShncixpLDYsNikpLGkuc2VjdGlvbnMpLDApLDE2NiksbmIobyxvLnN0YXJ0WCt1LG8uc3RhcnRZK2MpLGViKG8sby5lbmRYK3Usby5lbmRZK2MpLHI9bmV3IFllKCghby5iZW5kUG9pbnRzJiYoby5iZW5kUG9pbnRzPW5ldyBqcihCYSxvLDUpKSxvLmJlbmRQb2ludHMpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSwzNzcpLFdSKG4sbi54XzArdSxuLnlfMCtjKTtyUShhKFYoaSwoRm4oKSx5ZCkpLDc1KSx1LGMpfX1mdW5jdGlvbiBiUmUoKXt9cCg4NjksMSx7fSxiUmUpLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlIiwiUmVjdXJzaXZlR3JhcGhMYXlvdXRFbmdpbmUiLDg2OSk7ZnVuY3Rpb24gSVJlKCl7Q18uY2FsbCh0aGlzKX1mdW5jdGlvbiBLYyhlKXtJby5jYWxsKHRoaXMsZSl9cCgyMjQsNjMsS3UsSVJlLEtjKSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZSIsIlVuc3VwcG9ydGVkQ29uZmlndXJhdGlvbkV4Y2VwdGlvbiIsMjI0KTtmdW5jdGlvbiBlbShlKXtJby5jYWxsKHRoaXMsZSl9cCgzNzAsNjMsS3UsZW0pLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlIiwiVW5zdXBwb3J0ZWRHcmFwaEV4Y2VwdGlvbiIsMzcwKTtmdW5jdGlvbiB4UmUoZSxuKXt2YXIgcjtmb3Iocj1lLmxpc3QuYXJyYXkubGVuZ3RoO3I8bjtyKyspZWUoZS5saXN0LGUucHJvdmlkZURlZmF1bHQoKSl9ZnVuY3Rpb24gd1QoZSxuKXtpZihuPDApdGhyb3cgYihuZXcgbm8oIkludmFsaWQgaW5kZXg6ICIrbikpO3JldHVybiB4UmUoZSxuKzEpLGxlKGUubGlzdCxuKX1mdW5jdGlvbiB1Mm4oZSxuLHIpe2lmKG48MCl0aHJvdyBiKG5ldyBubygiSW52YWxpZCBpbmRleDogIituKSk7bjxlLmxpc3QuYXJyYXkubGVuZ3RoP0thKGUubGlzdCxuLHIpOih4UmUoZSxuKSxlZShlLmxpc3QscikpfWZ1bmN0aW9uIFBSZSgpe3RoaXMubGlzdD1uZXcgUX1wKDc2MSwxLHt9KSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiQWJzdHJhY3RSYW5kb21MaXN0QWNjZXNzb3IiLDc2MSk7ZnVuY3Rpb24gR1ooZSxuKXtyZXR1cm4gUmEoZS5hZGRpdGlvbmFsUHJvY2Vzc29ycyxuKSxlfWZ1bmN0aW9uIEVUKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7aWYoZS5mYWlsT25NaXNzaW5nUGhhc2UmJmUuY29uZmlndXJlZFBoYXNlcy5zaXplXzA8ZS5udW1iZXJPZlBoYXNlcyl0aHJvdyBiKG5ldyBybygiRXhwZWN0ZWQgIitlLm51bWJlck9mUGhhc2VzKyIgcGhhc2VzIHRvIGJlIGNvbmZpZ3VyZWQ7IG9ubHkgZm91bmQgIitlLmNvbmZpZ3VyZWRQaGFzZXMuc2l6ZV8wKSk7Zm9yKGQ9YShpcyhlLnBoYXNlc0VudW1DbGFzcyksOSksbT1OdShlLm51bWJlck9mUGhhc2VzKSxpPWQsdT0wLF89aS5sZW5ndGg7dTxfOysrdSl0PWlbdV0sZj1hKHdUKGUsdC5vcmRpbmFsKSwxODgpLGY/ZWUobSxhKE5SZShlLGYpLDEwNikpOm0uYXJyYXkucHVzaChudWxsKTtmb3IoeT1uZXcgSHIsTHIoSm4ocG8oSm4obmV3IFNlKG51bGwsbmV3IHhlKG0sMTYpKSxuZXcgTFJlKSxuZXcga1JlKG4pKSxuZXcgT1JlKSxuZXcgTVJlKHkpKSxSYSh5LGUuYWRkaXRpb25hbFByb2Nlc3NvcnMpLHI9bmV3IFEsbz1kLHM9MCxjPW8ubGVuZ3RoO3M8YzsrK3MpdD1vW3NdLHFyKHIsQVJlKGUsQ0koYSh3VCh5LHQub3JkaW5hbCksMjApKSkpLGg9YShsZShtLHQub3JkaW5hbCksMTA2KSxoJiZSZShyLmFycmF5LGgpO3JldHVybiBxcihyLEFSZShlLENJKGEod1QoeSxkW2QubGVuZ3RoLTFdLm9yZGluYWwrMSksMjApKSkpLHJ9ZnVuY3Rpb24gYzJuKGUsbixyKXtyZXR1cm4gZWUobixOUmUoZSxyKSl9ZnVuY3Rpb24gdlQoZSl7cmV0dXJuIGUubGlzdC5hcnJheS5sZW5ndGg9MCxteihlLmNvbmZpZ3VyZWRQaGFzZXMpLGYybihlLmFkZGl0aW9uYWxQcm9jZXNzb3JzKSxlfWZ1bmN0aW9uIE5SZShlLG4pe3ZhciByO3JldHVybiBlLmVuYWJsZUNhY2hpbmc/eWkoZS5jYWNoZSxuKT9hKEtlKGUuY2FjaGUsbiksNDcpOihyPW4uY3JlYXRlXzEoKSxCbihlLmNhY2hlLG4scikscik6bi5jcmVhdGVfMSgpfWZ1bmN0aW9uIEFSZShlLG4pe3ZhciByO3JldHVybiByPU51KG4ubWFwXzAuc2l6ZV8xKCkpLExyKEV4KG5ldyBTZShudWxsLG5ldyB4ZShuLDEpKSxlLnByb2Nlc3NvckNvbXBhcmF0b3IpLG5ldyBSUmUoZSxyKSkscn1mdW5jdGlvbiBncyhlLG4scil7cmV0dXJuIHUybihlLG4ub3JkaW5hbCxyKSxNbChlLmNvbmZpZ3VyZWRQaGFzZXMsbiksZX1mdW5jdGlvbiBBdihlKXt2YXIgbjtpZihQUmUuY2FsbCh0aGlzKSx0aGlzLnByb2Nlc3NvckNvbXBhcmF0b3I9bmV3IERSZSx0aGlzLnBoYXNlc0VudW1DbGFzcz1lLHRoaXMubnVtYmVyT2ZQaGFzZXM9YShlLmVudW1Db25zdGFudHNGdW5jJiZlLmVudW1Db25zdGFudHNGdW5jKCksOSkubGVuZ3RoLHRoaXMubnVtYmVyT2ZQaGFzZXM9PTApdGhyb3cgYihuZXcgR2UoIlRoZXJlIG11c3QgYmUgYXQgbGVhc3Qgb25lIHBoYXNlIGluIHRoZSBwaGFzZSBlbnVtZXJhdGlvbi4iKSk7dGhpcy5jb25maWd1cmVkUGhhc2VzPShuPWEoaXModGhpcy5waGFzZXNFbnVtQ2xhc3MpLDkpLG5ldyBKYShuLGEoRGwobixuLmxlbmd0aCksOSksMCkpLHRoaXMuYWRkaXRpb25hbFByb2Nlc3NvcnM9bmV3IEhyLHRoaXMuY2FjaGU9bmV3IHNufWZ1bmN0aW9uIF8ybihlLG4pe3JldHVybiBuLmdldExheW91dFByb2Nlc3NvckNvbmZpZ3VyYXRpb24oZSl9cCg0NTAsNzYxLHt9LEF2KSxsLnByb3ZpZGVEZWZhdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZW5hYmxlQ2FjaGluZz0hMCxsLmZhaWxPbk1pc3NpbmdQaGFzZT0hMCxsLm51bWJlck9mUGhhc2VzPTAsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuYWxnIiwiQWxnb3JpdGhtQXNzZW1ibGVyIiw0NTApO2Z1bmN0aW9uIExSZSgpe31wKDEyMDAsMSxJbixMUmUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiEhYShuLDEwNil9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmFsZyIsIkFsZ29yaXRobUFzc2VtYmxlci9sYW1iZGEkMCRUeXBlIiwxMjAwKTtmdW5jdGlvbiBrUmUoZSl7dGhpcy5ncmFwaF8wPWV9cCgxMjAxLDEse30sa1JlKSxsLmFwcGx5XzA9ZnVuY3Rpb24obil7cmV0dXJuIF8ybih0aGlzLmdyYXBoXzAsYShuLDEwNikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5hbGciLCJBbGdvcml0aG1Bc3NlbWJsZXIvbGFtYmRhJDEkVHlwZSIsMTIwMSk7ZnVuY3Rpb24gT1JlKCl7fXAoMTIwMiwxLEluLE9SZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuISFhKG4sODApfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5hbGciLCJBbGdvcml0aG1Bc3NlbWJsZXIvbGFtYmRhJDIkVHlwZSIsMTIwMik7ZnVuY3Rpb24gTVJlKGUpe3RoaXMucHJvY2Vzc29yQ29uZmlndXJhdGlvbl8wPWV9cCgxMjAzLDEsSmUsTVJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtSYSh0aGlzLnByb2Nlc3NvckNvbmZpZ3VyYXRpb25fMCxhKG4sODApKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuYWxnIiwiQWxnb3JpdGhtQXNzZW1ibGVyL2xhbWJkYSQzJFR5cGUiLDEyMDMpO2Z1bmN0aW9uIFJSZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5wcm9jZXNzb3JzXzE9bn1wKDEyMDQsMSxKZSxSUmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2Mybih0aGlzLiQkb3V0ZXJfMCx0aGlzLnByb2Nlc3NvcnNfMSxhKG4sMTk2KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmFsZyIsIkFsZ29yaXRobUFzc2VtYmxlci9sYW1iZGEkNCRUeXBlIiwxMjA0KTtmdW5jdGlvbiBkMm4oZSxuKXtyZXR1cm4gd2EoZSksd2EobiksWGxlKGEoZSwyMiksYShuLDIyKSl9ZnVuY3Rpb24gRFJlKCl7fXAoMTM0MywxLE5uLERSZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gZDJuKGEobiwxOTYpLGEociwxOTYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5hbGciLCJFbnVtQmFzZWRGYWN0b3J5Q29tcGFyYXRvciIsMTM0Myk7ZnVuY3Rpb24gaHUoZSxuKXtpZihlLmN1cnJlbnRJbmRleDwwKXRocm93IGIobmV3IHJvKCJEaWQgbm90IGNhbGwgYmVmb3JlKC4uLikgb3IgYWZ0ZXIoLi4uKSBiZWZvcmUgY2FsbGluZyBhZGQoLi4uKS4iKSk7cmV0dXJuIEhaKGUsZS5jdXJyZW50SW5kZXgsbiksZX1mdW5jdGlvbiBXaShlLG4scil7cmV0dXJuIGUuY3VycmVudEluZGV4PS0xLEhaKGUsbi5vcmRpbmFsKzEsciksZX1mdW5jdGlvbiBSYShlLG4pe3ZhciByO2ZvcihyPTA7cjxuLmxpc3QuYXJyYXkubGVuZ3RoO3IrKylhKHdUKGUsciksMjEpLmFkZEFsbChhKHdUKG4sciksMTYpKTtyZXR1cm4gZX1mdW5jdGlvbiBNbihlLG4scil7cmV0dXJuIGUuY3VycmVudEluZGV4PS0xLEhaKGUsbi5vcmRpbmFsLHIpLGV9ZnVuY3Rpb24gRlJlKGUsbil7cmV0dXJuIGUuY3VycmVudEluZGV4PW4ub3JkaW5hbCsxLGV9ZnVuY3Rpb24gTHYoZSxuKXtyZXR1cm4gZS5jdXJyZW50SW5kZXg9bi5vcmRpbmFsLGV9ZnVuY3Rpb24gZjJuKGUpe3JldHVybiBfZihlLmxpc3QuYXJyYXksMCksZS5jdXJyZW50SW5kZXg9LTEsZX1mdW5jdGlvbiBIWihlLG4scil7YSh3VChlLG4pLDIxKS5hZGRfMihyKX1mdW5jdGlvbiBIcigpe1BSZS5jYWxsKHRoaXMpLF9mKHRoaXMubGlzdC5hcnJheSwwKSx0aGlzLmN1cnJlbnRJbmRleD0tMX1mdW5jdGlvbiBVTihlKXtyZXR1cm4gUmEobmV3IEhyLGUpfXAoODAsNzYxLHs4MDoxfSxIciksbC5wcm92aWRlRGVmYXVsdD1mdW5jdGlvbigpe3JldHVybiBuZXcgQnJ9LGwuY3VycmVudEluZGV4PTAsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuYWxnIiwiTGF5b3V0UHJvY2Vzc29yQ29uZmlndXJhdGlvbiIsODApO2Z1bmN0aW9uIFdOKCl7V049RiwkUmU9bmV3IEhSZSxHUmU9bmV3IFVSZSxCUmU9SUtlKChGbigpLGRSKSwkUmUsVzAsR1JlKX1mdW5jdGlvbiB6UmUoKXtXTigpfWZ1bmN0aW9uIHAybihlKXtXTigpLGEoZS5nZXRQcm9wZXJ0eSgoRm4oKSxqZikpLDE4MSkuYWRkXzIoKGFhKCksJFQpKSxlLnNldFByb3BlcnR5KGRSLG51bGwpfWZ1bmN0aW9uIGcybihlKXtXTigpLGEoZS5nZXRQcm9wZXJ0eSgoRm4oKSxXMCkpLDE4MSkuY29udGFpbnMoKGdhKCksaEEpKSYmKGEoZS5nZXRQcm9wZXJ0eShqZiksMTgxKS5hZGRfMigoYWEoKSxkbSkpLGEoZS5nZXRQcm9wZXJ0eShXMCksMTgxKS5yZW1vdmVfMShoQSkpfWZ1bmN0aW9uIGgybihlLG4scil7V04oKSxlLmhhc1Byb3BlcnR5KG4pJiZyLmFjY2VwdChlKX1wKDEwMjUsMSx7NTM2OjF9LHpSZSksbC52aXNpdD1mdW5jdGlvbihuKXtUMihCUmUsbmV3IFdSZShuKSl9O3ZhciAkUmUsQlJlLEdSZTtnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiRGVwcmVjYXRlZExheW91dE9wdGlvblJlcGxhY2VyIiwxMDI1KTtmdW5jdGlvbiBIUmUoKXt9cCgxMDI2LDEsSmUsSFJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtwMm4oYShuLDE2NykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiRGVwcmVjYXRlZExheW91dE9wdGlvblJlcGxhY2VyL2xhbWJkYSQwJFR5cGUiLDEwMjYpO2Z1bmN0aW9uIFVSZSgpe31wKDEwMjcsMSxKZSxVUmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2cybihhKG4sMTY3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJEZXByZWNhdGVkTGF5b3V0T3B0aW9uUmVwbGFjZXIvbGFtYmRhJDEkVHlwZSIsMTAyNyk7ZnVuY3Rpb24gV1JlKGUpe3RoaXMuZWxlbWVudF8wPWV9cCgxMDI4LDEse30sV1JlKSxsLmFjY2VwdF8xPWZ1bmN0aW9uKG4scil7aDJuKHRoaXMuZWxlbWVudF8wLGEobiwxNDkpLGEociw0MSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiRGVwcmVjYXRlZExheW91dE9wdGlvblJlcGxhY2VyL2xhbWJkYSQyJFR5cGUiLDEwMjgpO2Z1bmN0aW9uIG0ybihlLG4scil7dG8oZS5rbm93bk9wdGlvbnMsbi5pZF8wLHIpfWZ1bmN0aW9uIFVaKGUsbil7cmV0dXJuIEwobiwxNDMpP1RlKGUuaWRfMCxhKG4sMTQzKS5pZF8wKTohMX1mdW5jdGlvbiBXWihlLG4pe3JldHVybiAkaShlLnN1cHBvcnRlZEZlYXR1cmVzLG4pfWZ1bmN0aW9uIEpfKGUpe3ZhciBuO3RoaXMua25vd25PcHRpb25zPW5ldyBzbix0aGlzLmlkXzA9ZS5pZF8wLHRoaXMubmFtZV8wPWUubmFtZV8wLHRoaXMuZGVzY3JpcHRpb249ZS5kZXNjcmlwdGlvbix0aGlzLnByb3ZpZGVyUG9vbD1uZXcgSHplKGUucHJvdmlkZXJGYWN0b3J5KSx0aGlzLmNhdGVnb3J5PWUuY2F0ZWdvcnksZS5zdXBwb3J0ZWRGZWF0dXJlcz90aGlzLnN1cHBvcnRlZEZlYXR1cmVzPWUuc3VwcG9ydGVkRmVhdHVyZXM6dGhpcy5zdXBwb3J0ZWRGZWF0dXJlcz0obj1hKGlzKEpBKSw5KSxuZXcgSmEobixhKERsKG4sbi5sZW5ndGgpLDkpLDApKX1wKDE0MywxLHs3MDE6MSwxNDM6MX0sSl8pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIFVaKHRoaXMsbil9LGwuZ2V0RGVzY3JpcHRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZXNjcmlwdGlvbn0sbC5nZXRJZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlkXzB9LGwuZ2V0TmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWVfMH0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIE5jKHRoaXMuaWRfMCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiJMYXlvdXQgQWxnb3JpdGhtOiAiK3RoaXMuaWRfMH07dmFyIHkybj1nKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0QWxnb3JpdGhtRGF0YSIsMTQzKTtmdW5jdGlvbiBqTihlLG4pe3JldHVybiBlLmNhdGVnb3J5PW4sZX1mdW5jdGlvbiBkZChlLG4pe3JldHVybiBlLmRlc2NyaXB0aW9uPW4sZX1mdW5jdGlvbiBmZChlLG4pe3JldHVybiBlLmlkXzA9bixlfWZ1bmN0aW9uIHBkKGUsbil7cmV0dXJuIGUubmFtZV8wPW4sZX1mdW5jdGlvbiBnZChlLG4pe3JldHVybiBlLnByb3ZpZGVyRmFjdG9yeT1uLGV9ZnVuY3Rpb24galooZSxuKXtyZXR1cm4gZS5zdXBwb3J0ZWRGZWF0dXJlcz1uLGV9ZnVuY3Rpb24gWl8oKXt9cCgyNjksMSx7fSxaXyksZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dEFsZ29yaXRobURhdGEvQnVpbGRlciIsMjY5KTtmdW5jdGlvbiB3Mm4oZSl7dmFyIG4scjtpZihuPXhuKFYoZSwoRm4oKSxUdykpKSwhalJlKG4sZSkmJiFXcyhlLE5nKSYmKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pLnNpemVfMCE9MHx8YWUoaWUoVihlLFBUKSkpKSlpZihuPT1udWxsfHxuZihuKS5sZW5ndGg9PTApe2lmKCFqUmUoIm9yZy5lY2xpcHNlLmVsay5sYXllcmVkIixlKSl0aHJvdyByPU9uKE9uKG5ldyBMYSgiVW5hYmxlIHRvIGxvYWQgZGVmYXVsdCBsYXlvdXQgYWxnb3JpdGhtICIpLCJvcmcuZWNsaXBzZS5lbGsubGF5ZXJlZCIpLCIgZm9yIHVuY29uZmlndXJlZCBub2RlICIpLENBKGUsciksYihuZXcgS2Moci5zdHJpbmcpKX1lbHNlIHRocm93IHI9T24oT24obmV3IExhKCJMYXlvdXQgYWxnb3JpdGhtICciKSxuKSwiJyBub3QgZm91bmQgZm9yICIpLENBKGUsciksYihuZXcgS2Moci5zdHJpbmcpKX1mdW5jdGlvbiBqUmUoZSxuKXt2YXIgcjtyZXR1cm4gcj1XTSh2dygpLGUpLHI/KG5yKG4sKEZuKCksTmcpLHIpLCEwKTohMX1mdW5jdGlvbiBWUmUoKXt9cCgxMDI5LDEsezUzNjoxfSxWUmUpLGwudmlzaXQ9ZnVuY3Rpb24obil7TChuLDIwNykmJiFhZShpZShuLmdldFByb3BlcnR5KChGbigpLHJBKSkpKSYmdzJuKGEobiwyNykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0QWxnb3JpdGhtUmVzb2x2ZXIiLDEwMjkpO2Z1bmN0aW9uIG5tKGUpe3RoaXMubGF5b3V0ZXJzPW5ldyBwcix0aGlzLmlkXzA9ZS5pZF8wLHRoaXMubmFtZV8wPWUubmFtZV8wLHRoaXMuZGVzY3JpcHRpb249ZS5kZXNjcmlwdGlvbn1wKDIzMywxLHs3MDE6MSwyMzM6MX0sbm0pLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyMzMpP1RlKHRoaXMuaWRfMCxhKG4sMjMzKS5pZF8wKTohMX0sbC5nZXREZXNjcmlwdGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlc2NyaXB0aW9ufSxsLmdldElkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWRfMH0sbC5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZV8wfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gTmModGhpcy5pZF8wKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIkxheW91dCBUeXBlOiAiK3RoaXMuaWRfMH0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dENhdGVnb3J5RGF0YSIsMjMzKTtmdW5jdGlvbiBrdihlLG4pe3JldHVybiBlLmRlc2NyaXB0aW9uPW4sZX1mdW5jdGlvbiB3dyhlLG4pe3JldHVybiBlLmlkXzA9bixlfWZ1bmN0aW9uIEV3KGUsbil7cmV0dXJuIGUubmFtZV8wPW4sZX1mdW5jdGlvbiBybSgpe31wKDM1NywxLHt9LHJtKSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0Q2F0ZWdvcnlEYXRhL0J1aWxkZXIiLDM1Nyk7ZnVuY3Rpb24gRTJuKGUsbil7cmV0dXJuIGEoeHMoZS5sYXlvdXRBbGdvcml0aG1NYXAsbiksMTQzKX1mdW5jdGlvbiBXTShlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2lmKG49PW51bGx8fG4ubGVuZ3RoPT0wKXJldHVybiBudWxsO2lmKG89YShuaShlLmFsZ29yaXRobVN1ZmZpeE1hcCxuKSwxNDMpLCFvKXtmb3IodD0odT1uZXcgdGMoZS5sYXlvdXRBbGdvcml0aG1NYXApLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgdGYodSkpO3QudmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KWlmKHI9KGk9YSh0LnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKGkuZ2V0VmFsdWUoKSwxNDMpKSxzPXIuaWRfMCxjPW4ubGVuZ3RoLFRlKHMuc3Vic3RyKHMubGVuZ3RoLWMsYyksbikmJihuLmxlbmd0aD09cy5sZW5ndGh8fEl0KHMscy5sZW5ndGgtbi5sZW5ndGgtMSk9PTQ2KSl7aWYobylyZXR1cm4gbnVsbDtvPXJ9byYmdG8oZS5hbGdvcml0aG1TdWZmaXhNYXAsbixvKX1yZXR1cm4gb31mdW5jdGlvbiB2Mm4oZSxuKXtyZXR1cm4gYSh4cyhlLmxheW91dENhdGVnb3J5TWFwLG4pLDIzMyl9ZnVuY3Rpb24gak0oZSxuKXt2YXIgcjtyZXR1cm4gcj1hKHhzKGUubGF5b3V0T3B0aW9uTWFwLG4pLDIzKSxyfHxhKHhzKGUubGVnYWN5TGF5b3V0T3B0aW9uTWFwLG4pLDIzKX1mdW5jdGlvbiBWWihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKG49PW51bGx8fG4ubGVuZ3RoPT0wKXJldHVybiBudWxsO2lmKGk9YShuaShlLm9wdGlvblN1ZmZpeE1hcCxuKSwyMyksIWkpe2ZvcihvPShtPW5ldyB0YyhlLmxheW91dE9wdGlvbk1hcCkudGhpcyQwMS5lbnRyeVNldF8wKCkuaXRlcmF0b3JfMCgpLG5ldyB0ZihtKSk7by52YWwkb3V0ZXJJdGVyMi5oYXNOZXh0XzAoKTspaWYocj0ocz1hKG8udmFsJG91dGVySXRlcjIubmV4dF8xKCksNDQpLGEocy5nZXRWYWx1ZSgpLDIzKSksdT1yLmlkXzAseT1uLmxlbmd0aCxUZSh1LnN1YnN0cih1Lmxlbmd0aC15LHkpLG4pJiYobi5sZW5ndGg9PXUubGVuZ3RofHxJdCh1LHUubGVuZ3RoLW4ubGVuZ3RoLTEpPT00Nikpe2lmKGkpcmV0dXJuIG51bGw7aT1yfWlmKCFpKXtmb3IodD0oaD1uZXcgdGMoZS5sYXlvdXRPcHRpb25NYXApLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgdGYoaCkpO3QudmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KWlmKHI9KHM9YSh0LnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKHMuZ2V0VmFsdWUoKSwyMykpLGY9ci5sZWdhY3lJZHMsZiE9bnVsbCl7Zm9yKGM9ZixfPTAsZD1jLmxlbmd0aDtfPGQ7KytfKWlmKHU9Y1tfXSx5PW4ubGVuZ3RoLFRlKHUuc3Vic3RyKHUubGVuZ3RoLXkseSksbikmJihuLmxlbmd0aD09dS5sZW5ndGh8fEl0KHUsdS5sZW5ndGgtbi5sZW5ndGgtMSk9PTQ2KSl7aWYoaSlyZXR1cm4gbnVsbDtpPXJ9fX1pJiZ0byhlLm9wdGlvblN1ZmZpeE1hcCxuLGkpfXJldHVybiBpfWZ1bmN0aW9uIHlnKGUsbil7dmFyIHIsdCxvLGkscztmb3IodD1uLG89MCxpPXQubGVuZ3RoO288aTsrK28pcj10W29dLHM9bmV3IFlSZShlKSxyLmFwcGx5XzQocyksUzJuKHMpO1ppKGUub3B0aW9uU3VmZml4TWFwKX1mdW5jdGlvbiBxUmUoKXt0aGlzLmxheW91dEFsZ29yaXRobU1hcD1uZXcgRGMsdGhpcy5sYXlvdXRPcHRpb25NYXA9bmV3IERjLHRoaXMubGVnYWN5TGF5b3V0T3B0aW9uTWFwPW5ldyBEYyx0aGlzLmxheW91dENhdGVnb3J5TWFwPW5ldyBEYyx0aGlzLmFsZ29yaXRobVN1ZmZpeE1hcD1uZXcgc24sdGhpcy5vcHRpb25TdWZmaXhNYXA9bmV3IHNuLCRnKG90LG5ldyBLUmUsbmV3IFhSZSksJGcodFEsbmV3IGxEZSxuZXcgc0RlKSwkZyhEVyxuZXcgdURlLG5ldyBjRGUpLCRnKEhXLG5ldyBfRGUsbmV3IGREZSksJGcoJHplLG5ldyBmRGUsbmV3IHBEZSksJGcoVlplLG5ldyBKUmUsbmV3IFpSZSksJGcoeFFlLG5ldyBRUmUsbmV3IGVEZSksJGcoaFFlLG5ldyBuRGUsbmV3IHJEZSksJGcoVFFlLG5ldyB0RGUsbmV3IG9EZSksJGcocVFlLG5ldyBpRGUsbmV3IGFEZSl9ZnVuY3Rpb24gdncoKXtyZXR1cm4gVk18fChWTT1uZXcgcVJlLHlnKFZNLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IF9RXSkpKSxWTX1wKDg3OSwxLHt9LHFSZSk7dmFyIFZNO2coIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UiLDg3OSk7ZnVuY3Rpb24gVXIoZSxuLHIsdCl7dmFyIG87bz1uZXcgcVosby5maXJzdElkPW4sby5zZWNvbmRJZD1yLG8udmFsdWVfMD10LExuKGUub3B0aW9uRGVwZW5kZW5jaWVzLG8pfWZ1bmN0aW9uIFooZSxuLHIsdCl7dmFyIG87bz1uZXcgcVosby5maXJzdElkPW4sby5zZWNvbmRJZD1yLG8udmFsdWVfMD10LExuKGUub3B0aW9uU3VwcG9ydCxvKX1mdW5jdGlvbiBTMm4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG07Zm9yKHI9KF89bmV3IHRjKGUudGhpcyQwMS5sYXlvdXRBbGdvcml0aG1NYXApLnRoaXMkMDEuZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKSxuZXcgdGYoXykpO3IudmFsJG91dGVySXRlcjIuaGFzTmV4dF8wKCk7KW49KHU9YShyLnZhbCRvdXRlckl0ZXIyLm5leHRfMSgpLDQ0KSxhKHUuZ2V0VmFsdWUoKSwxNDMpKSxvPW4uY2F0ZWdvcnksbz09bnVsbCYmKG89IiIpLHQ9djJuKGUudGhpcyQwMSxvKSwhdCYmby5sZW5ndGg9PTAmJih0PUMybihlKSksdCYmIVlkKHQubGF5b3V0ZXJzLG4sITEpJiZMbih0LmxheW91dGVycyxuKTtmb3Iocz1kbihlLm9wdGlvbkRlcGVuZGVuY2llcywwKTtzLmN1cnJlbnROb2RlIT1zLnRoaXMkMDEudGFpbDspaT1hKHVuKHMpLDQ4NyksZD1qTShlLnRoaXMkMDEsaS5maXJzdElkKSxtPWpNKGUudGhpcyQwMSxpLnNlY29uZElkKSxkJiZtJiZMbihkLmRlcGVuZGVuY2llcyxuZXcgWnIobSxpLnZhbHVlXzApKTtmb3Ioa2EoZS5vcHRpb25EZXBlbmRlbmNpZXMpLGg9ZG4oZS5vcHRpb25TdXBwb3J0LDApO2guY3VycmVudE5vZGUhPWgudGhpcyQwMS50YWlsOylmPWEodW4oaCksNDg3KSxuPUUybihlLnRoaXMkMDEsZi5maXJzdElkKSxjPWpNKGUudGhpcyQwMSxmLnNlY29uZElkKSxuJiZjJiZtMm4obixjLGYudmFsdWVfMCk7a2EoZS5vcHRpb25TdXBwb3J0KX1mdW5jdGlvbiBoZChlLG4pe1JjKGUudGhpcyQwMS5sYXlvdXRBbGdvcml0aG1NYXAsbi5pZF8wLG4pfWZ1bmN0aW9uIE92KGUsbil7UmMoZS50aGlzJDAxLmxheW91dENhdGVnb3J5TWFwLG4uaWRfMCxuKX1mdW5jdGlvbiBfZShlLG4pe3ZhciByLHQsbyxpLHM7aWYocj1uLmlkXzAsUmMoZS50aGlzJDAxLmxheW91dE9wdGlvbk1hcCxyLG4pLG4ubGVnYWN5SWRzIT1udWxsKWZvcihvPW4ubGVnYWN5SWRzLGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpdD1vW2ldLFJjKGUudGhpcyQwMS5sZWdhY3lMYXlvdXRPcHRpb25NYXAsdCxuKX1mdW5jdGlvbiBDMm4oZSl7dmFyIG47cmV0dXJuIG49YSh4cyhlLnRoaXMkMDEubGF5b3V0Q2F0ZWdvcnlNYXAsIiIpLDIzMyksbnx8KG49bmV3IG5tKEV3KHd3KG5ldyBybSwiIiksIk90aGVyIikpLFJjKGUudGhpcyQwMS5sYXlvdXRDYXRlZ29yeU1hcCwiIixuKSksbn1mdW5jdGlvbiBZUmUoZSl7dGhpcy50aGlzJDAxPWUsdGhpcy5vcHRpb25EZXBlbmRlbmNpZXM9bmV3IHByLHRoaXMub3B0aW9uU3VwcG9ydD1uZXcgcHJ9cCg4ODAsMSx7fSxZUmUpLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvUmVnaXN0cnkiLDg4MCk7ZnVuY3Rpb24gcVooKXt9cCg0ODcsMSx7NDg3OjF9LHFaKSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL1JlZ2lzdHJ5L1RyaXBsZSIsNDg3KTtmdW5jdGlvbiBLUmUoKXt9cCg4ODEsMSx5cCxLUmUpLGwubmV3SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG10fSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQwJFR5cGUiLDg4MSk7ZnVuY3Rpb24gWFJlKCl7fXAoODgyLDEsV2QsWFJlKSxsLmNsb25lPWZ1bmN0aW9uKG4pe3JldHVybiBDdChhKG4sOCkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxJFR5cGUiLDg4Mik7ZnVuY3Rpb24gSlJlKCl7fXAoODkxLDEseXAsSlJlKSxsLm5ld0luc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBRfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxMCRUeXBlIiw4OTEpO2Z1bmN0aW9uIFpSZSgpe31wKDg5MiwxLFdkLFpSZSksbC5jbG9uZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IFFpKGEobiwxMykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxMSRUeXBlIiw4OTIpO2Z1bmN0aW9uIFFSZSgpe31wKDg5MywxLHlwLFFSZSksbC5uZXdJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBuZXcgcHJ9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDEyJFR5cGUiLDg5Myk7ZnVuY3Rpb24gZURlKCl7fXAoODk0LDEsV2QsZURlKSxsLmNsb25lPWZ1bmN0aW9uKG4pe3JldHVybiBjQyhhKG4sNjcpKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dE1ldGFEYXRhU2VydmljZS9sYW1iZGEkMTMkVHlwZSIsODk0KTtmdW5jdGlvbiBuRGUoKXt9cCg4OTUsMSx5cCxuRGUpLGwubmV3SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEJyfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxNCRUeXBlIiw4OTUpO2Z1bmN0aW9uIHJEZSgpe31wKDg5NiwxLFdkLHJEZSksbC5jbG9uZT1mdW5jdGlvbihuKXtyZXR1cm4gQ0koYShuLDQ5KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDE1JFR5cGUiLDg5Nik7ZnVuY3Rpb24gdERlKCl7fXAoODk3LDEseXAsdERlKSxsLm5ld0luc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBsdX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dE1ldGFEYXRhU2VydmljZS9sYW1iZGEkMTYkVHlwZSIsODk3KTtmdW5jdGlvbiBvRGUoKXt9cCg4OTgsMSxXZCxvRGUpLGwuY2xvbmU9ZnVuY3Rpb24obil7cmV0dXJuIFRJKGEobiw0OSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxNyRUeXBlIiw4OTgpO2Z1bmN0aW9uIGlEZSgpe31wKDg5OSwxLHlwLGlEZSksbC5uZXdJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBuZXcga0d9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDE4JFR5cGUiLDg5OSk7ZnVuY3Rpb24gYURlKCl7fXAoOTAwLDEsV2QsYURlKSxsLmNsb25lPWZ1bmN0aW9uKG4pe3JldHVybiBLc2UoYShuLDE1NykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQxOSRUeXBlIiw5MDApO2Z1bmN0aW9uIGxEZSgpe31wKDg4MywxLHlwLGxEZSksbC5uZXdJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBuZXcgaml9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDIkVHlwZSIsODgzKTtmdW5jdGlvbiBzRGUoKXt9cCg4ODQsMSxXZCxzRGUpLGwuY2xvbmU9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBKTihhKG4sNzUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dE1ldGFEYXRhU2VydmljZS9sYW1iZGEkMyRUeXBlIiw4ODQpO2Z1bmN0aW9uIHVEZSgpe31wKDg4NSwxLHlwLHVEZSksbC5uZXdJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBuZXcgdkV9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDQkVHlwZSIsODg1KTtmdW5jdGlvbiBjRGUoKXt9cCg4ODYsMSxXZCxjRGUpLGwuY2xvbmU9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyB0OShhKG4sMTQwKSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDUkVHlwZSIsODg2KTtmdW5jdGlvbiBfRGUoKXt9cCg4ODcsMSx5cCxfRGUpLGwubmV3SW5zdGFuY2U9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IE9ofSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQ2JFR5cGUiLDg4Nyk7ZnVuY3Rpb24gZERlKCl7fXAoODg4LDEsV2QsZERlKSxsLmNsb25lPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgR1coYShuLDEwNykpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5kYXRhIiwiTGF5b3V0TWV0YURhdGFTZXJ2aWNlL2xhbWJkYSQ3JFR5cGUiLDg4OCk7ZnVuY3Rpb24gZkRlKCl7fXAoODg5LDEseXAsZkRlKSxsLm5ld0luc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBiUn0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dE1ldGFEYXRhU2VydmljZS9sYW1iZGEkOCRUeXBlIiw4ODkpO2Z1bmN0aW9uIHBEZSgpe31wKDg5MCwxLFdkLHBEZSksbC5jbG9uZT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IHp6ZShhKG4sMzg1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRNZXRhRGF0YVNlcnZpY2UvbGFtYmRhJDkkVHlwZSIsODkwKTt2YXIgcU09Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5wcm9wZXJ0aWVzIiwiSVByb3BlcnR5Iik7ZnVuY3Rpb24gZ0RlKGUpe2lmKCFlLmNsYXp6fHwhKGUuY2xhenoubW9kaWZpZXJzJjgpKXRocm93IGIobmV3IHJvKCJFbnVtZXJhdGlvbiBjbGFzcyBleHBlY3RlZCBmb3IgbGF5b3V0IG9wdGlvbiAiK2UuaWRfMCkpfWZ1bmN0aW9uIFQybihlLG4pe3JldHVybiBsQihlLmlkXzAsbi5nZXRJZCgpKX1mdW5jdGlvbiBiMm4oZSl7dmFyIG47aWYoIWUuY2xhenopdGhyb3cgYihuZXcgcm8oIklEYXRhVHlwZSBjbGFzcyBleHBlY3RlZCBmb3IgbGF5b3V0IG9wdGlvbiAiK2UuaWRfMCkpO2lmKG49R1NuKGUuY2xhenopLG49PW51bGwpdGhyb3cgYihuZXcgcm8oIkNvdWxkbid0IGNyZWF0ZSBuZXcgaW5zdGFuY2Ugb2YgcHJvcGVydHkgJyIrZS5pZF8wKyInLiBNYWtlIHN1cmUgaXRzIHR5cGUgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSAiKyhKdShjYiksY2Iuc2ltcGxlTmFtZSkrIiB1dGlsaXR5IGNsYXNzLiIpKTtyZXR1cm4gYShuLDQyMyl9ZnVuY3Rpb24gaERlKGUsbil7dmFyIHIsdCxvO3RyeXtyZXR1cm4gbz1ZS2UoZS5jbGF6eixuKSxvfWNhdGNoKGkpe2lmKGk9d3IoaSksTChpLDMzKSl7dHJ5e2lmKHQ9QWEobixidCxxbikscj1pcyhlLmNsYXp6KSx0Pj0wJiZ0PHIubGVuZ3RoKXJldHVybiByW3RdfWNhdGNoKHMpe2lmKHM9d3IocyksIUwocywxMzApKXRocm93IGIocyl9cmV0dXJuIG51bGx9ZWxzZSB0aHJvdyBiKGkpfX1mdW5jdGlvbiBJMm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7Zm9yKGQ9KHQ9YShuLmVudW1Db25zdGFudHNGdW5jJiZuLmVudW1Db25zdGFudHNGdW5jKCksOSksbmV3IEphKHQsYShEbCh0LHQubGVuZ3RoKSw5KSwwKSksYz1lZihyLCJbXFxbXFxdXFxzLF0rIiksaT1jLHM9MCx1PWkubGVuZ3RoO3M8dTsrK3MpaWYobz1pW3NdLG5mKG8pLmxlbmd0aCE9MCl7aWYoXz1oRGUoZSxvKSxfPT1udWxsKXJldHVybiBudWxsO01sKGQsYShfLDIyKSl9cmV0dXJuIGR9ZnVuY3Rpb24gWVooZSxuKXt2YXIgcjtpZihuPT1udWxsfHxUZShuLCJudWxsIil8fG4ubGVuZ3RoPT0wJiZlLnR5cGVfMCE9KEpjKCksb20pKXJldHVybiBudWxsO3N3aXRjaChlLnR5cGVfMC5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIFdJKG4sInRydWUiKT8oemUoKSxveSk6V0kobiwiZmFsc2UiKT8oemUoKSxTMCk6bnVsbDtjYXNlIDI6dHJ5e3JldHVybiBKKEFhKG4sYnQscW4pKX1jYXRjaCh0KXtpZih0PXdyKHQpLEwodCwxMzApKXJldHVybiBudWxsO3Rocm93IGIodCl9Y2FzZSA0OnRyeXtyZXR1cm4gUWQobil9Y2F0Y2godCl7aWYodD13cih0KSxMKHQsMTMwKSlyZXR1cm4gbnVsbDt0aHJvdyBiKHQpfWNhc2UgMzpyZXR1cm4gbjtjYXNlIDU6cmV0dXJuIGdEZShlKSxoRGUoZSxuKTtjYXNlIDY6cmV0dXJuIGdEZShlKSxJMm4oZSxlLmNsYXp6LG4pO2Nhc2UgNzp0cnl7cmV0dXJuIHI9YjJuKGUpLHIucGFyc2VfMChuKSxyfWNhdGNoKHQpe2lmKHQ9d3IodCksTCh0LDMzKSlyZXR1cm4gbnVsbDt0aHJvdyBiKHQpfWRlZmF1bHQ6dGhyb3cgYihuZXcgcm8oIkludmFsaWQgdHlwZSBzZXQgZm9yIHRoaXMgbGF5b3V0IG9wdGlvbi4iKSl9fWZ1bmN0aW9uIHVlKGUpe3ZhciBuO3RoaXMuZGVwZW5kZW5jaWVzPW5ldyBwcix0aGlzLmlkXzA9ZS5pZF8wLHRoaXMuZ3JvdXBfMD1lLmdyb3VwXzAsdGhpcy5uYW1lXzA9ZS5uYW1lXzAsdGhpcy5kZXNjcmlwdGlvbj1lLmRlc2NyaXB0aW9uLHRoaXMuZGVmYXVsdFZhbHVlPWUuZGVmYXVsdFZhbHVlLHRoaXMudHlwZV8wPWUudHlwZV8wLHRoaXMuY2xheno9ZS5jbGF6eixlLnRhcmdldHM/dGhpcy50YXJnZXRzPWUudGFyZ2V0czp0aGlzLnRhcmdldHM9KG49YShpcyh6dSksOSksbmV3IEphKG4sYShEbChuLG4ubGVuZ3RoKSw5KSwwKSksdGhpcy5sZWdhY3lJZHM9ZS5sZWdhY3lJZHN9cCgyMywxLHszNDoxLDcwMToxLDIzOjEsMTQ5OjF9LHVlKSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBUMm4odGhpcyxhKG4sMTQ5KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyMyk/VGUodGhpcy5pZF8wLGEobiwyMykuaWRfMCk6TChuLDE0OSkmJlRlKHRoaXMuaWRfMCxhKG4sMTQ5KS5nZXRJZCgpKX0sbC5nZXREZWZhdWx0PWZ1bmN0aW9uKCl7dmFyIG47aWYoTCh0aGlzLmRlZmF1bHRWYWx1ZSw0KSl7aWYobj1vcmUodGhpcy5kZWZhdWx0VmFsdWUpLG49PW51bGwpdGhyb3cgYihuZXcgcm8oIkNvdWxkbid0IGNsb25lIHByb3BlcnR5ICciK3RoaXMuaWRfMCsiJy4gTWFrZSBzdXJlIGl0J3MgdHlwZSBpcyByZWdpc3RlcmVkIHdpdGggdGhlICIrKEp1KGNiKSxjYi5zaW1wbGVOYW1lKSsiIHV0aWxpdHkgY2xhc3MuIikpO3JldHVybiBufWVsc2UgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlfSxsLmdldERlc2NyaXB0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVzY3JpcHRpb259LGwuZ2V0SWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZF8wfSxsLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lXzB9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBOYyh0aGlzLmlkXzApfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iTGF5b3V0IE9wdGlvbjogIit0aGlzLmlkXzB9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRPcHRpb25EYXRhIiwyMyk7ZnVuY3Rpb24gSWUoZSxuKXtyZXR1cm4gZS5kZWZhdWx0VmFsdWU9bixlfWZ1bmN0aW9uIGRlKGUsbil7cmV0dXJuIGUuZGVzY3JpcHRpb249bixlfWZ1bmN0aW9uIGZlKGUsbil7cmV0dXJuIGUuZ3JvdXBfMD1uLGV9ZnVuY3Rpb24gcGUoZSxuKXtyZXR1cm4gZS5pZF8wPW4sZX1mdW5jdGlvbiB4Mm4oZSxuKXtyZXR1cm4gZS5sZWdhY3lJZHM9bixlfWZ1bmN0aW9uIGdlKGUsbil7cmV0dXJuIGUubmFtZV8wPW4sZX1mdW5jdGlvbiBoZShlLG4pe3JldHVybiBlLmNsYXp6PW4sZX1mdW5jdGlvbiBtZShlLG4pe3JldHVybiBlLnRhcmdldHM9bixlfWZ1bmN0aW9uIHllKGUsbil7cmV0dXJuIGUudHlwZV8wPW4sZX1mdW5jdGlvbiBjZSgpe31wKDI0LDEse30sY2UpLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRPcHRpb25EYXRhL0J1aWxkZXIiLDI0KTtmdW5jdGlvbiBocygpe2hzPUYsT2U9bmV3IFNUKCJQQVJFTlRTIiwwKSxKcj1uZXcgU1QoIk5PREVTIiwxKSxtdT1uZXcgU1QoIkVER0VTIiwyKSxRXz1uZXcgU1QoIlBPUlRTIiwzKSxYYz1uZXcgU1QoIkxBQkVMUyIsNCl9ZnVuY3Rpb24gU1QoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBQMm4oZSl7cmV0dXJuIGhzKCksd24oKG1EZSgpLHlEZSksZSl9ZnVuY3Rpb24gTjJuKCl7cmV0dXJuIGhzKCksUChJKHp1LDEpLFcsMTcwLDAsW09lLEpyLG11LFFfLFhjXSl9cCgxNzAsMjIsezM6MSwzNDoxLDIyOjEsMTcwOjF9LFNUKTt2YXIgbXUsWGMsSnIsT2UsUV8senU9Y24oIm9yZy5lY2xpcHNlLmVsay5jb3JlLmRhdGEiLCJMYXlvdXRPcHRpb25EYXRhL1RhcmdldCIsMTcwLGduLE4ybixQMm4pO2Z1bmN0aW9uIG1EZSgpe21EZT1GLHlEZT15bigoaHMoKSxQKEkoenUsMSksVywxNzAsMCxbT2UsSnIsbXUsUV8sWGNdKSkpfXZhciB5RGU7ZnVuY3Rpb24gSmMoKXtKYz1GLEtaPW5ldyB0bSgiVU5ERUZJTkVEIiwwKSxudD1uZXcgdG0oIkJPT0xFQU4iLDEpLGJvPW5ldyB0bSgiSU5UIiwyKSx3Zz1uZXcgdG0oIlNUUklORyIsMyksUHQ9bmV3IHRtKCJET1VCTEUiLDQpLG1yPW5ldyB0bSgiRU5VTSIsNSksb209bmV3IHRtKCJFTlVNU0VUIiw2KSx6cz1uZXcgdG0oIk9CSkVDVCIsNyl9ZnVuY3Rpb24gdG0oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBBMm4oZSl7cmV0dXJuIEpjKCksd24oKEVEZSgpLHZEZSksZSl9ZnVuY3Rpb24gTDJuKCl7cmV0dXJuIEpjKCksUChJKHdEZSwxKSxXLDI4NSwwLFtLWixudCxibyx3ZyxQdCxtcixvbSx6c10pfXAoMjg1LDIyLHszOjEsMzQ6MSwyMjoxLDI4NToxfSx0bSk7dmFyIG50LFB0LG1yLG9tLGJvLHpzLHdnLEtaLHdEZT1jbigib3JnLmVjbGlwc2UuZWxrLmNvcmUuZGF0YSIsIkxheW91dE9wdGlvbkRhdGEvVHlwZSIsMjg1LGduLEwybixBMm4pO2Z1bmN0aW9uIEVEZSgpe0VEZT1GLHZEZT15bigoSmMoKSxQKEkod0RlLDEpLFcsMjg1LDAsW0taLG50LGJvLHdnLFB0LG1yLG9tLHpzXSkpKX12YXIgdkRlO2Z1bmN0aW9uIFZOKCl7Vk49RixNdj1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5sYWJlbHMubGFiZWxNYW5hZ2VyIil9dmFyIE12O2Z1bmN0aW9uIEVnKCl7RWc9RixRWj1QKEkoX18sMSksYTYsMjgsMTQsWzEsMSwyLDYsMjQsMTIwLDcyMCw1MDQwLDQwMzIwLDM2Mjg4MCwzNjI4ODAwLDM5OTE2ODAwLDQ3OTAwMTYwMCw2MjI3MDIwODAwLDg3MTc4MjkxMjAwLDEzMDc2NzQzNjhlMyx7bDozNTA2MTc2LG06Nzk0MDc3LGg6MX0se2w6ODg0NzM2LG06OTE2NDExLGg6MjB9LHtsOjMzNDIzMzYsbTozOTEyNDg5LGg6MzYzfSx7bDo1ODk4MjQsbTozMDM0MTM4LGg6NjkxNH0se2w6MzQwNzg3MixtOjE5NjI1MDYsaDoxMzgyOTR9XSksUy5NYXRoLnBvdygyLC02NSl9ZnVuY3Rpb24gazJuKGUpe0VnKCk7dmFyIG4scix0O2ZvcihyPUIob3QsWCw4LDIsMCwxKSx0PTAsbj0wO248MjtuKyspdCs9LjUscltuXT1EMm4odCxlKTtyZXR1cm4gcn1mdW5jdGlvbiBPMm4oZSxuKXtpZihlPDB8fG48MCl0aHJvdyBiKG5ldyBHZSgiayBhbmQgbiBtdXN0IGJlIHBvc2l0aXZlIikpO2lmKG4+ZSl0aHJvdyBiKG5ldyBHZSgiayBtdXN0IGJlIHNtYWxsZXIgdGhhbiBuIikpO3JldHVybiBuPT0wfHxuPT1lPzE6ZT09MD8wOlhaKGUpLyhYWihuKSpYWihlLW4pKX1mdW5jdGlvbiBTdyhlLG4scil7RWcoKTt2YXIgdCxvLGkscyx1LGM7cmV0dXJuIHM9bi8yLGk9ci8yLHQ9Uy5NYXRoLmFicyhlLnhfMCksbz1TLk1hdGguYWJzKGUueV8wKSx1PTEsYz0xLHQ+cyYmKHU9cy90KSxvPmkmJihjPWkvbykseXUoZSxTLk1hdGgubWluKHUsYykpLGV9ZnVuY3Rpb24gQ3coZSxuKXt2YXIgcix0LG8saTtyZXR1cm4gbz1lLnhfMCxyPWUueF8wK2Uud2lkdGhfMCxpPWUueV8wLHQ9ZS55XzArZS5oZWlnaHQsbi54XzA+byYmbi54XzA8ciYmbi55XzA+aSYmbi55XzA8dH1mdW5jdGlvbiBTRGUoZSxuLHIpe3JldHVybiBFZygpLEN3KGUsbikmJkN3KGUscil9ZnVuY3Rpb24gTTJuKGUsbil7RWcoKTt2YXIgcix0LG8saTtpZihuLnNpemVfMDwyKXJldHVybiExO2ZvcihpPWRuKG4sMCkscj1hKHVuKGkpLDgpLHQ9cjtpLmN1cnJlbnROb2RlIT1pLnRoaXMkMDEudGFpbDspe2lmKG89YSh1bihpKSw4KSwhKEN3KGUsdCkmJkN3KGUsbykpKXJldHVybiExO3Q9b31yZXR1cm4hIShDdyhlLHQpJiZDdyhlLHIpKX1mdW5jdGlvbiBSMm4oZSxuLHIsdCxvKXtyZXR1cm4gRWcoKSxTLk1hdGgubWluKENEZShlLG4scix0LG8pLENEZShyLHQsZSxuLEtOKG5ldyBZKG8ueF8wLG8ueV8wKSkpKX1mdW5jdGlvbiBYWihlKXtpZihlPDApdGhyb3cgYihuZXcgR2UoIlRoZSBpbnB1dCBtdXN0IGJlIHBvc2l0aXZlIikpO3JldHVybiBlPFFaLmxlbmd0aD9JXyhRWltlXSk6Uy5NYXRoLnNxcnQoaF8qZSkqKHoybihlLGUpL1paKDIuNzE4MjgxODI4NDU5MDQ1LGUpKX1mdW5jdGlvbiBEMm4oZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKG89bi5sZW5ndGgtMSxzPTAsdT0wLHQ9MDt0PD1vO3QrKylpPW5bdF0scj1PMm4obyx0KSpaWigxLWUsby10KSpaWihlLHQpLHMrPWkueF8wKnIsdSs9aS55XzAqcjtyZXR1cm4gbmV3IFkocyx1KX1mdW5jdGlvbiBZTShlLG4scil7cmV0dXJuIEVnKCksQ3coZSxuKSYmQ3coZSxyKT8hMTpLTShuZXcgWShlLnhfMCxlLnlfMCksbmV3IFkoZS54XzArZS53aWR0aF8wLGUueV8wKSxuLHIpfHxLTShuZXcgWShlLnhfMCtlLndpZHRoXzAsZS55XzApLG5ldyBZKGUueF8wK2Uud2lkdGhfMCxlLnlfMCtlLmhlaWdodCksbixyKXx8S00obmV3IFkoZS54XzArZS53aWR0aF8wLGUueV8wK2UuaGVpZ2h0KSxuZXcgWShlLnhfMCxlLnlfMCtlLmhlaWdodCksbixyKXx8S00obmV3IFkoZS54XzAsZS55XzArZS5oZWlnaHQpLG5ldyBZKGUueF8wLGUueV8wKSxuLHIpfWZ1bmN0aW9uIEYybihlLG4pe0VnKCk7dmFyIHIsdCxvLGk7aWYobi5zaXplXzA8MilyZXR1cm4hMTtmb3IoaT1kbihuLDApLHI9YSh1bihpKSw4KSx0PXI7aS5jdXJyZW50Tm9kZSE9aS50aGlzJDAxLnRhaWw7KXtpZihvPWEodW4oaSksOCksWU0oZSx0LG8pKXJldHVybiEwO3Q9b31yZXR1cm4hIVlNKGUsdCxyKX1mdW5jdGlvbiBLTShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsaztyZXR1cm4gYz1lLGQ9cnQobmV3IFkobi54XzAsbi55XzApLGUpLF89cixmPXJ0KG5ldyBZKHQueF8wLHQueV8wKSxyKSxoPWMueF8wLHY9Yy55XzAseT1fLnhfMCxBPV8ueV8wLG09ZC54XzAseD1kLnlfMCxFPWYueF8wLGs9Zi55XzAsbz1FKngtbSprLGJzKCksa2woUXMpLFMuTWF0aC5hYnMoMC1vKTw9UXN8fG89PTB8fGlzTmFOKDApJiZpc05hTihvKT8hMToocz0xL28qKChoLXkpKngtKHYtQSkqbSksdT0xL28qLSgtKGgteSkqaysodi1BKSpFKSxpPShrbChRcyksKFMuTWF0aC5hYnMoMC1zKTw9UXN8fHM9PTB8fGlzTmFOKDApJiZpc05hTihzKT8wOjA8cz8tMTowPnM/MTpDMShpc05hTigwKSxpc05hTihzKSkpPDAmJihrbChRcyksKFMuTWF0aC5hYnMocy0xKTw9UXN8fHM9PTF8fGlzTmFOKHMpJiZpc05hTigxKT8wOnM8MT8tMTpzPjE/MTpDMShpc05hTihzKSxpc05hTigxKSkpPDApJiYoa2woUXMpLChTLk1hdGguYWJzKDAtdSk8PVFzfHx1PT0wfHxpc05hTigwKSYmaXNOYU4odSk/MDowPHU/LTE6MD51PzE6QzEoaXNOYU4oMCksaXNOYU4odSkpKTwwKSYmKGtsKFFzKSwoUy5NYXRoLmFicyh1LTEpPD1Rc3x8dT09MXx8aXNOYU4odSkmJmlzTmFOKDEpPzA6dTwxPy0xOnU+MT8xOkMxKGlzTmFOKHUpLGlzTmFOKDEpKSk8MCkpLGkpfWZ1bmN0aW9uIEpaKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaDtyZXR1cm4gYz1ydChuZXcgWShyLnhfMCxyLnlfMCksZSksXz1jLnhfMCpuLnlfMC1jLnlfMCpuLnhfMCxkPW4ueF8wKnQueV8wLW4ueV8wKnQueF8wLGY9KGMueF8wKnQueV8wLWMueV8wKnQueF8wKS9kLGg9Xy9kLGQ9PTA/Xz09MD8obz1LbihuZXcgWShyLnhfMCxyLnlfMCkseXUobmV3IFkodC54XzAsdC55XzApLC41KSksaT1VMChlLG8pLHM9VTAoS24obmV3IFkoZS54XzAsZS55XzApLG4pLG8pLHU9Uy5NYXRoLnNxcnQodC54XzAqdC54XzArdC55XzAqdC55XzApKi41LGk8cyYmaTw9dT9uZXcgWShlLnhfMCxlLnlfMCk6czw9dT9LbihuZXcgWShlLnhfMCxlLnlfMCksbik6bnVsbCk6bnVsbDpmPj0wJiZmPD0xJiZoPj0wJiZoPD0xP0tuKG5ldyBZKGUueF8wLGUueV8wKSx5dShuZXcgWShuLnhfMCxuLnlfMCksZikpOm51bGx9ZnVuY3Rpb24gdmcoZSl7RWcoKTt2YXIgbixyO2ZvcihyPUtGLG49MDtuPGUubGVuZ3RoO24rKyllW25dPnImJihyPWVbbl0pO3JldHVybiByfWZ1bmN0aW9uIFpaKGUsbil7dmFyIHIsdCxvO2ZvcihvPTEscj1lLHQ9bj49MD9uOi1uO3Q+MDspdCUyPT0wPyhyKj1yLHQ9dC8yfDApOihvKj1yLHQtPTEpO3JldHVybiBuPDA/MS9vOm99ZnVuY3Rpb24gejJuKGUsbil7dmFyIHIsdCxvO2ZvcihvPTEscj1lLHQ9bj49MD9uOi1uO3Q+MDspdCUyPT0wPyhyKj1yLHQ9dC8yfDApOihvKj1yLHQtPTEpO3JldHVybiBuPDA/MS9vOm99ZnVuY3Rpb24gJDJuKGUsbil7RWcoKTt2YXIgcix0LG8saSxzLHU7cmV0dXJuIGk9bi54XzAtKGUueF8wK2Uud2lkdGhfMCksbz1lLnhfMC0obi54XzArbi53aWR0aF8wKSxzPWUueV8wLShuLnlfMCtuLmhlaWdodCkscj1uLnlfMC0oZS55XzArZS5oZWlnaHQpLHQ9Uy5NYXRoLm1heChvLGkpLHU9Uy5NYXRoLm1heChzLHIpLGJzKCksa2woUXMpLChTLk1hdGguYWJzKHQpPD1Rc3x8dD09MHx8aXNOYU4odCkmJmlzTmFOKDApPzA6dDwwPy0xOnQ+MD8xOkMxKGlzTmFOKHQpLGlzTmFOKDApKSk+PTBeKGtsKFFzKSwoUy5NYXRoLmFicyh1KTw9UXN8fHU9PTB8fGlzTmFOKHUpJiZpc05hTigwKT8wOnU8MD8tMTp1PjA/MTpDMShpc05hTih1KSxpc05hTigwKSkpPj0wKT9TLk1hdGgubWF4KHUsdCk6KGtsKFFzKSwoUy5NYXRoLmFicyh0KTw9UXN8fHQ9PTB8fGlzTmFOKHQpJiZpc05hTigwKT8wOnQ8MD8tMTp0PjA/MTpDMShpc05hTih0KSxpc05hTigwKSkpPjA/Uy5NYXRoLnNxcnQodSp1K3QqdCk6LVMuTWF0aC5zcXJ0KHUqdSt0KnQpKX1mdW5jdGlvbiBDRGUoZSxuLHIsdCxvKXt2YXIgaSxzLHUsYztyZXR1cm4gYz1ocixzPSExLHU9SlooZSxydChuZXcgWShuLnhfMCxuLnlfMCksZSksS24obmV3IFkoci54XzAsci55XzApLG8pLHJ0KG5ldyBZKHQueF8wLHQueV8wKSxyKSksaT0hIXUmJiEoUy5NYXRoLmFicyh1LnhfMC1lLnhfMCk8PW0xJiZTLk1hdGguYWJzKHUueV8wLWUueV8wKTw9bTF8fFMuTWF0aC5hYnModS54XzAtbi54XzApPD1tMSYmUy5NYXRoLmFicyh1LnlfMC1uLnlfMCk8PW0xKSx1PUpaKGUscnQobmV3IFkobi54XzAsbi55XzApLGUpLHIsbyksdSYmKChTLk1hdGguYWJzKHUueF8wLWUueF8wKTw9bTEmJlMuTWF0aC5hYnModS55XzAtZS55XzApPD1tMSk9PShTLk1hdGguYWJzKHUueF8wLW4ueF8wKTw9bTEmJlMuTWF0aC5hYnModS55XzAtbi55XzApPD1tMSl8fGk/Yz1TLk1hdGgubWluKGMsRHYocnQodSxyKSkpOnM9ITApLHU9SlooZSxydChuZXcgWShuLnhfMCxuLnlfMCksZSksdCxvKSx1JiYoc3x8KFMuTWF0aC5hYnModS54XzAtZS54XzApPD1tMSYmUy5NYXRoLmFicyh1LnlfMC1lLnlfMCk8PW0xKT09KFMuTWF0aC5hYnModS54XzAtbi54XzApPD1tMSYmUy5NYXRoLmFicyh1LnlfMC1uLnlfMCk8PW0xKXx8aSkmJihjPVMuTWF0aC5taW4oYyxEdihydCh1LHQpKSkpLGN9dmFyIFFaO2Z1bmN0aW9uIFREZShlKXtyZXR1cm4gbmV3IFkoZS54XzAsZS55XzArZS5oZWlnaHQpfWZ1bmN0aW9uIEIybihlKXtyZXR1cm4gbmV3IFkoZS54XzArZS53aWR0aF8wLGUueV8wK2UuaGVpZ2h0KX1mdW5jdGlvbiBxTihlKXtyZXR1cm4gbmV3IFkoZS54XzArZS53aWR0aF8wLzIsZS55XzArZS5oZWlnaHQvMil9ZnVuY3Rpb24gZVEoZSl7cmV0dXJuIG5ldyBZKGUueF8wLGUueV8wKX1mdW5jdGlvbiBHMm4oZSl7cmV0dXJuIG5ldyBZKGUueF8wLGUueV8wKX1mdW5jdGlvbiBiRGUoZSxuLHIsdCxvKXtlLnhfMD1uLGUueV8wPXIsZS53aWR0aF8wPXQsZS5oZWlnaHQ9b31mdW5jdGlvbiBSdihlLG4pe3ZhciByLHQsbyxpLHM7dD1TLk1hdGgubWluKGUueF8wLG4ueF8wKSxpPVMuTWF0aC5taW4oZS55XzAsbi55XzApLG89Uy5NYXRoLm1heChlLnhfMCtlLndpZHRoXzAsbi54XzArbi53aWR0aF8wKSxzPVMuTWF0aC5tYXgoZS55XzArZS5oZWlnaHQsbi55XzArbi5oZWlnaHQpLG88dCYmKHI9dCx0PW8sbz1yKSxzPGkmJihyPWksaT1zLHM9ciksYkRlKGUsdCxpLG8tdCxzLWkpfWZ1bmN0aW9uIGltKCl7dGwuY2FsbCh0aGlzLDAsMCwwLDApfWZ1bmN0aW9uIHRsKGUsbixyLHQpe3RoaXMueF8wPWUsdGhpcy55XzA9bix0aGlzLndpZHRoXzA9cix0aGlzLmhlaWdodD10fWZ1bmN0aW9uIFlOKGUpe3RoaXMueF8wPWUueF8wLHRoaXMueV8wPWUueV8wLHRoaXMud2lkdGhfMD1lLndpZHRoXzAsdGhpcy5oZWlnaHQ9ZS5oZWlnaHR9cCgxMTYsMSx7MTE2OjF9LGltLHRsLFlOKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiBuPT1udWxsfHwhTChuLDExNik/ITE6KHI9YShuLDExNiksVW8odGhpcy54XzAsci54XzApJiZVbyh0aGlzLnlfMCxyLnlfMCkmJlVvKHRoaXMud2lkdGhfMCxyLndpZHRoXzApJiZVbyh0aGlzLmhlaWdodCxyLmhlaWdodCkpfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4ga0MoUChJKFFyLDEpLE1lLDEsNSxbdGhpcy54XzAsdGhpcy55XzAsdGhpcy53aWR0aF8wLHRoaXMuaGVpZ2h0XSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iUmVjdFt4PSIrdGhpcy54XzArIix5PSIrdGhpcy55XzArIix3PSIrdGhpcy53aWR0aF8wKyIsaD0iK3RoaXMuaGVpZ2h0KyJdIn0sbC5oZWlnaHQ9MCxsLndpZHRoXzA9MCxsLnhfMD0wLGwueV8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUubWF0aCIsIkVsa1JlY3RhbmdsZSIsMTE2KTtmdW5jdGlvbiBtZChlLG4scil7cmV0dXJuIGUueF8wKz1uLGUueV8wKz1yLGV9ZnVuY3Rpb24gS24oZSxuKXtyZXR1cm4gZS54XzArPW4ueF8wLGUueV8wKz1uLnlfMCxlfWZ1bmN0aW9uIElEZShlLG4scix0LG8pe2lmKHQ8bnx8bzxyKXRocm93IGIobmV3IEdlKCJUaGUgaGlnaHggbXVzdCBiZSBiaWdnZXIgdGhlbiBsb3d4IGFuZCB0aGUgaGlnaHkgbXVzdCBiZSBiaWdnZXIgdGhlbiBsb3d5IikpO3JldHVybiBlLnhfMDxuP2UueF8wPW46ZS54XzA+dCYmKGUueF8wPXQpLGUueV8wPHI/ZS55XzA9cjplLnlfMD5vJiYoZS55XzA9byksZX1mdW5jdGlvbiBDdChlKXtyZXR1cm4gbmV3IFkoZS54XzAsZS55XzApfWZ1bmN0aW9uIFUwKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1lLnhfMC1uLnhfMCx0PWUueV8wLW4ueV8wLFMuTWF0aC5zcXJ0KHIqcit0KnQpfWZ1bmN0aW9uIGFtKGUsbil7cmV0dXJuIGUueF8wKm4ueF8wK2UueV8wKm4ueV8wfWZ1bmN0aW9uIHhEZShlLG4pe3ZhciByO3JldHVybiBMKG4sOCk/KHI9YShuLDgpLGUueF8wPT1yLnhfMCYmZS55XzA9PXIueV8wKTohMX1mdW5jdGlvbiBEdihlKXtyZXR1cm4gUy5NYXRoLnNxcnQoZS54XzAqZS54XzArZS55XzAqZS55XzApfWZ1bmN0aW9uIEtOKGUpe3JldHVybiBlLnhfMD0tZS54XzAsZS55XzA9LWUueV8wLGV9ZnVuY3Rpb24gSDJuKGUpe3ZhciBuO3JldHVybiBuPVMuTWF0aC5zcXJ0KGUueF8wKmUueF8wK2UueV8wKmUueV8wKSxuPjAmJihlLnhfMC89bixlLnlfMC89biksZX1mdW5jdGlvbiBtcyhlKXtyZXR1cm4gZS54XzA9MCxlLnlfMD0wLGV9ZnVuY3Rpb24geXUoZSxuKXtyZXR1cm4gZS54XzAqPW4sZS55XzAqPW4sZX1mdW5jdGlvbiBVMm4oZSxuLHIpe3JldHVybiBlLnhfMCo9bixlLnlfMCo9cixlfWZ1bmN0aW9uIFhOKGUsbil7cmV0dXJuIEgybihlKSxlLnhfMCo9bixlLnlfMCo9bixlfWZ1bmN0aW9uIFcybihlLG4scil7cmV0dXJuIGUueF8wPW4sZS55XzA9cixlfWZ1bmN0aW9uIG5RKGUsbil7cmV0dXJuIGUueF8wPW4ueF8wLGUueV8wPW4ueV8wLGV9ZnVuY3Rpb24gRnYoZSxuLHIpe3JldHVybiBlLnhfMC09bixlLnlfMC09cixlfWZ1bmN0aW9uIHJ0KGUsbil7cmV0dXJuIGUueF8wLT1uLnhfMCxlLnlfMC09bi55XzAsZX1mdW5jdGlvbiBtdCgpe3RoaXMueF8wPTAsdGhpcy55XzA9MH1mdW5jdGlvbiBYTShlKXt0aGlzLnhfMD1TLk1hdGguY29zKGUpLHRoaXMueV8wPVMuTWF0aC5zaW4oZSl9ZnVuY3Rpb24gWShlLG4pe3RoaXMueF8wPWUsdGhpcy55XzA9bn1mdW5jdGlvbiBSdChlKXt0aGlzLnhfMD1lLnhfMCx0aGlzLnlfMD1lLnlfMH1mdW5jdGlvbiBQRGUoZSxuKXt2YXIgcjtmb3Iocj0wO3I8bi5sZW5ndGg7cisrKWlmKGU9PShIZShyLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQocikpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGtvKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKG49bmV3IG10LHQ9ZSxvPTAsaT10Lmxlbmd0aDtvPGk7KytvKXI9dFtvXSxuLnhfMCs9ci54XzAsbi55XzArPXIueV8wO3JldHVybiBufXAoOCwxLHszOjEsNDoxLDg6MSw0MjM6MX0sbXQsWE0sWSxSdCksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4geERlKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBjaCh0aGlzLnhfMCkrY1plKGNoKHRoaXMueV8wKSl9LGwucGFyc2VfMD1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtmb3Iobz0wO288bi5sZW5ndGgmJlBEZSgoSGUobyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KG8pKSxgKFt7IicgCVxyCmApOykrK287Zm9yKHI9bi5sZW5ndGg7cj4wJiZQRGUoKEhlKHItMSxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHItMSkpLGApXX0iJyAJXHIKYCk7KS0tcjtpZihvPj1yKXRocm93IGIobmV3IEdlKCJUaGUgZ2l2ZW4gc3RyaW5nIGRvZXMgbm90IGNvbnRhaW4gYW55IG51bWJlcnMuIikpO2lmKGk9ZWYoKGd0KG8scixuLmxlbmd0aCksbi5zdWJzdHIobyxyLW8pKSxgLHw7fFxyfApgKSxpLmxlbmd0aCE9Mil0aHJvdyBiKG5ldyBHZSgiRXhhY3RseSB0d28gbnVtYmVycyBhcmUgZXhwZWN0ZWQsICIraS5sZW5ndGgrIiB3ZXJlIGZvdW5kLiIpKTt0cnl7dGhpcy54XzA9UWQobmYoaVswXSkpLHRoaXMueV8wPVFkKG5mKGlbMV0pKX1jYXRjaChzKXt0aHJvdyBzPXdyKHMpLEwocywxMzApPyh0PXMsYihuZXcgR2UoIlRoZSBnaXZlbiBzdHJpbmcgY29udGFpbnMgcGFydHMgdGhhdCBjYW5ub3QgYmUgcGFyc2VkIGFzIG51bWJlcnMuIit0KSkpOmIocyl9fSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iKCIrdGhpcy54XzArIiwiK3RoaXMueV8wKyIpIn0sbC54XzA9MCxsLnlfMD0wO3ZhciBvdD1nKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5tYXRoIiwiS1ZlY3RvciIsOCk7ZnVuY3Rpb24genYoZSxuKXt2YXIgcix0LG8saTtmb3IodD1uLG89MCxpPXQubGVuZ3RoO288aTsrK28pcj10W29dLGJyKGUscixlLnRhaWwucHJldixlLnRhaWwpfWZ1bmN0aW9uIEpNKGUsbixyKXt2YXIgdCxvLGk7Zm9yKHQ9bmV3IHByLGk9ZG4ociwwKTtpLmN1cnJlbnROb2RlIT1pLnRoaXMkMDEudGFpbDspbz1hKHVuKGkpLDgpLExuKHQsbmV3IFJ0KG8pKTtkc2UoZSxuLHQpfWZ1bmN0aW9uIHJRKGUsbixyKXt2YXIgdCxvO2ZvcihvPWRuKGUsMCk7by5jdXJyZW50Tm9kZSE9by50aGlzJDAxLnRhaWw7KXQ9YSh1bihvKSw4KSx0LnhfMCs9bix0LnlfMCs9cjtyZXR1cm4gZX1mdW5jdGlvbiBVZihlLG4pe3ZhciByLHQ7Zm9yKHQ9ZG4oZSwwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDgpLHIueF8wKz1uLnhfMCxyLnlfMCs9bi55XzA7cmV0dXJuIGV9ZnVuY3Rpb24gajJuKGUpe3ZhciBuLHIsdDtmb3Iobj0wLHQ9QihvdCxYLDgsZS5zaXplXzAsMCwxKSxyPWRuKGUsMCk7ci5jdXJyZW50Tm9kZSE9ci50aGlzJDAxLnRhaWw7KXRbbisrXT1hKHVuKHIpLDgpO3JldHVybiB0fWZ1bmN0aW9uIGppKCl7cHIuY2FsbCh0aGlzKX1mdW5jdGlvbiBKTihlKXtpay5jYWxsKHRoaXMsZSl9ZnVuY3Rpb24gTkRlKGUpe3ByLmNhbGwodGhpcyksenYodGhpcyxlKX1mdW5jdGlvbiBDVChlKXt2YXIgbixyLHQ7Zm9yKG49bmV3IGppLHQ9ZG4oZSwwKTt0LmN1cnJlbnROb2RlIT10LnRoaXMkMDEudGFpbDspcj1hKHVuKHQpLDgpLFptKG4sMCxuZXcgUnQocikpO3JldHVybiBufXAoNzUsNjcsezM6MSw0OjEsMjA6MSwzMToxLDU2OjEsMTY6MSw2NzoxLDE1OjEsNzU6MSw0MjM6MX0samksSk4sTkRlKSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gajJuKHRoaXMpfSxsLnBhcnNlXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1O289ZWYobixgLHw7fFxcKHxcXCl8XFxbfFxcXXxcXHt8XFx9fCB8CXwKYCksa2EodGhpcyk7dHJ5e2Zvcih0PTAscz0wLGk9MCx1PTA7dDxvLmxlbmd0aDspb1t0XSE9bnVsbCYmbmYob1t0XSkubGVuZ3RoPjAmJihzJTI9PTA/aT1RZChvW3RdKTp1PVFkKG9bdF0pLHM+MCYmcyUyIT0wJiZMbih0aGlzLG5ldyBZKGksdSkpLCsrcyksKyt0fWNhdGNoKGMpe3Rocm93IGM9d3IoYyksTChjLDEzMCk/KHI9YyxiKG5ldyBHZSgiVGhlIGdpdmVuIHN0cmluZyBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciB2ZWN0b3JzLiIrcikpKTpiKGMpfX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scix0O2ZvcihuPW5ldyBMYSgiKCIpLHI9ZG4odGhpcywwKTtyLmN1cnJlbnROb2RlIT1yLnRoaXMkMDEudGFpbDspdD1hKHVuKHIpLDgpLE9uKG4sdC54XzArIiwiK3QueV8wKSxyLmN1cnJlbnROb2RlIT1yLnRoaXMkMDEudGFpbCYmKG4uc3RyaW5nKz0iOyAiKTtyZXR1cm4obi5zdHJpbmcrPSIpIixuKS5zdHJpbmd9O3ZhciB0UT1nKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5tYXRoIiwiS1ZlY3RvckNoYWluIiw3NSk7ZnVuY3Rpb24gJHUoKXskdT1GLFpNPW5ldyAkdigiQVVUT01BVElDIiwwKSxUVD1uZXcgJHYoIkxFRlQiLDEpLGJUPW5ldyAkdigiUklHSFQiLDIpLGVBPW5ldyAkdigiVE9QIiwzKSxaTj1uZXcgJHYoIkJPVFRPTSIsNCksUU49bmV3ICR2KCJDRU5URVIiLDUpfWZ1bmN0aW9uICR2KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gVjJuKGUpe3JldHVybiAkdSgpLHduKChBRGUoKSxMRGUpLGUpfWZ1bmN0aW9uIHEybigpe3JldHVybiAkdSgpLFAoSShvUSwxKSxXLDI1NSwwLFtaTSxUVCxiVCxlQSxaTixRTl0pfXAoMjU1LDIyLHszOjEsMzQ6MSwyMjoxLDI1NToxfSwkdik7dmFyIFpNLFpOLFFOLFRULGJULGVBLG9RPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiQWxpZ25tZW50IiwyNTUsZ24scTJuLFYybik7ZnVuY3Rpb24gQURlKCl7QURlPUYsTERlPXluKCgkdSgpLFAoSShvUSwxKSxXLDI1NSwwLFtaTSxUVCxiVCxlQSxaTixRTl0pKSl9dmFyIExEZTtmdW5jdGlvbiBuQSgpe25BPUYsdVE9bmV3IFcxKDE1KSxGRGU9bmV3IHl0KChGbigpLFpjKSx1USksekRlPW5ldyB5dCh0MSwxNSksY1E9bmV3IHl0KExULEooMCkpLGFRPVZEZSxSRGU9cjEsRERlPVcwLGlRPW5ldyB5dChTZyxiaWUpLGxRPU5ULHNRPXhnLFFNPVdEZSxNRGU9SVR9ZnVuY3Rpb24ga0RlKGUpe2hkKGUsbmV3IEpfKGdkKGRkKHBkKGZkKG5ldyBaXywib3JnLmVjbGlwc2UuZWxrLmJveCIpLCJFTEsgQm94IiksIkFsZ29yaXRobSBmb3IgcGFja2luZyBvZiB1bmNvbm5lY3RlZCBib3hlcywgaS5lLiBncmFwaHMgd2l0aG91dCBlZGdlcy4iKSxuZXcgJERlKSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmJveCIsIm9yZy5lY2xpcHNlLmVsay5wYWRkaW5nIix1USksWihlLCJvcmcuZWNsaXBzZS5lbGsuYm94Iiwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZU5vZGUiLDE1KSxaKGUsIm9yZy5lY2xpcHNlLmVsay5ib3giLCJvcmcuZWNsaXBzZS5lbGsucHJpb3JpdHkiLEooMCkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmJveCIsIm9yZy5lY2xpcHNlLmVsay5leHBhbmROb2RlcyIsdGUoYVEpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5ib3giLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuY29uc3RyYWludHMiLHRlKFJEZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmJveCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5vcHRpb25zIix0ZShERGUpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5ib3giLCJvcmcuZWNsaXBzZS5lbGsuYXNwZWN0UmF0aW8iLGJpZSksWihlLCJvcmcuZWNsaXBzZS5lbGsuYm94Iiwib3JnLmVjbGlwc2UuZWxrLmludGVyYWN0aXZlIix0ZShsUSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmJveCIsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5taW5pbXVtIix0ZShzUSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmJveCIsIm9yZy5lY2xpcHNlLmVsay5ib3gucGFja2luZ01vZGUiLHRlKFFNKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuYm94Iiwib3JnLmVjbGlwc2UuZWxrLmNvbnRlbnRBbGlnbm1lbnQiLHRlKE1EZSkpfWZ1bmN0aW9uIE9EZSgpe25BKCl9cCg5OTEsMSxwbCxPRGUpLGwuYXBwbHlfND1mdW5jdGlvbihuKXtrRGUobil9O3ZhciBpUSxRTSxNRGUsYVEsbFEsUkRlLHNRLEREZSxGRGUsdVEsY1EsekRlO2coIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJCb3hMYXlvdXRlck9wdGlvbnMiLDk5MSk7ZnVuY3Rpb24gJERlKCl7fXAoOTkyLDEse30sJERlKSxsLmNyZWF0ZV8wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IGl6ZSxufSxsLmRlc3Ryb3k9ZnVuY3Rpb24obil7fSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiQm94TGF5b3V0ZXJPcHRpb25zL0JveEZhY3RvcnkiLDk5Mik7ZnVuY3Rpb24gZTEoKXtlMT1GLG5SPW5ldyBCdigiVl9UT1AiLDApLFd2PW5ldyBCdigiVl9DRU5URVIiLDEpLFV2PW5ldyBCdigiVl9CT1RUT00iLDIpLGVSPW5ldyBCdigiSF9MRUZUIiwzKSxHdj1uZXcgQnYoIkhfQ0VOVEVSIiw0KSxIdj1uZXcgQnYoIkhfUklHSFQiLDUpfWZ1bmN0aW9uIEJ2KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gWTJuKGUpe3JldHVybiBlMSgpLHduKChCRGUoKSxHRGUpLGUpfWZ1bmN0aW9uIEsybigpe3JldHVybiBlMSgpLFAoSShyUiwxKSxXLDI5OCwwLFtuUixXdixVdixlUixHdixIdl0pfXAoMjk4LDIyLHszOjEsMzQ6MSwyMjoxLDI5ODoxfSxCdik7dmFyIEd2LGVSLEh2LFV2LFd2LG5SLHJSPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiQ29udGVudEFsaWdubWVudCIsMjk4LGduLEsybixZMm4pO2Z1bmN0aW9uIEJEZSgpe0JEZT1GLEdEZT15bigoZTEoKSxQKEkoclIsMSksVywyOTgsMCxbblIsV3YsVXYsZVIsR3YsSHZdKSkpfXZhciBHRGU7ZnVuY3Rpb24gRm4oKXtGbj1GO3ZhciBlLG47VHc9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsuYWxnb3JpdGhtIiksTmc9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsucmVzb2x2ZWRBbGdvcml0aG0iKSxkUT0oJHUoKSxaTSksSERlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmFsaWdubWVudCIsZFEpLFNnPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmFzcGVjdFJhdGlvIixudWxsKSxVRGU9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsuYmVuZFBvaW50cyIpLHBRPShlMSgpLGNyKG5SLFAoSShyUiwxKSxXLDI5OCwwLFtlUl0pKSksSVQ9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuY29udGVudEFsaWdubWVudCIscFEpLHhUPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmRlYnVnTW9kZSIsKHplKCksITEpKSxnUT0oV3IoKSxCcyksbjE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuZGlyZWN0aW9uIixnUSkseVE9KGZjKCksaFIpLG1RPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmVkZ2VSb3V0aW5nIix5USksVkRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmV4cGFuZE5vZGVzIiwhMSksdlE9KHBjKCksdUEpLGJnPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmhpZXJhcmNoeUhhbmRsaW5nIix2USksQVE9bmV3IFcxKDEyKSxaYz1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wYWRkaW5nIixBUSksTlQ9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuaW50ZXJhY3RpdmUiLCExKSxhUj1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5pbnRlcmFjdGl2ZUxheW91dCIsITEpLEFUPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm9taXROb2RlTWljcm9MYXlvdXQiLCExKSxSUT0oZHQoKSxxMCksanY9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucG9ydENvbnN0cmFpbnRzIixSUSksbG09bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsucG9zaXRpb24iKSxMVD1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5wcmlvcml0eSIpLGZSPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnJhbmRvbVNlZWQiKSxwUj1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5zZXBhcmF0ZUNvbm5lY3RlZENvbXBvbmVudHMiKSxTUT1uZXcgamkseWQ9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuanVuY3Rpb25Qb2ludHMiLFNRKSxqRGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuY29tbWVudEJveCIsITEpLHFEZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5oeXBlcm5vZGUiLCExKSxDUT1uZXcgdkUsYnc9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubWFyZ2lucyIsQ1EpLHJBPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm5vTGF5b3V0IiwhMSksSkRlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnNjYWxlRmFjdG9yIiwxKSxUZz1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5jaGlsZEFyZWFXaWR0aCIpLENnPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLmNoaWxkQXJlYUhlaWdodCIpLEl3PW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnRvcGRvd25MYXlvdXQiLCExKSxuZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5hbmltYXRlIiwhMCksSigwKSxuZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5hbmltVGltZUZhY3RvciIsSigxMDApKSxuZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5sYXlvdXRBbmNlc3RvcnMiLCExKSxKKDApLG5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm1heEFuaW1UaW1lIixKKDRlMykpLEooMCksbmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubWluQW5pbVRpbWUiLEooNDAwKSksbmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucHJvZ3Jlc3NCYXIiLCExKSxuZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay52YWxpZGF0ZUdyYXBoIiwhMSksbmV3IENlKCJvcmcuZWNsaXBzZS5lbGsudmFsaWRhdGVPcHRpb25zIiwhMCksbmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuem9vbVRvRml0IiwhMSksZlE9KHZBKCksVFIpLFdEZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5ib3gucGFja2luZ01vZGUiLGZRKSxaRGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5jb21tZW50Q29tbWVudCIsMTApLFFEZT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmNvbW1lbnROb2RlIiwxMCksJFE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5jb21wb25lbnRDb21wb25lbnQiLDIwKSxlRmU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5lZGdlRWRnZSIsMTApLEJRPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuZWRnZUxhYmVsIiwyKSxHUT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmVkZ2VOb2RlIiwxMCksSFE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbExhYmVsIiwwKSx0QT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmxhYmVsTm9kZSIsNSksVVE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbFBvcnRIb3Jpem9udGFsIiwxKSxXUT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmxhYmVsUG9ydFZlcnRpY2FsIiwxKSx0MT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLm5vZGVOb2RlIiwyMCksbkZlPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZVNlbGZMb29wIiwxMCkscVE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5wb3J0UG9ydCIsMTApLHNtPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuaW5kaXZpZHVhbCIpLFZRPW5ldyBad2UsalE9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5wb3J0c1N1cnJvdW5kaW5nIixWUSksS0RlPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5wYXJ0aXRpb24iKSxMUT0hMSxZRGU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucGFydGl0aW9uaW5nLmFjdGl2YXRlIixMUSksYlE9bmV3IFcxKDUpLFRRPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm5vZGVMYWJlbHMucGFkZGluZyIsYlEpLElRPShxZigpLG49YShpcyhZdCksOSksbmV3IEphKG4sYShEbChuLG4ubGVuZ3RoKSw5KSwwKSksSWc9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubm9kZUxhYmVscy5wbGFjZW1lbnQiLElRKSxPUT0oa2coKSxWMCksa1E9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5kZWZhdWx0IixPUSksc1I9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5ub3J0aCIpLHVSPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnBvcnRBbGlnbm1lbnQuc291dGgiKSxjUj1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5wb3J0QWxpZ25tZW50Lndlc3QiKSxsUj1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5wb3J0QWxpZ25tZW50LmVhc3QiKSx4UT0oZT1hKGlzKHRTKSw5KSxuZXcgSmEoZSxhKERsKGUsZS5sZW5ndGgpLDkpLDApKSxyMT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5jb25zdHJhaW50cyIseFEpLE5RPUVlKChnYSgpLEx3KSksVzA9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUub3B0aW9ucyIsTlEpLFBRPW5ldyBZKDAsMCkseGc9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUubWluaW11bSIsUFEpLFdmPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmZpeGVkR3JhcGhTaXplIiwhMSksaFE9KEdzKCkseHcpLG9SPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmVkZ2VMYWJlbHMucGxhY2VtZW50IixoUSksdFI9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuZWRnZUxhYmVscy5pbmxpbmUiLCExKSxKKDEpLG5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLmZvbnQuc2l6ZSIsbnVsbCksTVE9bmV3IHRyKCJvcmcuZWNsaXBzZS5lbGsucG9ydC5hbmNob3IiKSxfUj1uZXcgdHIoIm9yZy5lY2xpcHNlLmVsay5wb3J0LmluZGV4IikselE9KHJlKCksT28pLFBnPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnBvcnQuc2lkZSIselEpLHBhPW5ldyB0cigib3JnLmVjbGlwc2UuZWxrLnBvcnQuYm9yZGVyT2Zmc2V0IiksRFE9KGFhKCksRWUoWTApKSxqZj1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wb3J0TGFiZWxzLnBsYWNlbWVudCIsRFEpLGRSPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMubmV4dFRvUG9ydElmUG9zc2libGUiLCExKSxGUT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5wb3J0TGFiZWxzLnRyZWF0QXNHcm91cCIsITApLGlBPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2NhbGVGYWN0b3IiLDEpLFlRPW5ldyBDZSgib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2l6ZUFwcHJveGltYXRvciIsbnVsbCksa1Q9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5oaWVyYXJjaGljYWxOb2RlV2lkdGgiLDE1MCksb0E9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5oaWVyYXJjaGljYWxOb2RlQXNwZWN0UmF0aW8iLDEuNDE0KSx1bT1uZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLm5vZGVUeXBlIixudWxsKSxyRmU9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5zY2FsZUNhcCIsMSksUFQ9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuaW5zaWRlU2VsZkxvb3BzLmFjdGl2YXRlIiwhMSksaVI9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuaW5zaWRlU2VsZkxvb3BzLnlvIiwhMSksd1E9bmV3IENlKCJvcmcuZWNsaXBzZS5lbGsuZWRnZS50aGlja25lc3MiLDEpLEVRPShsQSgpLHlSKSxuZXcgQ2UoIm9yZy5lY2xpcHNlLmVsay5lZGdlLnR5cGUiLEVRKSxYRGU9ITAsb0ZlPShwbSgpLEtmKSxpRmU9S2YsdEZlPUtmfWZ1bmN0aW9uIF9RKCl7Rm4oKX1wKDY5OSwxLHBsLF9RKSxsLmFwcGx5XzQ9ZnVuY3Rpb24obil7X2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuYWxnb3JpdGhtIiksIiIpLCJMYXlvdXQgQWxnb3JpdGhtIiksIlNlbGVjdCBhIHNwZWNpZmljIGxheW91dCBhbGdvcml0aG0uIiksKEpjKCksd2cpKSxzZSksRWUoKGhzKCksT2UpKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5yZXNvbHZlZEFsZ29yaXRobSIpLCIiKSwiUmVzb2x2ZWQgTGF5b3V0IEFsZ29yaXRobSIpLCJNZXRhIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWxlY3RlZCBhbGdvcml0aG0uIiksenMpLHkybiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmFsaWdubWVudCIpLCIiKSwiQWxpZ25tZW50IiksIkFsaWdubWVudCBvZiB0aGUgc2VsZWN0ZWQgbm9kZSByZWxhdGl2ZSB0byBvdGhlciBub2RlczsgdGhlIGV4YWN0IG1lYW5pbmcgZGVwZW5kcyBvbiB0aGUgdXNlZCBhbGdvcml0aG0uIiksZFEpLG1yKSxvUSksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmFzcGVjdFJhdGlvIiksIiIpLCJBc3BlY3QgUmF0aW8iKSwiVGhlIGRlc2lyZWQgYXNwZWN0IHJhdGlvIG9mIHRoZSBkcmF3aW5nLCB0aGF0IGlzIHRoZSBxdW90aWVudCBvZiB3aWR0aCBieSBoZWlnaHQuIiksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuYmVuZFBvaW50cyIpLCIiKSwiQmVuZCBQb2ludHMiKSwiQSBmaXhlZCBsaXN0IG9mIGJlbmQgcG9pbnRzIGZvciB0aGUgZWRnZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSAnRml4ZWQgTGF5b3V0JyBhbGdvcml0aG0gdG8gc3BlY2lmeSBhIHByZS1kZWZpbmVkIHJvdXRpbmcgZm9yIGFuIGVkZ2UuIFRoZSB2ZWN0b3IgY2hhaW4gbXVzdCBpbmNsdWRlIHRoZSBzb3VyY2UgcG9pbnQsIGFueSBiZW5kIHBvaW50cywgYW5kIHRoZSB0YXJnZXQgcG9pbnQsIHNvIGl0IG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gcG9pbnRzLiIpLHpzKSx0USksRWUobXUpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmNvbnRlbnRBbGlnbm1lbnQiKSwiIiksIkNvbnRlbnQgQWxpZ25tZW50IiksIlNwZWNpZmllcyBob3cgdGhlIGNvbnRlbnQgb2YgYSBub2RlIGFyZSBhbGlnbmVkLiBFYWNoIG5vZGUgY2FuIGluZGl2aWR1YWxseSBjb250cm9sIHRoZSBhbGlnbm1lbnQgb2YgaXRzIGNvbnRlbnRzLiBJLmUuIGlmIGEgbm9kZSBzaG91bGQgYmUgYWxpZ25lZCB0b3AgbGVmdCBpbiBpdHMgcGFyZW50IG5vZGUsIHRoZSBwYXJlbnQgbm9kZSBzaG91bGQgc3BlY2lmeSB0aGF0IG9wdGlvbi4iKSxwUSksb20pLHJSKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZGVidWdNb2RlIiksIiIpLCJEZWJ1ZyBNb2RlIiksIldoZXRoZXIgYWRkaXRpb25hbCBkZWJ1ZyBpbmZvcm1hdGlvbiBzaGFsbCBiZSBnZW5lcmF0ZWQuIiksKHplKCksITEpKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5kaXJlY3Rpb24iKSwiIiksIkRpcmVjdGlvbiIpLCJPdmVyYWxsIGRpcmVjdGlvbiBvZiBlZGdlczogaG9yaXpvbnRhbCAocmlnaHQgLyBsZWZ0KSBvciB2ZXJ0aWNhbCAoZG93biAvIHVwKS4iKSxnUSksbXIpLFZ2KSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZWRnZVJvdXRpbmciKSwiIiksIkVkZ2UgUm91dGluZyIpLCJXaGF0IGtpbmQgb2YgZWRnZSByb3V0aW5nIHN0eWxlIHNob3VsZCBiZSBhcHBsaWVkIGZvciB0aGUgY29udGVudCBvZiBhIHBhcmVudCBub2RlLiBBbGdvcml0aG1zIG1heSBhbHNvIHNldCB0aGlzIG9wdGlvbiB0byBzaW5nbGUgZWRnZXMgaW4gb3JkZXIgdG8gbWFyayB0aGVtIGFzIHNwbGluZXMuIFRoZSBiZW5kIHBvaW50IGxpc3Qgb2YgZWRnZXMgd2l0aCB0aGlzIG9wdGlvbiBzZXQgdG8gU1BMSU5FUyBtdXN0IGJlIGludGVycHJldGVkIGFzIGNvbnRyb2wgcG9pbnRzIGZvciBhIHBpZWNld2lzZSBjdWJpYyBzcGxpbmUuIikseVEpLG1yKSxtUiksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmV4cGFuZE5vZGVzIiksIiIpLCJFeHBhbmQgTm9kZXMiKSwiSWYgYWN0aXZlLCBub2RlcyBhcmUgZXhwYW5kZWQgdG8gZmlsbCB0aGUgYXJlYSBvZiB0aGVpciBwYXJlbnQuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmhpZXJhcmNoeUhhbmRsaW5nIiksIiIpLCJIaWVyYXJjaHkgSGFuZGxpbmciKSwiRGV0ZXJtaW5lcyB3aGV0aGVyIHNlcGFyYXRlIGxheW91dCBydW5zIGFyZSB0cmlnZ2VyZWQgZm9yIGRpZmZlcmVudCBjb21wb3VuZCBub2RlcyBpbiBhIGhpZXJhcmNoaWNhbCBncmFwaC4gU2V0dGluZyBhIG5vZGUncyBoaWVyYXJjaHkgaGFuZGxpbmcgdG8gYElOQ0xVREVfQ0hJTERSRU5gIHdpbGwgbGF5IG91dCB0aGF0IG5vZGUgYW5kIGFsbCBvZiBpdHMgZGVzY2VuZGFudHMgaW4gYSBzaW5nbGUgbGF5b3V0IHJ1biwgdW50aWwgYSBkZXNjZW5kYW50IGlzIGVuY291bnRlcmVkIHdoaWNoIGhhcyBpdHMgaGllcmFyY2h5IGhhbmRsaW5nIHNldCB0byBgU0VQQVJBVEVfQ0hJTERSRU5gLiBJbiBnZW5lcmFsLCBgU0VQQVJBVEVfQ0hJTERSRU5gIHdpbGwgZW5zdXJlIHRoYXQgYSBuZXcgbGF5b3V0IHJ1biBpcyB0cmlnZ2VyZWQgZm9yIGEgbm9kZSB3aXRoIHRoYXQgc2V0dGluZy4gSW5jbHVkaW5nIG11bHRpcGxlIGxldmVscyBvZiBoaWVyYXJjaHkgaW4gYSBzaW5nbGUgbGF5b3V0IHJ1biBtYXkgYWxsb3cgY3Jvc3MtaGllcmFyY2hpY2FsIGVkZ2VzIHRvIGJlIGxhaWQgb3V0IHByb3Blcmx5LiBJZiB0aGUgcm9vdCBub2RlIGlzIHNldCB0byBgSU5IRVJJVGAgKG9yIG5vdCBzZXQgYXQgYWxsKSwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNFUEFSQVRFX0NISUxEUkVOYC4iKSx2USksbXIpLGxlZSksY3IoT2UsUChJKHp1LDEpLFcsMTcwLDAsW0pyXSkpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBhZGRpbmciKSwiIiksIlBhZGRpbmciKSwiVGhlIHBhZGRpbmcgdG8gYmUgbGVmdCB0byBhIHBhcmVudCBlbGVtZW50J3MgYm9yZGVyIHdoZW4gcGxhY2luZyBjaGlsZCBlbGVtZW50cy4gVGhpcyBjYW4gYWxzbyBzZXJ2ZSBhcyBhbiBvdXRwdXQgb3B0aW9uIG9mIGEgbGF5b3V0IGFsZ29yaXRobSBpZiBub2RlIHNpemUgY2FsY3VsYXRpb24gaXMgc2V0dXAgYXBwcm9wcmlhdGVseS4iKSxBUSksenMpLEhXKSxjcihPZSxQKEkoenUsMSksVywxNzAsMCxbSnJdKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuaW50ZXJhY3RpdmUiKSwiIiksIkludGVyYWN0aXZlIiksIldoZXRoZXIgdGhlIGFsZ29yaXRobSBzaG91bGQgYmUgcnVuIGluIGludGVyYWN0aXZlIG1vZGUgZm9yIHRoZSBjb250ZW50IG9mIGEgcGFyZW50IG5vZGUuIFdoYXQgdGhpcyBtZWFucyBleGFjdGx5IGRlcGVuZHMgb24gaG93IHRoZSBzcGVjaWZpYyBhbGdvcml0aG0gaW50ZXJwcmV0cyB0aGlzIG9wdGlvbi4gVXN1YWxseSBpbiB0aGUgaW50ZXJhY3RpdmUgbW9kZSBhbGdvcml0aG1zIHRyeSB0byBtb2RpZnkgdGhlIGN1cnJlbnQgbGF5b3V0IGFzIGxpdHRsZSBhcyBwb3NzaWJsZS4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuaW50ZXJhY3RpdmVMYXlvdXQiKSwiIiksImludGVyYWN0aXZlIExheW91dCIpLCJXaGV0aGVyIHRoZSBncmFwaCBzaG91bGQgYmUgY2hhbmdlYWJsZSBpbnRlcmFjdGl2ZWx5IGFuZCBieSBzZXR0aW5nIGNvbnN0cmFpbnRzIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm9taXROb2RlTWljcm9MYXlvdXQiKSwiIiksIk9taXQgTm9kZSBNaWNybyBMYXlvdXQiKSwiTm9kZSBtaWNybyBsYXlvdXQgY29tcHJpc2VzIHRoZSBjb21wdXRhdGlvbiBvZiBub2RlIGRpbWVuc2lvbnMgKGlmIHJlcXVlc3RlZCksIHRoZSBwbGFjZW1lbnQgb2YgcG9ydHMgYW5kIHRoZWlyIGxhYmVscywgYW5kIHRoZSBwbGFjZW1lbnQgb2Ygbm9kZSBsYWJlbHMuIFRoZSBmdW5jdGlvbmFsaXR5IGlzIGltcGxlbWVudGVkIGluZGVwZW5kZW50IG9mIGFueSBzcGVjaWZpYyBsYXlvdXQgYWxnb3JpdGhtIGFuZCBzaG91bGRuJ3QgaGF2ZSBhbnkgbmVnYXRpdmUgaW1wYWN0IG9uIHRoZSBsYXlvdXQgYWxnb3JpdGhtJ3MgcGVyZm9ybWFuY2UgaXRzZWxmLiBZZXQsIGlmIGFueSB1bmZvcmVzZWVuIGJlaGF2aW9yIG9jY3VycywgdGhpcyBvcHRpb24gYWxsb3dzIHRvIGRlYWN0aXZhdGUgdGhlIG1pY3JvIGxheW91dC4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydENvbnN0cmFpbnRzIiksIiIpLCJQb3J0IENvbnN0cmFpbnRzIiksIkRlZmluZXMgY29uc3RyYWludHMgb2YgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3J0cyBvZiBhIG5vZGUuIiksUlEpLG1yKSxjZWUpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5wb3NpdGlvbiIpLCIiKSwiUG9zaXRpb24iKSwiVGhlIHBvc2l0aW9uIG9mIGEgbm9kZSwgcG9ydCwgb3IgbGFiZWwuIFRoaXMgaXMgdXNlZCBieSB0aGUgJ0ZpeGVkIExheW91dCcgYWxnb3JpdGhtIHRvIHNwZWNpZnkgYSBwcmUtZGVmaW5lZCBwb3NpdGlvbi4iKSx6cyksb3QpLGNyKEpyLFAoSSh6dSwxKSxXLDE3MCwwLFtRXyxYY10pKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5wcmlvcml0eSIpLCIiKSwiUHJpb3JpdHkiKSwiRGVmaW5lcyB0aGUgcHJpb3JpdHkgb2YgYW4gb2JqZWN0OyBpdHMgbWVhbmluZyBkZXBlbmRzIG9uIHRoZSBzcGVjaWZpYyBsYXlvdXQgYWxnb3JpdGhtIGFuZCB0aGUgY29udGV4dCB3aGVyZSBpdCBpcyB1c2VkLiIpLGJvKSx2dCksY3IoSnIsUChJKHp1LDEpLFcsMTcwLDAsW211XSkpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnJhbmRvbVNlZWQiKSwiIiksIlJhbmRvbWl6YXRpb24gU2VlZCIpLCJTZWVkIHVzZWQgZm9yIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvcnMgdG8gY29udHJvbCB0aGUgbGF5b3V0IGFsZ29yaXRobS4gSWYgdGhlIHZhbHVlIGlzIDAsIHRoZSBzZWVkIHNoYWxsIGJlIGRldGVybWluZWQgcHNldWRvLXJhbmRvbWx5IChlLmcuIGZyb20gdGhlIHN5c3RlbSB0aW1lKS4iKSxibyksdnQpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zZXBhcmF0ZUNvbm5lY3RlZENvbXBvbmVudHMiKSwiIiksIlNlcGFyYXRlIENvbm5lY3RlZCBDb21wb25lbnRzIiksIldoZXRoZXIgZWFjaCBjb25uZWN0ZWQgY29tcG9uZW50IHNob3VsZCBiZSBwcm9jZXNzZWQgc2VwYXJhdGVseS4iKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5qdW5jdGlvblBvaW50cyIpLCIiKSwiSnVuY3Rpb24gUG9pbnRzIiksIlRoaXMgb3B0aW9uIGlzIG5vdCB1c2VkIGFzIG9wdGlvbiwgYnV0IGFzIG91dHB1dCBvZiB0aGUgbGF5b3V0IGFsZ29yaXRobXMuIEl0IGlzIGF0dGFjaGVkIHRvIGVkZ2VzIGFuZCBkZXRlcm1pbmVzIHRoZSBwb2ludHMgd2hlcmUganVuY3Rpb24gc3ltYm9scyBzaG91bGQgYmUgZHJhd24gaW4gb3JkZXIgdG8gcmVwcmVzZW50IGh5cGVyZWRnZXMgd2l0aCBvcnRob2dvbmFsIHJvdXRpbmcuIFdoZXRoZXIgc3VjaCBwb2ludHMgYXJlIGNvbXB1dGVkIGRlcGVuZHMgb24gdGhlIGNob3NlbiBsYXlvdXQgYWxnb3JpdGhtIGFuZCBlZGdlIHJvdXRpbmcgc3R5bGUuIFRoZSBwb2ludHMgYXJlIHB1dCBpbnRvIHRoZSB2ZWN0b3IgY2hhaW4gd2l0aCBubyBzcGVjaWZpYyBvcmRlci4iKSxTUSksenMpLHRRKSxFZShtdSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuY29tbWVudEJveCIpLCIiKSwiQ29tbWVudCBCb3giKSwiV2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgcmVnYXJkZWQgYXMgYSBjb21tZW50IGJveCBpbnN0ZWFkIG9mIGEgcmVndWxhciBub2RlLiBJbiB0aGF0IGNhc2UgaXRzIHBsYWNlbWVudCBzaG91bGQgYmUgc2ltaWxhciB0byBob3cgbGFiZWxzIGFyZSBoYW5kbGVkLiBBbnkgZWRnZXMgaW5jaWRlbnQgdG8gYSBjb21tZW50IGJveCBzcGVjaWZ5IHRvIHdoaWNoIGdyYXBoIGVsZW1lbnRzIHRoZSBjb21tZW50IGlzIHJlbGF0ZWQuIiksITEpLG50KSxBciksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmh5cGVybm9kZSIpLCIiKSwiSHlwZXJub2RlIiksIldoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGhhbmRsZWQgYXMgYSBoeXBlcm5vZGUuIiksITEpLG50KSxBciksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmxhYmVsTWFuYWdlciIpLCIiKSwiTGFiZWwgTWFuYWdlciIpLCJMYWJlbCBtYW5hZ2VycyBjYW4gc2hvcnRlbiBsYWJlbHMgdXBvbiBhIGxheW91dCBhbGdvcml0aG0ncyByZXF1ZXN0LiIpLHpzKSxJSW4pLGNyKE9lLFAoSSh6dSwxKSxXLDE3MCwwLFtYY10pKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5tYXJnaW5zIiksIiIpLCJNYXJnaW5zIiksIk1hcmdpbnMgZGVmaW5lIGFkZGl0aW9uYWwgc3BhY2UgYXJvdW5kIHRoZSBhY3R1YWwgYm91bmRzIG9mIGEgZ3JhcGggZWxlbWVudC4gRm9yIGluc3RhbmNlLCBwb3J0cyBvciBsYWJlbHMgYmVpbmcgcGxhY2VkIG9uIHRoZSBvdXRzaWRlIG9mIGEgbm9kZSdzIGJvcmRlciBtaWdodCBpbnRyb2R1Y2Ugc3VjaCBhIG1hcmdpbi4gVGhlIG1hcmdpbiBpcyB1c2VkIHRvIGd1YXJhbnRlZSBub24tb3ZlcmxhcCBvZiBvdGhlciBncmFwaCBlbGVtZW50cyB3aXRoIHRob3NlIHBvcnRzIG9yIGxhYmVscy4iKSxDUSksenMpLERXKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubm9MYXlvdXQiKSwiIiksIk5vIExheW91dCIpLCJObyBsYXlvdXQgaXMgZG9uZSBmb3IgdGhlIGFzc29jaWF0ZWQgZWxlbWVudC4gVGhpcyBpcyB1c2VkIHRvIG1hcmsgcGFydHMgb2YgYSBkaWFncmFtIHRvIGF2b2lkIHRoZWlyIGluY2x1c2lvbiBpbiB0aGUgbGF5b3V0IGdyYXBoLCBvciB0byBtYXJrIHBhcnRzIG9mIHRoZSBsYXlvdXQgZ3JhcGggdG8gcHJldmVudCBsYXlvdXQgZW5naW5lcyBmcm9tIHByb2Nlc3NpbmcgdGhlbS4gSWYgeW91IHdpc2ggdG8gZXhjbHVkZSB0aGUgY29udGVudHMgb2YgYSBjb21wb3VuZCBub2RlIGZyb20gYXV0b21hdGljIGxheW91dCwgd2hpbGUgdGhlIG5vZGUgaXRzZWxmIGlzIHN0aWxsIGNvbnNpZGVyZWQgb24gaXRzIG93biBsYXllciwgdXNlIHRoZSAnRml4ZWQgTGF5b3V0JyBhbGdvcml0aG0gZm9yIHRoYXQgbm9kZS4iKSwhMSksbnQpLEFyKSxjcihKcixQKEkoenUsMSksVywxNzAsMCxbbXUsUV8sWGNdKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc2NhbGVGYWN0b3IiKSwiIiksIlNjYWxlIEZhY3RvciIpLCJUaGUgc2NhbGluZyBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byB0aGUgY29ycmVzcG9uZGluZyBub2RlIGluIHJlY3Vyc2l2ZSBsYXlvdXQuIEl0IGNhdXNlcyB0aGUgY29ycmVzcG9uZGluZyBub2RlJ3Mgc2l6ZSB0byBiZSBhZGp1c3RlZCwgYW5kIGl0cyBwb3J0cyBhbmQgbGFiZWxzIHRvIGJlIHNpemVkIGFuZCBwbGFjZWQgYWNjb3JkaW5nbHkgYWZ0ZXIgdGhlIGxheW91dCBvZiB0aGF0IG5vZGUgaGFzIGJlZW4gZGV0ZXJtaW5lZCAoYW5kIGJlZm9yZSB0aGUgbm9kZSBpdHNlbGYgYW5kIGl0cyBzaWJsaW5ncyBhcmUgYXJyYW5nZWQpLiBUaGUgc2NhbGluZyBpcyBub3QgcmV2ZXJ0ZWQgYWZ0ZXJ3YXJkcywgc28gdGhlIHJlc3VsdGluZyBsYXlvdXQgZ3JhcGggY29udGFpbnMgdGhlIGFkanVzdGVkIHNpemUgYW5kIHBvc2l0aW9uIGRhdGEuIFRoaXMgb3B0aW9uIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGlmICdMYXlvdXQgSGllcmFyY2h5JyBpcyBzZXQuIiksMSksUHQpLCRyKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuY2hpbGRBcmVhV2lkdGgiKSwiIiksIkNoaWxkIEFyZWEgV2lkdGgiKSwiVGhlIHdpZHRoIG9mIHRoZSBhcmVhIG9jY3VwaWVkIGJ5IHRoZSBsYWlkIG91dCBjaGlsZHJlbiBvZiBhIG5vZGUuIiksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuY2hpbGRBcmVhSGVpZ2h0IiksIiIpLCJDaGlsZCBBcmVhIEhlaWdodCIpLCJUaGUgaGVpZ2h0IG9mIHRoZSBhcmVhIG9jY3VwaWVkIGJ5IHRoZSBsYWlkIG91dCBjaGlsZHJlbiBvZiBhIG5vZGUuIiksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bkxheW91dCIpLCIiKSwiVG9wZG93biBMYXlvdXQiKSwiVHVybnMgdG9wZG93biBsYXlvdXQgb24gYW5kIG9mZi4gSWYgdGhpcyBvcHRpb24gaXMgZW5hYmxlZCwgaGllcmFyY2hpY2FsIGxheW91dCB3aWxsIGJlIGNvbXB1dGVkIGZpcnN0IGZvciB0aGUgcm9vdCBub2RlIGFuZCB0aGVuIGZvciBpdHMgY2hpbGRyZW4gcmVjdXJzaXZlbHkuIExheW91dHMgYXJlIHRoZW4gc2NhbGVkIGRvd24gdG8gZml0IHRoZSBhcmVhIHByb3ZpZGVkIGJ5IHRoZWlyIHBhcmVudHMuIEdyYXBocyBtdXN0IGZvbGxvdyBhIGNlcnRhaW4gc3RydWN0dXJlIGZvciB0b3Bkb3duIGxheW91dCB0byB3b3JrIHByb3Blcmx5LiB7QGxpbmsgVG9wZG93bk5vZGVUeXBlcy5QQVJBTExFTF9OT0RFfSBub2RlcyBtdXN0IGhhdmUgY2hpbGRyZW4gb2YgdHlwZSB7QGxpbmsgVG9wZG93bk5vZGVUeXBlcy5ISUVSQVJDSElDQUxfTk9ERX0gYW5kIG11c3QgZGVmaW5lIHtAbGluayB0b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVXaWR0aH0gYW5kIHtAbGluayB0b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVBc3BlY3RSYXRpb30gZm9yIHRoZWlyIGNoaWxkcmVuLiBGdXJ0aGVybW9yZSB0aGV5IG5lZWQgdG8gYmUgbGFpZCBvdXQgdXNpbmcgYW4gYWxnb3JpdGhtIHRoYXQgaXMgYSB7QGxpbmsgVG9wZG93bkxheW91dFByb3ZpZGVyfS4gSGllcmFyY2hpY2FsIG5vZGVzIGNhbiBhbHNvIGJlIHBhcmVudHMgb2Ygb3RoZXIgaGllcmFyY2hpY2FsIG5vZGVzIGFuZCBjYW4gb3B0aW9uYWxseSB1c2UgYSB7QGxpbmsgVG9wZG93blNpemVBcHByb3hpbWF0b3J9IHRvIGR5bmFtaWNhbGx5IHNldCBzaXplcyBkdXJpbmcgdG9wZG93biBsYXlvdXQuIEluIHRoaXMgY2FzZSB7QGxpbmsgdG9wZG93bi5oaWVyYXJjaGljYWxOb2RlV2lkdGh9IGFuZCB7QGxpbmsgdG9wZG93bi5oaWVyYXJjaGljYWxOb2RlQXNwZWN0UmF0aW99IHNob3VsZCBiZSBzZXQgb24gdGhlIG5vZGUgaXRzZWxmIHJhdGhlciB0aGFuIHRoZSBwYXJlbnQuIFRoZSB2YWx1ZXMgYXJlIHRoZW4gdXNlZCBieSB0aGUgc2l6ZSBhcHByb3hpbWF0b3IgYXMgYmFzZSB2YWx1ZXMuIEhpZXJhcmNoaWNhbCBub2RlcyByZXF1aXJlIHRoZSBsYXlvdXQgb3B0aW9uIHtAbGluayBub2RlU2l6ZS5maXhlZEdyYXBoU2l6ZX0gdG8gYmUgdHJ1ZSB0byBwcmV2ZW50IHRoZSBhbGdvcml0aG0gdXNlZCB0aGVyZSBmcm9tIHJlc2l6aW5nIHRoZSBoaWVyYXJjaGljYWwgbm9kZS4gVGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpZiAnSGllcmFyY2h5IEhhbmRsaW5nJyBpcyBzZXQgdG8gJ0lOQ0xVREVfQ0hJTERSRU4nIiksITEpLG50KSxBciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duTGF5b3V0Iiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24ubm9kZVR5cGUiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmFuaW1hdGUiKSwiIiksIkFuaW1hdGUiKSwiV2hldGhlciB0aGUgc2hpZnQgZnJvbSB0aGUgb2xkIGxheW91dCB0byB0aGUgbmV3IGNvbXB1dGVkIGxheW91dCBzaGFsbCBiZSBhbmltYXRlZC4iKSwhMCksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuYW5pbVRpbWVGYWN0b3IiKSwiIiksIkFuaW1hdGlvbiBUaW1lIEZhY3RvciIpLCJGYWN0b3IgZm9yIGNvbXB1dGF0aW9uIG9mIGFuaW1hdGlvbiB0aW1lLiBUaGUgaGlnaGVyIHRoZSB2YWx1ZSwgdGhlIGxvbmdlciB0aGUgYW5pbWF0aW9uIHRpbWUuIElmIHRoZSB2YWx1ZSBpcyAwLCB0aGUgcmVzdWx0aW5nIHRpbWUgaXMgYWx3YXlzIGVxdWFsIHRvIHRoZSBtaW5pbXVtIGRlZmluZWQgYnkgJ01pbmltYWwgQW5pbWF0aW9uIFRpbWUnLiIpLEooMTAwKSksYm8pLHZ0KSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubGF5b3V0QW5jZXN0b3JzIiksIiIpLCJMYXlvdXQgQW5jZXN0b3JzIiksIldoZXRoZXIgdGhlIGhpZXJhcmNoeSBsZXZlbHMgb24gdGhlIHBhdGggZnJvbSB0aGUgc2VsZWN0ZWQgZWxlbWVudCB0byB0aGUgcm9vdCBvZiB0aGUgZGlhZ3JhbSBzaGFsbCBiZSBpbmNsdWRlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3MuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm1heEFuaW1UaW1lIiksIiIpLCJNYXhpbWFsIEFuaW1hdGlvbiBUaW1lIiksIlRoZSBtYXhpbWFsIHRpbWUgZm9yIGFuaW1hdGlvbnMsIGluIG1pbGxpc2Vjb25kcy4iKSxKKDRlMykpLGJvKSx2dCksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm1pbkFuaW1UaW1lIiksIiIpLCJNaW5pbWFsIEFuaW1hdGlvbiBUaW1lIiksIlRoZSBtaW5pbWFsIHRpbWUgZm9yIGFuaW1hdGlvbnMsIGluIG1pbGxpc2Vjb25kcy4iKSxKKDQwMCkpLGJvKSx2dCksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnByb2dyZXNzQmFyIiksIiIpLCJQcm9ncmVzcyBCYXIiKSwiV2hldGhlciBhIHByb2dyZXNzIGJhciBzaGFsbCBiZSBkaXNwbGF5ZWQgZHVyaW5nIGxheW91dCBjb21wdXRhdGlvbnMuIiksITEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnZhbGlkYXRlR3JhcGgiKSwiIiksIlZhbGlkYXRlIEdyYXBoIiksIldoZXRoZXIgdGhlIGdyYXBoIHNoYWxsIGJlIHZhbGlkYXRlZCBiZWZvcmUgYW55IGxheW91dCBhbGdvcml0aG0gaXMgYXBwbGllZC4gSWYgdGhpcyBvcHRpb24gaXMgZW5hYmxlZCBhbmQgYXQgbGVhc3Qgb25lIGVycm9yIGlzIGZvdW5kLCB0aGUgbGF5b3V0IHByb2Nlc3MgaXMgYWJvcnRlZCBhbmQgYSBtZXNzYWdlIGlzIHNob3duIHRvIHRoZSB1c2VyLiIpLCExKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay52YWxpZGF0ZU9wdGlvbnMiKSwiIiksIlZhbGlkYXRlIE9wdGlvbnMiKSwiV2hldGhlciBsYXlvdXQgb3B0aW9ucyBzaGFsbCBiZSB2YWxpZGF0ZWQgYmVmb3JlIGFueSBsYXlvdXQgYWxnb3JpdGhtIGlzIGFwcGxpZWQuIElmIHRoaXMgb3B0aW9uIGlzIGVuYWJsZWQgYW5kIGF0IGxlYXN0IG9uZSBlcnJvciBpcyBmb3VuZCwgdGhlIGxheW91dCBwcm9jZXNzIGlzIGFib3J0ZWQgYW5kIGEgbWVzc2FnZSBpcyBzaG93biB0byB0aGUgdXNlci4iKSwhMCksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuem9vbVRvRml0IiksIiIpLCJab29tIHRvIEZpdCIpLCJXaGV0aGVyIHRoZSB6b29tIGxldmVsIHNoYWxsIGJlIHNldCB0byB2aWV3IHRoZSB3aG9sZSBkaWFncmFtIGFmdGVyIGxheW91dC4iKSwhMSksbnQpLEFyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuYm94LnBhY2tpbmdNb2RlIiksImJveCIpLCJCb3ggTGF5b3V0IE1vZGUiKSwiQ29uZmlndXJlcyB0aGUgcGFja2luZyBtb2RlIHVzZWQgYnkgdGhlIHtAbGluayBCb3hMYXlvdXRQcm92aWRlcn0uIElmIFNJTVBMRSBpcyBub3QgcmVxdWlyZWQgKG5laXRoZXIgcHJpb3JpdGllcyBhcmUgdXNlZCBub3IgdGhlIGludGVyYWN0aXZlIG1vZGUpLCBHUk9VUF9ERUMgY2FuIGltcHJvdmUgdGhlIHBhY2tpbmcgYW5kIGRlY3JlYXNlIHRoZSBhcmVhLiBHUk9VUF9NSVhFRCBhbmQgR1JPVVBfSU5DIG1heSwgaW4gdmVyeSBzcGVjaWZpYyBzY2VuYXJpb3MsIHdvcmsgYmV0dGVyLiIpLGZRKSxtciksVGVlKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5jb21tZW50Q29tbWVudCIpLCJzcGFjaW5nIiksIkNvbW1lbnQgQ29tbWVudCBTcGFjaW5nIiksIlNwYWNpbmcgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gYSBjb21tZW50IGJveCBhbmQgb3RoZXIgY29tbWVudCBib3hlcyBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbm9kZS4gVGhlIHNwYWNlIGxlZnQgYmV0d2VlbiBjb21tZW50IGJveGVzIG9mIGRpZmZlcmVudCBub2RlcyBpcyBjb250cm9sbGVkIGJ5IHRoZSBub2RlLW5vZGUgc3BhY2luZy4iKSwxMCksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5jb21tZW50Tm9kZSIpLCJzcGFjaW5nIiksIkNvbW1lbnQgTm9kZSBTcGFjaW5nIiksIlNwYWNpbmcgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gYSBub2RlIGFuZCBpdHMgY29ubmVjdGVkIGNvbW1lbnQgYm94ZXMuIFRoZSBzcGFjZSBsZWZ0IGJldHdlZW4gYSBub2RlIGFuZCB0aGUgY29tbWVudHMgb2YgYW5vdGhlciBub2RlIGlzIGNvbnRyb2xsZWQgYnkgdGhlIG5vZGUtbm9kZSBzcGFjaW5nLiIpLDEwKSxQdCksJHIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmNvbXBvbmVudENvbXBvbmVudCIpLCJzcGFjaW5nIiksIkNvbXBvbmVudHMgU3BhY2luZyIpLCJTcGFjaW5nIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIHBhaXJzIG9mIGNvbm5lY3RlZCBjb21wb25lbnRzLiBUaGlzIG9wdGlvbiBpcyBvbmx5IHJlbGV2YW50IGlmICdzZXBhcmF0ZUNvbm5lY3RlZENvbXBvbmVudHMnIGlzIGFjdGl2YXRlZC4iKSwyMCksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5lZGdlRWRnZSIpLCJzcGFjaW5nIiksIkVkZ2UgU3BhY2luZyIpLCJTcGFjaW5nIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGFueSB0d28gZWRnZXMuIE5vdGUgdGhhdCB3aGlsZSB0aGlzIGNhbiBzb21ld2hhdCBlYXNpbHkgYmUgc2F0aXNmaWVkIGZvciB0aGUgc2VnbWVudHMgb2Ygb3J0aG9nb25hbGx5IGRyYXduIGVkZ2VzLCBpdCBpcyBoYXJkZXIgZm9yIGdlbmVyYWwgcG9seWxpbmVzIG9yIHNwbGluZXMuIiksMTApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuZWRnZUxhYmVsIiksInNwYWNpbmciKSwiRWRnZSBMYWJlbCBTcGFjaW5nIiksIlRoZSBtaW5pbWFsIGRpc3RhbmNlIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGEgbGFiZWwgYW5kIHRoZSBlZGdlIGl0IGlzIGFzc29jaWF0ZWQgd2l0aC4gTm90ZSB0aGF0IHRoZSBwbGFjZW1lbnQgb2YgYSBsYWJlbCBpcyBpbmZsdWVuY2VkIGJ5IHRoZSAnZWRnZWxhYmVscy5wbGFjZW1lbnQnIG9wdGlvbi4iKSwyKSxQdCksJHIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmVkZ2VOb2RlIiksInNwYWNpbmciKSwiRWRnZSBOb2RlIFNwYWNpbmciKSwiU3BhY2luZyB0byBiZSBwcmVzZXJ2ZWQgYmV0d2VlbiBub2RlcyBhbmQgZWRnZXMuIiksMTApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubGFiZWxMYWJlbCIpLCJzcGFjaW5nIiksIkxhYmVsIFNwYWNpbmciKSwiRGV0ZXJtaW5lcyB0aGUgYW1vdW50IG9mIHNwYWNlIHRvIGJlIGxlZnQgYmV0d2VlbiB0d28gbGFiZWxzIG9mIHRoZSBzYW1lIGdyYXBoIGVsZW1lbnQuIiksMCksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbE5vZGUiKSwic3BhY2luZyIpLCJMYWJlbCBOb2RlIFNwYWNpbmciKSwiU3BhY2luZyB0byBiZSBwcmVzZXJ2ZWQgYmV0d2VlbiBsYWJlbHMgYW5kIHRoZSBib3JkZXIgb2Ygbm9kZSB0aGV5IGFyZSBhc3NvY2lhdGVkIHdpdGguIE5vdGUgdGhhdCB0aGUgcGxhY2VtZW50IG9mIGEgbGFiZWwgaXMgaW5mbHVlbmNlZCBieSB0aGUgJ25vZGVsYWJlbHMucGxhY2VtZW50JyBvcHRpb24uIiksNSksUHQpLCRyKSxFZShPZSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5sYWJlbFBvcnRIb3Jpem9udGFsIiksInNwYWNpbmciKSwiSG9yaXpvbnRhbCBzcGFjaW5nIGJldHdlZW4gTGFiZWwgYW5kIFBvcnQiKSwiSG9yaXpvbnRhbCBzcGFjaW5nIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGxhYmVscyBhbmQgdGhlIHBvcnRzIHRoZXkgYXJlIGFzc29jaWF0ZWQgd2l0aC4gTm90ZSB0aGF0IHRoZSBwbGFjZW1lbnQgb2YgYSBsYWJlbCBpcyBpbmZsdWVuY2VkIGJ5IHRoZSAncG9ydGxhYmVscy5wbGFjZW1lbnQnIG9wdGlvbi4iKSwxKSxQdCksJHIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLmxhYmVsUG9ydFZlcnRpY2FsIiksInNwYWNpbmciKSwiVmVydGljYWwgc3BhY2luZyBiZXR3ZWVuIExhYmVsIGFuZCBQb3J0IiksIlZlcnRpY2FsIHNwYWNpbmcgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gbGFiZWxzIGFuZCB0aGUgcG9ydHMgdGhleSBhcmUgYXNzb2NpYXRlZCB3aXRoLiBOb3RlIHRoYXQgdGhlIHBsYWNlbWVudCBvZiBhIGxhYmVsIGlzIGluZmx1ZW5jZWQgYnkgdGhlICdwb3J0bGFiZWxzLnBsYWNlbWVudCcgb3B0aW9uLiIpLDEpLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZU5vZGUiKSwic3BhY2luZyIpLCJOb2RlIFNwYWNpbmciKSwiVGhlIG1pbmltYWwgZGlzdGFuY2UgdG8gYmUgcHJlc2VydmVkIGJldHdlZW4gZWFjaCB0d28gbm9kZXMuIiksMjApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcubm9kZVNlbGZMb29wIiksInNwYWNpbmciKSwiTm9kZSBTZWxmIExvb3AgU3BhY2luZyIpLCJTcGFjaW5nIHRvIGJlIHByZXNlcnZlZCBiZXR3ZWVuIGEgbm9kZSBhbmQgaXRzIHNlbGYgbG9vcHMuIiksMTApLFB0KSwkciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcucG9ydFBvcnQiKSwic3BhY2luZyIpLCJQb3J0IFNwYWNpbmciKSwiU3BhY2luZyBiZXR3ZWVuIHBhaXJzIG9mIHBvcnRzIG9mIHRoZSBzYW1lIG5vZGUuIiksMTApLFB0KSwkciksY3IoT2UsUChJKHp1LDEpLFcsMTcwLDAsW0pyXSkpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnNwYWNpbmcuaW5kaXZpZHVhbCIpLCJzcGFjaW5nIiksIkluZGl2aWR1YWwgU3BhY2luZyIpLCJBbGxvd3MgdG8gc3BlY2lmeSBpbmRpdmlkdWFsIHNwYWNpbmcgdmFsdWVzIGZvciBncmFwaCBlbGVtZW50cyB0aGF0IHNoYWxsIGJlIGRpZmZlcmVudCBmcm9tIHRoZSB2YWx1ZSBzcGVjaWZpZWQgZm9yIHRoZSBlbGVtZW50J3MgcGFyZW50LiIpLHpzKSwkemUpLGNyKEpyLFAoSSh6dSwxKSxXLDE3MCwwLFttdSxRXyxYY10pKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5zcGFjaW5nLnBvcnRzU3Vycm91bmRpbmciKSwic3BhY2luZyIpLCJBZGRpdGlvbmFsIFBvcnQgU3BhY2UiKSwiQWRkaXRpb25hbCBzcGFjZSBhcm91bmQgdGhlIHNldHMgb2YgcG9ydHMgb24gZWFjaCBub2RlIHNpZGUuIEZvciBlYWNoIHNpZGUgb2YgYSBub2RlLCB0aGlzIG9wdGlvbiBjYW4gcmVzZXJ2ZSBhZGRpdGlvbmFsIHNwYWNlIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHBvcnRzIG9uIGVhY2ggc2lkZS4gRm9yIGV4YW1wbGUsIGEgdG9wIHNwYWNpbmcgb2YgMjAgbWFrZXMgc3VyZSB0aGF0IHRoZSBmaXJzdCBwb3J0IG9uIHRoZSB3ZXN0ZXJuIGFuZCBlYXN0ZXJuIHNpZGUgaXMgMjAgdW5pdHMgYXdheSBmcm9tIHRoZSBub3J0aGVybiBib3JkZXIuIiksVlEpLHpzKSxEVyksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5wYXJ0aXRpb24iKSwicGFydGl0aW9uaW5nIiksIkxheW91dCBQYXJ0aXRpb24iKSwiUGFydGl0aW9uIHRvIHdoaWNoIHRoZSBub2RlIGJlbG9uZ3MuIFRoaXMgcmVxdWlyZXMgTGF5b3V0IFBhcnRpdGlvbmluZyB0byBiZSBhY3RpdmUuIE5vZGVzIHdpdGggbG93ZXIgcGFydGl0aW9uIElEcyB3aWxsIGFwcGVhciB0byB0aGUgbGVmdCBvZiBub2RlcyB3aXRoIGhpZ2hlciBwYXJ0aXRpb24gSURzIChhc3N1bWluZyBhIGxlZnQtdG8tcmlnaHQgbGF5b3V0IGRpcmVjdGlvbikuIiksYm8pLHZ0KSxjcihPZSxQKEkoenUsMSksVywxNzAsMCxbSnJdKSkpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5wYXJ0aXRpb24iLCJvcmcuZWNsaXBzZS5lbGsucGFydGl0aW9uaW5nLmFjdGl2YXRlIixYRGUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBhcnRpdGlvbmluZy5hY3RpdmF0ZSIpLCJwYXJ0aXRpb25pbmciKSwiTGF5b3V0IFBhcnRpdGlvbmluZyIpLCJXaGV0aGVyIHRvIGFjdGl2YXRlIHBhcnRpdGlvbmVkIGxheW91dC4gVGhpcyB3aWxsIGFsbG93IHRvIGdyb3VwIG5vZGVzIHRocm91Z2ggdGhlIExheW91dCBQYXJ0aXRpb24gb3B0aW9uLiBhIHBhaXIgb2Ygbm9kZXMgd2l0aCBkaWZmZXJlbnQgcGFydGl0aW9uIGluZGljZXMgaXMgdGhlbiBwbGFjZWQgc3VjaCB0aGF0IHRoZSBub2RlIHdpdGggbG93ZXIgaW5kZXggaXMgcGxhY2VkIHRvIHRoZSBsZWZ0IG9mIHRoZSBvdGhlciBub2RlICh3aXRoIGxlZnQtdG8tcmlnaHQgbGF5b3V0IGRpcmVjdGlvbikuIERlcGVuZGluZyBvbiB0aGUgbGF5b3V0IGFsZ29yaXRobSwgdGhpcyBtYXkgb25seSBiZSBndWFyYW50ZWVkIHRvIHdvcmsgaWYgYWxsIG5vZGVzIGhhdmUgYSBsYXlvdXQgcGFydGl0aW9uIGNvbmZpZ3VyZWQsIG9yIGF0IGxlYXN0IGlmIGVkZ2VzIHRoYXQgY3Jvc3MgcGFydGl0aW9ucyBhcmUgbm90IHBhcnQgb2YgYSBwYXJ0aXRpb24tY3Jvc3NpbmcgY3ljbGUuIiksTFEpLG50KSxBciksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm5vZGVMYWJlbHMucGFkZGluZyIpLCJub2RlTGFiZWxzIiksIk5vZGUgTGFiZWwgUGFkZGluZyIpLCJEZWZpbmUgcGFkZGluZyBmb3Igbm9kZSBsYWJlbHMgdGhhdCBhcmUgcGxhY2VkIGluc2lkZSBvZiBhIG5vZGUuIiksYlEpLHpzKSxIVyksRWUoT2UpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLm5vZGVMYWJlbHMucGxhY2VtZW50IiksIm5vZGVMYWJlbHMiKSwiTm9kZSBMYWJlbCBQbGFjZW1lbnQiKSwiSGludHMgZm9yIHdoZXJlIG5vZGUgbGFiZWxzIGFyZSB0byBiZSBwbGFjZWQ7IGlmIGVtcHR5LCB0aGUgbm9kZSBsYWJlbCdzIHBvc2l0aW9uIGlzIG5vdCBtb2RpZmllZC4iKSxJUSksb20pLFl0KSxjcihKcixQKEkoenUsMSksVywxNzAsMCxbWGNdKSkpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5kZWZhdWx0IiksInBvcnRBbGlnbm1lbnQiKSwiUG9ydCBBbGlnbm1lbnQiKSwiRGVmaW5lcyB0aGUgZGVmYXVsdCBwb3J0IGRpc3RyaWJ1dGlvbiBmb3IgYSBub2RlLiBNYXkgYmUgb3ZlcnJpZGRlbiBmb3IgZWFjaCBzaWRlIGluZGl2aWR1YWxseS4iKSxPUSksbXIpLEp2KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5ub3J0aCIpLCJwb3J0QWxpZ25tZW50IiksIlBvcnQgQWxpZ25tZW50IChOb3J0aCkiKSwiRGVmaW5lcyBob3cgcG9ydHMgb24gdGhlIG5vcnRoZXJuIHNpZGUgYXJlIHBsYWNlZCwgb3ZlcnJpZGluZyB0aGUgbm9kZSdzIGdlbmVyYWwgcG9ydCBhbGlnbm1lbnQuIiksbXIpLEp2KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5zb3V0aCIpLCJwb3J0QWxpZ25tZW50IiksIlBvcnQgQWxpZ25tZW50IChTb3V0aCkiKSwiRGVmaW5lcyBob3cgcG9ydHMgb24gdGhlIHNvdXRoZXJuIHNpZGUgYXJlIHBsYWNlZCwgb3ZlcnJpZGluZyB0aGUgbm9kZSdzIGdlbmVyYWwgcG9ydCBhbGlnbm1lbnQuIiksbXIpLEp2KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC53ZXN0IiksInBvcnRBbGlnbm1lbnQiKSwiUG9ydCBBbGlnbm1lbnQgKFdlc3QpIiksIkRlZmluZXMgaG93IHBvcnRzIG9uIHRoZSB3ZXN0ZXJuIHNpZGUgYXJlIHBsYWNlZCwgb3ZlcnJpZGluZyB0aGUgbm9kZSdzIGdlbmVyYWwgcG9ydCBhbGlnbm1lbnQuIiksbXIpLEp2KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydEFsaWdubWVudC5lYXN0IiksInBvcnRBbGlnbm1lbnQiKSwiUG9ydCBBbGlnbm1lbnQgKEVhc3QpIiksIkRlZmluZXMgaG93IHBvcnRzIG9uIHRoZSBlYXN0ZXJuIHNpZGUgYXJlIHBsYWNlZCwgb3ZlcnJpZGluZyB0aGUgbm9kZSdzIGdlbmVyYWwgcG9ydCBhbGlnbm1lbnQuIiksbXIpLEp2KSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuY29uc3RyYWludHMiKSwibm9kZVNpemUiKSwiTm9kZSBTaXplIENvbnN0cmFpbnRzIiksIldoYXQgc2hvdWxkIGJlIHRha2VuIGludG8gYWNjb3VudCB3aGVuIGNhbGN1bGF0aW5nIGEgbm9kZSdzIHNpemUuIEVtcHR5IHNpemUgY29uc3RyYWludHMgc3BlY2lmeSB0aGF0IGEgbm9kZSdzIHNpemUgaXMgYWxyZWFkeSBmaXhlZCBhbmQgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLiIpLHhRKSxvbSksdFMpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5vcHRpb25zIiksIm5vZGVTaXplIiksIk5vZGUgU2l6ZSBPcHRpb25zIiksIk9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiB0aGUgc2l6ZSBjb25zdHJhaW50cyBzZXQgb24gYSBub2RlLiBFYWNoIG1lbWJlciBvZiB0aGUgc2V0IHNwZWNpZmllcyBzb21ldGhpbmcgdGhhdCBzaG91bGQgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBzaXplcy4gVGhlIGVtcHR5IHNldCBjb3JyZXNwb25kcyB0byBubyBmdXJ0aGVyIG1vZGlmaWNhdGlvbnMuIiksTlEpLG9tKSxwZWUpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5taW5pbXVtIiksIm5vZGVTaXplIiksIk5vZGUgU2l6ZSBNaW5pbXVtIiksIlRoZSBtaW5pbWFsIHNpemUgdG8gd2hpY2ggYSBub2RlIGNhbiBiZSByZWR1Y2VkLiIpLFBRKSx6cyksb3QpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5ub2RlU2l6ZS5maXhlZEdyYXBoU2l6ZSIpLCJub2RlU2l6ZSIpLCJGaXhlZCBHcmFwaCBTaXplIiksIkJ5IGRlZmF1bHQsIHRoZSBmaXhlZCBsYXlvdXQgcHJvdmlkZXIgd2lsbCBlbmxhcmdlIGEgZ3JhcGggdW50aWwgaXQgaXMgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gaXRzIGNoaWxkcmVuLiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIGl0IHdvbid0IGRvIHNvLiIpLCExKSxudCksQXIpLEVlKE9lKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5lZGdlTGFiZWxzLnBsYWNlbWVudCIpLCJlZGdlTGFiZWxzIiksIkVkZ2UgTGFiZWwgUGxhY2VtZW50IiksIkdpdmVzIGEgaGludCBvbiB3aGVyZSB0byBwdXQgZWRnZSBsYWJlbHMuIiksaFEpLG1yKSxLUSksRWUoWGMpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLmVkZ2VMYWJlbHMuaW5saW5lIiksImVkZ2VMYWJlbHMiKSwiSW5saW5lIEVkZ2UgTGFiZWxzIiksIklmIHRydWUsIGFuIGVkZ2UgbGFiZWwgaXMgcGxhY2VkIGRpcmVjdGx5IG9uIGl0cyBlZGdlLiBNYXkgb25seSBhcHBseSB0byBjZW50ZXIgZWRnZSBsYWJlbHMuIFRoaXMga2luZCBvZiBsYWJlbCBwbGFjZW1lbnQgaXMgb25seSBhZHZpc2FibGUgaWYgdGhlIGxhYmVsJ3MgcmVuZGVyaW5nIGlzIHN1Y2ggdGhhdCBpdCBpcyBub3QgY3Jvc3NlZCBieSBpdHMgZWRnZSBhbmQgdGh1cyBzdGF5cyBsZWdpYmxlLiIpLCExKSxudCksQXIpLEVlKFhjKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5mb250Lm5hbWUiKSwiZm9udCIpLCJGb250IE5hbWUiKSwiRm9udCBuYW1lIHVzZWQgZm9yIGEgbGFiZWwuIiksd2cpLHNlKSxFZShYYykpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuZm9udC5zaXplIiksImZvbnQiKSwiRm9udCBTaXplIiksIkZvbnQgc2l6ZSB1c2VkIGZvciBhIGxhYmVsLiIpLGJvKSx2dCksRWUoWGMpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvcnQuYW5jaG9yIiksInBvcnQiKSwiUG9ydCBBbmNob3IgT2Zmc2V0IiksIlRoZSBvZmZzZXQgdG8gdGhlIHBvcnQgcG9zaXRpb24gd2hlcmUgY29ubmVjdGlvbnMgc2hhbGwgYmUgYXR0YWNoZWQuIiksenMpLG90KSxFZShRXykpKSksX2UobixuZXcgdWUobWUoaGUoeWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydC5pbmRleCIpLCJwb3J0IiksIlBvcnQgSW5kZXgiKSwiVGhlIGluZGV4IG9mIGEgcG9ydCBpbiB0aGUgZml4ZWQgb3JkZXIgYXJvdW5kIGEgbm9kZS4gVGhlIG9yZGVyIGlzIGFzc3VtZWQgYXMgY2xvY2t3aXNlLCBzdGFydGluZyB3aXRoIHRoZSBsZWZ0bW9zdCBwb3J0IG9uIHRoZSB0b3Agc2lkZS4gVGhpcyBvcHRpb24gbXVzdCBiZSBzZXQgaWYgJ1BvcnQgQ29uc3RyYWludHMnIGlzIHNldCB0byBGSVhFRF9PUkRFUiBhbmQgbm8gc3BlY2lmaWMgcG9zaXRpb25zIGFyZSBnaXZlbiBmb3IgdGhlIHBvcnRzLiBBZGRpdGlvbmFsbHksIHRoZSBvcHRpb24gJ1BvcnQgU2lkZScgbXVzdCBiZSBkZWZpbmVkIGluIHRoaXMgY2FzZS4iKSxibyksdnQpLEVlKFFfKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5wb3J0LnNpZGUiKSwicG9ydCIpLCJQb3J0IFNpZGUiKSwiVGhlIHNpZGUgb2YgYSBub2RlIG9uIHdoaWNoIGEgcG9ydCBpcyBzaXR1YXRlZC4gVGhpcyBvcHRpb24gbXVzdCBiZSBzZXQgaWYgJ1BvcnQgQ29uc3RyYWludHMnIGlzIHNldCB0byBGSVhFRF9TSURFIG9yIEZJWEVEX09SREVSIGFuZCBubyBzcGVjaWZpYyBwb3NpdGlvbnMgYXJlIGdpdmVuIGZvciB0aGUgcG9ydHMuIikselEpLG1yKSwkdCksRWUoUV8pKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvcnQuYm9yZGVyT2Zmc2V0IiksInBvcnQiKSwiUG9ydCBCb3JkZXIgT2Zmc2V0IiksIlRoZSBvZmZzZXQgb2YgcG9ydHMgb24gdGhlIG5vZGUgYm9yZGVyLiBXaXRoIGEgcG9zaXRpdmUgb2Zmc2V0IHRoZSBwb3J0IGlzIG1vdmVkIG91dHNpZGUgb2YgdGhlIG5vZGUsIHdoaWxlIHdpdGggYSBuZWdhdGl2ZSBvZmZzZXQgdGhlIHBvcnQgaXMgbW92ZWQgdG93YXJkcyB0aGUgaW5zaWRlLiBBbiBvZmZzZXQgb2YgMCBtZWFucyB0aGF0IHRoZSBwb3J0IGlzIHBsYWNlZCBkaXJlY3RseSBvbiB0aGUgbm9kZSBib3JkZXIsIGkuZS4gaWYgdGhlIHBvcnQgc2lkZSBpcyBub3J0aCwgdGhlIHBvcnQncyBzb3V0aCBib3JkZXIgdG91Y2hlcyB0aGUgbm9kZXMncyBub3J0aCBib3JkZXI7IGlmIHRoZSBwb3J0IHNpZGUgaXMgZWFzdCwgdGhlIHBvcnQncyB3ZXN0IGJvcmRlciB0b3VjaGVzIHRoZSBub2RlcydzIGVhc3QgYm9yZGVyOyBpZiB0aGUgcG9ydCBzaWRlIGlzIHNvdXRoLCB0aGUgcG9ydCdzIG5vcnRoIGJvcmRlciB0b3VjaGVzIHRoZSBub2RlJ3Mgc291dGggYm9yZGVyOyBpZiB0aGUgcG9ydCBzaWRlIGlzIHdlc3QsIHRoZSBwb3J0J3MgZWFzdCBib3JkZXIgdG91Y2hlcyB0aGUgbm9kZSdzIHdlc3QgYm9yZGVyLiIpLFB0KSwkciksRWUoUV8pKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMucGxhY2VtZW50IiksInBvcnRMYWJlbHMiKSwiUG9ydCBMYWJlbCBQbGFjZW1lbnQiKSwiRGVjaWRlcyBvbiBhIHBsYWNlbWVudCBtZXRob2QgZm9yIHBvcnQgbGFiZWxzOyBpZiBlbXB0eSwgdGhlIG5vZGUgbGFiZWwncyBwb3NpdGlvbiBpcyBub3QgbW9kaWZpZWQuIiksRFEpLG9tKSxfQSksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnBvcnRMYWJlbHMubmV4dFRvUG9ydElmUG9zc2libGUiKSwicG9ydExhYmVscyIpLCJQb3J0IExhYmVscyBOZXh0IHRvIFBvcnQiKSwiVXNlICdwb3J0TGFiZWxzLnBsYWNlbWVudCc6IE5FWFRfVE9fUE9SVF9PRl9QT1NTSUJMRS4iKSwhMSksbnQpLEFyKSxFZShKcikpKSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsucG9ydExhYmVscy50cmVhdEFzR3JvdXAiKSwicG9ydExhYmVscyIpLCJUcmVhdCBQb3J0IExhYmVscyBhcyBHcm91cCIpLCJJZiB0aGlzIG9wdGlvbiBpcyB0cnVlIChkZWZhdWx0KSwgdGhlIGxhYmVscyBvZiBhIHBvcnQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgZ3JvdXAgd2hlbiBpdCBjb21lcyB0byBjZW50ZXJpbmcgdGhlbSBuZXh0IHRvIHRoZWlyIHBvcnQuIElmIHRoaXMgb3B0aW9uIGlzIGZhbHNlLCBvbmx5IHRoZSBmaXJzdCBsYWJlbCB3aWxsIGJlIGNlbnRlcmVkIG5leHQgdG8gdGhlIHBvcnQsIHdpdGggdGhlIG90aGVycyBiZWluZyBwbGFjZWQgYmVsb3cuIFRoaXMgb25seSBhcHBsaWVzIHRvIGxhYmVscyBvZiBlYXN0ZXJuIGFuZCB3ZXN0ZXJuIHBvcnRzIGFuZCB3aWxsIGhhdmUgbm8gZWZmZWN0IGlmIGxhYmVscyBhcmUgbm90IHBsYWNlZCBuZXh0IHRvIHRoZWlyIHBvcnQuIiksITApLG50KSxBciksRWUoSnIpKSkpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2NhbGVGYWN0b3IiKSwidG9wZG93biIpLCJUb3Bkb3duIFNjYWxlIEZhY3RvciIpLCJUaGUgc2NhbGluZyBmYWN0b3IgdG8gYmUgYXBwbGllZCB0byB0aGUgbm9kZXMgbGFpZCBvdXQgd2l0aGluIHRoZSBub2RlIGluIHJlY3Vyc2l2ZSB0b3Bkb3duIGxheW91dC4gVGhlIGRpZmZlcmVuY2UgdG8gJ1NjYWxlIEZhY3RvcicgaXMgdGhhdCB0aGUgbm9kZSBpdHNlbGYgaXMgbm90IHNjYWxlZC4gVGhpcyB2YWx1ZSBoYXMgdG8gYmUgc2V0IG9uIGhpZXJhcmNoaWNhbCBub2Rlcy4iKSwxKSxQdCksJHIpLEVlKE9lKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5zY2FsZUZhY3RvciIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLm5vZGVUeXBlIixvRmUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2l6ZUFwcHJveGltYXRvciIpLCJ0b3Bkb3duIiksIlRvcGRvd24gU2l6ZSBBcHByb3hpbWF0b3IiKSwiVGhlIHNpemUgYXBwcm94aW1hdG9yIHRvIGJlIHVzZWQgdG8gc2V0IHNpemVzIG9mIGhpZXJhcmNoaWNhbCBub2RlcyBkdXJpbmcgdG9wZG93biBsYXlvdXQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIHJlc3VsdHMgaW4gbm9kZXMga2VlcGluZyB3aGF0ZXZlciBzaXplIGlzIGRlZmluZWQgZm9yIHRoZW0gZS5nLiB0aHJvdWdoIHBhcmVudCBwYXJhbGxlbCBub2RlIG9yIGJ5IG1hbnVhbGx5IHNldHRpbmcgdGhlIHNpemUuIiksbnVsbCksbXIpLHdBKSxFZShKcikpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2l6ZUFwcHJveGltYXRvciIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLm5vZGVUeXBlIixpRmUpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uaGllcmFyY2hpY2FsTm9kZVdpZHRoIiksInRvcGRvd24iKSwiVG9wZG93biBIaWVyYXJjaGljYWwgTm9kZSBXaWR0aCIpLCJUaGUgZml4ZWQgc2l6ZSBvZiBhIGhpZXJhcmNoaWNhbCBub2RlIHdoZW4gdXNpbmcgdG9wZG93biBsYXlvdXQuIElmIHRoaXMgdmFsdWUgaXMgc2V0IG9uIGEgcGFyYWxsZWwgbm9kZSBpdCBhcHBsaWVzIHRvIGl0cyBjaGlsZHJlbiwgd2hlbiBzZXQgb24gYSBoaWVyYXJjaGljYWwgbm9kZSBpdCBhcHBsaWVzIHRvIHRoZSBub2RlIGl0c2VsZi4iKSwxNTApLFB0KSwkciksY3IoT2UsUChJKHp1LDEpLFcsMTcwLDAsW0pyXSkpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVXaWR0aCIsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLm5vZGVUeXBlIixudWxsKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLmhpZXJhcmNoaWNhbE5vZGVBc3BlY3RSYXRpbyIpLCJ0b3Bkb3duIiksIlRvcGRvd24gSGllcmFyY2hpY2FsIE5vZGUgQXNwZWN0IFJhdGlvIiksIlRoZSBmaXhlZCBhc3BlY3QgcmF0aW8gb2YgYSBoaWVyYXJjaGljYWwgbm9kZSB3aGVuIHVzaW5nIHRvcGRvd24gbGF5b3V0LiBEZWZhdWx0IGlzIDEvc3FydCgyKS4gSWYgdGhpcyB2YWx1ZSBpcyBzZXQgb24gYSBwYXJhbGxlbCBub2RlIGl0IGFwcGxpZXMgdG8gaXRzIGNoaWxkcmVuLCB3aGVuIHNldCBvbiBhIGhpZXJhcmNoaWNhbCBub2RlIGl0IGFwcGxpZXMgdG8gdGhlIG5vZGUgaXRzZWxmLiIpLDEuNDE0KSxQdCksJHIpLGNyKE9lLFAoSSh6dSwxKSxXLDE3MCwwLFtKcl0pKSkpKSxVcihuLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5oaWVyYXJjaGljYWxOb2RlQXNwZWN0UmF0aW8iLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5ub2RlVHlwZSIsbnVsbCksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsudG9wZG93bi5ub2RlVHlwZSIpLCJ0b3Bkb3duIiksIlRvcGRvd24gTm9kZSBUeXBlIiksIlRoZSBkaWZmZXJlbnQgbm9kZSB0eXBlcyB1c2VkIGZvciB0b3Bkb3duIGxheW91dC4gSWYgdGhlIG5vZGUgdHlwZSBpcyBzZXQgdG8ge0BsaW5rIFRvcGRvd25Ob2RlVHlwZXMuUEFSQUxMRUxfTk9ERX0gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHNldCB0byBhIHtAbGluayBUb3Bkb3duTGF5b3V0UHJvdmlkZXJ9IHN1Y2ggYXMge0BsaW5rIFRvcGRvd25QYWNraW5nfS4gVGhlIHtAbGluayBub2RlU2l6ZS5maXhlZEdyYXBoU2l6ZX0gb3B0aW9uIGlzIHRlY2huaWNhbGx5IG9ubHkgcmVxdWlyZWQgZm9yIGhpZXJhcmNoaWNhbCBub2Rlcy4iKSxudWxsKSxtciksaGVlKSxFZShKcikpKSksVXIobiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24ubm9kZVR5cGUiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuZml4ZWRHcmFwaFNpemUiLG51bGwpLF9lKG4sbmV3IHVlKG1lKGhlKHllKEllKGRlKGdlKGZlKHBlKG5ldyBjZSwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24uc2NhbGVDYXAiKSwidG9wZG93biIpLCJUb3Bkb3duIFNjYWxlIENhcCIpLCJEZXRlcm1pbmVzIHRoZSB1cHBlciBsaW1pdCBmb3IgdGhlIHRvcGRvd24gc2NhbGUgZmFjdG9yLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjAgd2hpY2ggZW5zdXJlcyB0aGF0IG5lc3RlZCBjaGlsZHJlbiBuZXZlciBlbmQgdXAgYXBwZWFyaW5nIGxhcmdlciB0aGFuIHRoZWlyIHBhcmVudHMgaW4gdGVybXMgb2YgdW5pdCBzaXplcyBzdWNoIGFzIHRoZSBmb250IHNpemUuIElmIHRoZSBsaW1pdCBpcyBsYXJnZXIsIG5vZGVzIHdpbGwgZnVsbHkgdXRpbGl6ZSB0aGUgYXZhaWxhYmxlIHNwYWNlLCBidXQgaXQgaXMgY291bnRlcmluaXVpdGl2ZSBmb3IgaW5uZXIgbm9kZXMgdG8gaGF2ZSBhIGxhcmdlciBzY2FsZSB0aGFuIG91dGVyIG5vZGVzLiIpLDEpLFB0KSwkciksRWUoT2UpKSkpLFVyKG4sIm9yZy5lY2xpcHNlLmVsay50b3Bkb3duLnNjYWxlQ2FwIiwib3JnLmVjbGlwc2UuZWxrLnRvcGRvd24ubm9kZVR5cGUiLHRGZSksX2UobixuZXcgdWUobWUoaGUoeWUoSWUoZGUoZ2UoZmUocGUobmV3IGNlLCJvcmcuZWNsaXBzZS5lbGsuaW5zaWRlU2VsZkxvb3BzLmFjdGl2YXRlIiksImluc2lkZVNlbGZMb29wcyIpLCJBY3RpdmF0ZSBJbnNpZGUgU2VsZiBMb29wcyIpLCJXaGV0aGVyIHRoaXMgbm9kZSBhbGxvd3MgdG8gcm91dGUgc2VsZiBsb29wcyBpbnNpZGUgb2YgaXQgaW5zdGVhZCBvZiBhcm91bmQgaXQuIElmIHNldCB0byB0cnVlLCB0aGlzIHdpbGwgbWFrZSB0aGUgbm9kZSBhIGNvbXBvdW5kIG5vZGUgaWYgaXQgaXNuJ3QgYWxyZWFkeSwgYW5kIHdpbGwgcmVxdWlyZSB0aGUgbGF5b3V0IGFsZ29yaXRobSB0byBzdXBwb3J0IGNvbXBvdW5kIG5vZGVzIHdpdGggaGllcmFyY2hpY2FsIHBvcnRzLiIpLCExKSxudCksQXIpLEVlKEpyKSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5pbnNpZGVTZWxmTG9vcHMueW8iKSwiaW5zaWRlU2VsZkxvb3BzIiksIkluc2lkZSBTZWxmIExvb3AiKSwiV2hldGhlciBhIHNlbGYgbG9vcCBzaG91bGQgYmUgcm91dGVkIGluc2lkZSBhIG5vZGUgaW5zdGVhZCBvZiBhcm91bmQgdGhhdCBub2RlLiIpLCExKSxudCksQXIpLEVlKG11KSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5lZGdlLnRoaWNrbmVzcyIpLCJlZGdlIiksIkVkZ2UgVGhpY2tuZXNzIiksIlRoZSB0aGlja25lc3Mgb2YgYW4gZWRnZS4gVGhpcyBpcyBhIGhpbnQgb24gdGhlIGxpbmUgd2lkdGggdXNlZCB0byBkcmF3IGFuIGVkZ2UsIHBvc3NpYmx5IHJlcXVpcmluZyBtb3JlIHNwYWNlIHRvIGJlIHJlc2VydmVkIGZvciBpdC4iKSwxKSxQdCksJHIpLEVlKG11KSkpKSxfZShuLG5ldyB1ZShtZShoZSh5ZShJZShkZShnZShmZShwZShuZXcgY2UsIm9yZy5lY2xpcHNlLmVsay5lZGdlLnR5cGUiKSwiZWRnZSIpLCJFZGdlIFR5cGUiKSwiVGhlIHR5cGUgb2YgYW4gZWRnZS4gVGhpcyBpcyB1c3VhbGx5IHVzZWQgZm9yIFVNTCBjbGFzcyBkaWFncmFtcywgd2hlcmUgYXNzb2NpYXRpb25zIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSBmcm9tIGdlbmVyYWxpemF0aW9ucy4iKSxFUSksbXIpLG5lZSksRWUobXUpKSkpLE92KG4sbmV3IG5tKGt2KEV3KHd3KG5ldyBybSwib3JnLmVjbGlwc2UuZWxrLmxheWVyZWQiKSwiTGF5ZXJlZCIpLCdUaGUgbGF5ZXItYmFzZWQgbWV0aG9kIHdhcyBpbnRyb2R1Y2VkIGJ5IFN1Z2l5YW1hLCBUYWdhd2EgYW5kIFRvZGEgaW4gMTk4MS4gSXQgZW1waGFzaXplcyB0aGUgZGlyZWN0aW9uIG9mIGVkZ2VzIGJ5IHBvaW50aW5nIGFzIG1hbnkgZWRnZXMgYXMgcG9zc2libGUgaW50byB0aGUgc2FtZSBkaXJlY3Rpb24uIFRoZSBub2RlcyBhcmUgYXJyYW5nZWQgaW4gbGF5ZXJzLCB3aGljaCBhcmUgc29tZXRpbWVzIGNhbGxlZCAiaGllcmFyY2hpZXMiLCBhbmQgdGhlbiByZW9yZGVyZWQgc3VjaCB0aGF0IHRoZSBudW1iZXIgb2YgZWRnZSBjcm9zc2luZ3MgaXMgbWluaW1pemVkLiBBZnRlcndhcmRzLCBjb25jcmV0ZSBjb29yZGluYXRlcyBhcmUgY29tcHV0ZWQgZm9yIHRoZSBub2RlcyBhbmQgZWRnZSBiZW5kIHBvaW50cy4nKSkpLE92KG4sbmV3IG5tKGt2KEV3KHd3KG5ldyBybSwib3JnLmVjbGlwc2UuZWxrLm9ydGhvZ29uYWwiKSwiT3J0aG9nb25hbCIpLGBPcnRob2dvbmFsIG1ldGhvZHMgdGhhdCBmb2xsb3cgdGhlICJ0b3BvbG9neS1zaGFwZS1tZXRyaWNzIiBhcHByb2FjaCBieSBCYXRpbmksIE5hcmRlbGxpIGFuZCBUYW1hc3NpYSAnODYuIFRoZSBmaXJzdCBwaGFzZSBkZXRlcm1pbmVzIHRoZSB0b3BvbG9neSBvZiB0aGUgZHJhd2luZyBieSBhcHBseWluZyBhIHBsYW5hcml6YXRpb24gdGVjaG5pcXVlLCB3aGljaCByZXN1bHRzIGluIGEgcGxhbmFyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFwaC4gVGhlIG9ydGhvZ29uYWwgc2hhcGUgaXMgY29tcHV0ZWQgaW4gdGhlIHNlY29uZCBwaGFzZSwgd2hpY2ggYWltcyBhdCBtaW5pbWl6aW5nIHRoZSBudW1iZXIgb2YgZWRnZSBiZW5kcywgYW5kIGlzIGNhbGxlZCBvcnRob2dvbmFsaXphdGlvbi4gVGhlIHRoaXJkIHBoYXNlIGxlYWRzIHRvIGNvbmNyZXRlIGNvb3JkaW5hdGVzIGZvciBub2RlcyBhbmQgZWRnZSBiZW5kIHBvaW50cyBieSBhcHBseWluZyBhIGNvbXBhY3Rpb24gbWV0aG9kLCB0aHVzIGRlZmluaW5nIHRoZSBtZXRyaWNzLmApKSksT3YobixuZXcgbm0oa3YoRXcod3cobmV3IHJtLCJvcmcuZWNsaXBzZS5lbGsuZm9yY2UiKSwiRm9yY2UiKSwiTGF5b3V0IGFsZ29yaXRobXMgdGhhdCBmb2xsb3cgcGh5c2ljYWwgYW5hbG9naWVzIGJ5IHNpbXVsYXRpbmcgYSBzeXN0ZW0gb2YgYXR0cmFjdGl2ZSBhbmQgcmVwdWxzaXZlIGZvcmNlcy4gVGhlIGZpcnN0IHN1Y2Nlc3NmdWwgbWV0aG9kIG9mIHRoaXMga2luZCB3YXMgcHJvcG9zZWQgYnkgRWFkZXMgaW4gMTk4NC4iKSkpLE92KG4sbmV3IG5tKGt2KEV3KHd3KG5ldyBybSwib3JnLmVjbGlwc2UuZWxrLmNpcmNsZSIpLCJDaXJjbGUiKSwiQ2lyY3VsYXIgbGF5b3V0IGFsZ29yaXRobXMgZW1waGFzaXplIGN5Y2xlcyBvciBiaWNvbm5lY3RlZCBjb21wb25lbnRzIG9mIGEgZ3JhcGggYnkgYXJyYW5naW5nIHRoZW0gaW4gY2lyY2xlcy4gVGhpcyBpcyB1c2VmdWwgaWYgYSBkcmF3aW5nIGlzIGRlc2lyZWQgd2hlcmUgc3VjaCBjb21wb25lbnRzIGFyZSBjbGVhcmx5IGdyb3VwZWQsIG9yIHdoZXJlIGN5Y2xlcyBhcmUgc2hvd24gYXMgcHJvbWluZW50IE9QVElPTlMgb2YgdGhlIGdyYXBoLiIpKSksT3YobixuZXcgbm0oa3YoRXcod3cobmV3IHJtLCJvcmcuZWNsaXBzZS5lbGsudHJlZSIpLCJUcmVlIiksIlNwZWNpYWxpemVkIGxheW91dCBtZXRob2RzIGZvciB0cmVlcywgaS5lLiBhY3ljbGljIGdyYXBocy4gVGhlIHJlZ3VsYXIgc3RydWN0dXJlIG9mIGdyYXBocyB0aGF0IGhhdmUgbm8gdW5kaXJlY3RlZCBjeWNsZXMgY2FuIGJlIGVtcGhhc2l6ZWQgdXNpbmcgYW4gYWxnb3JpdGhtIG9mIHRoaXMgdHlwZS4iKSkpLE92KG4sbmV3IG5tKGt2KEV3KHd3KG5ldyBybSwib3JnLmVjbGlwc2UuZWxrLnBsYW5hciIpLCJQbGFuYXIiKSwiQWxnb3JpdGhtcyB0aGF0IHJlcXVpcmUgYSBwbGFuYXIgb3IgdXB3YXJkIHBsYW5hciBncmFwaC4gTW9zdCBvZiB0aGVzZSBhbGdvcml0aG1zIGFyZSB0aGVvcmV0aWNhbGx5IGludGVyZXN0aW5nLCBidXQgbm90IHByYWN0aWNhbGx5IHVzYWJsZS4iKSkpLE92KG4sbmV3IG5tKGt2KEV3KHd3KG5ldyBybSwib3JnLmVjbGlwc2UuZWxrLnJhZGlhbCIpLCJSYWRpYWwiKSwiUmFkaWFsIGxheW91dCBhbGdvcml0aG1zIHVzdWFsbHkgcG9zaXRpb24gdGhlIG5vZGVzIG9mIHRoZSBncmFwaCBvbiBjb25jZW50cmljIGNpcmNsZXMuIikpKSxnRmUoKG5ldyBoRmUsbikpLGtEZSgobmV3IE9EZSxuKSksUkZlKChuZXcgREZlLG4pKX07dmFyIFR3LEhEZSxkUSxTZyxVRGUsV0RlLGZRLENnLFRnLGpEZSxJVCxwUSx4VCxuMSxnUSx0UixvUixoUSxtUSx5USx3USxFUSxWRGUsYmcsdlEscURlLFBULGlSLE5ULGFSLHlkLFNRLGJ3LENRLFRRLGJRLElnLElRLHIxLHhRLFdmLHhnLFBRLFcwLE5RLHJBLEFULFpjLEFRLFlEZSxMUSxLRGUsWERlLGtRLE9RLGxSLHNSLHVSLGNSLE1RLHBhLGp2LFJRLF9SLGRSLGpmLERRLEZRLFBnLHpRLGxtLExULGZSLE5nLEpEZSxwUixaRGUsUURlLCRRLGVGZSxCUSxHUSxzbSxIUSx0QSxVUSxXUSx0MSxuRmUsalEsVlEscVEsb0Esa1QsSXcsdW0sckZlLHRGZSxpQSxvRmUsWVEsaUZlO2coIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJDb3JlT3B0aW9ucyIsNjk5KTtmdW5jdGlvbiBXcigpe1dyPUYsQnM9bmV3IE9UKCJVTkRFRklORUQiLDApLG1vPW5ldyBPVCgiUklHSFQiLDEpLGFvPW5ldyBPVCgiTEVGVCIsMiksJHM9bmV3IE9UKCJET1dOIiwzKSxvbD1uZXcgT1QoIlVQIiw0KX1mdW5jdGlvbiBkYyhlKXtyZXR1cm4gZT09YW98fGU9PW1vfWZ1bmN0aW9uIEFnKGUpe3JldHVybiBlPT1vbHx8ZT09JHN9ZnVuY3Rpb24gYUZlKGUpe3N3aXRjaChlLm9yZGluYWwpe2Nhc2UgMjpyZXR1cm4gbW87Y2FzZSAxOnJldHVybiBhbztjYXNlIDQ6cmV0dXJuICRzO2Nhc2UgMzpyZXR1cm4gb2w7ZGVmYXVsdDpyZXR1cm4gQnN9fWZ1bmN0aW9uIE9UKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gWDJuKGUpe3JldHVybiBXcigpLHduKChsRmUoKSxzRmUpLGUpfWZ1bmN0aW9uIEoybigpe3JldHVybiBXcigpLFAoSShWdiwxKSxXLDg4LDAsW0JzLG1vLGFvLCRzLG9sXSl9cCg4OCwyMix7MzoxLDM0OjEsMjI6MSw4ODoxfSxPVCk7dmFyICRzLGFvLG1vLEJzLG9sLFZ2PWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiRGlyZWN0aW9uIiw4OCxnbixKMm4sWDJuKTtmdW5jdGlvbiBsRmUoKXtsRmU9RixzRmU9eW4oKFdyKCksUChJKFZ2LDEpLFcsODgsMCxbQnMsbW8sYW8sJHMsb2xdKSkpfXZhciBzRmU7ZnVuY3Rpb24gR3MoKXtHcz1GLHh3PW5ldyBnUigiQ0VOVEVSIiwwKSxWZj1uZXcgZ1IoIkhFQUQiLDEpLFB3PW5ldyBnUigiVEFJTCIsMil9ZnVuY3Rpb24gZ1IoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBaMm4oZSl7cmV0dXJuIEdzKCksd24oKHVGZSgpLGNGZSksZSl9ZnVuY3Rpb24gUTJuKCl7cmV0dXJuIEdzKCksUChJKEtRLDEpLFcsMjc4LDAsW3h3LFZmLFB3XSl9cCgyNzgsMjIsezM6MSwzNDoxLDIyOjEsMjc4OjF9LGdSKTt2YXIgeHcsVmYsUHcsS1E9Y24oIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJFZGdlTGFiZWxQbGFjZW1lbnQiLDI3OCxnbixRMm4sWjJuKTtmdW5jdGlvbiB1RmUoKXt1RmU9RixjRmU9eW4oKEdzKCksUChJKEtRLDEpLFcsMjc4LDAsW3h3LFZmLFB3XSkpKX12YXIgY0ZlO2Z1bmN0aW9uIGZjKCl7ZmM9RixoUj1uZXcgYUEoIlVOREVGSU5FRCIsMCksTVQ9bmV3IGFBKCJQT0xZTElORSIsMSksTnc9bmV3IGFBKCJPUlRIT0dPTkFMIiwyKSxjbT1uZXcgYUEoIlNQTElORVMiLDMpfWZ1bmN0aW9uIGFBKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZUVuKGUpe3JldHVybiBmYygpLHduKChfRmUoKSxkRmUpLGUpfWZ1bmN0aW9uIG5Fbigpe3JldHVybiBmYygpLFAoSShtUiwxKSxXLDIyMywwLFtoUixNVCxOdyxjbV0pfXAoMjIzLDIyLHszOjEsMzQ6MSwyMjoxLDIyMzoxfSxhQSk7dmFyIE53LE1ULGNtLGhSLG1SPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiRWRnZVJvdXRpbmciLDIyMyxnbixuRW4sZUVuKTtmdW5jdGlvbiBfRmUoKXtfRmU9RixkRmU9eW4oKGZjKCksUChJKG1SLDEpLFcsMjIzLDAsW2hSLE1ULE53LGNtXSkpKX12YXIgZEZlO2Z1bmN0aW9uIGxBKCl7bEE9Rix5Uj1uZXcgcXYoIk5PTkUiLDApLFpRPW5ldyBxdigiRElSRUNURUQiLDEpLGVlZT1uZXcgcXYoIlVORElSRUNURUQiLDIpLFhRPW5ldyBxdigiQVNTT0NJQVRJT04iLDMpLFFRPW5ldyBxdigiR0VORVJBTElaQVRJT04iLDQpLEpRPW5ldyBxdigiREVQRU5ERU5DWSIsNSl9ZnVuY3Rpb24gcXYoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiByRW4oZSl7cmV0dXJuIGxBKCksd24oKGZGZSgpLHBGZSksZSl9ZnVuY3Rpb24gdEVuKCl7cmV0dXJuIGxBKCksUChJKG5lZSwxKSxXLDMyMSwwLFt5UixaUSxlZWUsWFEsUVEsSlFdKX1wKDMyMSwyMix7MzoxLDM0OjEsMjI6MSwzMjE6MX0scXYpO3ZhciBYUSxKUSxaUSxRUSx5UixlZWUsbmVlPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiRWRnZVR5cGUiLDMyMSxnbix0RW4sckVuKTtmdW5jdGlvbiBmRmUoKXtmRmU9RixwRmU9eW4oKGxBKCksUChJKG5lZSwxKSxXLDMyMSwwLFt5UixaUSxlZWUsWFEsUVEsSlFdKSkpfXZhciBwRmU7ZnVuY3Rpb24gc0EoKXtzQT1GLGFlZT1uZXcgVzEoMTUpLG1GZT1uZXcgeXQoKEZuKCksWmMpLGFlZSksWXY9bG0scmVlPVVEZSx0ZWU9cjEsaWVlPXhnLG9lZT1XZn1mdW5jdGlvbiBnRmUoZSl7aGQoZSxuZXcgSl8oZ2QoZGQocGQoZmQobmV3IFpfLCJvcmcuZWNsaXBzZS5lbGsuZml4ZWQiKSwiRUxLIEZpeGVkIiksIktlZXBzIHRoZSBjdXJyZW50IGxheW91dCBhcyBpdCBpcywgd2l0aG91dCBhbnkgYXV0b21hdGljIG1vZGlmaWNhdGlvbi4gT3B0aW9uYWwgY29vcmRpbmF0ZXMgY2FuIGJlIGdpdmVuIGZvciBub2RlcyBhbmQgZWRnZSBiZW5kIHBvaW50cy4iKSxuZXcgeUZlKSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZpeGVkIiwib3JnLmVjbGlwc2UuZWxrLnBhZGRpbmciLGFlZSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZml4ZWQiLCJvcmcuZWNsaXBzZS5lbGsucG9zaXRpb24iLHRlKFl2KSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZml4ZWQiLCJvcmcuZWNsaXBzZS5lbGsuYmVuZFBvaW50cyIsdGUocmVlKSksWihlLCJvcmcuZWNsaXBzZS5lbGsuZml4ZWQiLCJvcmcuZWNsaXBzZS5lbGsubm9kZVNpemUuY29uc3RyYWludHMiLHRlKHRlZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZpeGVkIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLm1pbmltdW0iLHRlKGllZSkpLFooZSwib3JnLmVjbGlwc2UuZWxrLmZpeGVkIiwib3JnLmVjbGlwc2UuZWxrLm5vZGVTaXplLmZpeGVkR3JhcGhTaXplIix0ZShvZWUpKX1mdW5jdGlvbiBoRmUoKXtzQSgpfXAoOTg5LDEscGwsaEZlKSxsLmFwcGx5XzQ9ZnVuY3Rpb24obil7Z0ZlKG4pfTt2YXIgcmVlLHRlZSxvZWUsaWVlLG1GZSxhZWUsWXY7Zygib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIkZpeGVkTGF5b3V0ZXJPcHRpb25zIiw5ODkpO2Z1bmN0aW9uIHlGZSgpe31wKDk5MCwxLHt9LHlGZSksbC5jcmVhdGVfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPW5ldyBGemUsbn0sbC5kZXN0cm95PWZ1bmN0aW9uKG4pe30sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIkZpeGVkTGF5b3V0ZXJPcHRpb25zL0ZpeGVkRmFjdG9yeSIsOTkwKTtmdW5jdGlvbiBwYygpe3BjPUYsdUE9bmV3IHdSKCJJTkhFUklUIiwwKSxRYz1uZXcgd1IoIklOQ0xVREVfQ0hJTERSRU4iLDEpLEt2PW5ldyB3UigiU0VQQVJBVEVfQ0hJTERSRU4iLDIpfWZ1bmN0aW9uIHdSKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gb0VuKGUpe3JldHVybiBwYygpLHduKCh3RmUoKSxFRmUpLGUpfWZ1bmN0aW9uIGlFbigpe3JldHVybiBwYygpLFAoSShsZWUsMSksVywzNDYsMCxbdUEsUWMsS3ZdKX1wKDM0NiwyMix7MzoxLDM0OjEsMjI6MSwzNDY6MX0sd1IpO3ZhciBRYyx1QSxLdixsZWU9Y24oIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJIaWVyYXJjaHlIYW5kbGluZyIsMzQ2LGduLGlFbixvRW4pO2Z1bmN0aW9uIHdGZSgpe3dGZT1GLEVGZT15bigocGMoKSxQKEkobGVlLDEpLFcsMzQ2LDAsW3VBLFFjLEt2XSkpKX12YXIgRUZlO2Z1bmN0aW9uIERhKCl7RGE9RixEVD1uZXcgY0EoIlVOS05PV04iLDApLEJ1PW5ldyBjQSgiQUJPVkUiLDEpLGowPW5ldyBjQSgiQkVMT1ciLDIpLFJUPW5ldyBjQSgiSU5MSU5FIiwzKSxuZXcgdnIoIm9yZy5lY2xpcHNlLmVsay5sYWJlbFNpZGUiLERUKX1mdW5jdGlvbiB2RmUoZSl7c3dpdGNoKGUub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBqMDtjYXNlIDI6cmV0dXJuIEJ1O2Nhc2UgMzpyZXR1cm4gUlQ7ZGVmYXVsdDpyZXR1cm4gRFR9fWZ1bmN0aW9uIGNBKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gYUVuKGUpe3JldHVybiBEYSgpLHduKChDRmUoKSxURmUpLGUpfWZ1bmN0aW9uIGxFbigpe3JldHVybiBEYSgpLFAoSShTRmUsMSksVywyOTEsMCxbRFQsQnUsajAsUlRdKX1wKDI5MSwyMix7MzoxLDM0OjEsMjI6MSwyOTE6MX0sY0EpO3ZhciBCdSxqMCxSVCxEVCxTRmU9Y24oIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJMYWJlbFNpZGUiLDI5MSxnbixsRW4sYUVuKTtmdW5jdGlvbiBDRmUoKXtDRmU9RixURmU9eW4oKERhKCksUChJKFNGZSwxKSxXLDI5MSwwLFtEVCxCdSxqMCxSVF0pKSl9dmFyIFRGZTtmdW5jdGlvbiBxZigpe3FmPUYsS2w9bmV3IExnKCJIX0xFRlQiLDApLGdjPW5ldyBMZygiSF9DRU5URVIiLDEpLFhsPW5ldyBMZygiSF9SSUdIVCIsMiksWmw9bmV3IExnKCJWX1RPUCIsMyksR3U9bmV3IExnKCJWX0NFTlRFUiIsNCksVGw9bmV3IExnKCJWX0JPVFRPTSIsNSksRmE9bmV3IExnKCJJTlNJREUiLDYpLEpsPW5ldyBMZygiT1VUU0lERSIsNyksQ2w9bmV3IExnKCJIX1BSSU9SSVRZIiw4KX1mdW5jdGlvbiBMZyhlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHNFbihlKXtxZigpO3ZhciBuLHIsdDtyZXR1cm4gcj1jcihGYSxQKEkoWXQsMSksVyw5NSwwLFtKbF0pKSwhKF9DKFNJKHIsZSkpPjF8fChuPWNyKEtsLFAoSShZdCwxKSxXLDk1LDAsW2djLFhsXSkpLF9DKFNJKG4sZSkpPjEpfHwodD1jcihabCxQKEkoWXQsMSksVyw5NSwwLFtHdSxUbF0pKSxfQyhTSSh0LGUpKT4xKSl9ZnVuY3Rpb24gdUVuKGUpe3JldHVybiBxZigpLHduKChiRmUoKSxJRmUpLGUpfWZ1bmN0aW9uIGNFbigpe3JldHVybiBxZigpLFAoSShZdCwxKSxXLDk1LDAsW0tsLGdjLFhsLFpsLEd1LFRsLEZhLEpsLENsXSl9cCg5NSwyMix7MzoxLDM0OjEsMjI6MSw5NToxfSxMZyk7dmFyIGdjLEtsLENsLFhsLEZhLEpsLFRsLEd1LFpsLFl0PWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiTm9kZUxhYmVsUGxhY2VtZW50Iiw5NSxnbixjRW4sdUVuKTtmdW5jdGlvbiBiRmUoKXtiRmU9RixJRmU9eW4oKHFmKCksUChJKFl0LDEpLFcsOTUsMCxbS2wsZ2MsWGwsWmwsR3UsVGwsRmEsSmwsQ2xdKSkpfXZhciBJRmU7ZnVuY3Rpb24ga2coKXtrZz1GLFYwPW5ldyBGVCgiRElTVFJJQlVURUQiLDApLHpUPW5ldyBGVCgiSlVTVElGSUVEIiwxKSxzZWU9bmV3IEZUKCJCRUdJTiIsMiksWHY9bmV3IEZUKCJDRU5URVIiLDMpLHVlZT1uZXcgRlQoIkVORCIsNCl9ZnVuY3Rpb24gRlQoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBfRW4oZSl7cmV0dXJuIGtnKCksd24oKHhGZSgpLFBGZSksZSl9ZnVuY3Rpb24gZEVuKCl7cmV0dXJuIGtnKCksUChJKEp2LDEpLFcsMjU2LDAsW1YwLHpULHNlZSxYdix1ZWVdKX1wKDI1NiwyMix7MzoxLDM0OjEsMjI6MSwyNTY6MX0sRlQpO3ZhciBzZWUsWHYsVjAsdWVlLHpULEp2PWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiUG9ydEFsaWdubWVudCIsMjU2LGduLGRFbixfRW4pO2Z1bmN0aW9uIHhGZSgpe3hGZT1GLFBGZT15bigoa2coKSxQKEkoSnYsMSksVywyNTYsMCxbVjAselQsc2VlLFh2LHVlZV0pKSl9dmFyIFBGZTtmdW5jdGlvbiBkdCgpe2R0PUYscTA9bmV3IFp2KCJVTkRFRklORUQiLDApLEhzPW5ldyBadigiRlJFRSIsMSksQXc9bmV3IFp2KCJGSVhFRF9TSURFIiwyKSxvMT1uZXcgWnYoIkZJWEVEX09SREVSIiwzKSxIdT1uZXcgWnYoIkZJWEVEX1JBVElPIiw0KSxhaT1uZXcgWnYoIkZJWEVEX1BPUyIsNSl9ZnVuY3Rpb24gX20oZSl7cmV0dXJuIGU9PW8xfHxlPT1IdXx8ZT09YWl9ZnVuY3Rpb24gT2coZSl7cmV0dXJuIGUhPUhzJiZlIT1xMH1mdW5jdGlvbiBadihlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGZFbihlKXtyZXR1cm4gZHQoKSx3bigoTkZlKCksQUZlKSxlKX1mdW5jdGlvbiBwRW4oKXtyZXR1cm4gZHQoKSxQKEkoY2VlLDEpLFcsMTAxLDAsW3EwLEhzLEF3LG8xLEh1LGFpXSl9cCgxMDEsMjIsezM6MSwzNDoxLDIyOjEsMTAxOjF9LFp2KTt2YXIgbzEsYWksSHUsQXcsSHMscTAsY2VlPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiUG9ydENvbnN0cmFpbnRzIiwxMDEsZ24scEVuLGZFbik7ZnVuY3Rpb24gTkZlKCl7TkZlPUYsQUZlPXluKChkdCgpLFAoSShjZWUsMSksVywxMDEsMCxbcTAsSHMsQXcsbzEsSHUsYWldKSkpfXZhciBBRmU7ZnVuY3Rpb24gYWEoKXthYT1GLFkwPW5ldyBRdigiT1VUU0lERSIsMCksaGM9bmV3IFF2KCJJTlNJREUiLDEpLCRUPW5ldyBRdigiTkVYVF9UT19QT1JUX0lGX1BPU1NJQkxFIiwyKSxyUz1uZXcgUXYoIkFMV0FZU19TQU1FX1NJREUiLDMpLG5TPW5ldyBRdigiQUxXQVlTX09USEVSX1NBTUVfU0lERSIsNCksZG09bmV3IFF2KCJTUEFDRV9FRkZJQ0lFTlQiLDUpfWZ1bmN0aW9uIFF2KGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gZVMoZSl7cmV0dXJuIGFhKCksIWUuY29udGFpbnMoaGMpJiYhZS5jb250YWlucyhZMCl9ZnVuY3Rpb24gZ0VuKGUpe2FhKCk7dmFyIG4scjtyZXR1cm4gbj1jcihoYyxQKEkoX0EsMSksVywyNzksMCxbWTBdKSksIShfQyhTSShuLGUpKT4xfHwocj1jcihyUyxQKEkoX0EsMSksVywyNzksMCxbblMsZG1dKSksX0MoU0kocixlKSk+MSkpfWZ1bmN0aW9uIGhFbihlKXtyZXR1cm4gYWEoKSx3bigoTEZlKCksa0ZlKSxlKX1mdW5jdGlvbiBtRW4oKXtyZXR1cm4gYWEoKSxQKEkoX0EsMSksVywyNzksMCxbWTAsaGMsJFQsclMsblMsZG1dKX1wKDI3OSwyMix7MzoxLDM0OjEsMjI6MSwyNzk6MX0sUXYpO3ZhciBuUyxyUyxoYywkVCxZMCxkbSxfQT1jbigib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIlBvcnRMYWJlbFBsYWNlbWVudCIsMjc5LGduLG1FbixoRW4pO2Z1bmN0aW9uIExGZSgpe0xGZT1GLGtGZT15bigoYWEoKSxQKEkoX0EsMSksVywyNzksMCxbWTAsaGMsJFQsclMsblMsZG1dKSkpfXZhciBrRmU7ZnVuY3Rpb24gcmUoKXtyZT1GO3ZhciBlO09vPW5ldyBHVCgiVU5ERUZJTkVEIiwwKSxVZT1uZXcgR1QoIk5PUlRIIiwxKSxxZT1uZXcgR1QoIkVBU1QiLDIpLGxuPW5ldyBHVCgiU09VVEgiLDMpLGplPW5ldyBHVCgiV0VTVCIsNCksVXM9KE5lKCksbmV3IG15KChlPWEoaXMoJHQpLDkpLG5ldyBKYShlLGEoRGwoZSxlLmxlbmd0aCksOSksMCkpKSksUWw9eGMoY3IoVWUsUChJKCR0LDEpLGpvLDY0LDAsW10pKSksaWw9eGMoY3IocWUsUChJKCR0LDEpLGpvLDY0LDAsW10pKSksemE9eGMoY3IobG4sUChJKCR0LDEpLGpvLDY0LDAsW10pKSksYmw9eGMoY3IoamUsUChJKCR0LDEpLGpvLDY0LDAsW10pKSksa2k9eGMoY3IoVWUsUChJKCR0LDEpLGpvLDY0LDAsW2xuXSkpKSx2aT14YyhjcihxZSxQKEkoJHQsMSksam8sNjQsMCxbamVdKSkpLGVzPXhjKGNyKFVlLFAoSSgkdCwxKSxqbyw2NCwwLFtqZV0pKSksbGE9eGMoY3IoVWUsUChJKCR0LDEpLGpvLDY0LDAsW3FlXSkpKSwkYT14YyhjcihsbixQKEkoJHQsMSksam8sNjQsMCxbamVdKSkpLGFsPXhjKGNyKHFlLFAoSSgkdCwxKSxqbyw2NCwwLFtsbl0pKSksc2E9eGMoY3IoVWUsUChJKCR0LDEpLGpvLDY0LDAsW3FlLGplXSkpKSxMaT14YyhjcihxZSxQKEkoJHQsMSksam8sNjQsMCxbbG4samVdKSkpLE9pPXhjKGNyKFVlLFAoSSgkdCwxKSxqbyw2NCwwLFtsbixqZV0pKSksVmk9eGMoY3IoVWUsUChJKCR0LDEpLGpvLDY0LDAsW3FlLGxuXSkpKSxsaT14YyhjcihVZSxQKEkoJHQsMSksam8sNjQsMCxbcWUsbG4samVdKSkpfWZ1bmN0aW9uIF9lZShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIGplO2Nhc2UgMjpyZXR1cm4gVWU7Y2FzZSAzOnJldHVybiBxZTtjYXNlIDQ6cmV0dXJuIGxuO2RlZmF1bHQ6cmV0dXJuIE9vfX1mdW5jdGlvbiBCVChlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIGxuO2Nhc2UgMjpyZXR1cm4gamU7Y2FzZSAzOnJldHVybiBVZTtjYXNlIDQ6cmV0dXJuIHFlO2RlZmF1bHQ6cmV0dXJuIE9vfX1mdW5jdGlvbiBkQShlKXtzd2l0Y2goZS5vcmRpbmFsKXtjYXNlIDE6cmV0dXJuIHFlO2Nhc2UgMjpyZXR1cm4gbG47Y2FzZSAzOnJldHVybiBqZTtjYXNlIDQ6cmV0dXJuIFVlO2RlZmF1bHQ6cmV0dXJuIE9vfX1mdW5jdGlvbiBHVChlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIGZtKGUpe3N3aXRjaChyZSgpLGUub3JkaW5hbCl7Y2FzZSA0OnJldHVybiBVZTtjYXNlIDE6cmV0dXJuIHFlO2Nhc2UgMzpyZXR1cm4gbG47Y2FzZSAyOnJldHVybiBqZTtkZWZhdWx0OnJldHVybiBPb319ZnVuY3Rpb24geUVuKGUpe3JldHVybiByZSgpLHduKChPRmUoKSxNRmUpLGUpfWZ1bmN0aW9uIHdFbigpe3JldHVybiByZSgpLFAoSSgkdCwxKSxqbyw2NCwwLFtPbyxVZSxxZSxsbixqZV0pfXAoNjQsMjIsezM6MSwzNDoxLDIyOjEsNjQ6MX0sR1QpO3ZhciBxZSxVZSxpbCxhbCxMaSx2aSxVcyxRbCxsYSxWaSxsaSxzYSxraSxPaSxlcyx6YSwkYSxibCxsbixPbyxqZSwkdD1jbigib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIlBvcnRTaWRlIiw2NCxnbix3RW4seUVuKTtmdW5jdGlvbiBPRmUoKXtPRmU9RixNRmU9eW4oKHJlKCksUChJKCR0LDEpLGpvLDY0LDAsW09vLFVlLHFlLGxuLGplXSkpKX12YXIgTUZlO2Z1bmN0aW9uIGRlZSgpe2RlZT1GLGZlZT1uZXcgVzEoMTUpLHpGZT1uZXcgeXQoKEZuKCksWmMpLGZlZSksQkZlPW5ldyB5dCh0MSwxNSksJEZlPW5ldyB5dChmUixKKDApKSxGRmU9bmV3IHl0KFNnLFVtKX1mdW5jdGlvbiBSRmUoZSl7aGQoZSxuZXcgSl8oZ2QoZGQocGQoZmQobmV3IFpfLCJvcmcuZWNsaXBzZS5lbGsucmFuZG9tIiksIkVMSyBSYW5kb21pemVyIiksJ0Rpc3RyaWJ1dGVzIHRoZSBub2RlcyByYW5kb21seSBvbiB0aGUgcGxhbmUsIGxlYWRpbmcgdG8gdmVyeSBvYmZ1c2NhdGluZyBsYXlvdXRzLiBDYW4gYmUgdXNlZnVsIHRvIGRlbW9uc3RyYXRlIHRoZSBwb3dlciBvZiAicmVhbCIgbGF5b3V0IGFsZ29yaXRobXMuJyksbmV3IEdGZSkpKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYW5kb20iLCJvcmcuZWNsaXBzZS5lbGsucGFkZGluZyIsZmVlKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYW5kb20iLCJvcmcuZWNsaXBzZS5lbGsuc3BhY2luZy5ub2RlTm9kZSIsMTUpLFooZSwib3JnLmVjbGlwc2UuZWxrLnJhbmRvbSIsIm9yZy5lY2xpcHNlLmVsay5yYW5kb21TZWVkIixKKDApKSxaKGUsIm9yZy5lY2xpcHNlLmVsay5yYW5kb20iLCJvcmcuZWNsaXBzZS5lbGsuYXNwZWN0UmF0aW8iLFVtKX1mdW5jdGlvbiBERmUoKXtkZWUoKX1wKDk5MywxLHBsLERGZSksbC5hcHBseV80PWZ1bmN0aW9uKG4pe1JGZShuKX07dmFyIEZGZSx6RmUsZmVlLCRGZSxCRmU7Zygib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIlJhbmRvbUxheW91dGVyT3B0aW9ucyIsOTkzKTtmdW5jdGlvbiBHRmUoKXt9cCg5OTQsMSx7fSxHRmUpLGwuY3JlYXRlXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgWHplLG59LGwuZGVzdHJveT1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJSYW5kb21MYXlvdXRlck9wdGlvbnMvUmFuZG9tRmFjdG9yeSIsOTk0KTtmdW5jdGlvbiBTYSgpe1NhPUYsVVQ9bmV3IGZBKCJQT1JUUyIsMCksaTE9bmV3IGZBKCJQT1JUX0xBQkVMUyIsMSksSFQ9bmV3IGZBKCJOT0RFX0xBQkVMUyIsMiksWWY9bmV3IGZBKCJNSU5JTVVNX1NJWkUiLDMpfWZ1bmN0aW9uIGZBKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gRUVuKGUpe3JldHVybiBTYSgpLHduKChIRmUoKSxVRmUpLGUpfWZ1bmN0aW9uIHZFbigpe3JldHVybiBTYSgpLFAoSSh0UywxKSxXLDM4NiwwLFtVVCxpMSxIVCxZZl0pfXAoMzg2LDIyLHszOjEsMzQ6MSwyMjoxLDM4NjoxfSxmQSk7dmFyIFlmLEhULFVULGkxLHRTPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiU2l6ZUNvbnN0cmFpbnQiLDM4Nixnbix2RW4sRUVuKTtmdW5jdGlvbiBIRmUoKXtIRmU9RixVRmU9eW4oKFNhKCksUChJKHRTLDEpLFcsMzg2LDAsW1VULGkxLEhULFlmXSkpKX12YXIgVUZlO2Z1bmN0aW9uIGdhKCl7Z2E9RixMdz1uZXcgTWcoIkRFRkFVTFRfTUlOSU1VTV9TSVpFIiwwKSxqVD1uZXcgTWcoIk1JTklNVU1fU0laRV9BQ0NPVU5UU19GT1JfUEFERElORyIsMSkscEE9bmV3IE1nKCJDT01QVVRFX1BBRERJTkciLDIpLG9TPW5ldyBNZygiT1VUU0lERV9OT0RFX0xBQkVMU19PVkVSSEFORyIsMyksZ0E9bmV3IE1nKCJQT1JUU19PVkVSSEFORyIsNCksbUE9bmV3IE1nKCJVTklGT1JNX1BPUlRfU1BBQ0lORyIsNSksaEE9bmV3IE1nKCJTUEFDRV9FRkZJQ0lFTlRfUE9SVF9MQUJFTFMiLDYpLEVSPW5ldyBNZygiRk9SQ0VfVEFCVUxBUl9OT0RFX0xBQkVMUyIsNyksV1Q9bmV3IE1nKCJBU1lNTUVUUklDQUwiLDgpfWZ1bmN0aW9uIE1nKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gU0VuKGUpe3JldHVybiBnYSgpLHduKChXRmUoKSxqRmUpLGUpfWZ1bmN0aW9uIENFbigpe3JldHVybiBnYSgpLFAoSShwZWUsMSksVywyNjQsMCxbTHcsalQscEEsb1MsZ0EsbUEsaEEsRVIsV1RdKX1wKDI2NCwyMix7MzoxLDM0OjEsMjI6MSwyNjQ6MX0sTWcpO3ZhciBXVCxwQSxMdyxFUixqVCxvUyxnQSxoQSxtQSxwZWU9Y24oIm9yZy5lY2xpcHNlLmVsay5jb3JlLm9wdGlvbnMiLCJTaXplT3B0aW9ucyIsMjY0LGduLENFbixTRW4pO2Z1bmN0aW9uIFdGZSgpe1dGZT1GLGpGZT15bigoZ2EoKSxQKEkocGVlLDEpLFcsMjY0LDAsW0x3LGpULHBBLG9TLGdBLG1BLGhBLEVSLFdUXSkpKX12YXIgakZlO2Z1bmN0aW9uIHBtKCl7cG09RixnZWU9bmV3IHZSKCJQQVJBTExFTF9OT0RFIiwwKSxLZj1uZXcgdlIoIkhJRVJBUkNISUNBTF9OT0RFIiwxKSx5QT1uZXcgdlIoIlJPT1RfTk9ERSIsMil9ZnVuY3Rpb24gdlIoZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBURW4oZSl7cmV0dXJuIHBtKCksd24oKFZGZSgpLHFGZSksZSl9ZnVuY3Rpb24gYkVuKCl7cmV0dXJuIHBtKCksUChJKGhlZSwxKSxXLDI4MCwwLFtnZWUsS2YseUFdKX1wKDI4MCwyMix7MzoxLDM0OjEsMjI6MSwyODA6MX0sdlIpO3ZhciBLZixnZWUseUEsaGVlPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiVG9wZG93bk5vZGVUeXBlcyIsMjgwLGduLGJFbixURW4pO2Z1bmN0aW9uIFZGZSgpe1ZGZT1GLHFGZT15bigocG0oKSxQKEkoaGVlLDEpLFcsMjgwLDAsW2dlZSxLZix5QV0pKSl9dmFyIHFGZTtmdW5jdGlvbiBTUigpe1NSPUYsbWVlPW5ldyBYRmUseWVlPW5ldyBKRmV9ZnVuY3Rpb24gWUZlKGUsbil7bW4uY2FsbCh0aGlzLGUsbil9ZnVuY3Rpb24gSUVuKGUpe3JldHVybiBTUigpLHduKChaRmUoKSxRRmUpLGUpfWZ1bmN0aW9uIHhFbigpe3JldHVybiBTUigpLFAoSSh3QSwxKSxXLDM0NywwLFttZWUseWVlXSl9cCgzNDcsMjIsSkYpO3ZhciBtZWUseWVlLHdBPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiVG9wZG93blNpemVBcHByb3hpbWF0b3IiLDM0Nyxnbix4RW4sSUVuKTtmdW5jdGlvbiBLRmUoZSl7dmFyIG47cmV0dXJuIG49UigkKFYoZSwoRm4oKSxrVCkpKSkqUy5NYXRoLnNxcnQoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikuc2l6ZV8wKSxuZXcgWShuLG4vUigkKFYoZSxvQSkpKSl9ZnVuY3Rpb24gWEZlKCl7WUZlLmNhbGwodGhpcywiQ09VTlRfQ0hJTERSRU4iLDApfXAoOTg3LDM0NyxKRixYRmUpLGwuZ2V0U2l6ZV8wPWZ1bmN0aW9uKG4pe3JldHVybiBLRmUobil9LGNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS5vcHRpb25zIiwiVG9wZG93blNpemVBcHByb3hpbWF0b3IvMSIsOTg3LHdBLG51bGwsbnVsbCk7ZnVuY3Rpb24gSkZlKCl7WUZlLmNhbGwodGhpcywiTE9PS0FIRUFEX0xBWU9VVCIsMSl9cCg5ODgsMzQ3LEpGLEpGZSksbC5nZXRTaXplXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlO2ZvcihyPWEoVihuLChGbigpLE5nKSksMTQzKSxuZT0oWDAoKSx5PW5ldyBfUyx5KSxaVChuZSxuKSx2ZT1uZXcgc24scz1uZXcgWWUoKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikpO3MuY3Vyc29yIT1zLnRoaXMkMDFfMi5zaXplXzEoKTspbz1hKGVuKHMpLDI3KSxrPShtPW5ldyBfUyxtKSxXQShrLG5lKSxaVChrLG8pLERlPUtGZShvKSxSZyhrLFMuTWF0aC5tYXgoby53aWR0aF8wLERlLnhfMCksUy5NYXRoLm1heChvLmhlaWdodCxEZS55XzApKSxkaSh2ZS5oYXNoQ29kZU1hcCxvLGspO2ZvcihpPW5ldyBZZSgoIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKSk7aS5jdXJzb3IhPWkudGhpcyQwMV8yLnNpemVfMSgpOylmb3Iobz1hKGVuKGkpLDI3KSxmPW5ldyBZZSgoIW8ub3V0Z29pbmdFZGdlcyYmKG8ub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsbyw3LDQpKSxvLm91dGdvaW5nRWRnZXMpKTtmLmN1cnNvciE9Zi50aGlzJDAxXzIuc2l6ZV8xKCk7KWQ9YShlbihmKSw3NCksSD1hKF9vKGp0KHZlLmhhc2hDb2RlTWFwLG8pKSwyNykscT1hKEtlKHZlLE8oKCFkLnRhcmdldHMmJihkLnRhcmdldHM9bmV3IExlKGFuLGQsNSw4KSksZC50YXJnZXRzKSwwKSksMjcpLE09KGg9bmV3IEtSLGgpLHBuKCghTS5zb3VyY2VzJiYoTS5zb3VyY2VzPW5ldyBMZShhbixNLDQsNykpLE0uc291cmNlcyksSCkscG4oKCFNLnRhcmdldHMmJihNLnRhcmdldHM9bmV3IExlKGFuLE0sNSw4KSksTS50YXJnZXRzKSxxKSxSQShNLHlyKEgpKSxaVChNLGQpO3Y9YShZVChyLnByb3ZpZGVyUG9vbCksMjA1KTt0cnl7di5sYXlvdXQobmUsbmV3IHF6ZSksR3plKHIucHJvdmlkZXJQb29sLHYpfWNhdGNoKEZlKXt0aHJvdyBGZT13cihGZSksTChGZSwxMDMpPyhFPUZlLGIoRSkpOmIoRmUpfXJldHVybiBXcyhuZSxUZyl8fFdzKG5lLENnKXx8eGVlKG5lKSxfPVIoJChWKG5lLFRnKSkpLGM9UigkKFYobmUsQ2cpKSksdT1fL2MsdD1SKCQoVihuZSxrVCkpKSpTLk1hdGguc3FydCgoIW5lLmNoaWxkcmVuJiYobmUuY2hpbGRyZW49bmV3IFUoVW4sbmUsMTAsMTEpKSxuZS5jaGlsZHJlbikuc2l6ZV8wKSx3ZT1hKFYobmUsWmMpLDEwNyksQT13ZS5sZWZ0K3dlLnJpZ2h0KzEseD13ZS50b3BfMCt3ZS5ib3R0b20rMSxuZXcgWShTLk1hdGgubWF4KEEsdCksUy5NYXRoLm1heCh4LHQvdSkpfSxjbigib3JnLmVjbGlwc2UuZWxrLmNvcmUub3B0aW9ucyIsIlRvcGRvd25TaXplQXBwcm94aW1hdG9yLzIiLDk4OCx3QSxudWxsLG51bGwpO2Z1bmN0aW9uIFpGZSgpe1pGZT1GLFFGZT15bigoU1IoKSxQKEkod0EsMSksVywzNDcsMCxbbWVlLHllZV0pKSl9dmFyIFFGZTtmdW5jdGlvbiBlemUoZSxuLHIpe2lmKGUuY2xvc2VkXzApdGhyb3cgYihuZXcgcm8oIlRoZSB0YXNrIGlzIGFscmVhZHkgZG9uZS4iKSk7cmV0dXJuIGUudGFza05hbWUhPW51bGw/ITE6KGUudGFza05hbWU9bixlLnRvdGFsV29yaz1yLGUucmVjb3JkRXhlY3V0aW9uVGltZSYmKGUuc3RhcnRUaW1lPShuYygpLEF0KEhvKERhdGUubm93KCkpLGJjKSkpLCEwKX1mdW5jdGlvbiBQRW4oZSxuKXt2YXIgcjtyZXR1cm4gcj1uPjA/bi0xOm4scnplKEFFbih0emUoRWVlKG5ldyBnbSxyKSxlLnJlY29yZExvZ3MpLGUucGVyc2lzdExvZ3MpLGUucmVjb3JkRXhlY3V0aW9uVGltZSl9ZnVuY3Rpb24gbnplKGUpe3ZhciBuO2lmKGUudGFza05hbWU9PW51bGwpdGhyb3cgYihuZXcgcm8oIlRoZSB0YXNrIGhhcyBub3QgYmVndW4geWV0LiIpKTtlLmNsb3NlZF8wfHwoZS5yZWNvcmRFeGVjdXRpb25UaW1lJiYobj0obmMoKSxBdChIbyhEYXRlLm5vdygpKSxiYykpLGUudG90YWxUaW1lPUlfKGhsKG4sZS5zdGFydFRpbWUpKSoxZS05KSxlLmNvbXBsZXRlZFdvcms8ZS50b3RhbFdvcmsmJndlZShlLGUudG90YWxXb3JrLWUuY29tcGxldGVkV29yayksZS5jbG9zZWRfMD0hMCl9ZnVuY3Rpb24gd2VlKGUsbil7ZS50b3RhbFdvcms+MCYmZS5jb21wbGV0ZWRXb3JrPGUudG90YWxXb3JrJiYoZS5jb21wbGV0ZWRXb3JrKz1uLGUucGFyZW50TW9uaXRvciYmZS5wYXJlbnRNb25pdG9yLmN1cnJlbnRDaGlsZFdvcms+MCYmZS5tYXhMZXZlbHMhPTAmJndlZShlLnBhcmVudE1vbml0b3Isbi9lLnRvdGFsV29yayplLnBhcmVudE1vbml0b3IuY3VycmVudENoaWxkV29yaykpfWZ1bmN0aW9uIE5FbihlLG4scil7dmFyIHQ7ZS5yZWNvcmRMb2dzJiZuJiZyJiYodD1uZXcgVXplLGVlKGUubG9nR3JhcGhzLHQpKX1mdW5jdGlvbiByemUoZSxuKXtyZXR1cm4gZS5yZWNvcmRFeGVjdXRpb25UaW1lPW4sZX1mdW5jdGlvbiBBRW4oZSxuKXtyZXR1cm4gZS5wZXJzaXN0TG9ncz1uLGV9ZnVuY3Rpb24gdHplKGUsbil7cmV0dXJuIGUucmVjb3JkTG9ncz1uLGUucmVjb3JkTG9ncz8oZS5sb2dNZXNzYWdlcz1uZXcgUSxlLmxvZ0dyYXBocz1uZXcgUSk6KGUubG9nTWVzc2FnZXM9bnVsbCxlLmxvZ0dyYXBocz1udWxsKSxlfWZ1bmN0aW9uIEVlZShlLG4pe3JldHVybiBuPDA/ZS5tYXhMZXZlbHM9LTE6ZS5tYXhMZXZlbHM9bixlfWZ1bmN0aW9uIGdtKCl7dGhpcy5jaGlsZHJlbj1uZXcgcHJ9cCgzNDQsMSx7ODcxOjF9LGdtKSxsLmJlZ2luPWZ1bmN0aW9uKG4scil7cmV0dXJuIGV6ZSh0aGlzLG4scil9LGwuZG9uZV8xPWZ1bmN0aW9uKCl7bnplKHRoaXMpfSxsLmdldEV4ZWN1dGlvblRpbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b3RhbFRpbWV9LGwuZ2V0TG9ncz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxvZ01lc3NhZ2VzP0o1KHRoaXMubG9nTWVzc2FnZXMpOm51bGx9LGwuZ2V0U3ViTW9uaXRvcnM9ZnVuY3Rpb24oKXtyZXR1cm4gSjUodGhpcy5jaGlsZHJlbil9LGwuZ2V0VGFza05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50YXNrTmFtZX0sbC5pc0NhbmNlbGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNMb2dnaW5nRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlY29yZExvZ3N9LGwuaXNSdW5uaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGFza05hbWUhPW51bGwmJiF0aGlzLmNsb3NlZF8wfSxsLmxvZ18wPWZ1bmN0aW9uKG4pe3ZhciByO3RoaXMucmVjb3JkTG9ncyYmKHI9bixlZSh0aGlzLmxvZ01lc3NhZ2VzLHIpKX0sbC5sb2dHcmFwaD1mdW5jdGlvbihuLHIpe3ZhciB0LG87dGhpcy5yZWNvcmRMb2dzJiZuJiZORW4odGhpcywodD1uZXcgbVZlLG89SUYodCxuKSxQYm4odCksbyksKFRBKCksSVIpKX0sbC5zdWJUYXNrPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiB0aGlzLmNsb3NlZF8wP251bGw6KHI9UEVuKHRoaXMsdGhpcy5tYXhMZXZlbHMpLExuKHRoaXMuY2hpbGRyZW4sciksci5wYXJlbnRNb25pdG9yPXRoaXMsdGhpcy5jdXJyZW50Q2hpbGRXb3JrPW4scil9LGwud29ya2VkPWZ1bmN0aW9uKG4pe24+MCYmIXRoaXMuY2xvc2VkXzAmJndlZSh0aGlzLG4pfSxsLmNsb3NlZF8wPSExLGwuY29tcGxldGVkV29yaz0wLGwuY3VycmVudENoaWxkV29yaz0tMSxsLmxvZ0dyYXBocz1udWxsLGwubG9nTWVzc2FnZXM9bnVsbCxsLm1heExldmVscz0tMSxsLnBlcnNpc3RMb2dzPSExLGwucmVjb3JkRXhlY3V0aW9uVGltZT0hMSxsLnJlY29yZExvZ3M9ITEsbC5zdGFydFRpbWU9MCxsLnRvdGFsVGltZT0wLGwudG90YWxXb3JrPTAsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkJhc2ljUHJvZ3Jlc3NNb25pdG9yIiwzNDQpO2Z1bmN0aW9uIExFbihlLG4pe3ZhciByLHQsbyxpO2ZvcihpPTAsdD1uZXcgVChlKTt0Lmk8dC50aGlzJDAxLmFycmF5Lmxlbmd0aDspcj1hKEModCksMjcpLGkrPVMuTWF0aC5wb3coci53aWR0aF8wKnIuaGVpZ2h0LW4sMik7cmV0dXJuIG89Uy5NYXRoLnNxcnQoaS8oZS5hcnJheS5sZW5ndGgtMSkpLG99ZnVuY3Rpb24ga0VuKGUsbil7dmFyIHIsdCxvLGk7Zm9yKGk9MCx0PW5ldyBUKGUpO3QuaTx0LnRoaXMkMDEuYXJyYXkubGVuZ3RoOylyPWEoQyh0KSwxNjMpLGkrPVMuTWF0aC5wb3cocWkocikqQ2EociktbiwyKTtyZXR1cm4gbz1TLk1hdGguc3FydChpLyhlLmFycmF5Lmxlbmd0aC0xKSksb31mdW5jdGlvbiBvemUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7c3dpdGNoKG4uYmVnaW4oIkJveCBsYXlvdXQiLDIpLG89U0MoJChWKGUsKG5BKCksekRlKSkpKSxpPWEoVihlLEZEZSksMTA3KSxyPWFlKGllKFYoZSxhUSkpKSx0PWFlKGllKFYoZSxsUSkpKSxhKFYoZSxRTSksMzIwKS5vcmRpbmFsKXtjYXNlIDA6cz0oZD1uZXcgUWkoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpLE5lKCksRHIoZCxuZXcgYXplKHQpKSxkKSx1PU5lZShlKSxjPSQoVihlLGlRKSksKGM9PW51bGx8fChWZShjKSxjPD0wKSkmJihjPTEuMyksXz1ERW4ocyxvLGksdS54XzAsdS55XzAsciwoVmUoYyksYykpLHdkKGUsXy54XzAsXy55XzAsITEsITApO2JyZWFrO2RlZmF1bHQ6RkVuKGUsbyxpLHIpfW4uZG9uZV8xKCl9ZnVuY3Rpb24gT0VuKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaCxtO2ZvcihOZSgpLERyKGUsbmV3IHB6ZSkscz1jQyhlKSxtPW5ldyBRLGg9bmV3IFEsdT1udWxsLGM9MDtzLnNpemVfMCE9MDspaT1hKHMuc2l6ZV8wPT0wP251bGw6KHJuKHMuc2l6ZV8wIT0wKSxaYShzLHMuaGVhZGVyLm5leHRfMCkpLDE2MyksIXV8fHFpKHUpKkNhKHUpLzI8cWkoaSkqQ2EoaSk/KHU9aSxSZShtLmFycmF5LGkpKTooYys9cWkoaSkqQ2EoaSksUmUoaC5hcnJheSxpKSxoLmFycmF5Lmxlbmd0aD4xJiYoYz5xaSh1KSpDYSh1KS8yfHxzLnNpemVfMD09MCkmJihmPW5ldyBFQShoKSxkPXFpKHUpL0NhKHUpLF89Q1IoZixuLG5ldyBPaCxyLHQsbyxkKSxLbihtcyhmLnNpemVfMCksXyksdT1mLFJlKG0uYXJyYXksZiksYz0wLGguYXJyYXkubGVuZ3RoPTApKTtyZXR1cm4gcXIobSxoKSxtfWZ1bmN0aW9uIE1FbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmO2ZvcihOZSgpLERyKGUsbmV3IGh6ZSksdT1uZXcgcHQoZSwwKSxmPW5ldyBRLGk9MDt1Lmk8dS50aGlzJDAxXzAuc2l6ZV8xKCk7KXM9KHJuKHUuaTx1LnRoaXMkMDFfMC5zaXplXzEoKSksYSh1LnRoaXMkMDFfMC5nZXRfMCh1Lmxhc3Q9dS5pKyspLDE2MykpLGYuYXJyYXkubGVuZ3RoIT0wJiZxaShzKSpDYShzKT5pKjI/KGQ9bmV3IEVBKGYpLF89cWkocykvQ2EocyksYz1DUihkLG4sbmV3IE9oLHIsdCxvLF8pLEtuKG1zKGQuc2l6ZV8wKSxjKSxmLmFycmF5Lmxlbmd0aD0wLGk9MCxSZShmLmFycmF5LGQpLFJlKGYuYXJyYXkscyksaT1xaShkKSpDYShkKStxaShzKSpDYShzKSk6KFJlKGYuYXJyYXkscyksaSs9cWkocykqQ2EocykpO3JldHVybiBmfWZ1bmN0aW9uIFJFbihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtmb3IodT1CKGN0LFh0LDI4LGUuYXJyYXkubGVuZ3RoLDE1LDEpLGg9bmV3IG94KG5ldyBnemUpLGZHKGgsZSksXz0wLEU9bmV3IFE7aC5oZWFwLmFycmF5Lmxlbmd0aCE9MDspaWYocz1hKGguaGVhcC5hcnJheS5sZW5ndGg9PTA/bnVsbDpsZShoLmhlYXAsMCksMTYzKSxfPjEmJnFpKHMpKkNhKHMpLzI+dVswXSl7Zm9yKGk9MDtpPEUuYXJyYXkubGVuZ3RoLTEmJnFpKHMpKkNhKHMpLzI+dVtpXTspKytpO3k9bmV3IE9jKEUsMCxpKzEpLGY9bmV3IEVBKHkpLGQ9cWkocykvQ2EocyksYz1DUihmLG4sbmV3IE9oLHIsdCxvLGQpLEtuKG1zKGYuc2l6ZV8wKSxjKSx4aChFeShoLGYpLCJVbmFibGUgdG8gYWRkIGVsZW1lbnQgdG8gcXVldWUiKSxtPW5ldyBPYyhFLGkrMSxFLmFycmF5Lmxlbmd0aCksZkcoaCxtKSxFLmFycmF5Lmxlbmd0aD0wLF89MCx0MGUodSx1Lmxlbmd0aCwwKX1lbHNlIHY9aC5oZWFwLmFycmF5Lmxlbmd0aD09MD9udWxsOmxlKGguaGVhcCwwKSx2IT1udWxsJiZmayhoLDApLF8+MCYmKHVbX109dVtfLTFdKSx1W19dKz1xaShzKSpDYShzKSwrK18sUmUoRS5hcnJheSxzKTtyZXR1cm4gRX1mdW5jdGlvbiBERW4oZSxuLHIsdCxvLGkscyl7dmFyIHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm4sam4sU3I7Zm9yKG09MCxEZT0wLGM9bmV3IFQoZSk7Yy5pPGMudGhpcyQwMS5hcnJheS5sZW5ndGg7KXU9YShDKGMpLDI3KSx4emUodSksbT1TLk1hdGgubWF4KG0sdS53aWR0aF8wKSxEZSs9dS53aWR0aF8wKnUuaGVpZ2h0O2Zvcih5PURlL2UuYXJyYXkubGVuZ3RoLHdlPUxFbihlLHkpLERlKz1lLmFycmF5Lmxlbmd0aCp3ZSxtPVMuTWF0aC5tYXgobSxTLk1hdGguc3FydChEZSpzKSkrci5sZWZ0LGpuPXIubGVmdCxTcj1yLnRvcF8wLGg9MCxkPXIubGVmdCtyLnJpZ2h0LHZlPW5ldyBwcixMbih2ZSxKKDApKSxxPW5ldyBwcixfPW5ldyBwdChlLDApO18uaTxfLnRoaXMkMDFfMC5zaXplXzEoKTspdT0ocm4oXy5pPF8udGhpcyQwMV8wLnNpemVfMSgpKSxhKF8udGhpcyQwMV8wLmdldF8wKF8ubGFzdD1fLmkrKyksMjcpKSxubj11LndpZHRoXzAsZj11LmhlaWdodCxqbitubj5tJiYoaSYmKE10KHEsaCksTXQodmUsSihfLmktMSkpKSxqbj1yLmxlZnQsU3IrPWgrbixoPTAsZD1TLk1hdGgubWF4KGQsci5sZWZ0K3IucmlnaHQrbm4pKSxDaSh1LGpuKSxUaSh1LFNyKSxkPVMuTWF0aC5tYXgoZCxqbitubityLnJpZ2h0KSxoPVMuTWF0aC5tYXgoaCxmKSxqbis9bm4rbjtpZihkPVMuTWF0aC5tYXgoZCx0KSxGZT1TcitoK3IuYm90dG9tLEZlPG8mJihoKz1vLUZlLEZlPW8pLGkpZm9yKGpuPXIubGVmdCxfPW5ldyBwdChlLDApLE10KHZlLEooZS5hcnJheS5sZW5ndGgpKSxuZT1kbih2ZSwwKSx4PWEodW4obmUpLDE3KS52YWx1ZV8wLE10KHEsaCksSD1kbihxLDApLE09MDtfLmk8Xy50aGlzJDAxXzAuc2l6ZV8xKCk7KV8uaT09eCYmKGpuPXIubGVmdCxNPVIoJCh1bihIKSkpLHg9YSh1bihuZSksMTcpLnZhbHVlXzApLHU9KHJuKF8uaTxfLnRoaXMkMDFfMC5zaXplXzEoKSksYShfLnRoaXMkMDFfMC5nZXRfMChfLmxhc3Q9Xy5pKyspLDI3KSksQT11LmhlaWdodCxDZCh1LE0pLEU9TSxfLmk9PXgmJih2PWQtam4tci5yaWdodCxrPXUud2lkdGhfMCxUZCh1LHYpLGtlZSh1LG5ldyBZKHYsRSksbmV3IFkoayxBKSkpLGpuKz11LndpZHRoXzArbjtyZXR1cm4gbmV3IFkoZCxGZSl9ZnVuY3Rpb24gRkVuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2ZvcihmPW5ldyBSdChhKFYoZSwobkEoKSxzUSkpLDgpKSxmLnhfMD1TLk1hdGgubWF4KGYueF8wLXIubGVmdC1yLnJpZ2h0LDApLGYueV8wPVMuTWF0aC5tYXgoZi55XzAtci50b3BfMC1yLmJvdHRvbSwwKSxvPSQoVihlLGlRKSksKG89PW51bGx8fChWZShvKSxvPD0wKSkmJihvPTEuMyksdT1uZXcgUSx5PW5ldyBZZSgoIWUuY2hpbGRyZW4mJihlLmNoaWxkcmVuPW5ldyBVKFVuLGUsMTAsMTEpKSxlLmNoaWxkcmVuKSk7eS5jdXJzb3IhPXkudGhpcyQwMV8yLnNpemVfMSgpOyltPWEoZW4oeSksMjcpLHM9bmV3IF96ZShtKSxSZSh1LmFycmF5LHMpO3N3aXRjaChoPWEoVihlLFFNKSwzMjApLGgub3JkaW5hbCl7Y2FzZSAzOnY9TUVuKHUsbixmLnhfMCxmLnlfMCwoXz10LFZlKG8pLF8pKTticmVhaztjYXNlIDE6dj1PRW4odSxuLGYueF8wLGYueV8wLChkPXQsVmUobyksZCkpO2JyZWFrO2RlZmF1bHQ6dj1SRW4odSxuLGYueF8wLGYueV8wLChjPXQsVmUobyksYykpfWk9bmV3IEVBKHYpLEU9Q1IoaSxuLHIsZi54XzAsZi55XzAsdCwoVmUobyksbykpLHdkKGUsRS54XzAsRS55XzAsITEsITApfWZ1bmN0aW9uIENSKGUsbixyLHQsbyxpLHMpe3ZhciB1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyO2ZvcihFPTAsRGU9MCxfPW5ldyBUKGUuZ3JvdXBzKTtfLmk8Xy50aGlzJDAxLmFycmF5Lmxlbmd0aDspYz1hKEMoXyksMTYzKSxjLm5vZGUmJnh6ZShjLm5vZGUpLEU9Uy5NYXRoLm1heChFLHFpKGMpKSxEZSs9cWkoYykqQ2EoYyk7Zm9yKHY9RGUvZS5ncm91cHMuYXJyYXkubGVuZ3RoLHdlPWtFbihlLmdyb3Vwcyx2KSxEZSs9ZS5ncm91cHMuYXJyYXkubGVuZ3RoKndlLEU9Uy5NYXRoLm1heChFLFMuTWF0aC5zcXJ0KERlKnMpKStyLmxlZnQsam49ci5sZWZ0LFNyPXIudG9wXzAsbT0wLGY9ci5sZWZ0K3IucmlnaHQsdmU9bmV3IHByLExuKHZlLEooMCkpLHE9bmV3IHByLGQ9bmV3IHB0KGUuZ3JvdXBzLDApLHk9bnVsbCx1PW5ldyBRO2QuaTxkLnRoaXMkMDFfMC5zaXplXzEoKTspYz0ocm4oZC5pPGQudGhpcyQwMV8wLnNpemVfMSgpKSxhKGQudGhpcyQwMV8wLmdldF8wKGQubGFzdD1kLmkrKyksMTYzKSksbm49cWkoYyksaD1DYShjKSxqbitubj5FJiYoaSYmKE10KHEsbSksTXQodmUsSihkLmktMSkpLGVlKGUucmlnaHQseSksdS5hcnJheS5sZW5ndGg9MCksam49ci5sZWZ0LFNyKz1tK24sbT0wLGY9Uy5NYXRoLm1heChmLHIubGVmdCtyLnJpZ2h0K25uKSksUmUodS5hcnJheSxjKSx1emUoYyxqbixTciksZj1TLk1hdGgubWF4KGYsam4rbm4rci5yaWdodCksbT1TLk1hdGgubWF4KG0saCksam4rPW5uK24seT1jO2lmKHFyKGUuYm90dG9tLHUpLGVlKGUucmlnaHQsYShsZSh1LHUuYXJyYXkubGVuZ3RoLTEpLDE2MykpLGY9Uy5NYXRoLm1heChmLHQpLEZlPVNyK20rci5ib3R0b20sRmU8byYmKG0rPW8tRmUsRmU9byksaSlmb3Ioam49ci5sZWZ0LGQ9bmV3IHB0KGUuZ3JvdXBzLDApLE10KHZlLEooZS5ncm91cHMuYXJyYXkubGVuZ3RoKSksbmU9ZG4odmUsMCksQT1hKHVuKG5lKSwxNykudmFsdWVfMCxNdChxLG0pLEg9ZG4ocSwwKSxNPTA7ZC5pPGQudGhpcyQwMV8wLnNpemVfMSgpOylkLmk9PUEmJihqbj1yLmxlZnQsTT1SKCQodW4oSCkpKSxBPWEodW4obmUpLDE3KS52YWx1ZV8wKSxjPShybihkLmk8ZC50aGlzJDAxXzAuc2l6ZV8xKCkpLGEoZC50aGlzJDAxXzAuZ2V0XzAoZC5sYXN0PWQuaSsrKSwxNjMpKSxsemUoYyxNKSxkLmk9PUEmJih4PWYtam4tci5yaWdodCxrPXFpKGMpLHN6ZShjLHgpLGN6ZShjLCh4LWspLzIsMCkpLGpuKz1xaShjKStuO3JldHVybiBuZXcgWShmLEZlKX1mdW5jdGlvbiBpemUoKXt9ZnVuY3Rpb24gekVuKGUsbil7cmV0dXJuLWlyKHFpKGUpKkNhKGUpLHFpKG4pKkNhKG4pKX1mdW5jdGlvbiAkRW4oZSxuKXtyZXR1cm4gaXIocWkoZSkqQ2EoZSkscWkobikqQ2EobikpfWZ1bmN0aW9uIEJFbihlLG4pe3JldHVybiBpcihxaShlKSpDYShlKSxxaShuKSpDYShuKSl9cCg3MTcsMjA1LGdfLGl6ZSksbC5sYXlvdXQ9ZnVuY3Rpb24obixyKXtvemUobixyKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkJveExheW91dFByb3ZpZGVyIiw3MTcpO2Z1bmN0aW9uIEdFbihlLG4scil7dmFyIHQsbyxpLHMsdTtyZXR1cm4gbz1hKFYobiwobkEoKSxjUSkpLDE3KSwhbyYmKG89SigwKSksaT1hKFYocixjUSksMTcpLCFpJiYoaT1KKDApKSxvLnZhbHVlXzA+aS52YWx1ZV8wPy0xOm8udmFsdWVfMDxpLnZhbHVlXzA/MTplLnZhbCRpbnRlcmFjdGl2ZTImJih0PWlyKG4ueV8wLHIueV8wKSx0IT0wfHwodD1pcihuLnhfMCxyLnhfMCksdCE9MCkpP3Q6KHM9bi53aWR0aF8wKm4uaGVpZ2h0LHU9ci53aWR0aF8wKnIuaGVpZ2h0LGlyKHMsdSkpfWZ1bmN0aW9uIGF6ZShlKXt0aGlzLnZhbCRpbnRlcmFjdGl2ZTI9ZX1wKDk4MywxLE5uLGF6ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gR0VuKHRoaXMsYShuLDI3KSxhKHIsMjcpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxsLnZhbCRpbnRlcmFjdGl2ZTI9ITEsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkJveExheW91dFByb3ZpZGVyLzEiLDk4Myk7ZnVuY3Rpb24gQ2EoZSl7cmV0dXJuIGUubm9kZT9lLm5vZGUuaGVpZ2h0OmUuc2l6ZV8wLnlfMH1mdW5jdGlvbiBxaShlKXtyZXR1cm4gZS5ub2RlP2Uubm9kZS53aWR0aF8wOmUuc2l6ZV8wLnhfMH1mdW5jdGlvbiBsemUoZSxuKXt2YXIgcix0LG87aWYoZS5ub2RlKUNkKGUubm9kZSxuKTtlbHNlIGZvcihyPW4tQ2EoZSksbz1uZXcgVChlLmJvdHRvbSk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE2MyksbHplKHQsQ2EodCkrcil9ZnVuY3Rpb24gc3plKGUsbil7dmFyIHIsdCxvO2lmKGUubm9kZSlUZChlLm5vZGUsbik7ZWxzZSBmb3Iocj1uLXFpKGUpLG89bmV3IFQoZS5yaWdodCk7by5pPG8udGhpcyQwMS5hcnJheS5sZW5ndGg7KXQ9YShDKG8pLDE2Myksc3plKHQscWkodCkrcil9ZnVuY3Rpb24gdXplKGUsbixyKXt2YXIgdCxvO2lmKGUubm9kZSlDaShlLm5vZGUsZS5ub2RlLnhfMCtuKSxUaShlLm5vZGUsZS5ub2RlLnlfMCtyKTtlbHNlIGZvcihvPW5ldyBUKGUuZ3JvdXBzKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTYzKSx1emUodCxuLHIpfWZ1bmN0aW9uIGN6ZShlLG4scil7dmFyIHQsbztpZihlLm5vZGUpTGVlKGUubm9kZSxuLHIpO2Vsc2UgZm9yKG89bmV3IFQoZS5ncm91cHMpO28uaTxvLnRoaXMkMDEuYXJyYXkubGVuZ3RoOyl0PWEoQyhvKSwxNjMpLGN6ZSh0LG4scil9ZnVuY3Rpb24gRUEoZSl7dGhpcy5ncm91cHM9KHZuKGUpLG5ldyBRaShlKSksdGhpcy5ib3R0b209bmV3IFEsdGhpcy5yaWdodD1uZXcgUSx0aGlzLnNpemVfMD1uZXcgbXR9ZnVuY3Rpb24gX3plKGUpe3RoaXMubm9kZT1lLENpKGUsMCksVGkoZSwwKX1wKDE2MywxLHsxNjM6MX0sRUEsX3plKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlP0xuZSh0aGlzLm5vZGUpOm0wKHRoaXMuZ3JvdXBzKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkJveExheW91dFByb3ZpZGVyL0dyb3VwIiwxNjMpO2Z1bmN0aW9uIHZBKCl7dkE9RixUUj1uZXcgU0EoIlNJTVBMRSIsMCksdmVlPW5ldyBTQSgiR1JPVVBfREVDIiwxKSxDZWU9bmV3IFNBKCJHUk9VUF9NSVhFRCIsMiksU2VlPW5ldyBTQSgiR1JPVVBfSU5DIiwzKX1mdW5jdGlvbiBTQShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIEhFbihlKXtyZXR1cm4gdkEoKSx3bigoZHplKCksZnplKSxlKX1mdW5jdGlvbiBVRW4oKXtyZXR1cm4gdkEoKSxQKEkoVGVlLDEpLFcsMzIwLDAsW1RSLHZlZSxDZWUsU2VlXSl9cCgzMjAsMjIsezM6MSwzNDoxLDIyOjEsMzIwOjF9LFNBKTt2YXIgdmVlLFNlZSxDZWUsVFIsVGVlPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiQm94TGF5b3V0UHJvdmlkZXIvUGFja2luZ01vZGUiLDMyMCxnbixVRW4sSEVuKTtmdW5jdGlvbiBkemUoKXtkemU9RixmemU9eW4oKHZBKCksUChJKFRlZSwxKSxXLDMyMCwwLFtUUix2ZWUsQ2VlLFNlZV0pKSl9dmFyIGZ6ZTtmdW5jdGlvbiBwemUoKXt9cCg5ODQsMSxObixwemUpLGwuY29tcGFyZV8xPWZ1bmN0aW9uKG4scil7cmV0dXJuIHpFbihhKG4sMTYzKSxhKHIsMTYzKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXM9PT1ufSxsLnJldmVyc2VkPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkJveExheW91dFByb3ZpZGVyL2xhbWJkYSQwJFR5cGUiLDk4NCk7ZnVuY3Rpb24gZ3plKCl7fXAoOTg1LDEsTm4sZ3plKSxsLmNvbXBhcmVfMT1mdW5jdGlvbihuLHIpe3JldHVybiAkRW4oYShuLDE2MyksYShyLDE2MykpfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5yZXZlcnNlZD1mdW5jdGlvbigpe3JldHVybiBuZXcgQ24odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJCb3hMYXlvdXRQcm92aWRlci9sYW1iZGEkMSRUeXBlIiw5ODUpO2Z1bmN0aW9uIGh6ZSgpe31wKDk4NiwxLE5uLGh6ZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gQkVuKGEobiwxNjMpLGEociwxNjMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiQm94TGF5b3V0UHJvdmlkZXIvbGFtYmRhJDIkVHlwZSIsOTg2KTtmdW5jdGlvbiBtemUoKXt9cCgxMzg0LDEsezg0NToxfSxtemUpLGwuYWNjZXB0XzQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gTFAoKSwhTChyLDE2Nyl8fHdSZSgoUWgoKSxhKG4sMTY3KSkscil9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFbGtTcGFjaW5ncy9BYnN0cmFjdFNwYWNpbmdzQnVpbGRlci9sYW1iZGEkMCRUeXBlIiwxMzg0KTtmdW5jdGlvbiB5emUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEzODUsMSxKZSx5emUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0Mxbih0aGlzLiQkb3V0ZXJfMCxhKG4sMTQ5KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFbGtTcGFjaW5ncy9BYnN0cmFjdFNwYWNpbmdzQnVpbGRlci9sYW1iZGEkMSRUeXBlIiwxMzg1KTtmdW5jdGlvbiB3emUoKXt9cCgxMzg2LDEsSmUsd3plKSxsLmFjY2VwdD1mdW5jdGlvbihuKXthKG4sOTYpLExQKCl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFbGtTcGFjaW5ncy9BYnN0cmFjdFNwYWNpbmdzQnVpbGRlci9sYW1iZGEkMiRUeXBlIiwxMzg2KTtmdW5jdGlvbiBFemUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDEzOTAsMSxKZSxFemUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1Qxbih0aGlzLiQkb3V0ZXJfMCxhKG4sOTYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkVsa1NwYWNpbmdzL0Fic3RyYWN0U3BhY2luZ3NCdWlsZGVyL2xhbWJkYSQzJFR5cGUiLDEzOTApO2Z1bmN0aW9uIHZ6ZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5lbGVtZW50XzE9bn1wKDEzODgsMSxJbix2emUpLGwudGVzdF8wPWZ1bmN0aW9uKG4pe3JldHVybiBiMW4odGhpcy4kJG91dGVyXzAsdGhpcy5lbGVtZW50XzEsYShuLDE0OSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiRWxrU3BhY2luZ3MvQWJzdHJhY3RTcGFjaW5nc0J1aWxkZXIvbGFtYmRhJDQkVHlwZSIsMTM4OCk7ZnVuY3Rpb24gU3plKGUsbil7dGhpcy5lbGVtZW50XzA9ZSx0aGlzLnBfMT1ufXAoMTM4NywxLEluLFN6ZSksbC50ZXN0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHgxbih0aGlzLmVsZW1lbnRfMCx0aGlzLnBfMSxhKG4sODQ1KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFbGtTcGFjaW5ncy9BYnN0cmFjdFNwYWNpbmdzQnVpbGRlci9sYW1iZGEkNSRUeXBlIiwxMzg3KTtmdW5jdGlvbiBDemUoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuZWxlbWVudF8xPW59cCgxMzg5LDEsSmUsQ3plKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtJMW4odGhpcy4kJG91dGVyXzAsdGhpcy5lbGVtZW50XzEsYShuLDE0OSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiRWxrU3BhY2luZ3MvQWJzdHJhY3RTcGFjaW5nc0J1aWxkZXIvbGFtYmRhJDYkVHlwZSIsMTM4OSk7ZnVuY3Rpb24gVHplKGUpe3ZhciBuLHIsdCxvLGk7aWYodD1SKCQoVihlLChGbigpLEpEZSkpKSksdCE9MSlmb3IoUmcoZSx0KmUud2lkdGhfMCx0KmUuaGVpZ2h0KSxyPU9LZShES2UoKCFlLnBvcnRzJiYoZS5wb3J0cz1uZXcgVSh1YSxlLDksOSkpLGUucG9ydHMpLG5ldyBMemUpKSxpPVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFsoIWUubGFiZWxzJiYoZS5sYWJlbHM9bmV3IFUoUXQsZSwxLDcpKSxlLmxhYmVscyksKCFlLnBvcnRzJiYoZS5wb3J0cz1uZXcgVSh1YSxlLDksOSkpLGUucG9ydHMpLHJdKSkpO19uKGkpOylvPWEodG4oaSksNDIyKSxvLnNldExvY2F0aW9uKHQqby5nZXRYKCksdCpvLmdldFkoKSksby5zZXREaW1lbnNpb25zKHQqby5nZXRXaWR0aCgpLHQqby5nZXRIZWlnaHQoKSksbj1hKG8uZ2V0UHJvcGVydHkoTVEpLDgpLG4mJihuLnhfMCo9dCxuLnlfMCo9dCl9ZnVuY3Rpb24gVlQoZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZihlLnNpemVfMDwyKXRocm93IGIobmV3IEdlKCJUaGUgdmVjdG9yIGNoYWluIG11c3QgY29udGFpbiBhdCBsZWFzdCBhIHNvdXJjZSBhbmQgYSB0YXJnZXQgcG9pbnQuIikpO2ZvcihvPShybihlLnNpemVfMCE9MCksYShlLmhlYWRlci5uZXh0XzAudmFsdWVfMCw4KSksbmIobixvLnhfMCxvLnlfMCksYz1uZXcgU20oKCFuLmJlbmRQb2ludHMmJihuLmJlbmRQb2ludHM9bmV3IGpyKEJhLG4sNSkpLG4uYmVuZFBvaW50cykpLHM9ZG4oZSwxKTtzLmN1cnJlbnRJbmRleDxlLnNpemVfMC0xOyl1PWEodW4ocyksOCksYy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpP3I9YShlbihjKSwzNzcpOihyPShYMCgpLHQ9bmV3IE9BLHQpLHBHZShjLHIpKSxXUihyLHUueF8wLHUueV8wKTtmb3IoO2MuY3Vyc29yIT1jLnRoaXMkMDFfMi5zaXplXzEoKTspZW4oYykseVMoYyk7aT0ocm4oZS5zaXplXzAhPTApLGEoZS50YWlsLnByZXYudmFsdWVfMCw4KSksZWIobixpLnhfMCxpLnlfMCl9ZnVuY3Rpb24gYmVlKGUsbil7dmFyIHIsdCxvLGk7Zm9yKHI9bmV3IHRyZShlKTtyLmRhdGFfMD09bnVsbCYmIXIuaW5jbHVkZVJvb3Q/cnJlKHIpOnIuZGF0YV8wPT1udWxsfHxyLnNpemVfMCE9MCYmYShyLmRhdGFfMFtyLnNpemVfMC0xXSw1MSkuaGFzTmV4dF8wKCk7KWlmKGk9YShlTChyKSw1OCksTChpLDE2NykpZm9yKHQ9YShpLDE2Nyksbz0wO288bi5sZW5ndGg7bysrKW5bb10udmlzaXQodCl9ZnVuY3Rpb24gV0VuKGUsbil7dmFyIHI7aWYoIWpzKGUpKXRocm93IGIobmV3IHJvKCJwb3J0IG11c3QgaGF2ZSBhIHBhcmVudCBub2RlIHRvIGNhbGN1bGF0ZSB0aGUgcG9ydCBzaWRlIikpO3N3aXRjaChyPWpzKGUpLG4ub3JkaW5hbCl7Y2FzZSAxOnJldHVybi0oZS55XzArZS5oZWlnaHQpO2Nhc2UgMjpyZXR1cm4gZS54XzAtci53aWR0aF8wO2Nhc2UgMzpyZXR1cm4gZS55XzAtci5oZWlnaHQ7Y2FzZSA0OnJldHVybi0oZS54XzArZS53aWR0aF8wKX1yZXR1cm4gMH1mdW5jdGlvbiBJZWUoZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZighanMoZSkpdGhyb3cgYihuZXcgcm8oInBvcnQgbXVzdCBoYXZlIGEgcGFyZW50IG5vZGUgdG8gY2FsY3VsYXRlIHRoZSBwb3J0IHNpZGUiKSk7aWYodD1qcyhlKSxpPXQud2lkdGhfMCxvPXQuaGVpZ2h0LGk8PTAmJm88PTApcmV0dXJuIHJlKCksT287c3dpdGNoKHU9ZS54XzAsYz1lLnlfMCxuLm9yZGluYWwpe2Nhc2UgMjpjYXNlIDE6aWYodTwwKXJldHVybiByZSgpLGplO2lmKHUrZS53aWR0aF8wPmkpcmV0dXJuIHJlKCkscWU7YnJlYWs7Y2FzZSA0OmNhc2UgMzppZihjPDApcmV0dXJuIHJlKCksVWU7aWYoYytlLmhlaWdodD5vKXJldHVybiByZSgpLGxufXJldHVybiBzPSh1K2Uud2lkdGhfMC8yKS9pLHI9KGMrZS5oZWlnaHQvMikvbyxzK3I8PTEmJnMtcjw9MD8ocmUoKSxqZSk6cytyPj0xJiZzLXI+PTA/KHJlKCkscWUpOnI8LjU/KHJlKCksVWUpOihyZSgpLGxuKX1mdW5jdGlvbiB4ZWUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGs7Zm9yKGg9aHIsbT1ocixkPTAsZj0wLGM9bmV3IFEsdT1uZXcgWWUoKCFlLmNvbnRhaW5lZEVkZ2VzJiYoZS5jb250YWluZWRFZGdlcz1uZXcgVShNcixlLDEyLDMpKSxlLmNvbnRhaW5lZEVkZ2VzKSk7dS5jdXJzb3IhPXUudGhpcyQwMV8yLnNpemVfMSgpOylpPWEoZW4odSksNzQpLGM9TmEoUChJKHhhLDEpLE1lLDIwLDAsW2MsKCFpLmxhYmVscyYmKGkubGFiZWxzPW5ldyBVKFF0LGksMSw3KSksaS5sYWJlbHMpXSkpO2ZvcihrPVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFsoIWUubGFiZWxzJiYoZS5sYWJlbHM9bmV3IFUoUXQsZSwxLDcpKSxlLmxhYmVscyksKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbiksY10pKSk7X24oayk7KUE9YSh0bihrKSw0MjIpLF89YShBLmdldFByb3BlcnR5KChGbigpLGJ3KSksMTQwKSxoPkEuZ2V0WCgpLV8ubGVmdCYmKGg9QS5nZXRYKCktXy5sZWZ0KSxtPkEuZ2V0WSgpLV8udG9wXzAmJihtPUEuZ2V0WSgpLV8udG9wXzApLGQ8QS5nZXRYKCkrQS5nZXRXaWR0aCgpK18ucmlnaHQmJihkPUEuZ2V0WCgpK0EuZ2V0V2lkdGgoKStfLnJpZ2h0KSxmPEEuZ2V0WSgpK0EuZ2V0SGVpZ2h0KCkrXy5ib3R0b20mJihmPUEuZ2V0WSgpK0EuZ2V0SGVpZ2h0KCkrXy5ib3R0b20pO2ZvcihzPW5ldyBZZSgoIWUuY29udGFpbmVkRWRnZXMmJihlLmNvbnRhaW5lZEVkZ2VzPW5ldyBVKE1yLGUsMTIsMykpLGUuY29udGFpbmVkRWRnZXMpKTtzLmN1cnNvciE9cy50aGlzJDAxXzIuc2l6ZV8xKCk7KWZvcihpPWEoZW4ocyksNzQpLHg9bmV3IFllKCghaS5zZWN0aW9ucyYmKGkuc2VjdGlvbnM9bmV3IFUoZ3IsaSw2LDYpKSxpLnNlY3Rpb25zKSk7eC5jdXJzb3IhPXgudGhpcyQwMV8yLnNpemVfMSgpOylmb3Iodj1hKGVuKHgpLDE2NikseT12LnN0YXJ0WCx0PXYuZW5kWCxFPXYuc3RhcnRZLG89di5lbmRZLGg9Uy5NYXRoLm1pbihoLHkpLGg9Uy5NYXRoLm1pbihoLHQpLGQ9Uy5NYXRoLm1heChkLHkpLGQ9Uy5NYXRoLm1heChkLHQpLG09Uy5NYXRoLm1pbihtLEUpLG09Uy5NYXRoLm1pbihtLG8pLGY9Uy5NYXRoLm1heChmLEUpLGY9Uy5NYXRoLm1heChmLG8pLHI9bmV3IFllKCghdi5iZW5kUG9pbnRzJiYodi5iZW5kUG9pbnRzPW5ldyBqcihCYSx2LDUpKSx2LmJlbmRQb2ludHMpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSwzNzcpLGg9Uy5NYXRoLm1pbihoLG4ueF8wKSxkPVMuTWF0aC5tYXgoZCxuLnhfMCksbT1TLk1hdGgubWluKG0sbi55XzApLGY9Uy5NYXRoLm1heChmLG4ueV8wKTtucihlLChGbigpLFRnKSxkLWgpLG5yKGUsQ2csZi1tKX1mdW5jdGlvbiBQZWUoZSxuLHIsdCxvKXt2YXIgaTtzd2l0Y2goaT0wLG8ub3JkaW5hbCl7Y2FzZSAxOmk9Uy5NYXRoLm1heCgwLG4ueV8wK2UueV8wLShyLnlfMCt0KSk7YnJlYWs7Y2FzZSAzOmk9Uy5NYXRoLm1heCgwLC1lLnlfMC10KTticmVhaztjYXNlIDI6aT1TLk1hdGgubWF4KDAsLWUueF8wLXQpO2JyZWFrO2Nhc2UgNDppPVMuTWF0aC5tYXgoMCxuLnhfMCtlLnhfMC0oci54XzArdCkpfXJldHVybiBpfWZ1bmN0aW9uIGpFbihlLG4pe3ZhciByO3JldHVybiByPUFlZShlKSxQZWUobmV3IFkoci54XzAsci55XzApLG5ldyBZKHIud2lkdGhfMCxyLmhlaWdodCksZS5nZXRTaXplKCksbixlLmdldFNpZGUoKSl9ZnVuY3Rpb24gcVQoZSl7dmFyIG4scix0O2Zvcih0PW5ldyBqaSxMbih0LG5ldyBZKGUuc3RhcnRYLGUuc3RhcnRZKSkscj1uZXcgWWUoKCFlLmJlbmRQb2ludHMmJihlLmJlbmRQb2ludHM9bmV3IGpyKEJhLGUsNSkpLGUuYmVuZFBvaW50cykpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDM3NyksTG4odCxuZXcgWShuLnhfMCxuLnlfMCkpO3JldHVybiBMbih0LG5ldyBZKGUuZW5kWCxlLmVuZFkpKSx0fWZ1bmN0aW9uIFZFbihlKXt2YXIgbjtpZigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykuc2l6ZV8wIT0xKXRocm93IGIobmV3IEdlKCJUaGUgZWRnZSBuZWVkcyB0byBoYXZlIGV4YWN0bHkgb25lIGVkZ2Ugc2VjdGlvbi4gRm91bmQ6ICIrKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLnNpemVfMCkpO3JldHVybiBuPW5ldyBqaSxpYihhKE8oKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKSwwKSw4NCkpJiZmdChuLGJ6ZShlLGliKGEoTygoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLDApLDg0KSksITEpKSxpYihhKE8oKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzKSwwKSw4NCkpJiZmdChuLGJ6ZShlLGliKGEoTygoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLDApLDg0KSksITApKSxufWZ1bmN0aW9uIGJ6ZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscTtmb3IoSD1hKE8oKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLDApLDE2NiksZD1uZXcgamksTT1uZXcgc24scT1JemUoSCksZGkoTS5oYXNoQ29kZU1hcCxILHEpLGg9bmV3IHNuLHQ9bmV3IHByLHk9UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsWyghbi5pbmNvbWluZ0VkZ2VzJiYobi5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixuLDgsNSkpLG4uaW5jb21pbmdFZGdlcyksKCFuLm91dGdvaW5nRWRnZXMmJihuLm91dGdvaW5nRWRnZXM9bmV3IExlKE1yLG4sNyw0KSksbi5vdXRnb2luZ0VkZ2VzKV0pKSk7X24oeSk7KXtpZihtPWEodG4oeSksNzQpLCghZS5zZWN0aW9ucyYmKGUuc2VjdGlvbnM9bmV3IFUoZ3IsZSw2LDYpKSxlLnNlY3Rpb25zKS5zaXplXzAhPTEpdGhyb3cgYihuZXcgR2UoIlRoZSBlZGdlIG5lZWRzIHRvIGhhdmUgZXhhY3RseSBvbmUgZWRnZSBzZWN0aW9uLiBGb3VuZDogIisoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykuc2l6ZV8wKSk7bSE9ZSYmKHY9YShPKCghbS5zZWN0aW9ucyYmKG0uc2VjdGlvbnM9bmV3IFUoZ3IsbSw2LDYpKSxtLnNlY3Rpb25zKSwwKSwxNjYpLGJyKHQsdix0LnRhaWwucHJldix0LnRhaWwpLEU9YShfbyhqdChNLmhhc2hDb2RlTWFwLHYpKSwxMyksRXx8KEU9SXplKHYpLGRpKE0uaGFzaENvZGVNYXAsdixFKSksZj1yP3J0KG5ldyBSdChhKGxlKHEscS5hcnJheS5sZW5ndGgtMSksOCkpLGEobGUoRSxFLmFycmF5Lmxlbmd0aC0xKSw4KSk6cnQobmV3IFJ0KChBZSgwLHEuYXJyYXkubGVuZ3RoKSxhKHEuYXJyYXlbMF0sOCkpKSwoQWUoMCxFLmFycmF5Lmxlbmd0aCksYShFLmFycmF5WzBdLDgpKSksZGkoaC5oYXNoQ29kZU1hcCx2LGYpKX1pZih0LnNpemVfMCE9MClmb3IoeD1hKGxlKHEscj9xLmFycmF5Lmxlbmd0aC0xOjApLDgpLF89MTtfPHEuYXJyYXkubGVuZ3RoO18rKyl7Zm9yKEE9YShsZShxLHI/cS5hcnJheS5sZW5ndGgtMS1fOl8pLDgpLG89ZG4odCwwKTtvLmN1cnJlbnROb2RlIT1vLnRoaXMkMDEudGFpbDspdj1hKHVuKG8pLDE2NiksRT1hKF9vKGp0KE0uaGFzaENvZGVNYXAsdikpLDEzKSxFLmFycmF5Lmxlbmd0aDw9Xz9hayhvKTooaz1LbihuZXcgUnQoYShsZShFLHI/RS5hcnJheS5sZW5ndGgtMS1fOl8pLDgpKSxhKF9vKGp0KGguaGFzaENvZGVNYXAsdikpLDgpKSwoQS54XzAhPWsueF8wfHxBLnlfMCE9ay55XzApJiYoaT1BLnhfMC14LnhfMCx1PUEueV8wLXgueV8wLHM9ay54XzAteC54XzAsYz1rLnlfMC14LnlfMCxzKnU9PWMqaSYmKGk9PTB8fGlzTmFOKGkpP2k6aTwwPy0xOjEpPT0ocz09MHx8aXNOYU4ocyk/czpzPDA/LTE6MSkmJih1PT0wfHxpc05hTih1KT91OnU8MD8tMToxKT09KGM9PTB8fGlzTmFOKGMpP2M6YzwwPy0xOjEpPyhTLk1hdGguYWJzKGkpPFMuTWF0aC5hYnMocyl8fFMuTWF0aC5hYnModSk8Uy5NYXRoLmFicyhjKSkmJmJyKGQsQSxkLnRhaWwucHJldixkLnRhaWwpOl8+MSYmYnIoZCx4LGQudGFpbC5wcmV2LGQudGFpbCksYWsobykpKTt4PUF9cmV0dXJuIGR9ZnVuY3Rpb24gTmVlKGUpe3ZhciBuLHIsdDtyZXR1cm4gcj1hKFYoZSwoRm4oKSxyMSkpLDIxKSxyLmNvbnRhaW5zKChTYSgpLFlmKSk/KHQ9YShWKGUsVzApLDIxKSxuPW5ldyBSdChhKFYoZSx4ZyksOCkpLHQuY29udGFpbnMoKGdhKCksTHcpKSYmKG4ueF8wPD0wJiYobi54XzA9MjApLG4ueV8wPD0wJiYobi55XzA9MjApKSxuKTpuZXcgbXR9ZnVuY3Rpb24gQWVlKGUpe3ZhciBuLHIsdCxvO2ZvcihuPW51bGwsbz1uZXcgVChlLmdldExhYmVscygpKTtvLmk8by50aGlzJDAxLmFycmF5Lmxlbmd0aDspdD1hKEMobyksMTg3KSxyPW5ldyB0bCh0LmdldFBvc2l0aW9uKCkueF8wLHQuZ2V0UG9zaXRpb24oKS55XzAsdC5nZXRTaXplKCkueF8wLHQuZ2V0U2l6ZSgpLnlfMCksbj9SdihuLHIpOm49cjtyZXR1cm4hbiYmKG49bmV3IGltKSxufWZ1bmN0aW9uIEl6ZShlKXt2YXIgbixyLHQsbyxpLHM7Zm9yKHI9KCFlLmJlbmRQb2ludHMmJihlLmJlbmRQb2ludHM9bmV3IGpyKEJhLGUsNSkpLGUuYmVuZFBvaW50cykuc2l6ZV8wKzIscz1uZXcgX2kociksZWUocyxuZXcgWShlLnN0YXJ0WCxlLnN0YXJ0WSkpLExyKG5ldyBTZShudWxsLCghZS5iZW5kUG9pbnRzJiYoZS5iZW5kUG9pbnRzPW5ldyBqcihCYSxlLDUpKSxuZXcgeGUoZS5iZW5kUG9pbnRzLDE2KSkpLG5ldyBSemUocykpLGVlKHMsbmV3IFkoZS5lbmRYLGUuZW5kWSkpLG49MTtuPHMuYXJyYXkubGVuZ3RoLTE7KXQ9KEFlKG4tMSxzLmFycmF5Lmxlbmd0aCksYShzLmFycmF5W24tMV0sOCkpLG89KEFlKG4scy5hcnJheS5sZW5ndGgpLGEocy5hcnJheVtuXSw4KSksaT0oQWUobisxLHMuYXJyYXkubGVuZ3RoKSxhKHMuYXJyYXlbbisxXSw4KSksdC54XzA9PW8ueF8wJiZvLnhfMD09aS54XzB8fHQueV8wPT1vLnlfMCYmby55XzA9PWkueV8wP01jKHMsbik6KytuO3JldHVybiBzfWZ1bmN0aW9uIHFFbihlLG4scil7dmFyIHQ7THIobmV3IFNlKG51bGwsKCFyLnNlY3Rpb25zJiYoci5zZWN0aW9ucz1uZXcgVShncixyLDYsNikpLG5ldyB4ZShyLnNlY3Rpb25zLDE2KSkpLG5ldyBPemUoZSxuKSksTHIobmV3IFNlKG51bGwsKCFyLmxhYmVscyYmKHIubGFiZWxzPW5ldyBVKFF0LHIsMSw3KSksbmV3IHhlKHIubGFiZWxzLDE2KSkpLG5ldyBNemUoZSxuKSksdD1hKFYociwoRm4oKSx5ZCkpLDc1KSx0JiZyUSh0LGUsbil9ZnVuY3Rpb24gWUVuKGUsbixyKXtKRW4ocixlLG4pfWZ1bmN0aW9uIEtFbihlLG4scil7X2wocixyLnhfMCtlLHIueV8wK24pfWZ1bmN0aW9uIFhFbihlLG4pe3JldHVybiBlZShlLG5ldyBZKG4ueF8wLG4ueV8wKSl9ZnVuY3Rpb24gQ0EoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfO2lmKEwoZS5lQ29udGFpbmVyXzAoKSwxNjcpPyhDQShhKGUuZUNvbnRhaW5lcl8wKCksMTY3KSxuKSxuLnN0cmluZys9IiA+ICIpOm4uc3RyaW5nKz0iUm9vdCAiLHI9ZS5lQ2xhc3NfMCgpLm5hbWVfMCxUZShyLnN1YnN0cigwLDMpLCJFbGsiKT9PbihuLChIZSgzLHIubGVuZ3RoKzEpLHIuc3Vic3RyKDMpKSk6bi5zdHJpbmcrPSIiK3Isbz1lLmdldElkZW50aWZpZXIoKSxvKXtPbigobi5zdHJpbmcrPSIgIixuKSxvKTtyZXR1cm59aWYoTChlLDM2NikmJihfPWEoZSwxMzUpLnRleHRfMCxfKSl7T24oKG4uc3RyaW5nKz0iICIsbiksXyk7cmV0dXJufWZvcihzPW5ldyBZZShlLmdldExhYmVsc18wKCkpO3MuY3Vyc29yIT1zLnRoaXMkMDFfMi5zaXplXzEoKTspaWYoaT1hKGVuKHMpLDEzNSksXz1pLnRleHRfMCxfKXtPbigobi5zdHJpbmcrPSIgIixuKSxfKTtyZXR1cm59aWYoTChlLDMyNikmJih0PWEoZSw3NCksIXQuc291cmNlcyYmKHQuc291cmNlcz1uZXcgTGUoYW4sdCw0LDcpKSx0LnNvdXJjZXMuc2l6ZV8wIT0wJiYoIXQudGFyZ2V0cyYmKHQudGFyZ2V0cz1uZXcgTGUoYW4sdCw1LDgpKSx0LnRhcmdldHMuc2l6ZV8wIT0wKSkpe2ZvcihuLnN0cmluZys9IiAoIix1PW5ldyBTbSgoIXQuc291cmNlcyYmKHQuc291cmNlcz1uZXcgTGUoYW4sdCw0LDcpKSx0LnNvdXJjZXMpKTt1LmN1cnNvciE9dS50aGlzJDAxXzIuc2l6ZV8xKCk7KXUuY3Vyc29yPjAmJihuLnN0cmluZys9IiwgIiksQ0EoYShlbih1KSwxNjcpLG4pO2ZvcihuLnN0cmluZys9IiAtPiAiLGM9bmV3IFNtKCghdC50YXJnZXRzJiYodC50YXJnZXRzPW5ldyBMZShhbix0LDUsOCkpLHQudGFyZ2V0cykpO2MuY3Vyc29yIT1jLnRoaXMkMDFfMi5zaXplXzEoKTspYy5jdXJzb3I+MCYmKG4uc3RyaW5nKz0iLCAiKSxDQShhKGVuKGMpLDE2Nyksbik7bi5zdHJpbmcrPSIpIn19ZnVuY3Rpb24geHplKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaDtpZihoPWEoVihlLChGbigpLHIxKSksMjEpLGguaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHU9MCxzPTAsaC5jb250YWlucygoU2EoKSxVVCkpKXtmb3IoZD1hKFYoZSxqdiksMTAxKSx0PTIscj0yLG89MixpPTIsbj15cihlKT9hKFYoeXIoZSksbjEpLDg4KTphKFYoZSxuMSksODgpLF89bmV3IFllKCghZS5wb3J0cyYmKGUucG9ydHM9bmV3IFUodWEsZSw5LDkpKSxlLnBvcnRzKSk7Xy5jdXJzb3IhPV8udGhpcyQwMV8yLnNpemVfMSgpOylpZihjPWEoZW4oXyksMTIzKSxmPWEoVihjLFBnKSw2NCksZj09KHJlKCksT28pJiYoZj1JZWUoYyxuKSxucihjLFBnLGYpKSxkPT0oZHQoKSxhaSkpc3dpdGNoKGYub3JkaW5hbCl7Y2FzZSAxOnQ9Uy5NYXRoLm1heCh0LGMueF8wK2Mud2lkdGhfMCk7YnJlYWs7Y2FzZSAyOnI9Uy5NYXRoLm1heChyLGMueV8wK2MuaGVpZ2h0KTticmVhaztjYXNlIDM6bz1TLk1hdGgubWF4KG8sYy54XzArYy53aWR0aF8wKTticmVhaztjYXNlIDQ6aT1TLk1hdGgubWF4KGksYy55XzArYy5oZWlnaHQpfWVsc2Ugc3dpdGNoKGYub3JkaW5hbCl7Y2FzZSAxOnQrPWMud2lkdGhfMCsyO2JyZWFrO2Nhc2UgMjpyKz1jLmhlaWdodCsyO2JyZWFrO2Nhc2UgMzpvKz1jLndpZHRoXzArMjticmVhaztjYXNlIDQ6aSs9Yy5oZWlnaHQrMn11PVMuTWF0aC5tYXgodCxvKSxzPVMuTWF0aC5tYXgocixpKX1yZXR1cm4gd2QoZSx1LHMsITAsITApfWZ1bmN0aW9uIHdkKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxO2lmKHY9bmV3IFkoZS53aWR0aF8wLGUuaGVpZ2h0KSxFPU5lZShlKSxFLnhfMD1TLk1hdGgubWF4KEUueF8wLG4pLEUueV8wPVMuTWF0aC5tYXgoRS55XzAscikscT1FLnhfMC92LnhfMCxkPUUueV8wL3YueV8wLE09RS54XzAtdi54XzAsYz1FLnlfMC12LnlfMCx0KWZvcihzPXlyKGUpP2EoVih5cihlKSwoRm4oKSxuMSkpLDg4KTphKFYoZSwoRm4oKSxuMSkpLDg4KSx1PUQoVihlLChGbigpLGp2KSkpPT09RCgoZHQoKSxhaSkpLEE9bmV3IFllKCghZS5wb3J0cyYmKGUucG9ydHM9bmV3IFUodWEsZSw5LDkpKSxlLnBvcnRzKSk7QS5jdXJzb3IhPUEudGhpcyQwMV8yLnNpemVfMSgpOylzd2l0Y2goeD1hKGVuKEEpLDEyMyksaz1hKFYoeCxQZyksNjQpLGs9PShyZSgpLE9vKSYmKGs9SWVlKHgscyksbnIoeCxQZyxrKSksay5vcmRpbmFsKXtjYXNlIDE6dXx8Q2koeCx4LnhfMCpxKTticmVhaztjYXNlIDI6Q2koeCx4LnhfMCtNKSx1fHxUaSh4LHgueV8wKmQpO2JyZWFrO2Nhc2UgMzp1fHxDaSh4LHgueF8wKnEpLFRpKHgseC55XzArYyk7YnJlYWs7Y2FzZSA0OnV8fFRpKHgseC55XzAqZCl9aWYoUmcoZSxFLnhfMCxFLnlfMCksbylmb3IoaD1uZXcgWWUoKCFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksZS5sYWJlbHMpKTtoLmN1cnNvciE9aC50aGlzJDAxXzIuc2l6ZV8xKCk7KWY9YShlbihoKSwxMzUpLG09Zi54XzArZi53aWR0aF8wLzIseT1mLnlfMCtmLmhlaWdodC8yLEg9bS92LnhfMCxfPXkvdi55XzAsSCtfPj0xJiYoSC1fPjAmJnk+PTA/KENpKGYsZi54XzArTSksVGkoZixmLnlfMCtjKl8pKTpILV88MCYmbT49MCYmKENpKGYsZi54XzArTSpIKSxUaShmLGYueV8wK2MpKSk7cmV0dXJuIG5yKGUsKEZuKCkscjEpLChTYSgpLGk9YShpcyh0UyksOSksbmV3IEphKGksYShEbChpLGkubGVuZ3RoKSw5KSwwKSkpLG5ldyBZKHEsZCl9ZnVuY3Rpb24gUHplKGUsbil7dmFyIHI7Zm9yKHI9bjtyOyltZChlLHIueF8wLHIueV8wKSxyPXlyKHIpO3JldHVybiBlfWZ1bmN0aW9uIE56ZShlLG4pe3ZhciByO2ZvcihyPW47cjspbWQoZSwtci54XzAsLXIueV8wKSxyPXlyKHIpO3JldHVybiBlfWZ1bmN0aW9uIEpFbihlLG4scil7dmFyIHQsbztmb3IobmIoZSxlLnN0YXJ0WCtuLGUuc3RhcnRZK3IpLG89bmV3IFllKCghZS5iZW5kUG9pbnRzJiYoZS5iZW5kUG9pbnRzPW5ldyBqcihCYSxlLDUpKSxlLmJlbmRQb2ludHMpKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YShlbihvKSwzNzcpLFdSKHQsdC54XzArbix0LnlfMCtyKTtlYihlLGUuZW5kWCtuLGUuZW5kWStyKX1mdW5jdGlvbiBMZWUoZSxuLHIpe3ZhciB0LG87Zm9yKG89bmV3IFllKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YShlbihvKSwyNyksX2wodCx0LnhfMCtuLHQueV8wK3IpO0V0KCghZS5jb250YWluZWRFZGdlcyYmKGUuY29udGFpbmVkRWRnZXM9bmV3IFUoTXIsZSwxMiwzKSksZS5jb250YWluZWRFZGdlcyksbmV3IGt6ZShuLHIpKX1mdW5jdGlvbiBrZWUoZSxuLHIpe3ZhciB0LG8saTt0PWEoVihlLChGbigpLElUKSksMjEpLG89MCxpPTAsbi54XzA+ci54XzAmJih0LmNvbnRhaW5zKChlMSgpLEd2KSk/bz0obi54XzAtci54XzApLzI6dC5jb250YWlucyhIdikmJihvPW4ueF8wLXIueF8wKSksbi55XzA+ci55XzAmJih0LmNvbnRhaW5zKChlMSgpLFd2KSk/aT0obi55XzAtci55XzApLzI6dC5jb250YWlucyhVdikmJihpPW4ueV8wLXIueV8wKSksTGVlKGUsbyxpKX1mdW5jdGlvbiBBemUoZSl7cmV0dXJuIE1BKGEoZSwxMjMpKX1mdW5jdGlvbiBMemUoKXt9cCg5NDcsMSx7fSxMemUpLGwuYXBwbHlfMD1mdW5jdGlvbihuKXtyZXR1cm4gQXplKG4pfSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkVsa1V0aWwvbGFtYmRhJDAkVHlwZSIsOTQ3KTtmdW5jdGlvbiBremUoZSxuKXt0aGlzLnhvZmZzZXRfMD1lLHRoaXMueW9mZnNldF8yPW59cCg5NDgsMSxKZSxremUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3FFbih0aGlzLnhvZmZzZXRfMCx0aGlzLnlvZmZzZXRfMixhKG4sNzQpKX0sbC54b2Zmc2V0XzA9MCxsLnlvZmZzZXRfMj0wLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFbGtVdGlsL2xhbWJkYSQxJFR5cGUiLDk0OCk7ZnVuY3Rpb24gT3plKGUsbil7dGhpcy54b2Zmc2V0XzA9ZSx0aGlzLnlvZmZzZXRfMj1ufXAoOTQ5LDEsSmUsT3plKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtZRW4odGhpcy54b2Zmc2V0XzAsdGhpcy55b2Zmc2V0XzIsYShuLDE2NikpfSxsLnhvZmZzZXRfMD0wLGwueW9mZnNldF8yPTAsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkVsa1V0aWwvbGFtYmRhJDIkVHlwZSIsOTQ5KTtmdW5jdGlvbiBNemUoZSxuKXt0aGlzLnhvZmZzZXRfMD1lLHRoaXMueW9mZnNldF8yPW59cCg5NTAsMSxKZSxNemUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe0tFbih0aGlzLnhvZmZzZXRfMCx0aGlzLnlvZmZzZXRfMixhKG4sMTM1KSl9LGwueG9mZnNldF8wPTAsbC55b2Zmc2V0XzI9MCxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiRWxrVXRpbC9sYW1iZGEkMyRUeXBlIiw5NTApO2Z1bmN0aW9uIFJ6ZShlKXt0aGlzLnBvaW50c18wPWV9cCg5NTEsMSxKZSxSemUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe1hFbih0aGlzLnBvaW50c18wLGEobiwzNzcpKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkVsa1V0aWwvbGFtYmRhJDQkVHlwZSIsOTUxKTtmdW5jdGlvbiBaRW4oZSxuKXtyZXR1cm4gZS5leGNsdXNpdmVMb3dlckJvdW5kPEckKG4pPy0xOjF9ZnVuY3Rpb24gUUVuKCl7dGhpcy5leGNsdXNpdmVMb3dlckJvdW5kPTB9cCgzMjUsMSx7MzQ6MSwzMjU6MX0sUUVuKSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBaRW4odGhpcyxhKG4sMjQyKSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIEwobiwzMjUpPyhyPWEobiwzMjUpLHRoaXMuZXhjbHVzaXZlTG93ZXJCb3VuZD09ci5leGNsdXNpdmVMb3dlckJvdW5kKTohMX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIEtyKHRoaXMuZXhjbHVzaXZlTG93ZXJCb3VuZCl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmV4Y2x1c2l2ZUxvd2VyQm91bmQrIiAoZXhjbHVzaXZlKSJ9LGwuZXhjbHVzaXZlTG93ZXJCb3VuZD0wLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJFeGNsdXNpdmVCb3VuZHMvRXhjbHVzaXZlTG93ZXJCb3VuZCIsMzI1KTtmdW5jdGlvbiBEemUoZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seTtpZihtPXlyKHlvKGEoTygoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLDApLDg0KSkpLHk9eXIoeW8oYShPKCghZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cyksMCksODQpKSksZj1tPT15LHU9bmV3IG10LG49YShWKGUsKHNBKCkscmVlKSksNzUpLG4mJm4uc2l6ZV8wPj0yKXtpZigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykuc2l6ZV8wPT0wKXI9KFgwKCksbz1uZXcgekEsbykscG4oKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLHIpO2Vsc2UgaWYoKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLnNpemVfMD4xKWZvcihoPW5ldyBTbSgoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykpO2guY3Vyc29yIT1oLnRoaXMkMDFfMi5zaXplXzEoKTspeVMoaCk7VlQobixhKE8oKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLDApLDE2NikpfWlmKGYpZm9yKHQ9bmV3IFllKCghZS5zZWN0aW9ucyYmKGUuc2VjdGlvbnM9bmV3IFUoZ3IsZSw2LDYpKSxlLnNlY3Rpb25zKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylmb3Iocj1hKGVuKHQpLDE2NiksXz1uZXcgWWUoKCFyLmJlbmRQb2ludHMmJihyLmJlbmRQb2ludHM9bmV3IGpyKEJhLHIsNSkpLHIuYmVuZFBvaW50cykpO18uY3Vyc29yIT1fLnRoaXMkMDFfMi5zaXplXzEoKTspYz1hKGVuKF8pLDM3NyksdS54XzA9Uy5NYXRoLm1heCh1LnhfMCxjLnhfMCksdS55XzA9Uy5NYXRoLm1heCh1LnlfMCxjLnlfMCk7Zm9yKHM9bmV3IFllKCghZS5sYWJlbHMmJihlLmxhYmVscz1uZXcgVShRdCxlLDEsNykpLGUubGFiZWxzKSk7cy5jdXJzb3IhPXMudGhpcyQwMV8yLnNpemVfMSgpOylpPWEoZW4ocyksMTM1KSxkPWEoVihpLFl2KSw4KSxkJiZfbChpLGQueF8wLGQueV8wKSxmJiYodS54XzA9Uy5NYXRoLm1heCh1LnhfMCxpLnhfMCtpLndpZHRoXzApLHUueV8wPVMuTWF0aC5tYXgodS55XzAsaS55XzAraS5oZWlnaHQpKTtyZXR1cm4gdX1mdW5jdGlvbiBGemUoKXt9cCgxMTE5LDIwNSxnXyxGemUpLGwubGF5b3V0PWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZTtmb3Ioci5iZWdpbigiRml4ZWQgTGF5b3V0IiwxKSxzPWEoVihuLChGbigpLG1RKSksMjIzKSxoPTAsbT0wLGs9bmV3IFllKCghbi5jaGlsZHJlbiYmKG4uY2hpbGRyZW49bmV3IFUoVW4sbiwxMCwxMSkpLG4uY2hpbGRyZW4pKTtrLmN1cnNvciE9ay50aGlzJDAxXzIuc2l6ZV8xKCk7KXtmb3IoeD1hKGVuKGspLDI3KSx3ZT1hKFYoeCwoc0EoKSxZdikpLDgpLHdlJiYoX2woeCx3ZS54XzAsd2UueV8wKSxhKFYoeCx0ZWUpLDE4MSkuY29udGFpbnMoKFNhKCksWWYpKSYmKHk9YShWKHgsaWVlKSw4KSx5LnhfMD4wJiZ5LnlfMD4wJiZ3ZCh4LHkueF8wLHkueV8wLCEwLCEwKSkpLGg9Uy5NYXRoLm1heChoLHgueF8wK3gud2lkdGhfMCksbT1TLk1hdGgubWF4KG0seC55XzAreC5oZWlnaHQpLGQ9bmV3IFllKCgheC5sYWJlbHMmJih4LmxhYmVscz1uZXcgVShRdCx4LDEsNykpLHgubGFiZWxzKSk7ZC5jdXJzb3IhPWQudGhpcyQwMV8yLnNpemVfMSgpOyljPWEoZW4oZCksMTM1KSx3ZT1hKFYoYyxZdiksOCksd2UmJl9sKGMsd2UueF8wLHdlLnlfMCksaD1TLk1hdGgubWF4KGgseC54XzArYy54XzArYy53aWR0aF8wKSxtPVMuTWF0aC5tYXgobSx4LnlfMCtjLnlfMCtjLmhlaWdodCk7Zm9yKHE9bmV3IFllKCgheC5wb3J0cyYmKHgucG9ydHM9bmV3IFUodWEseCw5LDkpKSx4LnBvcnRzKSk7cS5jdXJzb3IhPXEudGhpcyQwMV8yLnNpemVfMSgpOylmb3IoSD1hKGVuKHEpLDEyMyksd2U9YShWKEgsWXYpLDgpLHdlJiZfbChILHdlLnhfMCx3ZS55XzApLG5lPXgueF8wK0gueF8wLHZlPXgueV8wK0gueV8wLGg9Uy5NYXRoLm1heChoLG5lK0gud2lkdGhfMCksbT1TLk1hdGgubWF4KG0sdmUrSC5oZWlnaHQpLF89bmV3IFllKCghSC5sYWJlbHMmJihILmxhYmVscz1uZXcgVShRdCxILDEsNykpLEgubGFiZWxzKSk7Xy5jdXJzb3IhPV8udGhpcyQwMV8yLnNpemVfMSgpOyljPWEoZW4oXyksMTM1KSx3ZT1hKFYoYyxZdiksOCksd2UmJl9sKGMsd2UueF8wLHdlLnlfMCksaD1TLk1hdGgubWF4KGgsbmUrYy54XzArYy53aWR0aF8wKSxtPVMuTWF0aC5tYXgobSx2ZStjLnlfMCtjLmhlaWdodCk7Zm9yKGk9bmV3IFhlKFFlKEVjKHgpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihpKTspdD1hKHRuKGkpLDc0KSxmPUR6ZSh0KSxoPVMuTWF0aC5tYXgoaCxmLnhfMCksbT1TLk1hdGgubWF4KG0sZi55XzApO2ZvcihvPW5ldyBYZShRZShvYih4KS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSw3NCkseXIoV3UodCkpIT1uJiYoZj1EemUodCksaD1TLk1hdGgubWF4KGgsZi54XzApLG09Uy5NYXRoLm1heChtLGYueV8wKSl9aWYocz09KGZjKCksTncpKWZvcihBPW5ldyBZZSgoIW4uY2hpbGRyZW4mJihuLmNoaWxkcmVuPW5ldyBVKFVuLG4sMTAsMTEpKSxuLmNoaWxkcmVuKSk7QS5jdXJzb3IhPUEudGhpcyQwMV8yLnNpemVfMSgpOylmb3IoeD1hKGVuKEEpLDI3KSxvPW5ldyBYZShRZShFYyh4KS52YWwkaW5wdXRzMS5pdGVyYXRvcl8wKCksbmV3IFplKSk7X24obyk7KXQ9YSh0bihvKSw3NCksdT1WRW4odCksdS5zaXplXzA9PTA/bnIodCx5ZCxudWxsKTpucih0LHlkLHUpO2FlKGllKFYobiwoc0EoKSxvZWUpKSkpfHwoTT1hKFYobixtRmUpLDEwNyksdj1oK00ubGVmdCtNLnJpZ2h0LEU9bStNLnRvcF8wK00uYm90dG9tLHdkKG4sdixFLCEwLCEwKSksci5kb25lXzEoKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkZpeGVkTGF5b3V0UHJvdmlkZXIiLDExMTkpO2Z1bmN0aW9uIGJSKCl7fWZ1bmN0aW9uIHp6ZShlKXsodGhpcy5wcm9wZXJ0eU1hcD90aGlzLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5wdXRBbGwoZS5wcm9wZXJ0eU1hcD9lLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKX1mdW5jdGlvbiBpUyhlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9bnVsbCxlLmhhc1Byb3BlcnR5KChGbigpLHNtKSkmJihyPWEoZS5nZXRQcm9wZXJ0eShzbSksOTYpLHIuaGFzUHJvcGVydHkobikmJih0PXIuZ2V0UHJvcGVydHkobikpKSx0PT1udWxsJiZlLmdldEdyYXBoKCkmJih0PWUuZ2V0R3JhcGgoKS5nZXRQcm9wZXJ0eShuKSksdD09bnVsbCYmKHQ9dGUobikpLHR9ZnVuY3Rpb24gZXZuKGUpe3JldHVybiBhKGUuZ2V0S2V5KCksMTQ5KS5nZXRJZCgpKyI6Iit2byhlLmdldFZhbHVlKCkpfXAoMzg1LDEzNyx7MzoxLDQyMzoxLDM4NToxLDk2OjEsMTM3OjF9LGJSLHp6ZSksbC5wYXJzZV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihuKXRyeXtmb3IoXz1lZihuLCI7LDsiKSxzPV8sdT0wLGM9cy5sZW5ndGg7dTxjOysrdSl7aWYoaT1zW3VdLHQ9ZWYoaSwiXFw6Iiksbz1WWih2dygpLHRbMF0pLCFvKXRocm93IGIobmV3IEdlKCJJbnZhbGlkIG9wdGlvbiBpZDogIit0WzBdKSk7aWYoZD1ZWihvLHRbMV0pLGQ9PW51bGwpdGhyb3cgYihuZXcgR2UoIkludmFsaWQgb3B0aW9uIHZhbHVlOiAiK3RbMV0pKTtkPT1udWxsPyghdGhpcy5wcm9wZXJ0eU1hcCYmKHRoaXMucHJvcGVydHlNYXA9bmV3IHNuKSxoaCh0aGlzLnByb3BlcnR5TWFwLG8pKTooIXRoaXMucHJvcGVydHlNYXAmJih0aGlzLnByb3BlcnR5TWFwPW5ldyBzbiksQm4odGhpcy5wcm9wZXJ0eU1hcCxvLGQpKX19Y2F0Y2goZil7dGhyb3cgZj13cihmKSxMKGYsMTAzKT8ocj1mLGIobmV3IHRjZShyKSkpOmIoZil9fSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj14bihUbyhwbygodGhpcy5wcm9wZXJ0eU1hcD90aGlzLnByb3BlcnR5TWFwOihOZSgpLE5lKCksa3UpKS5lbnRyeVNldF8wKCkuc3RyZWFtKCksbmV3IEJ6ZSksbGYobmV3IEwxZSxuZXcgQTFlLG5ldyBJMWUsbmV3IHgxZSxQKEkob28sMSksVywxMDgsMCxbXSkpKSksbn07dmFyICR6ZT1nKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiSW5kaXZpZHVhbFNwYWNpbmdzIiwzODUpO2Z1bmN0aW9uIEJ6ZSgpe31wKDk4MiwxLHt9LEJ6ZSksbC5hcHBseV8wPWZ1bmN0aW9uKG4pe3JldHVybiBldm4oYShuLDQ0KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJJbmRpdmlkdWFsU3BhY2luZ3MvbGFtYmRhJDAkVHlwZSIsOTgyKTtmdW5jdGlvbiBZVChlKXtyZXR1cm4gZS5pbnN0YW5jZXMuc2l6ZV8wPT0wP2UuZmFjdG9yeS5jcmVhdGVfMCgpOm9rKGUuaW5zdGFuY2VzKX1mdW5jdGlvbiBHemUoZSxuKXtlLmxpbWl0PDB8fGUuaW5zdGFuY2VzLnNpemVfMDxlLmxpbWl0P010KGUuaW5zdGFuY2VzLG4pOmUuZmFjdG9yeS5kZXN0cm95KG4pfWZ1bmN0aW9uIEh6ZShlKXt0aGlzLmluc3RhbmNlcz1uZXcgcHIsdGhpcy5mYWN0b3J5PWUsdGhpcy5saW1pdD0tMX1wKDcxOCwxLHt9LEh6ZSksbC5saW1pdD0wLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJJbnN0YW5jZVBvb2wiLDcxOCk7ZnVuY3Rpb24gVXplKCl7fXAoMTgzNSwxLHt9LFV6ZSksZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIkxvZ2dlZEdyYXBoIiwxODM1KTtmdW5jdGlvbiBUQSgpe1RBPUYsSVI9bmV3IGJBKCJFTEsiLDApLE1lZT1uZXcgYkEoIkpTT04iLDEpLE9lZT1uZXcgYkEoIkRPVCIsMiksUmVlPW5ldyBiQSgiU1ZHIiwzKX1mdW5jdGlvbiBiQShlLG4pe21uLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIG52bihlKXtyZXR1cm4gVEEoKSx3bigoanplKCksVnplKSxlKX1mdW5jdGlvbiBydm4oKXtyZXR1cm4gVEEoKSxQKEkoV3plLDEpLFcsNDE1LDAsW0lSLE1lZSxPZWUsUmVlXSl9cCg0MTUsMjIsezM6MSwzNDoxLDIyOjEsNDE1OjF9LGJBKTt2YXIgT2VlLElSLE1lZSxSZWUsV3plPWNuKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsIiwiTG9nZ2VkR3JhcGgvVHlwZSIsNDE1LGduLHJ2bixudm4pO2Z1bmN0aW9uIGp6ZSgpe2p6ZT1GLFZ6ZT15bigoVEEoKSxQKEkoV3plLDEpLFcsNDE1LDAsW0lSLE1lZSxPZWUsUmVlXSkpKX12YXIgVnplO2Z1bmN0aW9uIHF6ZSgpe31wKDEwNjMsMSx7ODcxOjF9LHF6ZSksbC5iZWdpbj1mdW5jdGlvbihuLHIpe3JldHVybiExfSxsLmRvbmVfMT1mdW5jdGlvbigpe30sbC5nZXRFeGVjdXRpb25UaW1lPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwuZ2V0TG9ncz1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldFN1Yk1vbml0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZ2V0VGFza05hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbC5pc0NhbmNlbGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNMb2dnaW5nRW5hYmxlZD1mdW5jdGlvbigpe3JldHVybiExfSxsLmlzUnVubmluZz1mdW5jdGlvbigpe3JldHVybiExfSxsLmxvZ18wPWZ1bmN0aW9uKG4pe30sbC5sb2dHcmFwaD1mdW5jdGlvbihuLHIpe30sbC5zdWJUYXNrPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzfSxsLndvcmtlZD1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJOdWxsRWxrUHJvZ3Jlc3NNb25pdG9yIiwxMDYzKTtmdW5jdGlvbiB4UihlLG4pe2UuZmlyc3Q9bn1mdW5jdGlvbiBQUihlLG4pe2Uuc2Vjb25kPW59ZnVuY3Rpb24gWnIoZSxuKXt0aGlzLmZpcnN0PWUsdGhpcy5zZWNvbmQ9bn1wKDQyLDEsezIwOjEsNDI6MX0sWnIpLGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe0V0KHRoaXMsbil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvO3JldHVybiBMKG4sNDIpPyh0PWEobiw0Mikscj10aGlzLmZpcnN0PT1udWxsP3QuZmlyc3Q9PW51bGw6WW4odGhpcy5maXJzdCx0LmZpcnN0KSxvPXRoaXMuc2Vjb25kPT1udWxsP3Quc2Vjb25kPT1udWxsOlluKHRoaXMuc2Vjb25kLHQuc2Vjb25kKSxyJiZvKTohMX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saSxzO3JldHVybiB0PXRoaXMuZmlyc3Q9PW51bGw/MDp1cih0aGlzLmZpcnN0KSxuPXQmenIscj10Ji02NTUzNixzPXRoaXMuc2Vjb25kPT1udWxsPzA6dXIodGhpcy5zZWNvbmQpLG89cyZ6cixpPXMmLTY1NTM2LG5eaT4+MTYmenJ8cl5vPDwxNn0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBZemUodGhpcyl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZpcnN0PT1udWxsJiZ0aGlzLnNlY29uZD09bnVsbD8icGFpcihudWxsLG51bGwpIjp0aGlzLmZpcnN0PT1udWxsPyJwYWlyKG51bGwsIit2byh0aGlzLnNlY29uZCkrIikiOnRoaXMuc2Vjb25kPT1udWxsPyJwYWlyKCIrdm8odGhpcy5maXJzdCkrIixudWxsKSI6InBhaXIoIit2byh0aGlzLmZpcnN0KSsiLCIrdm8odGhpcy5zZWNvbmQpKyIpIn0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIlBhaXIiLDQyKTtmdW5jdGlvbiBZemUoZSl7dGhpcy50aGlzJDAxPWV9cCg5OTUsMSxzdCxZemUpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiF0aGlzLnZpc2l0ZWRTZWNvbmQmJighdGhpcy52aXNpdGVkRmlyc3QmJnRoaXMudGhpcyQwMS5maXJzdCE9bnVsbHx8dGhpcy50aGlzJDAxLnNlY29uZCE9bnVsbCl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7aWYoIXRoaXMudmlzaXRlZFNlY29uZCYmIXRoaXMudmlzaXRlZEZpcnN0JiZ0aGlzLnRoaXMkMDEuZmlyc3QhPW51bGwpcmV0dXJuIHRoaXMudmlzaXRlZEZpcnN0PSEwLHRoaXMudGhpcyQwMS5maXJzdDtpZighdGhpcy52aXNpdGVkU2Vjb25kJiZ0aGlzLnRoaXMkMDEuc2Vjb25kIT1udWxsKXJldHVybiB0aGlzLnZpc2l0ZWRTZWNvbmQ9ITAsdGhpcy50aGlzJDAxLnNlY29uZDt0aHJvdyBiKG5ldyBQbyl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgdGhpcy52aXNpdGVkU2Vjb25kJiZ0aGlzLnRoaXMkMDEuc2Vjb25kIT1udWxsP3RoaXMudGhpcyQwMS5zZWNvbmQ9bnVsbDp0aGlzLnZpc2l0ZWRGaXJzdCYmdGhpcy50aGlzJDAxLmZpcnN0IT1udWxsJiYodGhpcy50aGlzJDAxLmZpcnN0PW51bGwpLGIobmV3IHppKX0sbC52aXNpdGVkRmlyc3Q9ITEsbC52aXNpdGVkU2Vjb25kPSExLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJQYWlyLzEiLDk5NSk7ZnVuY3Rpb24gS3plKGUsbixyLHQpe3RoaXMuZmlyc3Q9ZSx0aGlzLnNlY29uZD1uLHRoaXMudGhpcmQ9cix0aGlzLmZvdXJ0aD10fXAoNDU1LDEsezQ1NToxfSxLemUpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIFVvKHRoaXMuZmlyc3QsYShuLDQ1NSkuZmlyc3QpJiZVbyh0aGlzLnNlY29uZCxhKG4sNDU1KS5zZWNvbmQpJiZVbyh0aGlzLnRoaXJkLGEobiw0NTUpLnRoaXJkKSYmVW8odGhpcy5mb3VydGgsYShuLDQ1NSkuZm91cnRoKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIGtDKFAoSShRciwxKSxNZSwxLDUsW3RoaXMuZmlyc3QsdGhpcy5zZWNvbmQsdGhpcy50aGlyZCx0aGlzLmZvdXJ0aF0pKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIigiK3RoaXMuZmlyc3QrIiwgIit0aGlzLnNlY29uZCsiLCAiK3RoaXMudGhpcmQrIiwgIit0aGlzLmZvdXJ0aCsiKSJ9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJRdWFkcnVwbGUiLDQ1NSk7ZnVuY3Rpb24gdHZuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyLGNhLGNvLFdhLEpnLHAwLHRzLG9zO2lmKGs9YShPKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcyksMCksODQpLEg9ay5nZXRYKCkscT1rLmdldFkoKSxNPWsuZ2V0V2lkdGgoKS8yLEU9ay5nZXRIZWlnaHQoKS8yLEwoaywxOTMpJiYoQT1hKGssMTIzKSxIKz1qcyhBKS54XzAsSCs9anMoQSkueF8wKSxIKz1NLHErPUUsRmU9YShPKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcyksMCksODQpLGpuPUZlLmdldFgoKSxTcj1GZS5nZXRZKCksbm49RmUuZ2V0V2lkdGgoKS8yLG5lPUZlLmdldEhlaWdodCgpLzIsTChGZSwxOTMpJiYoRGU9YShGZSwxMjMpLGpuKz1qcyhEZSkueF8wLGpuKz1qcyhEZSkueF8wKSxqbis9bm4sU3IrPW5lLCghZS5zZWN0aW9ucyYmKGUuc2VjdGlvbnM9bmV3IFUoZ3IsZSw2LDYpKSxlLnNlY3Rpb25zKS5zaXplXzA9PTApdT0oWDAoKSxfPW5ldyB6QSxfKSxwbigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucyksdSk7ZWxzZSBpZigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykuc2l6ZV8wPjEpZm9yKHk9bmV3IFNtKCghZS5zZWN0aW9ucyYmKGUuc2VjdGlvbnM9bmV3IFUoZ3IsZSw2LDYpKSxlLnNlY3Rpb25zKSk7eS5jdXJzb3IhPXkudGhpcyQwMV8yLnNpemVfMSgpOyl5Uyh5KTtmb3Iocz1hKE8oKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLDApLDE2Niksdj1qbixqbj5IK00/dj1IK006am48SC1NJiYodj1ILU0pLHg9U3IsU3I+cStFP3g9cStFOlNyPHEtRSYmKHg9cS1FKSx2PkgtTSYmdjxIK00mJng+cS1FJiZ4PHErRSYmKHY9SCtNKSxGdyhzLHYpLHp3KHMseCksdmU9SCxIPmpuK25uP3ZlPWpuK25uOkg8am4tbm4mJih2ZT1qbi1ubiksd2U9cSxxPlNyK25lP3dlPVNyK25lOnE8U3ItbmUmJih3ZT1Tci1uZSksdmU+am4tbm4mJnZlPGpuK25uJiZ3ZT5Tci1uZSYmd2U8U3IrbmUmJih3ZT1TcituZSksUncocyx2ZSksRHcocyx3ZSksZm4oKCFzLmJlbmRQb2ludHMmJihzLmJlbmRQb2ludHM9bmV3IGpyKEJhLHMsNSkpLHMuYmVuZFBvaW50cykpLGk9aXgobiw1KSxrPT1GZSYmKytpLFdhPXZlLXYsdHM9d2UteCxjYT1TLk1hdGguc3FydChXYSpXYSt0cyp0cyksZj1jYSouMjAwMDAwMDAyOTgwMjMyMjQsSmc9V2EvKGkrMSksb3M9dHMvKGkrMSksY289dixwMD14LGQ9MDtkPGk7ZCsrKWNvKz1KZyxwMCs9b3MsaD1jbytmYShuLDI0KSpKUypmLWYvMixoPDA/aD0xOmg+ciYmKGg9ci0xKSxtPXAwK2ZhKG4sMjQpKkpTKmYtZi8yLG08MD9tPTE6bT50JiYobT10LTEpLG89KFgwKCksYz1uZXcgT0EsYyksTEEobyxoKSxrQShvLG0pLHBuKCghcy5iZW5kUG9pbnRzJiYocy5iZW5kUG9pbnRzPW5ldyBqcihCYSxzLDUpKSxzLmJlbmRQb2ludHMpLG8pfWZ1bmN0aW9uIG92bihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZTtmb3Ioaz0wLHk9MCxtPTAsaD0xLEE9bmV3IFllKCghZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4pKTtBLmN1cnNvciE9QS50aGlzJDAxXzIuc2l6ZV8xKCk7KXY9YShlbihBKSwyNyksaCs9WnUobmV3IFhlKFFlKEVjKHYpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKSksdmU9di53aWR0aF8wLHk9Uy5NYXRoLm1heCh5LHZlKSxmPXYuaGVpZ2h0LG09Uy5NYXRoLm1heChtLGYpLGsrPXZlKmY7Zm9yKEU9KCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikuc2l6ZV8wLHM9aysyKnQqdCpoKkUsaT1TLk1hdGguc3FydChzKSxjPVMuTWF0aC5tYXgoaSpyLHkpLHU9Uy5NYXRoLm1heChpL3IsbSkseD1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO3guY3Vyc29yIT14LnRoaXMkMDFfMi5zaXplXzEoKTspdj1hKGVuKHgpLDI3KSx3ZT1vLmxlZnQrKGZhKG4sMjYpKncyK2ZhKG4sMjcpKkUyKSooYy12LndpZHRoXzApLERlPW8ubGVmdCsoZmEobiwyNikqdzIrZmEobiwyNykqRTIpKih1LXYuaGVpZ2h0KSxDaSh2LHdlKSxUaSh2LERlKTtmb3IobmU9Yysoby5sZWZ0K28ucmlnaHQpLHE9dSsoby50b3BfMCtvLmJvdHRvbSksSD1uZXcgWWUoKCFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbikpO0guY3Vyc29yIT1ILnRoaXMkMDFfMi5zaXplXzEoKTspZm9yKE09YShlbihIKSwyNyksZD1uZXcgWGUoUWUoRWMoTSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKGQpOylfPWEodG4oZCksNzQpLGxTKF8pfHx0dm4oXyxuLG5lLHEpO25lKz1vLmxlZnQrby5yaWdodCxxKz1vLnRvcF8wK28uYm90dG9tLHdkKGUsbmUscSwhMSwhMCl9ZnVuY3Rpb24gWHplKCl7fXAoMTEwOCwyMDUsZ18sWHplKSxsLmxheW91dD1mdW5jdGlvbihuLHIpe3ZhciB0LG8saSxzLHU7aWYoci5iZWdpbigiUmFuZG9tIExheW91dCIsMSksKCFuLmNoaWxkcmVuJiYobi5jaGlsZHJlbj1uZXcgVShVbixuLDEwLDExKSksbi5jaGlsZHJlbikuc2l6ZV8wPT0wKXtyLmRvbmVfMSgpO3JldHVybn1zPWEoVihuLChkZWUoKSwkRmUpKSwxNykscyYmcy52YWx1ZV8wIT0wP2k9bmV3IGF4KHMudmFsdWVfMCk6aT1uZXcgcGssdD1TQygkKFYobixGRmUpKSksdT1TQygkKFYobixCRmUpKSksbz1hKFYobix6RmUpLDEwNyksb3ZuKG4saSx0LHUsbyksci5kb25lXzEoKX0sZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbCIsIlJhbmRvbUxheW91dFByb3ZpZGVyIiwxMTA4KTtmdW5jdGlvbiBOUihlLG4scil7dGhpcy5maXJzdD1lLHRoaXMuc2Vjb25kPW4sdGhpcy50aGlyZD1yfXAoMjQwLDEsezI0MDoxfSxOUiksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gVW8odGhpcy5maXJzdCxhKG4sMjQwKS5maXJzdCkmJlVvKHRoaXMuc2Vjb25kLGEobiwyNDApLnNlY29uZCkmJlVvKHRoaXMudGhpcmQsYShuLDI0MCkudGhpcmQpfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4ga0MoUChJKFFyLDEpLE1lLDEsNSxbdGhpcy5maXJzdCx0aGlzLnNlY29uZCx0aGlzLnRoaXJkXSkpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4iKCIrdGhpcy5maXJzdCsiLCAiK3RoaXMuc2Vjb25kKyIsICIrdGhpcy50aGlyZCsiKSJ9LGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwiLCJUcmlwbGUiLDI0MCk7ZnVuY3Rpb24gRWQoKXtFZD1GLEp6ZT1uZXcgbiRlfXZhciBKemU7ZnVuY3Rpb24gQVIoKXtBUj1GLFp6ZT1uZXcgeXQoKEZuKCkscGEpLDApfXAoNTYyLDEse30pLGwuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFkodGhpcy5lbGVtZW50LnhfMCx0aGlzLmVsZW1lbnQueV8wKX0sbC5nZXRQcm9wZXJ0eT1mdW5jdGlvbihuKXtyZXR1cm4gJEJlKG4sKEZuKCkscGEpKT9WKHRoaXMuZWxlbWVudCxaemUpOlYodGhpcy5lbGVtZW50LG4pfSxsLmdldFNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFkodGhpcy5lbGVtZW50LndpZHRoXzAsdGhpcy5lbGVtZW50LmhlaWdodCl9LGwuZ2V0Vm9sYXRpbGVJZD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlkXzB9LGwuaGFzUHJvcGVydHk9ZnVuY3Rpb24obil7cmV0dXJuIFdzKHRoaXMuZWxlbWVudCxuKX0sbC5zZXRQb3NpdGlvbj1mdW5jdGlvbihuKXtDaSh0aGlzLmVsZW1lbnQsbi54XzApLFRpKHRoaXMuZWxlbWVudCxuLnlfMCl9LGwuc2V0U2l6ZT1mdW5jdGlvbihuKXtUZCh0aGlzLmVsZW1lbnQsbi54XzApLENkKHRoaXMuZWxlbWVudCxuLnlfMCl9LGwuc2V0Vm9sYXRpbGVJZD1mdW5jdGlvbihuKXt0aGlzLmlkXzA9bn0sbC5pZF8wPTA7dmFyIFp6ZTtnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsLmFkYXB0ZXJzIiwiRWxrR3JhcGhBZGFwdGVycy9BYnN0cmFjdEVsa0dyYXBoRWxlbWVudEFkYXB0ZXIiLDU2Mik7ZnVuY3Rpb24gSUEoZSl7dGhpcy5lbGVtZW50PWV9cCg1NjMsMSx7ODUzOjF9LElBKSxsLmdldExhYmVscz1mdW5jdGlvbigpe3ZhciBuLHI7aWYoIXRoaXMubGFiZWxBZGFwdGVycylmb3IodGhpcy5sYWJlbEFkYXB0ZXJzPXdJKE1BKHRoaXMuZWxlbWVudCkuc2l6ZV8wKSxyPW5ldyBZZShNQSh0aGlzLmVsZW1lbnQpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSwxMzUpLGVlKHRoaXMubGFiZWxBZGFwdGVycyxuZXcgTFIobikpO3JldHVybiB0aGlzLmxhYmVsQWRhcHRlcnN9LGwubGFiZWxBZGFwdGVycz1udWxsLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwuYWRhcHRlcnMiLCJFbGtHcmFwaEFkYXB0ZXJzL0Vsa0VkZ2VBZGFwdGVyIiw1NjMpO2Z1bmN0aW9uIFF6ZShlKXt2YXIgbixyO2lmKCFlLmNoaWxkTm9kZXMpZm9yKGUuY2hpbGROb2Rlcz13SShVQShhKGUuZWxlbWVudCwyNykpLnNpemVfMCkscj1uZXcgWWUoVUEoYShlLmVsZW1lbnQsMjcpKSk7ci5jdXJzb3IhPXIudGhpcyQwMV8yLnNpemVfMSgpOyluPWEoZW4ociksMjcpLGVlKGUuY2hpbGROb2RlcyxuZXcga1IoZSxuKSk7cmV0dXJuIGUuY2hpbGROb2Rlc31mdW5jdGlvbiB2ZChlKXtBUigpLHRoaXMuZWxlbWVudD1lfXAoMjg5LDU2Mix7fSx2ZCksbC5nZXROb2Rlcz1mdW5jdGlvbigpe3JldHVybiBRemUodGhpcyl9LGwuY2hpbGROb2Rlcz1udWxsLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwuYWRhcHRlcnMiLCJFbGtHcmFwaEFkYXB0ZXJzL0Vsa0dyYXBoQWRhcHRlciIsMjg5KTtmdW5jdGlvbiBMUihlKXtBUigpLHRoaXMuZWxlbWVudD1lfXAoNjQwLDU2Mix7MTg3OjF9LExSKSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsLmFkYXB0ZXJzIiwiRWxrR3JhcGhBZGFwdGVycy9FbGtMYWJlbEFkYXB0ZXIiLDY0MCk7ZnVuY3Rpb24gaXZuKGUpe3ZhciBuLHI7aWYoIWUubGFiZWxBZGFwdGVycylmb3IoZS5sYWJlbEFkYXB0ZXJzPXdJKGEoZS5lbGVtZW50LDI3KS5nZXRMYWJlbHNfMCgpLnNpemVfMCkscj1uZXcgWWUoYShlLmVsZW1lbnQsMjcpLmdldExhYmVsc18wKCkpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDEzNSksZWUoZS5sYWJlbEFkYXB0ZXJzLG5ldyBMUihuKSk7cmV0dXJuIGUubGFiZWxBZGFwdGVyc31mdW5jdGlvbiBhdm4oZSl7dmFyIG4scjtpZighZS5wb3J0QWRhcHRlcnMpZm9yKGUucG9ydEFkYXB0ZXJzPXdJKHJEKGEoZS5lbGVtZW50LDI3KSkuc2l6ZV8wKSxyPW5ldyBZZShyRChhKGUuZWxlbWVudCwyNykpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSwxMjMpLGVlKGUucG9ydEFkYXB0ZXJzLG5ldyBlJGUobikpO3JldHVybiBlLnBvcnRBZGFwdGVyc31mdW5jdGlvbiBsdm4oZSxuKXtfbShhKGEoZS5lbGVtZW50LDI3KS5nZXRQcm9wZXJ0eSgoRm4oKSxqdikpLDEwMSkpJiZOQ24ockQoYShlLmVsZW1lbnQsMjcpKSxuKX1mdW5jdGlvbiBrUihlLG4pe0FSKCksdGhpcy5lbGVtZW50PW4sdGhpcy5wYXJlbnRHcmFwaEFkYXB0ZXI9ZX1wKDYzOSw1NjIsezY5NToxfSxrUiksbC5nZXRMYWJlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gaXZuKHRoaXMpfSxsLmdldE1hcmdpbj1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPWEoVih0aGlzLmVsZW1lbnQsKEZuKCksYncpKSwxNDApLCFuJiYobj1uZXcgdkUpLG59LGwuZ2V0UG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4gYXZuKHRoaXMpfSxsLnNldE1hcmdpbj1mdW5jdGlvbihuKXt2YXIgcjtyPW5ldyB0OShuKSxucih0aGlzLmVsZW1lbnQsKEZuKCksYncpLHIpfSxsLnNldFBhZGRpbmc9ZnVuY3Rpb24obil7bnIodGhpcy5lbGVtZW50LChGbigpLFpjKSxuZXcgR1cobikpfSxsLmdldEdyYXBoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50R3JhcGhBZGFwdGVyfSxsLmdldEluY29taW5nRWRnZXM9ZnVuY3Rpb24oKXt2YXIgbixyO2lmKCF0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzKWZvcih0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzPW5ldyBRLHI9bmV3IFhlKFFlKG9iKGEodGhpcy5lbGVtZW50LDI3KSkudmFsJGlucHV0czEuaXRlcmF0b3JfMCgpLG5ldyBaZSkpO19uKHIpOyluPWEodG4ociksNzQpLGVlKHRoaXMuaW5jb21pbmdFZGdlQWRhcHRlcnMsbmV3IElBKG4pKTtyZXR1cm4gdGhpcy5pbmNvbWluZ0VkZ2VBZGFwdGVyc30sbC5nZXRPdXRnb2luZ0VkZ2VzPWZ1bmN0aW9uKCl7dmFyIG4scjtpZighdGhpcy5vdXRnb2luZ0VkZ2VBZGFwdGVycylmb3IodGhpcy5vdXRnb2luZ0VkZ2VBZGFwdGVycz1uZXcgUSxyPW5ldyBYZShRZShFYyhhKHRoaXMuZWxlbWVudCwyNykpLnZhbCRpbnB1dHMxLml0ZXJhdG9yXzAoKSxuZXcgWmUpKTtfbihyKTspbj1hKHRuKHIpLDc0KSxlZSh0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzLG5ldyBJQShuKSk7cmV0dXJuIHRoaXMub3V0Z29pbmdFZGdlQWRhcHRlcnN9LGwuaXNDb21wb3VuZE5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gVUEoYSh0aGlzLmVsZW1lbnQsMjcpKS5zaXplXzAhPTB8fGFlKGllKGEodGhpcy5lbGVtZW50LDI3KS5nZXRQcm9wZXJ0eSgoRm4oKSxQVCkpKSl9LGwuc29ydFBvcnRMaXN0PWZ1bmN0aW9uKCl7bHZuKHRoaXMsKEVkKCksSnplKSl9LGwuaW5jb21pbmdFZGdlQWRhcHRlcnM9bnVsbCxsLmxhYmVsQWRhcHRlcnM9bnVsbCxsLm91dGdvaW5nRWRnZUFkYXB0ZXJzPW51bGwsbC5wYXJlbnRHcmFwaEFkYXB0ZXI9bnVsbCxsLnBvcnRBZGFwdGVycz1udWxsLGcoIm9yZy5lY2xpcHNlLmVsay5jb3JlLnV0aWwuYWRhcHRlcnMiLCJFbGtHcmFwaEFkYXB0ZXJzL0Vsa05vZGVBZGFwdGVyIiw2MzkpO2Z1bmN0aW9uIHN2bihlKXt2YXIgbixyO2lmKCFlLmxhYmVsQWRhcHRlcnMpZm9yKGUubGFiZWxBZGFwdGVycz13SShhKGUuZWxlbWVudCwxMjMpLmdldExhYmVsc18wKCkuc2l6ZV8wKSxyPW5ldyBZZShhKGUuZWxlbWVudCwxMjMpLmdldExhYmVsc18wKCkpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDEzNSksZWUoZS5sYWJlbEFkYXB0ZXJzLG5ldyBMUihuKSk7cmV0dXJuIGUubGFiZWxBZGFwdGVyc31mdW5jdGlvbiBlJGUoZSl7dGhpcy5lbGVtZW50PWV9cCgxMjg0LDU2Mix7ODUyOjF9LGUkZSksbC5nZXRMYWJlbHM9ZnVuY3Rpb24oKXtyZXR1cm4gc3ZuKHRoaXMpfSxsLmdldEluY29taW5nRWRnZXM9ZnVuY3Rpb24oKXt2YXIgbixyO2lmKCF0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzKWZvcih0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzPU51KGEodGhpcy5lbGVtZW50LDEyMykuZ2V0SW5jb21pbmdFZGdlc18wKCkuc2l6ZV8wKSxyPW5ldyBZZShhKHRoaXMuZWxlbWVudCwxMjMpLmdldEluY29taW5nRWRnZXNfMCgpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSw3NCksZWUodGhpcy5pbmNvbWluZ0VkZ2VBZGFwdGVycyxuZXcgSUEobikpO3JldHVybiB0aGlzLmluY29taW5nRWRnZUFkYXB0ZXJzfSxsLmdldE91dGdvaW5nRWRnZXM9ZnVuY3Rpb24oKXt2YXIgbixyO2lmKCF0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzKWZvcih0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzPU51KGEodGhpcy5lbGVtZW50LDEyMykuZ2V0T3V0Z29pbmdFZGdlc18wKCkuc2l6ZV8wKSxyPW5ldyBZZShhKHRoaXMuZWxlbWVudCwxMjMpLmdldE91dGdvaW5nRWRnZXNfMCgpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSw3NCksZWUodGhpcy5vdXRnb2luZ0VkZ2VBZGFwdGVycyxuZXcgSUEobikpO3JldHVybiB0aGlzLm91dGdvaW5nRWRnZUFkYXB0ZXJzfSxsLmdldFNpZGU9ZnVuY3Rpb24oKXtyZXR1cm4gYShhKHRoaXMuZWxlbWVudCwxMjMpLmdldFByb3BlcnR5KChGbigpLFBnKSksNjQpfSxsLmhhc0NvbXBvdW5kQ29ubmVjdGlvbnM9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihvPWpzKGEodGhpcy5lbGVtZW50LDEyMykpLHQ9bmV3IFllKGEodGhpcy5lbGVtZW50LDEyMykuZ2V0T3V0Z29pbmdFZGdlc18wKCkpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspZm9yKG49YShlbih0KSw3NCksYz1uZXcgWWUoKCFuLnRhcmdldHMmJihuLnRhcmdldHM9bmV3IExlKGFuLG4sNSw4KSksbi50YXJnZXRzKSk7Yy5jdXJzb3IhPWMudGhpcyQwMV8yLnNpemVfMSgpOyl7aWYodT1hKGVuKGMpLDg0KSxYZih5byh1KSxvKSlyZXR1cm4hMDtpZih5byh1KT09byYmYWUoaWUoVihuLChGbigpLGlSKSkpKSlyZXR1cm4hMH1mb3Iocj1uZXcgWWUoYSh0aGlzLmVsZW1lbnQsMTIzKS5nZXRJbmNvbWluZ0VkZ2VzXzAoKSk7ci5jdXJzb3IhPXIudGhpcyQwMV8yLnNpemVfMSgpOylmb3Iobj1hKGVuKHIpLDc0KSxzPW5ldyBZZSgoIW4uc291cmNlcyYmKG4uc291cmNlcz1uZXcgTGUoYW4sbiw0LDcpKSxuLnNvdXJjZXMpKTtzLmN1cnNvciE9cy50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKGk9YShlbihzKSw4NCksWGYoeW8oaSksbykpcmV0dXJuITA7cmV0dXJuITF9LGwuaW5jb21pbmdFZGdlQWRhcHRlcnM9bnVsbCxsLmxhYmVsQWRhcHRlcnM9bnVsbCxsLm91dGdvaW5nRWRnZUFkYXB0ZXJzPW51bGwsZygib3JnLmVjbGlwc2UuZWxrLmNvcmUudXRpbC5hZGFwdGVycyIsIkVsa0dyYXBoQWRhcHRlcnMvRWxrUG9ydEFkYXB0ZXIiLDEyODQpO2Z1bmN0aW9uIHV2bihlLG4pe3ZhciByLHQsbyxpO2lmKGk9YShWKGUsKEZuKCksUGcpKSw2NCkub3JkaW5hbC1hKFYobixQZyksNjQpLm9yZGluYWwsaSE9MClyZXR1cm4gaTtpZihyPWEoVihlLF9SKSwxNyksdD1hKFYobixfUiksMTcpLHImJnQmJihvPXIudmFsdWVfMC10LnZhbHVlXzAsbyE9MCkpcmV0dXJuIG87c3dpdGNoKGEoVihlLFBnKSw2NCkub3JkaW5hbCl7Y2FzZSAxOnJldHVybiBpcihlLnhfMCxuLnhfMCk7Y2FzZSAyOnJldHVybiBpcihlLnlfMCxuLnlfMCk7Y2FzZSAzOnJldHVybiBpcihuLnhfMCxlLnhfMCk7Y2FzZSA0OnJldHVybiBpcihuLnlfMCxlLnlfMCk7ZGVmYXVsdDp0aHJvdyBiKG5ldyBybygiUG9ydCBzaWRlIGlzIHVuZGVmaW5lZCIpKX19ZnVuY3Rpb24gbiRlKCl7fXAoMTI4NSwxLE5uLG4kZSksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gdXZuKGEobiwxMjMpLGEociwxMjMpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuY29yZS51dGlsLmFkYXB0ZXJzIiwiRWxrR3JhcGhBZGFwdGVycy9Qb3J0Q29tcGFyYXRvciIsMTI4NSk7dmFyIEswPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFT2JqZWN0Iiksa3c9Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaCIsIkVNYXBQcm9wZXJ0eUhvbGRlciIpLEJhPUNyKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgiLCJFbGtCZW5kUG9pbnQiKSxLVD1Dcigib3JnLmVjbGlwc2UuZWxrLmdyYXBoIiwiRWxrR3JhcGhFbGVtZW50IiksWFQ9Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaCIsIkVsa1NoYXBlIiksYW49Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaCIsIkVsa0Nvbm5lY3RhYmxlU2hhcGUiKSxNcj1Dcigib3JnLmVjbGlwc2UuZWxrLmdyYXBoIiwiRWxrRWRnZSIpLGdyPUNyKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgiLCJFbGtFZGdlU2VjdGlvbiIpLEpUPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFTW9kZWxFbGVtZW50IiksYVM9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVGYWN0b3J5Iik7ZnVuY3Rpb24gWDAoKXtYMD1GLHIkZT1Fdm4oKX12YXIgciRlLE9SPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFTmFtZWRFbGVtZW50IikseXM9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVQYWNrYWdlIik7ZnVuY3Rpb24gdCRlKCl7dCRlPUYsYXQ9YnZuKCl9dmFyIGF0O2Z1bmN0aW9uIEtvKCl7S289Rix0JGUoKSxzJGU9YXQuZU1hcFByb3BlcnR5SG9sZGVyRUNsYXNzLGEoTyhHKGF0LmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcyksMCksMTkpLGEkZT1hdC5lbGtHcmFwaEVsZW1lbnRFQ2xhc3MsYShPKEcoYXQuZWxrR3JhcGhFbGVtZW50RUNsYXNzKSwwKSwxOSksYShPKEcoYXQuZWxrR3JhcGhFbGVtZW50RUNsYXNzKSwxKSwzNSksbCRlPWF0LmVsa1NoYXBlRUNsYXNzLGEoTyhHKGF0LmVsa1NoYXBlRUNsYXNzKSwwKSwzNSksYShPKEcoYXQuZWxrU2hhcGVFQ2xhc3MpLDEpLDM1KSxhKE8oRyhhdC5lbGtTaGFwZUVDbGFzcyksMiksMzUpLGEoTyhHKGF0LmVsa1NoYXBlRUNsYXNzKSwzKSwzNSksRmVlPWF0LmVsa0xhYmVsRUNsYXNzLGEoTyhHKGF0LmVsa0xhYmVsRUNsYXNzKSwwKSwxOSksYShPKEcoYXQuZWxrTGFiZWxFQ2xhc3MpLDEpLDM1KSxpJGU9YXQuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyxhKE8oRyhhdC5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzKSwwKSwxOSksYShPKEcoYXQuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyksMSksMTkpLHplZT1hdC5lbGtOb2RlRUNsYXNzLGEoTyhHKGF0LmVsa05vZGVFQ2xhc3MpLDApLDE5KSxhKE8oRyhhdC5lbGtOb2RlRUNsYXNzKSwxKSwxOSksYShPKEcoYXQuZWxrTm9kZUVDbGFzcyksMiksMTkpLGEoTyhHKGF0LmVsa05vZGVFQ2xhc3MpLDMpLDE5KSxhKE8oRyhhdC5lbGtOb2RlRUNsYXNzKSw0KSwzNSksJGVlPWF0LmVsa1BvcnRFQ2xhc3MsYShPKEcoYXQuZWxrUG9ydEVDbGFzcyksMCksMTkpLERlZT1hdC5lbGtFZGdlRUNsYXNzLGEoTyhHKGF0LmVsa0VkZ2VFQ2xhc3MpLDApLDE5KSxhKE8oRyhhdC5lbGtFZGdlRUNsYXNzKSwxKSwxOSksYShPKEcoYXQuZWxrRWRnZUVDbGFzcyksMiksMTkpLGEoTyhHKGF0LmVsa0VkZ2VFQ2xhc3MpLDMpLDE5KSxhKE8oRyhhdC5lbGtFZGdlRUNsYXNzKSw0KSwzNSksYShPKEcoYXQuZWxrRWRnZUVDbGFzcyksNSksMzUpLGEoTyhHKGF0LmVsa0VkZ2VFQ2xhc3MpLDYpLDM1KSxhKE8oRyhhdC5lbGtFZGdlRUNsYXNzKSw3KSwzNSksbyRlPWF0LmVsa0JlbmRQb2ludEVDbGFzcyxhKE8oRyhhdC5lbGtCZW5kUG9pbnRFQ2xhc3MpLDApLDM1KSxhKE8oRyhhdC5lbGtCZW5kUG9pbnRFQ2xhc3MpLDEpLDM1KSx4QT1hdC5lbGtFZGdlU2VjdGlvbkVDbGFzcyxhKE8oRyhhdC5lbGtFZGdlU2VjdGlvbkVDbGFzcyksMCksMzUpLGEoTyhHKGF0LmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSwxKSwzNSksYShPKEcoYXQuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDIpLDM1KSxhKE8oRyhhdC5lbGtFZGdlU2VjdGlvbkVDbGFzcyksMyksMzUpLGEoTyhHKGF0LmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw0KSwxOSksYShPKEcoYXQuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDUpLDE5KSxhKE8oRyhhdC5lbGtFZGdlU2VjdGlvbkVDbGFzcyksNiksMTkpLGEoTyhHKGF0LmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw3KSwxOSksYShPKEcoYXQuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDgpLDE5KSxhKE8oRyhhdC5lbGtFZGdlU2VjdGlvbkVDbGFzcyksOSksMTkpLGEoTyhHKGF0LmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSwxMCksMzUpLFV1PWF0LmVsa1Byb3BlcnR5VG9WYWx1ZU1hcEVudHJ5RUNsYXNzLGEoTyhHKGF0LmVsa1Byb3BlcnR5VG9WYWx1ZU1hcEVudHJ5RUNsYXNzKSwwKSwzNSksYShPKEcoYXQuZWxrUHJvcGVydHlUb1ZhbHVlTWFwRW50cnlFQ2xhc3MpLDEpLDM1KX12YXIgbyRlLGkkZSxEZWUseEEsYSRlLEZlZSx6ZWUsJGVlLFV1LGwkZSxzJGUsUXQ9Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaCIsIkVsa0xhYmVsIiksVW49Q3IoIm9yZy5lY2xpcHNlLmVsay5ncmFwaCIsIkVsa05vZGUiKSx1YT1Dcigib3JnLmVjbGlwc2UuZWxrLmdyYXBoIiwiRWxrUG9ydCIpO2Z1bmN0aW9uIFhuKGUsbil7dmFyIHIsdCxvO2lmKHI9ZS5lQmFzaWNBZGFwdGVyQXJyYXkoKSxyIT1udWxsJiZlLmVEZWxpdmVyKCkpZm9yKHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpclt0XS5ub3RpZnlDaGFuZ2VkKG4pfXAoOTMsMSxJaWUpLGwuZUJhc2ljQWRhcHRlckFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZUJhc2ljQWRhcHRlcnMoKSxudWxsfSxsLmVCYXNpY0FkYXB0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZUJhc2ljSGFzQWRhcHRlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQmFzaWNBZGFwdGVycygpLCExfSxsLmVEZWxpdmVyPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuZU5vdGlmeT1mdW5jdGlvbihuKXtYbih0aGlzLG4pfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLm5vdGlmeS5pbXBsIiwiQmFzaWNOb3RpZmllckltcGwiLDkzKTtmdW5jdGlvbiBjdm4oZSxuKXt2YXIgcjtpZihyPW1iKGUsbiksTChyLDMzMSkpcmV0dXJuIGEociwzNSk7dGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlICciK24rIicgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIikpfWZ1bmN0aW9uIEdhKGUsbixyLHQpe3ZhciBvLGkscyx1LGM7cmV0dXJuIHM9ZS5lSW50ZXJuYWxDb250YWluZXIoKSxjPWUuZURpcmVjdFJlc291cmNlKCksbz1udWxsLGM/biYmIShHUihlLG4scikuZUZsYWdzJkZ0KT8odD1EdChjLmdldENvbnRlbnRzKCksZSx0KSxlLmVTZXREaXJlY3RSZXNvdXJjZShudWxsKSxvPW4uZUludGVybmFsUmVzb3VyY2UoKSk6Yz1udWxsOihzJiYoYz1zLmVJbnRlcm5hbFJlc291cmNlKCkpLG4mJihvPW4uZUludGVybmFsUmVzb3VyY2UoKSkpLGMhPW8mJmMmJmMuZGV0YWNoZWQoZSksdT1lLmVDb250YWluZXJGZWF0dXJlSURfMCgpLGUuZUJhc2ljU2V0Q29udGFpbmVyKG4sciksYyE9byYmbyYmby5hdHRhY2hlZChlKSxlLmVCYXNpY0hhc0FkYXB0ZXJzKCkmJmUuZURlbGl2ZXIoKSYmKHMmJnU+PTAmJnUhPXImJihpPW5ldyBsdChlLDEsdSxzLG51bGwpLHQ/dC5hZGRfNShpKTp0PWkpLHI+PTAmJihpPW5ldyBsdChlLDEscix1PT1yP3M6bnVsbCxuKSx0P3QuYWRkXzUoaSk6dD1pKSksdH1mdW5jdGlvbiBNUihlKXt2YXIgbixyLHQsbyxpO3JldHVybiBpPWUuZUludGVybmFsQ29udGFpbmVyKCksaSYmaS5lSXNQcm94eSgpJiYobz1KMChlLGkpLG8hPWkpPyhyPWUuZUNvbnRhaW5lckZlYXR1cmVJRF8wKCksdD0obj1lLmVDb250YWluZXJGZWF0dXJlSURfMCgpLG4+PTA/ZS5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZShudWxsKTplLmVJbnRlcm5hbENvbnRhaW5lcigpLmVJbnZlcnNlUmVtb3ZlKGUsLTEtbixudWxsLG51bGwpKSxlLmVCYXNpY1NldENvbnRhaW5lcihhKG8sNTQpLHIpLHQmJnQuZGlzcGF0Y2hfMCgpLGUuZUJhc2ljSGFzQWRhcHRlcnMoKSYmZS5lRGVsaXZlcigpJiZyPi0xJiZYbihlLG5ldyBsdChlLDkscixpLG8pKSxvKTppfWZ1bmN0aW9uIGxsKGUsbixyLHQsbyl7cmV0dXJuIG48MD9TZChlLHIsdCk6YShyLDY5KS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljR2V0XzAoZSxlLmVTZXR0aW5nc18wKCksbix0LG8pfWZ1bmN0aW9uIHNsKGUsbixyKXtyZXR1cm4gbjwwP3pSKGUscik6YShyLDY5KS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSXNTZXQoZSxlLmVTZXR0aW5nc18wKCksbil9ZnVuY3Rpb24gdWwoZSxuLHIsdCl7aWYobjwwKUJlZShlLHIsdCk7ZWxzZXtpZighci5pc0NoYW5nZWFibGUoKSl0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgJyIrci5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2hhbmdlYWJsZSBmZWF0dXJlIikpO2Eociw2OSkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY1NldF8wKGUsZS5lU2V0dGluZ3NfMCgpLG4sdCl9fWZ1bmN0aW9uIGNsKGUsbixyKXtpZihuPDApR2VlKGUscik7ZWxzZXtpZighci5pc0NoYW5nZWFibGUoKSl0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgJyIrci5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2hhbmdlYWJsZSBmZWF0dXJlIikpO2Eociw2OSkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY1Vuc2V0XzAoZSxlLmVTZXR0aW5nc18wKCksbil9fWZ1bmN0aW9uIFBBKGUsbixyLHQpe3ZhciBvLGkscztyZXR1cm4gaT1rZShlLmVDbGFzc18wKCksbiksbz1uLWUuZVN0YXRpY0ZlYXR1cmVDb3VudCgpLG88MD8ocz1lLmVEZXJpdmVkU3RydWN0dXJhbEZlYXR1cmVJRF8wKGkpLHM+PTA/ZS5lR2V0KHMsciwhMCk6U2QoZSxpLHIpKTphKGksNjkpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNHZXRfMChlLGUuZVNldHRpbmdzXzAoKSxvLHIsdCl9ZnVuY3Rpb24gT3coZSxuKXt2YXIgcjtyZXR1cm4gcj1lLmVEZXJpdmVkU3RydWN0dXJhbEZlYXR1cmVJRF8wKG4pLHI+PTA/ZS5lR2V0KHIsITAsITApOlNkKGUsbiwhMCl9ZnVuY3Rpb24gUlIoZSxuLHIpe3ZhciB0O3JldHVybiB0PWUuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAobiksdD49MD9lLmVHZXQodCxyLCEwKTpTZChlLG4scil9ZnVuY3Rpb24gRFIoZSxuKXt2YXIgcjtyZXR1cm4gcj1FcihlLmVDbGFzcyxuKSxyPj0wP1BBKGUsciwhMCwhMCk6U2QoZSxuLCEwKX1mdW5jdGlvbiBOQShlKXt2YXIgbixyLHQ7aWYodD1lLmVEaXJlY3RSZXNvdXJjZSgpLCF0KWZvcihuPTAscj1lLmVJbnRlcm5hbENvbnRhaW5lcigpO3I7cj1yLmVJbnRlcm5hbENvbnRhaW5lcigpKXtpZigrK24+bDYpcmV0dXJuIHIuZUludGVybmFsUmVzb3VyY2UoKTtpZih0PXIuZURpcmVjdFJlc291cmNlKCksdHx8cj09ZSlicmVha31yZXR1cm4gdH1mdW5jdGlvbiBobShlLG4scix0KXt2YXIgbztyZXR1cm4gcj49MD9lLmVJbnZlcnNlQWRkXzAobixyLHQpOihlLmVJbnRlcm5hbENvbnRhaW5lcigpJiYodD0obz1lLmVDb250YWluZXJGZWF0dXJlSURfMCgpLG8+PTA/ZS5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZSh0KTplLmVJbnRlcm5hbENvbnRhaW5lcigpLmVJbnZlcnNlUmVtb3ZlKGUsLTEtbyxudWxsLHQpKSksZS5lQmFzaWNTZXRDb250YWluZXJfMChuLHIsdCkpfWZ1bmN0aW9uIEFBKGUsbixyLHQpe3JldHVybiByPj0wP2UuZUludmVyc2VSZW1vdmVfMChuLHIsdCk6ZS5lQmFzaWNTZXRDb250YWluZXJfMChudWxsLHIsdCl9ZnVuY3Rpb24gRlIoZSxuKXt2YXIgcix0LG87cmV0dXJuIHQ9a2UoZS5lQ2xhc3NfMCgpLG4pLHI9bi1lLmVTdGF0aWNGZWF0dXJlQ291bnQoKSxyPDA/KG89ZS5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMCh0KSxvPj0wP2UuZUlzU2V0KG8pOnpSKGUsdCkpOnI8MD96UihlLHQpOmEodCw2OSkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0lzU2V0KGUsZS5lU2V0dGluZ3NfMCgpLHIpfWZ1bmN0aW9uIHUkZShlLG4pe3ZhciByO3JldHVybiByPWUuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAobikscj49MD9lLmVJc1NldChyKTp6UihlLG4pfWZ1bmN0aW9uIFRhKGUpe3JldHVybiBlLmVCYXNpY0hhc0FkYXB0ZXJzKCkmJmUuZURlbGl2ZXIoKX1mdW5jdGlvbiBfdm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoO2ZvcihjPW5ldyBRLGY9bi5sZW5ndGgscz1wdGUociksXz0wO188ZjsrK18pe3N3aXRjaChkPXNCKG4seGkoNjEpLF8pLHQ9Y3ZuKHMsKGd0KF8sZCxuLmxlbmd0aCksbi5zdWJzdHIoXyxkLV8pKSksbz16RCh0KSxpPW8uZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCksSXQobiwrK2QpKXtjYXNlIDM5Ont1PXN5KG4sMzksKytkKSxlZShjLG5ldyBnTCh0LEhSKChndChkLHUsbi5sZW5ndGgpLG4uc3Vic3RyKGQsdS1kKSksaSxvKSkpLF89dSsxO2JyZWFrfWNhc2UgMzQ6e3U9c3kobiwzNCwrK2QpLGVlKGMsbmV3IGdMKHQsSFIoKGd0KGQsdSxuLmxlbmd0aCksbi5zdWJzdHIoZCx1LWQpKSxpLG8pKSksXz11KzE7YnJlYWt9Y2FzZSA5MTp7aD1uZXcgUSxlZShjLG5ldyBnTCh0LGgpKTtlOmZvcig7Oyl7c3dpdGNoKEl0KG4sKytkKSl7Y2FzZSAzOTp7dT1zeShuLDM5LCsrZCksZWUoaCxIUigoZ3QoZCx1LG4ubGVuZ3RoKSxuLnN1YnN0cihkLHUtZCkpLGksbykpLGQ9dSsxO2JyZWFrfWNhc2UgMzQ6e3U9c3kobiwzNCwrK2QpLGVlKGgsSFIoKGd0KGQsdSxuLmxlbmd0aCksbi5zdWJzdHIoZCx1LWQpKSxpLG8pKSxkPXUrMTticmVha31jYXNlIDExMDp7aWYoKytkLG4uaW5kZXhPZigidWxsIixkKT09ZCloLmFycmF5LnB1c2gobnVsbCk7ZWxzZSB0aHJvdyBiKG5ldyBJbygiRXhwZWN0aW5nIG51bGwiKSk7ZCs9MzticmVha319aWYoZDxmKXN3aXRjaChIZShkLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoZCkpe2Nhc2UgNDQ6YnJlYWs7Y2FzZSA5MzpicmVhayBlO2RlZmF1bHQ6dGhyb3cgYihuZXcgSW8oIkV4cGVjdGluZyAsIG9yIF0iKSl9ZWxzZSBicmVha31fPWQrMTticmVha31jYXNlIDExMDp7aWYoKytkLG4uaW5kZXhPZigidWxsIixkKT09ZCllZShjLG5ldyBnTCh0LG51bGwpKTtlbHNlIHRocm93IGIobmV3IElvKCJFeHBlY3RpbmcgbnVsbCIpKTtfPWQrMzticmVha319aWYoXzxmKXtpZihIZShfLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoXykhPTQ0KXRocm93IGIobmV3IElvKCJFeHBlY3RpbmcgLCIpKX1lbHNlIGJyZWFrfXJldHVybiBkdm4oZSxjLHIpfWZ1bmN0aW9uIGR2bihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7aD1uLmFycmF5Lmxlbmd0aCxmPShfPWUuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAociksYShfPj0wP2UuZUdldChfLCExLCEwKTpTZChlLHIsITEpLDYxKSk7ZTpmb3IoaT1mLml0ZXJhdG9yXzAoKTtpLmhhc05leHRfMCgpOyl7Zm9yKG89YShpLm5leHRfMSgpLDU4KSxkPTA7ZDxoOysrZClpZihzPShBZShkLG4uYXJyYXkubGVuZ3RoKSxhKG4uYXJyYXlbZF0sNzYpKSxjPXMuZ2V0VmFsdWUoKSx1PXMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksdD1vLmVHZXRfMSh1LCExKSxjPT1udWxsP3QhPW51bGw6IVluKGMsdCkpY29udGludWUgZTtyZXR1cm4gb31yZXR1cm4gbnVsbH1mdW5jdGlvbiBjJGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZihjPW4ubGVuZ3RoLTEsdT0oSGUoYyxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KGMpKSx1PT05Myl7aWYocz1vdShuLHhpKDkxKSkscz49MClyZXR1cm4gbz1mdm4oZSwoZ3QoMSxzLG4ubGVuZ3RoKSxuLnN1YnN0cigxLHMtMSkpKSxkPShndChzKzEsYyxuLmxlbmd0aCksbi5zdWJzdHIocysxLGMtKHMrMSkpKSxfdm4oZSxkLG8pfWVsc2V7aWYocj0tMSxqJD09bnVsbCYmKGokPW5ldyBSZWdFeHAoIlxcZCIpKSxqJC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUodSkpJiYocj1jQihuLHhpKDQ2KSxjLTEpLHI+PTApKXt0PWEoUlIoZSxfJGUoZSwoZ3QoMSxyLG4ubGVuZ3RoKSxuLnN1YnN0cigxLHItMSkpKSwhMSksNjEpLF89MDt0cnl7Xz1BYSgoSGUocisxLG4ubGVuZ3RoKzEpLG4uc3Vic3RyKHIrMSkpLGJ0LHFuKX1jYXRjaChoKXt0aHJvdyBoPXdyKGgpLEwoaCwxMzApPyhpPWgsYihuZXcgZEwoaSkpKTpiKGgpfWlmKF88dC5zaXplXzEoKSlyZXR1cm4gZj10LmdldF8wKF8pLEwoZiw3NikmJihmPWEoZiw3NikuZ2V0VmFsdWUoKSksYShmLDU4KX1pZihyPDApcmV0dXJuIGEoUlIoZSxfJGUoZSwoSGUoMSxuLmxlbmd0aCsxKSxuLnN1YnN0cigxKSkpLCExKSw1OCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gU2QoZSxuLHIpe3ZhciB0LG8saTtpZihpPVVnKChLaSgpLFR0KSxlLmVDbGFzc18wKCksbiksaSlyZXR1cm4gSHQoKSxhKGksNjkpLmlzRmVhdHVyZU1hcF8wKCl8fChpPVBtKHVvKFR0LGkpKSksbz0odD1lLmVEZXJpdmVkU3RydWN0dXJhbEZlYXR1cmVJRF8wKGkpLGEodD49MD9lLmVHZXQodCwhMCwhMCk6U2QoZSxpLCEwKSwxNjApKSxhKG8sMjIwKS5nZXRfNyhuLHIpO3Rocm93IGIobmV3IEdlKCJUaGUgZmVhdHVyZSAnIituLmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBmZWF0dXJlIikpfWZ1bmN0aW9uIHpSKGUsbil7dmFyIHIsdCxvO2lmKG89VWcoKEtpKCksVHQpLGUuZUNsYXNzXzAoKSxuKSxvKXJldHVybiBIdCgpLGEobyw2OSkuaXNGZWF0dXJlTWFwXzAoKXx8KG89UG0odW8oVHQsbykpKSx0PShyPWUuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAobyksYShyPj0wP2UuZUdldChyLCEwLCEwKTpTZChlLG8sITApLDE2MCkpLGEodCwyMjApLmlzU2V0XzEobik7dGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlICciK24uZ2V0TmFtZSgpKyInIGlzIG5vdCBhIHZhbGlkIGZlYXR1cmUiKSl9ZnVuY3Rpb24gQmVlKGUsbixyKXt2YXIgdCxvLGk7aWYoaT1VZygoS2koKSxUdCksZS5lQ2xhc3NfMCgpLG4pLGkpe2lmKEh0KCksIWEoaSw2OSkuaXNGZWF0dXJlTWFwXzAoKSYmKGk9UG0odW8oVHQsaSkpLCFpKSl0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2hhbmdlYWJsZSBmZWF0dXJlIikpO289KHQ9ZS5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMChpKSxhKHQ+PTA/ZS5lR2V0KHQsITAsITApOlNkKGUsaSwhMCksMTYwKSksYShvLDIyMCkuc2V0XzMobixyKX1lbHNlIHRocm93IGIobmV3IEdlKCJUaGUgZmVhdHVyZSAnIituLmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBjaGFuZ2VhYmxlIGZlYXR1cmUiKSl9ZnVuY3Rpb24gR2VlKGUsbil7dmFyIHIsdCxvO2lmKG89VWcoKEtpKCksVHQpLGUuZUNsYXNzXzAoKSxuKSxvKUh0KCksYShvLDY5KS5pc0ZlYXR1cmVNYXBfMCgpfHwobz1QbSh1byhUdCxvKSkpLHQ9KHI9ZS5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMChvKSxhKHI+PTA/ZS5lR2V0KHIsITAsITApOlNkKGUsbywhMCksMTYwKSksYSh0LDIyMCkudW5zZXRfMChuKTtlbHNlIHRocm93IGIobmV3IEdlKCJUaGUgZmVhdHVyZSAnIituLmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBjaGFuZ2VhYmxlIGZlYXR1cmUiKSl9ZnVuY3Rpb24gZnZuKGUsbil7dmFyIHI7aWYocj1tYihlLmVDbGFzc18wKCksbiksTChyLDEwMikpcmV0dXJuIGEociwxOSk7dGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlICciK24rIicgaXMgbm90IGEgdmFsaWQgcmVmZXJlbmNlIikpfWZ1bmN0aW9uIEowKGUsbil7dmFyIHIsdCxvLGk7cmV0dXJuIGk9KG89ZT9OQShlKTpudWxsLGhWZSgodD1uLG8mJm8uZ2V0UmVzb3VyY2VTZXQoKSx0KSkpLGk9PW4mJihyPU5BKGUpLHImJnIuZ2V0UmVzb3VyY2VTZXQoKSksaX1mdW5jdGlvbiAkUihlLG4scil7dmFyIHQsbyxpO2lmKG89a2UoZS5lQ2xhc3NfMCgpLG4pLHQ9bi1lLmVTdGF0aWNGZWF0dXJlQ291bnQoKSx0PDApaWYobylpZihvLmlzQ2hhbmdlYWJsZSgpKWk9ZS5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMChvKSxpPj0wP2UuZVNldChpLHIpOkJlZShlLG8scik7ZWxzZSB0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgJyIrby5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2hhbmdlYWJsZSBmZWF0dXJlIikpO2Vsc2UgdGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlIElEIituKyIgaXMgbm90IGEgdmFsaWQgZmVhdHVyZSBJRCIpKTtlbHNlIHVsKGUsdCxvLHIpfWZ1bmN0aW9uIEhlZShlLG4scil7dmFyIHQ7dD1lLmVEZXJpdmVkU3RydWN0dXJhbEZlYXR1cmVJRF8wKG4pLHQ+PTA/ZS5lU2V0KHQscik6QmVlKGUsbixyKX1mdW5jdGlvbiBVZWUoZSl7dmFyIG47cmV0dXJuIGUuZUhhc1NldHRpbmdzKCl8fChuPW9uKGUuZUNsYXNzXzAoKSktZS5lU3RhdGljRmVhdHVyZUNvdW50KCksZS5lUHJvcGVydGllc18wKCkuYWxsb2NhdGVTZXR0aW5ncyhuKSksZS5lQmFzaWNQcm9wZXJ0aWVzKCl9ZnVuY3Rpb24gXyRlKGUsbil7dmFyIHI7aWYocj1tYihlLmVDbGFzc18wKCksbiksIXIpdGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlICciK24rIicgaXMgbm90IGEgdmFsaWQgZmVhdHVyZSIpKTtyZXR1cm4gcn1mdW5jdGlvbiBCUihlLG4pe3ZhciByLHQsbztpZih0PWtlKGUuZUNsYXNzXzAoKSxuKSxyPW4tZS5lU3RhdGljRmVhdHVyZUNvdW50KCkscjwwKWlmKHQpaWYodC5pc0NoYW5nZWFibGUoKSlvPWUuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAodCksbz49MD9lLmVVbnNldChvKTpHZWUoZSx0KTtlbHNlIHRocm93IGIobmV3IEdlKCJUaGUgZmVhdHVyZSAnIit0LmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBjaGFuZ2VhYmxlIGZlYXR1cmUiKSk7ZWxzZSB0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgSUQiK24rIiBpcyBub3QgYSB2YWxpZCBmZWF0dXJlIElEIikpO2Vsc2UgY2woZSxyLHQpfWZ1bmN0aW9uIHB2bihlLG4pe3ZhciByO3I9ZS5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMChuKSxyPj0wP2UuZVVuc2V0KHIpOkdlZShlLG4pfWZ1bmN0aW9uIG5zKGUpe3ZhciBuLHI7cmV0dXJuIHI9bmV3IExhKHlfKGUuX19fY2xhenopKSxyLnN0cmluZys9IkAiLE9uKHIsKG49dXIoZSk+Pj4wLG4udG9TdHJpbmcoMTYpKSksZS5lSXNQcm94eSgpPyhyLnN0cmluZys9IiAoZVByb3h5VVJJOiAiLGVpKHIsZS5lUHJveHlVUklfMCgpKSxlLmVEeW5hbWljQ2xhc3MoKSYmKHIuc3RyaW5nKz0iIGVDbGFzczogIixlaShyLGUuZUR5bmFtaWNDbGFzcygpKSksci5zdHJpbmcrPSIpIik6ZS5lRHluYW1pY0NsYXNzKCkmJihyLnN0cmluZys9IiAoZUNsYXNzOiAiLGVpKHIsZS5lRHluYW1pY0NsYXNzKCkpLHIuc3RyaW5nKz0iKSIpLHIuc3RyaW5nfWZ1bmN0aW9uIEdSKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYobilpZihyPD0tMSl7aWYodD1rZShuLmVDbGFzc18wKCksLTEtciksTCh0LDEwMikpcmV0dXJuIGEodCwxOSk7Zm9yKHM9YShuLmVHZXRfMCh0KSwxNjApLHU9MCxjPXMuc2l6ZV8xKCk7dTxjOysrdSlpZihEKHMuZ2V0VmFsdWVfMSh1KSk9PT1EKGUpJiYobz1zLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZV8wKHUpLEwobywxMDIpJiYoaT1hKG8sMTkpLGkuZUZsYWdzJkdvKSkpcmV0dXJuIGk7dGhyb3cgYihuZXcgcm8oIlRoZSBjb250YWlubWVudCBmZWF0dXJlIGNvdWxkIG5vdCBiZSBsb2NhdGVkIikpfWVsc2UgcmV0dXJuIEd0KGEoa2UoZS5lQ2xhc3NfMCgpLHIpLDE5KSk7ZWxzZSByZXR1cm4gbnVsbH1mdW5jdGlvbiBIUihlLG4scil7dmFyIHQsbztyZXR1cm4gdD12cmUoZSksbz1uLmNyZWF0ZUZyb21TdHJpbmcocix0KSxvfXAoOTksOTMseGllKSxsLmVOb3RpZmljYXRpb25SZXF1aXJlZD1mdW5jdGlvbigpe3JldHVybiBUYSh0aGlzKX0sbC5lQmFzZVN0cnVjdHVyYWxGZWF0dXJlSUQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gbn0sbC5lQmFzaWNQcm9wZXJ0aWVzPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPUd0KGEoa2UodGhpcy5lQ2xhc3NfMCgpLHRoaXMuZUNvbnRhaW5lckZlYXR1cmVJRF8wKCkpLDE5KSksdGhpcy5lSW50ZXJuYWxDb250YWluZXIoKS5lSW52ZXJzZVJlbW92ZSh0aGlzLHIuZmVhdHVyZUlELHIuY29udGFpbmVyQ2xhc3Msbil9LGwuZUJhc2ljU2V0Q29udGFpbmVyPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLmVCYXNpY1NldENvbnRhaW5lcl8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gR2EodGhpcyxuLHIsdCl9LGwuZUNsYXNzXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lQmFzaWNQcm9wZXJ0aWVzKCkmJihuPXRoaXMuZUJhc2ljUHJvcGVydGllcygpLmdldEVDbGFzcygpLG4pP246dGhpcy5lU3RhdGljQ2xhc3MoKX0sbC5lQ29udGFpbmVyXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTVIodGhpcyl9LGwuZUNvbnRhaW5lckZlYXR1cmVJRF8wPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLmVDb250ZW50c18wPWZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gcj10aGlzLmVQcm9wZXJ0aWVzXzAoKS5nZXRFQ29udGVudHMoKSwhciYmdGhpcy5lQmFzaWNQcm9wZXJ0aWVzKCkuc2V0RUNvbnRlbnRzKHI9KFRTKCksbj1ZcmUoRXUodGhpcy5lQ2xhc3NfMCgpKSksbj09bnVsbD9yRjpuZXcgdmIodGhpcyxuKSkpLHJ9LGwuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEPWZ1bmN0aW9uKG4scil7cmV0dXJuIG59LGwuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9bi5nZXRDb250YWluZXJDbGFzcygpLHI/bi5nZXRGZWF0dXJlSURfMCgpOkVyKHRoaXMuZUNsYXNzXzAoKSxuKX0sbC5lRGlyZWN0UmVzb3VyY2U9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmVCYXNpY1Byb3BlcnRpZXMoKSxuP24uZ2V0RVJlc291cmNlKCk6bnVsbH0sbC5lRHluYW1pY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZUJhc2ljUHJvcGVydGllcygpP3RoaXMuZUJhc2ljUHJvcGVydGllcygpLmdldEVDbGFzcygpOm51bGx9LGwuZUdldD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIFBBKHRoaXMsbixyLHQpfSxsLmVHZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gT3codGhpcyxuKX0sbC5lR2V0XzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gUlIodGhpcyxuLHIpfSxsLmVIYXNTZXR0aW5ncz1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuZUJhc2ljUHJvcGVydGllcygpLCEhbiYmbi5oYXNTZXR0aW5ncygpfSxsLmVJbnRlcm5hbENvbnRhaW5lcj1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5lSW50ZXJuYWxSZXNvdXJjZT1mdW5jdGlvbigpe3JldHVybiBOQSh0aGlzKX0sbC5lSW52ZXJzZUFkZD1mdW5jdGlvbihuLHIsdCxvKXtyZXR1cm4gaG0odGhpcyxuLHIsbyl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87cmV0dXJuIG89YShrZSh0aGlzLmVDbGFzc18wKCksciksNjkpLG8uZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQodGhpcyx0aGlzLmVTZXR0aW5nc18wKCksci10aGlzLmVTdGF0aWNGZWF0dXJlQ291bnQoKSxuLHQpfSxsLmVJbnZlcnNlUmVtb3ZlPWZ1bmN0aW9uKG4scix0LG8pe3JldHVybiBBQSh0aGlzLG4scixvKX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbztyZXR1cm4gbz1hKGtlKHRoaXMuZUNsYXNzXzAoKSxyKSw2OSksby5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZVJlbW92ZSh0aGlzLHRoaXMuZVNldHRpbmdzXzAoKSxyLXRoaXMuZVN0YXRpY0ZlYXR1cmVDb3VudCgpLG4sdCl9LGwuZUlzUHJveHk9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuZUJhc2ljUHJvcGVydGllcygpJiYhIXRoaXMuZUJhc2ljUHJvcGVydGllcygpLmdldEVQcm94eVVSSSgpfSxsLmVJc1NldD1mdW5jdGlvbihuKXtyZXR1cm4gRlIodGhpcyxuKX0sbC5lSXNTZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gdSRlKHRoaXMsbil9LGwuZU9iamVjdEZvclVSSUZyYWdtZW50U2VnbWVudD1mdW5jdGlvbihuKXtyZXR1cm4gYyRlKHRoaXMsbil9LGwuZVByb3BlcnRpZXNfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5lUHJveHlVUklfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVCYXNpY1Byb3BlcnRpZXMoKT90aGlzLmVCYXNpY1Byb3BlcnRpZXMoKS5nZXRFUHJveHlVUkkoKTpudWxsfSxsLmVSZXNvdXJjZV8wPWZ1bmN0aW9uKCl7cmV0dXJuIE5BKHRoaXMpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXskUih0aGlzLG4scil9LGwuZVNldENsYXNzPWZ1bmN0aW9uKG4pe3RoaXMuZVByb3BlcnRpZXNfMCgpLnNldEVDbGFzcyhuKX0sbC5lU2V0RGlyZWN0UmVzb3VyY2U9ZnVuY3Rpb24obil7dGhpcy5lUHJvcGVydGllc18wKCkuc2V0RVJlc291cmNlKG4pfSxsLmVTZXRQcm94eVVSST1mdW5jdGlvbihuKXt0aGlzLmVQcm9wZXJ0aWVzXzAoKS5zZXRFUHJveHlVUkkobil9LGwuZVNldFJlc291cmNlPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHM7cmV0dXJuIHM9dGhpcy5lRGlyZWN0UmVzb3VyY2UoKSxzJiZuJiYocj1EdChzLmdldENvbnRlbnRzKCksdGhpcyxyKSxzLmRldGFjaGVkKHRoaXMpKSxvPXRoaXMuZUludGVybmFsQ29udGFpbmVyKCksbyYmKEdSKHRoaXMsdGhpcy5lSW50ZXJuYWxDb250YWluZXIoKSx0aGlzLmVDb250YWluZXJGZWF0dXJlSURfMCgpKS5lRmxhZ3MmRnQ/KGk9by5lSW50ZXJuYWxSZXNvdXJjZSgpLGkmJihuPyFzJiZpLmRldGFjaGVkKHRoaXMpOmkuYXR0YWNoZWQodGhpcykpKToocj0odD10aGlzLmVDb250YWluZXJGZWF0dXJlSURfMCgpLHQ+PTA/dGhpcy5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZShyKTp0aGlzLmVJbnRlcm5hbENvbnRhaW5lcigpLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtdCxudWxsLHIpKSxyPXRoaXMuZUJhc2ljU2V0Q29udGFpbmVyXzAobnVsbCwtMSxyKSkpLHRoaXMuZVNldERpcmVjdFJlc291cmNlKG4pLHJ9LGwuZVNldHRpbmc9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXztpZih0PXRoaXMuZUNsYXNzXzAoKSxzPUVyKHQsbikscj10aGlzLmVTdGF0aWNGZWF0dXJlQ291bnQoKSxzPj1yKXJldHVybiBhKG4sNjkpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNTZXR0aW5nKHRoaXMsdGhpcy5lU2V0dGluZ3NfMCgpLHMtcik7aWYoczw9LTEpaWYodT1VZygoS2koKSxUdCksdCxuKSx1KXtpZihIdCgpLGEodSw2OSkuaXNGZWF0dXJlTWFwXzAoKXx8KHU9UG0odW8oVHQsdSkpKSxpPShvPXRoaXMuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzAodSksYShvPj0wP3RoaXMuZUdldChvLCEwLCEwKTpTZCh0aGlzLHUsITApLDE2MCkpLF89dS5nZXRVcHBlckJvdW5kKCksXz4xfHxfPT0tMSlyZXR1cm4gYShhKGksMjIwKS5nZXRfNyhuLCExKSw3OSl9ZWxzZSB0aHJvdyBiKG5ldyBHZSgiVGhlIGZlYXR1cmUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgZmVhdHVyZSIpKTtlbHNlIGlmKG4uaXNNYW55KCkpcmV0dXJuIG89dGhpcy5lRGVyaXZlZFN0cnVjdHVyYWxGZWF0dXJlSURfMChuKSxhKG8+PTA/dGhpcy5lR2V0KG8sITEsITApOlNkKHRoaXMsbiwhMSksNzkpO3JldHVybiBjPW5ldyBESGUodGhpcyxuKSxjfSxsLmVTZXR0aW5nc18wPWZ1bmN0aW9uKCl7cmV0dXJuIFVlZSh0aGlzKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4ocl8oKSwkZSkuZU9iamVjdEVDbGFzc30sbC5lU3RhdGljRmVhdHVyZUNvdW50PWZ1bmN0aW9uKCl7cmV0dXJuIG9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpfSxsLmVVbnNldD1mdW5jdGlvbihuKXtCUih0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gbnModGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiQmFzaWNFT2JqZWN0SW1wbCIsOTkpO2Z1bmN0aW9uIGQkZSgpe2QkZT1GLGYkZT1uZXcgVEhlfXZhciBmJGU7ZnVuY3Rpb24gZ3ZuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXztpZihvPW9jZShlLmVGbGFnc18wJjI1NCksbz09MCllLmVTdG9yYWdlPXI7ZWxzZXtpZihvPT0xKXU9QihRcixNZSwxLDIsNSwxKSxpPVVSKGUsbiksaT09MD8odVswXT1yLHVbMV09ZS5lU3RvcmFnZSk6KHVbMF09ZS5lU3RvcmFnZSx1WzFdPXIpO2Vsc2UgZm9yKHU9QihRcixNZSwxLG8rMSw1LDEpLHM9bV8oZS5lU3RvcmFnZSksdD0yLGM9MCxfPTA7dDw9MTI4O3Q8PD0xKXQ9PW4/dVtfKytdPXI6ZS5lRmxhZ3NfMCZ0JiYodVtfKytdPXNbYysrXSk7ZS5lU3RvcmFnZT11fWUuZUZsYWdzXzB8PW59ZnVuY3Rpb24gTWkoZSl7dmFyIG47cmV0dXJuIG49YShCZShlLDE2KSwyOSksbnx8ZS5lU3RhdGljQ2xhc3MoKX1mdW5jdGlvbiBXZWUoZSl7dmFyIG47cmV0dXJuIG49bV8oQmUoZSwzMikpLG49PW51bGwmJihTaShlKSxuPW1fKEJlKGUsMzIpKSksbn1mdW5jdGlvbiBTaShlKXt2YXIgbixyO3JldHVybiBlLmVGbGFnc18wJjMyfHwocj0obj1hKEJlKGUsMTYpLDI5KSxvbihufHxlLmVTdGF0aWNDbGFzcygpKS1vbihlLmVTdGF0aWNDbGFzcygpKSksciE9MCYmbW0oZSwzMixCKFFyLE1lLDEsciw1LDEpKSksZX1mdW5jdGlvbiBVUihlLG4pe3ZhciByLHQsbztmb3Iobz0wLHQ9Mjt0PG47dDw8PTEpZS5lRmxhZ3NfMCZ0JiYrK287aWYobz09MCl7Zm9yKHI9bjw8PTE7cjw9MTI4O3I8PD0xKWlmKGUuZUZsYWdzXzAmcilyZXR1cm4gMDtyZXR1cm4tMX1lbHNlIHJldHVybiBvfWZ1bmN0aW9uIEJlKGUsbil7dmFyIHI7cmV0dXJuIGUuZUZsYWdzXzAmbj8ocj1VUihlLG4pLHI9PS0xP2UuZVN0b3JhZ2U6bV8oZS5lU3RvcmFnZSlbcl0pOm51bGx9ZnVuY3Rpb24gaHZuKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7aWYodD1vY2UoZS5lRmxhZ3NfMCYyNTQpLHQ9PTEpZS5lU3RvcmFnZT1udWxsO2Vsc2UgaWYoaT1tXyhlLmVTdG9yYWdlKSx0PT0yKW89VVIoZSxuKSxlLmVTdG9yYWdlPWlbbz09MD8xOjBdO2Vsc2V7Zm9yKHM9QihRcixNZSwxLHQtMSw1LDEpLHI9Mix1PTAsYz0wO3I8PTEyODtyPDw9MSlyPT1uPysrdTplLmVGbGFnc18wJnImJihzW2MrK109aVt1KytdKTtlLmVTdG9yYWdlPXN9ZS5lRmxhZ3NfMCY9fm59ZnVuY3Rpb24gbW0oZSxuLHIpe3ZhciB0O2UuZUZsYWdzXzAmbj9yPT1udWxsP2h2bihlLG4pOih0PVVSKGUsbiksdD09LTE/ZS5lU3RvcmFnZT1yOlRyKG1fKGUuZVN0b3JhZ2UpLHQscikpOnIhPW51bGwmJmd2bihlLG4scil9cCgxMTksOTksezExMDoxLDk0OjEsOTM6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwxMTk6MX0pLGwuZHluYW1pY0dldD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1XZWUodGhpcykscltuXX0sbC5keW5hbWljU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQ7dD1XZWUodGhpcyksVHIodCxuLHIpfSxsLmR5bmFtaWNVbnNldD1mdW5jdGlvbihuKXt2YXIgcjtyPVdlZSh0aGlzKSxUcihyLG4sbnVsbCl9LGwuZUJhc2ljQWRhcHRlckFycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIGEoQmUodGhpcyw0KSwxMjkpfSxsLmVCYXNpY0FkYXB0ZXJzPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLmVCYXNpY0hhc0FkYXB0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzXzAmNCkhPTB9LGwuZUJhc2ljUHJvcGVydGllcz1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5lQmFzaWNTZXRDb250YWluZXJfMT1mdW5jdGlvbihuKXttbSh0aGlzLDIsbil9LGwuZUJhc2ljU2V0Q29udGFpbmVyPWZ1bmN0aW9uKG4scil7dGhpcy5lRmxhZ3NfMD1yPDwxNnx0aGlzLmVGbGFnc18wJjI1NSx0aGlzLmVCYXNpY1NldENvbnRhaW5lcl8xKG4pfSxsLmVDbGFzc18wPWZ1bmN0aW9uKCl7cmV0dXJuIE1pKHRoaXMpfSxsLmVDb250YWluZXJGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVGbGFnc18wPj4xNn0sbC5lQ29udGVudHNfMD1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIFRTKCkscj1ZcmUoRXUoKG49YShCZSh0aGlzLDE2KSwyOSksbnx8dGhpcy5lU3RhdGljQ2xhc3MoKSkpKSxyPT1udWxsP3JGOm5ldyB2Yih0aGlzLHIpfSxsLmVEZWxpdmVyPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzXzAmMSk9PTB9LGwuZURpcmVjdFJlc291cmNlPWZ1bmN0aW9uKCl7cmV0dXJuIGEoQmUodGhpcywxMjgpLDIwMzQpfSxsLmVEeW5hbWljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gYShCZSh0aGlzLDE2KSwyOSl9LGwuZUhhc1NldHRpbmdzPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzXzAmMzIpIT0wfSxsLmVJbnRlcm5hbENvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiBhKEJlKHRoaXMsMiksNTQpfSxsLmVJc1Byb3h5PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzXzAmNjQpIT0wfSxsLmVQcm9wZXJ0aWVzXzA9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuZVByb3h5VVJJXzA9ZnVuY3Rpb24oKXtyZXR1cm4gYShCZSh0aGlzLDY0KSwyODgpfSxsLmVTZXRDbGFzcz1mdW5jdGlvbihuKXttbSh0aGlzLDE2LG4pfSxsLmVTZXREaXJlY3RSZXNvdXJjZT1mdW5jdGlvbihuKXttbSh0aGlzLDEyOCxuKX0sbC5lU2V0UHJveHlVUkk9ZnVuY3Rpb24obil7bW0odGhpcyw2NCxuKX0sbC5lU2V0dGluZ3NfMD1mdW5jdGlvbigpe3JldHVybiBTaSh0aGlzKX0sbC5lRmxhZ3NfMD0wLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiTWluaW1hbEVPYmplY3RJbXBsIiwxMTkpLHAoMTIwLDExOSx7MTEwOjEsOTQ6MSw5MzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDExOToxLDEyMDoxfSksbC5lQmFzaWNTZXRDb250YWluZXJfMT1mdW5jdGlvbihuKXt0aGlzLmVDb250YWluZXI9bn0sbC5lSW50ZXJuYWxDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQ29udGFpbmVyfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIk1pbmltYWxFT2JqZWN0SW1wbC9Db250YWluZXIiLDEyMCk7ZnVuY3Rpb24gWlQoZSxuKXt2YXIgcix0LG8saSxzO2lmKCFuKXJldHVybiBlO2lmKEwobiwzNDIpKWZvcihvPWEobiwzNDIpLGk9KCFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSxlLnByb3BlcnRpZXMpLHQ9by5nZXRQcm9wZXJ0aWVzKCkuZGVsZWdhdGVFTGlzdC5pdGVyYXRvcl8wKCk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEodC5kb05leHQoKSw0NCkscz1yLmdldFZhbHVlKCksZ2IoaSxhKHIuZ2V0S2V5KCksMTQ5KSxzKTtlbHNlIWUucHJvcGVydGllcyYmKGUucHJvcGVydGllcz1uZXcgWWkoKEtvKCksVXUpLGUwLGUsMCkpLGtHZShlLnByb3BlcnRpZXMsbi5nZXRBbGxQcm9wZXJ0aWVzKCkpO3JldHVybiBlfWZ1bmN0aW9uIGplZShlLG4scix0KXtyZXR1cm4gbj09MD90PyghZS5wcm9wZXJ0aWVzJiYoZS5wcm9wZXJ0aWVzPW5ldyBZaSgoS28oKSxVdSksZTAsZSwwKSksZS5wcm9wZXJ0aWVzKTooIWUucHJvcGVydGllcyYmKGUucHJvcGVydGllcz1uZXcgWWkoKEtvKCksVXUpLGUwLGUsMCkpLHBiKGUucHJvcGVydGllcykpOlBBKGUsbixyLHQpfWZ1bmN0aW9uIFZlZShlLG4scix0KXt2YXIgbyxpO3JldHVybiByPT0wPyghZS5wcm9wZXJ0aWVzJiYoZS5wcm9wZXJ0aWVzPW5ldyBZaSgoS28oKSxVdSksZTAsZSwwKSksbUwoZS5wcm9wZXJ0aWVzLG4sdCkpOihpPWEoa2UoKG89YShCZShlLDE2KSwyOSksb3x8ZS5lU3RhdGljQ2xhc3MoKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUoZSxTaShlKSxyLW9uKGUuZVN0YXRpY0NsYXNzKCkpLG4sdCkpfWZ1bmN0aW9uIHFlZShlLG4pe3JldHVybiBuPT0wPyEhZS5wcm9wZXJ0aWVzJiZlLnByb3BlcnRpZXMuc2l6ZV8wIT0wOkZSKGUsbil9ZnVuY3Rpb24gWWVlKGUsbixyKXtzd2l0Y2gobil7Y2FzZSAwOiFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSx5TChlLnByb3BlcnRpZXMscik7cmV0dXJufSRSKGUsbixyKX1mdW5jdGlvbiBLZWUoZSxuKXtzd2l0Y2gobil7Y2FzZSAwOiFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSxlLnByb3BlcnRpZXMuZGVsZWdhdGVFTGlzdC5jbGVhcl8wKCk7cmV0dXJufUJSKGUsbil9ZnVuY3Rpb24gcCRlKGUpe3ZhciBuLHIsdDtmb3IodD0oIWUucHJvcGVydGllcyYmKGUucHJvcGVydGllcz1uZXcgWWkoKEtvKCksVXUpLGUwLGUsMCkpLGUucHJvcGVydGllcykscj10LmRlbGVnYXRlRUxpc3QuaXRlcmF0b3JfMCgpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKHIuZG9OZXh0KCksNDQpLG4uZ2V0VmFsdWUoKTtyZXR1cm4gcGIodCl9ZnVuY3Rpb24gVihlLG4pe3ZhciByLHQ7cmV0dXJuIHQ9KCFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSx3cyhlLnByb3BlcnRpZXMsbikpLHQ/PyhyPW4uZ2V0RGVmYXVsdCgpLEwociw0KSYmKHI9PW51bGw/KCFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSxvTChlLnByb3BlcnRpZXMsbikpOighZS5wcm9wZXJ0aWVzJiYoZS5wcm9wZXJ0aWVzPW5ldyBZaSgoS28oKSxVdSksZTAsZSwwKSksZ2IoZS5wcm9wZXJ0aWVzLG4scikpKSxyKX1mdW5jdGlvbiBXcyhlLG4pe3JldHVybiFlLnByb3BlcnRpZXMmJihlLnByb3BlcnRpZXM9bmV3IFlpKChLbygpLFV1KSxlMCxlLDApKSxiRChlLnByb3BlcnRpZXMsbil9ZnVuY3Rpb24gbnIoZSxuLHIpe3JldHVybiByPT1udWxsPyghZS5wcm9wZXJ0aWVzJiYoZS5wcm9wZXJ0aWVzPW5ldyBZaSgoS28oKSxVdSksZTAsZSwwKSksb0woZS5wcm9wZXJ0aWVzLG4pKTooIWUucHJvcGVydGllcyYmKGUucHJvcGVydGllcz1uZXcgWWkoKEtvKCksVXUpLGUwLGUsMCkpLGdiKGUucHJvcGVydGllcyxuLHIpKSxlfXAoMjA4MywxMjAsezExMDoxLDM0MjoxLDk2OjEsOTQ6MSw5MzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDExOToxLDEyMDoxfSksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gamVlKHRoaXMsbixyLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiBWZWUodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3JldHVybiBxZWUodGhpcyxuKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7WWVlKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSxzJGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe0tlZSh0aGlzLG4pfSxsLmdldEFsbFByb3BlcnRpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCRlKHRoaXMpfSxsLmdldFByb3BlcnRpZXM9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5wcm9wZXJ0aWVzJiYodGhpcy5wcm9wZXJ0aWVzPW5ldyBZaSgoS28oKSxVdSksZTAsdGhpcywwKSksdGhpcy5wcm9wZXJ0aWVzfSxsLmdldFByb3BlcnR5PWZ1bmN0aW9uKG4pe3JldHVybiBWKHRoaXMsbil9LGwuaGFzUHJvcGVydHk9ZnVuY3Rpb24obil7cmV0dXJuIFdzKHRoaXMsbil9LGwuc2V0UHJvcGVydHk9ZnVuY3Rpb24obixyKXtyZXR1cm4gbnIodGhpcyxuLHIpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguaW1wbCIsIkVNYXBQcm9wZXJ0eUhvbGRlckltcGwiLDIwODMpO2Z1bmN0aW9uIFdSKGUsbixyKXtMQShlLG4pLGtBKGUscil9ZnVuY3Rpb24gTEEoZSxuKXt2YXIgcjtyPWUueF8wLGUueF8wPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHNwKGUsMCxyLGUueF8wKSl9ZnVuY3Rpb24ga0EoZSxuKXt2YXIgcjtyPWUueV8wLGUueV8wPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHNwKGUsMSxyLGUueV8wKSl9ZnVuY3Rpb24gT0EoKXt9cCg1NzIsMTIwLHsxMTA6MSwzNzc6MSw5NDoxLDkzOjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTE5OjEsMTIwOjF9LE9BKSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIHRoaXMueF8wO2Nhc2UgMTpyZXR1cm4gdGhpcy55XzB9cmV0dXJuIFBBKHRoaXMsbixyLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiB0aGlzLnhfMCE9MDtjYXNlIDE6cmV0dXJuIHRoaXMueV8wIT0wfXJldHVybiBGUih0aGlzLG4pfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXtzd2l0Y2gobil7Y2FzZSAwOkxBKHRoaXMsUigkKHIpKSk7cmV0dXJuO2Nhc2UgMTprQSh0aGlzLFIoJChyKSkpO3JldHVybn0kUih0aGlzLG4scil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIEtvKCksbyRlfSxsLmVVbnNldD1mdW5jdGlvbihuKXtzd2l0Y2gobil7Y2FzZSAwOkxBKHRoaXMsMCk7cmV0dXJuO2Nhc2UgMTprQSh0aGlzLDApO3JldHVybn1CUih0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lRmxhZ3NfMCY2ND9ucyh0aGlzKToobj1uZXcgeWwobnModGhpcykpLG4uc3RyaW5nKz0iICh4OiAiLHhwKG4sdGhpcy54XzApLG4uc3RyaW5nKz0iLCB5OiAiLHhwKG4sdGhpcy55XzApLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfSxsLnhfMD0wLGwueV8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmltcGwiLCJFbGtCZW5kUG9pbnRJbXBsIiw1NzIpO2Z1bmN0aW9uIFhlZShlLG4scix0KXtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksZS5sYWJlbHM7Y2FzZSAyOnJldHVybiBlLmlkZW50aWZpZXJ9cmV0dXJuIGplZShlLG4scix0KX1mdW5jdGlvbiBqUihlLG4scix0KXt2YXIgbyxpO3JldHVybiByPT0xPyghZS5sYWJlbHMmJihlLmxhYmVscz1uZXcgVShRdCxlLDEsNykpLGhpKGUubGFiZWxzLG4sdCkpOihpPWEoa2UoKG89YShCZShlLDE2KSwyOSksb3x8ZS5lU3RhdGljQ2xhc3MoKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQoZSxTaShlKSxyLW9uKGUuZVN0YXRpY0NsYXNzKCkpLG4sdCkpfWZ1bmN0aW9uIFZSKGUsbixyLHQpe3JldHVybiByPT0xPyghZS5sYWJlbHMmJihlLmxhYmVscz1uZXcgVShRdCxlLDEsNykpLER0KGUubGFiZWxzLG4sdCkpOlZlZShlLG4scix0KX1mdW5jdGlvbiBKZWUoZSxuKXtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiEhZS5sYWJlbHMmJmUubGFiZWxzLnNpemVfMCE9MDtjYXNlIDI6cmV0dXJuIGUuaWRlbnRpZmllciE9bnVsbH1yZXR1cm4gcWVlKGUsbil9ZnVuY3Rpb24gWmVlKGUsbixyKXtzd2l0Y2gobil7Y2FzZSAxOiFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksZm4oZS5sYWJlbHMpLCFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksUHIoZS5sYWJlbHMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMjpNdyhlLHhuKHIpKTtyZXR1cm59WWVlKGUsbixyKX1mdW5jdGlvbiBRZWUoZSxuKXtzd2l0Y2gobil7Y2FzZSAxOiFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksZm4oZS5sYWJlbHMpO3JldHVybjtjYXNlIDI6TXcoZSxudWxsKTtyZXR1cm59S2VlKGUsbil9ZnVuY3Rpb24gTUEoZSl7cmV0dXJuIWUubGFiZWxzJiYoZS5sYWJlbHM9bmV3IFUoUXQsZSwxLDcpKSxlLmxhYmVsc31mdW5jdGlvbiBNdyhlLG4pe3ZhciByO3I9ZS5pZGVudGlmaWVyLGUuaWRlbnRpZmllcj1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMixyLGUuaWRlbnRpZmllcikpfWZ1bmN0aW9uIHFSKGUpe3ZhciBuO3JldHVybiBlLmVGbGFnc18wJjY0P25zKGUpOihuPW5ldyB5bChucyhlKSksbi5zdHJpbmcrPSIgKGlkZW50aWZpZXI6ICIsSnQobixlLmlkZW50aWZpZXIpLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfXAoNzM5LDIwODMsezExMDoxLDM0MjoxLDE2NzoxLDk2OjEsOTQ6MSw5MzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDExOToxLDEyMDoxfSksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gWGVlKHRoaXMsbixyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiBqUih0aGlzLG4scix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gVlIodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3JldHVybiBKZWUodGhpcyxuKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7WmVlKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSxhJGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe1FlZSh0aGlzLG4pfSxsLmdldElkZW50aWZpZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZGVudGlmaWVyfSxsLmdldExhYmVsc18wPWZ1bmN0aW9uKCl7cmV0dXJuIE1BKHRoaXMpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gcVIodGhpcyl9LGwuaWRlbnRpZmllcj1udWxsLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5pbXBsIiwiRWxrR3JhcGhFbGVtZW50SW1wbCIsNzM5KTtmdW5jdGlvbiBlbmUoZSxuLHIsdCl7c3dpdGNoKG4pe2Nhc2UgMzpyZXR1cm4gZS5oZWlnaHQ7Y2FzZSA0OnJldHVybiBlLndpZHRoXzA7Y2FzZSA1OnJldHVybiBlLnhfMDtjYXNlIDY6cmV0dXJuIGUueV8wfXJldHVybiBYZWUoZSxuLHIsdCl9ZnVuY3Rpb24gbm5lKGUsbil7c3dpdGNoKG4pe2Nhc2UgMzpyZXR1cm4gZS5oZWlnaHQhPTA7Y2FzZSA0OnJldHVybiBlLndpZHRoXzAhPTA7Y2FzZSA1OnJldHVybiBlLnhfMCE9MDtjYXNlIDY6cmV0dXJuIGUueV8wIT0wfXJldHVybiBKZWUoZSxuKX1mdW5jdGlvbiBybmUoZSxuLHIpe3N3aXRjaChuKXtjYXNlIDM6Q2QoZSxSKCQocikpKTtyZXR1cm47Y2FzZSA0OlRkKGUsUigkKHIpKSk7cmV0dXJuO2Nhc2UgNTpDaShlLFIoJChyKSkpO3JldHVybjtjYXNlIDY6VGkoZSxSKCQocikpKTtyZXR1cm59WmVlKGUsbixyKX1mdW5jdGlvbiB0bmUoZSxuKXtzd2l0Y2gobil7Y2FzZSAzOkNkKGUsMCk7cmV0dXJuO2Nhc2UgNDpUZChlLDApO3JldHVybjtjYXNlIDU6Q2koZSwwKTtyZXR1cm47Y2FzZSA2OlRpKGUsMCk7cmV0dXJufVFlZShlLG4pfWZ1bmN0aW9uIFJnKGUsbixyKXtUZChlLG4pLENkKGUscil9ZnVuY3Rpb24gQ2QoZSxuKXt2YXIgcjtyPWUuaGVpZ2h0LGUuaGVpZ2h0PW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHNwKGUsMyxyLGUuaGVpZ2h0KSl9ZnVuY3Rpb24gX2woZSxuLHIpe0NpKGUsbiksVGkoZSxyKX1mdW5jdGlvbiBUZChlLG4pe3ZhciByO3I9ZS53aWR0aF8wLGUud2lkdGhfMD1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBzcChlLDQscixlLndpZHRoXzApKX1mdW5jdGlvbiBDaShlLG4pe3ZhciByO3I9ZS54XzAsZS54XzA9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSw1LHIsZS54XzApKX1mdW5jdGlvbiBUaShlLG4pe3ZhciByO3I9ZS55XzAsZS55XzA9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSw2LHIsZS55XzApKX1mdW5jdGlvbiBZUihlKXt2YXIgbjtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9xUihlKToobj1uZXcgeWwocVIoZSkpLG4uc3RyaW5nKz0iIChoZWlnaHQ6ICIseHAobixlLmhlaWdodCksbi5zdHJpbmcrPSIsIHdpZHRoOiAiLHhwKG4sZS53aWR0aF8wKSxuLnN0cmluZys9IiwgeDogIix4cChuLGUueF8wKSxuLnN0cmluZys9IiwgeTogIix4cChuLGUueV8wKSxuLnN0cmluZys9IikiLG4uc3RyaW5nKX1wKDc0MCw3MzksezExMDoxLDM0MjoxLDE2NzoxLDQyMjoxLDk2OjEsOTQ6MSw5MzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDExOToxLDEyMDoxfSksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gZW5lKHRoaXMsbixyLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXtyZXR1cm4gbm5lKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3JuZSh0aGlzLG4scil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIEtvKCksbCRlfSxsLmVVbnNldD1mdW5jdGlvbihuKXt0bmUodGhpcyxuKX0sbC5nZXRIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oZWlnaHR9LGwuZ2V0V2lkdGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53aWR0aF8wfSxsLmdldFg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy54XzB9LGwuZ2V0WT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnlfMH0sbC5zZXREaW1lbnNpb25zPWZ1bmN0aW9uKG4scil7UmcodGhpcyxuLHIpfSxsLnNldExvY2F0aW9uPWZ1bmN0aW9uKG4scil7X2wodGhpcyxuLHIpfSxsLnNldFg9ZnVuY3Rpb24obil7Q2kodGhpcyxuKX0sbC5zZXRZPWZ1bmN0aW9uKG4pe1RpKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBZUih0aGlzKX0sbC5oZWlnaHQ9MCxsLndpZHRoXzA9MCxsLnhfMD0wLGwueV8wPTAsZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmltcGwiLCJFbGtTaGFwZUltcGwiLDc0MCk7ZnVuY3Rpb24gb25lKGUsbixyLHQpe3N3aXRjaChuKXtjYXNlIDc6cmV0dXJuIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxlLm91dGdvaW5nRWRnZXM7Y2FzZSA4OnJldHVybiFlLmluY29taW5nRWRnZXMmJihlLmluY29taW5nRWRnZXM9bmV3IExlKE1yLGUsOCw1KSksZS5pbmNvbWluZ0VkZ2VzfXJldHVybiBlbmUoZSxuLHIsdCl9ZnVuY3Rpb24gaW5lKGUsbixyLHQpe3N3aXRjaChyKXtjYXNlIDc6cmV0dXJuIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxoaShlLm91dGdvaW5nRWRnZXMsbix0KTtjYXNlIDg6cmV0dXJuIWUuaW5jb21pbmdFZGdlcyYmKGUuaW5jb21pbmdFZGdlcz1uZXcgTGUoTXIsZSw4LDUpKSxoaShlLmluY29taW5nRWRnZXMsbix0KX1yZXR1cm4galIoZSxuLHIsdCl9ZnVuY3Rpb24gYW5lKGUsbixyLHQpe3N3aXRjaChyKXtjYXNlIDc6cmV0dXJuIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxEdChlLm91dGdvaW5nRWRnZXMsbix0KTtjYXNlIDg6cmV0dXJuIWUuaW5jb21pbmdFZGdlcyYmKGUuaW5jb21pbmdFZGdlcz1uZXcgTGUoTXIsZSw4LDUpKSxEdChlLmluY29taW5nRWRnZXMsbix0KX1yZXR1cm4gVlIoZSxuLHIsdCl9ZnVuY3Rpb24gbG5lKGUsbil7c3dpdGNoKG4pe2Nhc2UgNzpyZXR1cm4hIWUub3V0Z29pbmdFZGdlcyYmZS5vdXRnb2luZ0VkZ2VzLnNpemVfMCE9MDtjYXNlIDg6cmV0dXJuISFlLmluY29taW5nRWRnZXMmJmUuaW5jb21pbmdFZGdlcy5zaXplXzAhPTB9cmV0dXJuIG5uZShlLG4pfWZ1bmN0aW9uIHNuZShlLG4scil7c3dpdGNoKG4pe2Nhc2UgNzohZS5vdXRnb2luZ0VkZ2VzJiYoZS5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixlLDcsNCkpLGZuKGUub3V0Z29pbmdFZGdlcyksIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxQcihlLm91dGdvaW5nRWRnZXMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgODohZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGZuKGUuaW5jb21pbmdFZGdlcyksIWUuaW5jb21pbmdFZGdlcyYmKGUuaW5jb21pbmdFZGdlcz1uZXcgTGUoTXIsZSw4LDUpKSxQcihlLmluY29taW5nRWRnZXMsYShyLDE2KSk7cmV0dXJufXJuZShlLG4scil9ZnVuY3Rpb24gdW5lKGUsbil7c3dpdGNoKG4pe2Nhc2UgNzohZS5vdXRnb2luZ0VkZ2VzJiYoZS5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcixlLDcsNCkpLGZuKGUub3V0Z29pbmdFZGdlcyk7cmV0dXJuO2Nhc2UgODohZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGZuKGUuaW5jb21pbmdFZGdlcyk7cmV0dXJufXRuZShlLG4pfWZ1bmN0aW9uIGckZSgpe31wKDc0MSw3NDAsezExMDoxLDM0MjoxLDg0OjEsMTY3OjEsNDIyOjEsOTY6MSw5NDoxLDkzOjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTE5OjEsMTIwOjF9KSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3JldHVybiBvbmUodGhpcyxuLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIGluZSh0aGlzLG4scix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gYW5lKHRoaXMsbixyLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXtyZXR1cm4gbG5lKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3NuZSh0aGlzLG4scil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIEtvKCksaSRlfSxsLmVVbnNldD1mdW5jdGlvbihuKXt1bmUodGhpcyxuKX0sbC5nZXRJbmNvbWluZ0VkZ2VzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pbmNvbWluZ0VkZ2VzJiYodGhpcy5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcix0aGlzLDgsNSkpLHRoaXMuaW5jb21pbmdFZGdlc30sbC5nZXRPdXRnb2luZ0VkZ2VzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5vdXRnb2luZ0VkZ2VzJiYodGhpcy5vdXRnb2luZ0VkZ2VzPW5ldyBMZShNcix0aGlzLDcsNCkpLHRoaXMub3V0Z29pbmdFZGdlc30sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmltcGwiLCJFbGtDb25uZWN0YWJsZVNoYXBlSW1wbCIsNzQxKTtmdW5jdGlvbiBjbmUoZSxuLHIpe3JldHVybiByPUdhKGUsbiwzLHIpLHJ9ZnVuY3Rpb24gX25lKGUsbil7dmFyIHIsdDtyZXR1cm4gZS5lRmxhZ3NfMD4+MTY9PTM/ZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsMTIsVW4sbik6KHQ9R3QoYShrZSgocj1hKEJlKGUsMTYpLDI5KSxyfHwoS28oKSxEZWUpKSxlLmVGbGFnc18wPj4xNiksMTkpKSxlLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSx0LmZlYXR1cmVJRCx0LmNvbnRhaW5lckNsYXNzLG4pKX1mdW5jdGlvbiBRVChlKXtyZXR1cm4gZS5lRmxhZ3NfMD4+MTYhPTM/bnVsbDphKGUuZUNvbnRhaW5lciwyNyl9ZnVuY3Rpb24gbXZuKGUpe3JldHVybiFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzfWZ1bmN0aW9uIGRuZShlKXtyZXR1cm4hZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0c31mdW5jdGlvbiBsUyhlKXt2YXIgbixyLHQsbztmb3Iobj1udWxsLHQ9UHUoTmEoUChJKHhhLDEpLE1lLDIwLDAsWyghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcyksKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzKV0pKSk7X24odCk7KWlmKHI9YSh0bih0KSw4NCksbz15byhyKSwhbiluPXlyKG8pO2Vsc2UgaWYobiE9eXIobykpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYmQoZSl7dmFyIG4scix0LG87Zm9yKG49bnVsbCx0PVB1KE5hKFAoSSh4YSwxKSxNZSwyMCwwLFsoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLCghZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cyldKSkpO19uKHQpOylpZihyPWEodG4odCksODQpLG89eW8ociksIW4pbj1vO2Vsc2UgaWYobiE9bylyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBSQShlLG4pe3ZhciByLHQ7aWYobiE9ZS5lQ29udGFpbmVyfHxlLmVGbGFnc18wPj4xNiE9MyYmbil7aWYoZjIoZSxuKSl0aHJvdyBiKG5ldyBHZSgiUmVjdXJzaXZlIGNvbnRhaW5tZW50IG5vdCBhbGxvd2VkIGZvciAiK2gkZShlKSkpO3Q9bnVsbCxlLmVDb250YWluZXImJih0PShyPWUuZUZsYWdzXzA+PjE2LHI+PTA/X25lKGUsdCk6ZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsLTEtcixudWxsLHQpKSksbiYmKHQ9aG0obixlLDEyLHQpKSx0PWNuZShlLG4sdCksdCYmdC5kaXNwYXRjaF8wKCl9ZWxzZSBlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDMsbixuKSl9ZnVuY3Rpb24gaCRlKGUpe3ZhciBuLHIsdCxvO3JldHVybiBlLmVGbGFnc18wJjY0P3FSKGUpOihuPW5ldyBMYSgiRWxrRWRnZSIpLHQ9ZS5pZGVudGlmaWVyLHQ/T24oT24oKG4uc3RyaW5nKz0nICInLG4pLHQpLCciJyk6KCFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksZS5sYWJlbHMuc2l6ZV8wPjAmJihvPSghZS5sYWJlbHMmJihlLmxhYmVscz1uZXcgVShRdCxlLDEsNykpLGEoTyhlLmxhYmVscywwKSwxMzUpKS50ZXh0XzAsIW98fE9uKE9uKChuLnN0cmluZys9JyAiJyxuKSxvKSwnIicpKSkscj0oIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSwhKGUuc291cmNlcy5zaXplXzA8PTEmJighZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cy5zaXplXzA8PTEpKSkscj9uLnN0cmluZys9IiBbIjpuLnN0cmluZys9IiAiLE9uKG4sbHoobmV3IHg2LG5ldyBZZShlLnNvdXJjZXMpKSksciYmKG4uc3RyaW5nKz0iXSIpLG4uc3RyaW5nKz0iIC0+ICIsciYmKG4uc3RyaW5nKz0iWyIpLE9uKG4sbHoobmV3IHg2LG5ldyBZZShlLnRhcmdldHMpKSksciYmKG4uc3RyaW5nKz0iXSIpLG4uc3RyaW5nKX1mdW5jdGlvbiBLUigpe31wKDMyNiw3MzksezExMDoxLDM0MjoxLDc0OjEsMTY3OjEsMzI2OjEsOTY6MSw5NDoxLDkzOjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTE5OjEsMTIwOjF9LEtSKSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBfbmUodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtzd2l0Y2gobil7Y2FzZSAzOnJldHVybiBRVCh0aGlzKTtjYXNlIDQ6cmV0dXJuIXRoaXMuc291cmNlcyYmKHRoaXMuc291cmNlcz1uZXcgTGUoYW4sdGhpcyw0LDcpKSx0aGlzLnNvdXJjZXM7Y2FzZSA1OnJldHVybiF0aGlzLnRhcmdldHMmJih0aGlzLnRhcmdldHM9bmV3IExlKGFuLHRoaXMsNSw4KSksdGhpcy50YXJnZXRzO2Nhc2UgNjpyZXR1cm4hdGhpcy5zZWN0aW9ucyYmKHRoaXMuc2VjdGlvbnM9bmV3IFUoZ3IsdGhpcyw2LDYpKSx0aGlzLnNlY3Rpb25zO2Nhc2UgNzpyZXR1cm4gemUoKSwhdGhpcy5zb3VyY2VzJiYodGhpcy5zb3VyY2VzPW5ldyBMZShhbix0aGlzLDQsNykpLCEodGhpcy5zb3VyY2VzLnNpemVfMDw9MSYmKCF0aGlzLnRhcmdldHMmJih0aGlzLnRhcmdldHM9bmV3IExlKGFuLHRoaXMsNSw4KSksdGhpcy50YXJnZXRzLnNpemVfMDw9MSkpO2Nhc2UgODpyZXR1cm4gemUoKSwhIWxTKHRoaXMpO2Nhc2UgOTpyZXR1cm4gemUoKSwhIWJkKHRoaXMpO2Nhc2UgMTA6cmV0dXJuIHplKCksIXRoaXMuc291cmNlcyYmKHRoaXMuc291cmNlcz1uZXcgTGUoYW4sdGhpcyw0LDcpKSx0aGlzLnNvdXJjZXMuc2l6ZV8wIT0wJiYoIXRoaXMudGFyZ2V0cyYmKHRoaXMudGFyZ2V0cz1uZXcgTGUoYW4sdGhpcyw1LDgpKSx0aGlzLnRhcmdldHMuc2l6ZV8wIT0wKX1yZXR1cm4gWGVlKHRoaXMsbixyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChyKXtjYXNlIDM6cmV0dXJuIHRoaXMuZUNvbnRhaW5lciYmKHQ9KG89dGhpcy5lRmxhZ3NfMD4+MTYsbz49MD9fbmUodGhpcyx0KTp0aGlzLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUodGhpcywtMS1vLG51bGwsdCkpKSxjbmUodGhpcyxhKG4sMjcpLHQpO2Nhc2UgNDpyZXR1cm4hdGhpcy5zb3VyY2VzJiYodGhpcy5zb3VyY2VzPW5ldyBMZShhbix0aGlzLDQsNykpLGhpKHRoaXMuc291cmNlcyxuLHQpO2Nhc2UgNTpyZXR1cm4hdGhpcy50YXJnZXRzJiYodGhpcy50YXJnZXRzPW5ldyBMZShhbix0aGlzLDUsOCkpLGhpKHRoaXMudGFyZ2V0cyxuLHQpO2Nhc2UgNjpyZXR1cm4hdGhpcy5zZWN0aW9ucyYmKHRoaXMuc2VjdGlvbnM9bmV3IFUoZ3IsdGhpcyw2LDYpKSxoaSh0aGlzLnNlY3Rpb25zLG4sdCl9cmV0dXJuIGpSKHRoaXMsbixyLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3N3aXRjaChyKXtjYXNlIDM6cmV0dXJuIGNuZSh0aGlzLG51bGwsdCk7Y2FzZSA0OnJldHVybiF0aGlzLnNvdXJjZXMmJih0aGlzLnNvdXJjZXM9bmV3IExlKGFuLHRoaXMsNCw3KSksRHQodGhpcy5zb3VyY2VzLG4sdCk7Y2FzZSA1OnJldHVybiF0aGlzLnRhcmdldHMmJih0aGlzLnRhcmdldHM9bmV3IExlKGFuLHRoaXMsNSw4KSksRHQodGhpcy50YXJnZXRzLG4sdCk7Y2FzZSA2OnJldHVybiF0aGlzLnNlY3Rpb25zJiYodGhpcy5zZWN0aW9ucz1uZXcgVShncix0aGlzLDYsNikpLER0KHRoaXMuc2VjdGlvbnMsbix0KX1yZXR1cm4gVlIodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDM6cmV0dXJuISFRVCh0aGlzKTtjYXNlIDQ6cmV0dXJuISF0aGlzLnNvdXJjZXMmJnRoaXMuc291cmNlcy5zaXplXzAhPTA7Y2FzZSA1OnJldHVybiEhdGhpcy50YXJnZXRzJiZ0aGlzLnRhcmdldHMuc2l6ZV8wIT0wO2Nhc2UgNjpyZXR1cm4hIXRoaXMuc2VjdGlvbnMmJnRoaXMuc2VjdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgNzpyZXR1cm4hdGhpcy5zb3VyY2VzJiYodGhpcy5zb3VyY2VzPW5ldyBMZShhbix0aGlzLDQsNykpLCEodGhpcy5zb3VyY2VzLnNpemVfMDw9MSYmKCF0aGlzLnRhcmdldHMmJih0aGlzLnRhcmdldHM9bmV3IExlKGFuLHRoaXMsNSw4KSksdGhpcy50YXJnZXRzLnNpemVfMDw9MSkpO2Nhc2UgODpyZXR1cm4gbFModGhpcyk7Y2FzZSA5OnJldHVybiBiZCh0aGlzKTtjYXNlIDEwOnJldHVybiF0aGlzLnNvdXJjZXMmJih0aGlzLnNvdXJjZXM9bmV3IExlKGFuLHRoaXMsNCw3KSksdGhpcy5zb3VyY2VzLnNpemVfMCE9MCYmKCF0aGlzLnRhcmdldHMmJih0aGlzLnRhcmdldHM9bmV3IExlKGFuLHRoaXMsNSw4KSksdGhpcy50YXJnZXRzLnNpemVfMCE9MCl9cmV0dXJuIEplZSh0aGlzLG4pfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXtzd2l0Y2gobil7Y2FzZSAzOlJBKHRoaXMsYShyLDI3KSk7cmV0dXJuO2Nhc2UgNDohdGhpcy5zb3VyY2VzJiYodGhpcy5zb3VyY2VzPW5ldyBMZShhbix0aGlzLDQsNykpLGZuKHRoaXMuc291cmNlcyksIXRoaXMuc291cmNlcyYmKHRoaXMuc291cmNlcz1uZXcgTGUoYW4sdGhpcyw0LDcpKSxQcih0aGlzLnNvdXJjZXMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgNTohdGhpcy50YXJnZXRzJiYodGhpcy50YXJnZXRzPW5ldyBMZShhbix0aGlzLDUsOCkpLGZuKHRoaXMudGFyZ2V0cyksIXRoaXMudGFyZ2V0cyYmKHRoaXMudGFyZ2V0cz1uZXcgTGUoYW4sdGhpcyw1LDgpKSxQcih0aGlzLnRhcmdldHMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgNjohdGhpcy5zZWN0aW9ucyYmKHRoaXMuc2VjdGlvbnM9bmV3IFUoZ3IsdGhpcyw2LDYpKSxmbih0aGlzLnNlY3Rpb25zKSwhdGhpcy5zZWN0aW9ucyYmKHRoaXMuc2VjdGlvbnM9bmV3IFUoZ3IsdGhpcyw2LDYpKSxQcih0aGlzLnNlY3Rpb25zLGEociwxNikpO3JldHVybn1aZWUodGhpcyxuLHIpfSxsLmVTdGF0aWNDbGFzcz1mdW5jdGlvbigpe3JldHVybiBLbygpLERlZX0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMzpSQSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDQ6IXRoaXMuc291cmNlcyYmKHRoaXMuc291cmNlcz1uZXcgTGUoYW4sdGhpcyw0LDcpKSxmbih0aGlzLnNvdXJjZXMpO3JldHVybjtjYXNlIDU6IXRoaXMudGFyZ2V0cyYmKHRoaXMudGFyZ2V0cz1uZXcgTGUoYW4sdGhpcyw1LDgpKSxmbih0aGlzLnRhcmdldHMpO3JldHVybjtjYXNlIDY6IXRoaXMuc2VjdGlvbnMmJih0aGlzLnNlY3Rpb25zPW5ldyBVKGdyLHRoaXMsNiw2KSksZm4odGhpcy5zZWN0aW9ucyk7cmV0dXJufVFlZSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gaCRlKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguaW1wbCIsIkVsa0VkZ2VJbXBsIiwzMjYpO2Z1bmN0aW9uIGZuZShlLG4scil7cmV0dXJuIHI9R2EoZSxuLDYscikscn1mdW5jdGlvbiBwbmUoZSxuKXt2YXIgcix0O3JldHVybiBlLmVGbGFnc18wPj4xNj09Nj9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSw2LE1yLG4pOih0PUd0KGEoa2UoKHI9YShCZShlLDE2KSwyOSkscnx8KEtvKCkseEEpKSxlLmVGbGFnc18wPj4xNiksMTkpKSxlLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSx0LmZlYXR1cmVJRCx0LmNvbnRhaW5lckNsYXNzLG4pKX1mdW5jdGlvbiBYUihlKXt2YXIgbjtyZXR1cm4gZS5pbmNvbWluZ1NoYXBlJiZlLmluY29taW5nU2hhcGUuZUlzUHJveHkoKSYmKG49YShlLmluY29taW5nU2hhcGUsNTQpLGUuaW5jb21pbmdTaGFwZT1hKEowKGUsbiksODQpLGUuaW5jb21pbmdTaGFwZSE9biYmZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsOSw4LG4sZS5pbmNvbWluZ1NoYXBlKSkpLGUuaW5jb21pbmdTaGFwZX1mdW5jdGlvbiBKUihlKXt2YXIgbjtyZXR1cm4gZS5vdXRnb2luZ1NoYXBlJiZlLm91dGdvaW5nU2hhcGUuZUlzUHJveHkoKSYmKG49YShlLm91dGdvaW5nU2hhcGUsNTQpLGUub3V0Z29pbmdTaGFwZT1hKEowKGUsbiksODQpLGUub3V0Z29pbmdTaGFwZSE9biYmZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsOSw3LG4sZS5vdXRnb2luZ1NoYXBlKSkpLGUub3V0Z29pbmdTaGFwZX1mdW5jdGlvbiBtJGUoZSl7cmV0dXJuIGUuZUZsYWdzXzA+PjE2IT02P251bGw6YShlLmVDb250YWluZXIsNzQpfWZ1bmN0aW9uIGViKGUsbixyKXtSdyhlLG4pLER3KGUscil9ZnVuY3Rpb24gUncoZSxuKXt2YXIgcjtyPWUuZW5kWCxlLmVuZFg9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSwzLHIsZS5lbmRYKSl9ZnVuY3Rpb24gRHcoZSxuKXt2YXIgcjtyPWUuZW5kWSxlLmVuZFk9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSw0LHIsZS5lbmRZKSl9ZnVuY3Rpb24gZ25lKGUsbil7dmFyIHI7cj1lLmlkZW50aWZpZXIsZS5pZGVudGlmaWVyPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwxMSxyLGUuaWRlbnRpZmllcikpfWZ1bmN0aW9uIERBKGUsbil7dmFyIHI7cj1lLmluY29taW5nU2hhcGUsZS5pbmNvbWluZ1NoYXBlPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSw4LHIsZS5pbmNvbWluZ1NoYXBlKSl9ZnVuY3Rpb24gRkEoZSxuKXt2YXIgcjtyPWUub3V0Z29pbmdTaGFwZSxlLm91dGdvaW5nU2hhcGU9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDcscixlLm91dGdvaW5nU2hhcGUpKX1mdW5jdGlvbiB5JGUoZSxuKXt2YXIgcix0O2lmKG4hPWUuZUNvbnRhaW5lcnx8ZS5lRmxhZ3NfMD4+MTYhPTYmJm4pe2lmKGYyKGUsbikpdGhyb3cgYihuZXcgR2UoIlJlY3Vyc2l2ZSBjb250YWlubWVudCBub3QgYWxsb3dlZCBmb3IgIit3JGUoZSkpKTt0PW51bGwsZS5lQ29udGFpbmVyJiYodD0ocj1lLmVGbGFnc18wPj4xNixyPj0wP3BuZShlLHQpOmUuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLC0xLXIsbnVsbCx0KSkpLG4mJih0PWhtKG4sZSw2LHQpKSx0PWZuZShlLG4sdCksdCYmdC5kaXNwYXRjaF8wKCl9ZWxzZSBlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDYsbixuKSl9ZnVuY3Rpb24gbmIoZSxuLHIpe0Z3KGUsbiksencoZSxyKX1mdW5jdGlvbiBGdyhlLG4pe3ZhciByO3I9ZS5zdGFydFgsZS5zdGFydFg9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSwxLHIsZS5zdGFydFgpKX1mdW5jdGlvbiB6dyhlLG4pe3ZhciByO3I9ZS5zdGFydFksZS5zdGFydFk9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgc3AoZSwyLHIsZS5zdGFydFkpKX1mdW5jdGlvbiB3JGUoZSl7dmFyIG47cmV0dXJuIGUuZUZsYWdzXzAmNjQ/bnMoZSk6KG49bmV3IHlsKG5zKGUpKSxuLnN0cmluZys9IiAoc3RhcnRYOiAiLHhwKG4sZS5zdGFydFgpLG4uc3RyaW5nKz0iLCBzdGFydFk6ICIseHAobixlLnN0YXJ0WSksbi5zdHJpbmcrPSIsIGVuZFg6ICIseHAobixlLmVuZFgpLG4uc3RyaW5nKz0iLCBlbmRZOiAiLHhwKG4sZS5lbmRZKSxuLnN0cmluZys9IiwgaWRlbnRpZmllcjogIixKdChuLGUuaWRlbnRpZmllciksbi5zdHJpbmcrPSIpIixuLnN0cmluZyl9ZnVuY3Rpb24gekEoKXt9cCg0NTIsMjA4Myx7MTEwOjEsMzQyOjEsMTY2OjEsNDUyOjEsOTY6MSw5NDoxLDkzOjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTE5OjEsMTIwOjF9LHpBKSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBwbmUodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtzd2l0Y2gobil7Y2FzZSAxOnJldHVybiB0aGlzLnN0YXJ0WDtjYXNlIDI6cmV0dXJuIHRoaXMuc3RhcnRZO2Nhc2UgMzpyZXR1cm4gdGhpcy5lbmRYO2Nhc2UgNDpyZXR1cm4gdGhpcy5lbmRZO2Nhc2UgNTpyZXR1cm4hdGhpcy5iZW5kUG9pbnRzJiYodGhpcy5iZW5kUG9pbnRzPW5ldyBqcihCYSx0aGlzLDUpKSx0aGlzLmJlbmRQb2ludHM7Y2FzZSA2OnJldHVybiBtJGUodGhpcyk7Y2FzZSA3OnJldHVybiByP0pSKHRoaXMpOnRoaXMub3V0Z29pbmdTaGFwZTtjYXNlIDg6cmV0dXJuIHI/WFIodGhpcyk6dGhpcy5pbmNvbWluZ1NoYXBlO2Nhc2UgOTpyZXR1cm4hdGhpcy5vdXRnb2luZ1NlY3Rpb25zJiYodGhpcy5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0aGlzLDksMTApKSx0aGlzLm91dGdvaW5nU2VjdGlvbnM7Y2FzZSAxMDpyZXR1cm4hdGhpcy5pbmNvbWluZ1NlY3Rpb25zJiYodGhpcy5pbmNvbWluZ1NlY3Rpb25zPW5ldyBMZShncix0aGlzLDEwLDkpKSx0aGlzLmluY29taW5nU2VjdGlvbnM7Y2FzZSAxMTpyZXR1cm4gdGhpcy5pZGVudGlmaWVyfXJldHVybiBqZWUodGhpcyxuLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzO3N3aXRjaChyKXtjYXNlIDY6cmV0dXJuIHRoaXMuZUNvbnRhaW5lciYmKHQ9KGk9dGhpcy5lRmxhZ3NfMD4+MTYsaT49MD9wbmUodGhpcyx0KTp0aGlzLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUodGhpcywtMS1pLG51bGwsdCkpKSxmbmUodGhpcyxhKG4sNzQpLHQpO2Nhc2UgOTpyZXR1cm4hdGhpcy5vdXRnb2luZ1NlY3Rpb25zJiYodGhpcy5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0aGlzLDksMTApKSxoaSh0aGlzLm91dGdvaW5nU2VjdGlvbnMsbix0KTtjYXNlIDEwOnJldHVybiF0aGlzLmluY29taW5nU2VjdGlvbnMmJih0aGlzLmluY29taW5nU2VjdGlvbnM9bmV3IExlKGdyLHRoaXMsMTAsOSkpLGhpKHRoaXMuaW5jb21pbmdTZWN0aW9ucyxuLHQpfXJldHVybiBzPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KEtvKCkseEEpKSxyKSw2OSkscy5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZUFkZCh0aGlzLFNpKHRoaXMpLHItb24oKEtvKCkseEEpKSxuLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3N3aXRjaChyKXtjYXNlIDU6cmV0dXJuIXRoaXMuYmVuZFBvaW50cyYmKHRoaXMuYmVuZFBvaW50cz1uZXcganIoQmEsdGhpcyw1KSksRHQodGhpcy5iZW5kUG9pbnRzLG4sdCk7Y2FzZSA2OnJldHVybiBmbmUodGhpcyxudWxsLHQpO2Nhc2UgOTpyZXR1cm4hdGhpcy5vdXRnb2luZ1NlY3Rpb25zJiYodGhpcy5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0aGlzLDksMTApKSxEdCh0aGlzLm91dGdvaW5nU2VjdGlvbnMsbix0KTtjYXNlIDEwOnJldHVybiF0aGlzLmluY29taW5nU2VjdGlvbnMmJih0aGlzLmluY29taW5nU2VjdGlvbnM9bmV3IExlKGdyLHRoaXMsMTAsOSkpLER0KHRoaXMuaW5jb21pbmdTZWN0aW9ucyxuLHQpfXJldHVybiBWZWUodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDE6cmV0dXJuIHRoaXMuc3RhcnRYIT0wO2Nhc2UgMjpyZXR1cm4gdGhpcy5zdGFydFkhPTA7Y2FzZSAzOnJldHVybiB0aGlzLmVuZFghPTA7Y2FzZSA0OnJldHVybiB0aGlzLmVuZFkhPTA7Y2FzZSA1OnJldHVybiEhdGhpcy5iZW5kUG9pbnRzJiZ0aGlzLmJlbmRQb2ludHMuc2l6ZV8wIT0wO2Nhc2UgNjpyZXR1cm4hIW0kZSh0aGlzKTtjYXNlIDc6cmV0dXJuISF0aGlzLm91dGdvaW5nU2hhcGU7Y2FzZSA4OnJldHVybiEhdGhpcy5pbmNvbWluZ1NoYXBlO2Nhc2UgOTpyZXR1cm4hIXRoaXMub3V0Z29pbmdTZWN0aW9ucyYmdGhpcy5vdXRnb2luZ1NlY3Rpb25zLnNpemVfMCE9MDtjYXNlIDEwOnJldHVybiEhdGhpcy5pbmNvbWluZ1NlY3Rpb25zJiZ0aGlzLmluY29taW5nU2VjdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTE6cmV0dXJuIHRoaXMuaWRlbnRpZmllciE9bnVsbH1yZXR1cm4gcWVlKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3N3aXRjaChuKXtjYXNlIDE6RncodGhpcyxSKCQocikpKTtyZXR1cm47Y2FzZSAyOnp3KHRoaXMsUigkKHIpKSk7cmV0dXJuO2Nhc2UgMzpSdyh0aGlzLFIoJChyKSkpO3JldHVybjtjYXNlIDQ6RHcodGhpcyxSKCQocikpKTtyZXR1cm47Y2FzZSA1OiF0aGlzLmJlbmRQb2ludHMmJih0aGlzLmJlbmRQb2ludHM9bmV3IGpyKEJhLHRoaXMsNSkpLGZuKHRoaXMuYmVuZFBvaW50cyksIXRoaXMuYmVuZFBvaW50cyYmKHRoaXMuYmVuZFBvaW50cz1uZXcganIoQmEsdGhpcyw1KSksUHIodGhpcy5iZW5kUG9pbnRzLGEociwxNikpO3JldHVybjtjYXNlIDY6eSRlKHRoaXMsYShyLDc0KSk7cmV0dXJuO2Nhc2UgNzpGQSh0aGlzLGEociw4NCkpO3JldHVybjtjYXNlIDg6REEodGhpcyxhKHIsODQpKTtyZXR1cm47Y2FzZSA5OiF0aGlzLm91dGdvaW5nU2VjdGlvbnMmJih0aGlzLm91dGdvaW5nU2VjdGlvbnM9bmV3IExlKGdyLHRoaXMsOSwxMCkpLGZuKHRoaXMub3V0Z29pbmdTZWN0aW9ucyksIXRoaXMub3V0Z29pbmdTZWN0aW9ucyYmKHRoaXMub3V0Z29pbmdTZWN0aW9ucz1uZXcgTGUoZ3IsdGhpcyw5LDEwKSksUHIodGhpcy5vdXRnb2luZ1NlY3Rpb25zLGEociwxNikpO3JldHVybjtjYXNlIDEwOiF0aGlzLmluY29taW5nU2VjdGlvbnMmJih0aGlzLmluY29taW5nU2VjdGlvbnM9bmV3IExlKGdyLHRoaXMsMTAsOSkpLGZuKHRoaXMuaW5jb21pbmdTZWN0aW9ucyksIXRoaXMuaW5jb21pbmdTZWN0aW9ucyYmKHRoaXMuaW5jb21pbmdTZWN0aW9ucz1uZXcgTGUoZ3IsdGhpcywxMCw5KSksUHIodGhpcy5pbmNvbWluZ1NlY3Rpb25zLGEociwxNikpO3JldHVybjtjYXNlIDExOmduZSh0aGlzLHhuKHIpKTtyZXR1cm59WWVlKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSx4QX0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMTpGdyh0aGlzLDApO3JldHVybjtjYXNlIDI6encodGhpcywwKTtyZXR1cm47Y2FzZSAzOlJ3KHRoaXMsMCk7cmV0dXJuO2Nhc2UgNDpEdyh0aGlzLDApO3JldHVybjtjYXNlIDU6IXRoaXMuYmVuZFBvaW50cyYmKHRoaXMuYmVuZFBvaW50cz1uZXcganIoQmEsdGhpcyw1KSksZm4odGhpcy5iZW5kUG9pbnRzKTtyZXR1cm47Y2FzZSA2OnkkZSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDc6RkEodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA4OkRBKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgOTohdGhpcy5vdXRnb2luZ1NlY3Rpb25zJiYodGhpcy5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0aGlzLDksMTApKSxmbih0aGlzLm91dGdvaW5nU2VjdGlvbnMpO3JldHVybjtjYXNlIDEwOiF0aGlzLmluY29taW5nU2VjdGlvbnMmJih0aGlzLmluY29taW5nU2VjdGlvbnM9bmV3IExlKGdyLHRoaXMsMTAsOSkpLGZuKHRoaXMuaW5jb21pbmdTZWN0aW9ucyk7cmV0dXJuO2Nhc2UgMTE6Z25lKHRoaXMsbnVsbCk7cmV0dXJufUtlZSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdyRlKHRoaXMpfSxsLmVuZFg9MCxsLmVuZFk9MCxsLmlkZW50aWZpZXI9bnVsbCxsLnN0YXJ0WD0wLGwuc3RhcnRZPTAsZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmltcGwiLCJFbGtFZGdlU2VjdGlvbkltcGwiLDQ1Mik7ZnVuY3Rpb24gaG5lKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrO2lmKGg9bi5sZW5ndGgsaD4wJiYoYz0oSGUoMCxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KDApKSxjIT02NCkpe2lmKGM9PTM3JiYoZj1uLmxhc3RJbmRleE9mKCIlIiksXz0hMSxmIT0wJiYoZj09aC0xfHwoXz0oSGUoZisxLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoZisxKT09NDYpKSkpKXtpZihzPShndCgxLGYsbi5sZW5ndGgpLG4uc3Vic3RyKDEsZi0xKSksaz1UZSgiJSIscyk/bnVsbDp2cmUocyksdD0wLF8pdHJ5e3Q9QWEoKEhlKGYrMixuLmxlbmd0aCsxKSxuLnN1YnN0cihmKzIpKSxidCxxbil9Y2F0Y2goTSl7dGhyb3cgTT13cihNKSxMKE0sMTMwKT8odT1NLGIobmV3IGRMKHUpKSk6YihNKX1mb3Iodj1udGUoZS5lQ29udGVudHNfMCgpKTt2Lmhhc05leHRfMCgpOylpZih5PUFMKHYpLEwoeSw1MTkpJiYobz1hKHksNTk4KSxBPW8uc291cmNlLChrPT1udWxsP0E9PW51bGw6VGUoayxBKSkmJnQtLT09MCkpcmV0dXJuIG87cmV0dXJuIG51bGx9aWYoZD1uLmxhc3RJbmRleE9mKCIuIiksbT1kPT0tMT9uOihndCgwLGQsbi5sZW5ndGgpLG4uc3Vic3RyKDAsZCkpLHI9MCxkIT0tMSl0cnl7cj1BYSgoSGUoZCsxLG4ubGVuZ3RoKzEpLG4uc3Vic3RyKGQrMSkpLGJ0LHFuKX1jYXRjaChNKXtpZihNPXdyKE0pLEwoTSwxMzApKW09bjtlbHNlIHRocm93IGIoTSl9Zm9yKG09VGUoIiUiLG0pP251bGw6dnJlKG0pLEU9bnRlKGUuZUNvbnRlbnRzXzAoKSk7RS5oYXNOZXh0XzAoKTspaWYoeT1BTChFKSxMKHksMTk3KSYmKGk9YSh5LDE5NykseD1pLmdldE5hbWUoKSwobT09bnVsbD94PT1udWxsOlRlKG0seCkpJiZyLS09PTApKXJldHVybiBpO3JldHVybiBudWxsfXJldHVybiBjJGUoZSxuKX1mdW5jdGlvbiByYihlKXtMKGUsMTU4KSYmYShlLDE1OCkuZnJlZXplKCl9ZnVuY3Rpb24gc1MoZSxuKXt2YXIgcix0LG8saSxzO2lmKGUuZUFubm90YXRpb25zKXtpZihlLmVBbm5vdGF0aW9ucyl7aWYocz1lLmVBbm5vdGF0aW9ucy5zaXplXzAscz4wKXtpZihvPWEoZS5lQW5ub3RhdGlvbnMuZGF0YV8wLDIwMzMpLG49PW51bGwpe2ZvcihpPTA7aTxzOysraSlpZihyPW9baV0sci5zb3VyY2U9PW51bGwpcmV0dXJuIHJ9ZWxzZSBmb3IoaT0wO2k8czsrK2kpaWYocj1vW2ldLFRlKG4sci5zb3VyY2UpKXJldHVybiByfX1lbHNlIGlmKG49PW51bGwpe2Zvcih0PW5ldyBZZShlLmVBbm5vdGF0aW9ucyk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylpZihyPWEoZW4odCksNTk4KSxyLnNvdXJjZT09bnVsbClyZXR1cm4gcn1lbHNlIGZvcih0PW5ldyBZZShlLmVBbm5vdGF0aW9ucyk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylpZihyPWEoZW4odCksNTk4KSxUZShuLHIuc291cmNlKSlyZXR1cm4gcn1yZXR1cm4gbnVsbH1wKDE1OCwxMjAsezExMDoxLDk0OjEsOTM6MSwxNTU6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwxNTg6MSwxMTk6MSwxMjA6MX0pLGwuZUdldD1mdW5jdGlvbihuLHIsdCl7dmFyIG87cmV0dXJuIG49PTA/KCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnMpOmxsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7cmV0dXJuIHI9PTA/KCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksaGkodGhpcy5lQW5ub3RhdGlvbnMsbix0KSk6KGk9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxyKSw2OSksaS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZUFkZCh0aGlzLFNpKHRoaXMpLHItb24odGhpcy5lU3RhdGljQ2xhc3MoKSksbix0KSl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtyZXR1cm4gcj09MD8oIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxEdCh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpKTooaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fHRoaXMuZVN0YXRpY0NsYXNzKCkpLHIpLDY5KSxpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlUmVtb3ZlKHRoaXMsU2kodGhpcyksci1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxuLHQpKX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIG49PTA/ISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wOnNsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSl9LGwuZU9iamVjdEZvclVSSUZyYWdtZW50U2VnbWVudD1mdW5jdGlvbihuKXtyZXR1cm4gaG5lKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0O3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyksIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxQcih0aGlzLmVBbm5vdGF0aW9ucyxhKHIsMTYpKTtyZXR1cm59dWwodGhpcyxuLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4pLHIpfSxsLmVTZXREaXJlY3RSZXNvdXJjZT1mdW5jdGlvbihuKXttbSh0aGlzLDEyOCxuKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxMSGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJufWNsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSl9LGwuZnJlZXplPWZ1bmN0aW9uKCl7dGhpcy5lRmxhZ3N8PTF9LGwuZ2V0RUFubm90YXRpb249ZnVuY3Rpb24obil7cmV0dXJuIHNTKHRoaXMsbil9LGwuZUZsYWdzPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFTW9kZWxFbGVtZW50SW1wbCIsMTU4KTtmdW5jdGlvbiAkQSgpeyRBPUYsRW5lPVAoSShmbCwxKSxYcywyOCwxNSxbNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNjUsNjYsNjcsNjgsNjksNzBdKSxTJGU9bmV3IFJlZ0V4cChgWyAJClxyXGZdK2ApO3RyeXt1Uz1QKEkodzNuLDEpLE1lLDIxMTQsMCxbbmV3IEViKChFJCgpLE1JKCJ5eXl5LU1NLWRkJ1QnSEg6bW06c3MnLidTU1NaIixkQygoUkkoKSxSSSgpLE8yKSkpKSksbmV3IEViKE1JKCJ5eXl5LU1NLWRkJ1QnSEg6bW06c3MnLidTU1MiLGRDKE8yKSkpLG5ldyBFYihNSSgieXl5eS1NTS1kZCdUJ0hIOm1tOnNzIixkQyhPMikpKSxuZXcgRWIoTUkoInl5eXktTU0tZGQnVCdISDptbSIsZEMoTzIpKSksbmV3IEViKE1JKCJ5eXl5LU1NLWRkIixkQyhPMikpKV0pfWNhdGNoKGUpe2lmKGU9d3IoZSksIUwoZSw4MikpdGhyb3cgYihlKX19ZnVuY3Rpb24gbW5lKGUsbixyKXt2YXIgdCxvO3JldHVybiBvPWUuZVBhY2thZ2UsZS5lUGFja2FnZT1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiYodD1uZXcgbHQoZSwxLDEsbyxuKSxyP3IuYWRkXzUodCk6cj10KSxyfWZ1bmN0aW9uIHl2bihlLG4pe3ZhciByLHQsbyxpLHM7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtmb3Iocz1CKGZsLFhzLDI4LDIqbiwxNSwxKSx0PTAsbz0wO3Q8bjsrK3Qpcj1lW3RdPj40JjE1LGk9ZVt0XSYxNSxzW28rK109RW5lW3JdLHNbbysrXT1FbmVbaV07cmV0dXJuIGl1KHMsMCxzLmxlbmd0aCl9ZnVuY3Rpb24gRSRlKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGY7aWYoZS5lUGFja2FnZSE9bi5nZXRFUGFja2FnZSgpKXRocm93IGIobmV3IEdlKCJUaGUgZGF0YXR5cGUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKTtpZih0PWQwKChLaSgpLFR0KSxuKS5nZXRCYXNlVHlwZSgpLHQpcmV0dXJuIHQuZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCkuY29udmVydFRvU3RyaW5nKHQscik7aWYocz1kMChUdCxuKS5nZXRJdGVtVHlwZSgpLHMpe2lmKHI9PW51bGwpcmV0dXJuIG51bGw7aWYodT1hKHIsMTUpLHUuaXNFbXB0eSgpKXJldHVybiIiO2ZvcihmPW5ldyBMYyxpPXUuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KW89aS5uZXh0XzEoKSxKdChmLHMuZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCkuY29udmVydFRvU3RyaW5nKHMsbykpLGYuc3RyaW5nKz0iICI7cmV0dXJuIEE1KGYsZi5zdHJpbmcubGVuZ3RoLTEpfWlmKGQ9ZDAoVHQsbikuZ2V0TWVtYmVyVHlwZXMoKSwhZC5pc0VtcHR5KCkpe2ZvcihfPWQuaXRlcmF0b3JfMCgpO18uaGFzTmV4dF8wKCk7KWlmKGM9YShfLm5leHRfMSgpLDE1NiksYy5pc0luc3RhbmNlKHIpKXRyeXtpZihmPWMuZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCkuY29udmVydFRvU3RyaW5nKGMsciksZiE9bnVsbClyZXR1cm4gZn1jYXRjaChoKXtpZihoPXdyKGgpLCFMKGgsMTAzKSl0aHJvdyBiKGgpfXRocm93IGIobmV3IEdlKCJJbnZhbGlkIHZhbHVlOiAnIityKyInIGZvciBkYXRhdHlwZSA6IituLmdldE5hbWUoKSkpfXJldHVybiBhKG4sODQ3KS5nZXRDb252ZXJzaW9uRGVsZWdhdGUoKSxyPT1udWxsP251bGw6TChyLDE4MCk/IiIrYShyLDE4MCkudmFsdWVfMDp3YShyKT09ekk/SVVlKHVTWzBdLGEociwyMDYpKTp2byhyKX1mdW5jdGlvbiBJZChlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdjtpZihyPT1udWxsKXJldHVybiBudWxsO2lmKGUuZVBhY2thZ2UhPW4uZ2V0RVBhY2thZ2UoKSl0aHJvdyBiKG5ldyBHZSgiVGhlIGRhdGF0eXBlICciK24uZ2V0TmFtZSgpKyInIGlzIG5vdCBhIHZhbGlkIGNsYXNzaWZpZXIiKSk7aWYoTChuLDQ2OSkpe2lmKHY9bTNuKGEobiw2ODUpLHIpLCF2KXRocm93IGIobmV3IEdlKCJUaGUgdmFsdWUgJyIrcisiJyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdG9yIG9mICciK24uZ2V0TmFtZSgpKyInIikpO3JldHVybiB2fXN3aXRjaChkMCgoS2koKSxUdCksbikuZ2V0V2hpdGVTcGFjZUZhY2V0KCkpe2Nhc2UgMjp7cj1jaShyLCExKTticmVha31jYXNlIDM6e3I9Y2kociwhMCk7YnJlYWt9fWlmKHQ9ZDAoVHQsbikuZ2V0QmFzZVR5cGUoKSx0KXJldHVybiB0LmdldEVQYWNrYWdlKCkuZ2V0RUZhY3RvcnlJbnN0YW5jZSgpLmNyZWF0ZUZyb21TdHJpbmcodCxyKTtpZihoPWQwKFR0LG4pLmdldEl0ZW1UeXBlKCksaCl7Zm9yKHY9bmV3IFEsXz1aUihyKSxkPTAsZj1fLmxlbmd0aDtkPGY7KytkKWM9X1tkXSxlZSh2LGguZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCkuY3JlYXRlRnJvbVN0cmluZyhoLGMpKTtyZXR1cm4gdn1pZihFPWQwKFR0LG4pLmdldE1lbWJlclR5cGVzKCksIUUuaXNFbXB0eSgpKXtmb3IoeT1FLml0ZXJhdG9yXzAoKTt5Lmhhc05leHRfMCgpOyl7bT1hKHkubmV4dF8xKCksMTU2KTt0cnl7aWYodj1tLmdldEVQYWNrYWdlKCkuZ2V0RUZhY3RvcnlJbnN0YW5jZSgpLmNyZWF0ZUZyb21TdHJpbmcobSxyKSx2IT1udWxsKXJldHVybiB2fWNhdGNoKHgpe2lmKHg9d3IoeCksIUwoeCw2MykpdGhyb3cgYih4KX19dGhyb3cgYihuZXcgR2UoIlRoZSB2YWx1ZSAnIityKyInIGRvZXMgbm90IG1hdGNoIGFueSBtZW1iZXIgdHlwZXMgb2YgdGhlIHVuaW9uIGRhdGF0eXBlICciK24uZ2V0TmFtZSgpKyInIikpfWlmKGEobiw4NDcpLmdldENvbnZlcnNpb25EZWxlZ2F0ZSgpLG89dmJuKG4uZ2V0SW5zdGFuY2VDbGFzcygpKSwhbylyZXR1cm4gbnVsbDtpZihvPT1GMil7cz0wO3RyeXtzPUFhKHIsYnQscW4pJnpyfWNhdGNoKHgpe2lmKHg9d3IoeCksTCh4LDEzMCkpaT1WSShyKSxzPWlbMF07ZWxzZSB0aHJvdyBiKHgpfXJldHVybiB2QyhzKX1pZihvPT16SSl7Zm9yKHU9MDt1PHVTLmxlbmd0aDsrK3UpdHJ5e3JldHVybiB4VWUodVNbdV0scil9Y2F0Y2goeCl7aWYoeD13cih4KSwhTCh4LDMzKSl0aHJvdyBiKHgpfXRocm93IGIobmV3IEdlKCJUaGUgdmFsdWUgJyIrcisiJyBpcyBub3QgYSBkYXRlIGZvcm1hdHRlZCBzdHJpbmcgb2YgdGhlIGZvcm0geXl5eS1NTS1kZCdUJ0hIOm1tOnNzJy4nU1NTWiBvciBhIHZhbGlkIHN1YnNldCB0aGVyZW9mIikpfXRocm93IGIobmV3IEdlKCJUaGUgdmFsdWUgJyIrcisiJyBpcyBpbnZhbGlkLiAiKSl9ZnVuY3Rpb24gd3ZuKGUpe3ZhciBuLHIsdCxvLGkscyx1O2lmKGU9PW51bGwpcmV0dXJuIG51bGw7Zm9yKHU9ZS5sZW5ndGgsbz0odSsxKS8yfDAscz1CKEppLHdwLDI4LG8sMTUsMSksdSUyIT0wJiYoc1stLW9dPXduZSgoSGUodS0xLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodS0xKSkpKSxyPTAsdD0wO3I8bzsrK3Ipbj13bmUoSXQoZSx0KyspKSxpPXduZShJdChlLHQrKykpLHNbcl09KG48PDR8aSk8PDI0Pj4yNDtyZXR1cm4gc31mdW5jdGlvbiB2JGUoZSxuKXt2YXIgcjtuIT1lLmVQYWNrYWdlPyhyPW51bGwsZS5lUGFja2FnZSYmKHI9YShlLmVQYWNrYWdlLDU0KS5lSW52ZXJzZVJlbW92ZShlLDQseXMscikpLG4mJihyPWEobiw1NCkuZUludmVyc2VBZGQoZSw0LHlzLHIpKSxyPW1uZShlLG4sciksciYmci5kaXNwYXRjaF8wKCkpOmUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMSxuLG4pKX1mdW5jdGlvbiBaUihlKXt2YXIgbixyLHQsbztmb3Iobz1RSmUoUyRlLGUpLHI9by5sZW5ndGgsdD1CKHNlLFgsMixyLDYsMSksbj0wO248cjsrK24pdFtuXT1vW25dO3JldHVybiB0fWZ1bmN0aW9uIHluZSgpeyRBKCl9ZnVuY3Rpb24gd25lKGUpe3N3aXRjaChlKXtjYXNlIDQ4OmNhc2UgNDk6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTI6Y2FzZSA1MzpjYXNlIDU0OmNhc2UgNTU6Y2FzZSA1NjpjYXNlIDU3OnJldHVybiBlLTQ4PDwyND4+MjQ7Y2FzZSA5NzpjYXNlIDk4OmNhc2UgOTk6Y2FzZSAxMDA6Y2FzZSAxMDE6Y2FzZSAxMDI6cmV0dXJuIGUtOTcrMTA8PDI0Pj4yNDtjYXNlIDY1OmNhc2UgNjY6Y2FzZSA2NzpjYXNlIDY4OmNhc2UgNjk6Y2FzZSA3MDpyZXR1cm4gZS02NSsxMDw8MjQ+PjI0O2RlZmF1bHQ6dGhyb3cgYihuZXcgdHUoIkludmFsaWQgaGV4YWRlY2ltYWwiKSl9fXAoNzIwLDE1OCx7MTEwOjEsOTQ6MSw5MzoxLDQ4MDoxLDE1NToxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDE1ODoxLDExOToxLDEyMDoxfSx5bmUpLGwuY29udmVydFRvU3RyaW5nPWZ1bmN0aW9uKG4scil7cmV0dXJuIEUkZSh0aGlzLG4scil9LGwuY3JlYXRlXzM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscztpZih0aGlzLmVQYWNrYWdlIT1IYShuKXx8bi5lRmxhZ3MmMjU2KXRocm93IGIobmV3IEdlKCJUaGUgY2xhc3MgJyIrbi5uYW1lXzArIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKTtmb3Iobz13byhuKTtRbyhvLnRoaXMkMDEpLnNpemVfMCE9MDspe2lmKHQ9YSh3YihvLDAsKHI9YShPKFFvKG8udGhpcyQwMSksMCksODkpLHM9ci5lUmF3VHlwZSxMKHMsOTApP2EocywyOSk6KFBlKCksTmwpKSksMjkpLGtkKHQpKXJldHVybiBpPUhhKHQpLmdldEVGYWN0b3J5SW5zdGFuY2UoKS5jcmVhdGVfMyh0KSxhKGksNTQpLmVTZXRDbGFzcyhuKSxpO289d28odCl9cmV0dXJuKG4uaW5zdGFuY2VDbGFzc05hbWUhPW51bGw/bi5pbnN0YW5jZUNsYXNzTmFtZTpuLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lKT09ImphdmEudXRpbC5NYXAkRW50cnkiP25ldyBCSGUobik6bmV3IGtyZShuKX0sbC5jcmVhdGVGcm9tU3RyaW5nPWZ1bmN0aW9uKG4scil7cmV0dXJuIElkKHRoaXMsbixyKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbztzd2l0Y2gobil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnM7Y2FzZSAxOnJldHVybiB0aGlzLmVQYWNrYWdlfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCksaV8pKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHxpXyksbikscix0KX0sbC5lSW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxoaSh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgMTpyZXR1cm4gdGhpcy5lUGFja2FnZSYmKHQ9YSh0aGlzLmVQYWNrYWdlLDU0KS5lSW52ZXJzZVJlbW92ZSh0aGlzLDQseXMsdCkpLG1uZSh0aGlzLGEobiwyNDEpLHQpfXJldHVybiBpPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KFBlKCksaV8pKSxyKSw2OSksaS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZUFkZCh0aGlzLFNpKHRoaXMpLHItb24oKFBlKCksaV8pKSxuLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLER0KHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSAxOnJldHVybiBtbmUodGhpcyxudWxsLHQpfXJldHVybiBpPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KFBlKCksaV8pKSxyKSw2OSksaS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZVJlbW92ZSh0aGlzLFNpKHRoaXMpLHItb24oKFBlKCksaV8pKSxuLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiEhdGhpcy5lQW5ub3RhdGlvbnMmJnRoaXMuZUFubm90YXRpb25zLnNpemVfMCE9MDtjYXNlIDE6cmV0dXJuISF0aGlzLmVQYWNrYWdlfXJldHVybiBzbCh0aGlzLG4tb24oKFBlKCksaV8pKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxpXyksbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpLCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksUHIodGhpcy5lQW5ub3RhdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTp2JGUodGhpcyxhKHIsMjQxKSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxpXykpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fGlfKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxpX30sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOnYkZSh0aGlzLG51bGwpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCksaV8pKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxpXyksbikpfTt2YXIgdVMsRW5lLFMkZTtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVGYWN0b3J5SW1wbCIsNzIwKTtmdW5jdGlvbiBDJGUoKXt9ZnVuY3Rpb24gRXZuKCl7JEEoKTt2YXIgZSxuO3RyeXtpZihuPWEoZHRlKChuXygpLFBsKSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbGsvRWxrR3JhcGgiKSwyMTEzKSxuKXJldHVybiBufWNhdGNoKHIpe2lmKHI9d3IociksTChyLDEwMykpZT1yLGxyZSgoYm4oKSxlKSk7ZWxzZSB0aHJvdyBiKHIpfXJldHVybiBuZXcgQyRlfXAoMTAzNyw3MjAsezExMDoxLDIxMTM6MSw5NDoxLDkzOjEsNDgwOjEsMTU1OjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTU4OjEsMTE5OjEsMTIwOjF9LEMkZSksbC5jb252ZXJ0VG9TdHJpbmc9ZnVuY3Rpb24obixyKXtzd2l0Y2gobi5nZXRDbGFzc2lmaWVySUQoKSl7Y2FzZSAxMjpyZXR1cm4gYShyLDE0OSkuZ2V0SWQoKTtjYXNlIDEzOnJldHVybiB2byhyKTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJUaGUgZGF0YXR5cGUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKX19LGwuY3JlYXRlXzM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXztzd2l0Y2gobi5tZXRhT2JqZWN0SUQ9PS0xJiYobi5tZXRhT2JqZWN0SUQ9KHI9SGEobikscj9zMChyLmdldEVDbGFzc2lmaWVycygpLG4pOi0xKSksbi5tZXRhT2JqZWN0SUQpe2Nhc2UgNDpyZXR1cm4gcz1uZXcgUG5lLHM7Y2FzZSA2OnJldHVybiB1PW5ldyBfUyx1O2Nhc2UgNzpyZXR1cm4gYz1uZXcgUm5lLGM7Y2FzZSA4OnJldHVybiBvPW5ldyBLUixvO2Nhc2UgOTpyZXR1cm4gdD1uZXcgT0EsdDtjYXNlIDEwOnJldHVybiBpPW5ldyB6QSxpO2Nhc2UgMTE6cmV0dXJuIF89bmV3IHokZSxfO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIlRoZSBjbGFzcyAnIituLm5hbWVfMCsiJyBpcyBub3QgYSB2YWxpZCBjbGFzc2lmaWVyIikpfX0sbC5jcmVhdGVGcm9tU3RyaW5nPWZ1bmN0aW9uKG4scil7c3dpdGNoKG4uZ2V0Q2xhc3NpZmllcklEKCkpe2Nhc2UgMTM6Y2FzZSAxMjpyZXR1cm4gbnVsbDtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJUaGUgZGF0YXR5cGUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKX19LGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5pbXBsIiwiRWxrR3JhcGhGYWN0b3J5SW1wbCIsMTAzNyk7ZnVuY3Rpb24gZ2koZSxuKXt2YXIgcjtyPWUubmFtZV8wLGUubmFtZV8wPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwxLHIsZS5uYW1lXzApKX1mdW5jdGlvbiBjUyhlKXt2YXIgbjtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9ucyhlKToobj1uZXcgeWwobnMoZSkpLG4uc3RyaW5nKz0iIChuYW1lOiAiLEp0KG4sZS5uYW1lXzApLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfXAoNDQ4LDE1OCx7MTEwOjEsOTQ6MSw5MzoxLDE1NToxLDE5NzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDE1ODoxLDExOToxLDEyMDoxfSksbC5lQ29udGVudHNfMD1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIHI9KG49YShCZSh0aGlzLDE2KSwyOSksWXJlKEV1KG58fHRoaXMuZVN0YXRpY0NsYXNzKCkpKSkscj09bnVsbD8oVFMoKSxUUygpLHJGKTpuZXcgT1VlKHRoaXMscil9LGwuZUdldD1mdW5jdGlvbihuLHIsdCl7dmFyIG87c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5nZXROYW1lKCl9cmV0dXJuIGxsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiEhdGhpcy5lQW5ub3RhdGlvbnMmJnRoaXMuZUFubm90YXRpb25zLnNpemVfMCE9MDtjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wIT1udWxsfXJldHVybiBzbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpLCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksUHIodGhpcy5lQW5ub3RhdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTp0aGlzLnNldE5hbWUoeG4ocikpO3JldHVybn11bCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHQ9YShCZSh0aGlzLDE2KSwyOSksdHx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksa0hlfSxsLmVVbnNldD1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpO3JldHVybjtjYXNlIDE6dGhpcy5zZXROYW1lKG51bGwpO3JldHVybn1jbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lXzB9LGwuc2V0TmFtZT1mdW5jdGlvbihuKXtnaSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gY1ModGhpcyl9LGwubmFtZV8wPW51bGwsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFTmFtZWRFbGVtZW50SW1wbCIsNDQ4KTtmdW5jdGlvbiBFbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF87Zm9yKHM9KGk9bmV3IERyZSxpKSxScmUocywoVmUobiksbikpLF89KCFzLmRldGFpbHMmJihzLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxzKSkscy5kZXRhaWxzKSxjPTE7YzxyLmxlbmd0aDtjKz0yKWdiKF8scltjLTFdLHJbY10pO2Zvcih0PSghZS5lQW5ub3RhdGlvbnMmJihlLmVBbm5vdGF0aW9ucz1uZXcgVShEbixlLDAsMykpLGUuZUFubm90YXRpb25zKSx1PTA7dTwwOysrdSlvPVZDbihhKE8odCx0LnNpemVfMC0xKSw1OTgpKSx0PW87cG4odCxzKX1mdW5jdGlvbiB2dm4oZSxuKXtwbigoIWUuZUV4Y2VwdGlvbnMmJihlLmVFeGNlcHRpb25zPW5ldyBUYihlLGUpKSxlLmVFeGNlcHRpb25zKSxuKX1mdW5jdGlvbiBEZyhlLG4scil7dmFyIHQsbztyZXR1cm4gbz0odD1uZXcgYUYsdCksZW8obyxuLHIpLHBuKCghZS5lT3BlcmF0aW9ucyYmKGUuZU9wZXJhdGlvbnM9bmV3IFUoeGwsZSwxMSwxMCkpLGUuZU9wZXJhdGlvbnMpLG8pLG99ZnVuY3Rpb24gbG8oZSxuLHIpe3ZhciB0LG87cmV0dXJuIHQ9KG89bmV3IHNGLGwxKG8sbiksZ2kobyxyKSxwbigoIWUuZVBhcmFtZXRlcnMmJihlLmVQYXJhbWV0ZXJzPW5ldyBVKE5kLGUsMTIsMTApKSxlLmVQYXJhbWV0ZXJzKSxvKSxvKSxpMCh0LDApLGlwKHQsMSksbDAodCwhMCksYTAodCwhMCksdH1mdW5jdGlvbiBCQShlLG4scil7dmFyIHQsbyxpO2k9KHQ9bmV3IHNGLHQpLG89cXMoaSxuLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpLGdpKGkscikscG4oKCFlLmVQYXJhbWV0ZXJzJiYoZS5lUGFyYW1ldGVycz1uZXcgVShOZCxlLDEyLDEwKSksZS5lUGFyYW1ldGVycyksaSksaTAoaSwwKSxpcChpLDEpLGwwKGksITApLGEwKGksITApfWZ1bmN0aW9uIHRiKGUsbil7dmFyIHIsdDtyZXR1cm4gdD0ocj1uZXcgcEYsciksZ2kodCxuKSxwbigoIWUuZVR5cGVQYXJhbWV0ZXJzJiYoZS5lVHlwZVBhcmFtZXRlcnM9bmV3IFhpKGJpLGUsNykpLGUuZVR5cGVQYXJhbWV0ZXJzKSx0KSx0fWZ1bmN0aW9uIFQkZShlKXt2YXIgbixyO3JldHVybiByPShuPW5ldyBwRixuKSxnaShyLCJUIikscG4oKCFlLmVUeXBlUGFyYW1ldGVycyYmKGUuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSxlLDExKSksZS5lVHlwZVBhcmFtZXRlcnMpLHIpLHJ9ZnVuY3Rpb24gYiRlKGUpe3JldHVybiBlLmVGbGFnc18wPj4xNiE9Nz9udWxsOmEoZS5lQ29udGFpbmVyLDI0MSl9ZnVuY3Rpb24gdm5lKGUsbixyKXt2YXIgdCxvO3JldHVybiBvPWUuZUZhY3RvcnlJbnN0YW5jZSxlLmVGYWN0b3J5SW5zdGFuY2U9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmKHQ9bmV3IGx0KGUsMSw0LG8sbikscj9yLmFkZF81KHQpOnI9dCkscn1mdW5jdGlvbiBJcihlLG4pe3ZhciByLHQ7cj0odD1uZXcgQkQsdCksci5mZWF0dXJlSUQ9bixwbigoIWUuZVN0cnVjdHVyYWxGZWF0dXJlcyYmKGUuZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSxlLDIxLDE3KSksZS5lU3RydWN0dXJhbEZlYXR1cmVzKSxyKX1mdW5jdGlvbiB6byhlLG4pe3ZhciByLHQ7cmV0dXJuIHI9KHQ9bmV3IFZyZSx0KSxyLm1ldGFPYmplY3RJRD1uLCFlLmVDbGFzc2lmaWVycyYmKGUuZUNsYXNzaWZpZXJzPW5ldyB1cChlLEVzLGUpKSxwbihlLmVDbGFzc2lmaWVycyxyKSxyfWZ1bmN0aW9uIEduKGUsbil7dmFyIHIsdDtyZXR1cm4gcj0odD1uZXcgeEwsdCksci5tZXRhT2JqZWN0SUQ9biwhZS5lQ2xhc3NpZmllcnMmJihlLmVDbGFzc2lmaWVycz1uZXcgdXAoZSxFcyxlKSkscG4oZS5lQ2xhc3NpZmllcnMscikscn1mdW5jdGlvbiBtYyhlKXt2YXIgbixyO3JldHVybiByPShuPW5ldyBNZCxuKSxvMihyLGUpLHJ9ZnVuY3Rpb24gUVIoZSl7dmFyIG4scjtyZXR1cm4gcj0obj1uZXcgTWQsbiksUXJlKHIsZSkscn1mdW5jdGlvbiBzbyhlKXt2YXIgbixyO3I9KG49bmV3IGFGLG4pLHBuKCghZS5lT3BlcmF0aW9ucyYmKGUuZU9wZXJhdGlvbnM9bmV3IFUoeGwsZSwxMSwxMCkpLGUuZU9wZXJhdGlvbnMpLHIpfWZ1bmN0aW9uIGRyKGUsbil7dmFyIHIsdDt0PShyPW5ldyB5dGUsciksdC5mZWF0dXJlSUQ9bixwbigoIWUuZVN0cnVjdHVyYWxGZWF0dXJlcyYmKGUuZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSxlLDIxLDE3KSksZS5lU3RydWN0dXJhbEZlYXR1cmVzKSx0KX1mdW5jdGlvbiBTbmUoZSxuKXt2YXIgcix0O3JldHVybiB0PU5BKGUpLHR8fChyPShQRCgpLHVIZShuKSksdD1uZXcga2plKHIpLHBuKHQuZ2V0Q29udGVudHMoKSxlKSksdH1mdW5jdGlvbiBJJGUoZSxuKXt2YXIgcix0O3JldHVybiBlLmVGbGFnc18wPj4xNj09Nz9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSw2LHlzLG4pOih0PUd0KGEoa2UoKHI9YShCZShlLDE2KSwyOSkscnx8KFBlKCksbzApKSxlLmVGbGFnc18wPj4xNiksMTkpKSxlLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSx0LmZlYXR1cmVJRCx0LmNvbnRhaW5lckNsYXNzLG4pKX1mdW5jdGlvbiBlRChlKXt2YXIgbixyO2lmKGUuZUNsYXNzaWZpZXJzKWZvcihuPTAscj1lLmVDbGFzc2lmaWVycy5zaXplXzA7bjxyOysrbilyYihPKGUuZUNsYXNzaWZpZXJzLG4pKTtpZihlLmVTdWJwYWNrYWdlcylmb3Iobj0wLHI9ZS5lU3VicGFja2FnZXMuc2l6ZV8wO248cjsrK24pcmIoTyhlLmVTdWJwYWNrYWdlcyxuKSk7eFMoKEtpKCksVHQpLGUpLGUuZUZsYWdzfD0xfWZ1bmN0aW9uIFN2bihlLG4pe3ZhciByLHQsbyxpLHMsdTtpZighZS5lTmFtZVRvRUNsYXNzaWZpZXJNYXApe2ZvcihpPSghZS5lQ2xhc3NpZmllcnMmJihlLmVDbGFzc2lmaWVycz1uZXcgdXAoZSxFcyxlKSksZS5lQ2xhc3NpZmllcnMpLHU9bmV3IEVoKGkuc2l6ZV8wKSxvPW5ldyBZZShpKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YShlbihvKSwxNDIpLHM9dC5nZXROYW1lKCkscj1hKHM9PW51bGw/ZGkodS5oYXNoQ29kZU1hcCxudWxsLHQpOmsxKHUuc3RyaW5nTWFwLHMsdCksMTQyKSxyJiYocz09bnVsbD9kaSh1Lmhhc2hDb2RlTWFwLG51bGwscik6azEodS5zdHJpbmdNYXAscyxyKSk7ZS5lTmFtZVRvRUNsYXNzaWZpZXJNYXA9dX1yZXR1cm4gYShuaShlLmVOYW1lVG9FQ2xhc3NpZmllck1hcCxuKSwxNDIpfWZ1bmN0aW9uIE9yKGUsbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgpe3JldHVybiBOJGUoZSxuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCksJEQoZSwhMSksZX1mdW5jdGlvbiB4JGUoZSxuLHIsdCxvLGkscyx1KXt2YXIgYztyZXR1cm4gTChlLmVDb250YWluZXIsOTApJiZscChoYShhKGUuZUNvbnRhaW5lciw5MCkpLDQpLGdpKGUsciksZS5jb250YWluZXJDbGFzcz10LFh3KGUsbyksWncoZSxpKSxZdyhlLHMpLEp3KGUsITEpLGwwKGUsITApLEt3KGUsdSksYTAoZSwhMCksaTAoZSwwKSxlLmVmZmVjdGl2ZUlzTWFueT0wLGlwKGUsMSksYz1xcyhlLG4sbnVsbCksYyYmYy5kaXNwYXRjaF8wKCksJEQoZSwhMSksZX1mdW5jdGlvbiAkbyhlLG4scix0LG8saSl7cmV0dXJuIFAkZShlLG4scixpKSxVcmUoZSx0KSxXcmUoZSxvKSxlfWZ1bmN0aW9uIFAkZShlLG4scix0KXtMKGUuZUNvbnRhaW5lciwxODQpJiYoYShlLmVDb250YWluZXIsMTg0KS5lTmFtZVRvRUNsYXNzaWZpZXJNYXA9bnVsbCksZ2koZSxyKSxuJiZRQ24oZSxuKSx0JiZlLnNldEdlbmVyYXRlZEluc3RhbmNlQ2xhc3MoITApfWZ1bmN0aW9uIEhuKGUsbixyLHQpe3JldHVybiBQJGUoZSxuLHIsITEpLElMKGUsdCksZX1mdW5jdGlvbiBlbyhlLG4scil7cmV0dXJuIGwxKGUsbiksZ2koZSxyKSxpMChlLDApLGlwKGUsMSksbDAoZSwhMCksYTAoZSwhMCksZX1mdW5jdGlvbiBmcihlLG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0pe3JldHVybiBOJGUoZSxuLHQsbnVsbCxvLGkscyx1LGMsXyxoLCEwLG0pLGd0ZShlLGQpLEwoZS5lQ29udGFpbmVyLDkwKSYmbHAoaGEoYShlLmVDb250YWluZXIsOTApKSwyKSxyJiZodGUoZSxyKSxtdGUoZSxmKSxlfWZ1bmN0aW9uIE4kZShlLG4scix0LG8saSxzLHUsYyxfLGQsZixoKXtMKGUuZUNvbnRhaW5lciw5MCkmJmxwKGhhKGEoZS5lQ29udGFpbmVyLDkwKSksNCksZ2koZSxyKSxlLmNvbnRhaW5lckNsYXNzPXMsWHcoZSx1KSxadyhlLGMpLFl3KGUsXyksSncoZSxkKSxsMChlLGYpLEt3KGUsaCksYTAoZSwhMCksaTAoZSxvKSxlLnNldFVwcGVyQm91bmQoaSksbDEoZSxuKSx0IT1udWxsJiYoZS5kZWZhdWx0VmFsdWVGYWN0b3J5PW51bGwsRUwoZSx0KSl9ZnVuY3Rpb24gbkQoZSxuKXt2YXIgcjtuIT1lLmVGYWN0b3J5SW5zdGFuY2U/KHI9bnVsbCxlLmVGYWN0b3J5SW5zdGFuY2UmJihyPWEoZS5lRmFjdG9yeUluc3RhbmNlLDU0KS5lSW52ZXJzZVJlbW92ZShlLDEsYVMscikpLG4mJihyPWEobiw1NCkuZUludmVyc2VBZGQoZSwxLGFTLHIpKSxyPXZuZShlLG4sciksciYmci5kaXNwYXRjaF8wKCkpOmUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsNCxuLG4pKX1mdW5jdGlvbiBHQShlLG4pe3ZhciByO3I9ZS5uc1ByZWZpeCxlLm5zUHJlZml4PW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwzLHIsZS5uc1ByZWZpeCkpfWZ1bmN0aW9uIEhBKGUsbil7dmFyIHI7cj1lLm5zVVJJLGUubnNVUkk9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDIscixlLm5zVVJJKSl9ZnVuY3Rpb24gQSRlKCl7bkQodGhpcyxuZXcgeW5lKSx0aGlzLmVjb3JlUGFja2FnZT0ocl8oKSwkZSksVncoKX1mdW5jdGlvbiBDbmUoZSxuKXt2YXIgcjtyPW5pKChuXygpLFBsKSxlKSxMKHIsNTA3KT90byhQbCxlLG5ldyBRVWUodGhpcyxuKSk6dG8oUGwsZSx0aGlzKSxuRCh0aGlzLG4pLG49PShWdygpLEFyZSk/KHRoaXMuZWNvcmVQYWNrYWdlPWEodGhpcywyMDM4KSxhKG4sMjA0MCkpOnRoaXMuZWNvcmVQYWNrYWdlPShyXygpLCRlKX1wKDE4NCw0NDgsezExMDoxLDk0OjEsOTM6MSwxNTU6MSwxOTc6MSw1ODoxLDI0MToxLDExNDoxLDU0OjEsOTk6MSwxNTg6MSwxODQ6MSwxMTk6MSwxMjA6MSw2OTA6MX0sQSRlKSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBJJGUodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbztzd2l0Y2gobil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnM7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMDtjYXNlIDI6cmV0dXJuIHRoaXMubnNVUkk7Y2FzZSAzOnJldHVybiB0aGlzLm5zUHJlZml4O2Nhc2UgNDpyZXR1cm4gdGhpcy5lRmFjdG9yeUluc3RhbmNlO2Nhc2UgNTpyZXR1cm4hdGhpcy5lQ2xhc3NpZmllcnMmJih0aGlzLmVDbGFzc2lmaWVycz1uZXcgdXAodGhpcyxFcyx0aGlzKSksdGhpcy5lQ2xhc3NpZmllcnM7Y2FzZSA2OnJldHVybiF0aGlzLmVTdWJwYWNrYWdlcyYmKHRoaXMuZVN1YnBhY2thZ2VzPW5ldyB4bSh5cyx0aGlzLDYsNykpLHRoaXMuZVN1YnBhY2thZ2VzO2Nhc2UgNzpyZXR1cm4gcj90aGlzLmVGbGFnc18wPj4xNj09Nz9hKHRoaXMuZUNvbnRhaW5lciwyNDEpOm51bGw6YiRlKHRoaXMpfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCksbzApKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHxvMCksbikscix0KX0sbC5lSW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHM7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGhpKHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSA0OnJldHVybiB0aGlzLmVGYWN0b3J5SW5zdGFuY2UmJih0PWEodGhpcy5lRmFjdG9yeUluc3RhbmNlLDU0KS5lSW52ZXJzZVJlbW92ZSh0aGlzLDEsYVMsdCkpLHZuZSh0aGlzLGEobiw0ODApLHQpO2Nhc2UgNTpyZXR1cm4hdGhpcy5lQ2xhc3NpZmllcnMmJih0aGlzLmVDbGFzc2lmaWVycz1uZXcgdXAodGhpcyxFcyx0aGlzKSksaGkodGhpcy5lQ2xhc3NpZmllcnMsbix0KTtjYXNlIDY6cmV0dXJuIXRoaXMuZVN1YnBhY2thZ2VzJiYodGhpcy5lU3VicGFja2FnZXM9bmV3IHhtKHlzLHRoaXMsNiw3KSksaGkodGhpcy5lU3VicGFja2FnZXMsbix0KTtjYXNlIDc6cmV0dXJuIHRoaXMuZUNvbnRhaW5lciYmKHQ9KGk9dGhpcy5lRmxhZ3NfMD4+MTYsaT49MD9JJGUodGhpcyx0KTp0aGlzLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUodGhpcywtMS1pLG51bGwsdCkpKSxHYSh0aGlzLG4sNyx0KX1yZXR1cm4gcz1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLG8wKSksciksNjkpLHMuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLG8wKSksbix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxEdCh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgNDpyZXR1cm4gdm5lKHRoaXMsbnVsbCx0KTtjYXNlIDU6cmV0dXJuIXRoaXMuZUNsYXNzaWZpZXJzJiYodGhpcy5lQ2xhc3NpZmllcnM9bmV3IHVwKHRoaXMsRXMsdGhpcykpLER0KHRoaXMuZUNsYXNzaWZpZXJzLG4sdCk7Y2FzZSA2OnJldHVybiF0aGlzLmVTdWJwYWNrYWdlcyYmKHRoaXMuZVN1YnBhY2thZ2VzPW5ldyB4bSh5cyx0aGlzLDYsNykpLER0KHRoaXMuZVN1YnBhY2thZ2VzLG4sdCk7Y2FzZSA3OnJldHVybiBHYSh0aGlzLG51bGwsNyx0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLG8wKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLG8wKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMCE9bnVsbDtjYXNlIDI6cmV0dXJuIHRoaXMubnNVUkkhPW51bGw7Y2FzZSAzOnJldHVybiB0aGlzLm5zUHJlZml4IT1udWxsO2Nhc2UgNDpyZXR1cm4hIXRoaXMuZUZhY3RvcnlJbnN0YW5jZTtjYXNlIDU6cmV0dXJuISF0aGlzLmVDbGFzc2lmaWVycyYmdGhpcy5lQ2xhc3NpZmllcnMuc2l6ZV8wIT0wO2Nhc2UgNjpyZXR1cm4hIXRoaXMuZVN1YnBhY2thZ2VzJiZ0aGlzLmVTdWJwYWNrYWdlcy5zaXplXzAhPTA7Y2FzZSA3OnJldHVybiEhYiRlKHRoaXMpfXJldHVybiBzbCh0aGlzLG4tb24oKFBlKCksbzApKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxvMCksbikpfSxsLmVPYmplY3RGb3JVUklGcmFnbWVudFNlZ21lbnQ9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9U3ZuKHRoaXMsbikscnx8aG5lKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0O3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyksIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxQcih0aGlzLmVBbm5vdGF0aW9ucyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxOmdpKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDI6SEEodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMzpHQSh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSA0Om5EKHRoaXMsYShyLDQ4MCkpO3JldHVybjtjYXNlIDU6IXRoaXMuZUNsYXNzaWZpZXJzJiYodGhpcy5lQ2xhc3NpZmllcnM9bmV3IHVwKHRoaXMsRXMsdGhpcykpLGZuKHRoaXMuZUNsYXNzaWZpZXJzKSwhdGhpcy5lQ2xhc3NpZmllcnMmJih0aGlzLmVDbGFzc2lmaWVycz1uZXcgdXAodGhpcyxFcyx0aGlzKSksUHIodGhpcy5lQ2xhc3NpZmllcnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgNjohdGhpcy5lU3VicGFja2FnZXMmJih0aGlzLmVTdWJwYWNrYWdlcz1uZXcgeG0oeXMsdGhpcyw2LDcpKSxmbih0aGlzLmVTdWJwYWNrYWdlcyksIXRoaXMuZVN1YnBhY2thZ2VzJiYodGhpcy5lU3VicGFja2FnZXM9bmV3IHhtKHlzLHRoaXMsNiw3KSksUHIodGhpcy5lU3VicGFja2FnZXMsYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxvMCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fG8wKSxuKSxyKX0sbC5lU2V0UHJveHlVUkk9ZnVuY3Rpb24obil7dmFyIHIsdDtpZihuJiZ0aGlzLmVDbGFzc2lmaWVycylmb3IodD1uZXcgWWUodGhpcy5lQ2xhc3NpZmllcnMpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1lbih0KSxMKHIsMzY0KSYmKGEociwzNjQpLmVQYWNrYWdlPW51bGwpO21tKHRoaXMsNjQsbil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksbzB9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJuO2Nhc2UgMTpnaSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDI6SEEodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAzOkdBKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgNDpuRCh0aGlzLG51bGwpO3JldHVybjtjYXNlIDU6IXRoaXMuZUNsYXNzaWZpZXJzJiYodGhpcy5lQ2xhc3NpZmllcnM9bmV3IHVwKHRoaXMsRXMsdGhpcykpLGZuKHRoaXMuZUNsYXNzaWZpZXJzKTtyZXR1cm47Y2FzZSA2OiF0aGlzLmVTdWJwYWNrYWdlcyYmKHRoaXMuZVN1YnBhY2thZ2VzPW5ldyB4bSh5cyx0aGlzLDYsNykpLGZuKHRoaXMuZVN1YnBhY2thZ2VzKTtyZXR1cm59Y2wodGhpcyxuLW9uKChQZSgpLG8wKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8bzApLG4pKX0sbC5mcmVlemU9ZnVuY3Rpb24oKXtlRCh0aGlzKX0sbC5nZXRFQ2xhc3NpZmllcnM9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5lQ2xhc3NpZmllcnMmJih0aGlzLmVDbGFzc2lmaWVycz1uZXcgdXAodGhpcyxFcyx0aGlzKSksdGhpcy5lQ2xhc3NpZmllcnN9LGwuZ2V0RUZhY3RvcnlJbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVGYWN0b3J5SW5zdGFuY2V9LGwuZ2V0RXh0ZW5kZWRNZXRhRGF0YT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVQYWNrYWdlRXh0ZW5kZWRNZXRhRGF0YX0sbC5nZXROc1ByZWZpeD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5zUHJlZml4fSxsLmdldE5zVVJJPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubnNVUkl9LGwuc2V0RXh0ZW5kZWRNZXRhRGF0YT1mdW5jdGlvbihuKXt0aGlzLmVQYWNrYWdlRXh0ZW5kZWRNZXRhRGF0YT1ufSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lRmxhZ3NfMCY2ND9jUyh0aGlzKToobj1uZXcgeWwoY1ModGhpcykpLG4uc3RyaW5nKz0iIChuc1VSSTogIixKdChuLHRoaXMubnNVUkkpLG4uc3RyaW5nKz0iLCBuc1ByZWZpeDogIixKdChuLHRoaXMubnNQcmVmaXgpLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfSxsLm5zUHJlZml4PW51bGwsbC5uc1VSST1udWxsLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVBhY2thZ2VJbXBsIiwxODQpO2Z1bmN0aW9uIEN2bihlKXtlLmlzQ3JlYXRlZHx8KGUuaXNDcmVhdGVkPSEwLGUuaVByb3BlcnR5SG9sZGVyRUNsYXNzPXpvKGUsMCksZS5lTWFwUHJvcGVydHlIb2xkZXJFQ2xhc3M9em8oZSwxKSxkcihlLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcywwKSxlLmVsa0dyYXBoRWxlbWVudEVDbGFzcz16byhlLDIpLGRyKGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzLDEpLElyKGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzLDIpLGUuZWxrU2hhcGVFQ2xhc3M9em8oZSwzKSxJcihlLmVsa1NoYXBlRUNsYXNzLDMpLElyKGUuZWxrU2hhcGVFQ2xhc3MsNCksSXIoZS5lbGtTaGFwZUVDbGFzcyw1KSxJcihlLmVsa1NoYXBlRUNsYXNzLDYpLGUuZWxrTGFiZWxFQ2xhc3M9em8oZSw0KSxkcihlLmVsa0xhYmVsRUNsYXNzLDcpLElyKGUuZWxrTGFiZWxFQ2xhc3MsOCksZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzPXpvKGUsNSksZHIoZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzLDcpLGRyKGUuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyw4KSxlLmVsa05vZGVFQ2xhc3M9em8oZSw2KSxkcihlLmVsa05vZGVFQ2xhc3MsOSksZHIoZS5lbGtOb2RlRUNsYXNzLDEwKSxkcihlLmVsa05vZGVFQ2xhc3MsMTEpLGRyKGUuZWxrTm9kZUVDbGFzcywxMiksSXIoZS5lbGtOb2RlRUNsYXNzLDEzKSxlLmVsa1BvcnRFQ2xhc3M9em8oZSw3KSxkcihlLmVsa1BvcnRFQ2xhc3MsOSksZS5lbGtFZGdlRUNsYXNzPXpvKGUsOCksZHIoZS5lbGtFZGdlRUNsYXNzLDMpLGRyKGUuZWxrRWRnZUVDbGFzcyw0KSxkcihlLmVsa0VkZ2VFQ2xhc3MsNSksZHIoZS5lbGtFZGdlRUNsYXNzLDYpLElyKGUuZWxrRWRnZUVDbGFzcyw3KSxJcihlLmVsa0VkZ2VFQ2xhc3MsOCksSXIoZS5lbGtFZGdlRUNsYXNzLDkpLElyKGUuZWxrRWRnZUVDbGFzcywxMCksZS5lbGtCZW5kUG9pbnRFQ2xhc3M9em8oZSw5KSxJcihlLmVsa0JlbmRQb2ludEVDbGFzcywwKSxJcihlLmVsa0JlbmRQb2ludEVDbGFzcywxKSxlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzPXpvKGUsMTApLElyKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsMSksSXIoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcywyKSxJcihlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzLDMpLElyKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsNCksZHIoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyw1KSxkcihlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzLDYpLGRyKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsNyksZHIoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyw4KSxkcihlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzLDkpLGRyKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsMTApLElyKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsMTEpLGUuZWxrUHJvcGVydHlUb1ZhbHVlTWFwRW50cnlFQ2xhc3M9em8oZSwxMSksSXIoZS5lbGtQcm9wZXJ0eVRvVmFsdWVNYXBFbnRyeUVDbGFzcywwKSxJcihlLmVsa1Byb3BlcnR5VG9WYWx1ZU1hcEVudHJ5RUNsYXNzLDEpLGUuaVByb3BlcnR5RURhdGFUeXBlPUduKGUsMTIpLGUucHJvcGVydHlWYWx1ZUVEYXRhVHlwZT1HbihlLDEzKSl9ZnVuY3Rpb24gVHZuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRTtlLmlzSW5pdGlhbGl6ZWR8fChlLmlzSW5pdGlhbGl6ZWQ9ITAsZ2koZSwiZ3JhcGgiKSxHQShlLCJncmFwaCIpLEhBKGUsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZWxrL0Vsa0dyYXBoIiksdGIoZS5pUHJvcGVydHlFRGF0YVR5cGUsIlQiKSxwbih3byhlLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcyksZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MpLHBuKHdvKGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzKSxlLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcykscG4od28oZS5lbGtTaGFwZUVDbGFzcyksZS5lbGtHcmFwaEVsZW1lbnRFQ2xhc3MpLHBuKHdvKGUuZWxrTGFiZWxFQ2xhc3MpLGUuZWxrU2hhcGVFQ2xhc3MpLHBuKHdvKGUuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyksZS5lbGtTaGFwZUVDbGFzcykscG4od28oZS5lbGtOb2RlRUNsYXNzKSxlLmVsa0Nvbm5lY3RhYmxlU2hhcGVFQ2xhc3MpLHBuKHdvKGUuZWxrUG9ydEVDbGFzcyksZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzKSxwbih3byhlLmVsa0VkZ2VFQ2xhc3MpLGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzKSxwbih3byhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSxlLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcyksJG8oZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MsYXRuLCJJUHJvcGVydHlIb2xkZXIiLCEwLCEwLCExKSx5PURnKGUuaVByb3BlcnR5SG9sZGVyRUNsYXNzLGUuaVByb3BlcnR5SG9sZGVyRUNsYXNzLCJzZXRQcm9wZXJ0eSIpLEU9VCRlKHkpLF89bWMoZS5pUHJvcGVydHlFRGF0YVR5cGUpLGQ9KHI9KHQ9bmV3IE1kLHQpLHIpLHBuKCghXy5lVHlwZUFyZ3VtZW50cyYmKF8uZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LF8sMSkpLF8uZVR5cGVBcmd1bWVudHMpLGQpLGY9UVIoRSksWnJlKGQsZiksQkEoeSxfLCJwcm9wZXJ0eSIpLF89UVIoRSksQkEoeSxfLCJ2YWx1ZSIpLHk9RGcoZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MsbnVsbCwiZ2V0UHJvcGVydHkiKSxFPVQkZSh5KSxfPW1jKGUuaVByb3BlcnR5RURhdGFUeXBlKSxkPVFSKEUpLHBuKCghXy5lVHlwZUFyZ3VtZW50cyYmKF8uZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LF8sMSkpLF8uZVR5cGVBcmd1bWVudHMpLGQpLEJBKHksXywicHJvcGVydHkiKSxfPVFSKEUpLG09cXMoeSxfLG51bGwpLG0mJm0uZGlzcGF0Y2hfMCgpLHk9RGcoZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MsZS5lY29yZVBhY2thZ2UuZUJvb2xlYW5FRGF0YVR5cGUsImhhc1Byb3BlcnR5IiksXz1tYyhlLmlQcm9wZXJ0eUVEYXRhVHlwZSksZD0obz0oaT1uZXcgTWQsaSksbykscG4oKCFfLmVUeXBlQXJndW1lbnRzJiYoXy5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsXywxKSksXy5lVHlwZUFyZ3VtZW50cyksZCksQkEoeSxfLCJwcm9wZXJ0eSIpLHk9RGcoZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MsZS5pUHJvcGVydHlIb2xkZXJFQ2xhc3MsImNvcHlQcm9wZXJ0aWVzIiksbG8oeSxlLmlQcm9wZXJ0eUhvbGRlckVDbGFzcywic291cmNlIikseT1EZyhlLmlQcm9wZXJ0eUhvbGRlckVDbGFzcyxudWxsLCJnZXRBbGxQcm9wZXJ0aWVzIiksXz1tYyhlLmVjb3JlUGFja2FnZS5lTWFwRURhdGFUeXBlKSxkPW1jKGUuaVByb3BlcnR5RURhdGFUeXBlKSxwbigoIV8uZVR5cGVBcmd1bWVudHMmJihfLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxfLDEpKSxfLmVUeXBlQXJndW1lbnRzKSxkKSxmPShzPSh1PW5ldyBNZCx1KSxzKSxwbigoIWQuZVR5cGVBcmd1bWVudHMmJihkLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxkLDEpKSxkLmVUeXBlQXJndW1lbnRzKSxmKSxkPW1jKGUuZWNvcmVQYWNrYWdlLmVKYXZhT2JqZWN0RURhdGFUeXBlKSxwbigoIV8uZVR5cGVBcmd1bWVudHMmJihfLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxfLDEpKSxfLmVUeXBlQXJndW1lbnRzKSxkKSxoPXFzKHksXyxudWxsKSxoJiZoLmRpc3BhdGNoXzAoKSwkbyhlLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcyxrdywiRU1hcFByb3BlcnR5SG9sZGVyIiwhMCwhMSwhMCksZnIoYShPKEcoZS5lTWFwUHJvcGVydHlIb2xkZXJFQ2xhc3MpLDApLDE5KSxlLmVsa1Byb3BlcnR5VG9WYWx1ZU1hcEVudHJ5RUNsYXNzLG51bGwsInByb3BlcnRpZXMiLDAsLTEsa3csITEsITEsITAsITAsITEsITEsITEpLCRvKGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzLEtULCJFbGtHcmFwaEVsZW1lbnQiLCEwLCExLCEwKSxmcihhKE8oRyhlLmVsa0dyYXBoRWxlbWVudEVDbGFzcyksMCksMTkpLGUuZWxrTGFiZWxFQ2xhc3MsYShPKEcoZS5lbGtMYWJlbEVDbGFzcyksMCksMTkpLCJsYWJlbHMiLDAsLTEsS1QsITEsITEsITAsITAsITEsITEsITEpLE9yKGEoTyhHKGUuZWxrR3JhcGhFbGVtZW50RUNsYXNzKSwxKSwzNSksZS5lY29yZVBhY2thZ2UuZVN0cmluZ0VEYXRhVHlwZSwiaWRlbnRpZmllciIsbnVsbCwwLDEsS1QsITEsITEsITAsITEsITAsITEpLCRvKGUuZWxrU2hhcGVFQ2xhc3MsWFQsIkVsa1NoYXBlIiwhMCwhMSwhMCksT3IoYShPKEcoZS5lbGtTaGFwZUVDbGFzcyksMCksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsImhlaWdodCIsIjAuMCIsMSwxLFhULCExLCExLCEwLCExLCEwLCExKSxPcihhKE8oRyhlLmVsa1NoYXBlRUNsYXNzKSwxKSwzNSksZS5lY29yZVBhY2thZ2UuZURvdWJsZUVEYXRhVHlwZSwid2lkdGgiLCIwLjAiLDEsMSxYVCwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lbGtTaGFwZUVDbGFzcyksMiksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsIngiLCIwLjAiLDEsMSxYVCwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lbGtTaGFwZUVDbGFzcyksMyksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsInkiLCIwLjAiLDEsMSxYVCwhMSwhMSwhMCwhMSwhMCwhMSkseT1EZyhlLmVsa1NoYXBlRUNsYXNzLG51bGwsInNldERpbWVuc2lvbnMiKSxsbyh5LGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsIndpZHRoIiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJoZWlnaHQiKSx5PURnKGUuZWxrU2hhcGVFQ2xhc3MsbnVsbCwic2V0TG9jYXRpb24iKSxsbyh5LGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsIngiKSxsbyh5LGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsInkiKSwkbyhlLmVsa0xhYmVsRUNsYXNzLFF0LCJFbGtMYWJlbCIsITEsITEsITApLGZyKGEoTyhHKGUuZWxrTGFiZWxFQ2xhc3MpLDApLDE5KSxlLmVsa0dyYXBoRWxlbWVudEVDbGFzcyxhKE8oRyhlLmVsa0dyYXBoRWxlbWVudEVDbGFzcyksMCksMTkpLCJwYXJlbnQiLDAsMSxRdCwhMSwhMSwhMCwhMSwhMSwhMSwhMSksT3IoYShPKEcoZS5lbGtMYWJlbEVDbGFzcyksMSksMzUpLGUuZWNvcmVQYWNrYWdlLmVTdHJpbmdFRGF0YVR5cGUsInRleHQiLCIiLDAsMSxRdCwhMSwhMSwhMCwhMSwhMCwhMSksJG8oZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzLGFuLCJFbGtDb25uZWN0YWJsZVNoYXBlIiwhMCwhMSwhMCksZnIoYShPKEcoZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzKSwwKSwxOSksZS5lbGtFZGdlRUNsYXNzLGEoTyhHKGUuZWxrRWRnZUVDbGFzcyksMSksMTkpLCJvdXRnb2luZ0VkZ2VzIiwwLC0xLGFuLCExLCExLCEwLCExLCEwLCExLCExKSxmcihhKE8oRyhlLmVsa0Nvbm5lY3RhYmxlU2hhcGVFQ2xhc3MpLDEpLDE5KSxlLmVsa0VkZ2VFQ2xhc3MsYShPKEcoZS5lbGtFZGdlRUNsYXNzKSwyKSwxOSksImluY29taW5nRWRnZXMiLDAsLTEsYW4sITEsITEsITAsITEsITAsITEsITEpLCRvKGUuZWxrTm9kZUVDbGFzcyxVbiwiRWxrTm9kZSIsITEsITEsITApLGZyKGEoTyhHKGUuZWxrTm9kZUVDbGFzcyksMCksMTkpLGUuZWxrUG9ydEVDbGFzcyxhKE8oRyhlLmVsa1BvcnRFQ2xhc3MpLDApLDE5KSwicG9ydHMiLDAsLTEsVW4sITEsITEsITAsITAsITEsITEsITEpLGZyKGEoTyhHKGUuZWxrTm9kZUVDbGFzcyksMSksMTkpLGUuZWxrTm9kZUVDbGFzcyxhKE8oRyhlLmVsa05vZGVFQ2xhc3MpLDIpLDE5KSwiY2hpbGRyZW4iLDAsLTEsVW4sITEsITEsITAsITAsITEsITEsITEpLGZyKGEoTyhHKGUuZWxrTm9kZUVDbGFzcyksMiksMTkpLGUuZWxrTm9kZUVDbGFzcyxhKE8oRyhlLmVsa05vZGVFQ2xhc3MpLDEpLDE5KSwicGFyZW50IiwwLDEsVW4sITEsITEsITAsITEsITEsITEsITEpLGZyKGEoTyhHKGUuZWxrTm9kZUVDbGFzcyksMyksMTkpLGUuZWxrRWRnZUVDbGFzcyxhKE8oRyhlLmVsa0VkZ2VFQ2xhc3MpLDApLDE5KSwiY29udGFpbmVkRWRnZXMiLDAsLTEsVW4sITEsITEsITAsITAsITEsITEsITEpLE9yKGEoTyhHKGUuZWxrTm9kZUVDbGFzcyksNCksMzUpLGUuZWNvcmVQYWNrYWdlLmVCb29sZWFuRURhdGFUeXBlLCJoaWVyYXJjaGljYWwiLG51bGwsMCwxLFVuLCEwLCEwLCExLCExLCEwLCEwKSwkbyhlLmVsa1BvcnRFQ2xhc3MsdWEsIkVsa1BvcnQiLCExLCExLCEwKSxmcihhKE8oRyhlLmVsa1BvcnRFQ2xhc3MpLDApLDE5KSxlLmVsa05vZGVFQ2xhc3MsYShPKEcoZS5lbGtOb2RlRUNsYXNzKSwwKSwxOSksInBhcmVudCIsMCwxLHVhLCExLCExLCEwLCExLCExLCExLCExKSwkbyhlLmVsa0VkZ2VFQ2xhc3MsTXIsIkVsa0VkZ2UiLCExLCExLCEwKSxmcihhKE8oRyhlLmVsa0VkZ2VFQ2xhc3MpLDApLDE5KSxlLmVsa05vZGVFQ2xhc3MsYShPKEcoZS5lbGtOb2RlRUNsYXNzKSwzKSwxOSksImNvbnRhaW5pbmdOb2RlIiwwLDEsTXIsITEsITEsITAsITEsITEsITEsITEpLGZyKGEoTyhHKGUuZWxrRWRnZUVDbGFzcyksMSksMTkpLGUuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyxhKE8oRyhlLmVsa0Nvbm5lY3RhYmxlU2hhcGVFQ2xhc3MpLDApLDE5KSwic291cmNlcyIsMCwtMSxNciwhMSwhMSwhMCwhMSwhMCwhMSwhMSksZnIoYShPKEcoZS5lbGtFZGdlRUNsYXNzKSwyKSwxOSksZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzLGEoTyhHKGUuZWxrQ29ubmVjdGFibGVTaGFwZUVDbGFzcyksMSksMTkpLCJ0YXJnZXRzIiwwLC0xLE1yLCExLCExLCEwLCExLCEwLCExLCExKSxmcihhKE8oRyhlLmVsa0VkZ2VFQ2xhc3MpLDMpLDE5KSxlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzLGEoTyhHKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDUpLDE5KSwic2VjdGlvbnMiLDAsLTEsTXIsITEsITEsITAsITAsITEsITEsITEpLE9yKGEoTyhHKGUuZWxrRWRnZUVDbGFzcyksNCksMzUpLGUuZWNvcmVQYWNrYWdlLmVCb29sZWFuRURhdGFUeXBlLCJoeXBlcmVkZ2UiLG51bGwsMCwxLE1yLCEwLCEwLCExLCExLCEwLCEwKSxPcihhKE8oRyhlLmVsa0VkZ2VFQ2xhc3MpLDUpLDM1KSxlLmVjb3JlUGFja2FnZS5lQm9vbGVhbkVEYXRhVHlwZSwiaGllcmFyY2hpY2FsIixudWxsLDAsMSxNciwhMCwhMCwhMSwhMSwhMCwhMCksT3IoYShPKEcoZS5lbGtFZGdlRUNsYXNzKSw2KSwzNSksZS5lY29yZVBhY2thZ2UuZUJvb2xlYW5FRGF0YVR5cGUsInNlbGZsb29wIixudWxsLDAsMSxNciwhMCwhMCwhMSwhMSwhMCwhMCksT3IoYShPKEcoZS5lbGtFZGdlRUNsYXNzKSw3KSwzNSksZS5lY29yZVBhY2thZ2UuZUJvb2xlYW5FRGF0YVR5cGUsImNvbm5lY3RlZCIsbnVsbCwwLDEsTXIsITAsITAsITEsITEsITAsITApLCRvKGUuZWxrQmVuZFBvaW50RUNsYXNzLEJhLCJFbGtCZW5kUG9pbnQiLCExLCExLCEwKSxPcihhKE8oRyhlLmVsa0JlbmRQb2ludEVDbGFzcyksMCksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsIngiLCIwLjAiLDEsMSxCYSwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lbGtCZW5kUG9pbnRFQ2xhc3MpLDEpLDM1KSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ5IiwiMC4wIiwxLDEsQmEsITEsITEsITAsITEsITAsITEpLHk9RGcoZS5lbGtCZW5kUG9pbnRFQ2xhc3MsbnVsbCwic2V0IiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ4IiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ5IiksJG8oZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyxnciwiRWxrRWRnZVNlY3Rpb24iLCExLCExLCEwKSxPcihhKE8oRyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSwwKSwzNSksZS5lY29yZVBhY2thZ2UuZURvdWJsZUVEYXRhVHlwZSwic3RhcnRYIixudWxsLDAsMSxnciwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyksMSksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsInN0YXJ0WSIsbnVsbCwwLDEsZ3IsITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDIpLDM1KSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJlbmRYIixudWxsLDAsMSxnciwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyksMyksMzUpLGUuZWNvcmVQYWNrYWdlLmVEb3VibGVFRGF0YVR5cGUsImVuZFkiLG51bGwsMCwxLGdyLCExLCExLCEwLCExLCEwLCExKSxmcihhKE8oRyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw0KSwxOSksZS5lbGtCZW5kUG9pbnRFQ2xhc3MsbnVsbCwiYmVuZFBvaW50cyIsMCwtMSxnciwhMSwhMSwhMCwhMCwhMSwhMSwhMSksZnIoYShPKEcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyksNSksMTkpLGUuZWxrRWRnZUVDbGFzcyxhKE8oRyhlLmVsa0VkZ2VFQ2xhc3MpLDMpLDE5KSwicGFyZW50IiwwLDEsZ3IsITEsITEsITAsITEsITEsITEsITEpLGZyKGEoTyhHKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDYpLDE5KSxlLmVsa0Nvbm5lY3RhYmxlU2hhcGVFQ2xhc3MsbnVsbCwib3V0Z29pbmdTaGFwZSIsMCwxLGdyLCExLCExLCEwLCExLCEwLCExLCExKSxmcihhKE8oRyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw3KSwxOSksZS5lbGtDb25uZWN0YWJsZVNoYXBlRUNsYXNzLG51bGwsImluY29taW5nU2hhcGUiLDAsMSxnciwhMSwhMSwhMCwhMSwhMCwhMSwhMSksZnIoYShPKEcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyksOCksMTkpLGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MsYShPKEcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyksOSksMTkpLCJvdXRnb2luZ1NlY3Rpb25zIiwwLC0xLGdyLCExLCExLCEwLCExLCEwLCExLCExKSxmcihhKE8oRyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw5KSwxOSksZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyxhKE8oRyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzKSw4KSwxOSksImluY29taW5nU2VjdGlvbnMiLDAsLTEsZ3IsITEsITEsITAsITEsITAsITEsITEpLE9yKGEoTyhHKGUuZWxrRWRnZVNlY3Rpb25FQ2xhc3MpLDEwKSwzNSksZS5lY29yZVBhY2thZ2UuZVN0cmluZ0VEYXRhVHlwZSwiaWRlbnRpZmllciIsbnVsbCwwLDEsZ3IsITEsITEsITAsITEsITAsITEpLHk9RGcoZS5lbGtFZGdlU2VjdGlvbkVDbGFzcyxudWxsLCJzZXRTdGFydExvY2F0aW9uIiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ4IiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ5IikseT1EZyhlLmVsa0VkZ2VTZWN0aW9uRUNsYXNzLG51bGwsInNldEVuZExvY2F0aW9uIiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ4IiksbG8oeSxlLmVjb3JlUGFja2FnZS5lRG91YmxlRURhdGFUeXBlLCJ5IiksJG8oZS5lbGtQcm9wZXJ0eVRvVmFsdWVNYXBFbnRyeUVDbGFzcyxFXywiRWxrUHJvcGVydHlUb1ZhbHVlTWFwRW50cnkiLCExLCExLCExKSxfPW1jKGUuaVByb3BlcnR5RURhdGFUeXBlKSxkPShjPShuPW5ldyBNZCxuKSxjKSxwbigoIV8uZVR5cGVBcmd1bWVudHMmJihfLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxfLDEpKSxfLmVUeXBlQXJndW1lbnRzKSxkKSx4JGUoYShPKEcoZS5lbGtQcm9wZXJ0eVRvVmFsdWVNYXBFbnRyeUVDbGFzcyksMCksMzUpLF8sImtleSIsRV8sITEsITEsITAsITEpLE9yKGEoTyhHKGUuZWxrUHJvcGVydHlUb1ZhbHVlTWFwRW50cnlFQ2xhc3MpLDEpLDM1KSxlLnByb3BlcnR5VmFsdWVFRGF0YVR5cGUsInZhbHVlIixudWxsLDAsMSxFXywhMSwhMSwhMCwhMSwhMCwhMSksSG4oZS5pUHJvcGVydHlFRGF0YVR5cGUscU0sIklQcm9wZXJ0eSIsITApLEhuKGUucHJvcGVydHlWYWx1ZUVEYXRhVHlwZSxRciwiUHJvcGVydHlWYWx1ZSIsITApLFNuZShlLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2Vsay9FbGtHcmFwaCIpKX1mdW5jdGlvbiBMJGUoKXtDbmUuY2FsbCh0aGlzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2Vsay9FbGtHcmFwaCIsKFgwKCksciRlKSksdGhpcy5pUHJvcGVydHlIb2xkZXJFQ2xhc3M9bnVsbCx0aGlzLmVNYXBQcm9wZXJ0eUhvbGRlckVDbGFzcz1udWxsLHRoaXMuZWxrR3JhcGhFbGVtZW50RUNsYXNzPW51bGwsdGhpcy5lbGtTaGFwZUVDbGFzcz1udWxsLHRoaXMuZWxrTGFiZWxFQ2xhc3M9bnVsbCx0aGlzLmVsa0Nvbm5lY3RhYmxlU2hhcGVFQ2xhc3M9bnVsbCx0aGlzLmVsa05vZGVFQ2xhc3M9bnVsbCx0aGlzLmVsa1BvcnRFQ2xhc3M9bnVsbCx0aGlzLmVsa0VkZ2VFQ2xhc3M9bnVsbCx0aGlzLmVsa0JlbmRQb2ludEVDbGFzcz1udWxsLHRoaXMuZWxrRWRnZVNlY3Rpb25FQ2xhc3M9bnVsbCx0aGlzLmVsa1Byb3BlcnR5VG9WYWx1ZU1hcEVudHJ5RUNsYXNzPW51bGwsdGhpcy5pUHJvcGVydHlFRGF0YVR5cGU9bnVsbCx0aGlzLnByb3BlcnR5VmFsdWVFRGF0YVR5cGU9bnVsbCx0aGlzLmlzQ3JlYXRlZD0hMSx0aGlzLmlzSW5pdGlhbGl6ZWQ9ITF9ZnVuY3Rpb24gYnZuKCl7dmFyIGU7cmV0dXJuIGskZT9hKGEyKChuXygpLFBsKSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbGsvRWxrR3JhcGgiKSwyMTE1KTooZT1hKEwobmkoKG5fKCksUGwpLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2Vsay9FbGtHcmFwaCIpLDU2OSk/bmkoUGwsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZWxrL0Vsa0dyYXBoIik6bmV3IEwkZSw1NjkpLGskZT0hMCxDdm4oZSksVHZuKGUpLGVEKGUpLHRvKFBsLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2Vsay9FbGtHcmFwaCIsZSksZSl9cCg1NjksMTg0LHsxMTA6MSwyMTE1OjEsNTY5OjEsOTQ6MSw5MzoxLDE1NToxLDE5NzoxLDU4OjEsMjQxOjEsMTE0OjEsNTQ6MSw5OToxLDE1ODoxLDE4NDoxLDExOToxLDEyMDoxLDY5MDoxfSxMJGUpLGwuaXNDcmVhdGVkPSExLGwuaXNJbml0aWFsaXplZD0hMTt2YXIgayRlPSExO2coIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5pbXBsIiwiRWxrR3JhcGhQYWNrYWdlSW1wbCIsNTY5KTtmdW5jdGlvbiBUbmUoZSxuLHIpe3JldHVybiByPUdhKGUsYShuLDU0KSw3LHIpLHJ9ZnVuY3Rpb24gYm5lKGUsbil7dmFyIHIsdDtyZXR1cm4gZS5lRmxhZ3NfMD4+MTY9PTc/ZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsMSxLVCxuKToodD1HdChhKGtlKChyPWEoQmUoZSwxNiksMjkpLHJ8fChLbygpLEZlZSkpLGUuZUZsYWdzXzA+PjE2KSwxOSkpLGUuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLHQuZmVhdHVyZUlELHQuY29udGFpbmVyQ2xhc3MsbikpfWZ1bmN0aW9uIE8kZShlKXtyZXR1cm4gZS5lRmxhZ3NfMD4+MTYhPTc/bnVsbDphKGUuZUNvbnRhaW5lciwxNjcpfWZ1bmN0aW9uIEluZShlLG4pe3ZhciByLHQ7aWYobiE9ZS5lQ29udGFpbmVyfHxlLmVGbGFnc18wPj4xNiE9NyYmbil7aWYoZjIoZSxuKSl0aHJvdyBiKG5ldyBHZSgiUmVjdXJzaXZlIGNvbnRhaW5tZW50IG5vdCBhbGxvd2VkIGZvciAiK00kZShlKSkpO3Q9bnVsbCxlLmVDb250YWluZXImJih0PShyPWUuZUZsYWdzXzA+PjE2LHI+PTA/Ym5lKGUsdCk6ZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsLTEtcixudWxsLHQpKSksbiYmKHQ9YShuLDU0KS5lSW52ZXJzZUFkZChlLDEsS1QsdCkpLHQ9VG5lKGUsbix0KSx0JiZ0LmRpc3BhdGNoXzAoKX1lbHNlIGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsNyxuLG4pKX1mdW5jdGlvbiB4bmUoZSxuKXt2YXIgcjtyPWUudGV4dF8wLGUudGV4dF8wPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSw4LHIsZS50ZXh0XzApKX1mdW5jdGlvbiBNJGUoZSl7dmFyIG47cmV0dXJuIGUuZUZsYWdzXzAmNjQ/WVIoZSk6KG49bmV3IExhKCJFbGtMYWJlbCIpLCFlLnRleHRfMHx8T24oT24oKG4uc3RyaW5nKz0nICInLG4pLGUudGV4dF8wKSwnIicpLE9uKFAxKE9uKFAxKE9uKFAxKE9uKFAxKChuLnN0cmluZys9IiAoIixuKSxlLnhfMCksIiwiKSxlLnlfMCksIiB8ICIpLGUud2lkdGhfMCksIiwiKSxlLmhlaWdodCksIikiKSxuLnN0cmluZyl9ZnVuY3Rpb24gUG5lKCl7fXAoMzY2LDc0MCx7MTEwOjEsMzQyOjEsMTY3OjEsMTM1OjEsNDIyOjEsMzY2OjEsOTY6MSw5NDoxLDkzOjEsNTg6MSwxMTQ6MSw1NDoxLDk5OjEsMTE5OjEsMTIwOjF9LFBuZSksbC5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZT1mdW5jdGlvbihuKXtyZXR1cm4gYm5lKHRoaXMsbil9LGwuZUdldD1mdW5jdGlvbihuLHIsdCl7c3dpdGNoKG4pe2Nhc2UgNzpyZXR1cm4gTyRlKHRoaXMpO2Nhc2UgODpyZXR1cm4gdGhpcy50ZXh0XzB9cmV0dXJuIGVuZSh0aGlzLG4scix0KX0sbC5lSW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbztzd2l0Y2gocil7Y2FzZSA3OnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShvPXRoaXMuZUZsYWdzXzA+PjE2LG8+PTA/Ym5lKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtbyxudWxsLHQpKSksVG5lKHRoaXMsYShuLDE2NyksdCl9cmV0dXJuIGpSKHRoaXMsbixyLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiByPT03P1RuZSh0aGlzLG51bGwsdCk6VlIodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDc6cmV0dXJuISFPJGUodGhpcyk7Y2FzZSA4OnJldHVybiFUZSgiIix0aGlzLnRleHRfMCl9cmV0dXJuIG5uZSh0aGlzLG4pfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXtzd2l0Y2gobil7Y2FzZSA3OkluZSh0aGlzLGEociwxNjcpKTtyZXR1cm47Y2FzZSA4OnhuZSh0aGlzLHhuKHIpKTtyZXR1cm59cm5lKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSxGZWV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDc6SW5lKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgODp4bmUodGhpcywiIik7cmV0dXJufXRuZSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gTSRlKHRoaXMpfSxsLnRleHRfMD0iIixnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguaW1wbCIsIkVsa0xhYmVsSW1wbCIsMzY2KTtmdW5jdGlvbiBObmUoZSxuLHIpe3JldHVybiByPUdhKGUsbiwxMSxyKSxyfWZ1bmN0aW9uIEFuZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT0xMT9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwxMCxVbixuKToodD1HdChhKGtlKChyPWEoQmUoZSwxNiksMjkpLHJ8fChLbygpLHplZSkpLGUuZUZsYWdzXzA+PjE2KSwxOSkpLGUuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLHQuZmVhdHVyZUlELHQuY29udGFpbmVyQ2xhc3MsbikpfWZ1bmN0aW9uIFVBKGUpe3JldHVybiFlLmNoaWxkcmVuJiYoZS5jaGlsZHJlbj1uZXcgVShVbixlLDEwLDExKSksZS5jaGlsZHJlbn1mdW5jdGlvbiBSJGUoZSl7cmV0dXJuIWUuY29udGFpbmVkRWRnZXMmJihlLmNvbnRhaW5lZEVkZ2VzPW5ldyBVKE1yLGUsMTIsMykpLGUuY29udGFpbmVkRWRnZXN9ZnVuY3Rpb24geXIoZSl7cmV0dXJuIGUuZUZsYWdzXzA+PjE2IT0xMT9udWxsOmEoZS5lQ29udGFpbmVyLDI3KX1mdW5jdGlvbiByRChlKXtyZXR1cm4hZS5wb3J0cyYmKGUucG9ydHM9bmV3IFUodWEsZSw5LDkpKSxlLnBvcnRzfWZ1bmN0aW9uIEl2bihlKXtyZXR1cm4hZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IFUoVW4sZSwxMCwxMSkpLGUuY2hpbGRyZW4uc2l6ZV8wPjB9ZnVuY3Rpb24gV0EoZSxuKXt2YXIgcix0O2lmKG4hPWUuZUNvbnRhaW5lcnx8ZS5lRmxhZ3NfMD4+MTYhPTExJiZuKXtpZihmMihlLG4pKXRocm93IGIobmV3IEdlKCJSZWN1cnNpdmUgY29udGFpbm1lbnQgbm90IGFsbG93ZWQgZm9yICIrTG5lKGUpKSk7dD1udWxsLGUuZUNvbnRhaW5lciYmKHQ9KHI9ZS5lRmxhZ3NfMD4+MTYscj49MD9BbmUoZSx0KTplLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwtMS1yLG51bGwsdCkpKSxuJiYodD1obShuLGUsMTAsdCkpLHQ9Tm5lKGUsbix0KSx0JiZ0LmRpc3BhdGNoXzAoKX1lbHNlIGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMTEsbixuKSl9ZnVuY3Rpb24gTG5lKGUpe3ZhciBuLHIsdDtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9ZUihlKToobj1uZXcgTGEoIkVsa05vZGUiKSxyPWUuaWRlbnRpZmllcixyP09uKE9uKChuLnN0cmluZys9JyAiJyxuKSxyKSwnIicpOighZS5sYWJlbHMmJihlLmxhYmVscz1uZXcgVShRdCxlLDEsNykpLGUubGFiZWxzLnNpemVfMD4wJiYodD0oIWUubGFiZWxzJiYoZS5sYWJlbHM9bmV3IFUoUXQsZSwxLDcpKSxhKE8oZS5sYWJlbHMsMCksMTM1KSkudGV4dF8wLCF0fHxPbihPbigobi5zdHJpbmcrPScgIicsbiksdCksJyInKSkpLE9uKFAxKE9uKFAxKE9uKFAxKE9uKFAxKChuLnN0cmluZys9IiAoIixuKSxlLnhfMCksIiwiKSxlLnlfMCksIiB8ICIpLGUud2lkdGhfMCksIiwiKSxlLmhlaWdodCksIikiKSxuLnN0cmluZyl9ZnVuY3Rpb24gX1MoKXtnJGUuY2FsbCh0aGlzKX1wKDIwNyw3NDEsezExMDoxLDM0MjoxLDg0OjEsMTY3OjEsMjc6MSw0MjI6MSwyMDc6MSw5NjoxLDk0OjEsOTM6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwxMTk6MSwxMjA6MX0sX1MpLGwuZUJhc2ljUmVtb3ZlRnJvbUNvbnRhaW5lckZlYXR1cmU9ZnVuY3Rpb24obil7cmV0dXJuIEFuZSh0aGlzLG4pfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3N3aXRjaChuKXtjYXNlIDk6cmV0dXJuIXRoaXMucG9ydHMmJih0aGlzLnBvcnRzPW5ldyBVKHVhLHRoaXMsOSw5KSksdGhpcy5wb3J0cztjYXNlIDEwOnJldHVybiF0aGlzLmNoaWxkcmVuJiYodGhpcy5jaGlsZHJlbj1uZXcgVShVbix0aGlzLDEwLDExKSksdGhpcy5jaGlsZHJlbjtjYXNlIDExOnJldHVybiB5cih0aGlzKTtjYXNlIDEyOnJldHVybiF0aGlzLmNvbnRhaW5lZEVkZ2VzJiYodGhpcy5jb250YWluZWRFZGdlcz1uZXcgVShNcix0aGlzLDEyLDMpKSx0aGlzLmNvbnRhaW5lZEVkZ2VzO2Nhc2UgMTM6cmV0dXJuIHplKCksIXRoaXMuY2hpbGRyZW4mJih0aGlzLmNoaWxkcmVuPW5ldyBVKFVuLHRoaXMsMTAsMTEpKSx0aGlzLmNoaWxkcmVuLnNpemVfMD4wfXJldHVybiBvbmUodGhpcyxuLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87c3dpdGNoKHIpe2Nhc2UgOTpyZXR1cm4hdGhpcy5wb3J0cyYmKHRoaXMucG9ydHM9bmV3IFUodWEsdGhpcyw5LDkpKSxoaSh0aGlzLnBvcnRzLG4sdCk7Y2FzZSAxMDpyZXR1cm4hdGhpcy5jaGlsZHJlbiYmKHRoaXMuY2hpbGRyZW49bmV3IFUoVW4sdGhpcywxMCwxMSkpLGhpKHRoaXMuY2hpbGRyZW4sbix0KTtjYXNlIDExOnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShvPXRoaXMuZUZsYWdzXzA+PjE2LG8+PTA/QW5lKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtbyxudWxsLHQpKSksTm5lKHRoaXMsYShuLDI3KSx0KTtjYXNlIDEyOnJldHVybiF0aGlzLmNvbnRhaW5lZEVkZ2VzJiYodGhpcy5jb250YWluZWRFZGdlcz1uZXcgVShNcix0aGlzLDEyLDMpKSxoaSh0aGlzLmNvbnRhaW5lZEVkZ2VzLG4sdCl9cmV0dXJuIGluZSh0aGlzLG4scix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtzd2l0Y2gocil7Y2FzZSA5OnJldHVybiF0aGlzLnBvcnRzJiYodGhpcy5wb3J0cz1uZXcgVSh1YSx0aGlzLDksOSkpLER0KHRoaXMucG9ydHMsbix0KTtjYXNlIDEwOnJldHVybiF0aGlzLmNoaWxkcmVuJiYodGhpcy5jaGlsZHJlbj1uZXcgVShVbix0aGlzLDEwLDExKSksRHQodGhpcy5jaGlsZHJlbixuLHQpO2Nhc2UgMTE6cmV0dXJuIE5uZSh0aGlzLG51bGwsdCk7Y2FzZSAxMjpyZXR1cm4hdGhpcy5jb250YWluZWRFZGdlcyYmKHRoaXMuY29udGFpbmVkRWRnZXM9bmV3IFUoTXIsdGhpcywxMiwzKSksRHQodGhpcy5jb250YWluZWRFZGdlcyxuLHQpfXJldHVybiBhbmUodGhpcyxuLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDk6cmV0dXJuISF0aGlzLnBvcnRzJiZ0aGlzLnBvcnRzLnNpemVfMCE9MDtjYXNlIDEwOnJldHVybiEhdGhpcy5jaGlsZHJlbiYmdGhpcy5jaGlsZHJlbi5zaXplXzAhPTA7Y2FzZSAxMTpyZXR1cm4hIXlyKHRoaXMpO2Nhc2UgMTI6cmV0dXJuISF0aGlzLmNvbnRhaW5lZEVkZ2VzJiZ0aGlzLmNvbnRhaW5lZEVkZ2VzLnNpemVfMCE9MDtjYXNlIDEzOnJldHVybiF0aGlzLmNoaWxkcmVuJiYodGhpcy5jaGlsZHJlbj1uZXcgVShVbix0aGlzLDEwLDExKSksdGhpcy5jaGlsZHJlbi5zaXplXzA+MH1yZXR1cm4gbG5lKHRoaXMsbil9LGwuZVNldD1mdW5jdGlvbihuLHIpe3N3aXRjaChuKXtjYXNlIDk6IXRoaXMucG9ydHMmJih0aGlzLnBvcnRzPW5ldyBVKHVhLHRoaXMsOSw5KSksZm4odGhpcy5wb3J0cyksIXRoaXMucG9ydHMmJih0aGlzLnBvcnRzPW5ldyBVKHVhLHRoaXMsOSw5KSksUHIodGhpcy5wb3J0cyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxMDohdGhpcy5jaGlsZHJlbiYmKHRoaXMuY2hpbGRyZW49bmV3IFUoVW4sdGhpcywxMCwxMSkpLGZuKHRoaXMuY2hpbGRyZW4pLCF0aGlzLmNoaWxkcmVuJiYodGhpcy5jaGlsZHJlbj1uZXcgVShVbix0aGlzLDEwLDExKSksUHIodGhpcy5jaGlsZHJlbixhKHIsMTYpKTtyZXR1cm47Y2FzZSAxMTpXQSh0aGlzLGEociwyNykpO3JldHVybjtjYXNlIDEyOiF0aGlzLmNvbnRhaW5lZEVkZ2VzJiYodGhpcy5jb250YWluZWRFZGdlcz1uZXcgVShNcix0aGlzLDEyLDMpKSxmbih0aGlzLmNvbnRhaW5lZEVkZ2VzKSwhdGhpcy5jb250YWluZWRFZGdlcyYmKHRoaXMuY29udGFpbmVkRWRnZXM9bmV3IFUoTXIsdGhpcywxMiwzKSksUHIodGhpcy5jb250YWluZWRFZGdlcyxhKHIsMTYpKTtyZXR1cm59c25lKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSx6ZWV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDk6IXRoaXMucG9ydHMmJih0aGlzLnBvcnRzPW5ldyBVKHVhLHRoaXMsOSw5KSksZm4odGhpcy5wb3J0cyk7cmV0dXJuO2Nhc2UgMTA6IXRoaXMuY2hpbGRyZW4mJih0aGlzLmNoaWxkcmVuPW5ldyBVKFVuLHRoaXMsMTAsMTEpKSxmbih0aGlzLmNoaWxkcmVuKTtyZXR1cm47Y2FzZSAxMTpXQSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDEyOiF0aGlzLmNvbnRhaW5lZEVkZ2VzJiYodGhpcy5jb250YWluZWRFZGdlcz1uZXcgVShNcix0aGlzLDEyLDMpKSxmbih0aGlzLmNvbnRhaW5lZEVkZ2VzKTtyZXR1cm59dW5lKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBMbmUodGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5pbXBsIiwiRWxrTm9kZUltcGwiLDIwNyk7ZnVuY3Rpb24ga25lKGUsbixyKXtyZXR1cm4gcj1HYShlLG4sOSxyKSxyfWZ1bmN0aW9uIE9uZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT05P2UuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLDksVW4sbik6KHQ9R3QoYShrZSgocj1hKEJlKGUsMTYpLDI5KSxyfHwoS28oKSwkZWUpKSxlLmVGbGFnc18wPj4xNiksMTkpKSxlLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSx0LmZlYXR1cmVJRCx0LmNvbnRhaW5lckNsYXNzLG4pKX1mdW5jdGlvbiBqcyhlKXtyZXR1cm4gZS5lRmxhZ3NfMD4+MTYhPTk/bnVsbDphKGUuZUNvbnRhaW5lciwyNyl9ZnVuY3Rpb24gTW5lKGUsbil7dmFyIHIsdDtpZihuIT1lLmVDb250YWluZXJ8fGUuZUZsYWdzXzA+PjE2IT05JiZuKXtpZihmMihlLG4pKXRocm93IGIobmV3IEdlKCJSZWN1cnNpdmUgY29udGFpbm1lbnQgbm90IGFsbG93ZWQgZm9yICIrRCRlKGUpKSk7dD1udWxsLGUuZUNvbnRhaW5lciYmKHQ9KHI9ZS5lRmxhZ3NfMD4+MTYscj49MD9PbmUoZSx0KTplLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwtMS1yLG51bGwsdCkpKSxuJiYodD1obShuLGUsOSx0KSksdD1rbmUoZSxuLHQpLHQmJnQuZGlzcGF0Y2hfMCgpfWVsc2UgZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSw5LG4sbikpfWZ1bmN0aW9uIEQkZShlKXt2YXIgbixyLHQ7cmV0dXJuIGUuZUZsYWdzXzAmNjQ/WVIoZSk6KG49bmV3IExhKCJFbGtQb3J0Iikscj1lLmlkZW50aWZpZXIscj9PbihPbigobi5zdHJpbmcrPScgIicsbiksciksJyInKTooIWUubGFiZWxzJiYoZS5sYWJlbHM9bmV3IFUoUXQsZSwxLDcpKSxlLmxhYmVscy5zaXplXzA+MCYmKHQ9KCFlLmxhYmVscyYmKGUubGFiZWxzPW5ldyBVKFF0LGUsMSw3KSksYShPKGUubGFiZWxzLDApLDEzNSkpLnRleHRfMCwhdHx8T24oT24oKG4uc3RyaW5nKz0nICInLG4pLHQpLCciJykpKSxPbihQMShPbihQMShPbihQMShPbihQMSgobi5zdHJpbmcrPSIgKCIsbiksZS54XzApLCIsIiksZS55XzApLCIgfCAiKSxlLndpZHRoXzApLCIsIiksZS5oZWlnaHQpLCIpIiksbi5zdHJpbmcpfWZ1bmN0aW9uIFJuZSgpe2ckZS5jYWxsKHRoaXMpfXAoMTkzLDc0MSx7MTEwOjEsMzQyOjEsODQ6MSwxNjc6MSwxMjM6MSw0MjI6MSwxOTM6MSw5NjoxLDk0OjEsOTM6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwxMTk6MSwxMjA6MX0sUm5lKSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBPbmUodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gbj09OT9qcyh0aGlzKTpvbmUodGhpcyxuLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87c3dpdGNoKHIpe2Nhc2UgOTpyZXR1cm4gdGhpcy5lQ29udGFpbmVyJiYodD0obz10aGlzLmVGbGFnc18wPj4xNixvPj0wP09uZSh0aGlzLHQpOnRoaXMuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZSh0aGlzLC0xLW8sbnVsbCx0KSkpLGtuZSh0aGlzLGEobiwyNyksdCl9cmV0dXJuIGluZSh0aGlzLG4scix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gcj09OT9rbmUodGhpcyxudWxsLHQpOmFuZSh0aGlzLG4scix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7cmV0dXJuIG49PTk/ISFqcyh0aGlzKTpsbmUodGhpcyxuKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7c3dpdGNoKG4pe2Nhc2UgOTpNbmUodGhpcyxhKHIsMjcpKTtyZXR1cm59c25lKHRoaXMsbixyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gS28oKSwkZWV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDk6TW5lKHRoaXMsbnVsbCk7cmV0dXJufXVuZSh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gRCRlKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguaW1wbCIsIkVsa1BvcnRJbXBsIiwxOTMpO3ZhciBGJGU9Q3IoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkJhc2ljRU1hcC9FbnRyeSIpO2Z1bmN0aW9uIERuZShlLG4pe3ZhciByO3I9ZS5rZXksZS5rZXk9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDAscixlLmtleSkpfWZ1bmN0aW9uIEZuZShlLG4pe3ZhciByO3I9ZS52YWx1ZV8wLGUudmFsdWVfMD1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMSxyLGUudmFsdWVfMCkpfWZ1bmN0aW9uIHokZSgpe31wKDExMjIsMTIwLHsxMTA6MSw0NDoxLDk0OjEsOTM6MSwxMzY6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwxMTk6MSwxMjA6MX0seiRlKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBSMSh0aGlzKX0sbC5zZXRLZXk9ZnVuY3Rpb24obil7RG5lKHRoaXMsYShuLDE0OSkpfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIHRoaXMua2V5O2Nhc2UgMTpyZXR1cm4gdGhpcy52YWx1ZV8wfXJldHVybiBQQSh0aGlzLG4scix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMua2V5O2Nhc2UgMTpyZXR1cm4gdGhpcy52YWx1ZV8wIT1udWxsfXJldHVybiBGUih0aGlzLG4pfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXtzd2l0Y2gobil7Y2FzZSAwOkRuZSh0aGlzLGEociwxNDkpKTtyZXR1cm47Y2FzZSAxOkZuZSh0aGlzLHIpO3JldHVybn0kUih0aGlzLG4scil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIEtvKCksVXV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDA6RG5lKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMTpGbmUodGhpcyxudWxsKTtyZXR1cm59QlIodGhpcyxuKX0sbC5nZXRIYXNoPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuaGFzaD09LTEmJihuPXRoaXMua2V5LHRoaXMuaGFzaD1uP3VyKG4pOjApLHRoaXMuaGFzaH0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlXzB9LGwuc2V0SGFzaD1mdW5jdGlvbihuKXt0aGlzLmhhc2g9bn0sbC5zZXRWYWx1ZT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj10aGlzLnZhbHVlXzAsRm5lKHRoaXMsbikscn0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuZUZsYWdzXzAmNjQ/bnModGhpcyk6KG49bmV3IEMwLE9uKE9uKE9uKG4sdGhpcy5rZXk/dGhpcy5rZXkuZ2V0SWQoKToibnVsbCIpLCIgLT4gIiksejIodGhpcy52YWx1ZV8wKSksbi5zdHJpbmcpfSxsLmhhc2g9LTEsbC52YWx1ZV8wPW51bGw7dmFyIGUwPWcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5pbXBsIiwiRWxrUHJvcGVydHlUb1ZhbHVlTWFwRW50cnlJbXBsIiwxMTIyKTtmdW5jdGlvbiB5bShlLG4pe3ZhciByO3I9ZS5qc0FycmF5Lmxlbmd0aCxKZChlLHIpLHk1KGUscixuKX1mdW5jdGlvbiAkJGUoZSxuKXt2YXIgcix0O2lmKHQ9ITEsdXQobikmJih0PSEwLHltKGUsbmV3IFpkKHhuKG4pKSkpLHR8fEwobiwyNDIpJiYodD0hMCx5bShlLChyPUckKGEobiwyNDIpKSxuZXcgJEkocikpKSksIXQpdGhyb3cgYihuZXcgazUoIlNldmVyZSBpbXBsZW1lbnRhdGlvbiBlcnJvciBpbiB0aGUgSnNvbiB0byBFbGtHcmFwaCBpbXBvcnRlci4iKSl9ZnVuY3Rpb24gYTEoZSxuLHIpe3ZhciB0LG87dD1HJChyKSxvPW5ldyAkSSh0KSxhcyhlLG4sbyl9ZnVuY3Rpb24gem5lKGUsbixyLHQpe3ZhciBvO2lmKG89ITEsdXQodCkmJihvPSEwLCR3KG4scix4bih0KSkpLG98fFZkKHQpJiYobz0hMCx6bmUoZSxuLHIsdCkpLG98fEwodCwyNDIpJiYobz0hMCxhMShuLHIsYSh0LDI0MikpKSwhbyl0aHJvdyBiKG5ldyBrNSgiU2V2ZXJlIGltcGxlbWVudGF0aW9uIGVycm9yIGluIHRoZSBKc29uIHRvIEVsa0dyYXBoIGltcG9ydGVyLiIpKX1mdW5jdGlvbiAkdyhlLG4scil7dmFyIHQ7dD1uZXcgWmQociksYXMoZSxuLHQpfWZ1bmN0aW9uIHdtKGUpe3ZhciBuLHI7aWYocj0hMSxMKGUsMjExKSlyZXR1cm4gcj0hMCxhKGUsMjExKS52YWx1ZV8wO2lmKCFyJiZMKGUsMjYzKSYmKG49YShlLDI2MykudmFsdWVfMCUxPT0wLG4pKXJldHVybiByPSEwLEooYVplKGEoZSwyNjMpLnZhbHVlXzApKTt0aHJvdyBiKG5ldyB3dSgiSWQgbXVzdCBiZSBhIHN0cmluZyBvciBhbiBpbnRlZ2VyOiAnIitlKyInLiIpKX1mdW5jdGlvbiBCdyhlKXt2YXIgbixyLHQ7aWYodD1udWxsLG49ImlkImluIGUuanNPYmplY3Qscj0hbixyKXRocm93IGIobmV3IHd1KCJFdmVyeSBlbGVtZW50IG11c3QgaGF2ZSBhbiBpZC4iKSk7cmV0dXJuIHQ9d20oUXUoZSwiaWQiKSksdH1mdW5jdGlvbiB5YyhlLG4pe3ZhciByLHQ7cmV0dXJuIHI9biBpbiBlLmpzT2JqZWN0LHImJih0PVF1KGUsbikuaXNOdW1iZXIoKSx0KT90LnZhbHVlXzA6bnVsbH1mdW5jdGlvbiB4ZChlLG4pe3ZhciByLHQ7cmV0dXJuIHI9UXUoZSxuKSx0PW51bGwsciYmKHQ9ci5pc0FycmF5XzAoKSksdH1mdW5jdGlvbiBHdyhlLG4pe3ZhciByLHQ7cmV0dXJuIHI9SmQoZSxuKSx0PW51bGwsciYmKHQ9ci5pc09iamVjdCgpKSx0fWZ1bmN0aW9uIGRTKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1RdShlLG4pLHQ9bnVsbCxyJiYodD1yLmlzT2JqZWN0KCkpLHR9ZnVuY3Rpb24gd2MoZSxuKXt2YXIgcix0O3JldHVybiByPVF1KGUsbiksdD1udWxsLHImJih0PSRuZShyKSksdH1mdW5jdGlvbiAkbmUoZSl7dmFyIG4scjtpZihyPW51bGwsbj0hMSxMKGUsMjExKSYmKG49ITAscj1hKGUsMjExKS52YWx1ZV8wKSxufHxMKGUsMjYzKSYmKG49ITAscj0iIithKGUsMjYzKS52YWx1ZV8wKSxufHxMKGUsNDkzKSYmKG49ITAscj0iIithKGUsNDkzKS52YWx1ZV8wKSwhbil0aHJvdyBiKG5ldyBrNSgiU2V2ZXJlIGltcGxlbWVudGF0aW9uIGVycm9yIGluIHRoZSBKc29uIHRvIEVsa0dyYXBoIGltcG9ydGVyLiIpKTtyZXR1cm4gcn1mdW5jdGlvbiBCJGUoKXt9cCg5OTYsMSx7fSxCJGUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkFkYXB0ZXIiLDk5Nik7ZnVuY3Rpb24gd3UoZSl7SW8uY2FsbCh0aGlzLGUpfXAoMjE2LDYzLEt1LHd1KSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRFeGNlcHRpb24iLDIxNik7ZnVuY3Rpb24geHZuKGUsbil7cmV0dXJuIGZJKFk2KGUuZWRnZVNlY3Rpb25JZE1hcCksbil9ZnVuY3Rpb24gUHZuKGUsbil7cmV0dXJuIGZJKFk2KGUubm9kZUlkTWFwKSxuKX1mdW5jdGlvbiBOdm4oZSxuKXtyZXR1cm4gZkkoWTYoZS5wb3J0SWRNYXApLG4pfWZ1bmN0aW9uIEF2bihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtpZihoPWEoS2UoZS5lZGdlSnNvbk1hcCxuKSwxOTApLCFoKXRocm93IGIobmV3IHd1KCJFZGdlIGRpZCBub3QgZXhpc3QgaW4gaW5wdXQuIikpO3JldHVybiBfPUJ3KGgpLGk9R2IoKCFuLnNlY3Rpb25zJiYobi5zZWN0aW9ucz1uZXcgVShncixuLDYsNikpLG4uc2VjdGlvbnMpKSx1PSFpLHUmJihtPW5ldyBUXyxyPW5ldyBTQmUoZSxfLG0pLENJbigoIW4uc2VjdGlvbnMmJihuLnNlY3Rpb25zPW5ldyBVKGdyLG4sNiw2KSksbi5zZWN0aW9ucyksciksYXMoaCwic2VjdGlvbnMiLG0pKSxvPVdzKG4sKEZuKCkseWQpKSxvJiYoZD1hKFYobix5ZCksNzUpLHM9IWR8fFBZZShkKSxjPSFzLGMmJihmPW5ldyBUXyx0PW5ldyB4QmUoZiksRXQoZCx0KSxhcyhoLCJqdW5jdGlvblBvaW50cyIsZikpKSwkdyhoLCJjb250YWluZXIiLFFUKG4pLmlkZW50aWZpZXIpLG51bGx9ZnVuY3Rpb24gTHZuKGUsbil7dmFyIHI7cmV0dXJuIHI9S2UoZS5sYWJlbEpzb25NYXAsbiksQm5lKG4sciksbnVsbH1mdW5jdGlvbiBrdm4oZSxuKXt2YXIgcjtpZihyPWJwKGUubm9kZUpzb25NYXAsbikscj09bnVsbCl0aHJvdyBiKG5ldyB3dSgiTm9kZSBkaWQgbm90IGV4aXN0IGluIGlucHV0LiIpKTtyZXR1cm4gQm5lKG4sciksbnVsbH1mdW5jdGlvbiBPdm4oZSxuKXt2YXIgcjtpZihyPUtlKGUucG9ydEpzb25NYXAsbikscj09bnVsbCl0aHJvdyBiKG5ldyB3dSgiUG9ydCBkaWQgbm90IGV4aXN0IGluIGlucHV0LiIpKTtyZXR1cm4gQm5lKG4sciksbnVsbH1mdW5jdGlvbiB0RChlLG4pe2lmKEwobiwyMDcpKXJldHVybiBQdm4oZSxhKG4sMjcpKTtpZihMKG4sMTkzKSlyZXR1cm4gTnZuKGUsYShuLDEyMykpO2lmKEwobiw0NTIpKXJldHVybiB4dm4oZSxhKG4sMTY2KSk7dGhyb3cgYihuZXcgR2UoIlVuaGFuZGxlZCBwYXJhbWV0ZXIgdHlwZXM6ICIrbTAobmV3IGVhKFAoSShRciwxKSxNZSwxLDUsW25dKSkpKSl9ZnVuY3Rpb24gTXZuKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKHIpZm9yKGk9ci5qc0FycmF5Lmxlbmd0aCx0PW5ldyBmMShpKSx1PSh0Lmxhc3QtdC5maXJzdCkqdC5zdGVwPDA/KHNfKCksdV8pOm5ldyBjXyh0KTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxNyksbz1HdyhyLHMudmFsdWVfMCksbyYmVyRlKGUsbyxuKX1mdW5jdGlvbiBSdm4oZSxuLHIpe3ZhciB0LG8saSxzLHU7aWYocilmb3Iobz1yLmpzQXJyYXkubGVuZ3RoLHQ9bmV3IGYxKG8pLHU9KHQubGFzdC10LmZpcnN0KSp0LnN0ZXA8MD8oc18oKSx1Xyk6bmV3IGNfKHQpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDE3KSxpPUd3KHIscy52YWx1ZV8wKSwic291cmNlcyJpbiBpLmpzT2JqZWN0fHwidGFyZ2V0cyJpbiBpLmpzT2JqZWN0P21TbihlLGksbik6RVNuKGUsaSxuKSx6U24oYShLZShlLmVkZ2VJZE1hcCxCdyhpKSksNzQpKX1mdW5jdGlvbiBEdm4oZSxuKXtVbmUoZSxSKHljKG4sIngiKSksUih5YyhuLCJ5IikpKX1mdW5jdGlvbiBGdm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpZihyKWZvcihvPXIuanNBcnJheS5sZW5ndGgsdD1uZXcgZjEobyksdT0odC5sYXN0LXQuZmlyc3QpKnQuc3RlcDwwPyhzXygpLHVfKTpuZXcgY18odCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMTcpLGM9b0QoZSx3bShKZChyLHMudmFsdWVfMCkpKSxjJiYoaT0oIW4uc291cmNlcyYmKG4uc291cmNlcz1uZXcgTGUoYW4sbiw0LDcpKSxuLnNvdXJjZXMpLHBuKGksYykpfWZ1bmN0aW9uIHp2bihlLG4scil7dmFyIHQsbyxpLHMsdSxjO2lmKHIpZm9yKG89ci5qc0FycmF5Lmxlbmd0aCx0PW5ldyBmMShvKSx1PSh0Lmxhc3QtdC5maXJzdCkqdC5zdGVwPDA/KHNfKCksdV8pOm5ldyBjXyh0KTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxNyksYz1vRChlLHdtKEpkKHIscy52YWx1ZV8wKSkpLGMmJihpPSghbi50YXJnZXRzJiYobi50YXJnZXRzPW5ldyBMZShhbixuLDUsOCkpLG4udGFyZ2V0cykscG4oaSxjKSl9ZnVuY3Rpb24gJHZuKGUsbixyLHQsbyl7dmFyIGkscyx1LGMsXyxkO2lmKG8pZm9yKGM9by5qc0FycmF5Lmxlbmd0aCxpPW5ldyBmMShjKSxkPShpLmxhc3QtaS5maXJzdCkqaS5zdGVwPDA/KHNfKCksdV8pOm5ldyBjXyhpKTtkLmhhc05leHRfMCgpOylfPWEoZC5uZXh0XzEoKSwxNyksdT1HdyhvLF8udmFsdWVfMCkscz1uZXcgWiRlKGUsbixyLHQpLEJ2bihzLiQkb3V0ZXJfMCxzLmVkZ2VfMSxzLmluY29taW5nU2VjdGlvbklkZW50aWZpZXJzXzIscy5vdXRnb2luZ1NlY3Rpb25JZGVudGlmaWVyc18zLHUpfWZ1bmN0aW9uIEJ2bihlLG4scix0LG8pe3ZhciBpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO209ZFNuKGUsV25lKG4pLG8pLGduZShtLHdjKG8sImlkIikpLHk9byxFPWRTKHksInN0YXJ0UG9pbnQiKSx2PW5ldyB0QmUobSksanZuKHYuc2VjdGlvbl8xLEUpLHg9ZFMoeSwiZW5kUG9pbnQiKSxBPW5ldyBsQmUobSkscXZuKEEuc2VjdGlvbl8xLHgpLGs9eGQoeSwiYmVuZFBvaW50cyIpLE09bmV3IGNCZShtKSxZdm4oTS5zZWN0aW9uXzEsayksZj13YyhvLCJpbmNvbWluZ1NoYXBlIiksaT1uZXcgUSRlKGUsbSksR3ZuKGkuJCRvdXRlcl8wLGkuZWxrU2VjdGlvbl8xLGYpLGg9d2Mobywib3V0Z29pbmdTaGFwZSIpLHM9bmV3IGVCZShlLG0pLEh2bihzLiQkb3V0ZXJfMCxzLmVsa1NlY3Rpb25fMSxoKSxfPXhkKG8sImluY29taW5nU2VjdGlvbnMiKSx1PW5ldyBuQmUocixtKSxVdm4odS5pbmNvbWluZ1NlY3Rpb25JZGVudGlmaWVyc18xLHUuZWxrU2VjdGlvbl8yLF8pLGQ9eGQobywib3V0Z29pbmdTZWN0aW9ucyIpLGM9bmV3IHJCZSh0LG0pLFd2bihjLm91dGdvaW5nU2VjdGlvbklkZW50aWZpZXJzXzEsYy5lbGtTZWN0aW9uXzIsZCl9ZnVuY3Rpb24gR3ZuKGUsbixyKXtyIT1udWxsJiZEQShuLG9EKGUscikpfWZ1bmN0aW9uIEh2bihlLG4scil7ciE9bnVsbCYmRkEobixvRChlLHIpKX1mdW5jdGlvbiBVdm4oZSxuLHIpe3ZhciB0LG8saSxzO2lmKHIpZm9yKG89ci5qc0FycmF5Lmxlbmd0aCx0PW5ldyBmMShvKSxzPSh0Lmxhc3QtdC5maXJzdCkqdC5zdGVwPDA/KHNfKCksdV8pOm5ldyBjXyh0KTtzLmhhc05leHRfMCgpOylpPWEocy5uZXh0XzEoKSwxNyksYmUoZSxuLHdtKEpkKHIsaS52YWx1ZV8wKSkpfWZ1bmN0aW9uIFd2bihlLG4scil7dmFyIHQsbyxpLHM7aWYocilmb3Iobz1yLmpzQXJyYXkubGVuZ3RoLHQ9bmV3IGYxKG8pLHM9KHQubGFzdC10LmZpcnN0KSp0LnN0ZXA8MD8oc18oKSx1Xyk6bmV3IGNfKHQpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDE3KSxiZShlLG4sd20oSmQocixpLnZhbHVlXzApKSl9ZnVuY3Rpb24ganZuKGUsbil7dmFyIHIsdCxvLGk7aWYobilvPXljKG4sIngiKSxyPW5ldyBpQmUoZSksRncoci5zZWN0aW9uXzAsKFZlKG8pLG8pKSxpPXljKG4sInkiKSx0PW5ldyBhQmUoZSksencodC5zZWN0aW9uXzAsKFZlKGkpLGkpKTtlbHNlIHRocm93IGIobmV3IHd1KCJBbGwgZWRnZSBzZWN0aW9ucyBuZWVkIGEgc3RhcnQgcG9pbnQuIikpfWZ1bmN0aW9uIFZ2bihlLG4pe3ZhciByLHQsbyxpLHM7aWYobilmb3Iobz1uLmpzQXJyYXkubGVuZ3RoLHI9bmV3IGYxKG8pLHM9KHIubGFzdC1yLmZpcnN0KSpyLnN0ZXA8MD8oc18oKSx1Xyk6bmV3IGNfKHIpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDE3KSx0PUd3KG4saS52YWx1ZV8wKSx0JiZVJGUoZSx0KX1mdW5jdGlvbiBxdm4oZSxuKXt2YXIgcix0LG8saTtpZihuKW89eWMobiwieCIpLHI9bmV3IHNCZShlKSxSdyhyLnNlY3Rpb25fMCwoVmUobyksbykpLGk9eWMobiwieSIpLHQ9bmV3IHVCZShlKSxEdyh0LnNlY3Rpb25fMCwoVmUoaSksaSkpO2Vsc2UgdGhyb3cgYihuZXcgd3UoIkFsbCBlZGdlIHNlY3Rpb25zIG5lZWQgYW4gZW5kIHBvaW50LiIpKX1mdW5jdGlvbiBZdm4oZSxuKXt2YXIgcix0LG8saSxzLHU7aWYobilmb3IoaT1uLmpzQXJyYXkubGVuZ3RoLHI9bmV3IGYxKGkpLHU9KHIubGFzdC1yLmZpcnN0KSpyLnN0ZXA8MD8oc18oKSx1Xyk6bmV3IGNfKHIpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDE3KSxvPUd3KG4scy52YWx1ZV8wKSx0PW5ldyBfQmUoZSksS3ZuKHQuc2VjdGlvbl8xLG8pfWZ1bmN0aW9uIEt2bihlLG4pe1VuZShlLFIoeWMobiwieCIpKSxSKHljKG4sInkiKSkpfWZ1bmN0aW9uIFh2bihlLG4scil7dmFyIHQsbyxpO3Q9UXUoZSxyKSxvPW51bGwsdCYmKG89JG5lKHQpKSxpPW8sSCRlKG4scixpKX1mdW5jdGlvbiBKdm4oZSxuLHIpe3ZhciB0LG8saTt0PVF1KGUsciksbz1udWxsLHQmJihvPSRuZSh0KSksaT1vLEgkZShuLHIsaSl9ZnVuY3Rpb24gWnZuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXztpZihyKWZvcihpPXIuanNBcnJheS5sZW5ndGgsdD1uZXcgZjEoaSksdT0odC5sYXN0LXQuZmlyc3QpKnQuc3RlcDwwPyhzXygpLHVfKTpuZXcgY18odCk7dS5oYXNOZXh0XzAoKTspcz1hKHUubmV4dF8xKCksMTcpLGM9R3cocixzLnZhbHVlXzApLGMmJihfPVJTbih3YyhjLCJ0ZXh0IiksbiksQm4oZS5sYWJlbEpzb25NYXAsXyxjKSxvPSJpZCJpbiBjLmpzT2JqZWN0LG8mJk13KF8sd2MoYywiaWQiKSksakEoYyxfKSxHbmUoYyxfKSl9ZnVuY3Rpb24gUXZuKGUsbil7dmFyIHIsdCxvLGk7biYmKG89eWMobiwieCIpLHI9bmV3IElCZShlKSxGdyhyLnNlY3Rpb25fMCwoVmUobyksbykpLGk9eWMobiwieSIpLHQ9bmV3IFBCZShlKSx6dyh0LnNlY3Rpb25fMCwoVmUoaSksaSkpKX1mdW5jdGlvbiBlU24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7aWYocilmb3IoaT1yLmpzQXJyYXkubGVuZ3RoLHQ9bmV3IGYxKGkpLHU9KHQubGFzdC10LmZpcnN0KSp0LnN0ZXA8MD8oc18oKSx1Xyk6bmV3IGNfKHQpO3UuaGFzTmV4dF8wKCk7KXM9YSh1Lm5leHRfMSgpLDE3KSxvPUd3KHIscy52YWx1ZV8wKSxvJiYoYz1wU24oZSwoXz0oWDAoKSxkPW5ldyBSbmUsZCksbiYmTW5lKF8sbiksXyksbyksTXcoYyx3YyhvLCJpZCIpKSxqQShvLGMpLEduZShvLGMpLGlEKGUsbyxjKSl9ZnVuY3Rpb24gblNuKGUsbil7Q2koZSxuPT1udWxsfHxVSSgoVmUobiksbikpfHxpc05hTigoVmUobiksbikpPzA6KFZlKG4pLG4pKX1mdW5jdGlvbiByU24oZSxuKXtUaShlLG49PW51bGx8fFVJKChWZShuKSxuKSl8fGlzTmFOKChWZShuKSxuKSk/MDooVmUobiksbikpfWZ1bmN0aW9uIHRTbihlLG4pe1RkKGUsbj09bnVsbHx8VUkoKFZlKG4pLG4pKXx8aXNOYU4oKFZlKG4pLG4pKT8wOihWZShuKSxuKSl9ZnVuY3Rpb24gb1NuKGUsbil7Q2QoZSxuPT1udWxsfHxVSSgoVmUobiksbikpfHxpc05hTigoVmUobiksbikpPzA6KFZlKG4pLG4pKX1mdW5jdGlvbiBpU24oZSxuLHIsdCxvKXt2YXIgaSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHEsbmUsdmUsd2UsRGUsRmUsbm47RGU9S2UoZS5lZGdlU2VjdGlvbkpzb25NYXAsdCksRGU9PW51bGwmJihEZT1uZXcgc2gsbT1hKERlLDE5MCksQT1uKyJfcyIsaz1BK28saD1uZXcgWmQoayksYXMobSwiaWQiLGgpKSx3ZT1hKERlLDE5MCkseW0ocix3ZSksbm49bmV3IHNoLGExKG5uLCJ4Iix0LnN0YXJ0WCksYTEobm4sInkiLHQuc3RhcnRZKSxhcyh3ZSwic3RhcnRQb2ludCIsbm4pLG5lPW5ldyBzaCxhMShuZSwieCIsdC5lbmRYKSxhMShuZSwieSIsdC5lbmRZKSxhcyh3ZSwiZW5kUG9pbnQiLG5lKSxmPUdiKCghdC5iZW5kUG9pbnRzJiYodC5iZW5kUG9pbnRzPW5ldyBqcihCYSx0LDUpKSx0LmJlbmRQb2ludHMpKSx5PSFmLHkmJihxPW5ldyBUXyxpPW5ldyBDQmUocSksRXQoKCF0LmJlbmRQb2ludHMmJih0LmJlbmRQb2ludHM9bmV3IGpyKEJhLHQsNSkpLHQuYmVuZFBvaW50cyksaSksYXMod2UsImJlbmRQb2ludHMiLHEpKSxjPVhSKHQpLE09ISFjLE0mJnpuZShlLl9qc29uQWRhcHRlcix3ZSwiaW5jb21pbmdTaGFwZSIsdEQoZSxYUih0KSkpLHg9SlIodCksSD0hIXgsSCYmem5lKGUuX2pzb25BZGFwdGVyLHdlLCJvdXRnb2luZ1NoYXBlIix0RChlLEpSKHQpKSksXz0oIXQuaW5jb21pbmdTZWN0aW9ucyYmKHQuaW5jb21pbmdTZWN0aW9ucz1uZXcgTGUoZ3IsdCwxMCw5KSksdC5pbmNvbWluZ1NlY3Rpb25zKS5zaXplXzA9PTAsRT0hXyxFJiYodmU9bmV3IFRfLHM9bmV3IFRCZShlLHZlKSxFdCgoIXQuaW5jb21pbmdTZWN0aW9ucyYmKHQuaW5jb21pbmdTZWN0aW9ucz1uZXcgTGUoZ3IsdCwxMCw5KSksdC5pbmNvbWluZ1NlY3Rpb25zKSxzKSxhcyh3ZSwiaW5jb21pbmdTZWN0aW9ucyIsdmUpKSxkPSghdC5vdXRnb2luZ1NlY3Rpb25zJiYodC5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0LDksMTApKSx0Lm91dGdvaW5nU2VjdGlvbnMpLnNpemVfMD09MCx2PSFkLHYmJihGZT1uZXcgVF8sdT1uZXcgYkJlKGUsRmUpLEV0KCghdC5vdXRnb2luZ1NlY3Rpb25zJiYodC5vdXRnb2luZ1NlY3Rpb25zPW5ldyBMZShncix0LDksMTApKSx0Lm91dGdvaW5nU2VjdGlvbnMpLHUpLGFzKHdlLCJvdXRnb2luZ1NlY3Rpb25zIixGZSkpfWZ1bmN0aW9uIGFTbihlLG4pe3ZhciByO3I9bmV3IHNoLGExKHIsIngiLG4ueF8wKSxhMShyLCJ5IixuLnlfMCkseW0oZSxyKX1mdW5jdGlvbiBsU24oZSxuLHIpeyQkZShuLHREKGUscikpfWZ1bmN0aW9uIHNTbihlLG4scil7JCRlKG4sdEQoZSxyKSl9ZnVuY3Rpb24gdVNuKGUsbil7dmFyIHI7cj1uZXcgc2gsYTEociwieCIsbi54XzApLGExKHIsInkiLG4ueV8wKSx5bShlLHIpfWZ1bmN0aW9uIGNTbihlLG4pe3ZhciByLHQsbyxpO24mJihvPXljKG4sIngiKSxyPW5ldyBBQmUoZSksUncoci5zZWN0aW9uXzAsKFZlKG8pLG8pKSxpPXljKG4sInkiKSx0PW5ldyBMQmUoZSksRHcodC5zZWN0aW9uXzAsKFZlKGkpLGkpKSl9ZnVuY3Rpb24gX1NuKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKG4pZm9yKGk9bi5qc0FycmF5Lmxlbmd0aCxyPW5ldyBmMShpKSx1PShyLmxhc3Qtci5maXJzdCkqci5zdGVwPDA/KHNfKCksdV8pOm5ldyBjXyhyKTt1Lmhhc05leHRfMCgpOylzPWEodS5uZXh0XzEoKSwxNyksbz1HdyhuLHMudmFsdWVfMCksdD1uZXcgWSRlKGUpLER2bih0LnNlY3Rpb25fMSxvKX1mdW5jdGlvbiBHJGUoZSxuLHIpe3ZhciB0O3JldHVybiB0PUJ3KHIpLEJuKGUuZWRnZUlkTWFwLHQsbiksQm4oZS5lZGdlSnNvbk1hcCxuLHIpLG59ZnVuY3Rpb24gZFNuKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1CdyhyKSxjSShlLmVkZ2VTZWN0aW9uSWRNYXAsdCxuKSxCbihlLmVkZ2VTZWN0aW9uSnNvbk1hcCxuLHIpLG59ZnVuY3Rpb24gZlNuKGUsbixyKXt2YXIgdDtyZXR1cm4gdD1CdyhyKSxjSShlLm5vZGVJZE1hcCx0LG4pLGNJKGUubm9kZUpzb25NYXAsbixyKSxufWZ1bmN0aW9uIHBTbihlLG4scil7dmFyIHQ7cmV0dXJuIHQ9QncociksY0koZS5wb3J0SWRNYXAsdCxuKSxCbihlLnBvcnRKc29uTWFwLG4sciksbn1mdW5jdGlvbiBIJGUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztyZXR1cm4gdD1udWxsLHU9VloodncoKSxuKSxpPW51bGwsdSYmKG89bnVsbCxjPVlaKHUscikscz1udWxsLGMhPW51bGwmJihzPWUuc2V0UHJvcGVydHkodSxjKSksbz1zLGk9byksdD1pLHR9ZnVuY3Rpb24gb0QoZSxuKXt2YXIgcix0O2lmKHI9YShicChlLm5vZGVJZE1hcCxuKSwyNykscilyZXR1cm4gcjtpZih0PWEoYnAoZS5wb3J0SWRNYXAsbiksMTIzKSx0KXJldHVybiB0O3Rocm93IGIobmV3IHd1KCJSZWZlcmVuY2VkIHNoYXBlIGRvZXMgbm90IGV4aXN0OiAiK24pKX1mdW5jdGlvbiBnU24oZSxuKXtpZihMKG4sMjA3KSlyZXR1cm4ga3ZuKGUsYShuLDI3KSk7aWYoTChuLDE5MykpcmV0dXJuIE92bihlLGEobiwxMjMpKTtpZihMKG4sMzY2KSlyZXR1cm4gTHZuKGUsYShuLDEzNSkpO2lmKEwobiwzMjYpKXJldHVybiBBdm4oZSxhKG4sNzQpKTtpZihuKXJldHVybiBudWxsO3Rocm93IGIobmV3IEdlKCJVbmhhbmRsZWQgcGFyYW1ldGVyIHR5cGVzOiAiK20wKG5ldyBlYShQKEkoUXIsMSksTWUsMSw1LFtuXSkpKSkpfWZ1bmN0aW9uIEJuZShlLG4pe3ZhciByO3I9YShuLDE5MCksYTEociwieCIsZS54XzApLGExKHIsInkiLGUueV8wKSxhMShyLCJ3aWR0aCIsZS53aWR0aF8wKSxhMShyLCJoZWlnaHQiLGUuaGVpZ2h0KX1mdW5jdGlvbiBoU24oZSxuLHIpe3ZhciB0LG8saSxzO3JldHVybiBpPW51bGwscz1uLG89eGQocywiY2hpbGRyZW4iKSx0PW5ldyBWJGUoZSxyKSxpPShNdm4odC4kJG91dGVyXzAsdC5wYXJlbnRfMSxvKSxvKSxpfWZ1bmN0aW9uIG1TbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGg7aWYoZD1udWxsLGg9bixmPUckZShlLEJCZShyKSxoKSxNdyhmLHdjKGgsImlkIikpLHM9eGQoaCwic291cmNlcyIpLHQ9bmV3IEskZShlLGYpLEZ2bih0LiQkb3V0ZXJfMCx0LmVkZ2VfMSxzKSx1PXhkKGgsInRhcmdldHMiKSxvPW5ldyBYJGUoZSxmKSx6dm4oby4kJG91dGVyXzAsby5lZGdlXzEsdSksKCFmLnNvdXJjZXMmJihmLnNvdXJjZXM9bmV3IExlKGFuLGYsNCw3KSksZi5zb3VyY2VzKS5zaXplXzA9PTB8fCghZi50YXJnZXRzJiYoZi50YXJnZXRzPW5ldyBMZShhbixmLDUsOCkpLGYudGFyZ2V0cykuc2l6ZV8wPT0wKXRocm93IGk9d2MoaCwiaWQiKSxjPSJBbiBlZGdlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc291cmNlIGFuZCBvbmUgdGFyZ2V0IChlZGdlIGlkOiAnIitpLF89YysiJykuIixiKG5ldyB3dShfKSk7cmV0dXJuIGpBKGgsZikseVNuKGUsaCxmKSxkPWlEKGUsaCxmKSxkfWZ1bmN0aW9uIHlTbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNLEgscSxuZSx2ZSx3ZSxEZSxGZSxubjtmb3Ioaz1uLEE9bmV3IEUxLE09bmV3IEUxLGQ9eGQoaywic2VjdGlvbnMiKSx0PW5ldyBKJGUoZSxyLEEsTSksJHZuKHQuJCRvdXRlcl8wLHQuZWRnZV8xLHQuaW5jb21pbmdTZWN0aW9uSWRlbnRpZmllcnNfMix0Lm91dGdvaW5nU2VjdGlvbklkZW50aWZpZXJzXzMsZCksYz0obmU9QS5rZXlTZXQsbmV8fChBLmtleVNldD1uZXcgU3AoQSxBLm1hcF8wKSkpLHdlPWMuaXRlcmF0b3JfMCgpO3dlLmhhc05leHRfMCgpOylmb3IodmU9YSh3ZS5uZXh0XzEoKSwxNjYpLG89YShabihBLHZlKSwyMSksRT1vLml0ZXJhdG9yXzAoKTtFLmhhc05leHRfMCgpOylpZih5PUUubmV4dF8xKCksSD1hKGJwKGUuZWRnZVNlY3Rpb25JZE1hcCx5KSwxNjYpLEgpdT0oIXZlLmluY29taW5nU2VjdGlvbnMmJih2ZS5pbmNvbWluZ1NlY3Rpb25zPW5ldyBMZShncix2ZSwxMCw5KSksdmUuaW5jb21pbmdTZWN0aW9ucykscG4odSxIKTtlbHNlIHRocm93IHM9d2MoaywiaWQiKSxoPSJSZWZlcmVuY2VkIGVkZ2Ugc2VjdGlvbiBkb2VzIG5vdCBleGlzdDogIit5KyIgKGVkZ2UgaWQ6ICciK3MsbT1oKyInKS4iLGIobmV3IHd1KG0pKTtmb3IoXz0ocT1NLmtleVNldCxxfHwoTS5rZXlTZXQ9bmV3IFNwKE0sTS5tYXBfMCkpKSxGZT1fLml0ZXJhdG9yXzAoKTtGZS5oYXNOZXh0XzAoKTspZm9yKERlPWEoRmUubmV4dF8xKCksMTY2KSxpPWEoWm4oTSxEZSksMjEpLHg9aS5pdGVyYXRvcl8wKCk7eC5oYXNOZXh0XzAoKTspaWYodj14Lm5leHRfMSgpLEg9YShicChlLmVkZ2VTZWN0aW9uSWRNYXAsdiksMTY2KSxIKWY9KCFEZS5vdXRnb2luZ1NlY3Rpb25zJiYoRGUub3V0Z29pbmdTZWN0aW9ucz1uZXcgTGUoZ3IsRGUsOSwxMCkpLERlLm91dGdvaW5nU2VjdGlvbnMpLHBuKGYsSCk7ZWxzZSB0aHJvdyBzPXdjKGssImlkIiksaD0iUmVmZXJlbmNlZCBlZGdlIHNlY3Rpb24gZG9lcyBub3QgZXhpc3Q6ICIrdisiIChlZGdlIGlkOiAnIitzLG09aCsiJykuIixiKG5ldyB3dShtKSk7IXIuc291cmNlcyYmKHIuc291cmNlcz1uZXcgTGUoYW4sciw0LDcpKSxyLnNvdXJjZXMuc2l6ZV8wIT0wJiYoIXIudGFyZ2V0cyYmKHIudGFyZ2V0cz1uZXcgTGUoYW4sciw1LDgpKSxyLnRhcmdldHMuc2l6ZV8wIT0wKSYmKCFyLnNvdXJjZXMmJihyLnNvdXJjZXM9bmV3IExlKGFuLHIsNCw3KSksci5zb3VyY2VzLnNpemVfMDw9MSYmKCFyLnRhcmdldHMmJihyLnRhcmdldHM9bmV3IExlKGFuLHIsNSw4KSksci50YXJnZXRzLnNpemVfMDw9MSkpJiYoIXIuc2VjdGlvbnMmJihyLnNlY3Rpb25zPW5ldyBVKGdyLHIsNiw2KSksci5zZWN0aW9ucykuc2l6ZV8wPT0xJiYobm49YShPKCghci5zZWN0aW9ucyYmKHIuc2VjdGlvbnM9bmV3IFUoZ3Isciw2LDYpKSxyLnNlY3Rpb25zKSwwKSwxNjYpLCFYUihubikmJiFKUihubikmJihEQShubixhKE8oKCFyLnNvdXJjZXMmJihyLnNvdXJjZXM9bmV3IExlKGFuLHIsNCw3KSksci5zb3VyY2VzKSwwKSw4NCkpLEZBKG5uLGEoTygoIXIudGFyZ2V0cyYmKHIudGFyZ2V0cz1uZXcgTGUoYW4sciw1LDgpKSxyLnRhcmdldHMpLDApLDg0KSkpKX1mdW5jdGlvbiBVJGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7aWYoXz1uLGQ9YShmSShZNihlLm5vZGVKc29uTWFwKSxfKSwyNyksIWQpdGhyb3cgbz13YyhfLCJpZCIpLHU9IlVuYWJsZSB0byBmaW5kIGVsayBub2RlIGZvciBqc29uIG9iamVjdCAnIitvLGM9dSsiJyBQYW5pYyEiLGIobmV3IHd1KGMpKTtpPXhkKF8sImVkZ2VzIikscj1uZXcgcSRlKGUsZCksUnZuKHIuJCRvdXRlcl8wLHIubm9kZV8xLGkpLHM9eGQoXywiY2hpbGRyZW4iKSx0PW5ldyBvQmUoZSksVnZuKHQuJCRvdXRlcl8wLHMpfWZ1bmN0aW9uIHdTbihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmO189ZSxjPWRTKF8sImluZGl2aWR1YWxTcGFjaW5ncyIpLGMmJih0PVdzKG4sKEZuKCksc20pKSxzPSF0LHMmJihvPW5ldyBiUixucihuLHNtLG8pKSx1PWEoVihuLHNtKSwzODUpLGY9YyxpPW51bGwsZiYmKGk9KGQ9dzUoZixCKHNlLFgsMiwwLDYsMSkpLG5ldyBFNShmLGQpKSksaSYmKHI9bmV3IGZCZShmLHUpLEV0KGkscikpKX1mdW5jdGlvbiBpRChlLG4scil7dmFyIHQsbyxpLHM7cmV0dXJuIGk9bnVsbCxzPW4sbz14ZChzLCJsYWJlbHMiKSx0PW5ldyBwQmUoZSxyKSxpPShadm4odC4kJG91dGVyXzAsdC5lbGVtZW50XzEsbyksbyksaX1mdW5jdGlvbiBXJGUoZSxuLHIpe3ZhciB0LG8saSxzLHUsYztyZXR1cm4gdD1mU24oZSwobz0oWDAoKSxpPW5ldyBfUyxpKSxyJiZXQShvLHIpLG8pLG4pLE13KHQsd2MobiwiaWQiKSksakEobix0KSx3U24obix0KSxHbmUobix0KSxzPW4sdT14ZChzLCJwb3J0cyIpLGM9bmV3IGhCZShlLHQpLGVTbihjLiQkb3V0ZXJfMCxjLnBhcmVudF8xLHUpLGlEKGUsbix0KSxoU24oZSxuLHQpLHR9ZnVuY3Rpb24gRVNuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQSxrLE0sSCxxLG5lLHZlLHdlLERlLEZlLG5uLGpuLFNyLGNhLGNvO2lmKERlPW51bGwsbm49bixGZT1HJGUoZSxCQmUociksbm4pLE13KEZlLHdjKG5uLCJpZCIpKSxqbj1hKGJwKGUubm9kZUlkTWFwLHdtKFF1KG5uLCJzb3VyY2UiKSkpLDI3KSxoPVF1KG5uLCJzb3VyY2VQb3J0IiksdD1udWxsLGgmJih0PXdtKGgpKSxTcj1hKGJwKGUucG9ydElkTWFwLHQpLDEyMyksIWpuKXRocm93IHU9Qncobm4pLHk9IkFuIGVkZ2UgbXVzdCBoYXZlIGEgc291cmNlIG5vZGUgKGVkZ2UgaWQ6ICciK3UsRT15KyInKS4iLGIobmV3IHd1KEUpKTtpZihTciYmIW51KGpzKFNyKSxqbikpdGhyb3cgYz13YyhubiwiaWQiKSx2PSJUaGUgc291cmNlIHBvcnQgb2YgYW4gZWRnZSBtdXN0IGJlIGEgcG9ydCBvZiB0aGUgZWRnZSdzIHNvdXJjZSBub2RlIChlZGdlIGlkOiAnIitjLHg9disiJykuIixiKG5ldyB3dSh4KSk7aWYodmU9KCFGZS5zb3VyY2VzJiYoRmUuc291cmNlcz1uZXcgTGUoYW4sRmUsNCw3KSksRmUuc291cmNlcyksaT1udWxsLFNyP2k9U3I6aT1qbixwbih2ZSxpKSxjYT1hKGJwKGUubm9kZUlkTWFwLHdtKFF1KG5uLCJ0YXJnZXQiKSkpLDI3KSxtPVF1KG5uLCJ0YXJnZXRQb3J0Iiksbz1udWxsLG0mJihvPXdtKG0pKSxjbz1hKGJwKGUucG9ydElkTWFwLG8pLDEyMyksIWNhKXRocm93IGY9Qncobm4pLEE9IkFuIGVkZ2UgbXVzdCBoYXZlIGEgdGFyZ2V0IG5vZGUgKGVkZ2UgaWQ6ICciK2Ysaz1BKyInKS4iLGIobmV3IHd1KGspKTtpZihjbyYmIW51KGpzKGNvKSxjYSkpdGhyb3cgXz13YyhubiwiaWQiKSxNPSJUaGUgdGFyZ2V0IHBvcnQgb2YgYW4gZWRnZSBtdXN0IGJlIGEgcG9ydCBvZiB0aGUgZWRnZSdzIHRhcmdldCBub2RlIChlZGdlIGlkOiAnIitfLEg9TSsiJykuIixiKG5ldyB3dShIKSk7aWYod2U9KCFGZS50YXJnZXRzJiYoRmUudGFyZ2V0cz1uZXcgTGUoYW4sRmUsNSw4KSksRmUudGFyZ2V0cykscz1udWxsLGNvP3M9Y286cz1jYSxwbih3ZSxzKSwoIUZlLnNvdXJjZXMmJihGZS5zb3VyY2VzPW5ldyBMZShhbixGZSw0LDcpKSxGZS5zb3VyY2VzKS5zaXplXzA9PTB8fCghRmUudGFyZ2V0cyYmKEZlLnRhcmdldHM9bmV3IExlKGFuLEZlLDUsOCkpLEZlLnRhcmdldHMpLnNpemVfMD09MCl0aHJvdyBkPXdjKG5uLCJpZCIpLHE9IkFuIGVkZ2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzb3VyY2UgYW5kIG9uZSB0YXJnZXQgKGVkZ2UgaWQ6ICciK2QsbmU9cSsiJykuIixiKG5ldyB3dShuZSkpO3JldHVybiBqQShubixGZSksdlNuKG5uLEZlKSxEZT1pRChlLG5uLEZlKSxEZX1mdW5jdGlvbiB2U24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZixoO3JldHVybiBjPW51bGwsZj1lLGQ9bnVsbCwoInNvdXJjZVBvaW50ImluIGYuanNPYmplY3R8fCJ0YXJnZXRQb2ludCJpbiBmLmpzT2JqZWN0fHwiYmVuZFBvaW50cyJpbiBmLmpzT2JqZWN0KSYmKF89bnVsbCxoPVduZShuKSxzPWRTKGYsInNvdXJjZVBvaW50Iikscj1uZXcgZ0JlKGgpLFF2bihyLnNlY3Rpb25fMSxzKSx1PWRTKGYsInRhcmdldFBvaW50IiksdD1uZXcgTkJlKGgpLGNTbih0LnNlY3Rpb25fMSx1KSxpPXhkKGYsImJlbmRQb2ludHMiKSxvPW5ldyBrQmUoaCksXz0oX1NuKG8uc2VjdGlvbl8xLGkpLGkpLGQ9XyksYz1kLGN9ZnVuY3Rpb24gakEoZSxuKXt2YXIgcix0LG8saSxzLHU7bz1lLHM9ZFMobywibGF5b3V0T3B0aW9ucyIpLCFzJiYocz1kUyhvLCJwcm9wZXJ0aWVzIikpLHMmJih1PXMsdD1udWxsLHUmJih0PShpPXc1KHUsQihzZSxYLDIsMCw2LDEpKSxuZXcgRTUodSxpKSkpLHQmJihyPW5ldyBkQmUodSxuKSxFdCh0LHIpKSl9ZnVuY3Rpb24gR25lKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGY7cmV0dXJuIGQ9bnVsbCxmPWUscz15YyhmLCJ4Iikscj1uZXcgbUJlKG4pLG5TbihyLnNoYXBlXzEscyksdT15YyhmLCJ5IiksdD1uZXcgeUJlKG4pLHJTbih0LnNoYXBlXzEsdSksYz15YyhmLCJ3aWR0aCIpLG89bmV3IHdCZShuKSx0U24oby5zaGFwZV8xLGMpLF89eWMoZiwiaGVpZ2h0IiksaT1uZXcgRUJlKG4pLGQ9KG9TbihpLnNoYXBlXzEsXyksXyksZH1mdW5jdGlvbiBqJGUoKXt0aGlzLl9qc29uQWRhcHRlcj1uZXcgQiRlLHRoaXMubm9kZUlkTWFwPW5ldyBfSSx0aGlzLnBvcnRJZE1hcD1uZXcgX0ksdGhpcy5lZGdlSWRNYXA9bmV3IHNuLHRoaXMuZWRnZVNlY3Rpb25JZE1hcD1uZXcgX0ksdGhpcy5ub2RlSnNvbk1hcD1uZXcgX0ksdGhpcy5wb3J0SnNvbk1hcD1uZXcgc24sdGhpcy5lZGdlSnNvbk1hcD1uZXcgc24sdGhpcy5lZGdlU2VjdGlvbkpzb25NYXA9bmV3IHNuLHRoaXMubGFiZWxKc29uTWFwPW5ldyBzbn1wKDg2OCwxLHt9LGokZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIiLDg2OCk7ZnVuY3Rpb24gViRlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLnBhcmVudF8xPW59cCg5MDMsMSx7fSxWJGUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQwJFR5cGUiLDkwMyk7ZnVuY3Rpb24gcSRlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLm5vZGVfMT1ufXAoOTA0LDEse30scSRlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMSRUeXBlIiw5MDQpO2Z1bmN0aW9uIFkkZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTEyLDEse30sWSRlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMTAkVHlwZSIsOTEyKTtmdW5jdGlvbiBLJGUoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuZWRnZV8xPW59cCg5MTQsMSx7fSxLJGUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQxMSRUeXBlIiw5MTQpO2Z1bmN0aW9uIFgkZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5lZGdlXzE9bn1wKDkxNSwxLHt9LFgkZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDEyJFR5cGUiLDkxNSk7ZnVuY3Rpb24gSiRlKGUsbixyLHQpe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5lZGdlXzE9bix0aGlzLmluY29taW5nU2VjdGlvbklkZW50aWZpZXJzXzI9cix0aGlzLm91dGdvaW5nU2VjdGlvbklkZW50aWZpZXJzXzM9dH1wKDkyMSwxLHt9LEokZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDEzJFR5cGUiLDkyMSk7ZnVuY3Rpb24gWiRlKGUsbixyLHQpe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5lZGdlXzE9bix0aGlzLmluY29taW5nU2VjdGlvbklkZW50aWZpZXJzXzI9cix0aGlzLm91dGdvaW5nU2VjdGlvbklkZW50aWZpZXJzXzM9dH1wKDkyMCwxLHt9LFokZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDE0JFR5cGUiLDkyMCk7ZnVuY3Rpb24gUSRlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLmVsa1NlY3Rpb25fMT1ufXAoOTE2LDEse30sUSRlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMTUkVHlwZSIsOTE2KTtmdW5jdGlvbiBlQmUoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuZWxrU2VjdGlvbl8xPW59cCg5MTcsMSx7fSxlQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQxNiRUeXBlIiw5MTcpO2Z1bmN0aW9uIG5CZShlLG4pe3RoaXMuaW5jb21pbmdTZWN0aW9uSWRlbnRpZmllcnNfMT1lLHRoaXMuZWxrU2VjdGlvbl8yPW59cCg5MTgsMSx7fSxuQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQxNyRUeXBlIiw5MTgpO2Z1bmN0aW9uIHJCZShlLG4pe3RoaXMub3V0Z29pbmdTZWN0aW9uSWRlbnRpZmllcnNfMT1lLHRoaXMuZWxrU2VjdGlvbl8yPW59cCg5MTksMSx7fSxyQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQxOCRUeXBlIiw5MTkpO2Z1bmN0aW9uIHRCZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTI0LDEse30sdEJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMTkkVHlwZSIsOTI0KTtmdW5jdGlvbiBvQmUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDkwNSwxLHt9LG9CZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDIkVHlwZSIsOTA1KTtmdW5jdGlvbiBpQmUoZSl7dGhpcy5zZWN0aW9uXzA9ZX1wKDkyMiwxLHt9LGlCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDIwJFR5cGUiLDkyMik7ZnVuY3Rpb24gYUJlKGUpe3RoaXMuc2VjdGlvbl8wPWV9cCg5MjMsMSx7fSxhQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQyMSRUeXBlIiw5MjMpO2Z1bmN0aW9uIGxCZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTI3LDEse30sbEJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMjIkVHlwZSIsOTI3KTtmdW5jdGlvbiBzQmUoZSl7dGhpcy5zZWN0aW9uXzA9ZX1wKDkyNSwxLHt9LHNCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDIzJFR5cGUiLDkyNSk7ZnVuY3Rpb24gdUJlKGUpe3RoaXMuc2VjdGlvbl8wPWV9cCg5MjYsMSx7fSx1QmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQyNCRUeXBlIiw5MjYpO2Z1bmN0aW9uIGNCZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTI5LDEse30sY0JlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMjUkVHlwZSIsOTI5KTtmdW5jdGlvbiBfQmUoZSl7dGhpcy5zZWN0aW9uXzE9ZX1wKDkyOCwxLHt9LF9CZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDI2JFR5cGUiLDkyOCk7ZnVuY3Rpb24gZEJlKGUsbil7dGhpcy5vcHRzXzE9ZSx0aGlzLmxheW91dERhdGFfMj1ufXAoOTMwLDEsSmUsZEJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtYdm4odGhpcy5vcHRzXzEsdGhpcy5sYXlvdXREYXRhXzIseG4obikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMjckVHlwZSIsOTMwKTtmdW5jdGlvbiBmQmUoZSxuKXt0aGlzLm9wdHNfMT1lLHRoaXMuaW5kaXZpZHVhbFNwYWNpbmdzXzI9bn1wKDkzMSwxLEplLGZCZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7SnZuKHRoaXMub3B0c18xLHRoaXMuaW5kaXZpZHVhbFNwYWNpbmdzXzIseG4obikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMjgkVHlwZSIsOTMxKTtmdW5jdGlvbiBwQmUoZSxuKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuZWxlbWVudF8xPW59cCg5MzIsMSx7fSxwQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQyOSRUeXBlIiw5MzIpO2Z1bmN0aW9uIGdCZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTA4LDEse30sZ0JlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMyRUeXBlIiw5MDgpO2Z1bmN0aW9uIGhCZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5wYXJlbnRfMT1ufXAoOTMzLDEse30saEJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMzAkVHlwZSIsOTMzKTtmdW5jdGlvbiBtQmUoZSl7dGhpcy5zaGFwZV8xPWV9cCg5MzQsMSx7fSxtQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQzMSRUeXBlIiw5MzQpO2Z1bmN0aW9uIHlCZShlKXt0aGlzLnNoYXBlXzE9ZX1wKDkzNSwxLHt9LHlCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDMyJFR5cGUiLDkzNSk7ZnVuY3Rpb24gd0JlKGUpe3RoaXMuc2hhcGVfMT1lfXAoOTM2LDEse30sd0JlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMzMkVHlwZSIsOTM2KTtmdW5jdGlvbiBFQmUoZSl7dGhpcy5zaGFwZV8xPWV9cCg5MzcsMSx7fSxFQmUpLGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQzNCRUeXBlIiw5MzcpO2Z1bmN0aW9uIFNTbihlLG4pe2dTbihlLiQkb3V0ZXJfMCxhKG4sNTgpKX1mdW5jdGlvbiB2QmUoZSl7dGhpcy4kJG91dGVyXzA9ZX1wKDg3MCwxLHt9LHZCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDM1JFR5cGUiLDg3MCk7ZnVuY3Rpb24gQ1NuKGUsbixyKXtpU24oZS4kJG91dGVyXzAsZS5lZGdlSWRfMSxlLnNlY3Rpb25zXzIsYShuLDE2Nikscil9ZnVuY3Rpb24gU0JlKGUsbixyKXt0aGlzLiQkb3V0ZXJfMD1lLHRoaXMuZWRnZUlkXzE9bix0aGlzLnNlY3Rpb25zXzI9cn1wKDk0MSwxLHt9LFNCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDM2JFR5cGUiLDk0MSk7ZnVuY3Rpb24gQ0JlKGUpe3RoaXMuYmVuZFBvaW50c18xPWV9cCg5MzgsMSxKZSxDQmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe2FTbih0aGlzLmJlbmRQb2ludHNfMSxhKG4sMzc3KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQzNyRUeXBlIiw5MzgpO2Z1bmN0aW9uIFRCZShlLG4pe3RoaXMuJCRvdXRlcl8wPWUsdGhpcy5pbmNvbWluZ1NlY3Rpb25zXzE9bn1wKDkzOSwxLEplLFRCZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7bFNuKHRoaXMuJCRvdXRlcl8wLHRoaXMuaW5jb21pbmdTZWN0aW9uc18xLGEobiwxNjYpKX0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDM4JFR5cGUiLDkzOSk7ZnVuY3Rpb24gYkJlKGUsbil7dGhpcy4kJG91dGVyXzA9ZSx0aGlzLm91dGdvaW5nU2VjdGlvbnNfMT1ufXAoOTQwLDEsSmUsYkJlKSxsLmFjY2VwdD1mdW5jdGlvbihuKXtzU24odGhpcy4kJG91dGVyXzAsdGhpcy5vdXRnb2luZ1NlY3Rpb25zXzEsYShuLDE2NikpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkMzkkVHlwZSIsOTQwKTtmdW5jdGlvbiBJQmUoZSl7dGhpcy5zZWN0aW9uXzA9ZX1wKDkwNiwxLHt9LElCZSksZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uSW1wb3J0ZXIvbGFtYmRhJDQkVHlwZSIsOTA2KTtmdW5jdGlvbiB4QmUoZSl7dGhpcy5qc29uSlBzXzE9ZX1wKDk0MiwxLEplLHhCZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7dVNuKHRoaXMuanNvbkpQc18xLGEobiw4KSl9LGcoIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5qc29uIiwiSnNvbkltcG9ydGVyL2xhbWJkYSQ0MCRUeXBlIiw5NDIpO2Z1bmN0aW9uIFBCZShlKXt0aGlzLnNlY3Rpb25fMD1lfXAoOTA3LDEse30sUEJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkNSRUeXBlIiw5MDcpO2Z1bmN0aW9uIE5CZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTExLDEse30sTkJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkNiRUeXBlIiw5MTEpO2Z1bmN0aW9uIEFCZShlKXt0aGlzLnNlY3Rpb25fMD1lfXAoOTA5LDEse30sQUJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkNyRUeXBlIiw5MDkpO2Z1bmN0aW9uIExCZShlKXt0aGlzLnNlY3Rpb25fMD1lfXAoOTEwLDEse30sTEJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkOCRUeXBlIiw5MTApO2Z1bmN0aW9uIGtCZShlKXt0aGlzLnNlY3Rpb25fMT1lfXAoOTEzLDEse30sa0JlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25JbXBvcnRlci9sYW1iZGEkOSRUeXBlIiw5MTMpO2Z1bmN0aW9uIFRTbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmO3JldHVybiBmPUhuZShlKSxuPWUuY2F0ZWdvcnksYz1uIT1udWxsLGMmJiR3KGYsImNhdGVnb3J5IixlLmNhdGVnb3J5KSxvPUdiKG5ldyBrXyhlLmtub3duT3B0aW9ucykpLHM9IW8scyYmKF89bmV3IFRfLGFzKGYsImtub3duT3B0aW9ucyIsXykscj1uZXcgT0JlKF8pLEV0KG5ldyBrXyhlLmtub3duT3B0aW9ucykscikpLGk9R2IoZS5zdXBwb3J0ZWRGZWF0dXJlcyksdT0haSx1JiYoZD1uZXcgVF8sYXMoZiwic3VwcG9ydGVkRmVhdHVyZXMiLGQpLHQ9bmV3IE1CZShkKSxFdChlLnN1cHBvcnRlZEZlYXR1cmVzLHQpKSxmfWZ1bmN0aW9uIGJTbihlKXt2YXIgbixyLHQsbyxpO3JldHVybiBpPUhuZShlKSxyPUdiKGUubGF5b3V0ZXJzKSx0PSFyLHQmJihvPW5ldyBUXyxhcyhpLCJrbm93bkxheW91dGVycyIsbyksbj1uZXcgUkJlKG8pLEV0KGUubGF5b3V0ZXJzLG4pKSxpfWZ1bmN0aW9uIElTbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF87cmV0dXJuIF89SG5lKGUpLHI9ZS5ncm91cF8wLGk9ciE9bnVsbCxpJiYkdyhfLCJncm91cCIsZS5ncm91cF8wKSx1PWUudHlwZV8wLHM9ISF1LHMmJiR3KF8sInR5cGUiLGE1KGUudHlwZV8wKSksdD1HYihlLnRhcmdldHMpLG89IXQsbyYmKGM9bmV3IFRfLGFzKF8sInRhcmdldHMiLGMpLG49bmV3IERCZShjKSxFdChlLnRhcmdldHMsbikpLF99ZnVuY3Rpb24gSG5lKGUpe3ZhciBuLHIsdCxvLGkscyx1O3JldHVybiB1PW5ldyBzaCxyPWUuZ2V0SWQoKSxvPXIhPW51bGwsbyYmJHcodSwiaWQiLGUuZ2V0SWQoKSksdD1lLmdldE5hbWUoKSxpPXQhPW51bGwsaSYmJHcodSwibmFtZSIsZS5nZXROYW1lKCkpLG49ZS5nZXREZXNjcmlwdGlvbigpLHM9biE9bnVsbCxzJiYkdyh1LCJkZXNjcmlwdGlvbiIsZS5nZXREZXNjcmlwdGlvbigpKSx1fWZ1bmN0aW9uIHhTbihlLG4pe3ltKGUsbmV3IFpkKG4ubmFtZV8wIT1udWxsP24ubmFtZV8wOiIiK24ub3JkaW5hbCkpfWZ1bmN0aW9uIFBTbihlLG4pe3ZhciByLHQ7cj1uLmlkXzAsdD1yIT1udWxsLHQmJnltKGUsbmV3IFpkKG4uaWRfMCkpfWZ1bmN0aW9uIE5TbihlLG4pe3ltKGUsbmV3IFpkKG4ubmFtZV8wIT1udWxsP24ubmFtZV8wOiIiK24ub3JkaW5hbCkpfWZ1bmN0aW9uIEFTbihlKXtpZihMKGUsMTQzKSlyZXR1cm4gVFNuKGEoZSwxNDMpKTtpZihMKGUsMjMzKSlyZXR1cm4gYlNuKGEoZSwyMzMpKTtpZihMKGUsMjMpKXJldHVybiBJU24oYShlLDIzKSk7dGhyb3cgYihuZXcgR2UoIlVuaGFuZGxlZCBwYXJhbWV0ZXIgdHlwZXM6ICIrbTAobmV3IGVhKFAoSShRciwxKSxNZSwxLDUsW2VdKSkpKSl9ZnVuY3Rpb24gT0JlKGUpe3RoaXMuanNvbkFycl8wPWV9cCg5NjEsMSxKZSxPQmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3ltKHRoaXMuanNvbkFycl8wLG5ldyBaZCh4bihuKSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGguanNvbiIsIkpzb25NZXRhRGF0YUNvbnZlcnRlci9sYW1iZGEkMCRUeXBlIiw5NjEpO2Z1bmN0aW9uIE1CZShlKXt0aGlzLmpzb25BcnJfMV8wPWV9cCg5NjIsMSxKZSxNQmUpLGwuYWNjZXB0PWZ1bmN0aW9uKG4pe3hTbih0aGlzLmpzb25BcnJfMV8wLGEobiwyNDUpKX0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uTWV0YURhdGFDb252ZXJ0ZXIvbGFtYmRhJDEkVHlwZSIsOTYyKTtmdW5jdGlvbiBSQmUoZSl7dGhpcy5qc29uQXJyXzA9ZX1wKDk2MywxLEplLFJCZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7UFNuKHRoaXMuanNvbkFycl8wLGEobiwxNDMpKX0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uTWV0YURhdGFDb252ZXJ0ZXIvbGFtYmRhJDIkVHlwZSIsOTYzKTtmdW5jdGlvbiBEQmUoZSl7dGhpcy5qc29uQXJyXzA9ZX1wKDk2NCwxLEplLERCZSksbC5hY2NlcHQ9ZnVuY3Rpb24obil7TlNuKHRoaXMuanNvbkFycl8wLGEobiwxNzApKX0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLmpzb24iLCJKc29uTWV0YURhdGFDb252ZXJ0ZXIvbGFtYmRhJDMkVHlwZSIsOTY0KTtmdW5jdGlvbiBIdygpe0h3PUYsc0Q9bmV3IEVtKCJTRUxGX0xPT1BTIiwwKSxLQT1uZXcgRW0oIklOU0lERV9TRUxGX0xPT1BTIiwxKSxYQT1uZXcgRW0oIk1VTFRJX0VER0VTIiwyKSxZQT1uZXcgRW0oIkVER0VfTEFCRUxTIiwzKSxsRD1uZXcgRW0oIlBPUlRTIiw0KSxxQT1uZXcgRW0oIkNPTVBPVU5EIiw1KSxWQT1uZXcgRW0oIkNMVVNURVJTIiw2KSxhRD1uZXcgRW0oIkRJU0NPTk5FQ1RFRCIsNyl9ZnVuY3Rpb24gRW0oZSxuKXttbi5jYWxsKHRoaXMsZSxuKX1mdW5jdGlvbiBMU24oZSl7cmV0dXJuIEh3KCksd24oKEZCZSgpLHpCZSksZSl9ZnVuY3Rpb24ga1NuKCl7cmV0dXJuIEh3KCksUChJKEpBLDEpLFcsMjQ1LDAsW3NELEtBLFhBLFlBLGxELHFBLFZBLGFEXSl9cCgyNDUsMjIsezM6MSwzNDoxLDIyOjEsMjQ1OjF9LEVtKTt2YXIgVkEscUEsYUQsWUEsS0EsWEEsbEQsc0QsSkE9Y24oIm9yZy5lY2xpcHNlLmVsay5ncmFwaC5wcm9wZXJ0aWVzIiwiR3JhcGhGZWF0dXJlIiwyNDUsZ24sa1NuLExTbik7ZnVuY3Rpb24gRkJlKCl7RkJlPUYsekJlPXluKChIdygpLFAoSShKQSwxKSxXLDI0NSwwLFtzRCxLQSxYQSxZQSxsRCxxQSxWQSxhRF0pKSl9dmFyIHpCZTtmdW5jdGlvbiBPU24oZSxuKXtyZXR1cm4gbEIoZS5pZF8wLG4uZ2V0SWQoKSl9ZnVuY3Rpb24gJEJlKGUsbil7cmV0dXJuIEwobiwxNDkpJiZUZShlLmlkXzAsYShuLDE0OSkuZ2V0SWQoKSl9ZnVuY3Rpb24gdGUoZSl7dmFyIG47aWYoTChlLmRlZmF1bHRWYWx1ZSw0KSl7aWYobj1vcmUoZS5kZWZhdWx0VmFsdWUpLG49PW51bGwpdGhyb3cgYihuZXcgcm8oIkNvdWxkbid0IGNsb25lIHByb3BlcnR5ICciK2UuaWRfMCsiJy4gTWFrZSBzdXJlIGl0cyB0eXBlIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgIisoSnUoY2IpLGNiLnNpbXBsZU5hbWUpKyIgdXRpbGl0eSBjbGFzcy4iKSk7cmV0dXJuIG59ZWxzZSByZXR1cm4gZS5kZWZhdWx0VmFsdWV9ZnVuY3Rpb24gdHIoZSl7dGhpcy5pZF8wPWV9ZnVuY3Rpb24gdnIoZSxuKXt0ci5jYWxsKHRoaXMsZSksdGhpcy5kZWZhdWx0VmFsdWU9bn1mdW5jdGlvbiBDZShlLG4pe3ZyLmNhbGwodGhpcyxlLG4pfWZ1bmN0aW9uIHl0KGUsbil7dnIuY2FsbCh0aGlzLGUuaWRfMCxuKX1wKDExLDEsezM0OjEsMTQ5OjF9LHRyLHZyLENlLHl0KSxsLmNvbXBhcmVUb18wPWZ1bmN0aW9uKG4pe3JldHVybiBPU24odGhpcyxhKG4sMTQ5KSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuICRCZSh0aGlzLG4pfSxsLmdldERlZmF1bHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGUodGhpcyl9LGwuZ2V0SWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pZF8wfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gTmModGhpcy5pZF8wKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWRfMH0sZygib3JnLmVjbGlwc2UuZWxrLmdyYXBoLnByb3BlcnRpZXMiLCJQcm9wZXJ0eSIsMTEpO2Z1bmN0aW9uIE1TbihlLG4scil7dmFyIHQsbztyZXR1cm4gdD1hKG4uZ2V0UHJvcGVydHkoZS5wcm9wZXJ0eSksMzQpLG89YShyLmdldFByb3BlcnR5KGUucHJvcGVydHkpLDM0KSx0IT1udWxsJiZvIT1udWxsP3dDKHQsbyk6dCE9bnVsbD8tMTpvIT1udWxsPzE6MH1mdW5jdGlvbiB1RChlKXt0aGlzLnByb3BlcnR5PWV9cCg2NzEsMSxObix1RCksbC5jb21wYXJlXzE9ZnVuY3Rpb24obixyKXtyZXR1cm4gTVNuKHRoaXMsYShuLDk2KSxhKHIsOTYpKX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcz09PW59LGwucmV2ZXJzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENuKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgucHJvcGVydGllcyIsIlByb3BlcnR5SG9sZGVyQ29tcGFyYXRvciIsNjcxKTtmdW5jdGlvbiBvYihlKXt2YXIgbixyLHQ7Zm9yKG49TnUoMSsoIWUucG9ydHMmJihlLnBvcnRzPW5ldyBVKHVhLGUsOSw5KSksZS5wb3J0cykuc2l6ZV8wKSxlZShuLCghZS5pbmNvbWluZ0VkZ2VzJiYoZS5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixlLDgsNSkpLGUuaW5jb21pbmdFZGdlcykpLHQ9bmV3IFllKCghZS5wb3J0cyYmKGUucG9ydHM9bmV3IFUodWEsZSw5LDkpKSxlLnBvcnRzKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEoZW4odCksMTIzKSxlZShuLCghci5pbmNvbWluZ0VkZ2VzJiYoci5pbmNvbWluZ0VkZ2VzPW5ldyBMZShNcixyLDgsNSkpLHIuaW5jb21pbmdFZGdlcykpO3JldHVybiB2bihuKSxuZXcgUDIobil9ZnVuY3Rpb24gRWMoZSl7dmFyIG4scix0O2ZvcihuPU51KDErKCFlLnBvcnRzJiYoZS5wb3J0cz1uZXcgVSh1YSxlLDksOSkpLGUucG9ydHMpLnNpemVfMCksZWUobiwoIWUub3V0Z29pbmdFZGdlcyYmKGUub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsZSw3LDQpKSxlLm91dGdvaW5nRWRnZXMpKSx0PW5ldyBZZSgoIWUucG9ydHMmJihlLnBvcnRzPW5ldyBVKHVhLGUsOSw5KSksZS5wb3J0cykpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDEyMyksZWUobiwoIXIub3V0Z29pbmdFZGdlcyYmKHIub3V0Z29pbmdFZGdlcz1uZXcgTGUoTXIsciw3LDQpKSxyLm91dGdvaW5nRWRnZXMpKTtyZXR1cm4gdm4obiksbmV3IFAyKG4pfWZ1bmN0aW9uIHlvKGUpe2lmKEwoZSwyMDcpKXJldHVybiBhKGUsMjcpO2lmKEwoZSwxOTMpKXJldHVybiBqcyhhKGUsMTIzKSk7dGhyb3cgYihlP25ldyBrYygiT25seSBzdXBwb3J0IG5vZGVzIGFuZCBwb3J0cy4iKTpuZXcgZGgoImNvbm5lY3RhYmxlU2hhcGUgY2Fubm90IGJlIG51bGwiKSl9ZnVuY3Rpb24gaWIoZSl7aWYoTChlLDE5MykpcmV0dXJuIGEoZSwxMjMpO2lmKGUpcmV0dXJuIG51bGw7dGhyb3cgYihuZXcgZGgoImNvbm5lY3RhYmxlU2hhcGUgY2Fubm90IGJlIG51bGwiKSl9ZnVuY3Rpb24gVW5lKGUsbixyKXt2YXIgdCxvO3JldHVybiB0PShYMCgpLG89bmV3IE9BLG8pLExBKHQsbiksa0EodCxyKSxlJiZwbigoIWUuYmVuZFBvaW50cyYmKGUuYmVuZFBvaW50cz1uZXcganIoQmEsZSw1KSksZS5iZW5kUG9pbnRzKSx0KSx0fWZ1bmN0aW9uIEJCZShlKXt2YXIgbixyO3JldHVybiBuPShYMCgpLHI9bmV3IEtSLHIpLGUmJlJBKG4sZSksbn1mdW5jdGlvbiBXbmUoZSl7dmFyIG4scjtyZXR1cm4gcj0oWDAoKSxuPW5ldyB6QSxuKSxlJiZwbigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykscikscn1mdW5jdGlvbiBSU24oZSxuKXt2YXIgcix0LG87cmV0dXJuIHI9KHQ9KFgwKCksbz1uZXcgUG5lLG8pLG4mJkluZSh0LG4pLHQpLHhuZShyLGUpLHJ9ZnVuY3Rpb24gRFNuKGUpe3ZhciBuLHIsdCxvLGk7c3dpdGNoKEZDKGUsImVkZ2UgY2Fubm90IGJlIG51bGwiKSwoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLnNpemVfMCsoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLnNpemVfMCl7Y2FzZSAwOnRocm93IGIobmV3IEdlKCJUaGUgZWRnZSBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHNvdXJjZSBvciB0YXJnZXQuIikpO2Nhc2UgMTpyZXR1cm4oIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLnNpemVfMD09MD95cih5byhhKE8oKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzKSwwKSw4NCkpKTp5cih5byhhKE8oKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKSwwKSw4NCkpKX1pZigoIWUuc291cmNlcyYmKGUuc291cmNlcz1uZXcgTGUoYW4sZSw0LDcpKSxlLnNvdXJjZXMpLnNpemVfMD09MSYmKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzKS5zaXplXzA9PTEpe2lmKG89eW8oYShPKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcyksMCksODQpKSxpPXlvKGEoTygoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLDApLDg0KSkseXIobyk9PXlyKGkpKXJldHVybiB5cihvKTtpZihvPT15cihpKSlyZXR1cm4gbztpZihpPT15cihvKSlyZXR1cm4gaX1mb3IodD1QdShOYShQKEkoeGEsMSksTWUsMjAsMCxbKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKSwoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpXSkpKSxuPXlvKGEodG4odCksODQpKTtfbih0KTspaWYocj15byhhKHRuKHQpLDg0KSksciE9biYmIVhmKHIsbikpe2lmKHlyKHIpPT15cihuKSluPXlyKHIpO2Vsc2UgaWYobj1GU24obixyKSwhbilyZXR1cm4gbnVsbH1yZXR1cm4gbn1mdW5jdGlvbiBGU24oZSxuKXt2YXIgcix0LG8saSxzLHUsYztmb3Iobz1RbShuZXcgam5lKGUpKSx1PW5ldyBwdChvLG8uYXJyYXkubGVuZ3RoKSxpPVFtKG5ldyBqbmUobikpLGM9bmV3IHB0KGksaS5hcnJheS5sZW5ndGgpLHM9bnVsbDt1Lmk+MCYmYy5pPjAmJihyPShybih1Lmk+MCksYSh1LnRoaXMkMDEuZ2V0XzAodS5sYXN0PS0tdS5pKSwyNykpLHQ9KHJuKGMuaT4wKSxhKGMudGhpcyQwMS5nZXRfMChjLmxhc3Q9LS1jLmkpLDI3KSkscj09dCk7KXM9cjtyZXR1cm4gc31mdW5jdGlvbiBGZyhlLG4scil7dmFyIHQsbztpZigoIWUuc2VjdGlvbnMmJihlLnNlY3Rpb25zPW5ldyBVKGdyLGUsNiw2KSksZS5zZWN0aW9ucykuc2l6ZV8wPT0wKXJldHVybiBXbmUoZSk7aWYodD1hKE8oKCFlLnNlY3Rpb25zJiYoZS5zZWN0aW9ucz1uZXcgVShncixlLDYsNikpLGUuc2VjdGlvbnMpLDApLDE2NiksbiYmKGZuKCghdC5iZW5kUG9pbnRzJiYodC5iZW5kUG9pbnRzPW5ldyBqcihCYSx0LDUpKSx0LmJlbmRQb2ludHMpKSxGdyh0LDApLHp3KHQsMCksUncodCwwKSxEdyh0LDApKSxyKWZvcihvPSghZS5zZWN0aW9ucyYmKGUuc2VjdGlvbnM9bmV3IFUoZ3IsZSw2LDYpKSxlLnNlY3Rpb25zKTtvLnNpemVfMD4xOylaZihvLG8uc2l6ZV8wLTEpO3JldHVybiB0fWZ1bmN0aW9uIFd1KGUpe2lmKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcykuc2l6ZV8wIT0xfHwoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLnNpemVfMCE9MSl0aHJvdyBiKG5ldyBHZSgiUGFzc2VkIGVkZ2UgaXMgbm90ICdzaW1wbGUnLiIpKTtyZXR1cm4geW8oYShPKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcyksMCksODQpKX1mdW5jdGlvbiBHQmUoZSl7aWYoKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKS5zaXplXzAhPTF8fCghZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cykuc2l6ZV8wIT0xKXRocm93IGIobmV3IEdlKCJQYXNzZWQgZWRnZSBpcyBub3QgJ3NpbXBsZScuIikpO3JldHVybiBpYihhKE8oKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKSwwKSw4NCkpfWZ1bmN0aW9uIFowKGUpe2lmKCghZS5zb3VyY2VzJiYoZS5zb3VyY2VzPW5ldyBMZShhbixlLDQsNykpLGUuc291cmNlcykuc2l6ZV8wIT0xfHwoIWUudGFyZ2V0cyYmKGUudGFyZ2V0cz1uZXcgTGUoYW4sZSw1LDgpKSxlLnRhcmdldHMpLnNpemVfMCE9MSl0aHJvdyBiKG5ldyBHZSgiUGFzc2VkIGVkZ2UgaXMgbm90ICdzaW1wbGUnLiIpKTtyZXR1cm4geW8oYShPKCghZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cyksMCksODQpKX1mdW5jdGlvbiBIQmUoZSl7aWYoKCFlLnNvdXJjZXMmJihlLnNvdXJjZXM9bmV3IExlKGFuLGUsNCw3KSksZS5zb3VyY2VzKS5zaXplXzAhPTF8fCghZS50YXJnZXRzJiYoZS50YXJnZXRzPW5ldyBMZShhbixlLDUsOCkpLGUudGFyZ2V0cykuc2l6ZV8wIT0xKXRocm93IGIobmV3IEdlKCJQYXNzZWQgZWRnZSBpcyBub3QgJ3NpbXBsZScuIikpO3JldHVybiBpYihhKE8oKCFlLnRhcmdldHMmJihlLnRhcmdldHM9bmV3IExlKGFuLGUsNSw4KSksZS50YXJnZXRzKSwwKSw4NCkpfWZ1bmN0aW9uIFhmKGUsbil7dmFyIHI7Zm9yKHI9ZTt5cihyKTspaWYocj15cihyKSxyPT1uKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHpTbihlKXtGQyhlLCJlZGdlIGNhbm5vdCBiZSBudWxsIiksUkEoZSxEU24oZSkpfWZ1bmN0aW9uICRTbihlKXt2YXIgbjtpZighZS5uZXh0Tm9kZSl0aHJvdyBiKG5ldyBtX2UpO3JldHVybiBuPWUubmV4dE5vZGUsZS5uZXh0Tm9kZT15cihlLm5leHROb2RlKSxufWZ1bmN0aW9uIGpuZShlKXt0aGlzLm5leHROb2RlPWV9cCg3MDksMSxzdCxqbmUpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiAkU24odGhpcyl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7UWllKCl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLm5leHROb2RlfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgudXRpbCIsIkVsa0dyYXBoVXRpbC9BbmNlc3Rvckl0ZXJhdG9yIiw3MDkpO3ZhciBWbmU9Q3IoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkVMaXN0Iik7ZnVuY3Rpb24gZlMoZSxuLHIpe3ZhciB0O2lmKHQ9ZS5zaXplXzEoKSxuPnQpdGhyb3cgYihuZXcgUWYobix0KSk7aWYoZS5pc1VuaXF1ZSgpJiZlLmNvbnRhaW5zKHIpKXRocm93IGIobmV3IEdlKCJUaGUgJ25vIGR1cGxpY2F0ZXMnIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQiKSk7ZS5hZGRVbmlxdWUobixyKX1mdW5jdGlvbiBwbihlLG4pe3JldHVybiBlLmlzVW5pcXVlKCkmJmUuY29udGFpbnMobik/ITE6KGUuYWRkVW5pcXVlXzAobiksITApfWZ1bmN0aW9uIHFuZShlLG4scil7dmFyIHQ7aWYodD1lLnNpemVfMSgpLG4+dCl0aHJvdyBiKG5ldyBRZihuLHQpKTtyZXR1cm4gZS5pc1VuaXF1ZSgpJiYocj1XQmUoZSxyKSksZS5hZGRBbGxVbmlxdWUobixyKX1mdW5jdGlvbiBQcihlLG4pe3JldHVybiBlLmlzVW5pcXVlKCkmJihuPVdCZShlLG4pKSxlLmFkZEFsbFVuaXF1ZV8wKG4pfWZ1bmN0aW9uIGFiKGUsbil7dmFyIHI7aWYocj1lLnNpemVfMSgpLG48MHx8bj5yKXRocm93IGIobmV3IFFmKG4scikpO3JldHVybiBuZXcgaHJlKGUsbil9ZnVuY3Rpb24gY0QoZSxuLHIpe3ZhciB0LG87aWYociE9bnVsbClmb3IodD0wO3Q8bjsrK3Qpbz1yW3RdLGUuZGlkUmVtb3ZlKHQsbyl9ZnVuY3Rpb24gVUJlKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKEQobik9PT1EKGUpKXJldHVybiEwO2lmKCFMKG4sMTUpfHwodD1hKG4sMTUpLHU9ZS5zaXplXzEoKSx0LnNpemVfMSgpIT11KSlyZXR1cm4hMTtpZihzPXQuaXRlcmF0b3JfMCgpLGUudXNlRXF1YWxzKCkpe2ZvcihyPTA7cjx1OysrcilpZihvPWUucHJpbWl0aXZlR2V0KHIpLGk9cy5uZXh0XzEoKSxvPT1udWxsP2khPW51bGw6IVluKG8saSkpcmV0dXJuITF9ZWxzZSBmb3Iocj0wO3I8dTsrK3IpaWYobz1lLnByaW1pdGl2ZUdldChyKSxpPXMubmV4dF8xKCksRChvKSE9PUQoaSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gQlNuKGUsbil7dmFyIHIsdCxvO2lmKG4uaXNFbXB0eSgpKXJldHVybiBqdygpLGp3KCksaGI7Zm9yKHI9bmV3IGZHZShlLG4uc2l6ZV8xKCkpLG89bmV3IFllKGUpO28uY3Vyc29yIT1vLnRoaXMkMDFfMi5zaXplXzEoKTspdD1lbihvKSxuLmNvbnRhaW5zKHQpJiZwbihyLHQpO3JldHVybiByfWZ1bmN0aW9uIFdCZShlLG4pe3ZhciByO3JldHVybiByPW5ldyBjRyhuKSxwYWUocixlKSxuZXcgUWkocil9ZnVuY3Rpb24gWW5lKGUpe3ZhciBuLHIsdCxvO2ZvcihuPTEscj0wLG89ZS5zaXplXzEoKTtyPG87KytyKXQ9ZS5wcmltaXRpdmVHZXQociksbj0zMSpuKyh0PT1udWxsPzA6dXIodCkpO3JldHVybiBufWZ1bmN0aW9uIFpBKGUsbil7dmFyIHI7cmV0dXJuIHI9ZS5pbmRleE9mXzAobikscj49MD8oZS5yZW1vdmVfMihyKSwhMCk6ITF9ZnVuY3Rpb24gemcoZSxuLHIpe3ZhciB0LG87aWYobz1lLnNpemVfMSgpLG4+PW8pdGhyb3cgYihuZXcgUWYobixvKSk7aWYoZS5pc1VuaXF1ZSgpJiYodD1lLmluZGV4T2ZfMChyKSx0Pj0wJiZ0IT1uKSl0aHJvdyBiKG5ldyBHZSgiVGhlICdubyBkdXBsaWNhdGVzJyBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpO3JldHVybiBlLnNldFVuaXF1ZShuLHIpfWZ1bmN0aW9uIEtuZShlKXt2YXIgbixyLHQ7Zm9yKHQ9bmV3IExjLHQuc3RyaW5nKz0iWyIsbj0wLHI9ZS5zaXplXzEoKTtuPHI7KUp0KHQsejIoZS5wcmltaXRpdmVHZXQobikpKSwrK248ciYmKHQuc3RyaW5nKz0iLCAiKTtyZXR1cm4gdC5zdHJpbmcrPSJdIix0LnN0cmluZ31mdW5jdGlvbiBVdyhlLG4pe2lmKCFlLmNhbkNvbnRhaW5OdWxsKCkmJm49PW51bGwpdGhyb3cgYihuZXcgR2UoIlRoZSAnbm8gbnVsbCcgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKTtyZXR1cm4gbn1wKDcwLDU2LHsyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNzA6MSw2MToxfSksbC5hZGRfMz1mdW5jdGlvbihuLHIpe2ZTKHRoaXMsbixyKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gcG4odGhpcyxuKX0sbC5hZGRBbGxfMD1mdW5jdGlvbihuLHIpe3JldHVybiBxbmUodGhpcyxuLHIpfSxsLmFkZEFsbD1mdW5jdGlvbihuKXtyZXR1cm4gUHIodGhpcyxuKX0sbC5iYXNpY0l0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbSh0aGlzKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgZGIodGhpcyl9LGwuYmFzaWNMaXN0SXRlcmF0b3JfMD1mdW5jdGlvbihuKXtyZXR1cm4gYWIodGhpcyxuKX0sbC5jYW5Db250YWluTnVsbD1mdW5jdGlvbigpe3JldHVybiEwfSxsLmRpZEFkZD1mdW5jdGlvbihuLHIpe30sbC5kaWRDaGFuZ2U9ZnVuY3Rpb24oKXt9LGwuZGlkQ2xlYXI9ZnVuY3Rpb24obixyKXtjRCh0aGlzLG4scil9LGwuZGlkTW92ZT1mdW5jdGlvbihuLHIsdCl7fSxsLmRpZFJlbW92ZT1mdW5jdGlvbihuLHIpe30sbC5kaWRTZXQ9ZnVuY3Rpb24obixyLHQpe30sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gVUJlKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBZbmUodGhpcyl9LGwuaXNVbmlxdWU9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBZZSh0aGlzKX0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgU20odGhpcyl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7dmFyIHI7aWYocj10aGlzLnNpemVfMSgpLG48MHx8bj5yKXRocm93IGIobmV3IFFmKG4scikpO3JldHVybiBuZXcgRUQodGhpcyxuKX0sbC5tb3ZlXzA9ZnVuY3Rpb24obixyKXt0aGlzLm1vdmUobix0aGlzLmluZGV4T2ZfMChyKSl9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7cmV0dXJuIFpBKHRoaXMsbil9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiByfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7cmV0dXJuIHpnKHRoaXMsbixyKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIEtuZSh0aGlzKX0sbC51c2VFcXVhbHM9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC52YWxpZGF0ZT1mdW5jdGlvbihuLHIpe3JldHVybiBVdyh0aGlzLHIpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJBYnN0cmFjdEVMaXN0Iiw3MCk7ZnVuY3Rpb24gX0QoZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKHQ9ci5zaXplXzEoKSxlLmdyb3coZS5zaXplXzArdCksdT1lLnNpemVfMC1uLHU+MCYmWG8oZS5kYXRhXzAsbixlLmRhdGFfMCxuK3QsdSkscz1yLml0ZXJhdG9yXzAoKSxlLnNpemVfMCs9dCxvPTA7bzx0OysrbylpPXMubmV4dF8xKCkscFMoZSxuLGUudmFsaWRhdGUobixpKSksZS5kaWRBZGQobixpKSxlLmRpZENoYW5nZSgpLCsrbjtyZXR1cm4gdCE9MH1mdW5jdGlvbiBqQmUoZSxuKXt2YXIgcix0LG8saSxzO2ZvcihyPW4uc2l6ZV8xKCksZS5ncm93KGUuc2l6ZV8wK3IpLGk9bi5pdGVyYXRvcl8wKCkscz1lLnNpemVfMCxlLnNpemVfMCs9cix0PXM7dDxlLnNpemVfMDsrK3Qpbz1pLm5leHRfMSgpLHBTKGUsdCxlLnZhbGlkYXRlKHQsbykpLGUuZGlkQWRkKHQsbyksZS5kaWRDaGFuZ2UoKTtyZXR1cm4gciE9MH1mdW5jdGlvbiBsYihlLG4scil7dmFyIHQ7ZS5ncm93KGUuc2l6ZV8wKzEpLHQ9ZS52YWxpZGF0ZShuLHIpLG4hPWUuc2l6ZV8wJiZYbyhlLmRhdGFfMCxuLGUuZGF0YV8wLG4rMSxlLnNpemVfMC1uKSxUcihlLmRhdGFfMCxuLHQpLCsrZS5zaXplXzAsZS5kaWRBZGQobixyKSxlLmRpZENoYW5nZSgpfWZ1bmN0aW9uIHNiKGUsbil7ZS5ncm93KGUuc2l6ZV8wKzEpLHBTKGUsZS5zaXplXzAsZS52YWxpZGF0ZShlLnNpemVfMCxuKSksZS5kaWRBZGQoZS5zaXplXzArKyxuKSxlLmRpZENoYW5nZSgpfWZ1bmN0aW9uIHBTKGUsbixyKXtyZXR1cm4gVHIoZS5kYXRhXzAsbixyKSxyfWZ1bmN0aW9uIFhuZShlLG4pe2lmKGUuZGF0YV8wPT1udWxsfHxuPj1lLnNpemVfMCl0aHJvdyBiKG5ldyBURChuLGUuc2l6ZV8wKSk7cmV0dXJuIGUuZGF0YV8wW25dfWZ1bmN0aW9uIGdTKGUpe3ZhciBuLHI7KytlLm1vZENvdW50LG49ZS5kYXRhXzAscj1lLnNpemVfMCxlLmRhdGFfMD1udWxsLGUuc2l6ZV8wPTAsZS5kaWRDbGVhcihyLG4pLGUuZGlkQ2hhbmdlKCl9ZnVuY3Rpb24gV3coZSxuKXt2YXIgcjtpZihlLnVzZUVxdWFscygpJiZuIT1udWxsKXtmb3Iocj0wO3I8ZS5zaXplXzA7KytyKWlmKFluKG4sZS5kYXRhXzBbcl0pKXJldHVybiEwfWVsc2UgZm9yKHI9MDtyPGUuc2l6ZV8wOysrcilpZihEKGUuZGF0YV8wW3JdKT09PUQobikpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gTyhlLG4pe2lmKGUuZGF0YV8wPT1udWxsfHxuPj1lLnNpemVfMCl0aHJvdyBiKG5ldyBURChuLGUuc2l6ZV8wKSk7cmV0dXJuIGUucmVzb2x2ZShuLGUuZGF0YV8wW25dKX1mdW5jdGlvbiBWQmUoZSxuKXt2YXIgcjtpZihlLnVzZUVxdWFscygpJiZuIT1udWxsKXtmb3Iocj0wO3I8ZS5zaXplXzA7KytyKWlmKFluKG4sZS5kYXRhXzBbcl0pKXJldHVybiByfWVsc2UgZm9yKHI9MDtyPGUuc2l6ZV8wOysrcilpZihEKGUuZGF0YV8wW3JdKT09PUQobikpcmV0dXJuIHI7cmV0dXJuLTF9ZnVuY3Rpb24gZEQoZSxuLHIpe3ZhciB0O2lmKCsrZS5tb2RDb3VudCxuPj1lLnNpemVfMCl0aHJvdyBiKG5ldyBubygidGFyZ2V0SW5kZXg9IituKyIsIHNpemU9IitlLnNpemVfMCkpO2lmKHI+PWUuc2l6ZV8wKXRocm93IGIobmV3IG5vKCJzb3VyY2VJbmRleD0iK3IrIiwgc2l6ZT0iK2Uuc2l6ZV8wKSk7cmV0dXJuIHQ9ZS5kYXRhXzBbcl0sbiE9ciYmKG48cj9YbyhlLmRhdGFfMCxuLGUuZGF0YV8wLG4rMSxyLW4pOlhvKGUuZGF0YV8wLHIrMSxlLmRhdGFfMCxyLG4tciksVHIoZS5kYXRhXzAsbix0KSxlLmRpZE1vdmUobix0LHIpLGUuZGlkQ2hhbmdlKCkpLHR9ZnVuY3Rpb24gdm0oZSxuKXt2YXIgcix0O2lmKG4+PWUuc2l6ZV8wKXRocm93IGIobmV3IFREKG4sZS5zaXplXzApKTtyZXR1cm4rK2UubW9kQ291bnQscj1lLmRhdGFfMFtuXSx0PWUuc2l6ZV8wLW4tMSx0PjAmJlhvKGUuZGF0YV8wLG4rMSxlLmRhdGFfMCxuLHQpLFRyKGUuZGF0YV8wLC0tZS5zaXplXzAsbnVsbCksZS5kaWRSZW1vdmUobixyKSxlLmRpZENoYW5nZSgpLHJ9ZnVuY3Rpb24gZkQoZSxuLHIpe3ZhciB0O3JldHVybiB0PWUuZGF0YV8wW25dLHBTKGUsbixlLnZhbGlkYXRlKG4scikpLGUuZGlkU2V0KG4scix0KSxlLmRpZENoYW5nZSgpLHR9ZnVuY3Rpb24gSmYoZSl7dmFyIG47KytlLm1vZENvdW50LGUuc2l6ZV8wPT0wP2UuZGF0YV8wPW51bGw6ZS5zaXplXzA8ZS5kYXRhXzAubGVuZ3RoJiYobj1lLmRhdGFfMCxlLmRhdGFfMD1lLm5ld0RhdGEoZS5zaXplXzApLFhvKG4sMCxlLmRhdGFfMCwwLGUuc2l6ZV8wKSl9ZnVuY3Rpb24gSm5lKGUpe3ZhciBuO3JldHVybiBuPWUubmV3RGF0YShlLnNpemVfMCksZS5zaXplXzA+MCYmWG8oZS5kYXRhXzAsMCxuLDAsZS5zaXplXzApLG59ZnVuY3Rpb24gWm5lKGUsbil7dmFyIHI7cmV0dXJuIGUuc2l6ZV8wPjAmJihuLmxlbmd0aDxlLnNpemVfMCYmKHI9ZmIod2EobikuY29tcG9uZW50VHlwZSxlLnNpemVfMCksbj1yKSxYbyhlLmRhdGFfMCwwLG4sMCxlLnNpemVfMCkpLG4ubGVuZ3RoPmUuc2l6ZV8wJiZUcihuLGUuc2l6ZV8wLG51bGwpLG59ZnVuY3Rpb24gUUEoKXt9ZnVuY3Rpb24gUGQoZSl7aWYoZTwwKXRocm93IGIobmV3IEdlKCJJbGxlZ2FsIENhcGFjaXR5OiAiK2UpKTt0aGlzLmRhdGFfMD10aGlzLm5ld0RhdGEoZSl9ZnVuY3Rpb24gUW5lKGUpe3RoaXMuc2l6ZV8wPWUuc2l6ZV8xKCksdGhpcy5zaXplXzA+MCYmKHRoaXMuZGF0YV8wPXRoaXMubmV3RGF0YSh0aGlzLnNpemVfMCsodGhpcy5zaXplXzAvOHwwKSsxKSxlLnRvQXJyYXlfMCh0aGlzLmRhdGFfMCkpfXAoNjYsNzAsZXUsUUEsUGQsUW5lKSxsLmFkZEFsbFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiBfRCh0aGlzLG4scil9LGwuYWRkQWxsVW5pcXVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIGpCZSh0aGlzLG4pfSxsLmFkZFVuaXF1ZT1mdW5jdGlvbihuLHIpe2xiKHRoaXMsbixyKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXtzYih0aGlzLG4pfSxsLmJhc2ljR2V0PWZ1bmN0aW9uKG4pe3JldHVybiBYbmUodGhpcyxuKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7Z1ModGhpcyl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIFd3KHRoaXMsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIE8odGhpcyxuKX0sbC5ncm93PWZ1bmN0aW9uKG4pe3ZhciByLHQsbzsrK3RoaXMubW9kQ291bnQsdD10aGlzLmRhdGFfMD09bnVsbD8wOnRoaXMuZGF0YV8wLmxlbmd0aCxuPnQmJihvPXRoaXMuZGF0YV8wLHI9dCsodC8yfDApKzQscjxuJiYocj1uKSx0aGlzLmRhdGFfMD10aGlzLm5ld0RhdGEociksbyE9bnVsbCYmWG8obywwLHRoaXMuZGF0YV8wLDAsdGhpcy5zaXplXzApKX0sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIFZCZSh0aGlzLG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzA9PTB9LGwubW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiBkRCh0aGlzLG4scil9LGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQihRcixNZSwxLG4sNSwxKX0sbC5wcmltaXRpdmVHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGF0YV8wW25dfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiB2bSh0aGlzLG4pfSxsLnNldFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiBmRCh0aGlzLG4scil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gSm5lKHRoaXMpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gWm5lKHRoaXMsbil9LGwuc2l6ZV8wPTA7dmFyIGVyZT1nKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VMaXN0Iiw2NiksbnJlPUNyKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJUcmVlSXRlcmF0b3IiKTtmdW5jdGlvbiBycmUoZSl7dmFyIG47cmV0dXJuIG49ZS5uZXh0UHJ1bmVJdGVyYXRvcixuPWUuZ2V0Q2hpbGRyZW4oZS5vYmplY3QpLHBuKGUsbiksbi5oYXNOZXh0XzAoKX1mdW5jdGlvbiBlTChlKXt2YXIgbixyLHQsbyxpO2lmKGUuZGF0YV8wPT1udWxsJiYoZS5uZXh0UHJ1bmVJdGVyYXRvcj1lLmdldENoaWxkcmVuKGUub2JqZWN0KSxwbihlLGUubmV4dFBydW5lSXRlcmF0b3IpLGUuaW5jbHVkZVJvb3QpKXJldHVybiBpPWUub2JqZWN0LGk7aWYobj1hKGUuZGF0YV8wW2Uuc2l6ZV8wLTFdLDUxKSxvPW4ubmV4dF8xKCksZS5uZXh0UmVtb3ZlSXRlcmF0b3I9bixyPWUuZ2V0Q2hpbGRyZW4obyksci5oYXNOZXh0XzAoKSllLm5leHRQcnVuZUl0ZXJhdG9yPXIscG4oZSxyKTtlbHNlIGZvcihlLm5leHRQcnVuZUl0ZXJhdG9yPW51bGw7IW4uaGFzTmV4dF8wKCkmJihUcihlLmRhdGFfMCwtLWUuc2l6ZV8wLG51bGwpLGUuc2l6ZV8wIT0wKTspdD1hKGUuZGF0YV8wW2Uuc2l6ZV8wLTFdLDUxKSxuPXQ7cmV0dXJuIG99ZnVuY3Rpb24gcUJlKGUsbil7dGhpcy5vYmplY3Q9ZSx0aGlzLmluY2x1ZGVSb290PW59cCg3MDgsNjYsbTYpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGFfMD09bnVsbCYmIXRoaXMuaW5jbHVkZVJvb3Q/cnJlKHRoaXMpOnRoaXMuZGF0YV8wPT1udWxsfHx0aGlzLnNpemVfMCE9MCYmYSh0aGlzLmRhdGFfMFt0aGlzLnNpemVfMC0xXSw1MSkuaGFzTmV4dF8wKCl9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIGVMKHRoaXMpfSxsLnJlbW92ZT1mdW5jdGlvbigpe2lmKCF0aGlzLm5leHRSZW1vdmVJdGVyYXRvcil0aHJvdyBiKG5ldyBybygiVGhlcmUgaXMgbm8gdmFsaWQgb2JqZWN0IHRvIHJlbW92ZS4iKSk7dGhpcy5uZXh0UmVtb3ZlSXRlcmF0b3IucmVtb3ZlKCl9LGwuaW5jbHVkZVJvb3Q9ITEsZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQWJzdHJhY3RUcmVlSXRlcmF0b3IiLDcwOCk7ZnVuY3Rpb24gdHJlKGUpe3FCZS5jYWxsKHRoaXMsZSwhMCl9cCg3MDAsNzA4LG02LHRyZSksbC5nZXRDaGlsZHJlbj1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1hKG4sNTgpLmVDb250ZW50c18wKCkuaXRlcmF0b3JfMCgpLEwociwyODcpJiZhKHIsMjg3KS5maWx0ZXJfMChuZXcgWUJlKSxyfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgudXRpbCIsIkVsa0dyYXBoVXRpbC9Qcm9wZXJ0aWVzU2tpcHBpbmdUcmVlSXRlcmF0b3IiLDcwMCk7ZnVuY3Rpb24gWUJlKCl7fXAoOTY1LDEse30sWUJlKSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgudXRpbCIsIkVsa0dyYXBoVXRpbC9Qcm9wZXJ0aWVzU2tpcHBpbmdUcmVlSXRlcmF0b3IvMSIsOTY1KTtmdW5jdGlvbiBuTCgpe25MPUYscEQ9bmV3IHNuLHViPW5ldyBzbixIU24oSDBlLG5ldyBLQmUpfWZ1bmN0aW9uIG9yZShlKXtyZXR1cm4gbkwoKSxMKGUsMTYyKT9hKEtlKHViLEgwZSksMjk1KS5jbG9uZShlKTp5aSh1Yix3YShlKSk/YShLZSh1Yix3YShlKSksMjk1KS5jbG9uZShlKTpudWxsfWZ1bmN0aW9uIEdTbihlKXtyZXR1cm4gbkwoKSx5aShwRCxlKT9hKEtlKHBELGUpLDM0MSkubmV3SW5zdGFuY2UoKTpudWxsfWZ1bmN0aW9uICRnKGUsbixyKXtuTCgpLGUmJkJuKHBELGUsbiksZSYmQm4odWIsZSxyKX1mdW5jdGlvbiBIU24oZSxuKXtlJiZCbih1YixlLG4pfXZhciB1YixwRCxjYj1nKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgudXRpbCIsIkVsa1JlZmxlY3QiLG51bGwpO2Z1bmN0aW9uIEtCZSgpe31wKDkwMSwxLFdkLEtCZSksbC5jbG9uZT1mdW5jdGlvbihuKXtyZXR1cm4gbkwoKSxwUWUoYShuLDE4MSkpfSxnKCJvcmcuZWNsaXBzZS5lbGsuZ3JhcGgudXRpbCIsIkVsa1JlZmxlY3QvbGFtYmRhJDAkVHlwZSIsOTAxKTtmdW5jdGlvbiBpcmUoKXtpcmU9RixRMD12dygpfWZ1bmN0aW9uIFhCZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKGg9bmV3IFpkKGUuZ2V0VGFza05hbWUoKSksYXMobiwibmFtZSIsaCksciYmIWUuZ2V0TG9ncygpLmxpc3QuaXNFbXB0eSgpKWZvcihkPW5ldyBUXyxhcyhuLCJsb2dzIixkKSx1PTAseT1uZXcgZ3koZS5nZXRMb2dzKCkuY29sbC5pdGVyYXRvcl8wKCkpO3kuaXQuaGFzTmV4dF8wKCk7KW09eG4oeS5pdC5uZXh0XzEoKSksZj1uZXcgWmQobSksSmQoZCx1KSx5NShkLHUsZiksKyt1O2lmKHQmJihfPW5ldyAkSShlLmdldEV4ZWN1dGlvblRpbWUoKSksYXMobiwiZXhlY3V0aW9uVGltZSIsXykpLCFlLmdldFN1Yk1vbml0b3JzKCkubGlzdC5pc0VtcHR5KCkpZm9yKHM9bmV3IFRfLGFzKG4sImNoaWxkcmVuIixzKSx1PTAsaT1uZXcgZ3koZS5nZXRTdWJNb25pdG9ycygpLmNvbGwuaXRlcmF0b3JfMCgpKTtpLml0Lmhhc05leHRfMCgpOylvPWEoaS5pdC5uZXh0XzEoKSw4NzEpLGM9bmV3IHNoLEpkKHMsdSkseTUocyx1LGMpLFhCZShvLGMscix0KSwrK3V9ZnVuY3Rpb24gVVNuKCl7aXJlKCk7ZnVuY3Rpb24gZSh0KXt2YXIgbz10aGlzO3RoaXMuZGlzcGF0Y2g9ZnVuY3Rpb24oaSl7dmFyIHM9aS5kYXRhO3N3aXRjaChzLmNtZCl7Y2FzZSJhbGdvcml0aG1zIjp2YXIgdT1hcmUoKE5lKCksbmV3IHB5KG5ldyB0YyhRMC5sYXlvdXRBbGdvcml0aG1NYXApKSkpO3QucG9zdE1lc3NhZ2Uoe2lkOnMuaWQsZGF0YTp1fSk7YnJlYWs7Y2FzZSJjYXRlZ29yaWVzIjp2YXIgYz1hcmUoKE5lKCksbmV3IHB5KG5ldyB0YyhRMC5sYXlvdXRDYXRlZ29yeU1hcCkpKSk7dC5wb3N0TWVzc2FnZSh7aWQ6cy5pZCxkYXRhOmN9KTticmVhaztjYXNlIm9wdGlvbnMiOnZhciBfPWFyZSgoTmUoKSxuZXcgcHkobmV3IHRjKFEwLmxheW91dE9wdGlvbk1hcCkpKSk7dC5wb3N0TWVzc2FnZSh7aWQ6cy5pZCxkYXRhOl99KTticmVhaztjYXNlInJlZ2lzdGVyIjpWU24ocy5hbGdvcml0aG1zKSx0LnBvc3RNZXNzYWdlKHtpZDpzLmlkfSk7YnJlYWs7Y2FzZSJsYXlvdXQiOldTbihzLmdyYXBoLHMubGF5b3V0T3B0aW9uc3x8e30scy5vcHRpb25zfHx7fSksdC5wb3N0TWVzc2FnZSh7aWQ6cy5pZCxkYXRhOnMuZ3JhcGh9KTticmVha319LHRoaXMuc2F2ZURpc3BhdGNoPWZ1bmN0aW9uKGkpe3RyeXtvLmRpc3BhdGNoKGkpfWNhdGNoKHMpe3QucG9zdE1lc3NhZ2Uoe2lkOmkuZGF0YS5pZCxlcnJvcjpzfSl9fX1mdW5jdGlvbiBuKHQpe3ZhciBvPXRoaXM7dGhpcy5kaXNwYXRjaGVyPW5ldyBlKHtwb3N0TWVzc2FnZTpmdW5jdGlvbihpKXtvLm9ubWVzc2FnZSh7ZGF0YTppfSl9fSksdGhpcy5wb3N0TWVzc2FnZT1mdW5jdGlvbihpKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7by5kaXNwYXRjaGVyLnNhdmVEaXNwYXRjaCh7ZGF0YTppfSl9LDApfX1pZih0eXBlb2YgZG9jdW1lbnQ+InUiJiZ0eXBlb2Ygc2VsZjwidSIpe3ZhciByPW5ldyBlKHNlbGYpO3NlbGYub25tZXNzYWdlPXIuc2F2ZURpc3BhdGNofWVsc2UgUW9lLmV4cG9ydHMmJihPYmplY3QuZGVmaW5lUHJvcGVydHkoT1llLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KSxRb2UuZXhwb3J0cz17ZGVmYXVsdDpuLFdvcmtlcjpufSl9ZnVuY3Rpb24gYXJlKGUpe3ZhciBuLHIsdCxvO2ZvcihuPW5ldyBUXyxvPW5ldyBneShlLmNvbGwuaXRlcmF0b3JfMCgpKTtvLml0Lmhhc05leHRfMCgpOyl0PWEoby5pdC5uZXh0XzEoKSw3MDEpLHI9QVNuKHQpLHZKZShuLG4uanNBcnJheS5sZW5ndGgscik7cmV0dXJuIG4uanNBcnJheX1mdW5jdGlvbiBXU24oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG07aT1uZXcgcEMoZSkscz1uZXcgaiRlLG89KGxDKHMubm9kZUlkTWFwKSxsQyhzLnBvcnRJZE1hcCksWmkocy5lZGdlSWRNYXApLGxDKHMuZWRnZVNlY3Rpb25JZE1hcCksbEMocy5ub2RlSnNvbk1hcCksWmkocy5wb3J0SnNvbk1hcCksWmkocy5lZGdlSnNvbk1hcCksWmkocy5lZGdlU2VjdGlvbkpzb25NYXApLG09VyRlKHMsaSxudWxsKSxVJGUocyxpKSxtKSxuJiYoXz1uZXcgcEMobiksdT1qU24oXyksYmVlKG8sUChJKCRaLDEpLE1lLDUzNiwwLFt1XSkpKSxoPSExLGY9ITEsciYmKF89bmV3IHBDKHIpLCJsb2dnaW5nImluIF8uanNPYmplY3QmJihoPVF1KF8sImxvZ2dpbmciKS5pc0Jvb2xlYW4oKS52YWx1ZV8wKSwibWVhc3VyZUV4ZWN1dGlvblRpbWUiaW4gXy5qc09iamVjdCYmKGY9UXUoXywibWVhc3VyZUV4ZWN1dGlvblRpbWUiKS5pc0Jvb2xlYW4oKS52YWx1ZV8wKSksZD1yemUodHplKG5ldyBnbSxoKSxmKSxsMm4obmV3IGJSZSxvLGQpLCJsb2dnaW5nImluIGkuanNPYmplY3QmJmFzKGksImxvZ2dpbmciLG51bGwpLChofHxmKSYmKGM9bmV3IHNoLFhCZShkLGMsaCxmKSxhcyhpLCJsb2dnaW5nIixjKSksdD1uZXcgdkJlKHMpLFRJbihuZXcgdHJlKG8pLHQpfWZ1bmN0aW9uIGpTbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2ZvcihpPW5ldyBwUmUsUXduKGksKFFoKCksZ1JlKSksdD0obz13NShlLEIoc2UsWCwyLDAsNiwxKSksbmV3IHEyKG5ldyBlYShuZXcgRTUoZSxvKS52YWwka2V5czIpKSk7dC5pPHQudGhpcyQwMV8wLnNpemVfMSgpOylyPShybih0Lmk8dC50aGlzJDAxXzAuc2l6ZV8xKCkpLHhuKHQudGhpcyQwMV8wLmdldF8wKHQubGFzdD10LmkrKykpKSxzPVZaKFEwLHIpLHMmJihuPVF1KGUsciksbi5pc1N0cmluZygpP3U9bi5pc1N0cmluZygpLnZhbHVlXzA6bi5pc0Jvb2xlYW4oKT91PSIiK24uaXNCb29sZWFuKCkudmFsdWVfMDpuLmlzTnVtYmVyKCk/dT0iIituLmlzTnVtYmVyKCkudmFsdWVfMDp1PW4udG9TdHJpbmdfMCgpLGM9WVoocyx1KSxjIT1udWxsJiYoKCRpKHMudGFyZ2V0cywoaHMoKSxKcikpfHwkaShzLnRhcmdldHMsT2UpKSYmUUMoVU0oaSxVbikscyxjKSwkaShzLnRhcmdldHMsbXUpJiZRQyhVTShpLE1yKSxzLGMpLCRpKHMudGFyZ2V0cyxRXykmJlFDKFVNKGksdWEpLHMsYyksJGkocy50YXJnZXRzLFhjKSYmUUMoVU0oaSxRdCkscyxjKSkpO3JldHVybiBpfWZ1bmN0aW9uIFZTbihlKXt2YXIgbixyLHQ7Zm9yKHlnKFEwLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IF9RXSkpLHI9bmV3IGIkKGUpLHQ9MDt0PHIuanNBcnJheS5sZW5ndGg7Kyt0KW49SmQocix0KS5pc1N0cmluZygpLnZhbHVlXzAsVGUobiwibGF5ZXJlZCIpP3lnKFEwLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IE1JZV0pKTpUZShuLCJmb3JjZSIpP3lnKFEwLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IGFtZV0pKTpUZShuLCJzdHJlc3MiKT95ZyhRMCxQKEkoRHAsMSksTWUsMTM0LDAsW25ldyBNbWVdKSk6VGUobiwibXJ0cmVlIik/eWcoUTAsUChJKERwLDEpLE1lLDEzNCwwLFtuZXcgcjhlXSkpOlRlKG4sInJhZGlhbCIpP3lnKFEwLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IHRPZV0pKTpUZShuLCJkaXNjbyIpP3lnKFEwLFAoSShEcCwxKSxNZSwxMzQsMCxbbmV3IGZmZSxuZXcgY2hlXSkpOlRlKG4sInNwb3JlT3ZlcmxhcCIpfHxUZShuLCJzcG9yZUNvbXBhY3Rpb24iKT95ZyhRMCxQKEkoRHAsMSksTWUsMTM0LDAsW25ldyBETWVdKSk6VGUobiwicmVjdHBhY2tpbmciKSYmeWcoUTAsUChJKERwLDEpLE1lLDEzNCwwLFtuZXcgbjdlXSkpfXZhciBRMDtDcigib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiUmVzb3VyY2VMb2NhdG9yIik7ZnVuY3Rpb24gQW4oZSl7cmV0dXJuIFRlKCJfVUlfRU1GRGlhZ25vc3RpY19tYXJrZXIiLGUpPyJFTUYgUHJvYmxlbSI6VGUoIl9VSV9DaXJjdWxhckNvbnRhaW5tZW50X2RpYWdub3N0aWMiLGUpPyJBbiBvYmplY3QgbWF5IG5vdCBjaXJjdWxhcmx5IGNvbnRhaW4gaXRzZWxmIjpUZSgicGFyc2VyLnBhcnNlLjEiLGUpPyJXcm9uZyBjaGFyYWN0ZXIuIjpUZSgicGFyc2VyLnBhcnNlLjIiLGUpPyJJbnZhbGlkIHJlZmVyZW5jZSBudW1iZXIuIjpUZSgicGFyc2VyLm5leHQuMSIsZSk/IkEgY2hhcmFjdGVyIGlzIHJlcXVpcmVkIGFmdGVyIFxcLiI6VGUoInBhcnNlci5uZXh0LjIiLGUpPyInPycgaXMgbm90IGV4cGVjdGVkLiAgJyg/Oicgb3IgJyg/PScgb3IgJyg/IScgb3IgJyg/PCcgb3IgJyg/Iycgb3IgJyg/Pic/IjpUZSgicGFyc2VyLm5leHQuMyIsZSk/IicoPzwnIG9yICcoPzwhJyBpcyBleHBlY3RlZC4iOlRlKCJwYXJzZXIubmV4dC40IixlKT8iQSBjb21tZW50IGlzIG5vdCB0ZXJtaW5hdGVkLiI6VGUoInBhcnNlci5mYWN0b3IuMSIsZSk/IicpJyBpcyBleHBlY3RlZC4iOlRlKCJwYXJzZXIuZmFjdG9yLjIiLGUpPyJVbmV4cGVjdGVkIGVuZCBvZiB0aGUgcGF0dGVybiBpbiBhIG1vZGlmaWVyIGdyb3VwLiI6VGUoInBhcnNlci5mYWN0b3IuMyIsZSk/Iic6JyBpcyBleHBlY3RlZC4iOlRlKCJwYXJzZXIuZmFjdG9yLjQiLGUpPyJVbmV4cGVjdGVkIGVuZCBvZiB0aGUgcGF0dGVybiBpbiBhIGNvbmRpdGlvbmFsIGdyb3VwLiI6VGUoInBhcnNlci5mYWN0b3IuNSIsZSk/IkEgYmFjayByZWZlcmVuY2Ugb3IgYW4gYW5jaG9yIG9yIGEgbG9va2FoZWFkIG9yIGEgbG9vay1iZWhpbmQgaXMgZXhwZWN0ZWQgaW4gYSBjb25kaXRpb25hbCBwYXR0ZXJuLiI6VGUoInBhcnNlci5mYWN0b3IuNiIsZSk/IlRoZXJlIGFyZSBtb3JlIHRoYW4gdGhyZWUgY2hvaWNlcyBpbiBhIGNvbmRpdGlvbmFsIGdyb3VwLiI6VGUoInBhcnNlci5hdG9tLjEiLGUpPyJBIGNoYXJhY3RlciBpbiBVKzAwNDAtVSswMDVmIG11c3QgZm9sbG93IFxcYy4iOlRlKCJwYXJzZXIuYXRvbS4yIixlKT8iQSAneycgaXMgcmVxdWlyZWQgYmVmb3JlIGEgY2hhcmFjdGVyIGNhdGVnb3J5LiI6VGUoInBhcnNlci5hdG9tLjMiLGUpPyJBIHByb3BlcnR5IG5hbWUgaXMgbm90IGNsb3NlZCBieSAnfScuIjpUZSgicGFyc2VyLmF0b20uNCIsZSk/IlVuZXhwZWN0ZWQgbWV0YSBjaGFyYWN0ZXIuIjpUZSgicGFyc2VyLmF0b20uNSIsZSk/IlVua25vd24gcHJvcGVydHkuIjpUZSgicGFyc2VyLmNjLjEiLGUpPyJBIFBPU0lYIGNoYXJhY3RlciBjbGFzcyBtdXN0IGJlIGNsb3NlZCBieSAnOl0nLiI6VGUoInBhcnNlci5jYy4yIixlKT8iVW5leHBlY3RlZCBlbmQgb2YgdGhlIHBhdHRlcm4gaW4gYSBjaGFyYWN0ZXIgY2xhc3MuIjpUZSgicGFyc2VyLmNjLjMiLGUpPyJVbmtub3duIG5hbWUgZm9yIGEgUE9TSVggY2hhcmFjdGVyIGNsYXNzLiI6VGUoInBhcnNlci5jYy40IixlKT8iJy0nIGlzIGludmFsaWQgaGVyZS4iOlRlKCJwYXJzZXIuY2MuNSIsZSk/IiddJyBpcyBleHBlY3RlZC4iOlRlKCJwYXJzZXIuY2MuNiIsZSk/IidbJyBpcyBpbnZhbGlkIGluIGEgY2hhcmFjdGVyIGNsYXNzLiAgV3JpdGUgJ1xcWycuIjpUZSgicGFyc2VyLmNjLjciLGUpPyInXScgaXMgaW52YWxpZCBpbiBhIGNoYXJhY3RlciBjbGFzcy4gIFdyaXRlICdcXF0nLiI6VGUoInBhcnNlci5jYy44IixlKT8iJy0nIGlzIGFuIGludmFsaWQgY2hhcmFjdGVyIHJhbmdlLiBXcml0ZSAnXFwtJy4iOlRlKCJwYXJzZXIub3BlLjEiLGUpPyInWycgaXMgZXhwZWN0ZWQuIjpUZSgicGFyc2VyLm9wZS4yIixlKT8iJyknIG9yICctWycgb3IgJytbJyBvciAnJlsnIGlzIGV4cGVjdGVkLiI6VGUoInBhcnNlci5vcGUuMyIsZSk/IlRoZSByYW5nZSBlbmQgY29kZSBwb2ludCBpcyBsZXNzIHRoYW4gdGhlIHN0YXJ0IGNvZGUgcG9pbnQuIjpUZSgicGFyc2VyLmRlc2NhcGUuMSIsZSk/IkludmFsaWQgVW5pY29kZSBoZXggbm90YXRpb24uIjpUZSgicGFyc2VyLmRlc2NhcGUuMiIsZSk/Ik92ZXJmbG93IGluIGEgaGV4IG5vdGF0aW9uLiI6VGUoInBhcnNlci5kZXNjYXBlLjMiLGUpPyInXFx4eycgbXVzdCBiZSBjbG9zZWQgYnkgJ30nLiI6VGUoInBhcnNlci5kZXNjYXBlLjQiLGUpPyJJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludC4iOlRlKCJwYXJzZXIuZGVzY2FwZS41IixlKT8iQW4gYW5jaG9yIG11c3Qgbm90IGJlIGhlcmUuIjpUZSgicGFyc2VyLnByb2Nlc3MuMSIsZSk/IlRoaXMgZXhwcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IG9wdGlvbiBzZXR0aW5nLiI6VGUoInBhcnNlci5xdWFudGlmaWVyLjEiLGUpPyJJbnZhbGlkIHF1YW50aWZpZXIuIEEgZGlnaXQgaXMgZXhwZWN0ZWQuIjpUZSgicGFyc2VyLnF1YW50aWZpZXIuMiIsZSk/IkludmFsaWQgcXVhbnRpZmllci4gSW52YWxpZCBxdWFudGl0eSBvciBhICd9JyBpcyBtaXNzaW5nLiI6VGUoInBhcnNlci5xdWFudGlmaWVyLjMiLGUpPyJJbnZhbGlkIHF1YW50aWZpZXIuIEEgZGlnaXQgb3IgJ30nIGlzIGV4cGVjdGVkLiI6VGUoInBhcnNlci5xdWFudGlmaWVyLjQiLGUpPyJJbnZhbGlkIHF1YW50aWZpZXIuIEEgbWluIHF1YW50aXR5IG11c3QgYmUgPD0gYSBtYXggcXVhbnRpdHkuIjpUZSgicGFyc2VyLnF1YW50aWZpZXIuNSIsZSk/IkludmFsaWQgcXVhbnRpZmllci4gQSBxdWFudGl0eSB2YWx1ZSBvdmVyZmxvdy4iOlRlKCJfVUlfUGFja2FnZVJlZ2lzdHJ5X2V4dGVuc2lvbnBvaW50IixlKT8iRWNvcmUgUGFja2FnZSBSZWdpc3RyeSBmb3IgR2VuZXJhdGVkIFBhY2thZ2VzIjpUZSgiX1VJX0R5bmFtaWNQYWNrYWdlUmVnaXN0cnlfZXh0ZW5zaW9ucG9pbnQiLGUpPyJFY29yZSBQYWNrYWdlIFJlZ2lzdHJ5IGZvciBEeW5hbWljIFBhY2thZ2VzIjpUZSgiX1VJX0ZhY3RvcnlSZWdpc3RyeV9leHRlbnNpb25wb2ludCIsZSk/IkVjb3JlIEZhY3RvcnkgT3ZlcnJpZGUgUmVnaXN0cnkiOlRlKCJfVUlfVVJJRXh0ZW5zaW9uUGFyc2VyUmVnaXN0cnlfZXh0ZW5zaW9ucG9pbnQiLGUpPyJVUkkgRXh0ZW5zaW9uIFBhcnNlciBSZWdpc3RyeSI6VGUoIl9VSV9VUklQcm90b2NvbFBhcnNlclJlZ2lzdHJ5X2V4dGVuc2lvbnBvaW50IixlKT8iVVJJIFByb3RvY29sIFBhcnNlciBSZWdpc3RyeSI6VGUoIl9VSV9VUklDb250ZW50UGFyc2VyUmVnaXN0cnlfZXh0ZW5zaW9ucG9pbnQiLGUpPyJVUkkgQ29udGVudCBQYXJzZXIgUmVnaXN0cnkiOlRlKCJfVUlfQ29udGVudEhhbmRsZXJSZWdpc3RyeV9leHRlbnNpb25wb2ludCIsZSk/IkNvbnRlbnQgSGFuZGxlciBSZWdpc3RyeSI6VGUoIl9VSV9VUklNYXBwaW5nUmVnaXN0cnlfZXh0ZW5zaW9ucG9pbnQiLGUpPyJVUkkgQ29udmVydGVyIE1hcHBpbmcgUmVnaXN0cnkiOlRlKCJfVUlfUGFja2FnZVJlZ2lzdHJ5SW1wbGVtZW50YXRpb25fZXh0ZW5zaW9ucG9pbnQiLGUpPyJFY29yZSBQYWNrYWdlIFJlZ2lzdHJ5IEltcGxlbWVudGF0aW9uIjpUZSgiX1VJX1ZhbGlkYXRpb25EZWxlZ2F0ZVJlZ2lzdHJ5X2V4dGVuc2lvbnBvaW50IixlKT8iVmFsaWRhdGlvbiBEZWxlZ2F0ZSBSZWdpc3RyeSI6VGUoIl9VSV9TZXR0aW5nRGVsZWdhdGVSZWdpc3RyeV9leHRlbnNpb25wb2ludCIsZSk/IkZlYXR1cmUgU2V0dGluZyBEZWxlZ2F0ZSBGYWN0b3J5IFJlZ2lzdHJ5IjpUZSgiX1VJX0ludm9jYXRpb25EZWxlZ2F0ZVJlZ2lzdHJ5X2V4dGVuc2lvbnBvaW50IixlKT8iT3BlcmF0aW9uIEludm9jYXRpb24gRGVsZWdhdGUgRmFjdG9yeSBSZWdpc3RyeSI6VGUoIl9VSV9FQ2xhc3NJbnRlcmZhY2VOb3RBYnN0cmFjdF9kaWFnbm9zdGljIixlKT8iQSBjbGFzcyB0aGF0IGlzIGFuIGludGVyZmFjZSBtdXN0IGFsc28gYmUgYWJzdHJhY3QiOlRlKCJfVUlfRUNsYXNzTm9DaXJjdWxhclN1cGVyVHlwZXNfZGlhZ25vc3RpYyIsZSk/IkEgY2xhc3MgbWF5IG5vdCBiZSBhIHN1cGVyIHR5cGUgb2YgaXRzZWxmIjpUZSgiX1VJX0VDbGFzc05vdFdlbGxGb3JtZWRNYXBFbnRyeU5vSW5zdGFuY2VDbGFzc05hbWVfZGlhZ25vc3RpYyIsZSk/IkEgY2xhc3MgdGhhdCBpbmhlcml0cyBmcm9tIGEgbWFwIGVudHJ5IGNsYXNzIG11c3QgaGF2ZSBpbnN0YW5jZSBjbGFzcyBuYW1lICdqYXZhLnV0aWwuTWFwJEVudHJ5JyI6VGUoIl9VSV9FUmVmZXJlbmNlT3Bwb3NpdGVPZk9wcG9zaXRlSW5jb25zaXN0ZW50X2RpYWdub3N0aWMiLGUpPyJUaGUgb3Bwb3NpdGUgb2YgdGhlIG9wcG9zaXRlIG1heSBub3QgYmUgYSByZWZlcmVuY2UgZGlmZmVyZW50IGZyb20gdGhpcyBvbmUiOlRlKCJfVUlfRVJlZmVyZW5jZU9wcG9zaXRlTm90RmVhdHVyZU9mVHlwZV9kaWFnbm9zdGljIixlKT8iVGhlIG9wcG9zaXRlIG11c3QgYmUgYSBmZWF0dXJlIG9mIHRoZSByZWZlcmVuY2UncyB0eXBlIjpUZSgiX1VJX0VSZWZlcmVuY2VUcmFuc2llbnRPcHBvc2l0ZU5vdFRyYW5zaWVudF9kaWFnbm9zdGljIixlKT8iVGhlIG9wcG9zaXRlIG9mIGEgdHJhbnNpZW50IHJlZmVyZW5jZSBtdXN0IGJlIHRyYW5zaWVudCBpZiBpdCBpcyBwcm94eSByZXNvbHZpbmciOlRlKCJfVUlfRVJlZmVyZW5jZU9wcG9zaXRlQm90aENvbnRhaW5tZW50X2RpYWdub3N0aWMiLGUpPyJUaGUgb3Bwb3NpdGUgb2YgYSBjb250YWlubWVudCByZWZlcmVuY2UgbXVzdCBub3QgYmUgYSBjb250YWlubWVudCByZWZlcmVuY2UiOlRlKCJfVUlfRVJlZmVyZW5jZUNvbnNpc3RlbnRVbmlxdWVfZGlhZ25vc3RpYyIsZSk/IkEgY29udGFpbm1lbnQgb3IgYmlkaXJlY3Rpb25hbCByZWZlcmVuY2UgbXVzdCBiZSB1bmlxdWUgaWYgaXRzIHVwcGVyIGJvdW5kIGlzIGRpZmZlcmVudCBmcm9tIDEiOlRlKCJfVUlfRVR5cGVkRWxlbWVudE5vVHlwZV9kaWFnbm9zdGljIixlKT8iVGhlIHR5cGVkIGVsZW1lbnQgbXVzdCBoYXZlIGEgdHlwZSI6VGUoIl9VSV9FQXR0cmlidXRlTm9EYXRhVHlwZV9kaWFnbm9zdGljIixlKT8iVGhlIGdlbmVyaWMgYXR0cmlidXRlIHR5cGUgbXVzdCBub3QgcmVmZXIgdG8gYSBjbGFzcyI6VGUoIl9VSV9FUmVmZXJlbmNlTm9DbGFzc19kaWFnbm9zdGljIixlKT8iVGhlIGdlbmVyaWMgcmVmZXJlbmNlIHR5cGUgbXVzdCBub3QgcmVmZXIgdG8gYSBkYXRhIHR5cGUiOlRlKCJfVUlfRUdlbmVyaWNUeXBlTm9UeXBlUGFyYW1ldGVyQW5kQ2xhc3NpZmllcl9kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgY2FuJ3QgcmVmZXIgdG8gYm90aCBhIHR5cGUgcGFyYW1ldGVyIGFuZCBhIGNsYXNzaWZpZXIiOlRlKCJfVUlfRUdlbmVyaWNUeXBlTm9DbGFzc19kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHN1cGVyIHR5cGUgbXVzdCByZWZlciB0byBhIGNsYXNzIjpUZSgiX1VJX0VHZW5lcmljVHlwZU5vVHlwZVBhcmFtZXRlck9yQ2xhc3NpZmllcl9kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgaW4gdGhpcyBjb250ZXh0IG11c3QgcmVmZXIgdG8gYSBjbGFzc2lmaWVyIG9yIGEgdHlwZSBwYXJhbWV0ZXIiOlRlKCJfVUlfRUdlbmVyaWNUeXBlQm91bmRzT25seUZvclR5cGVBcmd1bWVudF9kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgbWF5IGhhdmUgYm91bmRzIG9ubHkgd2hlbiB1c2VkIGFzIGEgdHlwZSBhcmd1bWVudCI6VGUoIl9VSV9FR2VuZXJpY1R5cGVOb1VwcGVyQW5kTG93ZXJCb3VuZF9kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgbXVzdCBub3QgaGF2ZSBib3RoIGEgbG93ZXIgYW5kIGFuIHVwcGVyIGJvdW5kIjpUZSgiX1VJX0VHZW5lcmljVHlwZU5vVHlwZVBhcmFtZXRlck9yQ2xhc3NpZmllckFuZEJvdW5kX2RpYWdub3N0aWMiLGUpPyJBIGdlbmVyaWMgdHlwZSB3aXRoIGJvdW5kcyBtdXN0IG5vdCBhbHNvIHJlZmVyIHRvIGEgdHlwZSBwYXJhbWV0ZXIgb3IgY2xhc3NpZmllciI6VGUoIl9VSV9FR2VuZXJpY1R5cGVOb0FyZ3VtZW50c19kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgbWF5IGhhdmUgYXJndW1lbnRzIG9ubHkgaWYgaXQgcmVmZXJzIHRvIGEgY2xhc3NpZmllciI6VGUoIl9VSV9FR2VuZXJpY1R5cGVPdXRPZlNjb3BlVHlwZVBhcmFtZXRlcl9kaWFnbm9zdGljIixlKT8iQSBnZW5lcmljIHR5cGUgbWF5IG9ubHkgcmVmZXIgdG8gYSB0eXBlIHBhcmFtZXRlciB0aGF0IGlzIGluIHNjb3BlIjplfXAoMTA2NSwxLHt9KSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJEZWxlZ2F0aW5nUmVzb3VyY2VMb2NhdG9yIiwxMDY1KTtmdW5jdGlvbiBscmUoZSl7ZT9fJChlLChuYygpLHZjZSkpOmVaZSgobmMoKSxlKSl9cCgxMDY2LDEwNjUse30pLGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24iLCJFTUZQbHVnaW4iLDEwNjYpO3ZhciBnRD1Dcigib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi5ub3RpZnkiLCJBZGFwdGVyIikscVNuPUNyKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLm5vdGlmeSIsIk5vdGlmaWNhdGlvbiIpO3AoMTE3NCwxLFpGKSxsLmdldFRhcmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRhcmdldH0sbC5ub3RpZnlDaGFuZ2VkPWZ1bmN0aW9uKG4pe30sbC5zZXRUYXJnZXQ9ZnVuY3Rpb24obil7dGhpcy50YXJnZXQ9bn0sbC51bnNldFRhcmdldD1mdW5jdGlvbihuKXt0aGlzLnRhcmdldD09biYmKHRoaXMudGFyZ2V0PW51bGwpfSxsLnRhcmdldD1udWxsLGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24ubm90aWZ5LmltcGwiLCJBZGFwdGVySW1wbCIsMTE3NCk7ZnVuY3Rpb24gc3JlKGUsbixyKXt2YXIgdCxvO2lmKCsrZS5tb2RDb3VudCxyLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3Iobz1yLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyl0PW8ubmV4dF8xKCksZS5kZWxlZ2F0ZUFkZChuLGUudmFsaWRhdGUobix0KSksKytuO3JldHVybiEwfWZ1bmN0aW9uIEpCZShlLG4scil7KytlLm1vZENvdW50LGUuZGVsZWdhdGVBZGQobixlLnZhbGlkYXRlKG4scikpfWZ1bmN0aW9uIFpCZShlLG4pe3ZhciByOysrZS5tb2RDb3VudCxyPWUuZGVsZWdhdGVTaXplKCksZS5kZWxlZ2F0ZUFkZF8wKGUudmFsaWRhdGUocixuKSl9ZnVuY3Rpb24gX2IoZSxuLHIpeysrZS5tb2RDb3VudCxlLmRlbGVnYXRlQ2xlYXIoKSxjRChlLG4scil9ZnVuY3Rpb24gdXJlKGUsbixyKXt2YXIgdCxvLGk7aWYoKytlLm1vZENvdW50LG89ZS5kZWxlZ2F0ZVNpemUoKSxuPj1vfHxuPDApdGhyb3cgYihuZXcgbm8oInRhcmdldEluZGV4PSIrbisiLCBzaXplPSIrbykpO2lmKHI+PW98fHI8MCl0aHJvdyBiKG5ldyBubygic291cmNlSW5kZXg9IityKyIsIHNpemU9IitvKSk7cmV0dXJuIG4hPXI/dD0oaT1lLmRlbGVnYXRlUmVtb3ZlKHIpLGUuZGVsZWdhdGVBZGQobixpKSxpKTp0PWUuZGVsZWdhdGVHZXQociksdH1mdW5jdGlvbiByTChlLG4pe3ZhciByO3JldHVybisrZS5tb2RDb3VudCxyPWUuZGVsZWdhdGVSZW1vdmUobikscn1wKDIwOTMsNzAsUGllKSxsLmFkZEFsbFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiBzcmUodGhpcyxuLHIpfSxsLmFkZEFsbFVuaXF1ZV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbztpZigrK3RoaXMubW9kQ291bnQsbi5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKHI9dGhpcy5kZWxlZ2F0ZVNpemUoKSxvPW4uaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXQ9by5uZXh0XzEoKSx0aGlzLmRlbGVnYXRlQWRkXzAodGhpcy52YWxpZGF0ZShyLHQpKSwrK3I7cmV0dXJuITB9LGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7SkJlKHRoaXMsbixyKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXtaQmUodGhpcyxuKX0sbC5iYXNpY0xpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUJhc2ljTGlzdCgpfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXtfYih0aGlzLHRoaXMuZGVsZWdhdGVTaXplKCksdGhpcy5kZWxlZ2F0ZVRvQXJyYXkoKSl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVDb250YWlucyhuKX0sbC5jb250YWluc0FsbD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUNvbnRhaW5zQWxsKG4pfSxsLmRlbGVnYXRlQWRkPWZ1bmN0aW9uKG4scil7dGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlQWRkXzA9ZnVuY3Rpb24obil7dGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlQmFzaWNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVMaXN0XzEoKX0sbC5kZWxlZ2F0ZUNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlQ29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVMaXN0XzEoKS4kX251bGxNZXRob2QoKX0sbC5kZWxlZ2F0ZUNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8xKCkuJF9udWxsTWV0aG9kKCl9LGwuZGVsZWdhdGVFcXVhbHM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVMaXN0XzEoKS4kX251bGxNZXRob2QoKX0sbC5kZWxlZ2F0ZUdldD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlSGFzaENvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlSW5kZXhPZj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlSXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8xKCkuJF9udWxsTWV0aG9kKCl9LGwuZGVsZWdhdGVSZW1vdmU9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVMaXN0XzEoKS4kX251bGxNZXRob2QoKX0sbC5kZWxlZ2F0ZVNldD1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8xKCkuJF9udWxsTWV0aG9kKCl9LGwuZGVsZWdhdGVTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVMaXN0XzEoKS4kX251bGxNZXRob2QoKX0sbC5kZWxlZ2F0ZVRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUxpc3RfMSgpLiRfbnVsbE1ldGhvZCgpfSxsLmRlbGVnYXRlVG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8xKCkuJF9udWxsTWV0aG9kKCl9LGwuZGVsZWdhdGVUb1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlTGlzdF8xKCkuJF9udWxsTWV0aG9kKCl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVFcXVhbHMobil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMucmVzb2x2ZShuLHRoaXMuZGVsZWdhdGVHZXQobikpfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUhhc2hDb2RlKCl9LGwuaW5kZXhPZl8wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlSW5kZXhPZihuKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVJc0VtcHR5KCl9LGwubW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiB1cmUodGhpcyxuLHIpfSxsLnByaW1pdGl2ZUdldD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUdldChuKX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXtyZXR1cm4gckwodGhpcyxuKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj10aGlzLmluZGV4T2ZfMChuKSxyPj0wPyh0aGlzLnJlbW92ZV8yKHIpLCEwKTohMX0sbC5zZXRVbmlxdWU9ZnVuY3Rpb24obixyKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZVNldChuLHRoaXMudmFsaWRhdGUobixyKSl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVTaXplKCl9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlVG9BcnJheSgpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZVRvQXJyYXlfMChuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVUb1N0cmluZygpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJEZWxlZ2F0aW5nRUxpc3QiLDIwOTMpO2Z1bmN0aW9uIGNyZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF87aWYodD1yLnNpemVfMSgpLHQ9PTApcmV0dXJuITE7aWYoZS5pc05vdGlmaWNhdGlvblJlcXVpcmVkKCkpaWYoYz1lLmlzU2V0XzAoKSxzcmUoZSxuLHIpLHM9dD09MT9lLmNyZWF0ZU5vdGlmaWNhdGlvbigzLG51bGwsci5pdGVyYXRvcl8wKCkubmV4dF8xKCksbixjKTplLmNyZWF0ZU5vdGlmaWNhdGlvbig1LG51bGwscixuLGMpLGUuaGFzSW52ZXJzZSgpKXtmb3IodT10PDEwMD9udWxsOm5ldyBlXyh0KSxpPW4rdCxvPW47bzxpOysrbylfPWUuZGVsZWdhdGVHZXQobyksdT1lLmludmVyc2VBZGQoXyx1KSx1PXU7dT8odS5hZGRfNShzKSx1LmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbihzKX1lbHNlIGUuZGlzcGF0Y2hOb3RpZmljYXRpb24ocyk7ZWxzZSBpZihzcmUoZSxuLHIpLGUuaGFzSW52ZXJzZSgpKXtmb3IodT10PDEwMD9udWxsOm5ldyBlXyh0KSxpPW4rdCxvPW47bzxpOysrbyl1PWUuaW52ZXJzZUFkZChlLmRlbGVnYXRlR2V0KG8pLHUpO3UmJnUuZGlzcGF0Y2hfMCgpfXJldHVybiEwfWZ1bmN0aW9uIFFCZShlLG4scil7dmFyIHQsbyxpO2UuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyhpPWUuaXNTZXRfMCgpLCsrZS5tb2RDb3VudCxlLmRlbGVnYXRlQWRkKG4sZS52YWxpZGF0ZShuLHIpKSx0PWUuY3JlYXRlTm90aWZpY2F0aW9uKDMsbnVsbCxyLG4saSksZS5oYXNJbnZlcnNlKCk/KG89ZS5pbnZlcnNlQWRkKHIsbnVsbCksbz8oby5hZGRfNSh0KSxvLmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbih0KSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbih0KSk6KCsrZS5tb2RDb3VudCxlLmRlbGVnYXRlQWRkKG4sZS52YWxpZGF0ZShuLHIpKSxlLmhhc0ludmVyc2UoKSYmKG89ZS5pbnZlcnNlQWRkKHIsbnVsbCksbyYmby5kaXNwYXRjaF8wKCkpKX1mdW5jdGlvbiBlR2UoZSxuKXt2YXIgcix0LG8saTtlLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQoKT8ocj1lLmRlbGVnYXRlU2l6ZSgpLGk9ZS5pc1NldF8wKCksKytlLm1vZENvdW50LGUuZGVsZWdhdGVBZGQocixlLnZhbGlkYXRlKHIsbikpLHQ9ZS5jcmVhdGVOb3RpZmljYXRpb24oMyxudWxsLG4scixpKSxlLmhhc0ludmVyc2UoKT8obz1lLmludmVyc2VBZGQobixudWxsKSxvPyhvLmFkZF81KHQpLG8uZGlzcGF0Y2hfMCgpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKHQpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKHQpKTooWkJlKGUsbiksZS5oYXNJbnZlcnNlKCkmJihvPWUuaW52ZXJzZUFkZChuLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpKSl9ZnVuY3Rpb24gWVNuKGUsbixyKXt2YXIgdCxvLGk7cmV0dXJuIGUuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyh0PWUuZGVsZWdhdGVTaXplKCksaT1lLmlzU2V0XzAoKSwrK2UubW9kQ291bnQsZS5kZWxlZ2F0ZUFkZCh0LGUudmFsaWRhdGUodCxuKSksbz1lLmNyZWF0ZU5vdGlmaWNhdGlvbigzLG51bGwsbix0LGkpLHI/ci5hZGRfNShvKTpyPW8pOkpCZShlLGUuZGVsZWdhdGVTaXplKCksbikscn1mdW5jdGlvbiBLU24oZSxuLHIpe3ZhciB0LG8saSxzO3JldHVybiB0PWUuaW5kZXhPZl8wKG4pLHQhPS0xJiYoZS5pc05vdGlmaWNhdGlvblJlcXVpcmVkKCk/KGk9ZS5pc1NldF8wKCkscz1yTChlLHQpLG89ZS5jcmVhdGVOb3RpZmljYXRpb24oNCxzLG51bGwsdCxpKSxyP3IuYWRkXzUobyk6cj1vKTpyTChlLHQpKSxyfWZ1bmN0aW9uIGhTKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkO2lmKGUuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpKWlmKGQ9ZS5kZWxlZ2F0ZVNpemUoKSxjPWUuaXNTZXRfMCgpLGQ+MClpZihuPW5ldyBRbmUoZS5iYXNpY0xpc3QoKSkscj1kLGk9cjwxMDA/bnVsbDpuZXcgZV8ociksX2IoZSxyLG4uZGF0YV8wKSxvPXI9PTE/ZS5jcmVhdGVOb3RpZmljYXRpb24oNCxPKG4sMCksbnVsbCwwLGMpOmUuY3JlYXRlTm90aWZpY2F0aW9uKDYsbixudWxsLC0xLGMpLGUuaGFzSW52ZXJzZSgpKXtmb3IodD1uZXcgWWUobik7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylpPWUuaW52ZXJzZVJlbW92ZShlbih0KSxpKTtpPyhpLmFkZF81KG8pLGkuZGlzcGF0Y2hfMCgpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKG8pfWVsc2UgaT8oaS5hZGRfNShvKSxpLmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbihvKTtlbHNlIF9iKGUsZS5kZWxlZ2F0ZVNpemUoKSxlLmRlbGVnYXRlVG9BcnJheSgpKSxlLmRpc3BhdGNoTm90aWZpY2F0aW9uKGUuY3JlYXRlTm90aWZpY2F0aW9uKDYsKE5lKCksT3QpLG51bGwsLTEsYykpO2Vsc2UgaWYoZS5oYXNJbnZlcnNlKCkpaWYoZD1lLmRlbGVnYXRlU2l6ZSgpLGQ+MCl7Zm9yKHU9ZS5kZWxlZ2F0ZVRvQXJyYXkoKSxfPWQsX2IoZSxkLHUpLGk9XzwxMDA/bnVsbDpuZXcgZV8oXyksdD0wO3Q8XzsrK3Qpcz11W3RdLGk9ZS5pbnZlcnNlUmVtb3ZlKHMsaSk7aSYmaS5kaXNwYXRjaF8wKCl9ZWxzZSBfYihlLGUuZGVsZWdhdGVTaXplKCksZS5kZWxlZ2F0ZVRvQXJyYXkoKSk7ZWxzZSBfYihlLGUuZGVsZWdhdGVTaXplKCksZS5kZWxlZ2F0ZVRvQXJyYXkoKSl9ZnVuY3Rpb24gbkdlKGUsbixyKXt2YXIgdCxvLGkscyx1O3JldHVybiBlLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQoKT8obz1udWxsLGk9ZS5pc1NldF8wKCksdD1lLmNyZWF0ZU5vdGlmaWNhdGlvbigxLHU9KHM9ZS5kZWxlZ2F0ZVNldChuLGUudmFsaWRhdGUobixyKSkscykscixuLGkpLGUuaGFzSW52ZXJzZSgpJiYhKGUudXNlRXF1YWxzKCkmJnU/WW4odSxyKTpEKHUpPT09RChyKSkmJih1JiYobz1lLmludmVyc2VSZW1vdmUodSxvKSksbz1lLmludmVyc2VBZGQocixvKSksbz8oby5hZGRfNSh0KSxvLmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbih0KSx1KToodT0ocz1lLmRlbGVnYXRlU2V0KG4sZS52YWxpZGF0ZShuLHIpKSxzKSxlLmhhc0ludmVyc2UoKSYmIShlLnVzZUVxdWFscygpJiZ1P1luKHUscik6RCh1KT09PUQocikpJiYobz1udWxsLHUmJihvPWUuaW52ZXJzZVJlbW92ZSh1LG51bGwpKSxvPWUuaW52ZXJzZUFkZChyLG8pLG8mJm8uZGlzcGF0Y2hfMCgpKSx1KX1wKDIwOTQsMjA5MyxQaWUpLGwuYWRkQWxsVW5pcXVlPWZ1bmN0aW9uKG4scil7cmV0dXJuIGNyZSh0aGlzLG4scil9LGwuYWRkQWxsVW5pcXVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYWRkQWxsVW5pcXVlKHRoaXMuZGVsZWdhdGVTaXplKCksbil9LGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7UUJlKHRoaXMsbixyKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXtlR2UodGhpcyxuKX0sbC5jYW5Db250YWluTnVsbD1mdW5jdGlvbigpe3JldHVybiF0aGlzLmhhc0ludmVyc2UoKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7aFModGhpcyl9LGwuY3JlYXRlTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyBsR2UodGhpcyxuLHIsdCxvLGkpfSxsLmRpc3BhdGNoTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4pe1huKHRoaXMuZ2V0Tm90aWZpZXIoKSxuKX0sbC5nZXRGZWF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZ2V0RmVhdHVyZUlEXzA9ZnVuY3Rpb24oKXtyZXR1cm4tMX0sbC5nZXROb3RpZmllcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pbnZlcnNlQWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIHJ9LGwuaW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiByfSxsLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuZGVsZWdhdGVJc0VtcHR5KCl9LGwubW92ZT1mdW5jdGlvbihuLHIpe3ZhciB0LG87cmV0dXJuIHRoaXMuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyhvPXRoaXMuaXNTZXRfMCgpLHQ9dXJlKHRoaXMsbixyKSx0aGlzLmRpc3BhdGNoTm90aWZpY2F0aW9uKHRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKDcsSihyKSx0LG4sbykpLHQpOnVyZSh0aGlzLG4scil9LGwucmVtb3ZlXzI9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGk7cmV0dXJuIHRoaXMuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyh0PW51bGwsbz10aGlzLmlzU2V0XzAoKSxyPXRoaXMuY3JlYXRlTm90aWZpY2F0aW9uKDQsaT1yTCh0aGlzLG4pLG51bGwsbixvKSx0aGlzLmhhc0ludmVyc2UoKSYmaT8odD10aGlzLmludmVyc2VSZW1vdmUoaSx0KSx0Pyh0LmFkZF81KHIpLHQuZGlzcGF0Y2hfMCgpKTp0aGlzLmRpc3BhdGNoTm90aWZpY2F0aW9uKHIpKTp0Pyh0LmFkZF81KHIpLHQuZGlzcGF0Y2hfMCgpKTp0aGlzLmRpc3BhdGNoTm90aWZpY2F0aW9uKHIpLGkpOihpPXJMKHRoaXMsbiksdGhpcy5oYXNJbnZlcnNlKCkmJmkmJih0PXRoaXMuaW52ZXJzZVJlbW92ZShpLG51bGwpLHQmJnQuZGlzcGF0Y2hfMCgpKSxpKX0sbC5zZXRVbmlxdWU9ZnVuY3Rpb24obixyKXtyZXR1cm4gbkdlKHRoaXMsbixyKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi5ub3RpZnkuaW1wbCIsIkRlbGVnYXRpbmdOb3RpZnlpbmdMaXN0SW1wbCIsMjA5NCk7ZnVuY3Rpb24gX3JlKGUsbil7cmV0dXJuIG4/ZS5tZXJnZV8wKG4pPyExOmUubmV4dF8wP2UubmV4dF8wLmFkZF81KG4pOkwobiwxNTIpPyhlLm5leHRfMD1hKG4sMTUyKSwhMCk6KGUubmV4dF8wPW5ldyB1R2UsZS5uZXh0XzAuYWRkXzUobikpOiExfWZ1bmN0aW9uIGhEKGUpe3ZhciBuO249ZS5nZXROb3RpZmllcigpLG4hPW51bGwmJmUuZXZlbnRUeXBlIT0tMSYmYShuLDk0KS5lTm90aWZ5KGUpLGUubmV4dF8wJiZlLm5leHRfMC5kaXNwYXRjaF8wKCl9ZnVuY3Rpb24gWFNuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9MCl0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIFIyKGUubmV3U2ltcGxlUHJpbWl0aXZlVmFsdWUsMCl9ZnVuY3Rpb24gSlNuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9MSl0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIFNuKGUubmV3U2ltcGxlUHJpbWl0aXZlVmFsdWUpPDwyND4+MjR9ZnVuY3Rpb24gWlNuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9Mil0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIFNuKGUubmV3U2ltcGxlUHJpbWl0aXZlVmFsdWUpJnpyfWZ1bmN0aW9uIFFTbihlKXtpZihlLnByaW1pdGl2ZVR5cGUhPTMpdGhyb3cgYihuZXcgemkpO3JldHVybiBlLm5ld0lFRUVQcmltaXRpdmVWYWx1ZX1mdW5jdGlvbiBlQ24oZSl7aWYoZS5wcmltaXRpdmVUeXBlIT00KXRocm93IGIobmV3IHppKTtyZXR1cm4gZS5uZXdJRUVFUHJpbWl0aXZlVmFsdWV9ZnVuY3Rpb24gbkNuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9NSl0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIFNuKGUubmV3U2ltcGxlUHJpbWl0aXZlVmFsdWUpfWZ1bmN0aW9uIHJDbihlKXtpZihlLnByaW1pdGl2ZVR5cGUhPTYpdGhyb3cgYihuZXcgemkpO3JldHVybiBlLm5ld1NpbXBsZVByaW1pdGl2ZVZhbHVlfWZ1bmN0aW9uIHRDbihlKXtpZihlLnByaW1pdGl2ZVR5cGUhPTcpdGhyb3cgYihuZXcgemkpO3JldHVybiBTbihlLm5ld1NpbXBsZVByaW1pdGl2ZVZhbHVlKTw8MTY+PjE2fWZ1bmN0aW9uIHJHZShlKXtpZihlLm5ld1ZhbHVlPT1udWxsKXN3aXRjaChlLnByaW1pdGl2ZVR5cGUpe2Nhc2UgMDplLm5ld1ZhbHVlPVhTbihlKT8oemUoKSxveSk6KHplKCksUzApO2JyZWFrO2Nhc2UgMTplLm5ld1ZhbHVlPUVDKEpTbihlKSk7YnJlYWs7Y2FzZSAyOmUubmV3VmFsdWU9dkMoWlNuKGUpKTticmVhaztjYXNlIDM6ZS5uZXdWYWx1ZT1RU24oZSk7YnJlYWs7Y2FzZSA0OmUubmV3VmFsdWU9bmV3IENDKGVDbihlKSk7YnJlYWs7Y2FzZSA2OmUubmV3VmFsdWU9ZWMockNuKGUpKTticmVhaztjYXNlIDU6ZS5uZXdWYWx1ZT1KKG5DbihlKSk7YnJlYWs7Y2FzZSA3OmUubmV3VmFsdWU9bHkodENuKGUpKX1yZXR1cm4gZS5uZXdWYWx1ZX1mdW5jdGlvbiBvQ24oZSl7aWYoZS5wcmltaXRpdmVUeXBlIT0wKXRocm93IGIobmV3IHppKTtyZXR1cm4gUjIoZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSwwKX1mdW5jdGlvbiBpQ24oZSl7aWYoZS5wcmltaXRpdmVUeXBlIT0xKXRocm93IGIobmV3IHppKTtyZXR1cm4gU24oZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSk8PDI0Pj4yNH1mdW5jdGlvbiBhQ24oZSl7aWYoZS5wcmltaXRpdmVUeXBlIT0yKXRocm93IGIobmV3IHppKTtyZXR1cm4gU24oZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSkmenJ9ZnVuY3Rpb24gbENuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9Myl0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIGUub2xkSUVFRVByaW1pdGl2ZVZhbHVlfWZ1bmN0aW9uIHNDbihlKXtpZihlLnByaW1pdGl2ZVR5cGUhPTQpdGhyb3cgYihuZXcgemkpO3JldHVybiBlLm9sZElFRUVQcmltaXRpdmVWYWx1ZX1mdW5jdGlvbiB1Q24oZSl7aWYoZS5wcmltaXRpdmVUeXBlIT01KXRocm93IGIobmV3IHppKTtyZXR1cm4gU24oZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSl9ZnVuY3Rpb24gY0NuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9Nil0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIGUub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWV9ZnVuY3Rpb24gX0NuKGUpe2lmKGUucHJpbWl0aXZlVHlwZSE9Nyl0aHJvdyBiKG5ldyB6aSk7cmV0dXJuIFNuKGUub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWUpPDwxNj4+MTZ9ZnVuY3Rpb24gZHJlKGUpe2lmKGUub2xkVmFsdWU9PW51bGwpc3dpdGNoKGUucHJpbWl0aXZlVHlwZSl7Y2FzZSAwOmUub2xkVmFsdWU9b0NuKGUpPyh6ZSgpLG95KTooemUoKSxTMCk7YnJlYWs7Y2FzZSAxOmUub2xkVmFsdWU9RUMoaUNuKGUpKTticmVhaztjYXNlIDI6ZS5vbGRWYWx1ZT12QyhhQ24oZSkpO2JyZWFrO2Nhc2UgMzplLm9sZFZhbHVlPWxDbihlKTticmVhaztjYXNlIDQ6ZS5vbGRWYWx1ZT1uZXcgQ0Moc0NuKGUpKTticmVhaztjYXNlIDY6ZS5vbGRWYWx1ZT1lYyhjQ24oZSkpO2JyZWFrO2Nhc2UgNTplLm9sZFZhbHVlPUoodUNuKGUpKTticmVhaztjYXNlIDc6ZS5vbGRWYWx1ZT1seShfQ24oZSkpfXJldHVybiBlLm9sZFZhbHVlfWZ1bmN0aW9uIHRHZShlKXtzd2l0Y2goZS5ldmVudFR5cGUpe2Nhc2UgOTpjYXNlIDg6cmV0dXJuITA7Y2FzZSAzOmNhc2UgNTpjYXNlIDQ6Y2FzZSA2OnJldHVybiExO2Nhc2UgNzpyZXR1cm4gYShkcmUoZSksMTcpLnZhbHVlXzA9PWUucG9zaXRpb247Y2FzZSAxOmNhc2UgMjp7aWYoZS5wb3NpdGlvbj09LTIpcmV0dXJuITE7c3dpdGNoKGUucHJpbWl0aXZlVHlwZSl7Y2FzZSAwOmNhc2UgMTpjYXNlIDI6Y2FzZSA2OmNhc2UgNTpjYXNlIDc6cmV0dXJuIFQxKGUub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWUsZS5uZXdTaW1wbGVQcmltaXRpdmVWYWx1ZSk7Y2FzZSAzOmNhc2UgNDpyZXR1cm4gZS5vbGRJRUVFUHJpbWl0aXZlVmFsdWU9PWUubmV3SUVFRVByaW1pdGl2ZVZhbHVlO2RlZmF1bHQ6cmV0dXJuIGUub2xkVmFsdWU9PW51bGw/ZS5uZXdWYWx1ZT09bnVsbDpZbihlLm9sZFZhbHVlLGUubmV3VmFsdWUpfX1kZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBmcmUoZSl7dmFyIG47c3dpdGNoKGUuZXZlbnRUeXBlKXtjYXNlIDE6e2lmKGUuaXNGZWF0dXJlVW5zZXR0YWJsZSgpKXJldHVybiBlLnBvc2l0aW9uIT0tMjticmVha31jYXNlIDI6e2lmKGUuaXNGZWF0dXJlVW5zZXR0YWJsZSgpKXJldHVybiBlLnBvc2l0aW9uPT0tMjticmVha31jYXNlIDM6Y2FzZSA1OmNhc2UgNDpjYXNlIDY6Y2FzZSA3OnJldHVybiBlLnBvc2l0aW9uPi0yO2RlZmF1bHQ6cmV0dXJuITF9c3dpdGNoKG49ZS5nZXRGZWF0dXJlRGVmYXVsdFZhbHVlKCksZS5wcmltaXRpdmVUeXBlKXtjYXNlIDA6cmV0dXJuIG4hPW51bGwmJmFlKGllKG4pKSE9UjIoZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSwwKTtjYXNlIDE6cmV0dXJuIG4hPW51bGwmJmEobiwyMjIpLnZhbHVlXzAhPVNuKGUub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWUpPDwyND4+MjQ7Y2FzZSAyOnJldHVybiBuIT1udWxsJiZhKG4sMTgwKS52YWx1ZV8wIT0oU24oZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSkmenIpO2Nhc2UgNjpyZXR1cm4gbiE9bnVsbCYmUjIoYShuLDE2OCkudmFsdWVfMCxlLm9sZFNpbXBsZVByaW1pdGl2ZVZhbHVlKTtjYXNlIDU6cmV0dXJuIG4hPW51bGwmJmEobiwxNykudmFsdWVfMCE9U24oZS5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZSk7Y2FzZSA3OnJldHVybiBuIT1udWxsJiZhKG4sMTkxKS52YWx1ZV8wIT1TbihlLm9sZFNpbXBsZVByaW1pdGl2ZVZhbHVlKTw8MTY+PjE2O2Nhc2UgMzpyZXR1cm4gbiE9bnVsbCYmUigkKG4pKSE9ZS5vbGRJRUVFUHJpbWl0aXZlVmFsdWU7Y2FzZSA0OnJldHVybiBuIT1udWxsJiZhKG4sMTYxKS52YWx1ZV8wIT1lLm9sZElFRUVQcmltaXRpdmVWYWx1ZTtkZWZhdWx0OnJldHVybiBuPT1udWxsP2Uub2xkVmFsdWUhPW51bGw6IVluKG4sZS5vbGRWYWx1ZSl9fWZ1bmN0aW9uIG9HZShlLG4scil7dGhpcy5ldmVudFR5cGU9ZSx0aGlzLm9sZElFRUVQcmltaXRpdmVWYWx1ZT1uLHRoaXMubmV3SUVFRVByaW1pdGl2ZVZhbHVlPXIsdGhpcy5wb3NpdGlvbj0tMSx0aGlzLnByaW1pdGl2ZVR5cGU9M31mdW5jdGlvbiBpR2UoZSxuLHIpe3RoaXMuZXZlbnRUeXBlPWUsdGhpcy5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZT1uLHRoaXMubmV3U2ltcGxlUHJpbWl0aXZlVmFsdWU9cix0aGlzLnBvc2l0aW9uPS0xLHRoaXMucHJpbWl0aXZlVHlwZT01fWZ1bmN0aW9uIHByZShlLG4scix0KXt0aGlzLmV2ZW50VHlwZT1lLHRoaXMub2xkVmFsdWU9bix0aGlzLm5ld1ZhbHVlPXIsdGhpcy5wb3NpdGlvbj10LHRoaXMucHJpbWl0aXZlVHlwZT0tMX1mdW5jdGlvbiBtRChlLG4scix0LG8pe3RoaXMuZXZlbnRUeXBlPWUsdGhpcy5vbGRWYWx1ZT1uLHRoaXMubmV3VmFsdWU9cix0aGlzLnBvc2l0aW9uPXQsdGhpcy5wcmltaXRpdmVUeXBlPS0xLG98fCh0aGlzLnBvc2l0aW9uPS0yLXQtMSl9ZnVuY3Rpb24gYUdlKGUsbixyKXt0aGlzLmV2ZW50VHlwZT1lLHRoaXMub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWU9bj8xOjAsdGhpcy5uZXdTaW1wbGVQcmltaXRpdmVWYWx1ZT1yPzE6MCx0aGlzLnBvc2l0aW9uPS0xLHRoaXMucHJpbWl0aXZlVHlwZT0wfXAoMTUyLDEsUVMpLGwuYWRkXzU9ZnVuY3Rpb24obil7cmV0dXJuIF9yZSh0aGlzLG4pfSxsLmRpc3BhdGNoXzA9ZnVuY3Rpb24oKXtoRCh0aGlzKX0sbC5nZXRFdmVudFR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFR5cGV9LGwuZ2V0RmVhdHVyZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldEZlYXR1cmVEZWZhdWx0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbC5nZXRGZWF0dXJlSUQ9ZnVuY3Rpb24obil7cmV0dXJuLTF9LGwuZ2V0TmV3VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gckdlKHRoaXMpfSxsLmdldE5vdGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZ2V0T2xkVmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gZHJlKHRoaXMpfSxsLmdldFBvc2l0aW9uXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbjwwP3RoaXMucG9zaXRpb248LTI/LTItdGhpcy5wb3NpdGlvbi0xOi0xOnRoaXMucG9zaXRpb259LGwuaXNGZWF0dXJlVW5zZXR0YWJsZT1mdW5jdGlvbigpe3JldHVybiExfSxsLm1lcmdlXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaDtzd2l0Y2godGhpcy5ldmVudFR5cGUpe2Nhc2UgMTpjYXNlIDI6c3dpdGNoKGk9bi5nZXRFdmVudFR5cGUoKSxpKXtjYXNlIDE6Y2FzZSAyOmlmKHM9bi5nZXROb3RpZmllcigpLEQocyk9PT1EKHRoaXMuZ2V0Tm90aWZpZXIoKSkmJnRoaXMuZ2V0RmVhdHVyZUlEKG51bGwpPT1uLmdldEZlYXR1cmVJRChudWxsKSlyZXR1cm4gdGhpcy5uZXdWYWx1ZT1uLmdldE5ld1ZhbHVlKCksbi5nZXRFdmVudFR5cGUoKT09MSYmKHRoaXMuZXZlbnRUeXBlPTEpLCEwfWNhc2UgNDp7c3dpdGNoKGk9bi5nZXRFdmVudFR5cGUoKSxpKXtjYXNlIDQ6e2lmKHM9bi5nZXROb3RpZmllcigpLEQocyk9PT1EKHRoaXMuZ2V0Tm90aWZpZXIoKSkmJnRoaXMuZ2V0RmVhdHVyZUlEKG51bGwpPT1uLmdldEZlYXR1cmVJRChudWxsKSlyZXR1cm4gZD1mcmUodGhpcyksXz10aGlzLnBvc2l0aW9uPDA/dGhpcy5wb3NpdGlvbjwtMj8tMi10aGlzLnBvc2l0aW9uLTE6LTE6dGhpcy5wb3NpdGlvbix1PW4uZ2V0UG9zaXRpb25fMCgpLHRoaXMuZXZlbnRUeXBlPTYsaD1uZXcgUGQoMiksXzw9dT8ocG4oaCx0aGlzLm9sZFZhbHVlKSxwbihoLG4uZ2V0T2xkVmFsdWUoKSksdGhpcy5uZXdWYWx1ZT1QKEkoaG4sMSksa24sMjgsMTUsW3RoaXMucG9zaXRpb249Xyx1KzFdKSk6KHBuKGgsbi5nZXRPbGRWYWx1ZSgpKSxwbihoLHRoaXMub2xkVmFsdWUpLHRoaXMubmV3VmFsdWU9UChJKGhuLDEpLGtuLDI4LDE1LFt0aGlzLnBvc2l0aW9uPXUsX10pKSx0aGlzLm9sZFZhbHVlPWgsZHx8KHRoaXMucG9zaXRpb249LTItdGhpcy5wb3NpdGlvbi0xKSwhMDticmVha319YnJlYWt9Y2FzZSA2Ontzd2l0Y2goaT1uLmdldEV2ZW50VHlwZSgpLGkpe2Nhc2UgNDp7aWYocz1uLmdldE5vdGlmaWVyKCksRChzKT09PUQodGhpcy5nZXROb3RpZmllcigpKSYmdGhpcy5nZXRGZWF0dXJlSUQobnVsbCk9PW4uZ2V0RmVhdHVyZUlEKG51bGwpKXtmb3IoZD1mcmUodGhpcyksdT1uLmdldFBvc2l0aW9uXzAoKSxmPWEodGhpcy5uZXdWYWx1ZSw1Myksbz1CKGhuLGtuLDI4LGYubGVuZ3RoKzEsMTUsMSkscj0wO3I8Zi5sZW5ndGgmJihjPWZbcl0sYzw9dSk7KW9bcisrXT1jLCsrdTtmb3IodD1hKHRoaXMub2xkVmFsdWUsMTUpLHQuYWRkXzMocixuLmdldE9sZFZhbHVlKCkpLG9bcl09dTsrK3I8by5sZW5ndGg7KW9bcl09ZltyLTFdO3JldHVybiB0aGlzLm5ld1ZhbHVlPW8sZHx8KHRoaXMucG9zaXRpb249LTItb1swXSksITB9YnJlYWt9fWJyZWFrfX1yZXR1cm4hMX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scix0LG87c3dpdGNoKG89bmV3IHlsKHlfKHRoaXMuX19fY2xhenopKyJAIisocj11cih0aGlzKT4+PjAsci50b1N0cmluZygxNikpKSxvLnN0cmluZys9IiAoZXZlbnRUeXBlOiAiLHRoaXMuZXZlbnRUeXBlKXtjYXNlIDE6e28uc3RyaW5nKz0iU0VUIjticmVha31jYXNlIDI6e28uc3RyaW5nKz0iVU5TRVQiO2JyZWFrfWNhc2UgMzp7by5zdHJpbmcrPSJBREQiO2JyZWFrfWNhc2UgNTp7by5zdHJpbmcrPSJBRERfTUFOWSI7YnJlYWt9Y2FzZSA0OntvLnN0cmluZys9IlJFTU9WRSI7YnJlYWt9Y2FzZSA2OntvLnN0cmluZys9IlJFTU9WRV9NQU5ZIjticmVha31jYXNlIDc6e28uc3RyaW5nKz0iTU9WRSI7YnJlYWt9Y2FzZSA4OntvLnN0cmluZys9IlJFTU9WSU5HX0FEQVBURVIiO2JyZWFrfWNhc2UgOTp7by5zdHJpbmcrPSJSRVNPTFZFIjticmVha31kZWZhdWx0OntENShvLHRoaXMuZXZlbnRUeXBlKTticmVha319aWYodEdlKHRoaXMpJiYoby5zdHJpbmcrPSIsIHRvdWNoOiB0cnVlIiksby5zdHJpbmcrPSIsIHBvc2l0aW9uOiAiLEQ1KG8sdGhpcy5wb3NpdGlvbjwwP3RoaXMucG9zaXRpb248LTI/LTItdGhpcy5wb3NpdGlvbi0xOi0xOnRoaXMucG9zaXRpb24pLG8uc3RyaW5nKz0iLCBub3RpZmllcjogIiwkMihvLHRoaXMuZ2V0Tm90aWZpZXIoKSksby5zdHJpbmcrPSIsIGZlYXR1cmU6ICIsJDIobyx0aGlzLmdldEZlYXR1cmUoKSksby5zdHJpbmcrPSIsIG9sZFZhbHVlOiAiLCQyKG8sZHJlKHRoaXMpKSxvLnN0cmluZys9IiwgbmV3VmFsdWU6ICIsdGhpcy5ldmVudFR5cGU9PTYmJkwodGhpcy5uZXdWYWx1ZSw1Mykpe2Zvcih0PWEodGhpcy5uZXdWYWx1ZSw1Myksby5zdHJpbmcrPSJbIixuPTA7bjx0Lmxlbmd0aDspby5zdHJpbmcrPXRbbl0sKytuPHQubGVuZ3RoJiYoby5zdHJpbmcrPSIsICIpO28uc3RyaW5nKz0iXSJ9ZWxzZSAkMihvLHJHZSh0aGlzKSk7cmV0dXJuIG8uc3RyaW5nKz0iLCBpc1RvdWNoOiAiLEFjKG8sdEdlKHRoaXMpKSxvLnN0cmluZys9Iiwgd2FzU2V0OiAiLEFjKG8sZnJlKHRoaXMpKSxvLnN0cmluZys9IikiLG8uc3RyaW5nfSxsLmV2ZW50VHlwZT0wLGwubmV3SUVFRVByaW1pdGl2ZVZhbHVlPTAsbC5uZXdTaW1wbGVQcmltaXRpdmVWYWx1ZT0wLGwub2xkSUVFRVByaW1pdGl2ZVZhbHVlPTAsbC5vbGRTaW1wbGVQcmltaXRpdmVWYWx1ZT0wLGwucG9zaXRpb249MCxsLnByaW1pdGl2ZVR5cGU9MCxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLm5vdGlmeS5pbXBsIiwiTm90aWZpY2F0aW9uSW1wbCIsMTUyKTtmdW5jdGlvbiBsR2UoZSxuLHIsdCxvLGkpe3RoaXMudGhpcyQwMT1lLG1ELmNhbGwodGhpcyxuLHIsdCxvLGkpfXAoMTE4OCwxNTIsUVMsbEdlKSxsLmdldEZlYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLmdldEZlYXR1cmUoKX0sbC5nZXRGZWF0dXJlSUQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMudGhpcyQwMS5nZXRGZWF0dXJlSURfMCgpfSxsLmdldE5vdGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5nZXROb3RpZmllcigpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLm5vdGlmeS5pbXBsIiwiRGVsZWdhdGluZ05vdGlmeWluZ0xpc3RJbXBsLzEiLDExODgpO2Z1bmN0aW9uIHNHZShlLG4pe3ZhciByLHQ7aWYobil7Zm9yKHI9MDtyPGUuc2l6ZV8wOysrcilpZih0PWEoZS5kYXRhXzBbcl0sMzc4KSx0Lm1lcmdlXzAobikpcmV0dXJuITE7cmV0dXJuIHBuKGUsbil9ZWxzZSByZXR1cm4hMX1mdW5jdGlvbiB1R2UoKXt9ZnVuY3Rpb24gZV8oZSl7UGQuY2FsbCh0aGlzLGUpfXAoMjUxLDY2LGV1LHVHZSxlXyksbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gc0dlKHRoaXMsYShuLDM3OCkpfSxsLmFkZF81PWZ1bmN0aW9uKG4pe3JldHVybiBzR2UodGhpcyxuKX0sbC5kaXNwYXRjaF8wPWZ1bmN0aW9uKCl7dmFyIG4scix0O2ZvcihuPTA7bjx0aGlzLnNpemVfMDsrK24pcj1hKHRoaXMuZGF0YV8wW25dLDM3OCksdD1yLmdldE5vdGlmaWVyKCksdCE9bnVsbCYmci5nZXRFdmVudFR5cGUoKSE9LTEmJmEodCw5NCkuZU5vdGlmeShyKX0sbC5uZXdEYXRhPWZ1bmN0aW9uKG4pe3JldHVybiBCKHFTbixNZSwzNzgsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLm5vdGlmeS5pbXBsIiwiTm90aWZpY2F0aW9uQ2hhaW5JbXBsIiwyNTEpLHAoMTUyNCw5MyxJaWUpLGwuZUJhc2ljQWRhcHRlcnM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQWRhcHRlcnN9LGwuZURlbGl2ZXI9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5lRmxhZ3MmMSkhPTB9LGwuZUZsYWdzPTEsZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi5ub3RpZnkuaW1wbCIsIk5vdGlmaWVySW1wbCIsMTUyNCk7ZnVuY3Rpb24geUQoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7aWYodD1yLnNpemVfMSgpLHQ9PTApcmV0dXJuITE7aWYoZS5pc05vdGlmaWNhdGlvblJlcXVpcmVkKCkpaWYoXz1lLmlzU2V0XzAoKSxfRChlLG4scikscz10PT0xP2UuY3JlYXRlTm90aWZpY2F0aW9uKDMsbnVsbCxyLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSxuLF8pOmUuY3JlYXRlTm90aWZpY2F0aW9uKDUsbnVsbCxyLG4sXyksZS5oYXNJbnZlcnNlKCkpe2Zvcih1PXQ8MTAwP251bGw6bmV3IGVfKHQpLGk9bit0LG89bjtvPGk7KytvKWQ9ZS5kYXRhXzBbb10sdT1lLmludmVyc2VBZGQoZCx1KSx1PWUuc2hhZG93QWRkKGQsdSk7dT8odS5hZGRfNShzKSx1LmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbihzKX1lbHNlIGUuZGlzcGF0Y2hOb3RpZmljYXRpb24ocyk7ZWxzZSBpZihfRChlLG4sciksZS5oYXNJbnZlcnNlKCkpe2Zvcih1PXQ8MTAwP251bGw6bmV3IGVfKHQpLGk9bit0LG89bjtvPGk7KytvKWM9ZS5kYXRhXzBbb10sdT1lLmludmVyc2VBZGQoYyx1KTt1JiZ1LmRpc3BhdGNoXzAoKX1yZXR1cm4hMH1mdW5jdGlvbiBncmUoZSxuLHIpe3ZhciB0LG8saTtlLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQoKT8oaT1lLmlzU2V0XzAoKSxsYihlLG4sciksdD1lLmNyZWF0ZU5vdGlmaWNhdGlvbigzLG51bGwscixuLGkpLGUuaGFzSW52ZXJzZSgpPyhvPWUuaW52ZXJzZUFkZChyLG51bGwpLGUuaGFzU2hhZG93KCkmJihvPWUuc2hhZG93QWRkKHIsbykpLG8/KG8uYWRkXzUodCksby5kaXNwYXRjaF8wKCkpOmUuZGlzcGF0Y2hOb3RpZmljYXRpb24odCkpOmUuZGlzcGF0Y2hOb3RpZmljYXRpb24odCkpOihsYihlLG4sciksZS5oYXNJbnZlcnNlKCkmJihvPWUuaW52ZXJzZUFkZChyLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpKSl9ZnVuY3Rpb24gd0QoZSxuKXt2YXIgcix0LG8saTtlLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQoKT8ocj1lLnNpemVfMCxpPWUuaXNTZXRfMCgpLHNiKGUsbiksdD1lLmNyZWF0ZU5vdGlmaWNhdGlvbigzLG51bGwsbixyLGkpLGUuaGFzSW52ZXJzZSgpPyhvPWUuaW52ZXJzZUFkZChuLG51bGwpLGUuaGFzU2hhZG93KCkmJihvPWUuc2hhZG93QWRkKG4sbykpLG8/KG8uYWRkXzUodCksby5kaXNwYXRjaF8wKCkpOmUuZGlzcGF0Y2hOb3RpZmljYXRpb24odCkpOmUuZGlzcGF0Y2hOb3RpZmljYXRpb24odCkpOihzYihlLG4pLGUuaGFzSW52ZXJzZSgpJiYobz1lLmludmVyc2VBZGQobixudWxsKSxvJiZvLmRpc3BhdGNoXzAoKSkpfWZ1bmN0aW9uIGhpKGUsbixyKXt2YXIgdCxvLGk7cmV0dXJuIGUuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyh0PWUuc2l6ZV8wLGk9ZS5pc1NldF8wKCksbGIoZSx0LG4pLG89ZS5jcmVhdGVOb3RpZmljYXRpb24oMyxudWxsLG4sdCxpKSxyP3IuYWRkXzUobyk6cj1vKTpsYihlLGUuc2l6ZV8wLG4pLHJ9ZnVuY3Rpb24gRHQoZSxuLHIpe3ZhciB0LG8saSxzO3JldHVybiB0PWUuaW5kZXhPZl8wKG4pLHQhPS0xJiYoZS5pc05vdGlmaWNhdGlvblJlcXVpcmVkKCk/KGk9ZS5pc1NldF8wKCkscz12bShlLHQpLG89ZS5jcmVhdGVOb3RpZmljYXRpb24oNCxzLG51bGwsdCxpKSxyP3IuYWRkXzUobyk6cj1vKTp2bShlLHQpKSxyfWZ1bmN0aW9uIGZuKGUpe3ZhciBuLHIsdCxvLGkscyx1LGMsXztpZihlLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQoKSlpZihjPWUuaXNTZXRfMCgpLGUuc2l6ZV8wPjApe2lmKG49bmV3IG1yZShlLnNpemVfMCxlLmRhdGFfMCkscj1lLnNpemVfMCxpPXI8MTAwP251bGw6bmV3IGVfKHIpLGUuaGFzU2hhZG93KCkpZm9yKHQ9MDt0PGUuc2l6ZV8wOysrdClzPWUuZGF0YV8wW3RdLGk9ZS5zaGFkb3dSZW1vdmUocyxpKTtpZihnUyhlKSxvPXI9PTE/ZS5jcmVhdGVOb3RpZmljYXRpb24oNCxPKG4sMCksbnVsbCwwLGMpOmUuY3JlYXRlTm90aWZpY2F0aW9uKDYsbixudWxsLC0xLGMpLGUuaGFzSW52ZXJzZSgpKXtmb3IodD1uZXcgQ20obik7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylpPWUuaW52ZXJzZVJlbW92ZSh2RCh0KSxpKTtpPyhpLmFkZF81KG8pLGkuZGlzcGF0Y2hfMCgpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKG8pfWVsc2UgaT8oaS5hZGRfNShvKSxpLmRpc3BhdGNoXzAoKSk6ZS5kaXNwYXRjaE5vdGlmaWNhdGlvbihvKX1lbHNlIGdTKGUpLGUuZGlzcGF0Y2hOb3RpZmljYXRpb24oZS5jcmVhdGVOb3RpZmljYXRpb24oNiwoTmUoKSxPdCksbnVsbCwtMSxjKSk7ZWxzZSBpZihlLmhhc0ludmVyc2UoKSlpZihlLnNpemVfMD4wKXtmb3IodT1lLmRhdGFfMCxfPWUuc2l6ZV8wLGdTKGUpLGk9XzwxMDA/bnVsbDpuZXcgZV8oXyksdD0wO3Q8XzsrK3Qpcz11W3RdLGk9ZS5pbnZlcnNlUmVtb3ZlKHMsaSk7aSYmaS5kaXNwYXRjaF8wKCl9ZWxzZSBnUyhlKTtlbHNlIGdTKGUpfWZ1bmN0aW9uIGRDbihlKXtyZXR1cm4gZTwxMDA/bnVsbDpuZXcgZV8oZSl9ZnVuY3Rpb24gbVMoZSxuLHIpe3ZhciB0LG87cmV0dXJuIGUuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyhvPWUuaXNTZXRfMCgpLHQ9ZEQoZSxuLHIpLGUuZGlzcGF0Y2hOb3RpZmljYXRpb24oZS5jcmVhdGVOb3RpZmljYXRpb24oNyxKKHIpLHQsbixvKSksdCk6ZEQoZSxuLHIpfWZ1bmN0aW9uIFpmKGUsbil7dmFyIHIsdCxvLGk7cmV0dXJuIGUuaXNOb3RpZmljYXRpb25SZXF1aXJlZCgpPyh0PW51bGwsbz1lLmlzU2V0XzAoKSxlLmhhc1NoYWRvdygpJiYodD1lLnNoYWRvd1JlbW92ZShlLmJhc2ljR2V0KG4pLG51bGwpKSxyPWUuY3JlYXRlTm90aWZpY2F0aW9uKDQsaT12bShlLG4pLG51bGwsbixvKSxlLmhhc0ludmVyc2UoKSYmaSE9bnVsbCYmKHQ9ZS5pbnZlcnNlUmVtb3ZlKGksdCkpLHQ/KHQuYWRkXzUociksdC5kaXNwYXRjaF8wKCkpOmUuZGlzcGF0Y2hOb3RpZmljYXRpb24ociksaSk6KGk9dm0oZSxuKSxlLmhhc0ludmVyc2UoKSYmaSE9bnVsbCYmKHQ9ZS5pbnZlcnNlUmVtb3ZlKGksbnVsbCksdCYmdC5kaXNwYXRjaF8wKCkpLGkpfWZ1bmN0aW9uIGNHZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5LEUsdix4LEEsayxNO2lmKEU9ZS5zaXplXzAhPTAsaz0hMSx4PW51bGwsVGEoZS5vd25lcikpe2lmKGQ9bi5zaXplXzEoKSxkPjApe2ZvcihoPWQ8MTAwP251bGw6bmV3IGVfKGQpLF89bmV3IFFuZShuKSx5PV8uZGF0YV8wLHg9QihobixrbiwyOCxkLDE1LDEpLHQ9MCxNPW5ldyBQZChkKSxvPTA7bzxlLnNpemVfMDsrK28pe3U9ZS5kYXRhXzBbb10sbT11O2U6Zm9yKEE9MDtBPDI7KytBKXtmb3IoYz1kOy0tYz49MDspaWYobSE9bnVsbD9ZbihtLHlbY10pOkQobSk9PT1EKHlbY10pKXt4Lmxlbmd0aDw9dCYmKHY9eCx4PUIoaG4sa24sMjgsMip4Lmxlbmd0aCwxNSwxKSxYbyh2LDAseCwwLHQpKSx4W3QrK109byxwbihNLHlbY10pO2JyZWFrIGV9aWYobT1tLEQobSk9PT1EKHUpKWJyZWFrfX1pZihfPU0seT1NLmRhdGFfMCxkPXQsdD54Lmxlbmd0aCYmKHY9eCx4PUIoaG4sa24sMjgsdCwxNSwxKSxYbyh2LDAseCwwLHQpKSx0PjApe2ZvcihrPSEwLGk9MDtpPHQ7KytpKW09eVtpXSxoPVlqZShlLGEobSw3NiksaCk7Zm9yKHM9dDstLXM+PTA7KXZtKGUseFtzXSk7aWYodCE9ZCl7Zm9yKG89ZDstLW8+PXQ7KXZtKF8sbyk7dj14LHg9QihobixrbiwyOCx0LDE1LDEpLFhvKHYsMCx4LDAsdCl9bj1ffX19ZWxzZSBmb3Iobj1CU24oZSxuKSxvPWUuc2l6ZV8wOy0tbz49MDspbi5jb250YWlucyhlLmRhdGFfMFtvXSkmJih2bShlLG8pLGs9ITApO2lmKGspe2lmKHghPW51bGwpe2ZvcihyPW4uc2l6ZV8xKCksZj1yPT0xP0NTKGUsNCxuLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSxudWxsLHhbMF0sRSk6Q1MoZSw2LG4seCx4WzBdLEUpLGg9cjwxMDA/bnVsbDpuZXcgZV8ociksbz1uLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyltPW8ubmV4dF8xKCksaD1pb2UoZSxhKG0sNzYpLGgpO2g/KGguYWRkXzUoZiksaC5kaXNwYXRjaF8wKCkpOlhuKGUub3duZXIsZil9ZWxzZXtmb3IoaD1kQ24obi5zaXplXzEoKSksbz1uLml0ZXJhdG9yXzAoKTtvLmhhc05leHRfMCgpOyltPW8ubmV4dF8xKCksaD1pb2UoZSxhKG0sNzYpLGgpO2gmJmguZGlzcGF0Y2hfMCgpfXJldHVybiEwfWVsc2UgcmV0dXJuITF9ZnVuY3Rpb24gX0dlKGUsbixyKXt2YXIgdCxvLGkscztyZXR1cm4gZS5pc05vdGlmaWNhdGlvblJlcXVpcmVkKCk/KG89bnVsbCxpPWUuaXNTZXRfMCgpLHQ9ZS5jcmVhdGVOb3RpZmljYXRpb24oMSxzPWZEKGUsbixyKSxyLG4saSksZS5oYXNJbnZlcnNlKCkmJiEoZS51c2VFcXVhbHMoKSYmcyE9bnVsbD9ZbihzLHIpOkQocyk9PT1EKHIpKT8ocyE9bnVsbCYmKG89ZS5pbnZlcnNlUmVtb3ZlKHMsbykpLG89ZS5pbnZlcnNlQWRkKHIsbyksZS5oYXNTaGFkb3coKSYmKG89ZS5zaGFkb3dTZXQocyxyLG8pKSxvPyhvLmFkZF81KHQpLG8uZGlzcGF0Y2hfMCgpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKHQpKTooZS5oYXNTaGFkb3coKSYmKG89ZS5zaGFkb3dTZXQocyxyLG8pKSxvPyhvLmFkZF81KHQpLG8uZGlzcGF0Y2hfMCgpKTplLmRpc3BhdGNoTm90aWZpY2F0aW9uKHQpKSxzKToocz1mRChlLG4sciksZS5oYXNJbnZlcnNlKCkmJiEoZS51c2VFcXVhbHMoKSYmcyE9bnVsbD9ZbihzLHIpOkQocyk9PT1EKHIpKSYmKG89bnVsbCxzIT1udWxsJiYobz1lLmludmVyc2VSZW1vdmUocyxudWxsKSksbz1lLmludmVyc2VBZGQocixvKSxvJiZvLmRpc3BhdGNoXzAoKSkscyl9cCgyMDkxLDY2LGV1KSxsLmFkZEFsbFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiB5RCh0aGlzLG4scil9LGwuYWRkQWxsVW5pcXVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYWRkQWxsVW5pcXVlKHRoaXMuc2l6ZV8wLG4pfSxsLmFkZFVuaXF1ZT1mdW5jdGlvbihuLHIpe2dyZSh0aGlzLG4scil9LGwuYWRkVW5pcXVlXzA9ZnVuY3Rpb24obil7d0QodGhpcyxuKX0sbC5jYW5Db250YWluTnVsbD1mdW5jdGlvbigpe3JldHVybiF0aGlzLmhhc0ludmVyc2UoKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7Zm4odGhpcyl9LGwuY3JlYXRlTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyBkR2UodGhpcyxuLHIsdCxvLGkpfSxsLmRpc3BhdGNoTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4pe1huKHRoaXMuZ2V0Tm90aWZpZXIoKSxuKX0sbC5nZXRGZWF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZ2V0RmVhdHVyZUlEXzA9ZnVuY3Rpb24oKXtyZXR1cm4tMX0sbC5nZXROb3RpZmllcj1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5oYXNTaGFkb3c9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pbnZlcnNlQWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIHJ9LGwuaW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiByfSxsLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wIT0wfSxsLm1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gbVModGhpcyxuLHIpfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiBaZih0aGlzLG4pfSxsLnNldFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiBfR2UodGhpcyxuLHIpfSxsLnNoYWRvd0FkZD1mdW5jdGlvbihuLHIpe3JldHVybiByfSxsLnNoYWRvd1JlbW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiByfSxsLnNoYWRvd1NldD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIHR9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24ubm90aWZ5LmltcGwiLCJOb3RpZnlpbmdMaXN0SW1wbCIsMjA5MSk7ZnVuY3Rpb24gZEdlKGUsbixyLHQsbyxpKXt0aGlzLnRoaXMkMDE9ZSxtRC5jYWxsKHRoaXMsbixyLHQsbyxpKX1wKDExODcsMTUyLFFTLGRHZSksbC5nZXRGZWF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5nZXRGZWF0dXJlKCl9LGwuZ2V0RmVhdHVyZUlEPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnRoaXMkMDEuZ2V0RmVhdHVyZUlEXzAoKX0sbC5nZXROb3RpZmllcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuZ2V0Tm90aWZpZXIoKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi5ub3RpZnkuaW1wbCIsIk5vdGlmeWluZ0xpc3RJbXBsLzEiLDExODcpO2Z1bmN0aW9uIGZHZShlLG4pe3RoaXMudGhpcyQwMT1lLFBkLmNhbGwodGhpcyxuKX1wKDk2Niw2NixldSxmR2UpLGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuc2l6ZV8wPjEwPygoIXRoaXMuc2V0XzB8fHRoaXMudGhpcyQwMS5tb2RDb3VudCE9dGhpcy5leHBlY3RlZE1vZENvdW50KSYmKHRoaXMuc2V0XzA9bmV3IG5FKHRoaXMpLHRoaXMuZXhwZWN0ZWRNb2RDb3VudD10aGlzLm1vZENvdW50KSxzcyh0aGlzLnNldF8wLG4pKTpXdyh0aGlzLG4pfSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiEwfSxsLmV4cGVjdGVkTW9kQ291bnQ9MCxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJBYnN0cmFjdEVMaXN0LzEiLDk2Nik7ZnVuY3Rpb24gUWYoZSxuKXtuby5jYWxsKHRoaXMsImluZGV4PSIrZSsiLCBzaXplPSIrbil9cCgzMDIsNzcsaTYsUWYpLGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkFic3RyYWN0RUxpc3QvQmFzaWNJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIiwzMDIpO2Z1bmN0aW9uIGVuKGUpe3ZhciBuO3RyeXtyZXR1cm4gbj1lLnRoaXMkMDFfMi5nZXRfMChlLmN1cnNvciksZS5jaGVja01vZENvdW50KCksZS5sYXN0Q3Vyc29yPWUuY3Vyc29yKyssbn1jYXRjaChyKXt0aHJvdyByPXdyKHIpLEwociw3Nyk/KGUuY2hlY2tNb2RDb3VudCgpLGIobmV3IFBvKSk6YihyKX19ZnVuY3Rpb24geVMoZSl7aWYoZS5sYXN0Q3Vyc29yPT0tMSl0aHJvdyBiKG5ldyB6aSk7ZS5jaGVja01vZENvdW50KCk7dHJ5e2UudGhpcyQwMV8yLnJlbW92ZV8yKGUubGFzdEN1cnNvciksZS5leHBlY3RlZE1vZENvdW50PWUudGhpcyQwMV8yLm1vZENvdW50LGUubGFzdEN1cnNvcjxlLmN1cnNvciYmLS1lLmN1cnNvcixlLmxhc3RDdXJzb3I9LTF9Y2F0Y2gobil7dGhyb3cgbj13cihuKSxMKG4sNzcpP2IobmV3IFhhKTpiKG4pfX1mdW5jdGlvbiBZZShlKXt0aGlzLnRoaXMkMDFfMj1lLHRoaXMuZXhwZWN0ZWRNb2RDb3VudD10aGlzLnRoaXMkMDFfMi5tb2RDb3VudH1wKDM3LDEsc3QsWWUpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmNoZWNrTW9kQ291bnQ9ZnVuY3Rpb24oKXtpZih0aGlzLnRoaXMkMDFfMi5tb2RDb3VudCE9dGhpcy5leHBlY3RlZE1vZENvdW50KXRocm93IGIobmV3IFhhKX0sbC5kb05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gZW4odGhpcyl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3Vyc29yIT10aGlzLnRoaXMkMDFfMi5zaXplXzEoKX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb05leHQoKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt5Uyh0aGlzKX0sbC5jdXJzb3I9MCxsLmV4cGVjdGVkTW9kQ291bnQ9MCxsLmxhc3RDdXJzb3I9LTEsZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQWJzdHJhY3RFTGlzdC9FSXRlcmF0b3IiLDM3KTtmdW5jdGlvbiBwR2UoZSxuKXtlLmNoZWNrTW9kQ291bnQoKTt0cnl7ZS50aGlzJDAxXzEuYWRkXzMoZS5jdXJzb3IrKyxuKSxlLmV4cGVjdGVkTW9kQ291bnQ9ZS50aGlzJDAxXzEubW9kQ291bnQsZS5sYXN0Q3Vyc29yPS0xfWNhdGNoKHIpe3Rocm93IHI9d3IociksTChyLDc3KT9iKG5ldyBYYSk6YihyKX19ZnVuY3Rpb24gZ0dlKGUsbil7aWYoZS5sYXN0Q3Vyc29yPT0tMSl0aHJvdyBiKG5ldyB6aSk7ZS5jaGVja01vZENvdW50KCk7dHJ5e2UudGhpcyQwMV8xLnNldF8yKGUubGFzdEN1cnNvcixuKSxlLmV4cGVjdGVkTW9kQ291bnQ9ZS50aGlzJDAxXzEubW9kQ291bnR9Y2F0Y2gocil7dGhyb3cgcj13cihyKSxMKHIsNzcpP2IobmV3IFhhKTpiKHIpfX1mdW5jdGlvbiBTbShlKXt0aGlzLnRoaXMkMDFfMT1lLFllLmNhbGwodGhpcyxlKX1mdW5jdGlvbiBFRChlLG4pe3RoaXMudGhpcyQwMV8xPWUsWWUuY2FsbCh0aGlzLGUpLHRoaXMuY3Vyc29yPW59cCgyODYsMzcsQ3UsU20sRUQpLGwucmVtb3ZlPWZ1bmN0aW9uKCl7eVModGhpcyl9LGwuYWRkXzE9ZnVuY3Rpb24obil7cEdlKHRoaXMsbil9LGwuZG9QcmV2aW91cz1mdW5jdGlvbigpe3ZhciBuO3RyeXtyZXR1cm4gbj10aGlzLnRoaXMkMDFfMS5nZXRfMCgtLXRoaXMuY3Vyc29yKSx0aGlzLmNoZWNrTW9kQ291bnQoKSx0aGlzLmxhc3RDdXJzb3I9dGhpcy5jdXJzb3Isbn1jYXRjaChyKXt0aHJvdyByPXdyKHIpLEwociw3Nyk/KHRoaXMuY2hlY2tNb2RDb3VudCgpLGIobmV3IFBvKSk6YihyKX19LGwuZG9TZXQ9ZnVuY3Rpb24obil7Z0dlKHRoaXMsbil9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJzb3IhPTB9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJzb3J9LGwucHJldmlvdXNfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRvUHJldmlvdXMoKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3Vyc29yLTF9LGwuc2V0XzE9ZnVuY3Rpb24obil7dGhpcy5kb1NldChuKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQWJzdHJhY3RFTGlzdC9FTGlzdEl0ZXJhdG9yIiwyODYpO2Z1bmN0aW9uIHZEKGUpe3ZhciBuO3RyeXtyZXR1cm4gbj1lLnRoaXMkMDFfMC5wcmltaXRpdmVHZXQoZS5jdXJzb3IpLGUuY2hlY2tNb2RDb3VudCgpLGUubGFzdEN1cnNvcj1lLmN1cnNvcisrLG59Y2F0Y2gocil7dGhyb3cgcj13cihyKSxMKHIsNzcpPyhlLmNoZWNrTW9kQ291bnQoKSxiKG5ldyBQbykpOmIocil9fWZ1bmN0aW9uIENtKGUpe3RoaXMudGhpcyQwMV8wPWUsWWUuY2FsbCh0aGlzLGUpfXAoMzU1LDM3LHN0LENtKSxsLmRvTmV4dD1mdW5jdGlvbigpe3JldHVybiB2RCh0aGlzKX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkFic3RyYWN0RUxpc3QvTm9uUmVzb2x2aW5nRUl0ZXJhdG9yIiwzNTUpO2Z1bmN0aW9uIGRiKGUpe3RoaXMudGhpcyQwMV8wPWUsU20uY2FsbCh0aGlzLGUpfWZ1bmN0aW9uIGhyZShlLG4pe3RoaXMudGhpcyQwMV8wPWUsRUQuY2FsbCh0aGlzLGUsbil9cCgzOTgsMjg2LEN1LGRiLGhyZSksbC5hZGRfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuZG9OZXh0PWZ1bmN0aW9uKCl7dmFyIG47dHJ5e3JldHVybiBuPXRoaXMudGhpcyQwMV8wLnByaW1pdGl2ZUdldCh0aGlzLmN1cnNvciksdGhpcy5jaGVja01vZENvdW50KCksdGhpcy5sYXN0Q3Vyc29yPXRoaXMuY3Vyc29yKyssbn1jYXRjaChyKXt0aHJvdyByPXdyKHIpLEwociw3Nyk/KHRoaXMuY2hlY2tNb2RDb3VudCgpLGIobmV3IFBvKSk6YihyKX19LGwuZG9QcmV2aW91cz1mdW5jdGlvbigpe3ZhciBuO3RyeXtyZXR1cm4gbj10aGlzLnRoaXMkMDFfMC5wcmltaXRpdmVHZXQoLS10aGlzLmN1cnNvciksdGhpcy5jaGVja01vZENvdW50KCksdGhpcy5sYXN0Q3Vyc29yPXRoaXMuY3Vyc29yLG59Y2F0Y2gocil7dGhyb3cgcj13cihyKSxMKHIsNzcpPyh0aGlzLmNoZWNrTW9kQ291bnQoKSxiKG5ldyBQbykpOmIocil9fSxsLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sbC5zZXRfMT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkFic3RyYWN0RUxpc3QvTm9uUmVzb2x2aW5nRUxpc3RJdGVyYXRvciIsMzk4KTtmdW5jdGlvbiBmYihlLG4pe3ZhciByO3JldHVybiByPWEoS2UoKGFMKCksbEwpLGUpLDU3KSxyP3IubmV3QXJyYXlJbnN0YW5jZShuKTpCKFFyLE1lLDEsbiw1LDEpfWZ1bmN0aW9uIGhHZSgpe2hHZT1GLHlHZT1CKFFyLE1lLDEsMCw1LDEpfWZ1bmN0aW9uIFNEKGUsbixyKXtyZXR1cm4gVHIoZSxuLHIpLHJ9ZnVuY3Rpb24gbUdlKGUpe3ZhciBuLHI7cmV0dXJuIG49YShCZShlLnRoaXMkMDEsNCksMTI5KSxuIT1udWxsPyhyPUIoZ0QseTYsNDI0LG4ubGVuZ3RoLDAsMSksWG8obiwwLHIsMCxuLmxlbmd0aCkscik6eUdlfWZ1bmN0aW9uIENEKGUsbil7dmFyIHIsdDtyZXR1cm4gdD1hKEJlKGUudGhpcyQwMSw0KSwxMjkpLHI9QihnRCx5Niw0MjQsbiwwLDEpLHQhPW51bGwmJlhvKHQsMCxyLDAsdC5sZW5ndGgpLHJ9ZnVuY3Rpb24gZkNuKGUsbil7dmFyIHIsdCxvLGkscztpZihyPWEoQmUoZS50aGlzJDAxLDQpLDEyOSkscz1yPT1udWxsPzA6ci5sZW5ndGgsbj49cyl0aHJvdyBiKG5ldyBRZihuLHMpKTtyZXR1cm4gbz1yW25dLHM9PTE/dD1udWxsOih0PUIoZ0QseTYsNDI0LHMtMSwwLDEpLFhvKHIsMCx0LDAsbiksaT1zLW4tMSxpPjAmJlhvKHIsbisxLHQsbixpKSksczIoZSx0KSxQamUoZSxuLG8pLG99cCgyMDgwLDcwLE5pZSksbC5hZGRBbGxVbmlxdWU9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtO2lmKGk9ci5zaXplXzEoKSxpIT0wKXtmb3IoZD1hKEJlKHRoaXMudGhpcyQwMSw0KSwxMjkpLGY9ZD09bnVsbD8wOmQubGVuZ3RoLG09ZitpLG89Q0QodGhpcyxtKSxoPWYtbixoPjAmJlhvKGQsbixvLG4raSxoKSxfPXIuaXRlcmF0b3JfMCgpLHU9MDt1PGk7Kyt1KWM9Xy5uZXh0XzEoKSx0PW4rdSxTRChvLHQsVXcodGhpcyxjKSk7Zm9yKHMyKHRoaXMsbykscz0wO3M8aTsrK3MpYz1vW25dLHRoaXMuZGlkQWRkKG4sYyksKytuO3JldHVybiEwfWVsc2UgcmV0dXJuKyt0aGlzLm1vZENvdW50LCExfSxsLmFkZEFsbFVuaXF1ZV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihvPW4uc2l6ZV8xKCksbyE9MCl7Zm9yKF89KHQ9YShCZSh0aGlzLnRoaXMkMDEsNCksMTI5KSx0PT1udWxsPzA6dC5sZW5ndGgpLGQ9XytvLHI9Q0QodGhpcyxkKSxjPW4uaXRlcmF0b3JfMCgpLHM9XztzPGQ7KytzKXU9Yy5uZXh0XzEoKSxTRChyLHMsVXcodGhpcyx1KSk7Zm9yKHMyKHRoaXMsciksaT1fO2k8ZDsrK2kpdT1yW2ldLHRoaXMuZGlkQWRkKGksdSk7cmV0dXJuITB9ZWxzZSByZXR1cm4rK3RoaXMubW9kQ291bnQsITF9LGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHM7bz1hKEJlKHRoaXMudGhpcyQwMSw0KSwxMjkpLGk9bz09bnVsbD8wOm8ubGVuZ3RoLHQ9Q0QodGhpcyxpKzEpLHM9VXcodGhpcyxyKSxuIT1pJiZYbyhvLG4sdCxuKzEsaS1uKSxUcih0LG4scyksczIodGhpcyx0KSx0aGlzLmRpZEFkZChuLHIpfSxsLmFkZFVuaXF1ZV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbztvPSh0PWEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSksdD09bnVsbD8wOnQubGVuZ3RoKSxyPUNEKHRoaXMsbysxKSxTRChyLG8sVXcodGhpcyxuKSksczIodGhpcyxyKSx0aGlzLmRpZEFkZChvLG4pfSxsLmJhc2ljSXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENHZSh0aGlzKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgYkdlKHRoaXMpfSxsLmJhc2ljTGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24obil7dmFyIHIsdDtpZih0PShyPWEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSkscj09bnVsbD8wOnIubGVuZ3RoKSxuPDB8fG4+dCl0aHJvdyBiKG5ldyBRZihuLHQpKTtyZXR1cm4gbmV3IElHZSh0aGlzLG4pfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt2YXIgbixyOysrdGhpcy5tb2RDb3VudCxuPWEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSkscj1uPT1udWxsPzA6bi5sZW5ndGgsczIodGhpcyxudWxsKSxjRCh0aGlzLHIsbil9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscztpZihyPWEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSksciE9bnVsbCl7aWYobiE9bnVsbCl7Zm9yKG89cixpPTAscz1vLmxlbmd0aDtpPHM7KytpKWlmKHQ9b1tpXSxZbihuLHQpKXJldHVybiEwfWVsc2UgZm9yKG89cixpPTAscz1vLmxlbmd0aDtpPHM7KytpKWlmKHQ9b1tpXSxEKHQpPT09RChuKSlyZXR1cm4hMH1yZXR1cm4hMX0sbC5nZXRfMD1mdW5jdGlvbihuKXt2YXIgcix0O2lmKHI9YShCZSh0aGlzLnRoaXMkMDEsNCksMTI5KSx0PXI9PW51bGw/MDpyLmxlbmd0aCxuPj10KXRocm93IGIobmV3IFFmKG4sdCkpO3JldHVybiByW25dfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXt2YXIgcix0LG87aWYocj1hKEJlKHRoaXMudGhpcyQwMSw0KSwxMjkpLHIhPW51bGwpe2lmKG4hPW51bGwpe2Zvcih0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KWlmKFluKG4sclt0XSkpcmV0dXJuIHR9ZWxzZSBmb3IodD0wLG89ci5sZW5ndGg7dDxvOysrdClpZihEKHJbdF0pPT09RChuKSlyZXR1cm4gdH1yZXR1cm4tMX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIGEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSk9PW51bGx9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgd0dlKHRoaXMpfSxsLmxpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB2R2UodGhpcyl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7dmFyIHIsdDtpZih0PShyPWEoQmUodGhpcy50aGlzJDAxLDQpLDEyOSkscj09bnVsbD8wOnIubGVuZ3RoKSxuPDB8fG4+dCl0aHJvdyBiKG5ldyBRZihuLHQpKTtyZXR1cm4gbmV3IFNHZSh0aGlzLG4pfSxsLm1vdmU9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGk7aWYodD1tR2UodGhpcyksaT10PT1udWxsPzA6dC5sZW5ndGgsbj49aSl0aHJvdyBiKG5ldyBubygidGFyZ2V0SW5kZXg9IituKyIsIHNpemU9IitpKSk7aWYocj49aSl0aHJvdyBiKG5ldyBubygic291cmNlSW5kZXg9IityKyIsIHNpemU9IitpKSk7cmV0dXJuIG89dFtyXSxuIT1yJiYobjxyP1hvKHQsbix0LG4rMSxyLW4pOlhvKHQscisxLHQscixuLXIpLFRyKHQsbixvKSxzMih0aGlzLHQpKSxvfSxsLnByaW1pdGl2ZUdldD1mdW5jdGlvbihuKXtyZXR1cm4gYShCZSh0aGlzLnRoaXMkMDEsNCksMTI5KVtuXX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXtyZXR1cm4gZkNuKHRoaXMsbil9LGwuc2V0VW5pcXVlPWZ1bmN0aW9uKG4scil7dmFyIHQsbztyZXR1cm4gdD1tR2UodGhpcyksbz10W25dLFNEKHQsbixVdyh0aGlzLHIpKSxzMih0aGlzLHQpLG99LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49YShCZSh0aGlzLnRoaXMkMDEsNCksMTI5KSxuPT1udWxsPzA6bi5sZW5ndGh9LGwudG9BcnJheT1mdW5jdGlvbigpe3ZhciBuLHIsdDtyZXR1cm4gbj1hKEJlKHRoaXMudGhpcyQwMSw0KSwxMjkpLHQ9bj09bnVsbD8wOm4ubGVuZ3RoLHI9QihnRCx5Niw0MjQsdCwwLDEpLHQ+MCYmWG8obiwwLHIsMCx0KSxyfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXt2YXIgcix0LG87cmV0dXJuIHI9YShCZSh0aGlzLnRoaXMkMDEsNCksMTI5KSxvPXI9PW51bGw/MDpyLmxlbmd0aCxvPjAmJihuLmxlbmd0aDxvJiYodD1mYih3YShuKS5jb21wb25lbnRUeXBlLG8pLG49dCksWG8ociwwLG4sMCxvKSksbi5sZW5ndGg+byYmVHIobixvLG51bGwpLG59O3ZhciB5R2U7Zygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQXJyYXlEZWxlZ2F0aW5nRUxpc3QiLDIwODApO2Z1bmN0aW9uIHdHZShlKXt0aGlzLnRoaXMkMDE9ZSxZZS5jYWxsKHRoaXMsZSksdGhpcy5leHBlY3RlZERhdGE9YShCZSh0aGlzLnRoaXMkMDEudGhpcyQwMSw0KSwxMjkpfXAoMTA1MSwzNyxzdCx3R2UpLGwuY2hlY2tNb2RDb3VudD1mdW5jdGlvbigpe2lmKHRoaXMudGhpcyQwMS5tb2RDb3VudCE9dGhpcy5leHBlY3RlZE1vZENvdW50fHxEKGEoQmUodGhpcy50aGlzJDAxLnRoaXMkMDEsNCksMTI5KSkhPT1EKHRoaXMuZXhwZWN0ZWREYXRhKSl0aHJvdyBiKG5ldyBYYSl9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7eVModGhpcyksdGhpcy5leHBlY3RlZERhdGE9YShCZSh0aGlzLnRoaXMkMDEudGhpcyQwMSw0KSwxMjkpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJBcnJheURlbGVnYXRpbmdFTGlzdC9FSXRlcmF0b3IiLDEwNTEpO2Z1bmN0aW9uIEVHZShlKXtlLmV4cGVjdGVkRGF0YT1hKEJlKGUudGhpcyQwMS50aGlzJDAxLDQpLDEyOSl9ZnVuY3Rpb24gdkdlKGUpe3RoaXMudGhpcyQwMT1lLFNtLmNhbGwodGhpcyxlKSxFR2UodGhpcyl9ZnVuY3Rpb24gU0dlKGUsbil7dGhpcy50aGlzJDAxPWUsRUQuY2FsbCh0aGlzLGUsbiksRUdlKHRoaXMpfXAoNzIyLDI4NixDdSx2R2UsU0dlKSxsLmNoZWNrTW9kQ291bnQ9ZnVuY3Rpb24oKXtpZih0aGlzLnRoaXMkMDEubW9kQ291bnQhPXRoaXMuZXhwZWN0ZWRNb2RDb3VudHx8RChhKEJlKHRoaXMudGhpcyQwMS50aGlzJDAxLDQpLDEyOSkpIT09RCh0aGlzLmV4cGVjdGVkRGF0YSkpdGhyb3cgYihuZXcgWGEpfSxsLmRvU2V0PWZ1bmN0aW9uKG4pe2dHZSh0aGlzLG4pLHRoaXMuZXhwZWN0ZWREYXRhPWEoQmUodGhpcy50aGlzJDAxLnRoaXMkMDEsNCksMTI5KX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt5Uyh0aGlzKSx0aGlzLmV4cGVjdGVkRGF0YT1hKEJlKHRoaXMudGhpcyQwMS50aGlzJDAxLDQpLDEyOSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkFycmF5RGVsZWdhdGluZ0VMaXN0L0VMaXN0SXRlcmF0b3IiLDcyMik7ZnVuY3Rpb24gQ0dlKGUpe3RoaXMudGhpcyQwMT1lLENtLmNhbGwodGhpcyxlKSx0aGlzLmV4cGVjdGVkRGF0YT1hKEJlKHRoaXMudGhpcyQwMS50aGlzJDAxLDQpLDEyOSl9cCgxMDUyLDM1NSxzdCxDR2UpLGwuY2hlY2tNb2RDb3VudD1mdW5jdGlvbigpe2lmKHRoaXMudGhpcyQwMS5tb2RDb3VudCE9dGhpcy5leHBlY3RlZE1vZENvdW50fHxEKGEoQmUodGhpcy50aGlzJDAxLnRoaXMkMDEsNCksMTI5KSkhPT1EKHRoaXMuZXhwZWN0ZWREYXRhKSl0aHJvdyBiKG5ldyBYYSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkFycmF5RGVsZWdhdGluZ0VMaXN0L05vblJlc29sdmluZ0VJdGVyYXRvciIsMTA1Mik7ZnVuY3Rpb24gVEdlKGUpe2UuZXhwZWN0ZWREYXRhPWEoQmUoZS50aGlzJDAxLnRoaXMkMDEsNCksMTI5KX1mdW5jdGlvbiBiR2UoZSl7dGhpcy50aGlzJDAxPWUsZGIuY2FsbCh0aGlzLGUpLFRHZSh0aGlzKX1mdW5jdGlvbiBJR2UoZSxuKXt0aGlzLnRoaXMkMDE9ZSxocmUuY2FsbCh0aGlzLGUsbiksVEdlKHRoaXMpfXAoNzIzLDM5OCxDdSxiR2UsSUdlKSxsLmNoZWNrTW9kQ291bnQ9ZnVuY3Rpb24oKXtpZih0aGlzLnRoaXMkMDEubW9kQ291bnQhPXRoaXMuZXhwZWN0ZWRNb2RDb3VudHx8RChhKEJlKHRoaXMudGhpcyQwMS50aGlzJDAxLDQpLDEyOSkpIT09RCh0aGlzLmV4cGVjdGVkRGF0YSkpdGhyb3cgYihuZXcgWGEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJBcnJheURlbGVnYXRpbmdFTGlzdC9Ob25SZXNvbHZpbmdFTGlzdEl0ZXJhdG9yIiw3MjMpO2Z1bmN0aW9uIFREKGUsbil7UWYuY2FsbCh0aGlzLGUsbil9cCg2MTUsMzAyLGk2LFREKSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VMaXN0L0Jhc2ljSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiIsNjE1KTtmdW5jdGlvbiBtcmUoZSxuKXt0aGlzLnNpemVfMD1lLHRoaXMuZGF0YV8wPW59cCg3MTAsNjYsZXUsbXJlKSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5hZGRBbGxfMD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuZ3Jvdz1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhc2ljSXRlcmF0b3IoKX0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhc2ljTGlzdEl0ZXJhdG9yKCl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFzaWNMaXN0SXRlcmF0b3JfMChuKX0sbC5tb3ZlPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLm1vdmVfMD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwucmVtb3ZlXzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VMaXN0L1VubW9kaWZpYWJsZUVMaXN0Iiw3MTApO2Z1bmN0aW9uIHBDbihlLG4scil7ZS5kZWxlZ2F0ZUVMaXN0LmFkZF8zKG4sYShyLDEzNikpfWZ1bmN0aW9uIGdDbihlLG4pe3JldHVybiBlLmRlbGVnYXRlRUxpc3QuYWRkXzIoYShuLDEzNikpfWZ1bmN0aW9uIGJEKGUsbil7dmFyIHIsdCxvO3JldHVybiBlLnNpemVfMD4wPyhlLmVuc3VyZUVudHJ5RGF0YUV4aXN0cygpLHQ9bj09bnVsbD8wOnVyKG4pLG89KHQmcW4pJWUuZW50cnlEYXRhLmxlbmd0aCxyPUFHZShlLG8sdCxuKSxyIT0tMSk6ITF9ZnVuY3Rpb24geEdlKGUsbil7dmFyIHIsdCxvLGkscyx1O2lmKGUuc2l6ZV8wPjApe2lmKGUuZW5zdXJlRW50cnlEYXRhRXhpc3RzKCksbiE9bnVsbCl7Zm9yKGk9MDtpPGUuZW50cnlEYXRhLmxlbmd0aDsrK2kpaWYocj1lLmVudHJ5RGF0YVtpXSxyKXtmb3IodD1hKHIuZGF0YV8wLDM3OSksdT1yLnNpemVfMCxzPTA7czx1OysrcylpZihvPXRbc10sWW4obixvLmdldFZhbHVlKCkpKXJldHVybiEwfX1lbHNlIGZvcihpPTA7aTxlLmVudHJ5RGF0YS5sZW5ndGg7KytpKWlmKHI9ZS5lbnRyeURhdGFbaV0scil7Zm9yKHQ9YShyLmRhdGFfMCwzNzkpLHU9ci5zaXplXzAscz0wO3M8dTsrK3MpaWYobz10W3NdLEQobik9PT1EKG8uZ2V0VmFsdWUoKSkpcmV0dXJuITB9fXJldHVybiExfWZ1bmN0aW9uIFBHZShlKXt2YXIgbixyO2lmKGUhPW51bGwpZm9yKHI9MDtyPGUubGVuZ3RoOysrciluPWVbcl0sbiYmKGEobi5kYXRhXzAsMzc5KSxuLnNpemVfMCl9ZnVuY3Rpb24gTkdlKGUpe3ZhciBuO2UuZW50cnlEYXRhPT1udWxsPygrK2UubW9kQ291bnQsZS5zaXplXzA9MCxQR2UobnVsbCkpOigrK2UubW9kQ291bnQsbj1lLmVudHJ5RGF0YSxlLmVudHJ5RGF0YT1udWxsLGUuc2l6ZV8wPTAsUEdlKG4pKX1mdW5jdGlvbiB0TChlLG4pe3ZhciByLHQsbztlLmVudHJ5RGF0YT09bnVsbD8oKytlLm1vZENvdW50LCsrZS5zaXplXzApOih0PW4uZ2V0SGFzaCgpLG1DbihlLGUuc2l6ZV8wKzEpLG89KHQmcW4pJWUuZW50cnlEYXRhLmxlbmd0aCxyPWUuZW50cnlEYXRhW29dLCFyJiYocj1lLmVudHJ5RGF0YVtvXT1lLm5ld0xpc3QoKSksci5hZGRfMihuKSwrK2Uuc2l6ZV8wKX1mdW5jdGlvbiBJRChlLG4pe3ZhciByLHQsbztlLmVudHJ5RGF0YT09bnVsbD8oKytlLm1vZENvdW50LC0tZS5zaXplXzApOihvPW4uZ2V0S2V5KCkscj1uLmdldEhhc2goKSx0PShyJnFuKSVlLmVudHJ5RGF0YS5sZW5ndGgsdkNuKGUsdCxBR2UoZSx0LHIsbykpKX1mdW5jdGlvbiB5cmUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYztpZihvPWUuZW50cnlEYXRhW25dLG8pe2lmKGk9by5kYXRhXzAsYz1vLnNpemVfMCx0IT1udWxsKXtmb3IodT0wO3U8YzsrK3UpaWYocz1hKGlbdV0sMTM2KSxzLmdldEhhc2goKT09ciYmWW4odCxzLmdldEtleSgpKSlyZXR1cm4gc31lbHNlIGZvcih1PTA7dTxjOysrdSlpZihzPWEoaVt1XSwxMzYpLEQocy5nZXRLZXkoKSk9PT1EKHQpKXJldHVybiBzfXJldHVybiBudWxsfWZ1bmN0aW9uIEFHZShlLG4scix0KXt2YXIgbyxpLHMsdSxjO2lmKHQhPW51bGwpe2lmKG89ZS5lbnRyeURhdGFbbl0sbyl7Zm9yKGk9by5kYXRhXzAsYz1vLnNpemVfMCx1PTA7dTxjOysrdSlpZihzPWEoaVt1XSwxMzYpLHMuZ2V0SGFzaCgpPT1yJiZZbih0LHMuZ2V0S2V5KCkpKXJldHVybiB1fX1lbHNlIGlmKG89ZS5lbnRyeURhdGFbbl0sbyl7Zm9yKGk9by5kYXRhXzAsYz1vLnNpemVfMCx1PTA7dTxjOysrdSlpZihzPWEoaVt1XSwxMzYpLEQocy5nZXRLZXkoKSk9PT1EKHQpKXJldHVybiB1fXJldHVybi0xfWZ1bmN0aW9uIGhDbihlKXtyZXR1cm4hZS52aWV3JiYoZS52aWV3PW5ldyBpTCksIWUudmlldy5lbnRyeVNldCYmKGUudmlldy5lbnRyeVNldD1uZXcgJEdlKGUpKSxlLnZpZXcuZW50cnlTZXR9ZnVuY3Rpb24gTEdlKGUsbil7cmV0dXJuIEwobiwxNSkmJlVCZShlLmRlbGVnYXRlRUxpc3Qsbil9ZnVuY3Rpb24gd3MoZSxuKXt2YXIgcix0LG87cmV0dXJuIGUuc2l6ZV8wPjAmJihlLmVuc3VyZUVudHJ5RGF0YUV4aXN0cygpLHQ9bj09bnVsbD8wOnVyKG4pLG89KHQmcW4pJWUuZW50cnlEYXRhLmxlbmd0aCxyPXlyZShlLG8sdCxuKSxyKT9yLmdldFZhbHVlKCk6bnVsbH1mdW5jdGlvbiBtQ24oZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZigrK2UubW9kQ291bnQsYz1lLmVudHJ5RGF0YT09bnVsbD8wOmUuZW50cnlEYXRhLmxlbmd0aCxuPmMpe2ZvcihkPWUuZW50cnlEYXRhLGUuZW50cnlEYXRhPUIoZXJlLFFGLDY2LDIqYys0LDAsMSksaT0wO2k8YzsrK2kpaWYoXz1kW2ldLF8pZm9yKHQ9Xy5kYXRhXzAsZj1fLnNpemVfMCx1PTA7dTxmOysrdSlvPWEodFt1XSwxMzYpLHM9d3JlKGUsby5nZXRIYXNoKCkpLHI9ZS5lbnRyeURhdGFbc10sIXImJihyPWUuZW50cnlEYXRhW3NdPWUubmV3TGlzdCgpKSxyLmFkZF8yKG8pO3JldHVybiEwfWVsc2UgcmV0dXJuITF9ZnVuY3Rpb24geUNuKGUpe3JldHVybiBlPT1udWxsPzA6dXIoZSl9ZnVuY3Rpb24gd3JlKGUsbil7cmV0dXJuKG4mcW4pJWUuZW50cnlEYXRhLmxlbmd0aH1mdW5jdGlvbiB3Q24oZSl7cmV0dXJuIWUudmlldyYmKGUudmlldz1uZXcgaUwpLCFlLnZpZXcua2V5U2V0JiYoZS52aWV3LmtleVNldD1uZXcgREdlKGUpKSxlLnZpZXcua2V5U2V0fWZ1bmN0aW9uIHBiKGUpe3JldHVybiFlLnZpZXcmJihlLnZpZXc9bmV3IGlMKSwhZS52aWV3Lm1hcF8wJiYoZS52aWV3Lm1hcF8wPW5ldyBXR2UoZSkpLGUudmlldy5tYXBfMH1mdW5jdGlvbiBFQ24oZSxuLHIpe2UuZGVsZWdhdGVFTGlzdC5tb3ZlXzAobixhKHIsMTM2KSl9ZnVuY3Rpb24gZ2IoZSxuLHIpe3ZhciB0LG8saSxzLHU7cmV0dXJuIGUuZW5zdXJlRW50cnlEYXRhRXhpc3RzKCksaT1uPT1udWxsPzA6dXIobiksZS5zaXplXzA+MCYmKHM9KGkmcW4pJWUuZW50cnlEYXRhLmxlbmd0aCxvPXlyZShlLHMsaSxuKSxvKT8odT1vLnNldFZhbHVlKHIpLHUpOih0PWUubmV3RW50cnkoaSxuLHIpLGUuZGVsZWdhdGVFTGlzdC5hZGRfMih0KSxudWxsKX1mdW5jdGlvbiBrR2UoZSxuKXt2YXIgcix0O2Zvcih0PW4uZW50cnlTZXRfMCgpLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPWEodC5uZXh0XzEoKSw0NCksZ2IoZSxyLmdldEtleSgpLHIuZ2V0VmFsdWUoKSl9ZnVuY3Rpb24gT0dlKGUsbil7dmFyIHI7cmV0dXJuIEwobiw0NCk/ZS5kZWxlZ2F0ZUVMaXN0LnJlbW92ZV8xKG4pOihyPWJEKGUsbiksb0woZSxuKSxyKX1mdW5jdGlvbiB2Q24oZSxuLHIpe3ZhciB0O3JldHVybisrZS5tb2RDb3VudCwtLWUuc2l6ZV8wLHQ9YShlLmVudHJ5RGF0YVtuXS5yZW1vdmVfMihyKSwxMzYpLHQuZ2V0VmFsdWUoKX1mdW5jdGlvbiBvTChlLG4pe3ZhciByLHQsbztyZXR1cm4gZS5lbnN1cmVFbnRyeURhdGFFeGlzdHMoKSx0PW49PW51bGw/MDp1cihuKSxvPSh0JnFuKSVlLmVudHJ5RGF0YS5sZW5ndGgscj15cmUoZSxvLHQsbikscj8oT0dlKGUsciksci5nZXRWYWx1ZSgpKTpudWxsfWZ1bmN0aW9uIFNDbihlLG4scil7cmV0dXJuIGEoZS5kZWxlZ2F0ZUVMaXN0LnNldF8yKG4sYShyLDEzNikpLDQ0KX1mdW5jdGlvbiBDQ24oZSl7cmV0dXJuIWUudmlldyYmKGUudmlldz1uZXcgaUwpLCFlLnZpZXcudmFsdWVzJiYoZS52aWV3LnZhbHVlcz1uZXcgRkdlKGUpKSxlLnZpZXcudmFsdWVzfXAoNzIxLDEsezM6MSwyMDoxLDE2OjEsMTU6MSw2MToxLDU5NzoxfSksbC5hZGRfMz1mdW5jdGlvbihuLHIpe3BDbih0aGlzLG4sYShyLDQ0KSl9LGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIGdDbih0aGlzLGEobiw0NCkpfSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLmdldF8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKE8odGhpcy5kZWxlZ2F0ZUVMaXN0LG4pLDEzNil9LGwubW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiBhKHRoaXMuZGVsZWdhdGVFTGlzdC5tb3ZlKG4sciksNDQpfSxsLm1vdmVfMD1mdW5jdGlvbihuLHIpe0VDbih0aGlzLG4sYShyLDQ0KSl9LGwucGFyYWxsZWxTdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFNlKG51bGwsbmV3IHhlKHRoaXMsMTYpKX0sbC5yZW1vdmVfMj1mdW5jdGlvbihuKXtyZXR1cm4gYSh0aGlzLmRlbGVnYXRlRUxpc3QucmVtb3ZlXzIobiksNDQpfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7cmV0dXJuIFNDbih0aGlzLG4sYShyLDQ0KSl9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3dfKHRoaXMsbil9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLDE2KSl9LGwuYWRkQWxsXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUVMaXN0LmFkZEFsbF8wKG4scil9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlRUxpc3QuYWRkQWxsKG4pfSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmRlbGVnYXRlRUxpc3QuY29udGFpbnMobil9LGwuY29udGFpbnNBbGw9ZnVuY3Rpb24obil7cmV0dXJuIHJDKHRoaXMuZGVsZWdhdGVFTGlzdCxuKX0sbC5lbnN1cmVFbnRyeURhdGFFeGlzdHM9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7aWYodGhpcy5lbnRyeURhdGE9PW51bGwpe2Zvcih0aGlzLmVudHJ5RGF0YT1CKGVyZSxRRiw2NiwyKnRoaXMuc2l6ZV8wKzEsMCwxKSx0PXRoaXMubW9kQ291bnQsdGhpcy5zaXplXzA9MCxyPXRoaXMuZGVsZWdhdGVFTGlzdC5pdGVyYXRvcl8wKCk7ci5jdXJzb3IhPXIudGhpcyQwMV8yLnNpemVfMSgpOyluPWEoci5kb05leHQoKSwxMzYpLHRMKHRoaXMsbik7dGhpcy5tb2RDb3VudD10fX0sbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gTEdlKHRoaXMsbil9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3JldHVybiBZbmUodGhpcy5kZWxlZ2F0ZUVMaXN0KX0sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVFTGlzdC5pbmRleE9mXzAobil9LGwuaW5pdGlhbGl6ZURlbGVnYXRlRUxpc3Q9ZnVuY3Rpb24oKXt0aGlzLmRlbGVnYXRlRUxpc3Q9bmV3IE1HZSh0aGlzKX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wPT0wfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUVMaXN0Lml0ZXJhdG9yXzAoKX0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlRUxpc3QubGlzdEl0ZXJhdG9yXzAoKX0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUVMaXN0Lmxpc3RJdGVyYXRvcl8xKG4pfSxsLm1hcF8yPWZ1bmN0aW9uKCl7cmV0dXJuIHBiKHRoaXMpfSxsLm5ld0VudHJ5PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gbmV3IGpHZShuLHIsdCl9LGwubmV3TGlzdD1mdW5jdGlvbigpe3JldHVybiBuZXcgUkdlfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBPR2UodGhpcyxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplXzB9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiBuZXcgT2ModGhpcy5kZWxlZ2F0ZUVMaXN0LG4scil9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGVnYXRlRUxpc3QudG9BcnJheSgpfSxsLnRvQXJyYXlfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kZWxlZ2F0ZUVMaXN0LnRvQXJyYXlfMChuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIEtuZSh0aGlzLmRlbGVnYXRlRUxpc3QpfSxsLm1vZENvdW50PTAsbC5zaXplXzA9MCxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VNYXAiLDcyMSk7ZnVuY3Rpb24gVENuKGUsbil7dEwoZS50aGlzJDAxLG4pfWZ1bmN0aW9uIGJDbihlLG4pe0lEKGUudGhpcyQwMSxuKX1mdW5jdGlvbiBJQ24oZSxuLHIpe0lEKGUudGhpcyQwMSxyKSx0TChlLnRoaXMkMDEsbil9ZnVuY3Rpb24gTUdlKGUpe3RoaXMudGhpcyQwMT1lfXAoMTA0Niw2NixldSxNR2UpLGwuZGlkQWRkPWZ1bmN0aW9uKG4scil7VENuKHRoaXMsYShyLDEzNikpfSxsLmRpZE1vdmU9ZnVuY3Rpb24obixyLHQpe3ZhciBvOysrKG89dGhpcyxhKHIsMTM2KSxvKS50aGlzJDAxLm1vZENvdW50fSxsLmRpZFJlbW92ZT1mdW5jdGlvbihuLHIpe2JDbih0aGlzLGEociwxMzYpKX0sbC5kaWRTZXQ9ZnVuY3Rpb24obixyLHQpe0lDbih0aGlzLGEociwxMzYpLGEodCwxMzYpKX0sbC5kaWRDbGVhcj1mdW5jdGlvbihuLHIpe05HZSh0aGlzLnRoaXMkMDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VNYXAvMSIsMTA0Nik7ZnVuY3Rpb24gUkdlKCl7fXAoMTA0Nyw2NixldSxSR2UpLGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQih4Q24sQWllLDYyMSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkJhc2ljRU1hcC8yIiwxMDQ3KTtmdW5jdGlvbiBER2UoZSl7dGhpcy50aGlzJDAxPWV9cCgxMDQ4LFNzLERpLERHZSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBiRCh0aGlzLnRoaXMkMDEsbil9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuc2l6ZV8wPT0wPyhqdygpLGhiLmxpc3RJdGVyYXRvcik6bmV3IEdHZSh0aGlzLnRoaXMkMDEpfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3ZhciByO3JldHVybiByPXRoaXMudGhpcyQwMS5zaXplXzAsb0wodGhpcy50aGlzJDAxLG4pLHRoaXMudGhpcyQwMS5zaXplXzAhPXJ9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzB9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkJhc2ljRU1hcC8zIiwxMDQ4KTtmdW5jdGlvbiBGR2UoZSl7dGhpcy50aGlzJDAxPWV9cCgxMDQ5LDMxLEdkLEZHZSksbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB4R2UodGhpcy50aGlzJDAxLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLnNpemVfMD09MD8oancoKSxoYi5saXN0SXRlcmF0b3IpOm5ldyBIR2UodGhpcy50aGlzJDAxKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGlzJDAxLnNpemVfMH0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQmFzaWNFTWFwLzQiLDEwNDkpO2Z1bmN0aW9uIHpHZShlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF8sZDtpZihlLnRoaXMkMDEuc2l6ZV8wPjAmJkwobiw0NCkmJihlLnRoaXMkMDEuZW5zdXJlRW50cnlEYXRhRXhpc3RzKCksXz1hKG4sNDQpLGM9Xy5nZXRLZXkoKSxpPWM9PW51bGw/MDp1cihjKSxzPXdyZShlLnRoaXMkMDEsaSkscj1lLnRoaXMkMDEuZW50cnlEYXRhW3NdLHIpKXtmb3IodD1hKHIuZGF0YV8wLDM3OSksZD1yLnNpemVfMCx1PTA7dTxkOysrdSlpZihvPXRbdV0sby5nZXRIYXNoKCk9PWkmJm8uZXF1YWxzXzAoXykpcmV0dXJuIHpHZShlLF8pLCEwfXJldHVybiExfWZ1bmN0aW9uICRHZShlKXt0aGlzLnRoaXMkMDE9ZX1wKDEwNTAsU3MsRGksJEdlKSxsLmNsZWFyXzA9ZnVuY3Rpb24oKXt0aGlzLnRoaXMkMDEuZGVsZWdhdGVFTGlzdC5jbGVhcl8wKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2lmKHRoaXMudGhpcyQwMS5zaXplXzA+MCYmTChuLDQ0KSYmKHRoaXMudGhpcyQwMS5lbnN1cmVFbnRyeURhdGFFeGlzdHMoKSxfPWEobiw0NCksYz1fLmdldEtleSgpLGk9Yz09bnVsbD8wOnVyKGMpLHM9d3JlKHRoaXMudGhpcyQwMSxpKSxyPXRoaXMudGhpcyQwMS5lbnRyeURhdGFbc10scikpe2Zvcih0PWEoci5kYXRhXzAsMzc5KSxkPXIuc2l6ZV8wLHU9MDt1PGQ7Kyt1KWlmKG89dFt1XSxvLmdldEhhc2goKT09aSYmby5lcXVhbHNfMChfKSlyZXR1cm4hMH1yZXR1cm4hMX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzA9PTA/KGp3KCksaGIubGlzdEl0ZXJhdG9yKTpuZXcgeEQodGhpcy50aGlzJDAxKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gekdlKHRoaXMsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzB9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkJhc2ljRU1hcC81IiwxMDUwKTtmdW5jdGlvbiBCR2UoZSl7dmFyIG47aWYoZS50aGlzJDAxLmVuc3VyZUVudHJ5RGF0YUV4aXN0cygpLGUuZW50cnlDdXJzb3IhPS0xKXtpZigrK2UuZW50cnlDdXJzb3Isbj1lLnRoaXMkMDEuZW50cnlEYXRhW2UuY3Vyc29yXSxlLmVudHJ5Q3Vyc29yPG4uc2l6ZV8wKXJldHVybjsrK2UuY3Vyc29yfWZvcig7ZS5jdXJzb3I8ZS50aGlzJDAxLmVudHJ5RGF0YS5sZW5ndGg7KytlLmN1cnNvcilpZihuPWUudGhpcyQwMS5lbnRyeURhdGFbZS5jdXJzb3JdLG4mJm4uc2l6ZV8wIT0wKXtlLmVudHJ5Q3Vyc29yPTA7cmV0dXJufWUuZW50cnlDdXJzb3I9LTF9ZnVuY3Rpb24geEQoZSl7dGhpcy50aGlzJDAxPWUsdGhpcy5leHBlY3RlZE1vZENvdW50PXRoaXMudGhpcyQwMS5tb2RDb3VudCxlLnNpemVfMD4wJiZCR2UodGhpcyl9cCg2MjIsMSxzdCx4RCksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW50cnlDdXJzb3IhPS0xfSxsLm5leHRfMT1mdW5jdGlvbigpe3ZhciBuO2lmKHRoaXMudGhpcyQwMS5tb2RDb3VudCE9dGhpcy5leHBlY3RlZE1vZENvdW50KXRocm93IGIobmV3IFhhKTtpZih0aGlzLmVudHJ5Q3Vyc29yPT0tMSl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIHRoaXMubGFzdEN1cnNvcj10aGlzLmN1cnNvcix0aGlzLmxhc3RFbnRyeUN1cnNvcj10aGlzLmVudHJ5Q3Vyc29yLEJHZSh0aGlzKSxuPWEodGhpcy50aGlzJDAxLmVudHJ5RGF0YVt0aGlzLmxhc3RDdXJzb3JdLmRhdGFfMFt0aGlzLmxhc3RFbnRyeUN1cnNvcl0sMTM2KSx0aGlzLnlpZWxkXzAobil9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7aWYodGhpcy50aGlzJDAxLm1vZENvdW50IT10aGlzLmV4cGVjdGVkTW9kQ291bnQpdGhyb3cgYihuZXcgWGEpO2lmKHRoaXMubGFzdEVudHJ5Q3Vyc29yPT0tMSl0aHJvdyBiKG5ldyB6aSk7dGhpcy50aGlzJDAxLmRlbGVnYXRlRUxpc3QucmVtb3ZlXzEoTyh0aGlzLnRoaXMkMDEuZW50cnlEYXRhW3RoaXMubGFzdEN1cnNvcl0sdGhpcy5sYXN0RW50cnlDdXJzb3IpKSx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy50aGlzJDAxLm1vZENvdW50LHRoaXMubGFzdEVudHJ5Q3Vyc29yPS0xLHRoaXMuY3Vyc29yPT10aGlzLmxhc3RDdXJzb3ImJnRoaXMuZW50cnlDdXJzb3IhPS0xJiYtLXRoaXMuZW50cnlDdXJzb3J9LGwueWllbGRfMD1mdW5jdGlvbihuKXtyZXR1cm4gbn0sbC5jdXJzb3I9MCxsLmVudHJ5Q3Vyc29yPS0xLGwuZXhwZWN0ZWRNb2RDb3VudD0wLGwubGFzdEN1cnNvcj0wLGwubGFzdEVudHJ5Q3Vyc29yPTAsZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQmFzaWNFTWFwL0Jhc2ljRU1hcEl0ZXJhdG9yIiw2MjIpO2Z1bmN0aW9uIEdHZShlKXt4RC5jYWxsKHRoaXMsZSl9cCgxMDQ0LDYyMixzdCxHR2UpLGwueWllbGRfMD1mdW5jdGlvbihuKXtyZXR1cm4gbi5nZXRLZXkoKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQmFzaWNFTWFwL0Jhc2ljRU1hcEtleUl0ZXJhdG9yIiwxMDQ0KTtmdW5jdGlvbiBIR2UoZSl7eEQuY2FsbCh0aGlzLGUpfXAoMTA0NSw2MjIsc3QsSEdlKSxsLnlpZWxkXzA9ZnVuY3Rpb24obil7cmV0dXJuIG4uZ2V0VmFsdWUoKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQmFzaWNFTWFwL0Jhc2ljRU1hcFZhbHVlSXRlcmF0b3IiLDEwNDUpO2Z1bmN0aW9uIFVHZShlLG4pe3JldHVybiBiRChlLnRoaXMkMDEsbil9ZnVuY3Rpb24gV0dlKGUpe3RoaXMudGhpcyQwMT1lfXAoMTA0MywxLGgxLFdHZSksbC5mb3JFYWNoPWZ1bmN0aW9uKG4pe1QyKHRoaXMsbil9LGwubWVyZ2U9ZnVuY3Rpb24obixyLHQpe3JldHVybiBMNih0aGlzLG4scix0KX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpfSxsLmNvbnRhaW5zS2V5PWZ1bmN0aW9uKG4pe3JldHVybiBVR2UodGhpcyxuKX0sbC5jb250YWluc1ZhbHVlPWZ1bmN0aW9uKG4pe3JldHVybiB4R2UodGhpcy50aGlzJDAxLG4pfSxsLmVudHJ5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gaENuKHRoaXMudGhpcyQwMSl9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7cmV0dXJuIExHZSh0aGlzLnRoaXMkMDEsbil9LGwuZ2V0XzM9ZnVuY3Rpb24obil7cmV0dXJuIHdzKHRoaXMudGhpcyQwMSxuKX0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFluZSh0aGlzLnRoaXMkMDEuZGVsZWdhdGVFTGlzdCl9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuc2l6ZV8wPT0wfSxsLmtleVNldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHdDbih0aGlzLnRoaXMkMDEpfSxsLnB1dD1mdW5jdGlvbihuLHIpe3JldHVybiBnYih0aGlzLnRoaXMkMDEsbixyKX0sbC5yZW1vdmVfMD1mdW5jdGlvbihuKXtyZXR1cm4gb0wodGhpcy50aGlzJDAxLG4pfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuc2l6ZV8wfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gS25lKHRoaXMudGhpcyQwMS5kZWxlZ2F0ZUVMaXN0KX0sbC52YWx1ZXNfMD1mdW5jdGlvbigpe3JldHVybiBDQ24odGhpcy50aGlzJDAxKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiQmFzaWNFTWFwL0RlbGVnYXRpbmdNYXAiLDEwNDMpO2Z1bmN0aW9uIGpHZShlLG4scil7dGhpcy5oYXNoPWUsdGhpcy5rZXk9bix0aGlzLnZhbHVlXzA9cn1wKDYyMSwxLHs0NDoxLDEzNjoxLDYyMToxfSxqR2UpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIEwobiw0NCk/KHI9YShuLDQ0KSwodGhpcy5rZXkhPW51bGw/WW4odGhpcy5rZXksci5nZXRLZXkoKSk6RCh0aGlzLmtleSk9PT1EKHIuZ2V0S2V5KCkpKSYmKHRoaXMudmFsdWVfMCE9bnVsbD9Zbih0aGlzLnZhbHVlXzAsci5nZXRWYWx1ZSgpKTpEKHRoaXMudmFsdWVfMCk9PT1EKHIuZ2V0VmFsdWUoKSkpKTohMX0sbC5nZXRIYXNoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzaH0sbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9LGwuZ2V0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNoXih0aGlzLnZhbHVlXzA9PW51bGw/MDp1cih0aGlzLnZhbHVlXzApKX0sbC5zZXRIYXNoPWZ1bmN0aW9uKG4pe3RoaXMuaGFzaD1ufSxsLnNldEtleT1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBDXyl9LGwuc2V0VmFsdWU9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9dGhpcy52YWx1ZV8wLHRoaXMudmFsdWVfMD1uLHJ9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmtleSsiLT4iK3RoaXMudmFsdWVfMH0sbC5oYXNoPTA7dmFyIHhDbj1nKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJCYXNpY0VNYXAvRW50cnlJbXBsIiw2MjEpO2Z1bmN0aW9uIGlMKCl7fXAoNTQ2LDEse30saUwpLGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkJhc2ljRU1hcC9WaWV3Iiw1NDYpO2Z1bmN0aW9uIGp3KCl7anc9RixoYj1uZXcgb0hlLG5ldyBpSGV9ZnVuY3Rpb24gUENuKGUsbixyKXt2YXIgdCxvLGk7Zm9yKHI8MCYmKHI9MCksaT1lLnNpemVfMCxvPXI7bzxpO28rKylpZih0PU8oZSxvKSxuPT1udWxsKXtpZih0PT1udWxsKXJldHVybiBvfWVsc2UgaWYoRChuKT09PUQodCl8fFluKG4sdCkpcmV0dXJuIG87cmV0dXJuLTF9ZnVuY3Rpb24gTkNuKGUsbil7ancoKTt2YXIgcix0LG8saTtmb3IodD1lVWUoZSksbz1uLF95KHQsMCx0Lmxlbmd0aCxvKSxyPTA7cjx0Lmxlbmd0aDtyKyspaT1QQ24oZSx0W3JdLHIpLHIhPWkmJm1TKGUscixpKX12YXIgaGI7ZnVuY3Rpb24gVkdlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIHFHZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBZR2UoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gS0dlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIFhHZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBKR2UoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gWkdlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIFFHZSgpe3Rocm93IGIobmV3IFRuKX1mdW5jdGlvbiBlSGUoKXt0aHJvdyBiKG5ldyBUbil9ZnVuY3Rpb24gbkhlKCl7dGhyb3cgYihuZXcgVG4pfWZ1bmN0aW9uIHJIZSgpe3RoaXMubGlzdEl0ZXJhdG9yPW5ldyB0SGV9cCg3ODMsMSx7fSksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXtyZXR1cm4gcXooKE5lKCksT3QpLG4pfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gR0IoKE5lKCksT3QpKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIG0wKChOZSgpLE90KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkVDb2xsZWN0aW9ucy9CYXNpY0VtcHR5VW5tb2RpZmlhYmxlRUxpc3QiLDc4Myk7ZnVuY3Rpb24gdEhlKCl7fXAoMTM0OCwxLEN1LHRIZSksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuYWRkXzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiExfSxsLmhhc1ByZXZpb3VzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwubmV4dF8xPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG8pfSxsLm5leHRJbmRleF8wPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwucHJldmlvdXNfMD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBvKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuLTF9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLnNldF8xPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiRUNvbGxlY3Rpb25zL0Jhc2ljRW1wdHlVbm1vZGlmaWFibGVFTGlzdC8xIiwxMzQ4KTtmdW5jdGlvbiBvSGUoKXtySGUuY2FsbCh0aGlzKX1wKDEzNDYsNzgzLHsyMDoxLDE2OjEsMTU6MSw2MToxfSxvSGUpLGwuYWRkXzM9ZnVuY3Rpb24obixyKXtWR2UoKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gcUdlKCl9LGwuYWRkQWxsXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gWUdlKCl9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBLR2UoKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7WEdlKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwuY29udGFpbnNBbGw9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe0V0KHRoaXMsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFVCKChOZSgpLG4pKSxudWxsfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXtyZXR1cm4tMX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3RJdGVyYXRvcn0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3RJdGVyYXRvcn0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5saXN0SXRlcmF0b3J9LGwubW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiBKR2UoKX0sbC5tb3ZlXzA9ZnVuY3Rpb24obixyKXtaR2UoKX0sbC5wYXJhbGxlbFN0cmVhbT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2UobnVsbCxuZXcgeGUodGhpcywxNikpfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiBRR2UoKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gZUhlKCl9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gbkhlKCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3dfKHRoaXMsbil9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLDE2KSl9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiBOZSgpLG5ldyBPYyhPdCxuLHIpfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gd3ooKE5lKCksT3QpKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE5lKCksSTIoT3Qsbil9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkVDb2xsZWN0aW9ucy9FbXB0eVVubW9kaWZpYWJsZUVMaXN0IiwxMzQ2KTtmdW5jdGlvbiBpSGUoKXtySGUuY2FsbCh0aGlzKX1wKDEzNDcsNzgzLHsyMDoxLDE2OjEsMTU6MSw2MToxLDU5NzoxfSxpSGUpLGwuYWRkXzM9ZnVuY3Rpb24obixyKXtWR2UoKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gcUdlKCl9LGwuYWRkQWxsXzA9ZnVuY3Rpb24obixyKXtyZXR1cm4gWUdlKCl9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBLR2UoKX0sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7WEdlKCl9LGwuY29udGFpbnM9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwuY29udGFpbnNBbGw9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwuZm9yRWFjaF8wPWZ1bmN0aW9uKG4pe0V0KHRoaXMsbil9LGwuZ2V0XzA9ZnVuY3Rpb24obil7cmV0dXJuIFVCKChOZSgpLG4pKSxudWxsfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXtyZXR1cm4tMX0sbC5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3RJdGVyYXRvcn0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxpc3RJdGVyYXRvcn0sbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5saXN0SXRlcmF0b3J9LGwubW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiBKR2UoKX0sbC5tb3ZlXzA9ZnVuY3Rpb24obixyKXtaR2UoKX0sbC5wYXJhbGxlbFN0cmVhbT1mdW5jdGlvbigpe3JldHVybiBuZXcgU2UobnVsbCxuZXcgeGUodGhpcywxNikpfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiBRR2UoKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gZUhlKCl9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gbkhlKCl9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwuc29ydF8wPWZ1bmN0aW9uKG4pe3dfKHRoaXMsbil9LGwuc3BsaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBuZXcgeGUodGhpcywxNil9LGwuc3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTZShudWxsLG5ldyB4ZSh0aGlzLDE2KSl9LGwuc3ViTGlzdD1mdW5jdGlvbihuLHIpe3JldHVybiBOZSgpLG5ldyBPYyhPdCxuLHIpfSxsLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm4gd3ooKE5lKCksT3QpKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7cmV0dXJuIE5lKCksSTIoT3Qsbil9LGwubWFwXzI9ZnVuY3Rpb24oKXtyZXR1cm4gTmUoKSxOZSgpLGt1fSxnKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJFQ29sbGVjdGlvbnMvRW1wdHlVbm1vZGlmaWFibGVFTWFwIiwxMzQ3KTt2YXIgRXJlPUNyKCJvcmcuZWNsaXBzZS5lbWYuY29tbW9uLnV0aWwiLCJFbnVtZXJhdG9yIik7ZnVuY3Rpb24gYUwoKXthTD1GLGxMPW5ldyBzbn1mdW5jdGlvbiBhSGUoZSxuKXthTCgpO3ZhciByO3JldHVybiByPWEoS2UobEwsZSksNTcpLCFyfHxyLmlzSW5zdGFuY2Uobil9ZnVuY3Rpb24gJG4oZSxuKXthTCgpLEJuKGxMLGUsbil9dmFyIGxMO2Z1bmN0aW9uIFBEKCl7UEQ9Rjt2YXIgZTt4cmU9bmV3IHdIZSxoSGU9QihzZSxYLDIsMCw2LDEpLHBIZT1scyhUbSgzMyw1OCksVG0oMSwyNikpLGdIZT1scyhUbSg5NywxMjIpLFRtKDY1LDkwKSksU3JlPVRtKDQ4LDU3KSxkSGU9bHMocEhlLDApLGZIZT1scyhnSGUsU3JlKSxDcmU9bHMobHMoMCxUbSgxLDYpKSxUbSgzMywzOCkpLFRyZT1scyhscyhTcmUsVG0oNjUsNzApKSxUbSg5NywxMDIpKSxtSGU9bHMoZEhlLHNMKCItXy4hfionKCkiKSkseUhlPWxzKGZIZSx1TCgiLV8uIX4qJygpIikpLHNMKCI7Lz86QCY9KyQsIiksdUwoIjsvPzpAJj0rJCwiKSxscyhtSGUsc0woIjs6QCY9KyQsIikpLGxzKHlIZSx1TCgiOzpAJj0rJCwiKSksYnJlPXNMKCI6Lz8jIiksSXJlPXVMKCI6Lz8jIiksd1M9c0woIi8/IyIpLEVTPXVMKCIvPyMiKSxlPW5ldyBCcixlLm1hcF8wLnB1dCgiamFyIixlKSxlLm1hcF8wLnB1dCgiemlwIixlKSxlLm1hcF8wLnB1dCgiYXJjaGl2ZSIsZSksY0w9KE5lKCksbmV3IG15KGUpKX1mdW5jdGlvbiBsSGUoZSxuKXt2YXIgcjtyZXR1cm4gcj1uZXcgTkQoKGUuaGFzaENvZGVfMCYyNTYpIT0wLGUuc2NoZW1lLGUuYXV0aG9yaXR5LGUuZGV2aWNlLChlLmhhc2hDb2RlXzAmMTYpIT0wLGUuc2VnbWVudHMsZS5xdWVyeSxuKSxlLmZyYWdtZW50IT1udWxsfHwoci5jYWNoZWRUcmltRnJhZ21lbnQ9ZSkscn1mdW5jdGlvbiBBQ24oZSxuKXt2YXIgcix0O2lmKGUuc2VnbWVudHMubGVuZ3RoIT1uLnNlZ21lbnRzLmxlbmd0aClyZXR1cm4hMTtmb3Iocj0wLHQ9ZS5zZWdtZW50cy5sZW5ndGg7cjx0O3IrKylpZighVGUoZS5zZWdtZW50c1tyXSxuLnNlZ21lbnRzW3JdKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBzSGUoZSl7dmFyIG4scix0O2lmKGUuY2FjaGVkVG9TdHJpbmc9PW51bGwpe2lmKHQ9bmV3IExjLGUuc2NoZW1lIT1udWxsJiYoSnQodCxlLnNjaGVtZSksdC5zdHJpbmcrPSI6IiksZS5oYXNoQ29kZV8wJjI1Nil7Zm9yKGUuaGFzaENvZGVfMCYyNTYmJmUuYXV0aG9yaXR5IT1udWxsJiYoTUNuKGUuc2NoZW1lKXx8KHQuc3RyaW5nKz0iLy8iKSxKdCh0LGUuYXV0aG9yaXR5KSksZS5kZXZpY2UhPW51bGwmJih0LnN0cmluZys9Ii8iLEp0KHQsZS5kZXZpY2UpKSxlLmhhc2hDb2RlXzAmMTYmJih0LnN0cmluZys9Ii8iKSxuPTAscj1lLnNlZ21lbnRzLmxlbmd0aDtuPHI7bisrKW4hPTAmJih0LnN0cmluZys9Ii8iKSxKdCh0LGUuc2VnbWVudHNbbl0pO2UucXVlcnkhPW51bGwmJih0LnN0cmluZys9Ij8iLEp0KHQsZS5xdWVyeSkpfWVsc2UgSnQodCxlLmF1dGhvcml0eSk7ZS5mcmFnbWVudCE9bnVsbCYmKHQuc3RyaW5nKz0iIyIsSnQodCxlLmZyYWdtZW50KSksZS5jYWNoZWRUb1N0cmluZz10LnN0cmluZ31yZXR1cm4gZS5jYWNoZWRUb1N0cmluZ31mdW5jdGlvbiBMQ24oZSl7cmV0dXJuIGUuZnJhZ21lbnQ9PW51bGw/ZTooIWUuY2FjaGVkVHJpbUZyYWdtZW50JiYoZS5jYWNoZWRUcmltRnJhZ21lbnQ9bmV3IE5EKChlLmhhc2hDb2RlXzAmMjU2KSE9MCxlLnNjaGVtZSxlLmF1dGhvcml0eSxlLmRldmljZSwoZS5oYXNoQ29kZV8wJjE2KSE9MCxlLnNlZ21lbnRzLGUucXVlcnksbnVsbCkpLGUuY2FjaGVkVHJpbUZyYWdtZW50KX1mdW5jdGlvbiBORChlLG4scix0LG8saSxzLHUpe3ZhciBjLF8sZDtmb3IoYz0wLG4hPW51bGwmJihjXj1OYyhuLnRvTG93ZXJDYXNlKCkpKSxyIT1udWxsJiYoY149TmMocikpLHQhPW51bGwmJihjXj1OYyh0KSkscyE9bnVsbCYmKGNePU5jKHMpKSx1IT1udWxsJiYoY149TmModSkpLF89MCxkPWkubGVuZ3RoO188ZDtfKyspY149TmMoaVtfXSk7ZT9jfD0yNTY6YyY9LTI1NyxvP2N8PTE2OmMmPS0xNyx0aGlzLmhhc2hDb2RlXzA9Yyx0aGlzLnNjaGVtZT1uPT1udWxsP251bGw6KFZlKG4pLG4pLHRoaXMuYXV0aG9yaXR5PXIsdGhpcy5kZXZpY2U9dCx0aGlzLnNlZ21lbnRzPWksdGhpcy5xdWVyeT1zLHRoaXMuZnJhZ21lbnQ9dX1mdW5jdGlvbiBBRChlLG4scil7dmFyIHQsbztmb3IodD0wLG89ZS5sZW5ndGg7dDxvO3QrKylpZihPRCgoSGUodCxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHQpKSxuLHIpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHVIZShlKXtQRCgpO3ZhciBuLHIsdCxvO3JldHVybiB0PW91KGUseGkoMzUpKSxuPXQ9PS0xP2U6KGd0KDAsdCxlLmxlbmd0aCksZS5zdWJzdHIoMCx0KSkscj10PT0tMT9udWxsOihIZSh0KzEsZS5sZW5ndGgrMSksZS5zdWJzdHIodCsxKSksbz1IQ24oeHJlLG4pLG8/ciE9bnVsbCYmKG89bEhlKG8sKFZlKHIpLHIpKSk6KG89UkNuKG4pLFVDbih4cmUsbixvKSxyIT1udWxsJiYobz1sSGUobyxyKSkpLG99ZnVuY3Rpb24gdnJlKGUpe1BEKCk7dmFyIG4scix0LG8saSxzLHUsYztpZihlPT1udWxsKXJldHVybiBudWxsO2lmKG89b3UoZSx4aSgzNykpLG88MClyZXR1cm4gZTtmb3IoYz1uZXcgTGEoKGd0KDAsbyxlLmxlbmd0aCksZS5zdWJzdHIoMCxvKSkpLG49QihKaSx3cCwyOCw0LDE1LDEpLHU9MCx0PTAscz1lLmxlbmd0aDtvPHM7bysrKWlmKEhlKG8sZS5sZW5ndGgpLGUuY2hhckNvZGVBdChvKT09MzcmJmUubGVuZ3RoPm8rMiYmT0QoKEhlKG8rMSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KG8rMSkpLENyZSxUcmUpJiZPRCgoSGUobysyLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQobysyKSksQ3JlLFRyZSkpaWYocj1GQ24oKEhlKG8rMSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KG8rMSkpLChIZShvKzIsZS5sZW5ndGgpLGUuY2hhckNvZGVBdChvKzIpKSksbys9Mix0PjA/KHImMTkyKT09MTI4P25bdSsrXT1yPDwyND4+MjQ6dD0wOnI+PTEyOCYmKChyJjIyNCk9PTE5Mj8oblt1KytdPXI8PDI0Pj4yNCx0PTIpOihyJjI0MCk9PTIyND8oblt1KytdPXI8PDI0Pj4yNCx0PTMpOihyJjI0OCk9PTI0MCYmKG5bdSsrXT1yPDwyND4+MjQsdD00KSksdD4wKXtpZih1PT10KXtzd2l0Y2godSl7Y2FzZSAyOnt4XyhjLCgoblswXSYzMSk8PDZ8blsxXSY2MykmenIpO2JyZWFrfWNhc2UgMzp7eF8oYywoKG5bMF0mMTUpPDwxMnwoblsxXSY2Myk8PDZ8blsyXSY2MykmenIpO2JyZWFrfX11PTAsdD0wfX1lbHNle2ZvcihpPTA7aTx1OysraSl4XyhjLG5baV0menIpO3U9MCxjLnN0cmluZys9U3RyaW5nLmZyb21DaGFyQ29kZShyKX1lbHNle2ZvcihpPTA7aTx1OysraSl4XyhjLG5baV0menIpO3U9MCx4XyhjLChIZShvLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQobykpKX1yZXR1cm4gYy5zdHJpbmd9ZnVuY3Rpb24gTEQoZSxuKXtyZXR1cm4gZT09bnVsbD9uPT1udWxsOlRlKGUsbil9ZnVuY3Rpb24ga0NuKGUsbil7cmV0dXJuIGU9PW51bGw/bj09bnVsbDpXSShlLG4pfWZ1bmN0aW9uIGtEKGUsbixyLHQpe3ZhciBvO2lmKG89ZS5sZW5ndGgsbj49bylyZXR1cm4gbztmb3Iobj1uPjA/bjowO248byYmIU9EKChIZShuLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQobikpLHIsdCk7bisrKTtyZXR1cm4gbn1mdW5jdGlvbiBPQ24oZSl7dmFyIG4scjtpZihlPT1udWxsKXJldHVybiBudWxsO2ZvcihuPTAscj1lLmxlbmd0aDtuPHI7bisrKWlmKCFjSGUoZVtuXSkpcmV0dXJuIGVbbl07cmV0dXJuIG51bGx9ZnVuY3Rpb24gc0woZSl7dmFyIG4scix0LG87Zm9yKG89MCxyPTAsdD1lLmxlbmd0aDtyPHQ7cisrKW49KEhlKHIsZS5sZW5ndGgpLGUuY2hhckNvZGVBdChyKSksbj49NjQmJm48MTI4JiYobz1scyhvLE9sKDEsbi02NCkpKTtyZXR1cm4gb31mdW5jdGlvbiBNQ24oZSl7cmV0dXJuIGUhPW51bGwmJk1DKGNMLGUudG9Mb3dlckNhc2UoKSl9ZnVuY3Rpb24gVG0oZSxuKXt2YXIgcix0O2lmKHQ9MCxlPDY0JiZlPD1uKWZvcihuPW48NjQ/bjo2MyxyPWU7cjw9bjtyKyspdD1scyh0LE9sKDEscikpO3JldHVybiB0fWZ1bmN0aW9uIHVMKGUpe3ZhciBuLHIsdCxvO2ZvcihvPTAscj0wLHQ9ZS5sZW5ndGg7cjx0O3IrKyluPShIZShyLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQocikpLG48NjQmJihvPWxzKG8sT2woMSxuKSkpO3JldHVybiBvfWZ1bmN0aW9uIE9EKGUsbixyKXtyZXR1cm4gZT49MTI4PyExOmU8NjQ/UjIoZXQoT2woMSxlKSxyKSwwKTpSMihldChPbCgxLGUtNjQpLG4pLDApfWZ1bmN0aW9uIFJDbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZCxmLGgsbTtpZihzPSEwLGY9bnVsbCx0PW51bGwsbz1udWxsLG49ITEsbT1oSGUsXz1udWxsLGk9bnVsbCx1PTAsYz1rRChlLHUsYnJlLElyZSksYzxlLmxlbmd0aCYmKEhlKGMsZS5sZW5ndGgpLGUuY2hhckNvZGVBdChjKT09NTgpJiYoZj0oZ3QodSxjLGUubGVuZ3RoKSxlLnN1YnN0cih1LGMtdSkpLHU9YysxKSxyPWYhPW51bGwmJk1DKGNMLGYudG9Mb3dlckNhc2UoKSkscil7aWYoYz1lLmxhc3RJbmRleE9mKCIhLyIpLGM9PS0xKXRocm93IGIobmV3IEdlKCJubyBhcmNoaXZlIHNlcGFyYXRvciIpKTtzPSEwLHQ9WWEoZSx1LCsrYyksdT1jfWVsc2UgdT49MCYmVGUoZS5zdWJzdHIodSwyKSwiLy8iKT8odSs9MixjPWtEKGUsdSx3UyxFUyksdD0oZ3QodSxjLGUubGVuZ3RoKSxlLnN1YnN0cih1LGMtdSkpLHU9Yyk6ZiE9bnVsbCYmKHU9PWUubGVuZ3RofHwoSGUodSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHUpIT00NykpJiYocz0hMSxjPXNCKGUseGkoMzUpLHUpLGM9PS0xJiYoYz1lLmxlbmd0aCksdD0oZ3QodSxjLGUubGVuZ3RoKSxlLnN1YnN0cih1LGMtdSkpLHU9Yyk7aWYoIXImJnU8ZS5sZW5ndGgmJihIZSh1LGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodSk9PTQ3KSYmKGM9a0QoZSx1KzEsd1MsRVMpLGQ9KGd0KHUrMSxjLGUubGVuZ3RoKSxlLnN1YnN0cih1KzEsYy0odSsxKSkpLGQubGVuZ3RoPjAmJkl0KGQsZC5sZW5ndGgtMSk9PTU4JiYobz1kLHU9YykpLHU8ZS5sZW5ndGgmJihIZSh1LGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodSk9PTQ3KSYmKCsrdSxuPSEwKSx1PGUubGVuZ3RoJiYoSGUodSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHUpIT02MykmJihIZSh1LGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodSkhPTM1KSl7Zm9yKGg9bmV3IFE7dTxlLmxlbmd0aCYmKEhlKHUsZS5sZW5ndGgpLGUuY2hhckNvZGVBdCh1KSE9NjMpJiYoSGUodSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHUpIT0zNSk7KWM9a0QoZSx1LHdTLEVTKSxlZShoLChndCh1LGMsZS5sZW5ndGgpLGUuc3Vic3RyKHUsYy11KSkpLHU9Yyx1PGUubGVuZ3RoJiYoSGUodSxlLmxlbmd0aCksZS5jaGFyQ29kZUF0KHUpPT00NykmJihEQ24oZSwrK3UpfHxoLmFycmF5LnB1c2goIiIpKTttPUIoc2UsWCwyLGguYXJyYXkubGVuZ3RoLDYsMSksSXMoaCxtKX1yZXR1cm4gdTxlLmxlbmd0aCYmKEhlKHUsZS5sZW5ndGgpLGUuY2hhckNvZGVBdCh1KT09NjMpJiYoYz1zeShlLDM1LCsrdSksYz09LTEmJihjPWUubGVuZ3RoKSxfPShndCh1LGMsZS5sZW5ndGgpLGUuc3Vic3RyKHUsYy11KSksdT1jKSx1PGUubGVuZ3RoJiYoaT1fQihlLCsrdSkpLEdDbihzLGYsdCxvLG0sXyksbmV3IE5EKHMsZix0LG8sbixtLF8saSl9ZnVuY3Rpb24gRENuKGUsbil7cmV0dXJuIG48ZS5sZW5ndGgmJihIZShuLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQobikhPTYzKSYmKEhlKG4sZS5sZW5ndGgpLGUuY2hhckNvZGVBdChuKSE9MzUpfWZ1bmN0aW9uIEZDbihlLG4pe3JldHVybihfSGUoZSk8PDR8X0hlKG4pKSZ6cn1mdW5jdGlvbiB6Q24oZSl7dmFyIG47aWYoZSE9bnVsbCYmZS5sZW5ndGg+MCYmSXQoZSxlLmxlbmd0aC0xKT09MzMpdHJ5e3JldHVybiBuPXVIZShZYShlLDAsZS5sZW5ndGgtMSkpLG4uZnJhZ21lbnQ9PW51bGx9Y2F0Y2gocil7aWYocj13cihyKSwhTChyLDMzKSl0aHJvdyBiKHIpfXJldHVybiExfWZ1bmN0aW9uICRDbihlKXt2YXIgbjtyZXR1cm4gZT09bnVsbD8hMDoobj1lLmxlbmd0aCxuPjAmJihIZShuLTEsZS5sZW5ndGgpLGUuY2hhckNvZGVBdChuLTEpPT01OCkmJiFBRChlLHdTLEVTKSl9ZnVuY3Rpb24gY0hlKGUpe3JldHVybiBlIT1udWxsJiYhQUQoZSx3UyxFUyl9ZnVuY3Rpb24gQkNuKGUpe3ZhciBuLHI7aWYoZT09bnVsbClyZXR1cm4hMTtmb3Iobj0wLHI9ZS5sZW5ndGg7bjxyO24rKylpZighY0hlKGVbbl0pKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIEdDbihlLG4scix0LG8saSl7dmFyIHM7aWYoIShuPT1udWxsfHwhQUQobixicmUsSXJlKSkpdGhyb3cgYihuZXcgR2UoImludmFsaWQgc2NoZW1lOiAiK24pKTtpZighZSYmIShyIT1udWxsJiZvdShyLHhpKDM1KSk9PS0xJiZyLmxlbmd0aD4wJiYoSGUoMCxyLmxlbmd0aCksci5jaGFyQ29kZUF0KDApIT00NykpKXRocm93IGIobmV3IEdlKCJpbnZhbGlkIG9wYXF1ZVBhcnQ6ICIrcikpO2lmKGUmJiEobiE9bnVsbCYmTUMoY0wsbi50b0xvd2VyQ2FzZSgpKSkmJiEocj09bnVsbHx8IUFEKHIsd1MsRVMpKSl0aHJvdyBiKG5ldyBHZSgiaW52YWxpZCBhdXRob3JpdHk6ICIrcikpO2lmKGUmJm4hPW51bGwmJk1DKGNMLG4udG9Mb3dlckNhc2UoKSkmJiF6Q24ocikpdGhyb3cgYihuZXcgR2UoImludmFsaWQgYXV0aG9yaXR5OiAiK3IpKTtpZighJENuKHQpKXRocm93IGIobmV3IEdlKCJpbnZhbGlkIGRldmljZTogIit0KSk7aWYoIUJDbihvKSl0aHJvdyBzPW89PW51bGw/ImludmFsaWQgc2VnbWVudHM6IG51bGwiOiJpbnZhbGlkIHNlZ21lbnQ6ICIrT0NuKG8pLGIobmV3IEdlKHMpKTtpZighKGk9PW51bGx8fG91KGkseGkoMzUpKT09LTEpKXRocm93IGIobmV3IEdlKCJpbnZhbGlkIHF1ZXJ5OiAiK2kpKX1mdW5jdGlvbiBfSGUoZSl7cmV0dXJuIGU+PTY1JiZlPD03MD9lLTY1KzEwOmU+PTk3JiZlPD0xMDI/ZS05NysxMDplPj00OCYmZTw9NTc/ZS00ODowfXAoMjg4LDEsezI4ODoxfSxORCksbC5lcXVhbHNfMD1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdGhpcz09PW4/ITA6TChuLDI4OCk/KHI9YShuLDI4OCksdGhpcy5oYXNoQ29kZV8wPT1yLmhhc2hDb2RlXzAmJmtDbih0aGlzLnNjaGVtZSxyLnNjaGVtZSkmJkxEKHRoaXMuYXV0aG9yaXR5LHRoaXMuaGFzaENvZGVfMCYyNTY/ci5oYXNoQ29kZV8wJjI1Nj9yLmF1dGhvcml0eTpudWxsOnIuaGFzaENvZGVfMCYyNTY/bnVsbDpyLmF1dGhvcml0eSkmJkxEKHRoaXMuZGV2aWNlLHIuZGV2aWNlKSYmTEQodGhpcy5xdWVyeSxyLnF1ZXJ5KSYmTEQodGhpcy5mcmFnbWVudCxyLmZyYWdtZW50KSYmQUNuKHRoaXMscikpOiExfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNoQ29kZV8wfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gc0hlKHRoaXMpfSxsLmhhc2hDb2RlXzA9MDt2YXIgZEhlPTAsZkhlPTAscEhlPTAsZ0hlPTAsU3JlPTAsQ3JlPTAsVHJlPTAsYnJlPTAsSXJlPTAsaEhlLHdTPTAsRVM9MCxtSGU9MCx5SGU9MCxjTCx4cmU7Zygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiVVJJIiwyODgpO2Z1bmN0aW9uIEhDbihlLG4pe3JldHVybiBhKG49PW51bGw/X28oanQoZS5oYXNoQ29kZU1hcCxudWxsKSk6ckUoZS5zdHJpbmdNYXAsbiksMjg4KX1mdW5jdGlvbiBVQ24oZSxuLHIpe3JldHVybiBhKG49PW51bGw/ZGkoZS5oYXNoQ29kZU1hcCxudWxsLHIpOmsxKGUuc3RyaW5nTWFwLG4sciksMjg4KX1mdW5jdGlvbiB3SGUoKXtzbi5jYWxsKHRoaXMpfXAoMTEyMSw0NSxocCx3SGUpLGwucHV0PWZ1bmN0aW9uKG4scil7cmV0dXJuIGEodG8odGhpcyx4bihuKSxhKHIsMjg4KSksMjg4KX0sZygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiVVJJL1VSSUNhY2hlIiwxMTIxKTtmdW5jdGlvbiBFSGUoKXt9ZnVuY3Rpb24gX0woZSl7UGQuY2FsbCh0aGlzLGUuc2l6ZV8xKCkpLFByKHRoaXMsZSl9cCg1MDYsNjYsZXUsRUhlLF9MKSxsLmlzVW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIlVuaXF1ZUVMaXN0Iiw1MDYpO2Z1bmN0aW9uIGRMKGUpe0lJKHRoaXMpLHRoaXMuZGV0YWlsTWVzc2FnZT1lP1BJKGUsZS5nZXRNZXNzYWdlKCkpOm51bGwsdGhpcy5jYXVzZV8wPWUseEkodGhpcyksdGhpcy5pbml0aWFsaXplQmFja2luZ0Vycm9yKCl9cCg1OTAsNjMsS3UsZEwpLGcoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIldyYXBwZWRFeGNlcHRpb24iLDU5MCk7dmFyIERuPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFQW5ub3RhdGlvbiIpLGVwPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFVHlwZWRFbGVtZW50IiksUmk9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVTdHJ1Y3R1cmFsRmVhdHVyZSIpLG5wPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFQXR0cmlidXRlIiksRXM9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVDbGFzc2lmaWVyIiksSWw9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVDbGFzcyIpLE1EPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFRGF0YVR5cGUiKTtmdW5jdGlvbiB2SGUoKXt2SGU9RixTSGU9bmV3IENIZX12YXIgU0hlO2Z1bmN0aW9uIFdDbihlLG4pe3ZhciByO3JldHVybiByPW4hPW51bGw/bmkoZSxuKTpfbyhqdChlLmhhc2hDb2RlTWFwLG4pKSxlSShyKX1mdW5jdGlvbiBDSGUoKXtzbi5jYWxsKHRoaXMpfXAoMTIzMyw0NSxocCxDSGUpLGwuZ2V0XzM9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pP25pKHRoaXMsbik6X28oanQodGhpcy5oYXNoQ29kZU1hcCxuKSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVEYXRhVHlwZS9JbnRlcm5hbC9Db252ZXJzaW9uRGVsZWdhdGUvRmFjdG9yeS9SZWdpc3RyeS9JbXBsIiwxMjMzKTt2YXIgZkw9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVFbnVtIiksdmM9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVFbnVtTGl0ZXJhbCIpLEt0PUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFR2VuZXJpY1R5cGUiKSx4bD1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlIiwiRU9wZXJhdGlvbiIpO2Z1bmN0aW9uIG5fKCl7bl89RixQbD1uZXcgZnRlfXZhciBQbCxOZD1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlIiwiRVBhcmFtZXRlciIpLHJwPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFUmVmZXJlbmNlIik7ZnVuY3Rpb24gVEhlKCl7fXAoMTA0MiwxLHt9LFRIZSksbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIk5JTCJ9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZSIsIkVTdHJ1Y3R1cmFsRmVhdHVyZS9JbnRlcm5hbC9EeW5hbWljVmFsdWVIb2xkZXIvMSIsMTA0Mik7ZnVuY3Rpb24gYkhlKCl7YkhlPUYsSUhlPW5ldyB4SGV9dmFyIElIZTtmdW5jdGlvbiBqQ24oZSxuKXt2YXIgcjtyZXR1cm4gcj1uIT1udWxsP25pKGUsbik6X28oanQoZS5oYXNoQ29kZU1hcCxuKSksZUkocil9ZnVuY3Rpb24geEhlKCl7c24uY2FsbCh0aGlzKX1wKDEwNDEsNDUsaHAseEhlKSxsLmdldF8zPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKT9uaSh0aGlzLG4pOl9vKGp0KHRoaXMuaGFzaENvZGVNYXAsbikpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFU3RydWN0dXJhbEZlYXR1cmUvSW50ZXJuYWwvU2V0dGluZ0RlbGVnYXRlL0ZhY3RvcnkvUmVnaXN0cnkvSW1wbCIsMTA0MSk7dmFyIGJpPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFVHlwZVBhcmFtZXRlciIpLGJtPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUiLCJFVmFsaWRhdG9yL1BhdHRlcm5NYXRjaGVyIik7ZnVuY3Rpb24gUHJlKCl7UHJlPUYsTnJlPW5ldyBNV2V9dmFyIE5yZTtmdW5jdGlvbiBWdygpe1Z3PUYsQXJlPVkzbigpfXZhciBBcmU7ZnVuY3Rpb24gcl8oKXtyXz1GLCRlPWVUbigpLFBlKCksdHAmJnJUbigpfXZhciAkZTtmdW5jdGlvbiBQZSgpe1BlPUYsdHA9KHJfKCksJGUpLmVBdHRyaWJ1dGVFQ2xhc3MsYShPKEcoJGUuZUF0dHJpYnV0ZUVDbGFzcyksMCksMzUpLGEoTyhHKCRlLmVBdHRyaWJ1dGVFQ2xhc3MpLDEpLDE5KSxuMD0kZS5lQW5ub3RhdGlvbkVDbGFzcyxhKE8oRygkZS5lQW5ub3RhdGlvbkVDbGFzcyksMCksMzUpLGEoTyhHKCRlLmVBbm5vdGF0aW9uRUNsYXNzKSwxKSwxOSksYShPKEcoJGUuZUFubm90YXRpb25FQ2xhc3MpLDIpLDE5KSxhKE8oRygkZS5lQW5ub3RhdGlvbkVDbGFzcyksMyksMTkpLGEoTyhHKCRlLmVBbm5vdGF0aW9uRUNsYXNzKSw0KSwxOSksdF89JGUuZUNsYXNzRUNsYXNzLGEoTyhHKCRlLmVDbGFzc0VDbGFzcyksMCksMzUpLGEoTyhHKCRlLmVDbGFzc0VDbGFzcyksMSksMzUpLE5IZT1hKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDIpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDMpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDQpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDUpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDYpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDcpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDgpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDkpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDEwKSwxOSksYShPKEcoJGUuZUNsYXNzRUNsYXNzKSwxMSksMTkpLGEoTyhHKCRlLmVDbGFzc0VDbGFzcyksMTIpLDE5KSxhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDEzKSwxOSksYShPKEcoJGUuZUNsYXNzRUNsYXNzKSwxNCksMTkpLGEoTyhHKCRlLmVDbGFzc0VDbGFzcyksMTUpLDE5KSxhKE8oZXIoJGUuZUNsYXNzRUNsYXNzKSwwKSw2MiksYShPKGVyKCRlLmVDbGFzc0VDbGFzcyksMSksNjIpLGEoTyhlcigkZS5lQ2xhc3NFQ2xhc3MpLDIpLDYyKSxhKE8oZXIoJGUuZUNsYXNzRUNsYXNzKSwzKSw2MiksYShPKGVyKCRlLmVDbGFzc0VDbGFzcyksNCksNjIpLGEoTyhlcigkZS5lQ2xhc3NFQ2xhc3MpLDUpLDYyKSxhKE8oZXIoJGUuZUNsYXNzRUNsYXNzKSw2KSw2MiksYShPKGVyKCRlLmVDbGFzc0VDbGFzcyksNyksNjIpLGEoTyhlcigkZS5lQ2xhc3NFQ2xhc3MpLDgpLDYyKSxhKE8oZXIoJGUuZUNsYXNzRUNsYXNzKSw5KSw2MiksUEhlPSRlLmVDbGFzc2lmaWVyRUNsYXNzLGEoTyhHKCRlLmVDbGFzc2lmaWVyRUNsYXNzKSwwKSwzNSksYShPKEcoJGUuZUNsYXNzaWZpZXJFQ2xhc3MpLDEpLDM1KSxhKE8oRygkZS5lQ2xhc3NpZmllckVDbGFzcyksMiksMzUpLGEoTyhHKCRlLmVDbGFzc2lmaWVyRUNsYXNzKSwzKSwzNSksYShPKEcoJGUuZUNsYXNzaWZpZXJFQ2xhc3MpLDQpLDE5KSxhKE8oRygkZS5lQ2xhc3NpZmllckVDbGFzcyksNSksMTkpLGEoTyhlcigkZS5lQ2xhc3NpZmllckVDbGFzcyksMCksNjIpLGEoTyhlcigkZS5lQ2xhc3NpZmllckVDbGFzcyksMSksNjIpLEFIZT0kZS5lRGF0YVR5cGVFQ2xhc3MsYShPKEcoJGUuZURhdGFUeXBlRUNsYXNzKSwwKSwzNSksb189JGUuZUVudW1FQ2xhc3MsYShPKEcoJGUuZUVudW1FQ2xhc3MpLDApLDE5KSxhKE8oZXIoJGUuZUVudW1FQ2xhc3MpLDApLDYyKSxhKE8oZXIoJGUuZUVudW1FQ2xhc3MpLDEpLDYyKSxhKE8oZXIoJGUuZUVudW1FQ2xhc3MpLDIpLDYyKSxyMD0kZS5lRW51bUxpdGVyYWxFQ2xhc3MsYShPKEcoJGUuZUVudW1MaXRlcmFsRUNsYXNzKSwwKSwzNSksYShPKEcoJGUuZUVudW1MaXRlcmFsRUNsYXNzKSwxKSwzNSksYShPKEcoJGUuZUVudW1MaXRlcmFsRUNsYXNzKSwyKSwzNSksYShPKEcoJGUuZUVudW1MaXRlcmFsRUNsYXNzKSwzKSwxOSksaV89JGUuZUZhY3RvcnlFQ2xhc3MsYShPKEcoJGUuZUZhY3RvcnlFQ2xhc3MpLDApLDE5KSxhKE8oZXIoJGUuZUZhY3RvcnlFQ2xhc3MpLDApLDYyKSxhKE8oZXIoJGUuZUZhY3RvcnlFQ2xhc3MpLDEpLDYyKSxhKE8oZXIoJGUuZUZhY3RvcnlFQ2xhc3MpLDIpLDYyKSxMSGU9JGUuZU1vZGVsRWxlbWVudEVDbGFzcyxhKE8oRygkZS5lTW9kZWxFbGVtZW50RUNsYXNzKSwwKSwxOSksYShPKGVyKCRlLmVNb2RlbEVsZW1lbnRFQ2xhc3MpLDApLDYyKSxrSGU9JGUuZU5hbWVkRWxlbWVudEVDbGFzcyxhKE8oRygkZS5lTmFtZWRFbGVtZW50RUNsYXNzKSwwKSwzNSksTmw9JGUuZU9iamVjdEVDbGFzcyxhKE8oZXIoJGUuZU9iamVjdEVDbGFzcyksMCksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxKSw2MiksYShPKGVyKCRlLmVPYmplY3RFQ2xhc3MpLDIpLDYyKSxhKE8oZXIoJGUuZU9iamVjdEVDbGFzcyksMyksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSw0KSw2MiksYShPKGVyKCRlLmVPYmplY3RFQ2xhc3MpLDUpLDYyKSxhKE8oZXIoJGUuZU9iamVjdEVDbGFzcyksNiksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSw3KSw2MiksYShPKGVyKCRlLmVPYmplY3RFQ2xhc3MpLDgpLDYyKSxhKE8oZXIoJGUuZU9iamVjdEVDbGFzcyksOSksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxMCksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxMSksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxMiksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxMyksNjIpLGEoTyhlcigkZS5lT2JqZWN0RUNsYXNzKSwxNCksNjIpLHQwPSRlLmVPcGVyYXRpb25FQ2xhc3MsYShPKEcoJGUuZU9wZXJhdGlvbkVDbGFzcyksMCksMTkpLGEoTyhHKCRlLmVPcGVyYXRpb25FQ2xhc3MpLDIpLDE5KSxPSGU9YShPKEcoJGUuZU9wZXJhdGlvbkVDbGFzcyksMyksMTkpLGEoTyhHKCRlLmVPcGVyYXRpb25FQ2xhc3MpLDQpLDE5KSxhKE8oZXIoJGUuZU9wZXJhdGlvbkVDbGFzcyksMCksNjIpLGEoTyhlcigkZS5lT3BlcmF0aW9uRUNsYXNzKSwxKSw2MiksYShPKEcoJGUuZU9wZXJhdGlvbkVDbGFzcyksMSksMTkpLG8wPSRlLmVQYWNrYWdlRUNsYXNzLGEoTyhHKCRlLmVQYWNrYWdlRUNsYXNzKSwwKSwzNSksYShPKEcoJGUuZVBhY2thZ2VFQ2xhc3MpLDEpLDM1KSxhKE8oRygkZS5lUGFja2FnZUVDbGFzcyksMiksMTkpLGEoTyhHKCRlLmVQYWNrYWdlRUNsYXNzKSwzKSwxOSksYShPKEcoJGUuZVBhY2thZ2VFQ2xhc3MpLDQpLDE5KSxhKE8oRygkZS5lUGFja2FnZUVDbGFzcyksNSksMTkpLGEoTyhlcigkZS5lUGFja2FnZUVDbGFzcyksMCksNjIpLG9wPSRlLmVQYXJhbWV0ZXJFQ2xhc3MsYShPKEcoJGUuZVBhcmFtZXRlckVDbGFzcyksMCksMTkpLEJnPSRlLmVSZWZlcmVuY2VFQ2xhc3MsYShPKEcoJGUuZVJlZmVyZW5jZUVDbGFzcyksMCksMzUpLGEoTyhHKCRlLmVSZWZlcmVuY2VFQ2xhc3MpLDEpLDM1KSxhKE8oRygkZS5lUmVmZXJlbmNlRUNsYXNzKSwyKSwzNSksYShPKEcoJGUuZVJlZmVyZW5jZUVDbGFzcyksMyksMTkpLGEoTyhHKCRlLmVSZWZlcmVuY2VFQ2xhc3MpLDQpLDE5KSxhKE8oRygkZS5lUmVmZXJlbmNlRUNsYXNzKSw1KSwxOSksTUhlPSRlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcyxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDApLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDEpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDIpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDMpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDQpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDUpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDYpLDM1KSxhKE8oRygkZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDcpLDE5KSxhKE8oZXIoJGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSwwKSw2MiksYShPKGVyKCRlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcyksMSksNjIpLFJIZT0kZS5lVHlwZWRFbGVtZW50RUNsYXNzLGEoTyhHKCRlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDApLDM1KSxhKE8oRygkZS5lVHlwZWRFbGVtZW50RUNsYXNzKSwxKSwzNSksYShPKEcoJGUuZVR5cGVkRWxlbWVudEVDbGFzcyksMiksMzUpLGEoTyhHKCRlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDMpLDM1KSxhKE8oRygkZS5lVHlwZWRFbGVtZW50RUNsYXNzKSw0KSwzNSksYShPKEcoJGUuZVR5cGVkRWxlbWVudEVDbGFzcyksNSksMzUpLGEoTyhHKCRlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDYpLDE5KSxhKE8oRygkZS5lVHlwZWRFbGVtZW50RUNsYXNzKSw3KSwxOSksQnQ9JGUuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MsYShPKEcoJGUuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MpLDApLDM1KSxhKE8oRygkZS5lU3RyaW5nVG9TdHJpbmdNYXBFbnRyeUVDbGFzcyksMSksMzUpLEFkPSRlLmVHZW5lcmljVHlwZUVDbGFzcyxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDApLDE5KSxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDEpLDE5KSxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDIpLDE5KSxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDMpLDE5KSxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDQpLDE5KSxhKE8oRygkZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDUpLDE5KSxhKE8oZXIoJGUuZUdlbmVyaWNUeXBlRUNsYXNzKSwwKSw2MiksTGQ9JGUuZVR5cGVQYXJhbWV0ZXJFQ2xhc3MsYShPKEcoJGUuZVR5cGVQYXJhbWV0ZXJFQ2xhc3MpLDApLDE5KSxWcz0kZS5lSmF2YU9iamVjdEVEYXRhVHlwZX12YXIgbjAsdHAsdF8sUEhlLE5IZSxBSGUsb18scjAsaV8sQWQsVnMsTEhlLGtIZSxObCx0MCxPSGUsbzAsb3AsQmcsQnQsTUhlLFJIZSxMZCxwTD1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJGZWF0dXJlTWFwL0VudHJ5Iik7ZnVuY3Rpb24gZ0woZSxuKXt0aGlzLnZhbCRlQXR0cmlidXRlMT1lLHRoaXMudmFsJHZhbHVlMj1ufXAoNTQ1LDEsezc2OjF9LGdMKSxsLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbCRlQXR0cmlidXRlMX0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbCR2YWx1ZTJ9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiQmFzaWNFT2JqZWN0SW1wbC8xIiw1NDUpO2Z1bmN0aW9uIERIZShlLG4pe3RoaXMudGhpcyQwMT1lLHRoaXMudmFsJGVGZWF0dXJlMj1ufXAoMTA0MCwxLHc2LERIZSksbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gUlIodGhpcy50aGlzJDAxLHRoaXMudmFsJGVGZWF0dXJlMixuKX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHUkZSh0aGlzLnRoaXMkMDEsdGhpcy52YWwkZUZlYXR1cmUyKX0sbC5zZXRfMT1mdW5jdGlvbihuKXtIZWUodGhpcy50aGlzJDAxLHRoaXMudmFsJGVGZWF0dXJlMixuKX0sbC51bnNldD1mdW5jdGlvbigpe3B2bih0aGlzLnRoaXMkMDEsdGhpcy52YWwkZUZlYXR1cmUyKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJCYXNpY0VPYmplY3RJbXBsLzQiLDEwNDApO2Z1bmN0aW9uIEZIZSgpe0ZIZT1GLHpIZT1CKFFyLE1lLDEsMCw1LDEpfXAoMjA4MSwxLHsxMTQ6MX0pLGwuYWxsb2NhdGVTZXR0aW5ncz1mdW5jdGlvbihuKXt0aGlzLmVTZXR0aW5ncz1uPT0wP3pIZTpCKFFyLE1lLDEsbiw1LDEpfSxsLmR5bmFtaWNHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZVNldHRpbmdzW25dfSxsLmR5bmFtaWNTZXQ9ZnVuY3Rpb24obixyKXt0aGlzLmVTZXR0aW5nc1tuXT1yfSxsLmR5bmFtaWNVbnNldD1mdW5jdGlvbihuKXt0aGlzLmVTZXR0aW5nc1tuXT1udWxsfSxsLmdldEVDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVDbGFzc30sbC5nZXRFQ29udGVudHM9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuZ2V0RVByb3h5VVJJPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgVG4pfSxsLmdldEVSZXNvdXJjZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVSZXNvdXJjZX0sbC5oYXNTZXR0aW5ncz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVTZXR0aW5ncyE9bnVsbH0sbC5zZXRFQ2xhc3M9ZnVuY3Rpb24obil7dGhpcy5lQ2xhc3M9bn0sbC5zZXRFQ29udGVudHM9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnNldEVQcm94eVVSST1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBUbil9LGwuc2V0RVJlc291cmNlPWZ1bmN0aW9uKG4pe3RoaXMuZVJlc291cmNlPW59O3ZhciB6SGU7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJCYXNpY0VPYmplY3RJbXBsL0VQcm9wZXJ0aWVzSG9sZGVyQmFzZUltcGwiLDIwODEpO2Z1bmN0aW9uIHZzKCl7RkhlKCl9cCgxOTIsMjA4MSx7MTE0OjF9LHZzKSxsLmdldEVDb250ZW50cz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVDb250ZW50c30sbC5nZXRFUHJveHlVUkk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lUHJveHlVUkl9LGwuc2V0RUNvbnRlbnRzPWZ1bmN0aW9uKG4pe3RoaXMuZUNvbnRlbnRzPW59LGwuc2V0RVByb3h5VVJJPWZ1bmN0aW9uKG4pe3RoaXMuZVByb3h5VVJJPW59LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiQmFzaWNFT2JqZWN0SW1wbC9FUHJvcGVydGllc0hvbGRlckltcGwiLDE5Mik7ZnVuY3Rpb24gaEwoKXt9cCg1MTYsOTkseGllLGhMKSxsLmVCYXNpY0FkYXB0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZUFkYXB0ZXJzfSxsLmVCYXNpY1Byb3BlcnRpZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lUHJvcGVydGllc30sbC5lQmFzaWNTZXRDb250YWluZXI9ZnVuY3Rpb24obixyKXt0aGlzLmVDb250YWluZXI9bix0aGlzLmVDb250YWluZXJGZWF0dXJlSUQ9cn0sbC5lQ2xhc3NfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVGbGFncyYyP3RoaXMuZVByb3BlcnRpZXNfMCgpLmdldEVDbGFzcygpOnRoaXMuZVN0YXRpY0NsYXNzKCl9LGwuZUNvbnRhaW5lckZlYXR1cmVJRF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZUNvbnRhaW5lckZlYXR1cmVJRH0sbC5lRGVsaXZlcj1mdW5jdGlvbigpe3JldHVybih0aGlzLmVGbGFncyYxKSE9MH0sbC5lSW50ZXJuYWxDb250YWluZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQ29udGFpbmVyfSxsLmVJc1Byb3h5PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzJjQpIT0wfSxsLmVQcm9wZXJ0aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzfSxsLmVTZXRDbGFzcz1mdW5jdGlvbihuKXt0aGlzLmVQcm9wZXJ0aWVzXzAoKS5zZXRFQ2xhc3Mobiksbj90aGlzLmVGbGFnc3w9Mjp0aGlzLmVGbGFncyY9LTN9LGwuZVNldFByb3h5VVJJPWZ1bmN0aW9uKG4pe3RoaXMuZVByb3BlcnRpZXNfMCgpLnNldEVQcm94eVVSSShuKSxuP3RoaXMuZUZsYWdzfD00OnRoaXMuZUZsYWdzJj0tNX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4ocl8oKSwkZSkuZU9iamVjdEVDbGFzc30sbC5lQ29udGFpbmVyRmVhdHVyZUlEPTAsbC5lRmxhZ3M9MSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVPYmplY3RJbXBsIiw1MTYpO2Z1bmN0aW9uIExyZSgpe0xyZT1GLCRIZT1CKFFyLE1lLDEsMCw1LDEpfWZ1bmN0aW9uIGtyZShlKXtMcmUoKSxoTC5jYWxsKHRoaXMpLHRoaXMuZVNldENsYXNzKGUpfXAoNzk4LDUxNix7MTEwOjEsOTQ6MSw5MzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxfSxrcmUpLGwuZHluYW1pY0dldD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lU2V0dGluZ3Nbbl19LGwuZHluYW1pY1NldD1mdW5jdGlvbihuLHIpe3RoaXMuZVNldHRpbmdzW25dPXJ9LGwuZHluYW1pY1Vuc2V0PWZ1bmN0aW9uKG4pe3RoaXMuZVNldHRpbmdzW25dPW51bGx9LGwuZUNsYXNzXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQ2xhc3N9LGwuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEXzA9ZnVuY3Rpb24obil7cmV0dXJuIEVyKHRoaXMuZUNsYXNzLG4pfSxsLmVEeW5hbWljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQ2xhc3N9LGwuZUhhc1NldHRpbmdzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZVNldHRpbmdzIT1udWxsfSxsLmVQcm9wZXJ0aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IEdIZSksdGhpcy5lUHJvcGVydGllc30sbC5lU2V0Q2xhc3M9ZnVuY3Rpb24obil7dGhpcy5lQ2xhc3M9bn0sbC5lU2V0dGluZ3NfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLmVTZXR0aW5ncz09bnVsbCYmKG49b24odGhpcy5lQ2xhc3MpLHRoaXMuZVNldHRpbmdzPW49PTA/JEhlOkIoUXIsTWUsMSxuLDUsMSkpLHRoaXN9LGwuZVN0YXRpY0ZlYXR1cmVDb3VudD1mdW5jdGlvbigpe3JldHVybiAwfTt2YXIgJEhlO2coIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRHluYW1pY0VPYmplY3RJbXBsIiw3OTgpO2Z1bmN0aW9uIEJIZShlKXtMcmUoKSxrcmUuY2FsbCh0aGlzLGUpLHRoaXMuaGFzaD0tMX1wKDE1MjIsNzk4LHsxMTA6MSw0NDoxLDk0OjEsOTM6MSwxMzY6MSw1ODoxLDExNDoxLDU0OjEsOTk6MX0sQkhlKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5oYXNoQ29kZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFIxKHRoaXMpfSxsLmVTZXRDbGFzcz1mdW5jdGlvbihuKXt0aGlzLmVDbGFzcz1uLHRoaXMua2V5RmVhdHVyZT1tYihuLCJrZXkiKSx0aGlzLnZhbHVlRmVhdHVyZT1tYihuLCJ2YWx1ZSIpfSxsLmdldEhhc2g9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5oYXNoPT0tMSYmKG49RFIodGhpcyx0aGlzLmtleUZlYXR1cmUpLHRoaXMuaGFzaD1uPT1udWxsPzA6dXIobikpLHRoaXMuaGFzaH0sbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gRFIodGhpcyx0aGlzLmtleUZlYXR1cmUpfSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIERSKHRoaXMsdGhpcy52YWx1ZUZlYXR1cmUpfSxsLnNldEhhc2g9ZnVuY3Rpb24obil7dGhpcy5oYXNoPW59LGwuc2V0S2V5PWZ1bmN0aW9uKG4pe0hlZSh0aGlzLHRoaXMua2V5RmVhdHVyZSxuKX0sbC5zZXRWYWx1ZT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gcj1EUih0aGlzLHRoaXMudmFsdWVGZWF0dXJlKSxIZWUodGhpcyx0aGlzLnZhbHVlRmVhdHVyZSxuKSxyfSxsLmhhc2g9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkR5bmFtaWNFT2JqZWN0SW1wbC9CYXNpY0VNYXBFbnRyeSIsMTUyMik7ZnVuY3Rpb24gR0hlKCl7fXAoMTUyMywxLHsxMTQ6MX0sR0hlKSxsLmFsbG9jYXRlU2V0dGluZ3M9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmR5bmFtaWNHZXQ9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmR5bmFtaWNTZXQ9ZnVuY3Rpb24obixyKXt0aHJvdyBiKG5ldyBUbil9LGwuZHluYW1pY1Vuc2V0PWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5nZXRFQ2xhc3M9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuZ2V0RUNvbnRlbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZUNvbnRlbnRzfSxsLmdldEVQcm94eVVSST1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVQcm94eVVSSX0sbC5nZXRFUmVzb3VyY2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lUmVzb3VyY2V9LGwuaGFzU2V0dGluZ3M9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwuc2V0RUNsYXNzPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC5zZXRFQ29udGVudHM9ZnVuY3Rpb24obil7dGhpcy5lQ29udGVudHM9bn0sbC5zZXRFUHJveHlVUkk9ZnVuY3Rpb24obil7dGhpcy5lUHJveHlVUkk9bn0sbC5zZXRFUmVzb3VyY2U9ZnVuY3Rpb24obil7dGhpcy5lUmVzb3VyY2U9bn0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJEeW5hbWljRU9iamVjdEltcGwvRHluYW1pY0VQcm9wZXJ0aWVzSG9sZGVySW1wbCIsMTUyMyk7ZnVuY3Rpb24gT3JlKGUsbixyKXtyZXR1cm4gcj1HYShlLGEobiw1NCksMyxyKSxyfWZ1bmN0aW9uIE1yZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT0zP2UuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLDAsSlQsbik6KHQ9R3QoYShrZSgocj1hKEJlKGUsMTYpLDI5KSxyfHwoUGUoKSxuMCkpLGUuZUZsYWdzXzA+PjE2KSwxOSkpLGUuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLHQuZmVhdHVyZUlELHQuY29udGFpbmVyQ2xhc3MsbikpfWZ1bmN0aW9uIFZDbihlKXtyZXR1cm4hZS5jb250ZW50cyYmKGUuY29udGVudHM9bmV3IGpyKEswLGUsNCkpLGUuY29udGVudHN9ZnVuY3Rpb24gSEhlKGUpe3JldHVybiBlLmVGbGFnc18wPj4xNiE9Mz9udWxsOmEoZS5lQ29udGFpbmVyLDE1NSl9ZnVuY3Rpb24gVUhlKGUsbil7dmFyIHIsdDtpZihuIT1lLmVDb250YWluZXJ8fGUuZUZsYWdzXzA+PjE2IT0zJiZuKXtpZihmMihlLG4pKXRocm93IGIobmV3IEdlKCJSZWN1cnNpdmUgY29udGFpbm1lbnQgbm90IGFsbG93ZWQgZm9yICIrV0hlKGUpKSk7dD1udWxsLGUuZUNvbnRhaW5lciYmKHQ9KHI9ZS5lRmxhZ3NfMD4+MTYscj49MD9NcmUoZSx0KTplLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwtMS1yLG51bGwsdCkpKSxuJiYodD1hKG4sNTQpLmVJbnZlcnNlQWRkKGUsMCxKVCx0KSksdD1PcmUoZSxuLHQpLHQmJnQuZGlzcGF0Y2hfMCgpfWVsc2UgZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwzLG4sbikpfWZ1bmN0aW9uIHFDbihlLG4pe1JyZShlLG49PW51bGw/bnVsbDooVmUobiksbikpfWZ1bmN0aW9uIFJyZShlLG4pe3ZhciByO3I9ZS5zb3VyY2UsZS5zb3VyY2U9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDEscixlLnNvdXJjZSkpfWZ1bmN0aW9uIFdIZShlKXt2YXIgbjtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9ucyhlKToobj1uZXcgeWwobnMoZSkpLG4uc3RyaW5nKz0iIChzb3VyY2U6ICIsSnQobixlLnNvdXJjZSksbi5zdHJpbmcrPSIpIixuLnN0cmluZyl9ZnVuY3Rpb24gRHJlKCl7fXAoNTE5LDE1OCx7MTEwOjEsOTQ6MSw5MzoxLDU5ODoxLDE1NToxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDUxOToxLDE1ODoxLDExOToxLDEyMDoxfSxEcmUpLGwuZUJhc2ljUmVtb3ZlRnJvbUNvbnRhaW5lckZlYXR1cmU9ZnVuY3Rpb24obil7cmV0dXJuIE1yZSh0aGlzLG4pfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSx0aGlzLmVBbm5vdGF0aW9ucztjYXNlIDE6cmV0dXJuIHRoaXMuc291cmNlO2Nhc2UgMjpyZXR1cm4gdD8oIXRoaXMuZGV0YWlscyYmKHRoaXMuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHRoaXMpKSx0aGlzLmRldGFpbHMpOighdGhpcy5kZXRhaWxzJiYodGhpcy5kZXRhaWxzPW5ldyBiYSgoUGUoKSxCdCksQm8sdGhpcykpLHBiKHRoaXMuZGV0YWlscykpO2Nhc2UgMzpyZXR1cm4gSEhlKHRoaXMpO2Nhc2UgNDpyZXR1cm4hdGhpcy5jb250ZW50cyYmKHRoaXMuY29udGVudHM9bmV3IGpyKEswLHRoaXMsNCkpLHRoaXMuY29udGVudHM7Y2FzZSA1OnJldHVybiF0aGlzLnJlZmVyZW5jZXMmJih0aGlzLnJlZmVyZW5jZXM9bmV3IFdnKEswLHRoaXMsNSkpLHRoaXMucmVmZXJlbmNlc31yZXR1cm4gbGwodGhpcyxuLW9uKChQZSgpLG4wKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8bjApLG4pLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxoaSh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgMzpyZXR1cm4gdGhpcy5lQ29udGFpbmVyJiYodD0oaT10aGlzLmVGbGFnc18wPj4xNixpPj0wP01yZSh0aGlzLHQpOnRoaXMuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZSh0aGlzLC0xLWksbnVsbCx0KSkpLE9yZSh0aGlzLGEobiwxNTUpLHQpfXJldHVybiBzPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KFBlKCksbjApKSxyKSw2OSkscy5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZUFkZCh0aGlzLFNpKHRoaXMpLHItb24oKFBlKCksbjApKSxuLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLER0KHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSAyOnJldHVybiF0aGlzLmRldGFpbHMmJih0aGlzLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyx0aGlzKSksbUwodGhpcy5kZXRhaWxzLG4sdCk7Y2FzZSAzOnJldHVybiBPcmUodGhpcyxudWxsLHQpO2Nhc2UgNDpyZXR1cm4hdGhpcy5jb250ZW50cyYmKHRoaXMuY29udGVudHM9bmV3IGpyKEswLHRoaXMsNCkpLER0KHRoaXMuY29udGVudHMsbix0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLG4wKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLG4wKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLnNvdXJjZSE9bnVsbDtjYXNlIDI6cmV0dXJuISF0aGlzLmRldGFpbHMmJnRoaXMuZGV0YWlscy5zaXplXzAhPTA7Y2FzZSAzOnJldHVybiEhSEhlKHRoaXMpO2Nhc2UgNDpyZXR1cm4hIXRoaXMuY29udGVudHMmJnRoaXMuY29udGVudHMuc2l6ZV8wIT0wO2Nhc2UgNTpyZXR1cm4hIXRoaXMucmVmZXJlbmNlcyYmdGhpcy5yZWZlcmVuY2VzLnNpemVfMCE9MH1yZXR1cm4gc2wodGhpcyxuLW9uKChQZSgpLG4wKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8bjApLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6cUNuKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDI6IXRoaXMuZGV0YWlscyYmKHRoaXMuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHRoaXMpKSx5TCh0aGlzLmRldGFpbHMscik7cmV0dXJuO2Nhc2UgMzpVSGUodGhpcyxhKHIsMTU1KSk7cmV0dXJuO2Nhc2UgNDohdGhpcy5jb250ZW50cyYmKHRoaXMuY29udGVudHM9bmV3IGpyKEswLHRoaXMsNCkpLGZuKHRoaXMuY29udGVudHMpLCF0aGlzLmNvbnRlbnRzJiYodGhpcy5jb250ZW50cz1uZXcganIoSzAsdGhpcyw0KSksUHIodGhpcy5jb250ZW50cyxhKHIsMTYpKTtyZXR1cm47Y2FzZSA1OiF0aGlzLnJlZmVyZW5jZXMmJih0aGlzLnJlZmVyZW5jZXM9bmV3IFdnKEswLHRoaXMsNSkpLGZuKHRoaXMucmVmZXJlbmNlcyksIXRoaXMucmVmZXJlbmNlcyYmKHRoaXMucmVmZXJlbmNlcz1uZXcgV2coSzAsdGhpcyw1KSksUHIodGhpcy5yZWZlcmVuY2VzLGEociwxNikpO3JldHVybn11bCh0aGlzLG4tb24oKFBlKCksbjApKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHxuMCksbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksbjB9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJuO2Nhc2UgMTpScmUodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAyOiF0aGlzLmRldGFpbHMmJih0aGlzLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyx0aGlzKSksdGhpcy5kZXRhaWxzLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpO3JldHVybjtjYXNlIDM6VUhlKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgNDohdGhpcy5jb250ZW50cyYmKHRoaXMuY29udGVudHM9bmV3IGpyKEswLHRoaXMsNCkpLGZuKHRoaXMuY29udGVudHMpO3JldHVybjtjYXNlIDU6IXRoaXMucmVmZXJlbmNlcyYmKHRoaXMucmVmZXJlbmNlcz1uZXcgV2coSzAsdGhpcyw1KSksZm4odGhpcy5yZWZlcmVuY2VzKTtyZXR1cm59Y2wodGhpcyxuLW9uKChQZSgpLG4wKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8bjApLG4pKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIFdIZSh0aGlzKX0sbC5zb3VyY2U9bnVsbCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVBbm5vdGF0aW9uSW1wbCIsNTE5KTtmdW5jdGlvbiBZQ24oZSxuLHIpe2EoZS5kZWxlZ2F0ZUVMaXN0LDcxKS5hZGRVbmlxdWUobixyKX1mdW5jdGlvbiBLQ24oZSxuLHIpe3JldHVybiBhKGUuZGVsZWdhdGVFTGlzdCw3MSkuYmFzaWNBZGQobixyKX1mdW5jdGlvbiBtTChlLG4scil7cmV0dXJuIGEoZS5kZWxlZ2F0ZUVMaXN0LDcxKS5iYXNpY1JlbW92ZShuLHIpfWZ1bmN0aW9uIHlMKGUsbil7dmFyIHI7TChuLDg1KT8oYShlLmRlbGVnYXRlRUxpc3QsNzkpLnVuc2V0KCkscj1hKG4sODUpLGtHZShlLHIpKTphKGUuZGVsZWdhdGVFTGlzdCw3OSkuc2V0XzEobil9ZnVuY3Rpb24gWWkoZSxuLHIsdCl7dGhpcy5pbml0aWFsaXplRGVsZWdhdGVFTGlzdCgpLHRoaXMuZW50cnlDbGFzcz1uLHRoaXMuZW50cnlFQ2xhc3M9ZSx0aGlzLmRlbGVnYXRlRUxpc3Q9bmV3IGZvZSh0aGlzLG4scix0KX1wKDE0MSw3MjEsZXosWWkpLGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7WUNuKHRoaXMsbixhKHIsNDQpKX0sbC5iYXNpY0FkZD1mdW5jdGlvbihuLHIpe3JldHVybiBLQ24odGhpcyxhKG4sNDQpLHIpfSxsLmJhc2ljR2V0PWZ1bmN0aW9uKG4pe3JldHVybiBhKGEodGhpcy5kZWxlZ2F0ZUVMaXN0LDcxKS5iYXNpY0dldChuKSwxMzYpfSxsLmJhc2ljSXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLmRlbGVnYXRlRUxpc3QsNzEpLmJhc2ljSXRlcmF0b3IoKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMuZGVsZWdhdGVFTGlzdCw3MSkuYmFzaWNMaXN0SXRlcmF0b3IoKX0sbC5iYXNpY0xpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKHRoaXMuZGVsZWdhdGVFTGlzdCw3MSkuYmFzaWNMaXN0SXRlcmF0b3JfMChuKX0sbC5iYXNpY1JlbW92ZT1mdW5jdGlvbihuLHIpe3JldHVybiBtTCh0aGlzLG4scil9LGwuZ2V0XzY9ZnVuY3Rpb24obil7cmV0dXJuIGEodGhpcy5kZWxlZ2F0ZUVMaXN0LDc5KS5nZXRfNihuKX0sbC5pbml0aWFsaXplRGVsZWdhdGVFTGlzdD1mdW5jdGlvbigpe30sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5kZWxlZ2F0ZUVMaXN0LDc5KS5pc1NldF8wKCl9LGwubmV3RW50cnk9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3JldHVybiBvPWEoSGEodGhpcy5lbnRyeUVDbGFzcykuZ2V0RUZhY3RvcnlJbnN0YW5jZSgpLmNyZWF0ZV8zKHRoaXMuZW50cnlFQ2xhc3MpLDEzNiksby5zZXRIYXNoKG4pLG8uc2V0S2V5KHIpLG8uc2V0VmFsdWUodCksb30sbC5uZXdMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkb2UodGhpcyl9LGwuc2V0XzE9ZnVuY3Rpb24obil7eUwodGhpcyxuKX0sbC51bnNldD1mdW5jdGlvbigpe2EodGhpcy5kZWxlZ2F0ZUVMaXN0LDc5KS51bnNldCgpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlRU1hcCIsMTQxKTtmdW5jdGlvbiBiYShlLG4scil7WWkuY2FsbCh0aGlzLGUsbixyLDIpfXAoMTY1LDE0MSxleixiYSksbC5lbnN1cmVFbnRyeURhdGFFeGlzdHM9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHM7aWYodGhpcy5lbnRyeURhdGE9PW51bGwpe2ZvcihzPUIoZXJlLFFGLDY2LDIqdGhpcy5zaXplXzArMSwwLDEpLHQ9dGhpcy5kZWxlZ2F0ZUVMaXN0Lml0ZXJhdG9yXzAoKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KXI9YSh0LmRvTmV4dCgpLDEzNiksbz1yLmdldEhhc2goKSxpPShvJnFuKSVzLmxlbmd0aCxuPXNbaV0sIW4mJihuPXNbaV09bmV3IGRvZSh0aGlzKSksbi5hZGRfMihyKTt0aGlzLmVudHJ5RGF0YT1zfX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQW5ub3RhdGlvbkltcGwvMSIsMTY1KTtmdW5jdGlvbiBqSGUoZSxuLHIpe3ZhciB0LG8saTtyZXR1cm4gaT1lLmVHZW5lcmljVHlwZSxlLmVHZW5lcmljVHlwZT1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiYobz1uZXcgbHQoZSwxLDksaSxuKSxyP3IuYWRkXzUobyk6cj1vKSxuPyh0PW4uZVJhd1R5cGUsdCE9ZS5lVHlwZSYmKHI9ZS5zZXRFVHlwZSh0LHIpKSk6ZS5lVHlwZSYmKHI9ZS5zZXRFVHlwZShudWxsLHIpKSxyfWZ1bmN0aW9uIFJEKGUsbil7cmV0dXJuIG49ZS5zZXRFVHlwZShudWxsLG4pLGpIZShlLG51bGwsbil9ZnVuY3Rpb24gQWwoZSl7dmFyIG47cmV0dXJuIShlLmVGbGFncyYxKSYmZS5lVHlwZSYmZS5lVHlwZS5lSXNQcm94eSgpJiYobj1hKGUuZVR5cGUsNTQpLGUuZVR5cGU9YShKMChlLG4pLDE0MiksZS5lVHlwZSE9biYmZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsOSw4LG4sZS5lVHlwZSkpKSxlLmVUeXBlfWZ1bmN0aW9uIHFzKGUsbixyKXt2YXIgdDtyZXR1cm4gbiE9ZS5lR2VuZXJpY1R5cGU/KGUuZUdlbmVyaWNUeXBlJiYocj1BQShlLmVHZW5lcmljVHlwZSxlLC0xMCxyKSksbiYmKHI9aG0obixlLC0xMCxyKSkscj1qSGUoZSxuLHIpKTplLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmKHQ9bmV3IGx0KGUsMSw5LG4sbikscj9yLmFkZF81KHQpOnI9dCkscn1mdW5jdGlvbiBsMShlLG4pe3ZhciByLHQsbzt0PWUuc2V0RVR5cGUobixudWxsKSxvPW51bGwsbiYmKG89KFZ3KCkscj1uZXcgTWQsciksbzIobyxlLmVUeXBlKSksdD1xcyhlLG8sdCksdCYmdC5kaXNwYXRjaF8wKCl9ZnVuY3Rpb24gRnJlKGUsbixyKXt2YXIgdCxvO3JldHVybiBvPWUuZVR5cGUsZS5lVHlwZT1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiYodD1uZXcgbHQoZSwxLDgsbyxlLmVUeXBlKSxyP3IuYWRkXzUodCk6cj10KSxyfWZ1bmN0aW9uIGkwKGUsbil7dmFyIHI7cj1lLmxvd2VyQm91bmQsZS5sb3dlckJvdW5kPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHRGKGUsNCxyLGUubG93ZXJCb3VuZCkpfWZ1bmN0aW9uIGEwKGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmMjU2KSE9MCxuP2UuZUZsYWdzfD0yNTY6ZS5lRmxhZ3MmPS0yNTcsZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHJzKGUsMSwyLHIsbikpfWZ1bmN0aW9uIGwwKGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmNTEyKSE9MCxuP2UuZUZsYWdzfD01MTI6ZS5lRmxhZ3MmPS01MTMsZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHJzKGUsMSwzLHIsbikpfWZ1bmN0aW9uIGlwKGUsbil7dmFyIHI7cj1lLnVwcGVyQm91bmQsZS51cHBlckJvdW5kPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHRGKGUsNSxyLGUudXBwZXJCb3VuZCkpfWZ1bmN0aW9uIHpyZShlKXt2YXIgbjtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9jUyhlKToobj1uZXcgeWwoY1MoZSkpLG4uc3RyaW5nKz0iIChvcmRlcmVkOiAiLEFjKG4sKGUuZUZsYWdzJjI1NikhPTApLG4uc3RyaW5nKz0iLCB1bmlxdWU6ICIsQWMobiwoZS5lRmxhZ3MmNTEyKSE9MCksbi5zdHJpbmcrPSIsIGxvd2VyQm91bmQ6ICIsRDUobixlLmxvd2VyQm91bmQpLG4uc3RyaW5nKz0iLCB1cHBlckJvdW5kOiAiLEQ1KG4sZS51cHBlckJvdW5kKSxuLnN0cmluZys9IikiLG4uc3RyaW5nKX1mdW5jdGlvbiAkcmUoKXt0aGlzLmVGbGFnc3w9MjU2LHRoaXMuZUZsYWdzfD01MTJ9cCgyOTIsNDQ4LHsxMTA6MSw5NDoxLDkzOjEsMTU1OjEsMTk3OjEsNTg6MSwxMTQ6MSw0ODE6MSw1NDoxLDk5OjEsMTU4OjEsMjkyOjEsMTE5OjEsMTIwOjF9KSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzA7Y2FzZSAyOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJjI1Nik7Y2FzZSAzOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJjUxMik7Y2FzZSA0OnJldHVybiBKKHRoaXMubG93ZXJCb3VuZCk7Y2FzZSA1OnJldHVybiBKKHRoaXMudXBwZXJCb3VuZCk7Y2FzZSA2OnJldHVybiB6ZSgpLCEhdGhpcy5pc01hbnkoKTtjYXNlIDc6cmV0dXJuIHplKCksaT10aGlzLmxvd2VyQm91bmQsaT49MTtjYXNlIDg6cmV0dXJuIHI/QWwodGhpcyk6dGhpcy5lVHlwZTtjYXNlIDk6cmV0dXJuIHRoaXMuZUdlbmVyaWNUeXBlfXJldHVybiBsbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikscix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxEdCh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgOTpyZXR1cm4gUkQodGhpcyx0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fHRoaXMuZVN0YXRpY0NsYXNzKCkpLHIpLDY5KSxpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlUmVtb3ZlKHRoaXMsU2kodGhpcyksci1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxuLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXt2YXIgcix0O3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybih0aGlzLmVGbGFncyYyNTYpPT0wO2Nhc2UgMzpyZXR1cm4odGhpcy5lRmxhZ3MmNTEyKT09MDtjYXNlIDQ6cmV0dXJuIHRoaXMubG93ZXJCb3VuZCE9MDtjYXNlIDU6cmV0dXJuIHRoaXMudXBwZXJCb3VuZCE9MTtjYXNlIDY6cmV0dXJuIHRoaXMuaXNNYW55KCk7Y2FzZSA3OnJldHVybiB0PXRoaXMubG93ZXJCb3VuZCx0Pj0xO2Nhc2UgODpyZXR1cm4hIXRoaXMuZVR5cGUmJiF0aGlzLmVHZW5lcmljVHlwZS5lVHlwZVBhcmFtZXRlciYmT2QodGhpcy5lR2VuZXJpY1R5cGUpLnNpemVfMD09MDtjYXNlIDk6cmV0dXJuISF0aGlzLmVHZW5lcmljVHlwZSYmISh0aGlzLmVUeXBlJiYhdGhpcy5lR2VuZXJpY1R5cGUuZVR5cGVQYXJhbWV0ZXImJk9kKHRoaXMuZUdlbmVyaWNUeXBlKS5zaXplXzA9PTApfXJldHVybiBzbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdCxvO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyksIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxQcih0aGlzLmVBbm5vdGF0aW9ucyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxOnRoaXMuc2V0TmFtZSh4bihyKSk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMzpsMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgNDppMCh0aGlzLGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgNTp0aGlzLnNldFVwcGVyQm91bmQoYShyLDE3KS52YWx1ZV8wKTtyZXR1cm47Y2FzZSA4OmwxKHRoaXMsYShyLDE0MikpO3JldHVybjtjYXNlIDk6bz1xcyh0aGlzLGEociw4OSksbnVsbCksbyYmby5kaXNwYXRjaF8wKCk7cmV0dXJufXVsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxSSGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByLHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOnRoaXMuc2V0TmFtZShudWxsKTtyZXR1cm47Y2FzZSAyOmEwKHRoaXMsITApO3JldHVybjtjYXNlIDM6bDAodGhpcywhMCk7cmV0dXJuO2Nhc2UgNDppMCh0aGlzLDApO3JldHVybjtjYXNlIDU6dGhpcy5zZXRVcHBlckJvdW5kKDEpO3JldHVybjtjYXNlIDg6bDEodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA5OnQ9cXModGhpcyxudWxsLG51bGwpLHQmJnQuZGlzcGF0Y2hfMCgpO3JldHVybn1jbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmZyZWV6ZT1mdW5jdGlvbigpe0FsKHRoaXMpLHRoaXMuZUZsYWdzfD0xfSxsLmdldEVUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEFsKHRoaXMpfSxsLmdldFVwcGVyQm91bmQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHBlckJvdW5kfSxsLmlzTWFueT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMudXBwZXJCb3VuZCxuPjF8fG49PS0xfSxsLmlzVW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzJjUxMikhPTB9LGwuc2V0RVR5cGU9ZnVuY3Rpb24obixyKXtyZXR1cm4gRnJlKHRoaXMsbixyKX0sbC5zZXRVcHBlckJvdW5kPWZ1bmN0aW9uKG4pe2lwKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB6cmUodGhpcyl9LGwubG93ZXJCb3VuZD0wLGwudXBwZXJCb3VuZD0xLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVR5cGVkRWxlbWVudEltcGwiLDI5Mik7ZnVuY3Rpb24gVkhlKGUsbil7dmFyIHIsdDtyZXR1cm4gZS5lRmxhZ3NfMD4+MTY9PTE3P2UuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLDIxLElsLG4pOih0PUd0KGEoa2UoKHI9YShCZShlLDE2KSwyOSkscnx8ZS5lU3RhdGljQ2xhc3MoKSksZS5lRmxhZ3NfMD4+MTYpLDE5KSksZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsdC5mZWF0dXJlSUQsdC5jb250YWluZXJDbGFzcyxuKSl9ZnVuY3Rpb24gcXcoZSl7dmFyIG4scix0LG8saTtpZih0PUFsKGUpLGk9ZS5kZWZhdWx0VmFsdWVMaXRlcmFsLGk9PW51bGwmJnQpcmV0dXJuIGUuaXNNYW55KCk/bnVsbDp0LmdldERlZmF1bHRWYWx1ZSgpO2lmKEwodCwxNTYpKXtpZihyPXQuZ2V0RVBhY2thZ2UoKSxyJiYobz1yLmdldEVGYWN0b3J5SW5zdGFuY2UoKSxvIT1lLmRlZmF1bHRWYWx1ZUZhY3RvcnkpKXtpZihuPWEodCwxNTYpLG4uaXNTZXJpYWxpemFibGUoKSl0cnl7ZS5kZWZhdWx0VmFsdWU9by5jcmVhdGVGcm9tU3RyaW5nKG4saSl9Y2F0Y2gocyl7aWYocz13cihzKSxMKHMsODIpKWUuZGVmYXVsdFZhbHVlPW51bGw7ZWxzZSB0aHJvdyBiKHMpfWUuZGVmYXVsdFZhbHVlRmFjdG9yeT1vfXJldHVybiBlLmRlZmF1bHRWYWx1ZX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBhcChlKXtyZXR1cm4gZS5lRmxhZ3NfMD4+MTYhPTE3P251bGw6YShlLmVDb250YWluZXIsMjkpfWZ1bmN0aW9uIHdMKGUpe3ZhciBuO3JldHVybiBlLnByb3RvdHlwZUZlYXR1cmVNYXBFbnRyeXx8KG49ZS5nZXRFT3Bwb3NpdGUoKSxuP2UucHJvdG90eXBlRmVhdHVyZU1hcEVudHJ5PW5ldyB6dGUoZSxlLG51bGwpOmUuaXNDb250YWlubWVudCgpP2UucHJvdG90eXBlRmVhdHVyZU1hcEVudHJ5PW5ldyBTdGUoZSxudWxsKTpSZCh1bygoS2koKSxUdCksZSkpPT0xP2UucHJvdG90eXBlRmVhdHVyZU1hcEVudHJ5PW5ldyBMV2UoZSk6ZS5wcm90b3R5cGVGZWF0dXJlTWFwRW50cnk9bmV3IGZGKGUsbnVsbCkpLGUucHJvdG90eXBlRmVhdHVyZU1hcEVudHJ5fWZ1bmN0aW9uIEREKGUpe3ZhciBuO3JldHVybiBlLmNhY2hlZEVUeXBlIT1lLmVUeXBlJiYobj1BbChlKSxlLmNhY2hlZElzRmVhdHVyZU1hcD0hIW4mJm4uZ2V0SW5zdGFuY2VDbGFzc05hbWUoKT09Im9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsLkZlYXR1cmVNYXAkRW50cnkiLGUuY2FjaGVkRVR5cGU9biksZS5jYWNoZWRJc0ZlYXR1cmVNYXB9ZnVuY3Rpb24gWXcoZSxuKXt2YXIgcjtyPShlLmVGbGFncyZMbCkhPTAsbj9lLmVGbGFnc3w9TGw6ZS5lRmxhZ3MmPS0xMDI1LGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBycyhlLDEsMTAscixuKSl9ZnVuY3Rpb24gQnJlKGUsbil7ZS5kZWZhdWx0VmFsdWVGYWN0b3J5PW51bGwsRUwoZSxuKX1mdW5jdGlvbiBFTChlLG4pe3ZhciByO3I9ZS5kZWZhdWx0VmFsdWVMaXRlcmFsLGUuZGVmYXVsdFZhbHVlTGl0ZXJhbD1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMTMscixlLmRlZmF1bHRWYWx1ZUxpdGVyYWwpKX1mdW5jdGlvbiBLdyhlLG4pe3ZhciByO3I9KGUuZUZsYWdzJktzKSE9MCxuP2UuZUZsYWdzfD1LczplLmVGbGFncyY9LTE2Mzg1LGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBycyhlLDEsMTYscixuKSl9ZnVuY3Rpb24gWENuKGUsbil7ZS5mZWF0dXJlSUQ9bn1mdW5jdGlvbiBGRChlLG4pe0woZS5lQ29udGFpbmVyLDkwKSYmbHAoaGEoYShlLmVDb250YWluZXIsOTApKSw0KSxnaShlLG4pfWZ1bmN0aW9uIFh3KGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmSGQpIT0wLG4/ZS5lRmxhZ3N8PUhkOmUuZUZsYWdzJj0tNDA5NyxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgcnMoZSwxLDEyLHIsbikpfWZ1bmN0aW9uIEp3KGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmRmkpIT0wLG4/ZS5lRmxhZ3N8PUZpOmUuZUZsYWdzJj0tODE5MyxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgcnMoZSwxLDE1LHIsbikpfWZ1bmN0aW9uIFp3KGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmamQpIT0wLG4/ZS5lRmxhZ3N8PWpkOmUuZUZsYWdzJj0tMjA0OSxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgcnMoZSwxLDExLHIsbikpfWZ1bmN0aW9uIHZMKGUpe3ZhciBuO3JldHVybiBlLmVGbGFnc18wJjY0P3pyZShlKToobj1uZXcgeWwoenJlKGUpKSxuLnN0cmluZys9IiAoY2hhbmdlYWJsZTogIixBYyhuLChlLmVGbGFncyZMbCkhPTApLG4uc3RyaW5nKz0iLCB2b2xhdGlsZTogIixBYyhuLChlLmVGbGFncyZqZCkhPTApLG4uc3RyaW5nKz0iLCB0cmFuc2llbnQ6ICIsQWMobiwoZS5lRmxhZ3MmSGQpIT0wKSxuLnN0cmluZys9IiwgZGVmYXVsdFZhbHVlTGl0ZXJhbDogIixKdChuLGUuZGVmYXVsdFZhbHVlTGl0ZXJhbCksbi5zdHJpbmcrPSIsIHVuc2V0dGFibGU6ICIsQWMobiwoZS5lRmxhZ3MmRmkpIT0wKSxuLnN0cmluZys9IiwgZGVyaXZlZDogIixBYyhuLChlLmVGbGFncyZLcykhPTApLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfWZ1bmN0aW9uIHFIZSgpeyRyZS5jYWxsKHRoaXMpLHRoaXMuZmVhdHVyZUlEPS0xLHRoaXMuZGVmYXVsdFZhbHVlPW51bGwsdGhpcy5kZWZhdWx0VmFsdWVGYWN0b3J5PW51bGwsdGhpcy5kZWZhdWx0VmFsdWVMaXRlcmFsPW51bGwsdGhpcy5lRmxhZ3N8PUxsfXAoNDYyLDI5Mix7MTEwOjEsOTQ6MSw5MzoxLDE1NToxLDE5NzoxLDU4OjEsMTc5OjEsNjk6MSwxMTQ6MSw0ODE6MSw1NDoxLDk5OjEsMTU4OjEsNDYyOjEsMjkyOjEsMTE5OjEsMTIwOjEsNjkyOjF9KSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBWSGUodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSx0aGlzLmVBbm5vdGF0aW9ucztjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wO2Nhc2UgMjpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyYyNTYpO2Nhc2UgMzpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyY1MTIpO2Nhc2UgNDpyZXR1cm4gSih0aGlzLmxvd2VyQm91bmQpO2Nhc2UgNTpyZXR1cm4gSih0aGlzLnVwcGVyQm91bmQpO2Nhc2UgNjpyZXR1cm4gemUoKSwhIXRoaXMuaXNNYW55KCk7Y2FzZSA3OnJldHVybiB6ZSgpLGk9dGhpcy5sb3dlckJvdW5kLGk+PTE7Y2FzZSA4OnJldHVybiByP0FsKHRoaXMpOnRoaXMuZVR5cGU7Y2FzZSA5OnJldHVybiB0aGlzLmVHZW5lcmljVHlwZTtjYXNlIDEwOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkxsKTtjYXNlIDExOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJmpkKTtjYXNlIDEyOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkhkKTtjYXNlIDEzOnJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZUxpdGVyYWw7Y2FzZSAxNDpyZXR1cm4gcXcodGhpcyk7Y2FzZSAxNTpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyZGaSk7Y2FzZSAxNjpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyZLcyk7Y2FzZSAxNzpyZXR1cm4gYXAodGhpcyl9cmV0dXJuIGxsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksaGkodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDE3OnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShpPXRoaXMuZUZsYWdzXzA+PjE2LGk+PTA/VkhlKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtaSxudWxsLHQpKSksR2EodGhpcyxuLDE3LHQpfXJldHVybiBzPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8dGhpcy5lU3RhdGljQ2xhc3MoKSksciksNjkpLHMuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQodGhpcyxTaSh0aGlzKSxyLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4sdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksRHQodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDk6cmV0dXJuIFJEKHRoaXMsdCk7Y2FzZSAxNzpyZXR1cm4gR2EodGhpcyxudWxsLDE3LHQpfXJldHVybiBpPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8dGhpcy5lU3RhdGljQ2xhc3MoKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4sdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByLHQ7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMCE9bnVsbDtjYXNlIDI6cmV0dXJuKHRoaXMuZUZsYWdzJjI1Nik9PTA7Y2FzZSAzOnJldHVybih0aGlzLmVGbGFncyY1MTIpPT0wO2Nhc2UgNDpyZXR1cm4gdGhpcy5sb3dlckJvdW5kIT0wO2Nhc2UgNTpyZXR1cm4gdGhpcy51cHBlckJvdW5kIT0xO2Nhc2UgNjpyZXR1cm4gdGhpcy5pc01hbnkoKTtjYXNlIDc6cmV0dXJuIHQ9dGhpcy5sb3dlckJvdW5kLHQ+PTE7Y2FzZSA4OnJldHVybiEhdGhpcy5lVHlwZSYmIXRoaXMuZUdlbmVyaWNUeXBlLmVUeXBlUGFyYW1ldGVyJiZPZCh0aGlzLmVHZW5lcmljVHlwZSkuc2l6ZV8wPT0wO2Nhc2UgOTpyZXR1cm4hIXRoaXMuZUdlbmVyaWNUeXBlJiYhKHRoaXMuZVR5cGUmJiF0aGlzLmVHZW5lcmljVHlwZS5lVHlwZVBhcmFtZXRlciYmT2QodGhpcy5lR2VuZXJpY1R5cGUpLnNpemVfMD09MCk7Y2FzZSAxMDpyZXR1cm4odGhpcy5lRmxhZ3MmTGwpPT0wO2Nhc2UgMTE6cmV0dXJuKHRoaXMuZUZsYWdzJmpkKSE9MDtjYXNlIDEyOnJldHVybih0aGlzLmVGbGFncyZIZCkhPTA7Y2FzZSAxMzpyZXR1cm4gdGhpcy5kZWZhdWx0VmFsdWVMaXRlcmFsIT1udWxsO2Nhc2UgMTQ6cmV0dXJuIHF3KHRoaXMpIT1udWxsO2Nhc2UgMTU6cmV0dXJuKHRoaXMuZUZsYWdzJkZpKSE9MDtjYXNlIDE2OnJldHVybih0aGlzLmVGbGFncyZLcykhPTA7Y2FzZSAxNzpyZXR1cm4hIWFwKHRoaXMpfXJldHVybiBzbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdCxvO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyksIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxQcih0aGlzLmVBbm5vdGF0aW9ucyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxOkZEKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDI6YTAodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDM6bDAodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDQ6aTAodGhpcyxhKHIsMTcpLnZhbHVlXzApO3JldHVybjtjYXNlIDU6dGhpcy5zZXRVcHBlckJvdW5kKGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgODpsMSh0aGlzLGEociwxNDIpKTtyZXR1cm47Y2FzZSA5Om89cXModGhpcyxhKHIsODkpLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpO3JldHVybjtjYXNlIDEwOll3KHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAxMTpadyh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMTI6WHcodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDEzOkJyZSh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSAxNTpKdyh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMTY6S3codGhpcyxhZShpZShyKSkpO3JldHVybn11bCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHQ9YShCZSh0aGlzLDE2KSwyOSksdHx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksTUhlfSxsLmVVbnNldD1mdW5jdGlvbihuKXt2YXIgcix0O3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJuO2Nhc2UgMTpMKHRoaXMuZUNvbnRhaW5lciw5MCkmJmxwKGhhKGEodGhpcy5lQ29udGFpbmVyLDkwKSksNCksZ2kodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAyOmEwKHRoaXMsITApO3JldHVybjtjYXNlIDM6bDAodGhpcywhMCk7cmV0dXJuO2Nhc2UgNDppMCh0aGlzLDApO3JldHVybjtjYXNlIDU6dGhpcy5zZXRVcHBlckJvdW5kKDEpO3JldHVybjtjYXNlIDg6bDEodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA5OnQ9cXModGhpcyxudWxsLG51bGwpLHQmJnQuZGlzcGF0Y2hfMCgpO3JldHVybjtjYXNlIDEwOll3KHRoaXMsITApO3JldHVybjtjYXNlIDExOlp3KHRoaXMsITEpO3JldHVybjtjYXNlIDEyOlh3KHRoaXMsITEpO3JldHVybjtjYXNlIDEzOnRoaXMuZGVmYXVsdFZhbHVlRmFjdG9yeT1udWxsLEVMKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMTU6SncodGhpcywhMSk7cmV0dXJuO2Nhc2UgMTY6S3codGhpcywhMSk7cmV0dXJufWNsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSl9LGwuZnJlZXplPWZ1bmN0aW9uKCl7YzIodW8oKEtpKCksVHQpLHRoaXMpKSxBbCh0aGlzKSx0aGlzLmVGbGFnc3w9MX0sbC5nZXRDb250YWluZXJDbGFzcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRhaW5lckNsYXNzfSxsLmdldERlZmF1bHRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiBxdyh0aGlzKX0sbC5nZXRFQ29udGFpbmluZ0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIGFwKHRoaXMpfSxsLmdldEVPcHBvc2l0ZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldEV4dGVuZGVkTWV0YURhdGFfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZUV4dGVuZGVkTWV0YURhdGF9LGwuZ2V0RmVhdHVyZUlEXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mZWF0dXJlSUR9LGwuZ2V0RmVhdHVyZU1hcEVudHJ5UHJvdG90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIHdMKHRoaXMpfSxsLmdldFNldHRpbmdEZWxlZ2F0ZT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGkscyx1LGMsXztyZXR1cm4gdGhpcy5zZXR0aW5nRGVsZWdhdGV8fCh0PWFwKHRoaXMpLCh0LmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdSh0KSx0LmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKS5sZW5ndGgsbz10aGlzLmdldEVPcHBvc2l0ZSgpLG8mJm9uKGFwKG8pKSxpPUFsKHRoaXMpLHU9aS5nZXRJbnN0YW5jZUNsYXNzKCksbj11P3UubW9kaWZpZXJzJjE/dT09eWE/QXI6dT09aG4/dnQ6dT09cHA/YXk6dT09Y3Q/JHI6dT09X18/STE6dT09WGc/eDE6dT09Smk/dWg6RjI6dTpudWxsLHI9cXcodGhpcyksYz1pLmdldERlZmF1bHRWYWx1ZSgpLHdibih0aGlzKSx0aGlzLmVGbGFncyZLcyYmKChzPUp0ZSgoS2koKSxUdCksdCkpJiZzIT10aGlzfHwocz1QbSh1byhUdCx0aGlzKSkpKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgb1dlKHRoaXMscyk6dGhpcy5pc01hbnkoKT90aGlzLmlzQ29udGFpbm1lbnQoKT9vP3RoaXMuZUZsYWdzJkZpP24/dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgczEoNDcsbix0aGlzLG8pOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBzMSg1LG4sdGhpcyxvKTp0aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB1MSg0Nix0aGlzLG8pOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB1MSg0LHRoaXMsbyk6bj90aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBzMSg0OSxuLHRoaXMsbyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHMxKDcsbix0aGlzLG8pOnRoaXMuaXNSZXNvbHZlUHJveGllc18wKCk/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHUxKDQ4LHRoaXMsbyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHUxKDYsdGhpcyxvKTp0aGlzLmVGbGFncyZGaT9uP249PUVfP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCg1MCxGJGUsdGhpcyk6dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYzAoNDMsbix0aGlzKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYzAoMSxuLHRoaXMpOnRoaXMuaXNSZXNvbHZlUHJveGllc18wKCk/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IF8wKDQyLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfMCgwLHRoaXMpOm4/bj09RV8/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IGMwKDQxLEYkZSx0aGlzKTp0aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCg0NSxuLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCgzLG4sdGhpcyk6dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgXzAoNDQsdGhpcyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IF8wKDIsdGhpcyk6TChpLDE1Nik/bj09cEw/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IF8wKDQwLHRoaXMpOnRoaXMuZUZsYWdzJjUxMj90aGlzLmVGbGFncyZGaT9uP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCg5LG4sdGhpcyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IF8wKDgsdGhpcyk6bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYzAoMTEsbix0aGlzKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgXzAoMTAsdGhpcyk6dGhpcy5lRmxhZ3MmRmk/bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYzAoMTMsbix0aGlzKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgXzAoMTIsdGhpcyk6bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYzAoMTUsbix0aGlzKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgXzAoMTQsdGhpcyk6bz8oXz1vLnVwcGVyQm91bmQsXz4xfHxfPT0tMT90aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuZUZsYWdzJkZpP24/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHMxKDI1LG4sdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgdTEoMjQsdGhpcyxvKTpuP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBzMSgyNyxuLHRoaXMsbyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHUxKDI2LHRoaXMsbyk6dGhpcy5lRmxhZ3MmRmk/bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgczEoMjksbix0aGlzLG8pOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB1MSgyOCx0aGlzLG8pOm4/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHMxKDMxLG4sdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgdTEoMzAsdGhpcyxvKTp0aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuZUZsYWdzJkZpP24/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHMxKDMzLG4sdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgdTEoMzIsdGhpcyxvKTpuP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBzMSgzNSxuLHRoaXMsbyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHUxKDM0LHRoaXMsbyk6dGhpcy5lRmxhZ3MmRmk/bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgczEoMzcsbix0aGlzLG8pOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB1MSgzNix0aGlzLG8pOm4/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IHMxKDM5LG4sdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgdTEoMzgsdGhpcyxvKSk6dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLmVGbGFncyZGaT9uP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCgxNyxuLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfMCgxNix0aGlzKTpuP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCgxOSxuLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfMCgxOCx0aGlzKTp0aGlzLmVGbGFncyZGaT9uP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCgyMSxuLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfMCgyMCx0aGlzKTpuP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBjMCgyMyxuLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfMCgyMix0aGlzKTp0aGlzLmlzQ29udGFpbmVyKCk/dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYVdlKGEoaSwyOSksdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgQ3RlKGEoaSwyOSksdGhpcyxvKTpMKGksMTU2KT9uPT1wTD90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgXzAoNDAsdGhpcyk6dGhpcy5lRmxhZ3MmRmk/bj90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgdldlKHIsYyx0aGlzLCh1RigpLHU9PWhuP050ZTp1PT15YT9UdGU6dT09X18/QXRlOnU9PXBwP1B0ZTp1PT1jdD94dGU6dT09WGc/THRlOnU9PUppP2J0ZTp1PT1mbD9JdGU6Y0YpKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgRVdlKGEoaSwxNTYpLHIsYyx0aGlzKTpuP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB3V2UocixjLHRoaXMsKHVGKCksdT09aG4/TnRlOnU9PXlhP1R0ZTp1PT1fXz9BdGU6dT09cHA/UHRlOnU9PWN0P3h0ZTp1PT1YZz9MdGU6dT09Smk/YnRlOnU9PWZsP0l0ZTpjRikpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyB5V2UoYShpLDE1NikscixjLHRoaXMpOnRoaXMuaXNDb250YWlubWVudCgpP28/dGhpcy5lRmxhZ3MmRmk/dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgYldlKGEoaSwyOSksdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgTXRlKGEoaSwyOSksdGhpcyxvKTp0aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpP3RoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBUV2UoYShpLDI5KSx0aGlzLG8pOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBkRihhKGksMjkpLHRoaXMsbyk6dGhpcy5lRmxhZ3MmRmk/dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgQ1dlKGEoaSwyOSksdGhpcyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IE90ZShhKGksMjkpLHRoaXMpOnRoaXMuaXNSZXNvbHZlUHJveGllc18wKCk/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IFNXZShhKGksMjkpLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBfRihhKGksMjkpLHRoaXMpOnRoaXMuaXNSZXNvbHZlUHJveGllc18wKCk/bz90aGlzLmVGbGFncyZGaT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgeFdlKGEoaSwyOSksdGhpcyxvKTp0aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgRHRlKGEoaSwyOSksdGhpcyxvKTp0aGlzLmVGbGFncyZGaT90aGlzLnNldHRpbmdEZWxlZ2F0ZT1uZXcgSVdlKGEoaSwyOSksdGhpcyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IFJ0ZShhKGksMjkpLHRoaXMpOm8/dGhpcy5lRmxhZ3MmRmk/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IE5XZShhKGksMjkpLHRoaXMsbyk6dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IEZ0ZShhKGksMjkpLHRoaXMsbyk6dGhpcy5lRmxhZ3MmRmk/dGhpcy5zZXR0aW5nRGVsZWdhdGU9bmV3IFBXZShhKGksMjkpLHRoaXMpOnRoaXMuc2V0dGluZ0RlbGVnYXRlPW5ldyBNTChhKGksMjkpLHRoaXMpKSx0aGlzLnNldHRpbmdEZWxlZ2F0ZX0sbC5pc0NoYW5nZWFibGU9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5lRmxhZ3MmTGwpIT0wfSxsLmlzQ29udGFpbmVyPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNDb250YWlubWVudD1mdW5jdGlvbigpe3JldHVybiExfSxsLmlzRGVyaXZlZD1mdW5jdGlvbigpe3JldHVybih0aGlzLmVGbGFncyZLcykhPTB9LGwuaXNGZWF0dXJlTWFwXzA9ZnVuY3Rpb24oKXtyZXR1cm4gREQodGhpcyl9LGwuaXNSZXNvbHZlUHJveGllc18wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNVbnNldHRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzJkZpKSE9MH0sbC5zZXRFeHRlbmRlZE1ldGFEYXRhXzA9ZnVuY3Rpb24obil7dGhpcy5lU3RydWN0dXJhbEZlYXR1cmVFeHRlbmRlZE1ldGFEYXRhPW59LGwuc2V0TmFtZT1mdW5jdGlvbihuKXtGRCh0aGlzLG4pfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdkwodGhpcyl9LGwuY2FjaGVkSXNGZWF0dXJlTWFwPSExLGwuZmVhdHVyZUlEPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsIiw0NjIpO2Z1bmN0aW9uIFlIZShlKXt2YXIgbjtyZXR1cm4gZS5lQXR0cmlidXRlVHlwZXx8KG49ZS5lVHlwZSxMKG4sMTU2KSYmKGUuZUF0dHJpYnV0ZVR5cGU9YShuLDE1NikpKSxlLmVBdHRyaWJ1dGVUeXBlfWZ1bmN0aW9uIHpEKGUpe3ZhciBuO3JldHVybighZS5lQXR0cmlidXRlVHlwZXx8IShlLmVGbGFncyYxKSYmZS5lQXR0cmlidXRlVHlwZS5lSXNQcm94eSgpKSYmKG49QWwoZSksTChuLDE1NikmJihlLmVBdHRyaWJ1dGVUeXBlPWEobiwxNTYpKSksZS5lQXR0cmlidXRlVHlwZX1mdW5jdGlvbiBHcmUoZSl7dmFyIG4scjtzd2l0Y2goZS5lZmZlY3RpdmVJc01hbnkpe2Nhc2UtMTpyZXR1cm4hMDtjYXNlIDA6cmV0dXJuIHI9ZS51cHBlckJvdW5kLHI+MXx8cj09LTE/KGUuZWZmZWN0aXZlSXNNYW55PS0xLCEwKToobj1BbChlKSxuJiYoSHQoKSxuLmdldEluc3RhbmNlQ2xhc3NOYW1lKCk9PSJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbC5GZWF0dXJlTWFwJEVudHJ5Iik/KGUuZWZmZWN0aXZlSXNNYW55PS0xLCEwKTooZS5lZmZlY3RpdmVJc01hbnk9MSwhMSkpO2RlZmF1bHQ6Y2FzZSAxOnJldHVybiExfX1mdW5jdGlvbiAkRChlLG4pe3ZhciByO3I9KGUuZUZsYWdzJkdvKSE9MCxuP2UuZUZsYWdzfD1HbzplLmVGbGFncyY9LTMyNzY5LGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBycyhlLDEsMTgscixuKSl9ZnVuY3Rpb24gS0hlKGUsbil7ZS5lZmZlY3RpdmVJc01hbnk9MCxpcChlLG4pfWZ1bmN0aW9uIEJEKCl7cUhlLmNhbGwodGhpcyl9cCgzMzEsNDYyLHsxMTA6MSw5NDoxLDkzOjEsMzU6MSwxNTU6MSwxOTc6MSw1ODoxLDE3OToxLDY5OjEsMTE0OjEsNDgxOjEsNTQ6MSw5OToxLDMzMToxLDE1ODoxLDQ2MjoxLDI5MjoxLDExOToxLDEyMDoxLDY5MjoxfSxCRCksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSx0aGlzLmVBbm5vdGF0aW9ucztjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wO2Nhc2UgMjpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyYyNTYpO2Nhc2UgMzpyZXR1cm4gemUoKSwhISh0aGlzLmVGbGFncyY1MTIpO2Nhc2UgNDpyZXR1cm4gSih0aGlzLmxvd2VyQm91bmQpO2Nhc2UgNTpyZXR1cm4gSih0aGlzLnVwcGVyQm91bmQpO2Nhc2UgNjpyZXR1cm4gemUoKSwhIUdyZSh0aGlzKTtjYXNlIDc6cmV0dXJuIHplKCksaT10aGlzLmxvd2VyQm91bmQsaT49MTtjYXNlIDg6cmV0dXJuIHI/QWwodGhpcyk6dGhpcy5lVHlwZTtjYXNlIDk6cmV0dXJuIHRoaXMuZUdlbmVyaWNUeXBlO2Nhc2UgMTA6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmTGwpO2Nhc2UgMTE6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmamQpO2Nhc2UgMTI6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmSGQpO2Nhc2UgMTM6cmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlTGl0ZXJhbDtjYXNlIDE0OnJldHVybiBxdyh0aGlzKTtjYXNlIDE1OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkZpKTtjYXNlIDE2OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJktzKTtjYXNlIDE3OnJldHVybiBhcCh0aGlzKTtjYXNlIDE4OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkdvKTtjYXNlIDE5OnJldHVybiByP3pEKHRoaXMpOllIZSh0aGlzKX1yZXR1cm4gbGwodGhpcyxuLW9uKChQZSgpLHRwKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8dHApLG4pLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByLHQ7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMCE9bnVsbDtjYXNlIDI6cmV0dXJuKHRoaXMuZUZsYWdzJjI1Nik9PTA7Y2FzZSAzOnJldHVybih0aGlzLmVGbGFncyY1MTIpPT0wO2Nhc2UgNDpyZXR1cm4gdGhpcy5sb3dlckJvdW5kIT0wO2Nhc2UgNTpyZXR1cm4gdGhpcy51cHBlckJvdW5kIT0xO2Nhc2UgNjpyZXR1cm4gR3JlKHRoaXMpO2Nhc2UgNzpyZXR1cm4gdD10aGlzLmxvd2VyQm91bmQsdD49MTtjYXNlIDg6cmV0dXJuISF0aGlzLmVUeXBlJiYhdGhpcy5lR2VuZXJpY1R5cGUuZVR5cGVQYXJhbWV0ZXImJk9kKHRoaXMuZUdlbmVyaWNUeXBlKS5zaXplXzA9PTA7Y2FzZSA5OnJldHVybiEhdGhpcy5lR2VuZXJpY1R5cGUmJiEodGhpcy5lVHlwZSYmIXRoaXMuZUdlbmVyaWNUeXBlLmVUeXBlUGFyYW1ldGVyJiZPZCh0aGlzLmVHZW5lcmljVHlwZSkuc2l6ZV8wPT0wKTtjYXNlIDEwOnJldHVybih0aGlzLmVGbGFncyZMbCk9PTA7Y2FzZSAxMTpyZXR1cm4odGhpcy5lRmxhZ3MmamQpIT0wO2Nhc2UgMTI6cmV0dXJuKHRoaXMuZUZsYWdzJkhkKSE9MDtjYXNlIDEzOnJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZUxpdGVyYWwhPW51bGw7Y2FzZSAxNDpyZXR1cm4gcXcodGhpcykhPW51bGw7Y2FzZSAxNTpyZXR1cm4odGhpcy5lRmxhZ3MmRmkpIT0wO2Nhc2UgMTY6cmV0dXJuKHRoaXMuZUZsYWdzJktzKSE9MDtjYXNlIDE3OnJldHVybiEhYXAodGhpcyk7Y2FzZSAxODpyZXR1cm4odGhpcy5lRmxhZ3MmR28pIT0wO2Nhc2UgMTk6cmV0dXJuISFZSGUodGhpcyl9cmV0dXJuIHNsKHRoaXMsbi1vbigoUGUoKSx0cCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fHRwKSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0LG87c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6RkQodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMzpsMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgNDppMCh0aGlzLGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgNTpLSGUodGhpcyxhKHIsMTcpLnZhbHVlXzApO3JldHVybjtjYXNlIDg6bDEodGhpcyxhKHIsMTQyKSk7cmV0dXJuO2Nhc2UgOTpvPXFzKHRoaXMsYShyLDg5KSxudWxsKSxvJiZvLmRpc3BhdGNoXzAoKTtyZXR1cm47Y2FzZSAxMDpZdyh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMTE6WncodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDEyOlh3KHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAxMzpCcmUodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMTU6SncodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDE2Okt3KHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAxODokRCh0aGlzLGFlKGllKHIpKSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSx0cCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fHRwKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSx0cH0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHIsdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpO3JldHVybjtjYXNlIDE6TCh0aGlzLmVDb250YWluZXIsOTApJiZscChoYShhKHRoaXMuZUNvbnRhaW5lciw5MCkpLDQpLGdpKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLCEwKTtyZXR1cm47Y2FzZSAzOmwwKHRoaXMsITApO3JldHVybjtjYXNlIDQ6aTAodGhpcywwKTtyZXR1cm47Y2FzZSA1OnRoaXMuZWZmZWN0aXZlSXNNYW55PTAsaXAodGhpcywxKTtyZXR1cm47Y2FzZSA4OmwxKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgOTp0PXFzKHRoaXMsbnVsbCxudWxsKSx0JiZ0LmRpc3BhdGNoXzAoKTtyZXR1cm47Y2FzZSAxMDpZdyh0aGlzLCEwKTtyZXR1cm47Y2FzZSAxMTpadyh0aGlzLCExKTtyZXR1cm47Y2FzZSAxMjpYdyh0aGlzLCExKTtyZXR1cm47Y2FzZSAxMzp0aGlzLmRlZmF1bHRWYWx1ZUZhY3Rvcnk9bnVsbCxFTCh0aGlzLG51bGwpO3JldHVybjtjYXNlIDE1Okp3KHRoaXMsITEpO3JldHVybjtjYXNlIDE2Okt3KHRoaXMsITEpO3JldHVybjtjYXNlIDE4OiREKHRoaXMsITEpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCksdHApKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0cCksbikpfSxsLmZyZWV6ZT1mdW5jdGlvbigpe3pEKHRoaXMpLGMyKHVvKChLaSgpLFR0KSx0aGlzKSksQWwodGhpcyksdGhpcy5lRmxhZ3N8PTF9LGwuaXNNYW55PWZ1bmN0aW9uKCl7cmV0dXJuIEdyZSh0aGlzKX0sbC5zZXRFVHlwZT1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmVmZmVjdGl2ZUlzTWFueT0wLHRoaXMuZUF0dHJpYnV0ZVR5cGU9bnVsbCxGcmUodGhpcyxuLHIpfSxsLnNldFVwcGVyQm91bmQ9ZnVuY3Rpb24obil7S0hlKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLmVGbGFnc18wJjY0P3ZMKHRoaXMpOihuPW5ldyB5bCh2TCh0aGlzKSksbi5zdHJpbmcrPSIgKGlEOiAiLEFjKG4sKHRoaXMuZUZsYWdzJkdvKSE9MCksbi5zdHJpbmcrPSIpIixuLnN0cmluZyl9LGwuZWZmZWN0aXZlSXNNYW55PTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQXR0cmlidXRlSW1wbCIsMzMxKTtmdW5jdGlvbiBRdyhlKXtyZXR1cm4gZS5lRmxhZ3NfMD4+MTYhPTY/bnVsbDphKGUuZUNvbnRhaW5lciwyNDEpfWZ1bmN0aW9uIGUyKGUsbil7ZS5pbnN0YW5jZUNsYXNzTmFtZT09bnVsbCYmZS5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZSE9bnVsbCYmKGUuaW5zdGFuY2VDbGFzc05hbWU9ZS5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZSxlLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lPW51bGwpLFdEKGUsbj09bnVsbD9udWxsOihWZShuKSxuKSksZS5pbnN0YW5jZUNsYXNzJiZlLnNldEluc3RhbmNlQ2xhc3NHZW4obnVsbCl9ZnVuY3Rpb24gbjIoZSxuKXt2YXIgcjtyPWUuaW5zdGFuY2VUeXBlTmFtZSxlLmluc3RhbmNlVHlwZU5hbWU9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDUscixuKSl9ZnVuY3Rpb24gR0QoZSxuKXt2YXIgcix0O3JldHVybiBlLmVGbGFnc18wPj4xNj09Nj9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSw1LHlzLG4pOih0PUd0KGEoa2UoKHI9YShCZShlLDE2KSwyOSkscnx8ZS5lU3RhdGljQ2xhc3MoKSksZS5lRmxhZ3NfMD4+MTYpLDE5KSksZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsdC5mZWF0dXJlSUQsdC5jb250YWluZXJDbGFzcyxuKSl9ZnVuY3Rpb24gSGEoZSl7dmFyIG47cmV0dXJuIGUuZVBhY2thZ2U/ZS5lUGFja2FnZToobj1KQ24oZSksbiYmIW4uZUlzUHJveHkoKSYmKGUuZVBhY2thZ2U9biksbil9ZnVuY3Rpb24gSkNuKGUpe3JldHVybiBlLmVGbGFnc18wPj4xNiE9Nj9udWxsOmEoTVIoZSksMjQxKX1mdW5jdGlvbiBrZChlKXt2YXIgbjtpZighZS5pbnN0YW5jZUNsYXNzJiYoZS5pbnN0YW5jZUNsYXNzTmFtZSE9bnVsbHx8ZS5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZSE9bnVsbCkpaWYobj1aQ24oZSksbillLnNldEluc3RhbmNlQ2xhc3NHZW4obik7ZWxzZSB0cnl7ZS5zZXRJbnN0YW5jZUNsYXNzR2VuKG51bGwpfWNhdGNoKHIpe2lmKHI9d3IociksIUwociw2MykpdGhyb3cgYihyKX1yZXR1cm4gZS5pbnN0YW5jZUNsYXNzfWZ1bmN0aW9uIFpDbihlKXt2YXIgbixyLHQsbztpZihyPWUuaW5zdGFuY2VDbGFzc05hbWUhPW51bGw/ZS5pbnN0YW5jZUNsYXNzTmFtZTplLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lLG49b3Uocix4aSg5MSkpLG4hPS0xKXt0PShndCgwLG4sci5sZW5ndGgpLHIuc3Vic3RyKDAsbikpLG89bmV3IExjO2RvIG8uc3RyaW5nKz0iWyI7d2hpbGUoKG49c3kociw5MSwrK24pKSE9LTEpO1RlKHQsImJvb2xlYW4iKT9vLnN0cmluZys9IloiOlRlKHQsImJ5dGUiKT9vLnN0cmluZys9IkIiOlRlKHQsImNoYXIiKT9vLnN0cmluZys9IkMiOlRlKHQsImRvdWJsZSIpP28uc3RyaW5nKz0iRCI6VGUodCwiZmxvYXQiKT9vLnN0cmluZys9IkYiOlRlKHQsImludCIpP28uc3RyaW5nKz0iSSI6VGUodCwibG9uZyIpP28uc3RyaW5nKz0iSiI6VGUodCwic2hvcnQiKT9vLnN0cmluZys9IlMiOihvLnN0cmluZys9IkwiLG8uc3RyaW5nKz0iIit0LG8uc3RyaW5nKz0iOyIpO3RyeXtyZXR1cm4gbnVsbH1jYXRjaChpKXtpZihpPXdyKGkpLCFMKGksNjMpKXRocm93IGIoaSl9fWVsc2UgaWYob3Uocix4aSg0NikpPT0tMSl7aWYoVGUociwiYm9vbGVhbiIpKXJldHVybiB5YTtpZihUZShyLCJieXRlIikpcmV0dXJuIEppO2lmKFRlKHIsImNoYXIiKSlyZXR1cm4gZmw7aWYoVGUociwiZG91YmxlIikpcmV0dXJuIGN0O2lmKFRlKHIsImZsb2F0IikpcmV0dXJuIHBwO2lmKFRlKHIsImludCIpKXJldHVybiBobjtpZihUZShyLCJsb25nIikpcmV0dXJuIF9fO2lmKFRlKHIsInNob3J0IikpcmV0dXJuIFhnfXJldHVybiBudWxsfWZ1bmN0aW9uIEhEKGUsbil7dmFyIHIsdDtpZihuIT1udWxsKXtpZih0PWtkKGUpLHQpaWYodC5tb2RpZmllcnMmMSl7aWYodD09eWEpcmV0dXJuIFZkKG4pO2lmKHQ9PWhuKXJldHVybiBMKG4sMTcpO2lmKHQ9PXBwKXJldHVybiBMKG4sMTYxKTtpZih0PT1KaSlyZXR1cm4gTChuLDIyMik7aWYodD09ZmwpcmV0dXJuIEwobiwxODApO2lmKHQ9PWN0KXJldHVybiBxZChuKTtpZih0PT1YZylyZXR1cm4gTChuLDE5MSk7aWYodD09X18pcmV0dXJuIEwobiwxNjgpfWVsc2UgcmV0dXJuIGFMKCkscj1hKEtlKGxMLHQpLDU3KSwhcnx8ci5pc0luc3RhbmNlKG4pO2Vsc2UgaWYoTChuLDU4KSlyZXR1cm4gZS5keW5hbWljSXNJbnN0YW5jZShhKG4sNTgpKX1yZXR1cm4hMX1mdW5jdGlvbiBYSGUoZSxuKXtuP2UuZ2VuZXJhdGVkSW5zdGFuY2VDbGFzc05hbWU9PW51bGwmJihlLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lPWUuaW5zdGFuY2VDbGFzc05hbWUsZS5pbnN0YW5jZUNsYXNzTmFtZT1udWxsKTplLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lIT1udWxsJiYoZS5pbnN0YW5jZUNsYXNzTmFtZT1lLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lLGUuZ2VuZXJhdGVkSW5zdGFuY2VDbGFzc05hbWU9bnVsbCl9ZnVuY3Rpb24gUUNuKGUsbil7dmFyIHIsdCxvO2lmKCFuKVdEKGUsbnVsbCksbjIoZSxudWxsKTtlbHNlIGlmKG4ubW9kaWZpZXJzJjQpZm9yKHQ9IltdIixyPW4uY29tcG9uZW50VHlwZTs7cj1yLmNvbXBvbmVudFR5cGUpe2lmKCEoci5tb2RpZmllcnMmNCkpe289dUIoKEp1KHIpLHIudHlwZU5hbWUrdCkpLFdEKGUsbyksbjIoZSxvKTticmVha310Kz0iW10ifWVsc2Ugbz11QigoSnUobiksbi50eXBlTmFtZSkpLFdEKGUsbyksbjIoZSxvKTtlLnNldEluc3RhbmNlQ2xhc3NHZW4obil9ZnVuY3Rpb24gVUQoZSxuKXtlMihlLG4pLG4yKGUsZS5pbnN0YW5jZUNsYXNzTmFtZSl9ZnVuY3Rpb24gV0QoZSxuKXt2YXIgcjtyPWUuaW5zdGFuY2VDbGFzc05hbWUsZS5pbnN0YW5jZUNsYXNzTmFtZT1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDEsMixyLGUuaW5zdGFuY2VDbGFzc05hbWUpKX1mdW5jdGlvbiByMihlLG4pe3ZhciByLHQsbyxpO2k9ZS5pbnN0YW5jZVR5cGVOYW1lLG49PW51bGw/KGUuaW5zdGFuY2VUeXBlTmFtZT1udWxsLGUyKGUsbnVsbCkpOihlLmluc3RhbmNlVHlwZU5hbWU9KFZlKG4pLG4pLHQ9b3Uobix4aSg2MCkpLHQhPS0xPyhvPShndCgwLHQsbi5sZW5ndGgpLG4uc3Vic3RyKDAsdCkpLG91KG4seGkoNDYpKT09LTEmJiFUZShvLCJib29sZWFuIikmJiFUZShvLCJieXRlIikmJiFUZShvLCJjaGFyIikmJiFUZShvLCJkb3VibGUiKSYmIVRlKG8sImZsb2F0IikmJiFUZShvLCJpbnQiKSYmIVRlKG8sImxvbmciKSYmIVRlKG8sInNob3J0IikmJihvPSJqYXZhLmxhbmcuT2JqZWN0Iikscj1qSShuLHhpKDYyKSksciE9LTEmJihvKz0iIisoSGUocisxLG4ubGVuZ3RoKzEpLG4uc3Vic3RyKHIrMSkpKSxlMihlLG8pKToobz1uLG91KG4seGkoNDYpKT09LTEmJih0PW91KG4seGkoOTEpKSx0IT0tMSYmKG89KGd0KDAsdCxuLmxlbmd0aCksbi5zdWJzdHIoMCx0KSkpLCFUZShvLCJib29sZWFuIikmJiFUZShvLCJieXRlIikmJiFUZShvLCJjaGFyIikmJiFUZShvLCJkb3VibGUiKSYmIVRlKG8sImZsb2F0IikmJiFUZShvLCJpbnQiKSYmIVRlKG8sImxvbmciKSYmIVRlKG8sInNob3J0Iik/KG89ImphdmEubGFuZy5PYmplY3QiLHQhPS0xJiYobys9IiIrKEhlKHQsbi5sZW5ndGgrMSksbi5zdWJzdHIodCkpKSk6bz1uKSxlMihlLG8pLG89PW4mJihlLmluc3RhbmNlVHlwZU5hbWU9ZS5pbnN0YW5jZUNsYXNzTmFtZSkpKSxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDUsaSxuKSl9ZnVuY3Rpb24gU0woZSxuKXtMKGUuZUNvbnRhaW5lciwxODQpJiYoYShlLmVDb250YWluZXIsMTg0KS5lTmFtZVRvRUNsYXNzaWZpZXJNYXA9bnVsbCksZ2koZSxuKX1mdW5jdGlvbiBDTChlKXt2YXIgbjtyZXR1cm4gZS5lRmxhZ3NfMCY2ND9jUyhlKToobj1uZXcgeWwoY1MoZSkpLG4uc3RyaW5nKz0iIChpbnN0YW5jZUNsYXNzTmFtZTogIixKdChuLGUuaW5zdGFuY2VDbGFzc05hbWUpLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfXAoMzY0LDQ0OCx7MTEwOjEsOTQ6MSw5MzoxLDE0MjoxLDE1NToxLDE5NzoxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDM2NDoxLDE1ODoxLDExOToxLDEyMDoxLDY5MToxfSksbC5keW5hbWljSXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gbi5lQ2xhc3NfMCgpPT10aGlzfSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBHRCh0aGlzLG4pfSxsLmVCYXNpY1NldENvbnRhaW5lcj1mdW5jdGlvbihuLHIpe3RoaXMuZVBhY2thZ2U9bnVsbCx0aGlzLmVGbGFnc18wPXI8PDE2fHRoaXMuZUZsYWdzXzAmMjU1LHRoaXMuZUNvbnRhaW5lcj1ufSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSx0aGlzLmVBbm5vdGF0aW9ucztjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wO2Nhc2UgMjpyZXR1cm4gdGhpcy5pbnN0YW5jZUNsYXNzTmFtZSE9bnVsbD90aGlzLmluc3RhbmNlQ2xhc3NOYW1lOnRoaXMuZ2VuZXJhdGVkSW5zdGFuY2VDbGFzc05hbWU7Y2FzZSAzOnJldHVybiBrZCh0aGlzKTtjYXNlIDQ6cmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFZhbHVlKCk7Y2FzZSA1OnJldHVybiB0aGlzLmluc3RhbmNlVHlwZU5hbWU7Y2FzZSA2OnJldHVybiByP0hhKHRoaXMpOlF3KHRoaXMpO2Nhc2UgNzpyZXR1cm4hdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksdGhpcy5lVHlwZVBhcmFtZXRlcnN9cmV0dXJuIGxsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksaGkodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDY6cmV0dXJuIHRoaXMuZUNvbnRhaW5lciYmKHQ9KGk9dGhpcy5lRmxhZ3NfMD4+MTYsaT49MD9HRCh0aGlzLHQpOnRoaXMuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZSh0aGlzLC0xLWksbnVsbCx0KSkpLEdhKHRoaXMsbiw2LHQpfXJldHVybiBzPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8dGhpcy5lU3RhdGljQ2xhc3MoKSksciksNjkpLHMuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQodGhpcyxTaSh0aGlzKSxyLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4sdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksRHQodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDY6cmV0dXJuIEdhKHRoaXMsbnVsbCw2LHQpO2Nhc2UgNzpyZXR1cm4hdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksRHQodGhpcy5lVHlwZVBhcmFtZXRlcnMsbix0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fHRoaXMuZVN0YXRpY0NsYXNzKCkpLHIpLDY5KSxpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlUmVtb3ZlKHRoaXMsU2kodGhpcyksci1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxuLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiEhdGhpcy5lQW5ub3RhdGlvbnMmJnRoaXMuZUFubm90YXRpb25zLnNpemVfMCE9MDtjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wIT1udWxsO2Nhc2UgMjpyZXR1cm4gdGhpcy5pbnN0YW5jZUNsYXNzTmFtZSE9bnVsbCYmdGhpcy5pbnN0YW5jZUNsYXNzTmFtZT09dGhpcy5pbnN0YW5jZVR5cGVOYW1lO2Nhc2UgMzpyZXR1cm4hIWtkKHRoaXMpO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXREZWZhdWx0VmFsdWUoKSE9bnVsbDtjYXNlIDU6cmV0dXJuIHRoaXMuaW5zdGFuY2VUeXBlTmFtZSE9bnVsbCYmdGhpcy5pbnN0YW5jZVR5cGVOYW1lIT10aGlzLmluc3RhbmNlQ2xhc3NOYW1lJiZ0aGlzLmluc3RhbmNlVHlwZU5hbWUhPXRoaXMuZ2VuZXJhdGVkSW5zdGFuY2VDbGFzc05hbWU7Y2FzZSA2OnJldHVybiEhUXcodGhpcyk7Y2FzZSA3OnJldHVybiEhdGhpcy5lVHlwZVBhcmFtZXRlcnMmJnRoaXMuZVR5cGVQYXJhbWV0ZXJzLnNpemVfMCE9MH1yZXR1cm4gc2wodGhpcyxuLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6U0wodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMjpVRCh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSA1OnIyKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDc6IXRoaXMuZVR5cGVQYXJhbWV0ZXJzJiYodGhpcy5lVHlwZVBhcmFtZXRlcnM9bmV3IFhpKGJpLHRoaXMsNykpLGZuKHRoaXMuZVR5cGVQYXJhbWV0ZXJzKSwhdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksUHIodGhpcy5lVHlwZVBhcmFtZXRlcnMsYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxQSGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJuO2Nhc2UgMTpMKHRoaXMuZUNvbnRhaW5lciwxODQpJiYoYSh0aGlzLmVDb250YWluZXIsMTg0KS5lTmFtZVRvRUNsYXNzaWZpZXJNYXA9bnVsbCksZ2kodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAyOmUyKHRoaXMsbnVsbCksbjIodGhpcyx0aGlzLmluc3RhbmNlQ2xhc3NOYW1lKTtyZXR1cm47Y2FzZSA1OnIyKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgNzohdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksZm4odGhpcy5lVHlwZVBhcmFtZXRlcnMpO3JldHVybn1jbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8dGhpcy5lU3RhdGljQ2xhc3MoKSksbikpfSxsLmdldENsYXNzaWZpZXJJRD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLm1ldGFPYmplY3RJRD09LTEmJih0aGlzLm1ldGFPYmplY3RJRD0obj1IYSh0aGlzKSxuP3MwKG4uZ2V0RUNsYXNzaWZpZXJzKCksdGhpcyk6LTEpKSx0aGlzLm1ldGFPYmplY3RJRH0sbC5nZXREZWZhdWx0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sbC5nZXRFUGFja2FnZT1mdW5jdGlvbigpe3JldHVybiBIYSh0aGlzKX0sbC5nZXRFeHRlbmRlZE1ldGFEYXRhXzE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lQ2xhc3NpZmllckV4dGVuZGVkTWV0YURhdGF9LGwuZ2V0SW5zdGFuY2VDbGFzcz1mdW5jdGlvbigpe3JldHVybiBrZCh0aGlzKX0sbC5nZXRJbnN0YW5jZUNsYXNzTmFtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmluc3RhbmNlQ2xhc3NOYW1lIT1udWxsP3RoaXMuaW5zdGFuY2VDbGFzc05hbWU6dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZX0sbC5nZXRJbnN0YW5jZVR5cGVOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5zdGFuY2VUeXBlTmFtZX0sbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBIRCh0aGlzLG4pfSxsLnNldEV4dGVuZGVkTWV0YURhdGFfMT1mdW5jdGlvbihuKXt0aGlzLmVDbGFzc2lmaWVyRXh0ZW5kZWRNZXRhRGF0YT1ufSxsLnNldEdlbmVyYXRlZEluc3RhbmNlQ2xhc3M9ZnVuY3Rpb24obil7WEhlKHRoaXMsbil9LGwuc2V0SW5zdGFuY2VDbGFzc0dlbj1mdW5jdGlvbihuKXt0aGlzLmluc3RhbmNlQ2xhc3M9bn0sbC5zZXROYW1lPWZ1bmN0aW9uKG4pe1NMKHRoaXMsbil9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiBDTCh0aGlzKX0sbC5pbnN0YW5jZUNsYXNzPW51bGwsbC5pbnN0YW5jZUNsYXNzTmFtZT1udWxsLGwubWV0YU9iamVjdElEPS0xLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzaWZpZXJJbXBsIiwzNjQpO2Z1bmN0aW9uIGpEKCl7akQ9RixTUz1uZXcgdlVlLFlEPVAoSShSaSwxKSxFcCwxNzksMCxbXSksSkhlPVAoSSh4bCwxKSxueiw2MiwwLFtdKX1mdW5jdGlvbiBHZyhlKXt2YXIgbixyLHQsbyxpLHMsdSxjO2lmKCFlLmVBbGxBdHRyaWJ1dGVzKXtpZihlLmVJREF0dHJpYnV0ZT1udWxsLGM9bmV3IHNVZShlKSxuPW5ldyB1VWUscj1TUyx1PXIubWFwXzAucHV0KGUsciksdT09bnVsbCl7Zm9yKHM9bmV3IFllKHdvKGUpKTtzLmN1cnNvciE9cy50aGlzJDAxXzIuc2l6ZV8xKCk7KWk9YShlbihzKSwyOSksUHIoYyxHZyhpKSk7ci5tYXBfMC5yZW1vdmVfMChlKSE9bnVsbCxyLm1hcF8wLnNpemVfMSgpPT0wfWZvcihvPSghZS5lU3RydWN0dXJhbEZlYXR1cmVzJiYoZS5lU3RydWN0dXJhbEZlYXR1cmVzPW5ldyBVKFJpLGUsMjEsMTcpKSxuZXcgWWUoZS5lU3RydWN0dXJhbEZlYXR1cmVzKSk7by5jdXJzb3IhPW8udGhpcyQwMV8yLnNpemVfMSgpOyl0PWEoZW4obyksMTc5KSxMKHQsMzMxKSYmcG4obixhKHQsMzUpKTtKZihuKSxlLmVBdHRyaWJ1dGVzPW5ldyBjVWUoZSwoYShPKEcoKHJfKCksJGUpLmVDbGFzc0VDbGFzcyksNyksMTkpLG4uc2l6ZV8wKSxuLmRhdGFfMCksUHIoYyxlLmVBdHRyaWJ1dGVzKSxKZihjKSxlLmVBbGxBdHRyaWJ1dGVzPW5ldyBIZygoYShPKEcoJGUuZUNsYXNzRUNsYXNzKSw0KSwxOSksYy5zaXplXzApLGMuZGF0YV8wKSxoYShlKS5tb2RpZmllZFN0YXRlJj0tMn1yZXR1cm4gZS5lQWxsQXR0cmlidXRlc31mdW5jdGlvbiBIcmUoZSl7dmFyIG4scix0O2lmKCFlLmVBbGxDb250YWlubWVudHMpe2Zvcih0PW5ldyBmVWUscj1uZXcgQ20odlMoZSkpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKHZEKHIpLDE5KSxuLmVGbGFncyZHbyYmcG4odCxuKTtKZih0KSxlLmVBbGxDb250YWlubWVudHM9bmV3IEhnKChhKE8oRygocl8oKSwkZSkuZUNsYXNzRUNsYXNzKSw4KSwxOSksdC5zaXplXzApLHQuZGF0YV8wKSxoYShlKS5tb2RpZmllZFN0YXRlJj0tOX1yZXR1cm4gZS5lQWxsQ29udGFpbm1lbnRzfWZ1bmN0aW9uIFZEKGUpe3ZhciBuLHIsdCxvLGkscztpZighZS5lQWxsR2VuZXJpY1N1cGVyVHlwZXMpe2lmKHM9bmV3IGxVZSxuPVNTLGk9bi5tYXBfMC5wdXQoZSxuKSxpPT1udWxsKXtmb3IodD1uZXcgWWUoUW8oZSkpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDg5KSxvPVBMKHIpLEwobyw5MCkmJlByKHMsVkQoYShvLDI5KSkpLHBuKHMscik7bi5tYXBfMC5yZW1vdmVfMChlKSE9bnVsbCxuLm1hcF8wLnNpemVfMSgpPT0wfXMzbihzKSxKZihzKSxlLmVBbGxHZW5lcmljU3VwZXJUeXBlcz1uZXcgSGcoKGEoTyhHKChyXygpLCRlKS5lQ2xhc3NFQ2xhc3MpLDE1KSwxOSkscy5zaXplXzApLHMuZGF0YV8wKSxoYShlKS5tb2RpZmllZFN0YXRlJj0tMzN9cmV0dXJuIGUuZUFsbEdlbmVyaWNTdXBlclR5cGVzfWZ1bmN0aW9uIHFEKGUpe3ZhciBuLHIsdCxvLGkscyx1O2lmKCFlLmVBbGxPcGVyYXRpb25zKXtpZih1PW5ldyBkVWUsbj1TUyxpPW4ubWFwXzAucHV0KGUsbiksaT09bnVsbCl7Zm9yKHQ9bmV3IFllKHdvKGUpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KXI9YShlbih0KSwyOSksUHIodSxxRChyKSk7bi5tYXBfMC5yZW1vdmVfMChlKSE9bnVsbCxuLm1hcF8wLnNpemVfMSgpPT0wfWZvcihzPXUuc2l6ZV8wLG89KCFlLmVPcGVyYXRpb25zJiYoZS5lT3BlcmF0aW9ucz1uZXcgVSh4bCxlLDExLDEwKSksbmV3IFllKGUuZU9wZXJhdGlvbnMpKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KytzKWEoZW4obyksNDExKTtQcih1LCghZS5lT3BlcmF0aW9ucyYmKGUuZU9wZXJhdGlvbnM9bmV3IFUoeGwsZSwxMSwxMCkpLGUuZU9wZXJhdGlvbnMpKSxKZih1KSxlLmVBbGxPcGVyYXRpb25zPW5ldyBIZygoYShPKEcoKHJfKCksJGUpLmVDbGFzc0VDbGFzcyksOSksMTkpLHUuc2l6ZV8wKSx1LmRhdGFfMCksZS5lQWxsT3BlcmF0aW9uc0RhdGE9YSh1LmRhdGFfMCw2ODgpLGUuZUFsbE9wZXJhdGlvbnNEYXRhPT1udWxsJiYoZS5lQWxsT3BlcmF0aW9uc0RhdGE9SkhlKSxoYShlKS5tb2RpZmllZFN0YXRlJj0tMTd9cmV0dXJuIGUuZUFsbE9wZXJhdGlvbnN9ZnVuY3Rpb24gdlMoZSl7dmFyIG4scix0LG8saSxzLHUsYztpZighZS5lQWxsUmVmZXJlbmNlcyl7aWYoYz1uZXcgWHJlLHU9bmV3IFhyZSxuPVNTLHM9bi5tYXBfMC5wdXQoZSxuKSxzPT1udWxsKXtmb3IoaT1uZXcgWWUod28oZSkpO2kuY3Vyc29yIT1pLnRoaXMkMDFfMi5zaXplXzEoKTspbz1hKGVuKGkpLDI5KSxQcihjLHZTKG8pKTtuLm1hcF8wLnJlbW92ZV8wKGUpIT1udWxsLG4ubWFwXzAuc2l6ZV8xKCk9PTB9Zm9yKHQ9KCFlLmVTdHJ1Y3R1cmFsRmVhdHVyZXMmJihlLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9bmV3IFUoUmksZSwyMSwxNykpLG5ldyBZZShlLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KXI9YShlbih0KSwxNzkpLEwociwxMDIpJiZwbih1LGEociwxOSkpO0pmKHUpLGUuZVJlZmVyZW5jZXM9bmV3IF9VZShlLChhKE8oRygocl8oKSwkZSkuZUNsYXNzRUNsYXNzKSw2KSwxOSksdS5zaXplXzApLHUuZGF0YV8wKSxQcihjLGUuZVJlZmVyZW5jZXMpLEpmKGMpLGUuZUFsbFJlZmVyZW5jZXM9bmV3IEhnKChhKE8oRygkZS5lQ2xhc3NFQ2xhc3MpLDUpLDE5KSxjLnNpemVfMCksYy5kYXRhXzApLGhhKGUpLm1vZGlmaWVkU3RhdGUmPS0zfXJldHVybiBlLmVBbGxSZWZlcmVuY2VzfWZ1bmN0aW9uIEV1KGUpe3ZhciBuLHIsdCxvLGkscyx1O2lmKCFlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXMpe2lmKHU9bmV3IFhELG49U1Mscz1uLm1hcF8wLnB1dChlLG4pLHM9PW51bGwpe2Zvcih0PW5ldyBZZSh3byhlKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEoZW4odCksMjkpLFByKHUsRXUocikpO24ubWFwXzAucmVtb3ZlXzAoZSkhPW51bGwsbi5tYXBfMC5zaXplXzEoKT09MH1mb3Iobz11LnNpemVfMCxpPSghZS5lU3RydWN0dXJhbEZlYXR1cmVzJiYoZS5lU3RydWN0dXJhbEZlYXR1cmVzPW5ldyBVKFJpLGUsMjEsMTcpKSxuZXcgWWUoZS5lU3RydWN0dXJhbEZlYXR1cmVzKSk7aS5jdXJzb3IhPWkudGhpcyQwMV8yLnNpemVfMSgpOysrbylYQ24oYShlbihpKSw0NjIpLG8pO1ByKHUsKCFlLmVTdHJ1Y3R1cmFsRmVhdHVyZXMmJihlLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9bmV3IFUoUmksZSwyMSwxNykpLGUuZVN0cnVjdHVyYWxGZWF0dXJlcykpLEpmKHUpLGUuZUFsbFN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgaVVlKGUsdSksZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT1hKHUuZGF0YV8wLDI1NCksZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmKGUuZUFsbFN0cnVjdHVyYWxGZWF0dXJlc0RhdGE9WUQpLGUuZU5hbWVUb0ZlYXR1cmVNYXA9bnVsbCxoYShlKS5tb2RpZmllZFN0YXRlJj0tNX1yZXR1cm4gZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzfWZ1bmN0aW9uIFRMKGUpe3ZhciBuLHIsdCxvLGkscztpZighZS5lQWxsU3VwZXJUeXBlcyl7aWYocz1uZXcgRVVlLG49U1MsaT1uLm1hcF8wLnB1dChlLG4pLGk9PW51bGwpe2Zvcih0PW5ldyBZZSh3byhlKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEoZW4odCksMjkpLG89VEwociksUHIocyxvKSxwbihzLHIpO24ubWFwXzAucmVtb3ZlXzAoZSkhPW51bGx9SmYocyksZS5lQWxsU3VwZXJUeXBlcz1uZXcgSGcoKGEoTyhHKChyXygpLCRlKS5lQ2xhc3NFQ2xhc3MpLDExKSwxOSkscy5zaXplXzApLHMuZGF0YV8wKSxoYShlKS5tb2RpZmllZFN0YXRlJj0tMzN9cmV0dXJuIGUuZUFsbFN1cGVyVHlwZXN9ZnVuY3Rpb24gUW8oZSl7cmV0dXJuIGUuZUdlbmVyaWNTdXBlclR5cGVzfHwoaGEoZSksZS5lR2VuZXJpY1N1cGVyVHlwZXM9bmV3IHJVZShlLEt0LGUpLHdvKGUpKSxlLmVHZW5lcmljU3VwZXJUeXBlc31mdW5jdGlvbiBlcihlKXtyZXR1cm4hZS5lT3BlcmF0aW9ucyYmKGUuZU9wZXJhdGlvbnM9bmV3IFUoeGwsZSwxMSwxMCkpLGUuZU9wZXJhdGlvbnN9ZnVuY3Rpb24ga2UoZSxuKXt2YXIgcjtyZXR1cm4gcj0oZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmRXUoZSksZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YSksbj49MCYmbjxyLmxlbmd0aD9yW25dOm51bGx9ZnVuY3Rpb24gbWIoZSxuKXt2YXIgcix0LG8saSxzO2lmKChlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdShlKSxlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKS5sZW5ndGgsIWUuZU5hbWVUb0ZlYXR1cmVNYXApe2ZvcihzPW5ldyBFaCgoMyplLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXMuc2l6ZV8wLzJ8MCkrMSksbz1uZXcgQ20oZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzKTtvLmN1cnNvciE9by50aGlzJDAxXzIuc2l6ZV8xKCk7KXQ9YSh2RChvKSwxNzkpLGk9dC5nZXROYW1lKCkscj1hKGk9PW51bGw/ZGkocy5oYXNoQ29kZU1hcCxudWxsLHQpOmsxKHMuc3RyaW5nTWFwLGksdCksMTc5KSxyJiYoaT09bnVsbD9kaShzLmhhc2hDb2RlTWFwLG51bGwscik6azEocy5zdHJpbmdNYXAsaSxyKSk7ZS5lTmFtZVRvRmVhdHVyZU1hcD1zfXJldHVybiBhKG5pKGUuZU5hbWVUb0ZlYXR1cmVNYXAsbiksMTc5KX1mdW5jdGlvbiBHKGUpe3JldHVybiFlLmVTdHJ1Y3R1cmFsRmVhdHVyZXMmJihlLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9bmV3IFUoUmksZSwyMSwxNykpLGUuZVN0cnVjdHVyYWxGZWF0dXJlc31mdW5jdGlvbiBoYShlKXtyZXR1cm4gZS5lU3VwZXJBZGFwdGVyfHwoZS5lU3VwZXJBZGFwdGVyPW5ldyBvVWUoZSksZlMobmV3IE5qZShlKSwwLGUuZVN1cGVyQWRhcHRlcikpLGUuZVN1cGVyQWRhcHRlcn1mdW5jdGlvbiB3byhlKXtyZXR1cm4gZS5lU3VwZXJUeXBlc3x8KGhhKGUpLGUuZVN1cGVyVHlwZXM9bmV3IHlVZShlLGUpKSxlLmVTdXBlclR5cGVzfWZ1bmN0aW9uIG9uKGUpe3JldHVybihlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdShlKSxlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKS5sZW5ndGh9ZnVuY3Rpb24gRXIoZSxuKXt2YXIgcix0LG87aWYocj0oZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmRXUoZSksZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YSksdD1uLmdldEZlYXR1cmVJRF8wKCksdCE9LTEpe2ZvcihvPXIubGVuZ3RoO3Q8bzsrK3QpaWYoclt0XT09bilyZXR1cm4gdH1yZXR1cm4tMX1mdW5jdGlvbiBlM24oZSl7cmV0dXJuISFlLmVTdXBlclR5cGVzJiZRbyhlLmVTdXBlclR5cGVzLnRoaXMkMDEpLnNpemVfMCE9MCYmIShlLmVHZW5lcmljU3VwZXJUeXBlcyYmS0QoZS5lR2VuZXJpY1N1cGVyVHlwZXMpKX1mdW5jdGlvbiBuM24oZSxuKXtyZXR1cm4gbj09ZXx8V3coVEwobiksZSl9ZnVuY3Rpb24gVXJlKGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmMjU2KSE9MCxuP2UuZUZsYWdzfD0yNTY6ZS5lRmxhZ3MmPS0yNTcsZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHJzKGUsMSw4LHIsbikpfWZ1bmN0aW9uIFdyZShlLG4pe3ZhciByO3I9KGUuZUZsYWdzJjUxMikhPTAsbj9lLmVGbGFnc3w9NTEyOmUuZUZsYWdzJj0tNTEzLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBycyhlLDEsOSxyLG4pKX1mdW5jdGlvbiBqcmUoZSl7dmFyIG47cmV0dXJuIGUuZUZsYWdzXzAmNjQ/Q0woZSk6KG49bmV3IHlsKENMKGUpKSxuLnN0cmluZys9IiAoYWJzdHJhY3Q6ICIsQWMobiwoZS5lRmxhZ3MmMjU2KSE9MCksbi5zdHJpbmcrPSIsIGludGVyZmFjZTogIixBYyhuLChlLmVGbGFncyY1MTIpIT0wKSxuLnN0cmluZys9IikiLG4uc3RyaW5nKX1mdW5jdGlvbiBWcmUoKXtqRCgpfXAoOTAsMzY0LHsxMTA6MSw5NDoxLDkzOjEsMjk6MSwxNDI6MSwxNTU6MSwxOTc6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSw5MDoxLDM2NDoxLDE1ODoxLDQ4MjoxLDExOToxLDEyMDoxLDY5MToxfSxWcmUpLGwuZHluYW1pY0lzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIG4zbih0aGlzLG4uZUNsYXNzXzAoKSl9LGwuZUdldD1mdW5jdGlvbihuLHIsdCl7dmFyIG87c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzA7Y2FzZSAyOnJldHVybiB0aGlzLmluc3RhbmNlQ2xhc3NOYW1lIT1udWxsP3RoaXMuaW5zdGFuY2VDbGFzc05hbWU6dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZTtjYXNlIDM6cmV0dXJuIGtkKHRoaXMpO2Nhc2UgNDpyZXR1cm4gbnVsbDtjYXNlIDU6cmV0dXJuIHRoaXMuaW5zdGFuY2VUeXBlTmFtZTtjYXNlIDY6cmV0dXJuIHI/SGEodGhpcyk6UXcodGhpcyk7Y2FzZSA3OnJldHVybiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSx0aGlzLmVUeXBlUGFyYW1ldGVycztjYXNlIDg6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmMjU2KTtjYXNlIDk6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmNTEyKTtjYXNlIDEwOnJldHVybiB3byh0aGlzKTtjYXNlIDExOnJldHVybiF0aGlzLmVPcGVyYXRpb25zJiYodGhpcy5lT3BlcmF0aW9ucz1uZXcgVSh4bCx0aGlzLDExLDEwKSksdGhpcy5lT3BlcmF0aW9ucztjYXNlIDEyOnJldHVybiBHZyh0aGlzKTtjYXNlIDEzOnJldHVybiB2Uyh0aGlzKTtjYXNlIDE0OnJldHVybiB2Uyh0aGlzKSx0aGlzLmVSZWZlcmVuY2VzO2Nhc2UgMTU6cmV0dXJuIEdnKHRoaXMpLHRoaXMuZUF0dHJpYnV0ZXM7Y2FzZSAxNjpyZXR1cm4gSHJlKHRoaXMpO2Nhc2UgMTc6cmV0dXJuIHFEKHRoaXMpO2Nhc2UgMTg6cmV0dXJuIEV1KHRoaXMpO2Nhc2UgMTk6cmV0dXJuIFRMKHRoaXMpO2Nhc2UgMjA6cmV0dXJuIEdnKHRoaXMpLHRoaXMuZUlEQXR0cmlidXRlO2Nhc2UgMjE6cmV0dXJuIXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcyYmKHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSx0aGlzLDIxLDE3KSksdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzO2Nhc2UgMjI6cmV0dXJuIFFvKHRoaXMpO2Nhc2UgMjM6cmV0dXJuIFZEKHRoaXMpfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCksdF8pKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHx0Xyksbikscix0KX0sbC5lSW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHM7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGhpKHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSA2OnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShpPXRoaXMuZUZsYWdzXzA+PjE2LGk+PTA/R0QodGhpcyx0KTp0aGlzLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUodGhpcywtMS1pLG51bGwsdCkpKSxHYSh0aGlzLG4sNix0KTtjYXNlIDExOnJldHVybiF0aGlzLmVPcGVyYXRpb25zJiYodGhpcy5lT3BlcmF0aW9ucz1uZXcgVSh4bCx0aGlzLDExLDEwKSksaGkodGhpcy5lT3BlcmF0aW9ucyxuLHQpO2Nhc2UgMjE6cmV0dXJuIXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcyYmKHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSx0aGlzLDIxLDE3KSksaGkodGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzLG4sdCl9cmV0dXJuIHM9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHwoUGUoKSx0XykpLHIpLDY5KSxzLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlQWRkKHRoaXMsU2kodGhpcyksci1vbigoUGUoKSx0XykpLG4sdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksRHQodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDY6cmV0dXJuIEdhKHRoaXMsbnVsbCw2LHQpO2Nhc2UgNzpyZXR1cm4hdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksRHQodGhpcy5lVHlwZVBhcmFtZXRlcnMsbix0KTtjYXNlIDExOnJldHVybiF0aGlzLmVPcGVyYXRpb25zJiYodGhpcy5lT3BlcmF0aW9ucz1uZXcgVSh4bCx0aGlzLDExLDEwKSksRHQodGhpcy5lT3BlcmF0aW9ucyxuLHQpO2Nhc2UgMjE6cmV0dXJuIXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcyYmKHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSx0aGlzLDIxLDE3KSksRHQodGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzLG4sdCk7Y2FzZSAyMjpyZXR1cm4gRHQoUW8odGhpcyksbix0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLHRfKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLHRfKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMCE9bnVsbDtjYXNlIDI6cmV0dXJuIHRoaXMuaW5zdGFuY2VDbGFzc05hbWUhPW51bGwmJnRoaXMuaW5zdGFuY2VDbGFzc05hbWU9PXRoaXMuaW5zdGFuY2VUeXBlTmFtZTtjYXNlIDM6cmV0dXJuISFrZCh0aGlzKTtjYXNlIDQ6cmV0dXJuITE7Y2FzZSA1OnJldHVybiB0aGlzLmluc3RhbmNlVHlwZU5hbWUhPW51bGwmJnRoaXMuaW5zdGFuY2VUeXBlTmFtZSE9dGhpcy5pbnN0YW5jZUNsYXNzTmFtZSYmdGhpcy5pbnN0YW5jZVR5cGVOYW1lIT10aGlzLmdlbmVyYXRlZEluc3RhbmNlQ2xhc3NOYW1lO2Nhc2UgNjpyZXR1cm4hIVF3KHRoaXMpO2Nhc2UgNzpyZXR1cm4hIXRoaXMuZVR5cGVQYXJhbWV0ZXJzJiZ0aGlzLmVUeXBlUGFyYW1ldGVycy5zaXplXzAhPTA7Y2FzZSA4OnJldHVybih0aGlzLmVGbGFncyYyNTYpIT0wO2Nhc2UgOTpyZXR1cm4odGhpcy5lRmxhZ3MmNTEyKSE9MDtjYXNlIDEwOnJldHVybiEhdGhpcy5lU3VwZXJUeXBlcyYmUW8odGhpcy5lU3VwZXJUeXBlcy50aGlzJDAxKS5zaXplXzAhPTAmJiEodGhpcy5lR2VuZXJpY1N1cGVyVHlwZXMmJktEKHRoaXMuZUdlbmVyaWNTdXBlclR5cGVzKSk7Y2FzZSAxMTpyZXR1cm4hIXRoaXMuZU9wZXJhdGlvbnMmJnRoaXMuZU9wZXJhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTI6cmV0dXJuIEdnKHRoaXMpLnNpemVfMCE9MDtjYXNlIDEzOnJldHVybiB2Uyh0aGlzKS5zaXplXzAhPTA7Y2FzZSAxNDpyZXR1cm4gdlModGhpcyksdGhpcy5lUmVmZXJlbmNlcy5zaXplXzAhPTA7Y2FzZSAxNTpyZXR1cm4gR2codGhpcyksdGhpcy5lQXR0cmlidXRlcy5zaXplXzAhPTA7Y2FzZSAxNjpyZXR1cm4gSHJlKHRoaXMpLnNpemVfMCE9MDtjYXNlIDE3OnJldHVybiBxRCh0aGlzKS5zaXplXzAhPTA7Y2FzZSAxODpyZXR1cm4gRXUodGhpcykuc2l6ZV8wIT0wO2Nhc2UgMTk6cmV0dXJuIFRMKHRoaXMpLnNpemVfMCE9MDtjYXNlIDIwOnJldHVybiBHZyh0aGlzKSwhIXRoaXMuZUlEQXR0cmlidXRlO2Nhc2UgMjE6cmV0dXJuISF0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMmJnRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcy5zaXplXzAhPTA7Y2FzZSAyMjpyZXR1cm4hIXRoaXMuZUdlbmVyaWNTdXBlclR5cGVzJiZLRCh0aGlzLmVHZW5lcmljU3VwZXJUeXBlcyk7Y2FzZSAyMzpyZXR1cm4gVkQodGhpcykuc2l6ZV8wIT0wfXJldHVybiBzbCh0aGlzLG4tb24oKFBlKCksdF8pKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0XyksbikpfSxsLmVPYmplY3RGb3JVUklGcmFnbWVudFNlZ21lbnQ9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHI9dGhpcy5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbHx8dGhpcy5lT3BlcmF0aW9ucyYmdGhpcy5lT3BlcmF0aW9ucy5zaXplXzAhPTA/bnVsbDptYih0aGlzLG4pLHJ8fGhuZSh0aGlzLG4pfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpLCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksUHIodGhpcy5lQW5ub3RhdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTpTTCh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSAyOlVEKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDU6cjIodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgNzohdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksZm4odGhpcy5lVHlwZVBhcmFtZXRlcnMpLCF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSxQcih0aGlzLmVUeXBlUGFyYW1ldGVycyxhKHIsMTYpKTtyZXR1cm47Y2FzZSA4OlVyZSh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgOTpXcmUodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDEwOmhTKHdvKHRoaXMpKSxQcih3byh0aGlzKSxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxMTohdGhpcy5lT3BlcmF0aW9ucyYmKHRoaXMuZU9wZXJhdGlvbnM9bmV3IFUoeGwsdGhpcywxMSwxMCkpLGZuKHRoaXMuZU9wZXJhdGlvbnMpLCF0aGlzLmVPcGVyYXRpb25zJiYodGhpcy5lT3BlcmF0aW9ucz1uZXcgVSh4bCx0aGlzLDExLDEwKSksUHIodGhpcy5lT3BlcmF0aW9ucyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAyMTohdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzJiYodGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzPW5ldyBVKFJpLHRoaXMsMjEsMTcpKSxmbih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpLCF0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMmJih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9bmV3IFUoUmksdGhpcywyMSwxNykpLFByKHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAyMjpmbihRbyh0aGlzKSksUHIoUW8odGhpcyksYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSx0XykpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fHRfKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSx0X30sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOkwodGhpcy5lQ29udGFpbmVyLDE4NCkmJihhKHRoaXMuZUNvbnRhaW5lciwxODQpLmVOYW1lVG9FQ2xhc3NpZmllck1hcD1udWxsKSxnaSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDI6ZTIodGhpcyxudWxsKSxuMih0aGlzLHRoaXMuaW5zdGFuY2VDbGFzc05hbWUpO3JldHVybjtjYXNlIDU6cjIodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA3OiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSxmbih0aGlzLmVUeXBlUGFyYW1ldGVycyk7cmV0dXJuO2Nhc2UgODpVcmUodGhpcywhMSk7cmV0dXJuO2Nhc2UgOTpXcmUodGhpcywhMSk7cmV0dXJuO2Nhc2UgMTA6dGhpcy5lU3VwZXJUeXBlcyYmaFModGhpcy5lU3VwZXJUeXBlcyk7cmV0dXJuO2Nhc2UgMTE6IXRoaXMuZU9wZXJhdGlvbnMmJih0aGlzLmVPcGVyYXRpb25zPW5ldyBVKHhsLHRoaXMsMTEsMTApKSxmbih0aGlzLmVPcGVyYXRpb25zKTtyZXR1cm47Y2FzZSAyMTohdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzJiYodGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzPW5ldyBVKFJpLHRoaXMsMjEsMTcpKSxmbih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpO3JldHVybjtjYXNlIDIyOnRoaXMuZUdlbmVyaWNTdXBlclR5cGVzJiZmbih0aGlzLmVHZW5lcmljU3VwZXJUeXBlcyk7cmV0dXJufWNsKHRoaXMsbi1vbigoUGUoKSx0XykpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fHRfKSxuKSl9LGwuZnJlZXplPWZ1bmN0aW9uKCl7dmFyIG4scjtpZihHZyh0aGlzKSx2Uyh0aGlzKSxIcmUodGhpcykscUQodGhpcyksRXUodGhpcyksVEwodGhpcyksVkQodGhpcyksZ1MoaTNuKGhhKHRoaXMpKSksdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzKWZvcihuPTAscj10aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMuc2l6ZV8wO248cjsrK24pcmIoTyh0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMsbikpO2lmKHRoaXMuZU9wZXJhdGlvbnMpZm9yKG49MCxyPXRoaXMuZU9wZXJhdGlvbnMuc2l6ZV8wO248cjsrK24pcmIoTyh0aGlzLmVPcGVyYXRpb25zLG4pKTtkMCgoS2koKSxUdCksdGhpcykuZ2V0TmFtZSgpLHRoaXMuZUZsYWdzfD0xfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4ganJlKHRoaXMpfSxsLmVBdHRyaWJ1dGVzPW51bGwsbC5lUmVmZXJlbmNlcz1udWxsO3ZhciBTUyxKSGUsWUQ7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsIiw5MCkscCgyMDkyLDIwOTEsTGllKSxsLmFkZEFsbFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiB5RCh0aGlzLG4scil9LGwuYWRkQWxsVW5pcXVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIHlEKHRoaXMsdGhpcy5zaXplXzAsbil9LGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7Z3JlKHRoaXMsbixyKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXt3RCh0aGlzLG4pfSxsLmJhc2ljQWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIGhpKHRoaXMsbixyKX0sbC5iYXNpY0dldD1mdW5jdGlvbihuKXtyZXR1cm4gWG5lKHRoaXMsbil9LGwuYmFzaWNSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gRHQodGhpcyxuLHIpfSxsLnNldFVuaXF1ZT1mdW5jdGlvbihuLHIpe3JldHVybiBfR2UodGhpcyxuLHIpfSxsLmJhc2ljSXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IENtKHRoaXMpfSxsLmJhc2ljTGlzdEl0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkYih0aGlzKX0sbC5iYXNpY0xpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKG4pe3JldHVybiBhYih0aGlzLG4pfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIk5vdGlmeWluZ0ludGVybmFsRUxpc3RJbXBsIiwyMDkyKTtmdW5jdGlvbiBaSGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZihlLmlzRU9iamVjdCgpKXtpZihlLnNpemVfMD40KWlmKGUuaXNJbnN0YW5jZShuKSl7aWYoZS5pc0NvbnRhaW5tZW50KCkpe2lmKG89YShuLDU0KSx0PW8uZUNvbnRhaW5lcl8wKCksYz10PT1lLm93bmVyJiYoZS5oYXNOYXZpZ2FibGVJbnZlcnNlKCk/by5lQmFzZVN0cnVjdHVyYWxGZWF0dXJlSUQoby5lQ29udGFpbmVyRmVhdHVyZUlEXzAoKSxlLmdldEludmVyc2VGZWF0dXJlQ2xhc3MoKSk9PWUuZ2V0SW52ZXJzZUZlYXR1cmVJRCgpOi0xLW8uZUNvbnRhaW5lckZlYXR1cmVJRF8wKCk9PWUuZ2V0RmVhdHVyZUlEXzAoKSksZS5oYXNQcm94aWVzKCkmJiFjJiYhdCYmby5lRGlyZWN0UmVzb3VyY2UoKSl7Zm9yKGk9MDtpPGUuc2l6ZV8wOysraSlpZihyPWUucmVzb2x2ZVByb3h5KGEoZS5kYXRhXzBbaV0sNTgpKSxEKHIpPT09RChuKSlyZXR1cm4hMH1yZXR1cm4gY31lbHNlIGlmKGUuaGFzTmF2aWdhYmxlSW52ZXJzZSgpJiYhZS5oYXNNYW55SW52ZXJzZSgpKXtpZihzPWEobiw1OCkuZUdldF8wKEd0KGEoZS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSwxOSkpKSxEKHMpPT09RChlLm93bmVyKSlyZXR1cm4hMDtpZihzPT1udWxsfHwhYShzLDU4KS5lSXNQcm94eSgpKXJldHVybiExfX1lbHNlIHJldHVybiExO2lmKHU9V3coZSxuKSxlLmhhc1Byb3hpZXMoKSYmIXUpe2ZvcihpPTA7aTxlLnNpemVfMDsrK2kpaWYobz1lLnJlc29sdmVQcm94eShhKGUuZGF0YV8wW2ldLDU4KSksRChvKT09PUQobikpcmV0dXJuITB9cmV0dXJuIHV9ZWxzZSByZXR1cm4gV3coZSxuKX1mdW5jdGlvbiBDUyhlLG4scix0LG8saSl7cmV0dXJuIG5ldyBTYyhlLm93bmVyLG4sZS5nZXRGZWF0dXJlSURfMCgpLHIsdCxvLGkpfWZ1bmN0aW9uIHQyKGUsbil7WG4oZS5vd25lcixuKX1mdW5jdGlvbiBzMChlLG4pe3ZhciByLHQsbztpZihvPVZCZShlLG4pLG8+PTApcmV0dXJuIG87aWYoZS5pc0VPYmplY3QoKSl7Zm9yKHQ9MDt0PGUuc2l6ZV8wOysrdClpZihyPWUucmVzb2x2ZVByb3h5KGEoZS5kYXRhXzBbdF0sNTgpKSxEKHIpPT09RChuKSlyZXR1cm4gdH1yZXR1cm4tMX1mdW5jdGlvbiBJbShlLG4scil7dmFyIHQsbyxpLHMsdSxjO3JldHVybiB1PWUucmVzb2x2ZVByb3h5KHIpLHUhPXI/KHM9ZS5kYXRhXzBbbl0sYz11LHBTKGUsbixlLnZhbGlkYXRlKG4sYykpLGk9cyxlLmRpZFNldChuLGMsaSksZS5pc0NvbnRhaW5tZW50KCkmJih0PXIsbz1lLmludmVyc2VSZW1vdmUodCxudWxsKSwhYSh1LDU0KS5lSW50ZXJuYWxDb250YWluZXIoKSYmKG89ZS5pbnZlcnNlQWRkKGMsbykpLG8mJm8uZGlzcGF0Y2hfMCgpKSxUYShlLm93bmVyKSYmdDIoZSxlLmNyZWF0ZU5vdGlmaWNhdGlvbig5LHIsdSxuLCExKSksdSk6cn1mdW5jdGlvbiBRSGUoZSxuKXtmbihlKSxlLmFkZEFsbChhKG4sMTUpKX1mdW5jdGlvbiBlVWUoZSl7dmFyIG47aWYoZS5oYXNQcm94aWVzKCkpZm9yKG49ZS5zaXplXzAtMTtuPj0wOy0tbilPKGUsbik7cmV0dXJuIEpuZShlKX1mdW5jdGlvbiBuVWUoZSxuLHIpe2lmKFV3KGUsciksIWUuaGFzSW5zdGFuY2VDbGFzcygpJiZyIT1udWxsJiYhZS5pc0luc3RhbmNlKHIpKXRocm93IGIobmV3IEw1KTtyZXR1cm4gcn1mdW5jdGlvbiBxcmUoZSxuKXt0aGlzLmRhdGFDbGFzcz1lLHRoaXMub3duZXI9bn1wKDYzMiwyMDkyLEVvKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBaSGUodGhpcyxuKX0sbC5jcmVhdGVOb3RpZmljYXRpb249ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gQ1ModGhpcyxuLHIsdCxvLGkpfSxsLmRpc3BhdGNoTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4pe3QyKHRoaXMsbil9LGwuZ2V0XzY9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXN9LGwuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGtlKHRoaXMub3duZXIuZUNsYXNzXzAoKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpfSxsLmdldEZlYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKX0sbC5nZXRGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiBFcih0aGlzLm93bmVyLmVDbGFzc18wKCksdGhpcy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSl9LGwuZ2V0SW52ZXJzZUZlYXR1cmVDbGFzcz1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkuZ2V0RVR5cGUoKSwyOSkuZ2V0SW5zdGFuY2VDbGFzcygpfSxsLmdldEludmVyc2VGZWF0dXJlSUQ9ZnVuY3Rpb24oKXtyZXR1cm4gR3QoYSh0aGlzLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLDE5KSkuZmVhdHVyZUlEfSxsLmdldE5vdGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3duZXJ9LGwuaGFzSW5zdGFuY2VDbGFzcz1mdW5jdGlvbigpe3JldHVybiEwfSxsLmhhc01hbnlJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzTmF2aWdhYmxlSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiExfSxsLmhhc1Byb3hpZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIHMwKHRoaXMsbil9LGwuaW52ZXJzZUFkZD1mdW5jdGlvbihuLHIpe3ZhciB0O3JldHVybiB0PWEobiw1NCksdGhpcy5oYXNOYXZpZ2FibGVJbnZlcnNlKCk/dGhpcy5oYXNJbnN0YW5jZUNsYXNzKCk/dC5lSW52ZXJzZUFkZCh0aGlzLm93bmVyLHRoaXMuZ2V0SW52ZXJzZUZlYXR1cmVJRCgpLHRoaXMuZ2V0SW52ZXJzZUZlYXR1cmVDbGFzcygpLHIpOnQuZUludmVyc2VBZGQodGhpcy5vd25lcixFcih0LmVDbGFzc18wKCksR3QoYSh0aGlzLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLDE5KSkpLG51bGwscik6dC5lSW52ZXJzZUFkZCh0aGlzLm93bmVyLC0xLXRoaXMuZ2V0RmVhdHVyZUlEXzAoKSxudWxsLHIpfSxsLmludmVyc2VSZW1vdmU9ZnVuY3Rpb24obixyKXt2YXIgdDtyZXR1cm4gdD1hKG4sNTQpLHRoaXMuaGFzTmF2aWdhYmxlSW52ZXJzZSgpP3RoaXMuaGFzSW5zdGFuY2VDbGFzcygpP3QuZUludmVyc2VSZW1vdmUodGhpcy5vd25lcix0aGlzLmdldEludmVyc2VGZWF0dXJlSUQoKSx0aGlzLmdldEludmVyc2VGZWF0dXJlQ2xhc3MoKSxyKTp0LmVJbnZlcnNlUmVtb3ZlKHRoaXMub3duZXIsRXIodC5lQ2xhc3NfMCgpLEd0KGEodGhpcy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSwxOSkpKSxudWxsLHIpOnQuZUludmVyc2VSZW1vdmUodGhpcy5vd25lciwtMS10aGlzLmdldEZlYXR1cmVJRF8wKCksbnVsbCxyKX0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNFT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gYUhlKHRoaXMuZGF0YUNsYXNzLG4pfSxsLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVGEodGhpcy5vd25lcil9LGwuaXNTZXRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNpemVfMCE9MH0sbC5uZXdEYXRhPWZ1bmN0aW9uKG4pe3JldHVybiBmYih0aGlzLmRhdGFDbGFzcyxuKX0sbC5yZXNvbHZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHRoaXMuaXNFT2JqZWN0KCkmJnRoaXMuaGFzUHJveGllcygpP0ltKHRoaXMsbixhKHIsNTgpKTpyfSxsLnJlc29sdmVQcm94eT1mdW5jdGlvbihuKXtyZXR1cm4gbi5lSXNQcm94eSgpP0owKHRoaXMub3duZXIsYShuLDU0KSk6bn0sbC5zZXRfMT1mdW5jdGlvbihuKXtRSGUodGhpcyxuKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7cmV0dXJuIGVVZSh0aGlzKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7dmFyIHI7aWYodGhpcy5oYXNQcm94aWVzKCkpZm9yKHI9dGhpcy5zaXplXzAtMTtyPj0wOy0tcilPKHRoaXMscik7cmV0dXJuIFpuZSh0aGlzLG4pfSxsLnVuc2V0PWZ1bmN0aW9uKCl7Zm4odGhpcyl9LGwudmFsaWRhdGU9ZnVuY3Rpb24obixyKXtyZXR1cm4gblVlKHRoaXMsbixyKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFY29yZUVMaXN0Iiw2MzIpO2Z1bmN0aW9uIHliKGUsbixyKXtxcmUuY2FsbCh0aGlzLGUsbiksdGhpcy5mZWF0dXJlSUQ9cn1wKDUwNSw2MzIsRW8seWIpLGwuY2FuQ29udGFpbk51bGw9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5nZXRGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZlYXR1cmVJRH0sbC5oYXNJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNFT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaXNVbmlxdWU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5yZXNvbHZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHJ9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuZmVhdHVyZUlEPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFT2JqZWN0RUxpc3QiLDUwNSk7ZnVuY3Rpb24ganIoZSxuLHIpe3liLmNhbGwodGhpcyxlLG4scil9cCg4Myw1MDUsRW8sanIpLGwuaGFzSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxsLmhhc05hdmlnYWJsZUludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50RUxpc3QiLDgzKTtmdW5jdGlvbiBiTChlLG4scil7anIuY2FsbCh0aGlzLGUsbixyKX1wKDU1NSw4MyxFbyxiTCksbC5kaWRDaGFuZ2U9ZnVuY3Rpb24oKXt0aGlzLmlzU2V0PSEwfSxsLmlzU2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1NldH0sbC51bnNldD1mdW5jdGlvbigpe3ZhciBuO2ZuKHRoaXMpLFRhKHRoaXMub3duZXIpPyhuPXRoaXMuaXNTZXQsdGhpcy5pc1NldD0hMSxYbih0aGlzLm93bmVyLG5ldyBycyh0aGlzLm93bmVyLDIsdGhpcy5mZWF0dXJlSUQsbiwhMSkpKTp0aGlzLmlzU2V0PSExfSxsLmlzU2V0PSExLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50RUxpc3QvVW5zZXR0YWJsZSIsNTU1KTtmdW5jdGlvbiBLRChlKXt2YXIgbixyO2ZvcihyPW5ldyBZZShlKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKG49YShlbihyKSw4OSksbi5lVHlwZVBhcmFtZXRlcnx8KCFuLmVUeXBlQXJndW1lbnRzJiYobi5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsbiwxKSksbi5lVHlwZUFyZ3VtZW50cykuc2l6ZV8wIT0wKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIHIzbihlLG4scil7dmFyIHQsbztyZXR1cm4gdD1uZXcgU2MoZS5vd25lciwzLDEwLG51bGwsKG89bi5lUmF3VHlwZSxMKG8sOTApP2EobywyOSk6KFBlKCksTmwpKSxzMChlLG4pLCExKSxyP3IuYWRkXzUodCk6cj10LHJ9ZnVuY3Rpb24gdDNuKGUsbixyKXt2YXIgdCxvO3JldHVybiB0PW5ldyBTYyhlLm93bmVyLDQsMTAsKG89bi5lUmF3VHlwZSxMKG8sOTApP2EobywyOSk6KFBlKCksTmwpKSxudWxsLHMwKGUsbiksITEpLHI/ci5hZGRfNSh0KTpyPXQscn1mdW5jdGlvbiBvM24oZSxuLHIsdCl7dmFyIG8saSxzO3JldHVybiBvPW5ldyBTYyhlLm93bmVyLDEsMTAsKHM9bi5lUmF3VHlwZSxMKHMsOTApP2EocywyOSk6KFBlKCksTmwpKSwoaT1yLmVSYXdUeXBlLEwoaSw5MCk/YShpLDI5KTooUGUoKSxObCkpLHMwKGUsbiksITEpLHQ/dC5hZGRfNShvKTp0PW8sdH1mdW5jdGlvbiByVWUoZSxuLHIpe3RoaXMudGhpcyQwMT1lLGJMLmNhbGwodGhpcyxuLHIsMjIpfXAoMTE2MSw1NTUsRW8sclVlKSxsLm1vdmU9ZnVuY3Rpb24obixyKXt2YXIgdCxvO3JldHVybiB0PWEobVModGhpcyxuLHIpLDg5KSxUYSh0aGlzLm93bmVyKSYmdDIodGhpcyxuZXcgQ2IodGhpcy50aGlzJDAxLDcsKFBlKCksTkhlKSxKKHIpLChvPXQuZVJhd1R5cGUsTChvLDkwKT9hKG8sMjkpOk5sKSxuKSksdH0sbC5zaGFkb3dBZGQ9ZnVuY3Rpb24obixyKXtyZXR1cm4gcjNuKHRoaXMsYShuLDg5KSxyKX0sbC5zaGFkb3dSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gdDNuKHRoaXMsYShuLDg5KSxyKX0sbC5zaGFkb3dTZXQ9ZnVuY3Rpb24obixyLHQpe3JldHVybiBvM24odGhpcyxhKG4sODkpLGEociw4OSksdCl9LGwuY3JlYXRlTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4scix0LG8saSl7c3dpdGNoKG4pe2Nhc2UgMzpyZXR1cm4gQ1ModGhpcyxuLHIsdCxvLHRoaXMuc2l6ZV8wPjEpO2Nhc2UgNTpyZXR1cm4gQ1ModGhpcyxuLHIsdCxvLHRoaXMuc2l6ZV8wLWEodCwxNSkuc2l6ZV8xKCk+MCk7ZGVmYXVsdDpyZXR1cm4gbmV3IFNjKHRoaXMub3duZXIsbix0aGlzLmZlYXR1cmVJRCxyLHQsbywhMCl9fSxsLmhhc1NoYWRvdz1mdW5jdGlvbigpe3JldHVybiEwfSxsLmlzU2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gS0QodGhpcyl9LGwudW5zZXQ9ZnVuY3Rpb24oKXtmbih0aGlzKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsLzEiLDExNjEpO2Z1bmN0aW9uIGkzbihlKXtyZXR1cm4hZS5zdWJjbGFzc2VzJiYoZS5zdWJjbGFzc2VzPW5ldyBsMiksZS5zdWJjbGFzc2VzfWZ1bmN0aW9uIHRVZShlLG4pe3ZhciByLHQsbyxpO3N3aXRjaChvPWUubW9kaWZpZWRTdGF0ZSxuKXtjYXNlIDE6e2UubW9kaWZpZWRTdGF0ZXw9MSxlLm1vZGlmaWVkU3RhdGV8PTQsZS5tb2RpZmllZFN0YXRlfD04O2JyZWFrfWNhc2UgMjp7ZS5tb2RpZmllZFN0YXRlfD0yLGUubW9kaWZpZWRTdGF0ZXw9NCxlLm1vZGlmaWVkU3RhdGV8PTg7YnJlYWt9Y2FzZSA0OntlLm1vZGlmaWVkU3RhdGV8PTEsZS5tb2RpZmllZFN0YXRlfD0yLGUubW9kaWZpZWRTdGF0ZXw9NCxlLm1vZGlmaWVkU3RhdGV8PTg7YnJlYWt9Y2FzZSAzOntlLm1vZGlmaWVkU3RhdGV8PTE2LGUubW9kaWZpZWRTdGF0ZXw9ODticmVha31jYXNlIDA6e2UubW9kaWZpZWRTdGF0ZXw9MzIsZS5tb2RpZmllZFN0YXRlfD0xNixlLm1vZGlmaWVkU3RhdGV8PTgsZS5tb2RpZmllZFN0YXRlfD0xLGUubW9kaWZpZWRTdGF0ZXw9MixlLm1vZGlmaWVkU3RhdGV8PTQ7YnJlYWt9fWlmKGUubW9kaWZpZWRTdGF0ZSE9byYmZS5zdWJjbGFzc2VzKWZvcih0PW5ldyBZZShlLnN1YmNsYXNzZXMpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspaT1hKGVuKHQpLDQ4Mikscj1oYShpKSxscChyLG4pfWZ1bmN0aW9uIGEzbihlKXt2YXIgbjtzd2l0Y2gobj1lLmdldEZlYXR1cmVJRChudWxsKSxuKXtjYXNlIDEwOnJldHVybiAwO2Nhc2UgMTU6cmV0dXJuIDE7Y2FzZSAxNDpyZXR1cm4gMjtjYXNlIDExOnJldHVybiAzO2Nhc2UgMjE6cmV0dXJuIDR9cmV0dXJuLTF9cCgxMTc1LDExNzQsWkYpLGwubm90aWZ5Q2hhbmdlZD1mdW5jdGlvbihuKXt2YXIgcix0LG8saSxzLHUsYztpZih0PW4uZ2V0RXZlbnRUeXBlKCksdCE9OCl7aWYobz1hM24obiksbz09MClzd2l0Y2godCl7Y2FzZSAxOmNhc2UgOTp7Yz1uLmdldE9sZFZhbHVlKCksYyE9bnVsbCYmKHI9aGEoYShjLDQ4MikpLCFyLnN1YmNsYXNzZXMmJihyLnN1YmNsYXNzZXM9bmV3IGwyKSxaQShyLnN1YmNsYXNzZXMsbi5nZXROb3RpZmllcigpKSksdT1uLmdldE5ld1ZhbHVlKCksdSE9bnVsbCYmKGk9YSh1LDQ4MiksaS5lRmxhZ3MmMXx8KHI9aGEoaSksIXIuc3ViY2xhc3NlcyYmKHIuc3ViY2xhc3Nlcz1uZXcgbDIpLHBuKHIuc3ViY2xhc3NlcyxhKG4uZ2V0Tm90aWZpZXIoKSwyOSkpKSk7YnJlYWt9Y2FzZSAzOnt1PW4uZ2V0TmV3VmFsdWUoKSx1IT1udWxsJiYoaT1hKHUsNDgyKSxpLmVGbGFncyYxfHwocj1oYShpKSwhci5zdWJjbGFzc2VzJiYoci5zdWJjbGFzc2VzPW5ldyBsMikscG4oci5zdWJjbGFzc2VzLGEobi5nZXROb3RpZmllcigpLDI5KSkpKTticmVha31jYXNlIDU6e2lmKHU9bi5nZXROZXdWYWx1ZSgpLHUhPW51bGwpZm9yKHM9YSh1LDE2KS5pdGVyYXRvcl8wKCk7cy5oYXNOZXh0XzAoKTspaT1hKHMubmV4dF8xKCksNDgyKSxpLmVGbGFncyYxfHwocj1oYShpKSwhci5zdWJjbGFzc2VzJiYoci5zdWJjbGFzc2VzPW5ldyBsMikscG4oci5zdWJjbGFzc2VzLGEobi5nZXROb3RpZmllcigpLDI5KSkpO2JyZWFrfWNhc2UgNDp7Yz1uLmdldE9sZFZhbHVlKCksYyE9bnVsbCYmKGk9YShjLDQ4MiksaS5lRmxhZ3MmMXx8KHI9aGEoaSksIXIuc3ViY2xhc3NlcyYmKHIuc3ViY2xhc3Nlcz1uZXcgbDIpLFpBKHIuc3ViY2xhc3NlcyxuLmdldE5vdGlmaWVyKCkpKSk7YnJlYWt9Y2FzZSA2OntpZihjPW4uZ2V0T2xkVmFsdWUoKSxjIT1udWxsKWZvcihzPWEoYywxNikuaXRlcmF0b3JfMCgpO3MuaGFzTmV4dF8wKCk7KWk9YShzLm5leHRfMSgpLDQ4MiksaS5lRmxhZ3MmMXx8KHI9aGEoaSksIXIuc3ViY2xhc3NlcyYmKHIuc3ViY2xhc3Nlcz1uZXcgbDIpLFpBKHIuc3ViY2xhc3NlcyxuLmdldE5vdGlmaWVyKCkpKTticmVha319dGhpcy5zZXRGbGFncyhvKX19LGwuc2V0RmxhZ3M9ZnVuY3Rpb24obil7dFVlKHRoaXMsbil9LGwubW9kaWZpZWRTdGF0ZT02MyxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdXBlckFkYXB0ZXIiLDExNzUpO2Z1bmN0aW9uIGxwKGUsbil7dFVlKGUsbiksZS5tb2RpZmllZFN0YXRlJjEmJihlLnRoaXMkMDEuZUFsbEF0dHJpYnV0ZXM9bnVsbCksZS5tb2RpZmllZFN0YXRlJjImJihlLnRoaXMkMDEuZUFsbFJlZmVyZW5jZXM9bnVsbCksZS5tb2RpZmllZFN0YXRlJjQmJihlLnRoaXMkMDEuZUFsbFN0cnVjdHVyYWxGZWF0dXJlcz1udWxsLGUudGhpcyQwMS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT1udWxsKSxlLm1vZGlmaWVkU3RhdGUmMTYmJihlLnRoaXMkMDEuZUFsbE9wZXJhdGlvbnM9bnVsbCxlLnRoaXMkMDEuZUFsbE9wZXJhdGlvbnNEYXRhPW51bGwpLGUubW9kaWZpZWRTdGF0ZSY4JiYoZS50aGlzJDAxLmVBbGxDb250YWlubWVudHM9bnVsbCksZS5tb2RpZmllZFN0YXRlJjMyJiYoZS50aGlzJDAxLmVBbGxTdXBlclR5cGVzPW51bGwsZS50aGlzJDAxLmVBbGxHZW5lcmljU3VwZXJUeXBlcz1udWxsKX1mdW5jdGlvbiBvVWUoZSl7dGhpcy50aGlzJDAxPWV9cCgxMTc2LDExNzUsWkYsb1VlKSxsLnNldEZsYWdzPWZ1bmN0aW9uKG4pe2xwKHRoaXMsbil9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC8xMCIsMTE3NikscCgxMTY1LDcxMCxFbyksbC5hZGRBbGxVbmlxdWU9ZnVuY3Rpb24obixyKXtyZXR1cm4gX0QodGhpcyxuLHIpfSxsLmFkZEFsbFVuaXF1ZV8wPWZ1bmN0aW9uKG4pe3JldHVybiBqQmUodGhpcyxuKX0sbC5hZGRVbmlxdWU9ZnVuY3Rpb24obixyKXtsYih0aGlzLG4scil9LGwuYWRkVW5pcXVlXzA9ZnVuY3Rpb24obil7c2IodGhpcyxuKX0sbC5iYXNpY0dldD1mdW5jdGlvbihuKXtyZXR1cm4gWG5lKHRoaXMsbil9LGwuc2V0VW5pcXVlPWZ1bmN0aW9uKG4scil7cmV0dXJuIGZEKHRoaXMsbixyKX0sbC5iYXNpY0FkZD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5iYXNpY0l0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDbSh0aGlzKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgZGIodGhpcyl9LGwuYmFzaWNMaXN0SXRlcmF0b3JfMD1mdW5jdGlvbihuKXtyZXR1cm4gYWIodGhpcyxuKX0sbC5iYXNpY1JlbW92ZT1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpc30sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV8wIT0wfSxsLnNldF8xPWZ1bmN0aW9uKG4pe3Rocm93IGIobmV3IFRuKX0sbC51bnNldD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFRuKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFY29yZUVMaXN0L1VubW9kaWZpYWJsZUVMaXN0IiwxMTY1KTtmdW5jdGlvbiBIZyhlLG4pe21yZS5jYWxsKHRoaXMsZSxuKX1wKDMyOCwxMTY1LEVvLEhnKSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlRUxpc3QvVW5tb2RpZmlhYmxlRUxpc3QvRmFzdENvbXBhcmUiLDMyOCk7ZnVuY3Rpb24gWXJlKGUpe3JldHVybiBEKGUuY29udGFpbm1lbnRzKT09PUQoKGpEKCksWUQpKSYmbDNuKGUpLGUuY29udGFpbm1lbnRzfWZ1bmN0aW9uIGwzbihlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF8sZDtmb3Iobj1uZXcgWEQscj1uZXcgWEQsXz1UZSgibWl4ZWQiLChvPXNTKGUudGhpcyQwMSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIiksbz94bih3cygoIW8uZGV0YWlscyYmKG8uZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLG8pKSxvLmRldGFpbHMpLCJraW5kIikpOm51bGwpKSxjPTA7YzxlLnNpemVfMDsrK2MpdT1hKGUuZGF0YV8wW2NdLDE3OSksTCh1LDEwMik/KHM9YSh1LDE5KSxzLmVGbGFncyZHbz8oIShzLmVGbGFncyZLcyl8fCFfJiYoaT1zUyhzLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiKSwoaT94bih3cygoIWkuZGV0YWlscyYmKGkuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLGkpKSxpLmRldGFpbHMpLCJncm91cCIpKTpudWxsKT09bnVsbCkpJiZwbihuLHMpOihkPUd0KHMpLGQmJmQuZUZsYWdzJkdvfHwoIShzLmVGbGFncyZLcyl8fCFfJiYodD1zUyhzLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiKSwodD94bih3cygoIXQuZGV0YWlscyYmKHQuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHQpKSx0LmRldGFpbHMpLCJncm91cCIpKTpudWxsKT09bnVsbCkpJiZwbihyLHMpKSk6KEh0KCksYSh1LDY5KS5pc0ZlYXR1cmVNYXBfMCgpJiYodS5pc0Rlcml2ZWQoKXx8KHBuKG4sdSkscG4ocix1KSkpKTtKZihuKSxKZihyKSxlLmNvbnRhaW5tZW50cz1hKG4uZGF0YV8wLDI1NCksYShyLmRhdGFfMCwyNTQpfWZ1bmN0aW9uIGlVZShlLG4pe3RoaXMudGhpcyQwMT1lLEhnLmNhbGwodGhpcywoYShPKEcoKHJfKCksJGUpLmVDbGFzc0VDbGFzcyksMTApLDE5KSxuLnNpemVfMCksbi5kYXRhXzApLHRoaXMuY29udGFpbm1lbnRzPShqRCgpLFlEKX1wKDExNjgsMzI4LEVvLGlVZSksbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvO2lmKEwobiwxNzkpJiYocj1hKG4sMTc5KSx0PXIuZ2V0RmVhdHVyZUlEXzAoKSx0IT0tMSkpe2ZvcihvPXRoaXMuc2l6ZV8wO3Q8bzsrK3QpaWYoRCh0aGlzLmRhdGFfMFt0XSk9PT1EKG4pKXJldHVybiB0fXJldHVybi0xfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVDbGFzc0ltcGwvMUVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNMaXN0IiwxMTY4KTtmdW5jdGlvbiBzM24oZSl7dmFyIG4scix0LG8saTtmb3Iocj1hKGUuZGF0YV8wLDY4OSksdD1lLnNpemVfMC0xO3Q+PTA7LS10KWZvcihuPXJbdF0sbz0wO288dDsrK28paWYoaT1yW29dLGFVZShlLG4saSkpe3ZtKGUsdCk7YnJlYWt9fWZ1bmN0aW9uIGFVZShlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmLGgsbSx5O2lmKG49PXIpcmV0dXJuITA7aWYobj1LcmUoZSxuKSxyPUtyZShlLHIpLHQ9ZUYobiksdCl7aWYoZD1lRihyKSxkIT10KXJldHVybiBkPyhjPXQuZ2V0SW5zdGFuY2VUeXBlTmFtZSgpLHk9ZC5nZXRJbnN0YW5jZVR5cGVOYW1lKCksYz09eSYmYyE9bnVsbCk6ITE7aWYocz0oIW4uZVR5cGVBcmd1bWVudHMmJihuLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxuLDEpKSxuLmVUeXBlQXJndW1lbnRzKSxpPXMuc2l6ZV8wLGg9KCFyLmVUeXBlQXJndW1lbnRzJiYoci5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsciwxKSksci5lVHlwZUFyZ3VtZW50cyksaT09aC5zaXplXzApe2ZvcihfPTA7XzxpOysrXylpZihvPWEoTyhzLF8pLDg5KSxmPWEoTyhoLF8pLDg5KSwhYVVlKGUsbyxmKSlyZXR1cm4hMX1yZXR1cm4hMH1lbHNlIHJldHVybiB1PW4uZVR5cGVQYXJhbWV0ZXIsbT1yLmVUeXBlUGFyYW1ldGVyLHU9PW19ZnVuY3Rpb24gS3JlKGUsbil7dmFyIHIsdCxvLGkscyx1LGM7aWYoaT1uLmVUeXBlUGFyYW1ldGVyLGkpe2ZvcihyPU1SKGkpLHQ9YShlLmRhdGFfMCw2ODkpLHM9MDtzPGUuc2l6ZV8wOysrcylpZihjPXRbc10sZUYoYyk9PXImJihvPSghYy5lVHlwZUFyZ3VtZW50cyYmKGMuZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LGMsMSkpLGMuZVR5cGVBcmd1bWVudHMpLHU9YShyLmVHZXRfMChHUihpLGkuZUNvbnRhaW5lcixpLmVGbGFnc18wPj4xNikpLDE1KS5pbmRleE9mXzAoaSksdTxvLnNpemVfMCkpcmV0dXJuIEtyZShlLGEoTyhvLHUpLDg5KSl9cmV0dXJuIG59ZnVuY3Rpb24gbFVlKCl7fXAoMTE2Miw1MDYsZXUsbFVlKSxsLm5ld0RhdGE9ZnVuY3Rpb24obil7cmV0dXJuIEIoS3Qsa2llLDg5LG4sMCwxKX0sbC51c2VFcXVhbHM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsLzFFR2VuZXJpY1N1cGVyVHlwZUVMaXN0IiwxMTYyKTtmdW5jdGlvbiBYRCgpe31wKDYzMyw1MDYsZXUsWEQpLGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQihSaSxFcCwxNzksbiwwLDEpfSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVDbGFzc0ltcGwvMUVTdHJ1Y3R1cmFsRmVhdHVyZVVuaXF1ZUVMaXN0Iiw2MzMpO2Z1bmN0aW9uIFhyZSgpe31wKDc1NSw1MDYsZXUsWHJlKSxsLm5ld0RhdGE9ZnVuY3Rpb24obil7cmV0dXJuIEIocnAsRXAsMTksbiwwLDEpfSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVDbGFzc0ltcGwvMVJlZmVyZW5jZUxpc3QiLDc1NSk7ZnVuY3Rpb24gdTNuKGUsbil7bi5lRmxhZ3MmR28mJiFlLnRoaXMkMDEuZUlEQXR0cmlidXRlJiYoZS50aGlzJDAxLmVJREF0dHJpYnV0ZT1uKX1mdW5jdGlvbiBzVWUoZSl7dGhpcy50aGlzJDAxPWV9cCgxMTYzLDUwNixldSxzVWUpLGwuZGlkQWRkPWZ1bmN0aW9uKG4scil7dTNuKHRoaXMsYShyLDM1KSl9LGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQihucCxFcCwzNSxuLDAsMSl9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC8yIiwxMTYzKTtmdW5jdGlvbiB1VWUoKXt9cCgxMTY0LDUwNixldSx1VWUpLGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQihucCxFcCwzNSxuLDAsMSl9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC8zIiwxMTY0KTtmdW5jdGlvbiBjM24oZSxuKXtyZXR1cm4gbmMoKSxwbihHKGUudGhpcyQwMSksbil9ZnVuY3Rpb24gXzNuKGUsbil7d0QoRyhlLnRoaXMkMDEpLG4pfWZ1bmN0aW9uIGNVZShlLG4scil7dGhpcy50aGlzJDAxPWUsSGcuY2FsbCh0aGlzLG4scil9cCgxMTY2LDMyOCxFbyxjVWUpLGwuYWRkXzI9ZnVuY3Rpb24obil7cmV0dXJuIGMzbih0aGlzLGEobiwzNSkpfSxsLmFkZFVuaXF1ZV8wPWZ1bmN0aW9uKG4pe18zbih0aGlzLGEobiwzNSkpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVDbGFzc0ltcGwvNCIsMTE2Nik7ZnVuY3Rpb24gZDNuKGUsbil7cmV0dXJuIG5jKCkscG4oRyhlLnRoaXMkMDEpLG4pfWZ1bmN0aW9uIGYzbihlLG4pe3dEKEcoZS50aGlzJDAxKSxuKX1mdW5jdGlvbiBfVWUoZSxuLHIpe3RoaXMudGhpcyQwMT1lLEhnLmNhbGwodGhpcyxuLHIpfXAoMTE2NywzMjgsRW8sX1VlKSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiBkM24odGhpcyxhKG4sMTkpKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXtmM24odGhpcyxhKG4sMTkpKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsLzUiLDExNjcpO2Z1bmN0aW9uIGRVZSgpe31wKDExNjksNTA2LGV1LGRVZSksbC5uZXdEYXRhPWZ1bmN0aW9uKG4pe3JldHVybiBCKHhsLG56LDYyLG4sMCwxKX0sbC51c2VFcXVhbHM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsLzYiLDExNjkpO2Z1bmN0aW9uIGZVZSgpe31wKDExNzAsNTA2LGV1LGZVZSksbC5uZXdEYXRhPWZ1bmN0aW9uKG4pe3JldHVybiBCKHJwLEVwLDE5LG4sMCwxKX0sbC51c2VFcXVhbHM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFQ2xhc3NJbXBsLzciLDExNzApLHAoMjA5NSwyMDk0LHszOjEsNDoxLDIwOjEsMzE6MSw1NjoxLDE2OjEsMTU6MSw3MDoxLDYxOjEsNzE6MX0pLGwuYWRkQWxsVW5pcXVlPWZ1bmN0aW9uKG4scil7cmV0dXJuIGNyZSh0aGlzLG4scil9LGwuYWRkQWxsVW5pcXVlXzA9ZnVuY3Rpb24obil7cmV0dXJuIGNyZSh0aGlzLHRoaXMuZGVsZWdhdGVTaXplKCksbil9LGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7UUJlKHRoaXMsbixyKX0sbC5hZGRVbmlxdWVfMD1mdW5jdGlvbihuKXtlR2UodGhpcyxuKX0sbC5iYXNpY0FkZD1mdW5jdGlvbihuLHIpe3JldHVybiBZU24odGhpcyxuLHIpfSxsLmJhc2ljUmVtb3ZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIEtTbih0aGlzLG4scil9LGwuc2V0VW5pcXVlPWZ1bmN0aW9uKG4scil7cmV0dXJuIG5HZSh0aGlzLG4scil9LGwuYmFzaWNHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZGVsZWdhdGVHZXQobil9LGwuYmFzaWNJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgQ20odGhpcyl9LGwuYmFzaWNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVsZWdhdGVCYXNpY0xpc3QoKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgZGIodGhpcyl9LGwuYmFzaWNMaXN0SXRlcmF0b3JfMD1mdW5jdGlvbihuKXtyZXR1cm4gYWIodGhpcyxuKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJEZWxlZ2F0aW5nTm90aWZ5aW5nSW50ZXJuYWxFTGlzdEltcGwiLDIwOTUpO2Z1bmN0aW9uIHdiKGUsbixyKXt2YXIgdCxvLGkscztyZXR1cm4gZS5pc0VPYmplY3QoKSYmZS5oYXNQcm94aWVzKCkmJihzPUpEKGUsYShyLDU4KSksRChzKSE9PUQocikpPyhlLmRlbGVnYXRlR2V0KG4pLGUuZGVsZWdhdGVTZXQobixwVWUoZSxuLHMpKSxlLmlzQ29udGFpbm1lbnQoKSYmKGk9KG89YShyLDU0KSxlLmhhc05hdmlnYWJsZUludmVyc2UoKT9lLmhhc0luc3RhbmNlQ2xhc3MoKT9vLmVJbnZlcnNlUmVtb3ZlKGUub3duZXIsR3QoYShrZShNaShlLm93bmVyKSxlLmdldEZlYXR1cmVJRF8wKCkpLDE5KSkuZmVhdHVyZUlELGEoa2UoTWkoZS5vd25lciksZS5nZXRGZWF0dXJlSURfMCgpKS5nZXRFVHlwZSgpLDI5KS5nZXRJbnN0YW5jZUNsYXNzKCksbnVsbCk6by5lSW52ZXJzZVJlbW92ZShlLm93bmVyLEVyKG8uZUNsYXNzXzAoKSxHdChhKGtlKE1pKGUub3duZXIpLGUuZ2V0RmVhdHVyZUlEXzAoKSksMTkpKSksbnVsbCxudWxsKTpvLmVJbnZlcnNlUmVtb3ZlKGUub3duZXIsLTEtZS5nZXRGZWF0dXJlSURfMCgpLG51bGwsbnVsbCkpLCFhKHMsNTQpLmVJbnRlcm5hbENvbnRhaW5lcigpJiYoaT0odD1hKHMsNTQpLGUuaGFzTmF2aWdhYmxlSW52ZXJzZSgpP2UuaGFzSW5zdGFuY2VDbGFzcygpP3QuZUludmVyc2VBZGQoZS5vd25lcixHdChhKGtlKE1pKGUub3duZXIpLGUuZ2V0RmVhdHVyZUlEXzAoKSksMTkpKS5mZWF0dXJlSUQsYShrZShNaShlLm93bmVyKSxlLmdldEZlYXR1cmVJRF8wKCkpLmdldEVUeXBlKCksMjkpLmdldEluc3RhbmNlQ2xhc3MoKSxpKTp0LmVJbnZlcnNlQWRkKGUub3duZXIsRXIodC5lQ2xhc3NfMCgpLEd0KGEoa2UoTWkoZS5vd25lciksZS5nZXRGZWF0dXJlSURfMCgpKSwxOSkpKSxudWxsLGkpOnQuZUludmVyc2VBZGQoZS5vd25lciwtMS1lLmdldEZlYXR1cmVJRF8wKCksbnVsbCxpKSkpLGkmJmkuZGlzcGF0Y2hfMCgpKSxUYShlLm93bmVyKSYmZS5kaXNwYXRjaE5vdGlmaWNhdGlvbihlLmNyZWF0ZU5vdGlmaWNhdGlvbig5LHIscyxuLCExKSkscyk6cn1mdW5jdGlvbiBKRChlLG4pe3JldHVybiBuLmVJc1Byb3h5KCk/SjAoZS5vd25lcixhKG4sNTQpKTpufWZ1bmN0aW9uIHBVZShlLG4scil7aWYoVXcoZSxyKSxyIT1udWxsJiYhZS5pc0luc3RhbmNlKHIpKXRocm93IGIobmV3IEw1KTtyZXR1cm4gcn1mdW5jdGlvbiBnVWUoZSl7dGhpcy5vd25lcj1lfXAoNzU2LDIwOTUscnopLGwuY2FuQ29udGFpbk51bGw9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1rZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLmdldEVUeXBlKCksTChuLDE1NikmJiFMKG4sNDY5KSYmKG4uZ2V0SW5zdGFuY2VDbGFzcygpLm1vZGlmaWVycyYxKT09MH0sbC5jb250YWlucz1mdW5jdGlvbihuKXt2YXIgcix0LG8saSxzLHUsYyxfO2lmKHRoaXMuaXNFT2JqZWN0KCkpe2lmKF89dGhpcy5kZWxlZ2F0ZVNpemUoKSxfPjQpaWYodGhpcy5pc0luc3RhbmNlKG4pKXtpZih0aGlzLmlzQ29udGFpbm1lbnQoKSl7aWYobz1hKG4sNTQpLHQ9by5lQ29udGFpbmVyXzAoKSxjPXQ9PXRoaXMub3duZXImJih0aGlzLmhhc05hdmlnYWJsZUludmVyc2UoKT9vLmVCYXNlU3RydWN0dXJhbEZlYXR1cmVJRChvLmVDb250YWluZXJGZWF0dXJlSURfMCgpLGEoa2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKS5nZXRFVHlwZSgpLDI5KS5nZXRJbnN0YW5jZUNsYXNzKCkpPT1HdChhKGtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSksMTkpKS5mZWF0dXJlSUQ6LTEtby5lQ29udGFpbmVyRmVhdHVyZUlEXzAoKT09dGhpcy5nZXRGZWF0dXJlSURfMCgpKSx0aGlzLmhhc1Byb3hpZXMoKSYmIWMmJiF0JiZvLmVEaXJlY3RSZXNvdXJjZSgpKXtmb3IoaT0wO2k8XzsrK2kpaWYocj1KRCh0aGlzLHRoaXMuZGVsZWdhdGVHZXQoaSkpLEQocik9PT1EKG4pKXJldHVybiEwfXJldHVybiBjfWVsc2UgaWYodGhpcy5oYXNOYXZpZ2FibGVJbnZlcnNlKCkmJiF0aGlzLmhhc01hbnlJbnZlcnNlKCkpe2lmKHM9YShuLDU4KS5lR2V0XzAoR3QoYShrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLDE5KSkpLEQocyk9PT1EKHRoaXMub3duZXIpKXJldHVybiEwO2lmKHM9PW51bGx8fCFhKHMsNTgpLmVJc1Byb3h5KCkpcmV0dXJuITF9fWVsc2UgcmV0dXJuITE7aWYodT10aGlzLmRlbGVnYXRlQ29udGFpbnMobiksdGhpcy5oYXNQcm94aWVzKCkmJiF1KXtmb3IoaT0wO2k8XzsrK2kpaWYobz1KRCh0aGlzLHRoaXMuZGVsZWdhdGVHZXQoaSkpLEQobyk9PT1EKG4pKXJldHVybiEwfXJldHVybiB1fWVsc2UgcmV0dXJuIHRoaXMuZGVsZWdhdGVDb250YWlucyhuKX0sbC5jcmVhdGVOb3RpZmljYXRpb249ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbmV3IFNjKHRoaXMub3duZXIsbix0aGlzLmdldEZlYXR1cmVJRF8wKCkscix0LG8saSl9LGwuZGlzcGF0Y2hOb3RpZmljYXRpb249ZnVuY3Rpb24obil7WG4odGhpcy5vd25lcixuKX0sbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpc30sbC5nZXRGZWF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSl9LGwuZ2V0RmVhdHVyZUlEXzA9ZnVuY3Rpb24oKXtyZXR1cm4gRXIoTWkodGhpcy5vd25lciksa2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKSl9LGwuZ2V0Tm90aWZpZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vd25lcn0sbC5oYXNJbnN0YW5jZUNsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuISFrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLmdldEVUeXBlKCkuZ2V0SW5zdGFuY2VDbGFzcygpfSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXt2YXIgbixyO3JldHVybiByPWtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSksTChyLDEwMik/KG49YShyLDE5KSwobi5lRmxhZ3MmR28pIT0wfHwhIUd0KGEociwxOSkpKTohMX0sbC5oYXNNYW55SW52ZXJzZT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvO3JldHVybiByPWtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSksTChyLDEwMik/KG49YShyLDE5KSx0PUd0KG4pLCEhdCYmKG89dC51cHBlckJvdW5kLG8+MXx8bz09LTEpKTohMX0sbC5oYXNOYXZpZ2FibGVJbnZlcnNlPWZ1bmN0aW9uKCl7dmFyIG4scix0O3JldHVybiByPWtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSksTChyLDEwMik/KG49YShyLDE5KSx0PUd0KG4pLCEhdCk6ITF9LGwuaGFzUHJveGllcz1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIHI9a2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKSxMKHIsMTAyKT8obj1hKHIsMTkpLChuLmVGbGFncyZGdCkhPTApOiExfSxsLmluZGV4T2ZfMD1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtpZihvPXRoaXMuZGVsZWdhdGVJbmRleE9mKG4pLG8+PTApcmV0dXJuIG87aWYodGhpcy5pc0VPYmplY3QoKSl7Zm9yKHQ9MCxpPXRoaXMuZGVsZWdhdGVTaXplKCk7dDxpOysrdClpZihyPUpEKHRoaXMsdGhpcy5kZWxlZ2F0ZUdldCh0KSksRChyKT09PUQobikpcmV0dXJuIHR9cmV0dXJuLTF9LGwuaW52ZXJzZUFkZD1mdW5jdGlvbihuLHIpe3ZhciB0O3JldHVybiB0PWEobiw1NCksdGhpcy5oYXNOYXZpZ2FibGVJbnZlcnNlKCk/dGhpcy5oYXNJbnN0YW5jZUNsYXNzKCk/dC5lSW52ZXJzZUFkZCh0aGlzLm93bmVyLEd0KGEoa2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKSwxOSkpLmZlYXR1cmVJRCxhKGtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSkuZ2V0RVR5cGUoKSwyOSkuZ2V0SW5zdGFuY2VDbGFzcygpLHIpOnQuZUludmVyc2VBZGQodGhpcy5vd25lcixFcih0LmVDbGFzc18wKCksR3QoYShrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLDE5KSkpLG51bGwscik6dC5lSW52ZXJzZUFkZCh0aGlzLm93bmVyLC0xLXRoaXMuZ2V0RmVhdHVyZUlEXzAoKSxudWxsLHIpfSxsLmludmVyc2VSZW1vdmU9ZnVuY3Rpb24obixyKXt2YXIgdDtyZXR1cm4gdD1hKG4sNTQpLHRoaXMuaGFzTmF2aWdhYmxlSW52ZXJzZSgpP3RoaXMuaGFzSW5zdGFuY2VDbGFzcygpP3QuZUludmVyc2VSZW1vdmUodGhpcy5vd25lcixHdChhKGtlKE1pKHRoaXMub3duZXIpLHRoaXMuZ2V0RmVhdHVyZUlEXzAoKSksMTkpKS5mZWF0dXJlSUQsYShrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLmdldEVUeXBlKCksMjkpLmdldEluc3RhbmNlQ2xhc3MoKSxyKTp0LmVJbnZlcnNlUmVtb3ZlKHRoaXMub3duZXIsRXIodC5lQ2xhc3NfMCgpLEd0KGEoa2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKSwxOSkpKSxudWxsLHIpOnQuZUludmVyc2VSZW1vdmUodGhpcy5vd25lciwtMS10aGlzLmdldEZlYXR1cmVJRF8wKCksbnVsbCxyKX0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7dmFyIG4scjtyZXR1cm4gcj1rZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLEwociwxMDIpPyhuPWEociwxOSksKG4uZUZsYWdzJkdvKSE9MCk6ITF9LGwuaXNFT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIEwoa2UoTWkodGhpcy5vd25lciksdGhpcy5nZXRGZWF0dXJlSURfMCgpKS5nZXRFVHlwZSgpLDkwKX0sbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLmdldEVUeXBlKCkuaXNJbnN0YW5jZShuKX0sbC5pc05vdGlmaWNhdGlvblJlcXVpcmVkPWZ1bmN0aW9uKCl7cmV0dXJuIFRhKHRoaXMub3duZXIpfSxsLmlzU2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5kZWxlZ2F0ZUlzRW1wdHkoKX0sbC5pc1VuaXF1ZT1mdW5jdGlvbigpe3JldHVybiBrZShNaSh0aGlzLm93bmVyKSx0aGlzLmdldEZlYXR1cmVJRF8wKCkpLmlzVW5pcXVlKCl9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiB3Yih0aGlzLG4scil9LGwuc2V0XzE9ZnVuY3Rpb24obil7aFModGhpcyksUHIodGhpcyxhKG4sMTUpKX0sbC50b0FycmF5PWZ1bmN0aW9uKCl7dmFyIG47aWYodGhpcy5oYXNQcm94aWVzKCkpZm9yKG49dGhpcy5kZWxlZ2F0ZVNpemUoKS0xO24+PTA7LS1uKXdiKHRoaXMsbix0aGlzLmRlbGVnYXRlR2V0KG4pKTtyZXR1cm4gdGhpcy5kZWxlZ2F0ZVRvQXJyYXkoKX0sbC50b0FycmF5XzA9ZnVuY3Rpb24obil7dmFyIHI7aWYodGhpcy5oYXNQcm94aWVzKCkpZm9yKHI9dGhpcy5kZWxlZ2F0ZVNpemUoKS0xO3I+PTA7LS1yKXdiKHRoaXMscix0aGlzLmRlbGVnYXRlR2V0KHIpKTtyZXR1cm4gdGhpcy5kZWxlZ2F0ZVRvQXJyYXlfMChuKX0sbC51bnNldD1mdW5jdGlvbigpe2hTKHRoaXMpfSxsLnZhbGlkYXRlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHBVZSh0aGlzLG4scil9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRGVsZWdhdGluZ0Vjb3JlRUxpc3QiLDc1Nik7ZnVuY3Rpb24gcDNuKGUsbixyKXtmUyhRbyhlLnRoaXMkMDEpLG4sbVVlKHIpKX1mdW5jdGlvbiBnM24oZSxuKXtwbihRbyhlLnRoaXMkMDEpLG1VZShuKSl9ZnVuY3Rpb24gaFVlKGUsbil7dmFyIHIsdDtmb3IodD1uZXcgWWUoZSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylpZihyPWEoZW4odCksMjkpLEQobik9PT1EKHIpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGgzbihlLG4scil7dmFyIHQsbyxpO3JldHVybiB0PWEoTyhRbyhlLnRoaXMkMDEpLG4pLDg5KSxpPShvPXQuZVJhd1R5cGUsTChvLDkwKT9hKG8sMjkpOihQZSgpLE5sKSksKGkuZUZsYWdzXzAmNjQ/SjAoZS5vd25lcixpKTppKT09cj9QTCh0KTpvMih0LHIpLGl9ZnVuY3Rpb24gbVVlKGUpe3ZhciBuLHI7cmV0dXJuIHI9KFZ3KCksbj1uZXcgTWQsbiksbzIocixlKSxyfWZ1bmN0aW9uIHlVZShlLG4pe3RoaXMudGhpcyQwMT1lLGdVZS5jYWxsKHRoaXMsbil9cCgxMTcxLDc1Nixyeix5VWUpLGwuZGVsZWdhdGVBZGQ9ZnVuY3Rpb24obixyKXtwM24odGhpcyxuLGEociwyOSkpfSxsLmRlbGVnYXRlQWRkXzA9ZnVuY3Rpb24obil7ZzNuKHRoaXMsYShuLDI5KSl9LGwuZGVsZWdhdGVHZXQ9ZnVuY3Rpb24obil7dmFyIHIsdDtyZXR1cm4gcj1hKE8oUW8odGhpcy50aGlzJDAxKSxuKSw4OSksdD1yLmVSYXdUeXBlLEwodCw5MCk/YSh0LDI5KTooUGUoKSxObCl9LGwuZGVsZWdhdGVSZW1vdmU9ZnVuY3Rpb24obil7dmFyIHIsdDtyZXR1cm4gcj1hKFpmKFFvKHRoaXMudGhpcyQwMSksbiksODkpLHQ9ci5lUmF3VHlwZSxMKHQsOTApP2EodCwyOSk6KFBlKCksTmwpfSxsLmRlbGVnYXRlU2V0PWZ1bmN0aW9uKG4scil7cmV0dXJuIGgzbih0aGlzLG4sYShyLDI5KSl9LGwuY2FuQ29udGFpbk51bGw9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5jcmVhdGVOb3RpZmljYXRpb249ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbnVsbH0sbC5kZWxlZ2F0ZUJhc2ljTGlzdD1mdW5jdGlvbigpe3JldHVybiBuZXcgd1VlKHRoaXMpfSxsLmRlbGVnYXRlQ2xlYXI9ZnVuY3Rpb24oKXtmbihRbyh0aGlzLnRoaXMkMDEpKX0sbC5kZWxlZ2F0ZUNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBoVWUodGhpcyxuKX0sbC5kZWxlZ2F0ZUNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3ZhciByLHQ7Zm9yKHQ9bi5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspaWYocj10Lm5leHRfMSgpLCFoVWUodGhpcyxyKSlyZXR1cm4hMTtyZXR1cm4hMH0sbC5kZWxlZ2F0ZUVxdWFscz1mdW5jdGlvbihuKXt2YXIgcix0LG87aWYoTChuLDE1KSYmKG89YShuLDE1KSxvLnNpemVfMSgpPT1Rbyh0aGlzLnRoaXMkMDEpLnNpemVfMCkpe2ZvcihyPW8uaXRlcmF0b3JfMCgpLHQ9bmV3IFllKHRoaXMpO3IuaGFzTmV4dF8wKCk7KWlmKEQoci5uZXh0XzEoKSkhPT1EKGVuKHQpKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX0sbC5kZWxlZ2F0ZUhhc2hDb2RlPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtmb3IodD0xLHI9bmV3IFllKFFvKHRoaXMudGhpcyQwMSkpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDg5KSxvPShpPW4uZVJhd1R5cGUsTChpLDkwKT9hKGksMjkpOihQZSgpLE5sKSksdD0zMSp0KyhvP1IxKG8pOjApO3JldHVybiB0fSxsLmRlbGVnYXRlSW5kZXhPZj1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtmb3Iobz0wLHQ9bmV3IFllKFFvKHRoaXMudGhpcyQwMSkpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspe2lmKHI9YShlbih0KSw4OSksRChuKT09PUQoKGk9ci5lUmF3VHlwZSxMKGksOTApP2EoaSwyOSk6KFBlKCksTmwpKSkpcmV0dXJuIG87KytvfXJldHVybi0xfSxsLmRlbGVnYXRlSXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiBRbyh0aGlzLnRoaXMkMDEpLnNpemVfMD09MH0sbC5kZWxlZ2F0ZUxpc3RfMT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmRlbGVnYXRlU2l6ZT1mdW5jdGlvbigpe3JldHVybiBRbyh0aGlzLnRoaXMkMDEpLnNpemVfMH0sbC5kZWxlZ2F0ZVRvQXJyYXk9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHM7Zm9yKHM9UW8odGhpcy50aGlzJDAxKS5zaXplXzAsaT1CKFFyLE1lLDEscyw1LDEpLHQ9MCxyPW5ldyBZZShRbyh0aGlzLnRoaXMkMDEpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSw4OSksaVt0KytdPShvPW4uZVJhd1R5cGUsTChvLDkwKT9hKG8sMjkpOihQZSgpLE5sKSk7cmV0dXJuIGl9LGwuZGVsZWdhdGVUb0FycmF5XzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGM7Zm9yKGM9UW8odGhpcy50aGlzJDAxKS5zaXplXzAsbi5sZW5ndGg8YyYmKGk9ZmIod2EobikuY29tcG9uZW50VHlwZSxjKSxuPWkpLG4ubGVuZ3RoPmMmJlRyKG4sYyxudWxsKSxvPTAsdD1uZXcgWWUoUW8odGhpcy50aGlzJDAxKSk7dC5jdXJzb3IhPXQudGhpcyQwMV8yLnNpemVfMSgpOylyPWEoZW4odCksODkpLHM9KHU9ci5lUmF3VHlwZSxMKHUsOTApP2EodSwyOSk6KFBlKCksTmwpKSxUcihuLG8rKyxzKTtyZXR1cm4gbn0sbC5kZWxlZ2F0ZVRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtmb3IoaT1uZXcgTGMsaS5zdHJpbmcrPSJbIixuPVFvKHRoaXMudGhpcyQwMSkscj0wLG89UW8odGhpcy50aGlzJDAxKS5zaXplXzA7cjxvOylKdChpLHoyKCh0PWEoTyhuLHIpLDg5KS5lUmF3VHlwZSxMKHQsOTApP2EodCwyOSk6KFBlKCksTmwpKSkpLCsrcjxvJiYoaS5zdHJpbmcrPSIsICIpO3JldHVybiBpLnN0cmluZys9Il0iLGkuc3RyaW5nfSxsLmRpc3BhdGNoTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4pe30sbC5nZXRGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiAxMH0sbC5oYXNJbnN0YW5jZUNsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaGFzSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiExfSxsLmhhc01hbnlJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzTmF2aWdhYmxlSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiExfSxsLmhhc1Byb3hpZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNFT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDkwKX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIGUzbih0aGlzLnRoaXMkMDEpfSxsLmlzVW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC84IiwxMTcxKTtmdW5jdGlvbiB3VWUoZSl7dGhpcy50aGlzJDExPWV9cCgxMTcyLDIwNjIsSG0sd1VlKSxsLmxpc3RJdGVyYXRvcl8xPWZ1bmN0aW9uKG4pe3JldHVybiBhYih0aGlzLnRoaXMkMTEsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIFFvKHRoaXMudGhpcyQxMS50aGlzJDAxKS5zaXplXzB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC84LzEiLDExNzIpO2Z1bmN0aW9uIEVVZSgpe31wKDExNzMsNTA2LGV1LEVVZSksbC5uZXdEYXRhPWZ1bmN0aW9uKG4pe3JldHVybiBCKEVzLE1lLDE0MixuLDAsMSl9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC85IiwxMTczKTtmdW5jdGlvbiB2VWUoKXtCci5jYWxsKHRoaXMpfXAoMTE2MCw0OSxHRix2VWUpLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUNsYXNzSW1wbC9NeUhhc2hTZXQiLDExNjApO2Z1bmN0aW9uIElMKGUsbil7dmFyIHI7cj0oZS5lRmxhZ3MmMjU2KSE9MCxuP2UuZUZsYWdzfD0yNTY6ZS5lRmxhZ3MmPS0yNTcsZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IHJzKGUsMSw4LHIsbikpfWZ1bmN0aW9uIHhMKCl7dGhpcy5lRmxhZ3N8PTI1Nn1wKDU3NywzNjQsezExMDoxLDk0OjEsOTM6MSwxNDI6MSwxNTY6MSw4NDc6MSwxNTU6MSwxOTc6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwzNjQ6MSwxNTg6MSwxMTk6MSwxMjA6MSw2OTE6MX0seEwpLGwuZUdldD1mdW5jdGlvbihuLHIsdCl7dmFyIG87c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzA7Y2FzZSAyOnJldHVybiB0aGlzLmluc3RhbmNlQ2xhc3NOYW1lIT1udWxsP3RoaXMuaW5zdGFuY2VDbGFzc05hbWU6dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZTtjYXNlIDM6cmV0dXJuIGtkKHRoaXMpO2Nhc2UgNDpyZXR1cm4gdGhpcy5nZXREZWZhdWx0VmFsdWUoKTtjYXNlIDU6cmV0dXJuIHRoaXMuaW5zdGFuY2VUeXBlTmFtZTtjYXNlIDY6cmV0dXJuIHI/SGEodGhpcyk6UXcodGhpcyk7Y2FzZSA3OnJldHVybiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSx0aGlzLmVUeXBlUGFyYW1ldGVycztjYXNlIDg6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmMjU2KX1yZXR1cm4gbGwodGhpcyxuLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4pLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybiB0aGlzLmluc3RhbmNlQ2xhc3NOYW1lIT1udWxsJiZ0aGlzLmluc3RhbmNlQ2xhc3NOYW1lPT10aGlzLmluc3RhbmNlVHlwZU5hbWU7Y2FzZSAzOnJldHVybiEha2QodGhpcyk7Y2FzZSA0OnJldHVybiB0aGlzLmdldERlZmF1bHRWYWx1ZSgpIT1udWxsO2Nhc2UgNTpyZXR1cm4gdGhpcy5pbnN0YW5jZVR5cGVOYW1lIT1udWxsJiZ0aGlzLmluc3RhbmNlVHlwZU5hbWUhPXRoaXMuaW5zdGFuY2VDbGFzc05hbWUmJnRoaXMuaW5zdGFuY2VUeXBlTmFtZSE9dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZTtjYXNlIDY6cmV0dXJuISFRdyh0aGlzKTtjYXNlIDc6cmV0dXJuISF0aGlzLmVUeXBlUGFyYW1ldGVycyYmdGhpcy5lVHlwZVBhcmFtZXRlcnMuc2l6ZV8wIT0wO2Nhc2UgODpyZXR1cm4odGhpcy5lRmxhZ3MmMjU2KT09MH1yZXR1cm4gc2wodGhpcyxuLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6U0wodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMjpVRCh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSA1OnIyKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDc6IXRoaXMuZVR5cGVQYXJhbWV0ZXJzJiYodGhpcy5lVHlwZVBhcmFtZXRlcnM9bmV3IFhpKGJpLHRoaXMsNykpLGZuKHRoaXMuZVR5cGVQYXJhbWV0ZXJzKSwhdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksUHIodGhpcy5lVHlwZVBhcmFtZXRlcnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgODpJTCh0aGlzLGFlKGllKHIpKSk7cmV0dXJufXVsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxBSGV9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyk7cmV0dXJuO2Nhc2UgMTpMKHRoaXMuZUNvbnRhaW5lciwxODQpJiYoYSh0aGlzLmVDb250YWluZXIsMTg0KS5lTmFtZVRvRUNsYXNzaWZpZXJNYXA9bnVsbCksZ2kodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAyOmUyKHRoaXMsbnVsbCksbjIodGhpcyx0aGlzLmluc3RhbmNlQ2xhc3NOYW1lKTtyZXR1cm47Y2FzZSA1OnIyKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgNzohdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksZm4odGhpcy5lVHlwZVBhcmFtZXRlcnMpO3JldHVybjtjYXNlIDg6SUwodGhpcywhMCk7cmV0dXJufWNsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0aGlzLmVTdGF0aWNDbGFzcygpKSxuKSl9LGwuZnJlZXplPWZ1bmN0aW9uKCl7ZDAoKEtpKCksVHQpLHRoaXMpLmdldE5hbWUoKSx0aGlzLmVGbGFnc3w9MX0sbC5nZXRDb252ZXJzaW9uRGVsZWdhdGU9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7aWYoIXRoaXMuY29udmVyc2lvbkRlbGVnYXRlSXNTZXQmJihuPXBWZShIYSh0aGlzKSksIW4uaXNFbXB0eSgpKSlmb3IodD1uLml0ZXJhdG9yXzAoKTt0Lmhhc05leHRfMCgpOylyPXhuKHQubmV4dF8xKCkpLHNTKHRoaXMscikmJnlibih0aGlzKTtyZXR1cm4gdGhpcy5jb252ZXJzaW9uRGVsZWdhdGV9LGwuZ2V0RGVmYXVsdFZhbHVlPWZ1bmN0aW9uKCl7dmFyIG47aWYoIXRoaXMuZGVmYXVsdFZhbHVlSXNTZXQpe249bnVsbDt0cnl7bj1rZCh0aGlzKX1jYXRjaChyKXtpZihyPXdyKHIpLCFMKHIsMTAzKSl0aHJvdyBiKHIpfXRoaXMuZGVmYXVsdFZhbHVlPW51bGwsbiYmbi5tb2RpZmllcnMmMSYmKG49PXlhP3RoaXMuZGVmYXVsdFZhbHVlPSh6ZSgpLFMwKTpuPT1obj90aGlzLmRlZmF1bHRWYWx1ZT1KKDApOm49PXBwP3RoaXMuZGVmYXVsdFZhbHVlPW5ldyBDQygwKTpuPT1jdD90aGlzLmRlZmF1bHRWYWx1ZT0wOm49PV9fP3RoaXMuZGVmYXVsdFZhbHVlPWVjKDApOm49PVhnP3RoaXMuZGVmYXVsdFZhbHVlPWx5KDApOm49PUppP3RoaXMuZGVmYXVsdFZhbHVlPUVDKDApOnRoaXMuZGVmYXVsdFZhbHVlPXZDKDApKSx0aGlzLmRlZmF1bHRWYWx1ZUlzU2V0PSEwfXJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZX0sbC5pc1NlcmlhbGl6YWJsZT1mdW5jdGlvbigpe3JldHVybih0aGlzLmVGbGFncyYyNTYpIT0wfSxsLnNldERhdGFUeXBlR2VuZXJhdGVkSW5zdGFuY2VDbGFzcz1mdW5jdGlvbihuKXtuJiYodGhpcy5pbnN0YW5jZUNsYXNzTmFtZT0ib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsLkFic3RyYWN0RW51bWVyYXRvciIpfSxsLnNldEdlbmVyYXRlZEluc3RhbmNlQ2xhc3M9ZnVuY3Rpb24obil7WEhlKHRoaXMsbiksdGhpcy5zZXREYXRhVHlwZUdlbmVyYXRlZEluc3RhbmNlQ2xhc3Mobil9LGwuc2V0SW5zdGFuY2VDbGFzc0dlbj1mdW5jdGlvbihuKXt0aGlzLmluc3RhbmNlQ2xhc3M9bix0aGlzLmRlZmF1bHRWYWx1ZUlzU2V0PSExfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lRmxhZ3NfMCY2ND9DTCh0aGlzKToobj1uZXcgeWwoQ0wodGhpcykpLG4uc3RyaW5nKz0iIChzZXJpYWxpemFibGU6ICIsQWMobiwodGhpcy5lRmxhZ3MmMjU2KSE9MCksbi5zdHJpbmcrPSIpIixuLnN0cmluZyl9LGwuY29udmVyc2lvbkRlbGVnYXRlSXNTZXQ9ITEsbC5kZWZhdWx0VmFsdWU9bnVsbCxsLmRlZmF1bHRWYWx1ZUlzU2V0PSExLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRURhdGFUeXBlSW1wbCIsNTc3KTtmdW5jdGlvbiBKcmUoZSl7dmFyIG47cmV0dXJuIG49KCFlLmVMaXRlcmFscyYmKGUuZUxpdGVyYWxzPW5ldyBVKHZjLGUsOSw1KSksZS5lTGl0ZXJhbHMpLG4uc2l6ZV8wIT0wP3kzbihhKE8obiwwKSw2OTQpKTpudWxsfWZ1bmN0aW9uIG0zbihlLG4pe3ZhciByLHQsbztpZihuPT1udWxsKXtmb3IodD0oIWUuZUxpdGVyYWxzJiYoZS5lTGl0ZXJhbHM9bmV3IFUodmMsZSw5LDUpKSxuZXcgWWUoZS5lTGl0ZXJhbHMpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKHI9YShlbih0KSw2OTQpLG89ci5saXRlcmFsLChvPz9yLm5hbWVfMCk9PW51bGwpcmV0dXJuIHJ9ZWxzZSBmb3IodD0oIWUuZUxpdGVyYWxzJiYoZS5lTGl0ZXJhbHM9bmV3IFUodmMsZSw5LDUpKSxuZXcgWWUoZS5lTGl0ZXJhbHMpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKHI9YShlbih0KSw2OTQpLFRlKG4sKG89ci5saXRlcmFsLG8/P3IubmFtZV8wKSkpcmV0dXJuIHI7cmV0dXJuIG51bGx9ZnVuY3Rpb24gU1VlKCl7eEwuY2FsbCh0aGlzKX1wKDQ2OSw1NzcsezExMDoxLDk0OjEsOTM6MSwxNDI6MSwxNTY6MSw4NDc6MSw2ODU6MSwxNTU6MSwxOTc6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSwzNjQ6MSw0Njk6MSwxNTg6MSwxMTk6MSwxMjA6MSw2OTE6MX0sU1VlKSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSx0aGlzLmVBbm5vdGF0aW9ucztjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wO2Nhc2UgMjpyZXR1cm4gdGhpcy5pbnN0YW5jZUNsYXNzTmFtZSE9bnVsbD90aGlzLmluc3RhbmNlQ2xhc3NOYW1lOnRoaXMuZ2VuZXJhdGVkSW5zdGFuY2VDbGFzc05hbWU7Y2FzZSAzOnJldHVybiBrZCh0aGlzKTtjYXNlIDQ6cmV0dXJuIEpyZSh0aGlzKTtjYXNlIDU6cmV0dXJuIHRoaXMuaW5zdGFuY2VUeXBlTmFtZTtjYXNlIDY6cmV0dXJuIHI/SGEodGhpcyk6UXcodGhpcyk7Y2FzZSA3OnJldHVybiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSx0aGlzLmVUeXBlUGFyYW1ldGVycztjYXNlIDg6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmMjU2KTtjYXNlIDk6cmV0dXJuIXRoaXMuZUxpdGVyYWxzJiYodGhpcy5lTGl0ZXJhbHM9bmV3IFUodmMsdGhpcyw5LDUpKSx0aGlzLmVMaXRlcmFsc31yZXR1cm4gbGwodGhpcyxuLW9uKChQZSgpLG9fKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8b18pLG4pLHIsdCl9LGwuZUludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxoaSh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgNjpyZXR1cm4gdGhpcy5lQ29udGFpbmVyJiYodD0oaT10aGlzLmVGbGFnc18wPj4xNixpPj0wP0dEKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtaSxudWxsLHQpKSksR2EodGhpcyxuLDYsdCk7Y2FzZSA5OnJldHVybiF0aGlzLmVMaXRlcmFscyYmKHRoaXMuZUxpdGVyYWxzPW5ldyBVKHZjLHRoaXMsOSw1KSksaGkodGhpcy5lTGl0ZXJhbHMsbix0KX1yZXR1cm4gcz1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLG9fKSksciksNjkpLHMuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VBZGQodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLG9fKSksbix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxEdCh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgNjpyZXR1cm4gR2EodGhpcyxudWxsLDYsdCk7Y2FzZSA3OnJldHVybiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSxEdCh0aGlzLmVUeXBlUGFyYW1ldGVycyxuLHQpO2Nhc2UgOTpyZXR1cm4hdGhpcy5lTGl0ZXJhbHMmJih0aGlzLmVMaXRlcmFscz1uZXcgVSh2Yyx0aGlzLDksNSkpLER0KHRoaXMuZUxpdGVyYWxzLG4sdCl9cmV0dXJuIGk9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHwoUGUoKSxvXykpLHIpLDY5KSxpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlUmVtb3ZlKHRoaXMsU2kodGhpcyksci1vbigoUGUoKSxvXykpLG4sdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybiB0aGlzLmluc3RhbmNlQ2xhc3NOYW1lIT1udWxsJiZ0aGlzLmluc3RhbmNlQ2xhc3NOYW1lPT10aGlzLmluc3RhbmNlVHlwZU5hbWU7Y2FzZSAzOnJldHVybiEha2QodGhpcyk7Y2FzZSA0OnJldHVybiEhSnJlKHRoaXMpO2Nhc2UgNTpyZXR1cm4gdGhpcy5pbnN0YW5jZVR5cGVOYW1lIT1udWxsJiZ0aGlzLmluc3RhbmNlVHlwZU5hbWUhPXRoaXMuaW5zdGFuY2VDbGFzc05hbWUmJnRoaXMuaW5zdGFuY2VUeXBlTmFtZSE9dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZUNsYXNzTmFtZTtjYXNlIDY6cmV0dXJuISFRdyh0aGlzKTtjYXNlIDc6cmV0dXJuISF0aGlzLmVUeXBlUGFyYW1ldGVycyYmdGhpcy5lVHlwZVBhcmFtZXRlcnMuc2l6ZV8wIT0wO2Nhc2UgODpyZXR1cm4odGhpcy5lRmxhZ3MmMjU2KT09MDtjYXNlIDk6cmV0dXJuISF0aGlzLmVMaXRlcmFscyYmdGhpcy5lTGl0ZXJhbHMuc2l6ZV8wIT0wfXJldHVybiBzbCh0aGlzLG4tb24oKFBlKCksb18pKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxvXyksbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXt2YXIgdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpLCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksUHIodGhpcy5lQW5ub3RhdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTpTTCh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSAyOlVEKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDU6cjIodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgNzohdGhpcy5lVHlwZVBhcmFtZXRlcnMmJih0aGlzLmVUeXBlUGFyYW1ldGVycz1uZXcgWGkoYmksdGhpcyw3KSksZm4odGhpcy5lVHlwZVBhcmFtZXRlcnMpLCF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSxQcih0aGlzLmVUeXBlUGFyYW1ldGVycyxhKHIsMTYpKTtyZXR1cm47Y2FzZSA4OklMKHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSA5OiF0aGlzLmVMaXRlcmFscyYmKHRoaXMuZUxpdGVyYWxzPW5ldyBVKHZjLHRoaXMsOSw1KSksZm4odGhpcy5lTGl0ZXJhbHMpLCF0aGlzLmVMaXRlcmFscyYmKHRoaXMuZUxpdGVyYWxzPW5ldyBVKHZjLHRoaXMsOSw1KSksUHIodGhpcy5lTGl0ZXJhbHMsYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxvXykpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fG9fKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxvX30sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOkwodGhpcy5lQ29udGFpbmVyLDE4NCkmJihhKHRoaXMuZUNvbnRhaW5lciwxODQpLmVOYW1lVG9FQ2xhc3NpZmllck1hcD1udWxsKSxnaSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDI6ZTIodGhpcyxudWxsKSxuMih0aGlzLHRoaXMuaW5zdGFuY2VDbGFzc05hbWUpO3JldHVybjtjYXNlIDU6cjIodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA3OiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDcpKSxmbih0aGlzLmVUeXBlUGFyYW1ldGVycyk7cmV0dXJuO2Nhc2UgODpJTCh0aGlzLCEwKTtyZXR1cm47Y2FzZSA5OiF0aGlzLmVMaXRlcmFscyYmKHRoaXMuZUxpdGVyYWxzPW5ldyBVKHZjLHRoaXMsOSw1KSksZm4odGhpcy5lTGl0ZXJhbHMpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCksb18pKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxvXyksbikpfSxsLmZyZWV6ZT1mdW5jdGlvbigpe3ZhciBuLHI7aWYodGhpcy5lTGl0ZXJhbHMpZm9yKG49MCxyPXRoaXMuZUxpdGVyYWxzLnNpemVfMDtuPHI7KytuKXJiKE8odGhpcy5lTGl0ZXJhbHMsbikpO2QwKChLaSgpLFR0KSx0aGlzKS5nZXROYW1lKCksdGhpcy5lRmxhZ3N8PTF9LGwuZ2V0RGVmYXVsdFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIEpyZSh0aGlzKX0sbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBuIT1udWxsfSxsLnNldERhdGFUeXBlR2VuZXJhdGVkSW5zdGFuY2VDbGFzcz1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUVudW1JbXBsIiw0NjkpO2Z1bmN0aW9uIENVZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT01P2UuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLDksZkwsbik6KHQ9R3QoYShrZSgocj1hKEJlKGUsMTYpLDI5KSxyfHwoUGUoKSxyMCkpLGUuZUZsYWdzXzA+PjE2KSwxOSkpLGUuZUNvbnRhaW5lci5lSW52ZXJzZVJlbW92ZShlLHQuZmVhdHVyZUlELHQuY29udGFpbmVyQ2xhc3MsbikpfWZ1bmN0aW9uIHkzbihlKXtyZXR1cm4gZS5pbnN0YW5jZT9lLmluc3RhbmNlOmUuZ2VuZXJhdGVkSW5zdGFuY2V9ZnVuY3Rpb24gVFVlKGUsbil7dmFyIHIsdCxvO289ZS5pbnN0YW5jZSxlLmluc3RhbmNlPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwzLG8sZS5pbnN0YW5jZSkpLG4/biE9ZSYmKGdpKGUsbi5uYW1lXzApLFFEKGUsbi52YWx1ZV8wKSxyPSh0PW4ubGl0ZXJhbCx0Pz9uLm5hbWVfMCksWkQoZSxyPT1udWxsfHxUZShyLG4ubmFtZV8wKT9udWxsOnIpKTooZ2koZSxudWxsKSxRRChlLDApLFpEKGUsbnVsbCkpfWZ1bmN0aW9uIFpEKGUsbil7dmFyIHI7cj1lLmxpdGVyYWwsZS5saXRlcmFsPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSw0LHIsZS5saXRlcmFsKSl9ZnVuY3Rpb24gUUQoZSxuKXt2YXIgcjtyPWUudmFsdWVfMCxlLnZhbHVlXzA9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgdEYoZSwyLHIsZS52YWx1ZV8wKSl9ZnVuY3Rpb24gYlVlKCl7dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZT10aGlzfXAoNTgyLDQ0OCx7MTEwOjEsOTQ6MSw5MzoxLDIwMzk6MSw2OTQ6MSwxNTU6MSwxOTc6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSw1ODI6MSwxNTg6MSwxMTk6MSwxMjA6MX0sYlVlKSxsLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lXzB9LGwuZUJhc2ljUmVtb3ZlRnJvbUNvbnRhaW5lckZlYXR1cmU9ZnVuY3Rpb24obil7cmV0dXJuIENVZSh0aGlzLG4pfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzA7Y2FzZSAyOnJldHVybiBKKHRoaXMudmFsdWVfMCk7Y2FzZSAzOnJldHVybiB0aGlzLmluc3RhbmNlP3RoaXMuaW5zdGFuY2U6dGhpcy5nZW5lcmF0ZWRJbnN0YW5jZTtjYXNlIDQ6cmV0dXJuIGk9dGhpcy5saXRlcmFsLGk/P3RoaXMubmFtZV8wO2Nhc2UgNTpyZXR1cm4gdGhpcy5lRmxhZ3NfMD4+MTY9PTU/YSh0aGlzLmVDb250YWluZXIsNjg1KTpudWxsfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCkscjApKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHxyMCksbikscix0KX0sbC5lSW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHM7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGhpKHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSA1OnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShpPXRoaXMuZUZsYWdzXzA+PjE2LGk+PTA/Q1VlKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtaSxudWxsLHQpKSksR2EodGhpcyxuLDUsdCl9cmV0dXJuIHM9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHwoUGUoKSxyMCkpLHIpLDY5KSxzLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlQWRkKHRoaXMsU2kodGhpcyksci1vbigoUGUoKSxyMCkpLG4sdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksRHQodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDU6cmV0dXJuIEdhKHRoaXMsbnVsbCw1LHQpfXJldHVybiBpPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KFBlKCkscjApKSxyKSw2OSksaS5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZVJlbW92ZSh0aGlzLFNpKHRoaXMpLHItb24oKFBlKCkscjApKSxuLHQpfSxsLmVJc1NldD1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiEhdGhpcy5lQW5ub3RhdGlvbnMmJnRoaXMuZUFubm90YXRpb25zLnNpemVfMCE9MDtjYXNlIDE6cmV0dXJuIHRoaXMubmFtZV8wIT1udWxsO2Nhc2UgMjpyZXR1cm4gdGhpcy52YWx1ZV8wIT0wO2Nhc2UgMzpyZXR1cm4hIXRoaXMuaW5zdGFuY2U7Y2FzZSA0OnJldHVybiB0aGlzLmxpdGVyYWwhPW51bGw7Y2FzZSA1OnJldHVybiEhKHRoaXMuZUZsYWdzXzA+PjE2PT01JiZhKHRoaXMuZUNvbnRhaW5lciw2ODUpKX1yZXR1cm4gc2wodGhpcyxuLW9uKChQZSgpLHIwKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8cjApLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6Z2kodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMjpRRCh0aGlzLGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgMzpUVWUodGhpcyxhKHIsMjAzOSkpO3JldHVybjtjYXNlIDQ6WkQodGhpcyx4bihyKSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxyMCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fHIwKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxyMH0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOmdpKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMjpRRCh0aGlzLDApO3JldHVybjtjYXNlIDM6VFVlKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgNDpaRCh0aGlzLG51bGwpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCkscjApKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxyMCksbikpfSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10aGlzLmxpdGVyYWwsbj8/dGhpcy5uYW1lXzB9LGwuaW5zdGFuY2U9bnVsbCxsLmxpdGVyYWw9bnVsbCxsLnZhbHVlXzA9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVFbnVtTGl0ZXJhbEltcGwiLDU4Mik7dmFyIHczbj1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFRmFjdG9yeUltcGwvSW50ZXJuYWxFRGF0ZVRpbWVGb3JtYXQiKTtmdW5jdGlvbiBJVWUoZSxuKXtyZXR1cm4gcVhlKGUuZGF0ZVRpbWVGb3JtYXQsbixudWxsKX1mdW5jdGlvbiB4VWUoZSxuKXtyZXR1cm4gZUplKGUuZGF0ZVRpbWVGb3JtYXQsbil9ZnVuY3Rpb24gRWIoZSl7dGhpcy5kYXRlVGltZUZvcm1hdD1lfXAoNDk5LDEsezIxMTQ6MX0sRWIpLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRUZhY3RvcnlJbXBsLzFDbGllbnRJbnRlcm5hbEVEYXRlVGltZUZvcm1hdCIsNDk5KTtmdW5jdGlvbiBQVWUoZSxuLHIpe3ZhciB0LG87cmV0dXJuIG89ZS5lTG93ZXJCb3VuZCxlLmVMb3dlckJvdW5kPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJih0PW5ldyBsdChlLDEsMyxvLG4pLHI/ci5hZGRfNSh0KTpyPXQpLHJ9ZnVuY3Rpb24gRTNuKGUsbixyKXt2YXIgdCxvO3JldHVybiBvPWUuZVR5cGVQYXJhbWV0ZXIsZS5lVHlwZVBhcmFtZXRlcj1uLGUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiYodD1uZXcgbHQoZSwxLDQsbyxuKSxyP3IuYWRkXzUodCk6cj10KSxvIT1uJiYobj9yPWkyKGUsTkwoZSxuKSxyKTpyPWkyKGUsZS5lQ2xhc3NpZmllcixyKSkscn1mdW5jdGlvbiBOVWUoZSxuLHIpe3ZhciB0LG87cmV0dXJuIG89ZS5lVXBwZXJCb3VuZCxlLmVVcHBlckJvdW5kPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJih0PW5ldyBsdChlLDEsMCxvLG4pLHI/ci5hZGRfNSh0KTpyPXQpLHJ9ZnVuY3Rpb24gZUYoZSl7dmFyIG47cmV0dXJuIGUuZUNsYXNzaWZpZXImJmUuZUNsYXNzaWZpZXIuZUlzUHJveHkoKSYmKG49YShlLmVDbGFzc2lmaWVyLDU0KSxlLmVDbGFzc2lmaWVyPWEoSjAoZSxuKSwxNDIpLGUuZUNsYXNzaWZpZXIhPW4mJmUuZUZsYWdzXzAmNCYmIShlLmVGbGFnc18wJjEpJiZYbihlLG5ldyBsdChlLDksNSxuLGUuZUNsYXNzaWZpZXIpKSksZS5lQ2xhc3NpZmllcn1mdW5jdGlvbiBQTChlKXt2YXIgbixyO3JldHVybiBlLmVSYXdUeXBlJiZlLmVSYXdUeXBlLmVJc1Byb3h5KCkmJihyPWEoZS5lUmF3VHlwZSw1NCksZS5lUmF3VHlwZT1hKEowKGUsciksMTQyKSxlLmVSYXdUeXBlIT1yJiYoZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsOSwyLHIsZS5lUmF3VHlwZSkpLEwoZS5lQ29udGFpbmVyLDQxMSk/ZS5lRmxhZ3NfMD4+MTY9PS0xNSYmZS5lQ29udGFpbmVyLmVOb3RpZmljYXRpb25SZXF1aXJlZCgpJiZoRChuZXcgb0YoZS5lQ29udGFpbmVyLDksMTMscixlLmVSYXdUeXBlLHMwKG1hKGEoZS5lQ29udGFpbmVyLDYyKSksZSkpKTpMKGUuZUNvbnRhaW5lciw5MCkmJmUuZUZsYWdzXzA+PjE2PT0tMjMmJmUuZUNvbnRhaW5lci5lTm90aWZpY2F0aW9uUmVxdWlyZWQoKSYmKG49ZS5lUmF3VHlwZSxMKG4sOTApfHwobj0oUGUoKSxObCkpLEwociw5MCl8fChyPShQZSgpLE5sKSksaEQobmV3IG9GKGUuZUNvbnRhaW5lciw5LDEwLHIsbixzMChRbyhhKGUuZUNvbnRhaW5lciwyOSkpLGUpKSkpKSksZS5lUmF3VHlwZX1mdW5jdGlvbiBPZChlKXtyZXR1cm4hZS5lVHlwZUFyZ3VtZW50cyYmKGUuZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LGUsMSkpLGUuZVR5cGVBcmd1bWVudHN9ZnVuY3Rpb24gTkwoZSxuKXt2YXIgcix0LG8saSxzO2lmKG4pe2ZvcihpPUwoZS5lQ29udGFpbmVyLDkwKXx8TChlLmVDb250YWluZXIsMTAyKSxzPSFpJiZMKGUuZUNvbnRhaW5lciwzMzEpLHQ9bmV3IFllKCghbi5lQm91bmRzJiYobi5lQm91bmRzPW5ldyBJUyhuLEt0LG4pKSxuLmVCb3VuZHMpKTt0LmN1cnNvciE9dC50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKHI9YShlbih0KSw4OSksbz1QTChyKSxpP0wobyw5MCk6cz9MKG8sMTU2KTpvKXJldHVybiBvO3JldHVybiBpPyhQZSgpLE5sKTooUGUoKSxWcyl9ZWxzZSByZXR1cm4gbnVsbH1mdW5jdGlvbiBvMihlLG4pe3ZhciByLHQ7dD1lLmVDbGFzc2lmaWVyLHI9djNuKGUsbixudWxsKSx0IT1uJiYhZS5lVHlwZVBhcmFtZXRlciYmKHI9aTIoZSxuLHIpKSxyJiZyLmRpc3BhdGNoXzAoKX1mdW5jdGlvbiB2M24oZSxuLHIpe3ZhciB0LG87cmV0dXJuIG89ZS5lQ2xhc3NpZmllcixlLmVDbGFzc2lmaWVyPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJih0PW5ldyBsdChlLDEsNSxvLGUuZUNsYXNzaWZpZXIpLHI/X3JlKHIsdCk6cj10KSxyfWZ1bmN0aW9uIFpyZShlLG4pe3ZhciByO24hPWUuZUxvd2VyQm91bmQ/KHI9bnVsbCxlLmVMb3dlckJvdW5kJiYocj1BQShlLmVMb3dlckJvdW5kLGUsLTQscikpLG4mJihyPWhtKG4sZSwtNCxyKSkscj1QVWUoZSxuLHIpLHImJnIuZGlzcGF0Y2hfMCgpKTplLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDMsbixuKSl9ZnVuY3Rpb24gaTIoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfO2lmKF89ZS5lUmF3VHlwZSwhbiYmKG49ZXRlKSxlLmVSYXdUeXBlPW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJihjPW5ldyBsdChlLDEsMixfLGUuZVJhd1R5cGUpLHI/ci5hZGRfNShjKTpyPWMpLF8hPW4pe2lmKEwoZS5lQ29udGFpbmVyLDI5MikpZS5lRmxhZ3NfMD4+MTY9PS0xMD9yPWEoZS5lQ29udGFpbmVyLDI5Mikuc2V0RVR5cGUobixyKTplLmVGbGFnc18wPj4xNj09LTE1JiYoIW4mJihuPShQZSgpLFZzKSksIV8mJihfPShQZSgpLFZzKSksZS5lQ29udGFpbmVyLmVOb3RpZmljYXRpb25SZXF1aXJlZCgpJiYoYz1uZXcgU2MoZS5lQ29udGFpbmVyLDEsMTMsXyxuLHMwKG1hKGEoZS5lQ29udGFpbmVyLDYyKSksZSksITEpLHI/ci5hZGRfNShjKTpyPWMpKTtlbHNlIGlmKEwoZS5lQ29udGFpbmVyLDkwKSllLmVGbGFnc18wPj4xNj09LTIzJiYoTChuLDkwKXx8KG49KFBlKCksTmwpKSxMKF8sOTApfHwoXz0oUGUoKSxObCkpLGUuZUNvbnRhaW5lci5lTm90aWZpY2F0aW9uUmVxdWlyZWQoKSYmKGM9bmV3IFNjKGUuZUNvbnRhaW5lciwxLDEwLF8sbixzMChRbyhhKGUuZUNvbnRhaW5lciwyOSkpLGUpLCExKSxyP3IuYWRkXzUoYyk6cj1jKSk7ZWxzZSBpZihMKGUuZUNvbnRhaW5lciw0NTcpKWZvcih1PWEoZS5lQ29udGFpbmVyLDg1MCkscz0oIXUuZUdlbmVyaWNUeXBlcyYmKHUuZUdlbmVyaWNUeXBlcz1uZXcgUkwobmV3IGdGKSksdS5lR2VuZXJpY1R5cGVzKSxpPSh0PW5ldyBMXyhuZXcgQV8ocy50aGlzJDExKS50aGlzJDAxKSxuZXcgREwodCkpO2kudmFsJGRlbGVnYXRlSXRlcmF0b3IyLmhhc05leHQ7KW89YShOMShpLnZhbCRkZWxlZ2F0ZUl0ZXJhdG9yMikuZ2V0S2V5KCksODkpLHI9aTIobyxOTChvLHUpLHIpfXJldHVybiByfWZ1bmN0aW9uIFFyZShlLG4pe3ZhciByO24hPWUuZVR5cGVQYXJhbWV0ZXI/KGUuZVR5cGVQYXJhbWV0ZXImJk9XZSgkdGUoZS5lVHlwZVBhcmFtZXRlciksZSksbiYmKCFuLmVHZW5lcmljVHlwZXMmJihuLmVHZW5lcmljVHlwZXM9bmV3IFJMKG5ldyBnRikpLGtXZShuLmVHZW5lcmljVHlwZXMsZSkpLHI9RTNuKGUsbixudWxsKSxyJiZyLmRpc3BhdGNoXzAoKSk6ZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSw0LG4sbikpfWZ1bmN0aW9uIEFVZShlLG4pe3ZhciByO24hPWUuZVVwcGVyQm91bmQ/KHI9bnVsbCxlLmVVcHBlckJvdW5kJiYocj1BQShlLmVVcHBlckJvdW5kLGUsLTEscikpLG4mJihyPWhtKG4sZSwtMSxyKSkscj1OVWUoZSxuLHIpLHImJnIuZGlzcGF0Y2hfMCgpKTplLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDAsbixuKSl9ZnVuY3Rpb24gbkYoZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZihlLmVDbGFzc2lmaWVyKXtpZih1PWUuZUNsYXNzaWZpZXIuZ2V0TmFtZSgpLGM9bnVsbCx1IT1udWxsP24uc3RyaW5nKz0iIit1OihzPWUuZUNsYXNzaWZpZXIuZ2V0SW5zdGFuY2VUeXBlTmFtZSgpLHMhPW51bGwmJihpPW91KHMseGkoOTEpKSxpIT0tMT8oYz0oSGUoaSxzLmxlbmd0aCsxKSxzLnN1YnN0cihpKSksbi5zdHJpbmcrPSIiK1lhKHM9PW51bGw/Im51bGwiOihWZShzKSxzKSwwLGkpKTpuLnN0cmluZys9IiIrcykpLGUuZVR5cGVBcmd1bWVudHMmJmUuZVR5cGVBcmd1bWVudHMuc2l6ZV8wIT0wKXtmb3Iobz0hMCxuLnN0cmluZys9IjwiLHQ9bmV3IFllKGUuZVR5cGVBcmd1bWVudHMpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDg5KSxvP289ITE6bi5zdHJpbmcrPSIsICIsbkYocixuKTtuLnN0cmluZys9Ij4ifWMhPW51bGwmJihuLnN0cmluZys9IiIrYyl9ZWxzZSBlLmVUeXBlUGFyYW1ldGVyPyh1PWUuZVR5cGVQYXJhbWV0ZXIubmFtZV8wLHUhPW51bGwmJihuLnN0cmluZys9IiIrdSkpOihuLnN0cmluZys9Ij8iLGUuZUxvd2VyQm91bmQ/KG4uc3RyaW5nKz0iIHN1cGVyICIsbkYoZS5lTG93ZXJCb3VuZCxuKSk6ZS5lVXBwZXJCb3VuZCYmKG4uc3RyaW5nKz0iIGV4dGVuZHMgIixuRihlLmVVcHBlckJvdW5kLG4pKSl9ZnVuY3Rpb24gTWQoKXt0aGlzLmVSYXdUeXBlPWV0ZX1wKDI0OCwxMjAsezExMDoxLDk0OjEsOTM6MSw4OToxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDI0ODoxLDExOToxLDEyMDoxfSxNZCksbC5lQmFzaWNTZXRDb250YWluZXJfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87cmV0dXJuIHQ9R2EodGhpcyxuLHIsdCksdGhpcy5lVHlwZVBhcmFtZXRlciYmTChuLDE3OSkmJihvPU5MKHRoaXMsdGhpcy5lVHlwZVBhcmFtZXRlciksbyE9dGhpcy5lUmF3VHlwZSYmKHQ9aTIodGhpcyxvLHQpKSksdH0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbztzd2l0Y2gobil7Y2FzZSAwOnJldHVybiB0aGlzLmVVcHBlckJvdW5kO2Nhc2UgMTpyZXR1cm4hdGhpcy5lVHlwZUFyZ3VtZW50cyYmKHRoaXMuZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LHRoaXMsMSkpLHRoaXMuZVR5cGVBcmd1bWVudHM7Y2FzZSAyOnJldHVybiByP1BMKHRoaXMpOnRoaXMuZVJhd1R5cGU7Y2FzZSAzOnJldHVybiB0aGlzLmVMb3dlckJvdW5kO2Nhc2UgNDpyZXR1cm4gdGhpcy5lVHlwZVBhcmFtZXRlcjtjYXNlIDU6cmV0dXJuIHI/ZUYodGhpcyk6dGhpcy5lQ2xhc3NpZmllcn1yZXR1cm4gbGwodGhpcyxuLW9uKChQZSgpLEFkKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8QWQpLG4pLHIsdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBOVWUodGhpcyxudWxsLHQpO2Nhc2UgMTpyZXR1cm4hdGhpcy5lVHlwZUFyZ3VtZW50cyYmKHRoaXMuZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LHRoaXMsMSkpLER0KHRoaXMuZVR5cGVBcmd1bWVudHMsbix0KTtjYXNlIDM6cmV0dXJuIFBVZSh0aGlzLG51bGwsdCl9cmV0dXJuIGk9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHwoUGUoKSxBZCkpLHIpLDY5KSxpLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlUmVtb3ZlKHRoaXMsU2kodGhpcyksci1vbigoUGUoKSxBZCkpLG4sdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVVcHBlckJvdW5kO2Nhc2UgMTpyZXR1cm4hIXRoaXMuZVR5cGVBcmd1bWVudHMmJnRoaXMuZVR5cGVBcmd1bWVudHMuc2l6ZV8wIT0wO2Nhc2UgMjpyZXR1cm4hIXRoaXMuZVJhd1R5cGU7Y2FzZSAzOnJldHVybiEhdGhpcy5lTG93ZXJCb3VuZDtjYXNlIDQ6cmV0dXJuISF0aGlzLmVUeXBlUGFyYW1ldGVyO2Nhc2UgNTpyZXR1cm4hIXRoaXMuZUNsYXNzaWZpZXJ9cmV0dXJuIHNsKHRoaXMsbi1vbigoUGUoKSxBZCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fEFkKSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0O3N3aXRjaChuKXtjYXNlIDA6QVVlKHRoaXMsYShyLDg5KSk7cmV0dXJuO2Nhc2UgMTohdGhpcy5lVHlwZUFyZ3VtZW50cyYmKHRoaXMuZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LHRoaXMsMSkpLGZuKHRoaXMuZVR5cGVBcmd1bWVudHMpLCF0aGlzLmVUeXBlQXJndW1lbnRzJiYodGhpcy5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsdGhpcywxKSksUHIodGhpcy5lVHlwZUFyZ3VtZW50cyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAzOlpyZSh0aGlzLGEociw4OSkpO3JldHVybjtjYXNlIDQ6UXJlKHRoaXMsYShyLDg1MCkpO3JldHVybjtjYXNlIDU6bzIodGhpcyxhKHIsMTQyKSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxBZCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fEFkKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxBZH0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpBVWUodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAxOiF0aGlzLmVUeXBlQXJndW1lbnRzJiYodGhpcy5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsdGhpcywxKSksZm4odGhpcy5lVHlwZUFyZ3VtZW50cyk7cmV0dXJuO2Nhc2UgMzpacmUodGhpcyxudWxsKTtyZXR1cm47Y2FzZSA0OlFyZSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDU6bzIodGhpcyxudWxsKTtyZXR1cm59Y2wodGhpcyxuLW9uKChQZSgpLEFkKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8QWQpLG4pKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49bmV3IExhKG5zKHRoaXMpKSxuLnN0cmluZys9IiAoZXhwcmVzc2lvbjogIixuRih0aGlzLG4pLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmd9O3ZhciBldGU7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFR2VuZXJpY1R5cGVJbXBsIiwyNDgpO2Z1bmN0aW9uIExVZShlLG4scil7dmFyIHQ7dD1lLmxpc3RJdGVyYXRvcl8xKG4pLHQuYWRkXzEocil9cCgyMDY3LDIwNjIsWWIpLGwuYWRkVW5pcXVlPWZ1bmN0aW9uKG4scil7TFVlKHRoaXMsbixyKX0sbC5iYXNpY0FkZD1mdW5jdGlvbihuLHIpe3JldHVybiBMVWUodGhpcyx0aGlzLnNpemVfMSgpLG4pLHJ9LGwuYmFzaWNHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIFZhKHRoaXMuYmFzaWNMaXN0KCksbil9LGwuYmFzaWNJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhc2ljTGlzdEl0ZXJhdG9yKCl9LGwuYmFzaWNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBNamUodGhpcyl9LGwuYmFzaWNMaXN0SXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5iYXNpY0xpc3RJdGVyYXRvcl8wKDApfSxsLmJhc2ljTGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuYmFzaWNMaXN0KCkubGlzdEl0ZXJhdG9yXzEobil9LGwuYmFzaWNSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gWWQodGhpcyxuLCEwKSxyfSxsLm1vdmU9ZnVuY3Rpb24obixyKXt2YXIgdCxvO3JldHVybiBvPXM1KHRoaXMsciksdD10aGlzLmxpc3RJdGVyYXRvcl8xKG4pLHQuYWRkXzEobyksb30sbC5tb3ZlXzA9ZnVuY3Rpb24obixyKXt2YXIgdDtZZCh0aGlzLHIsITApLHQ9dGhpcy5saXN0SXRlcmF0b3JfMShuKSx0LmFkZF8xKHIpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkFic3RyYWN0U2VxdWVudGlhbEludGVybmFsRUxpc3QiLDIwNjcpO2Z1bmN0aW9uIFRTKCl7VFM9RixyRj1uZXcgSmplfWZ1bmN0aW9uIGtVZShlKXtyZXR1cm4gTChlLDEwMikmJihhKGUsMTkpLmVGbGFncyZHbykhPTB9ZnVuY3Rpb24gbnRlKGUpe3ZhciBuO3JldHVybiBlLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9PW51bGw/KHUwKCksdTAoKSxTYik6KG49ZS5yZXNvbHZlXzAoKT9lLm5ld1Jlc29sdmluZ0xpc3RJdGVyYXRvcigpOmUubmV3Tm9uUmVzb2x2aW5nTGlzdEl0ZXJhdG9yKCksbil9ZnVuY3Rpb24gdmIoZSxuKXtUUygpLHRoaXMuZU9iamVjdD1lLHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlcz1ufXAoNDk2LDIwNjcsWWIsdmIpLGwuYmFzaWNHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIFZhKHRoaXMuYmFzaWNMaXN0KCksbil9LGwuYmFzaWNJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9PW51bGw/KHUwKCksdTAoKSxTYik6dGhpcy5uZXdOb25SZXNvbHZpbmdMaXN0SXRlcmF0b3IoKX0sbC5iYXNpY0xpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFpqZSh0aGlzLmVPYmplY3QsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzKX0sbC5iYXNpY0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9PW51bGw/KHUwKCksdTAoKSxTYik6dGhpcy5uZXdOb25SZXNvbHZpbmdMaXN0SXRlcmF0b3IoKX0sbC5iYXNpY0xpc3RJdGVyYXRvcl8wPWZ1bmN0aW9uKG4pe3ZhciByLHQ7aWYodGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzPT1udWxsKXtpZihuPDB8fG4+MSl0aHJvdyBiKG5ldyBubygiaW5kZXg9IituKyIsIHNpemU9MCIpKTtyZXR1cm4gdTAoKSx1MCgpLFNifWZvcih0PXRoaXMubmV3Tm9uUmVzb2x2aW5nTGlzdEl0ZXJhdG9yKCkscj0wO3I8bjsrK3IpQUwodCk7cmV0dXJuIHR9LGwuaXNFbXB0eT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGkscztpZih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMhPW51bGwpe2Zvcih0PTA7dDx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMubGVuZ3RoOysrdClpZihuPXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlc1t0XSwhdGhpcy51c2VJc1NldCgpfHx0aGlzLmVPYmplY3QuZUlzU2V0XzAobikpe2lmKHM9dGhpcy5lT2JqZWN0LmVHZXRfMShuLCExKSxIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSl7Zm9yKHI9YShzLDE2MCksbz0wLGk9ci5zaXplXzEoKTtvPGk7KytvKWlmKGtVZShyLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZV8wKG8pKSYmci5nZXRWYWx1ZV8xKG8pIT1udWxsKXJldHVybiExfWVsc2UgaWYobi5pc01hbnkoKSl7aWYoIWEocywxNikuaXNFbXB0eSgpKXJldHVybiExfWVsc2UgaWYocyE9bnVsbClyZXR1cm4hMX19cmV0dXJuITB9LGwuaXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiBudGUodGhpcyl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7dmFyIHIsdDtpZih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXM9PW51bGwpe2lmKG4hPTApdGhyb3cgYihuZXcgbm8oImluZGV4PSIrbisiLCBzaXplPTAiKSk7cmV0dXJuIHUwKCksdTAoKSxTYn1mb3IodD10aGlzLnJlc29sdmVfMCgpP3RoaXMubmV3UmVzb2x2aW5nTGlzdEl0ZXJhdG9yKCk6dGhpcy5uZXdOb25SZXNvbHZpbmdMaXN0SXRlcmF0b3IoKSxyPTA7cjxuOysrcilBTCh0KTtyZXR1cm4gdH0sbC5tb3ZlPWZ1bmN0aW9uKG4scil7dGhyb3cgYihuZXcgVG4pfSxsLm1vdmVfMD1mdW5jdGlvbihuLHIpe3Rocm93IGIobmV3IFRuKX0sbC5uZXdOb25SZXNvbHZpbmdMaXN0SXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IExMKHRoaXMuZU9iamVjdCx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpfSxsLm5ld1Jlc29sdmluZ0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgcnRlKHRoaXMuZU9iamVjdCx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpfSxsLnJlc29sdmVfMD1mdW5jdGlvbigpe3JldHVybiEwfSxsLnNpemVfMT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGkscyx1O2lmKGk9MCx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMhPW51bGwpe2Zvcih0PTA7dDx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMubGVuZ3RoOysrdClpZihuPXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlc1t0XSwhdGhpcy51c2VJc1NldCgpfHx0aGlzLmVPYmplY3QuZUlzU2V0XzAobikpaWYodT10aGlzLmVPYmplY3QuZUdldF8xKG4sITEpLEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpKWZvcihyPWEodSwxNjApLG89MCxzPXIuc2l6ZV8xKCk7bzxzOysrbylrVWUoci5nZXRFU3RydWN0dXJhbEZlYXR1cmVfMChvKSkmJnIuZ2V0VmFsdWVfMShvKSE9bnVsbCYmKytpO2Vsc2Ugbi5pc01hbnkoKT9pKz1hKHUsMTYpLnNpemVfMSgpOnUhPW51bGwmJisraX1yZXR1cm4gaX0sbC51c2VJc1NldD1mdW5jdGlvbigpe3JldHVybiEwfTt2YXIgckY7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFQ29udGVudHNFTGlzdCIsNDk2KTtmdW5jdGlvbiBPVWUoZSxuKXtUUygpLHZiLmNhbGwodGhpcyxlLG4pfXAoMTE3Nyw0OTYsWWIsT1VlKSxsLm5ld05vblJlc29sdmluZ0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgJFVlKHRoaXMuZU9iamVjdCx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpfSxsLm5ld1Jlc29sdmluZ0xpc3RJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgelVlKHRoaXMuZU9iamVjdCx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMpfSxsLnVzZUlzU2V0PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRU5hbWVkRWxlbWVudEltcGwvMSIsMTE3Nyk7ZnVuY3Rpb24gdTAoKXt1MD1GLFNiPW5ldyBRamV9ZnVuY3Rpb24gQUwoZSl7dmFyIG47aWYoZS5wcmVwYXJlZD4xfHxlLmhhc05leHRfMCgpKXJldHVybisrZS5jdXJzb3IsZS5wcmVwYXJlZD0wLG49ZS5wcmVwYXJlZFJlc3VsdCxlLmhhc05leHRfMCgpLG47dGhyb3cgYihuZXcgUG8pfWZ1bmN0aW9uIE1VZShlKXt2YXIgbixyO2lmKGUuaXNIYW5kbGluZ0ZlYXR1cmVNYXApe2Zvcig7ZS52YWx1ZUxpc3RJbmRleDxlLnZhbHVlTGlzdFNpemU7KXtpZihuPWEoZS52YWx1ZUludGVybmFsRUxpc3Q/ZS52YWx1ZUludGVybmFsRUxpc3QuYmFzaWNHZXQoZS52YWx1ZUxpc3RJbmRleCk6ZS52YWx1ZUxpc3QuZ2V0XzAoZS52YWx1ZUxpc3RJbmRleCksNzYpLHI9bi5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxMKHIsMTAyKSYmYShyLDE5KS5lRmxhZ3MmR28mJighZS5mZWF0dXJlRmlsdGVyfHxyLmdldENvbnRhaW5lckNsYXNzKCkhPWt3fHxyLmdldEZlYXR1cmVJRF8wKCkhPTApJiZuLmdldFZhbHVlKCkhPW51bGwpcmV0dXJuITA7KytlLnZhbHVlTGlzdEluZGV4fXJldHVybiExfWVsc2UgcmV0dXJuIGUudmFsdWVMaXN0SW5kZXg8ZS52YWx1ZUxpc3RTaXplfWZ1bmN0aW9uIFJVZShlLG4pe3ZhciByLHQ7aWYoZS5pc0hhbmRsaW5nRmVhdHVyZU1hcCl7Zm9yKDtuLmhhc05leHRfMCgpOylpZihyPWEobi5uZXh0XzEoKSw3NiksdD1yLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLEwodCwxMDIpJiZhKHQsMTkpLmVGbGFncyZHbyYmKCFlLmZlYXR1cmVGaWx0ZXJ8fHQuZ2V0Q29udGFpbmVyQ2xhc3MoKSE9a3d8fHQuZ2V0RmVhdHVyZUlEXzAoKSE9MCkmJnIuZ2V0VmFsdWUoKSE9bnVsbClyZXR1cm4gbi5wcmV2aW91c18wKCksITA7cmV0dXJuITF9ZWxzZSByZXR1cm4gbi5oYXNOZXh0XzAoKX1mdW5jdGlvbiBEVWUoZSl7dmFyIG4scjtpZihlLmlzSGFuZGxpbmdGZWF0dXJlTWFwKXtmb3IoO2UudmFsdWVMaXN0SW5kZXg+MDspe2lmKG49YShlLnZhbHVlTGlzdC5nZXRfMChlLnZhbHVlTGlzdEluZGV4LTEpLDc2KSxyPW4uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksTChyLDEwMikmJmEociwxOSkuZUZsYWdzJkdvJiYoIWUuZmVhdHVyZUZpbHRlcnx8ci5nZXRDb250YWluZXJDbGFzcygpIT1rd3x8ci5nZXRGZWF0dXJlSURfMCgpIT0wKSYmbi5nZXRWYWx1ZSgpIT1udWxsKXJldHVybiEwOy0tZS52YWx1ZUxpc3RJbmRleH1yZXR1cm4hMX1lbHNlIHJldHVybiBlLnZhbHVlTGlzdEluZGV4PjB9ZnVuY3Rpb24gRlVlKGUsbil7dmFyIHIsdDtpZihlLmlzSGFuZGxpbmdGZWF0dXJlTWFwKXtmb3IoO24uaGFzUHJldmlvdXMoKTspaWYocj1hKG4ucHJldmlvdXNfMCgpLDc2KSx0PXIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksTCh0LDEwMikmJmEodCwxOSkuZUZsYWdzJkdvJiYoIWUuZmVhdHVyZUZpbHRlcnx8dC5nZXRDb250YWluZXJDbGFzcygpIT1rd3x8dC5nZXRGZWF0dXJlSURfMCgpIT0wKSYmci5nZXRWYWx1ZSgpIT1udWxsKXJldHVybiBuLm5leHRfMSgpLCEwO3JldHVybiExfWVsc2UgcmV0dXJuIG4uaGFzUHJldmlvdXMoKX1mdW5jdGlvbiBMTChlLG4pe3UwKCksdGhpcy5lT2JqZWN0PWUsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmVzPW59cCgyODcsMSxLYixMTCksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwuYWRkXzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLmZpbHRlcl8wPWZ1bmN0aW9uKG4pe2lmKHRoaXMucHJlcGFyZWQhPTB8fHRoaXMuZmVhdHVyZUZpbHRlcil0aHJvdyBiKG5ldyBybygiSXRlcmF0b3IgYWxyZWFkeSBpbiB1c2Ugb3IgYWxyZWFkeSBmaWx0ZXJlZCIpKTt0aGlzLmZlYXR1cmVGaWx0ZXI9bn0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHM7c3dpdGNoKHRoaXMucHJlcGFyZWQpe2Nhc2UgMzpjYXNlIDI6cmV0dXJuITA7Y2FzZSAxOnJldHVybiExO2Nhc2UtMzp0aGlzLnZhbHVlcz90aGlzLnZhbHVlcy5uZXh0XzEoKTorK3RoaXMudmFsdWVMaXN0SW5kZXg7ZGVmYXVsdDppZighdGhpcy52YWx1ZUxpc3R8fCh0aGlzLnZhbHVlcz8hUlVlKHRoaXMsdGhpcy52YWx1ZXMpOiFNVWUodGhpcykpKXtmb3IoO3RoaXMuZmVhdHVyZUN1cnNvcjx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXMubGVuZ3RoOylpZihyPXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlc1t0aGlzLmZlYXR1cmVDdXJzb3IrK10sKCF0aGlzLmZlYXR1cmVGaWx0ZXJ8fHIuZ2V0Q29udGFpbmVyQ2xhc3MoKSE9a3d8fHIuZ2V0RmVhdHVyZUlEXzAoKSE9MCkmJighdGhpcy51c2VJc1NldCgpfHx0aGlzLmVPYmplY3QuZUlzU2V0XzAocikpKXtpZihzPXRoaXMuZU9iamVjdC5lR2V0XzEocix0aGlzLnJlc29sdmVfMCgpKSx0aGlzLmlzSGFuZGxpbmdGZWF0dXJlTWFwPShIdCgpLGEociw2OSkuaXNGZWF0dXJlTWFwXzAoKSksdGhpcy5pc0hhbmRsaW5nRmVhdHVyZU1hcHx8ci5pc01hbnkoKSl7aWYodGhpcy5yZXNvbHZlXzAoKT8obz1hKHMsMTUpLHRoaXMudmFsdWVMaXN0PW8pOihvPWEocyw3MSksdGhpcy52YWx1ZUxpc3Q9dGhpcy52YWx1ZUludGVybmFsRUxpc3Q9byksTCh0aGlzLnZhbHVlTGlzdCw1OSk/KHRoaXMudmFsdWVzPW51bGwsdGhpcy52YWx1ZUxpc3RTaXplPXRoaXMudmFsdWVMaXN0LnNpemVfMSgpLHRoaXMudmFsdWVMaXN0SW5kZXg9MCk6dGhpcy52YWx1ZXM9dGhpcy52YWx1ZUludGVybmFsRUxpc3Q/dGhpcy52YWx1ZUludGVybmFsRUxpc3QuYmFzaWNMaXN0SXRlcmF0b3IoKTp0aGlzLnZhbHVlTGlzdC5saXN0SXRlcmF0b3JfMCgpLHRoaXMudmFsdWVzP1JVZSh0aGlzLHRoaXMudmFsdWVzKTpNVWUodGhpcykpcmV0dXJuIGk9dGhpcy52YWx1ZXM/dGhpcy52YWx1ZXMubmV4dF8xKCk6dGhpcy52YWx1ZUludGVybmFsRUxpc3Q/dGhpcy52YWx1ZUludGVybmFsRUxpc3QuYmFzaWNHZXQodGhpcy52YWx1ZUxpc3RJbmRleCsrKTp0aGlzLnZhbHVlTGlzdC5nZXRfMCh0aGlzLnZhbHVlTGlzdEluZGV4KyspLHRoaXMuaXNIYW5kbGluZ0ZlYXR1cmVNYXA/KG49YShpLDc2KSxuLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLHQ9bi5nZXRWYWx1ZSgpLHRoaXMucHJlcGFyZWRSZXN1bHQ9dCk6KHQ9aSx0aGlzLnByZXBhcmVkUmVzdWx0PXQpLHRoaXMucHJlcGFyZWQ9MywhMH1lbHNlIGlmKHMhPW51bGwpcmV0dXJuIHRoaXMudmFsdWVMaXN0PW51bGwsdGhpcy52YWx1ZXM9bnVsbCx0PXMsdGhpcy5wcmVwYXJlZFJlc3VsdD10LHRoaXMucHJlcGFyZWQ9MiwhMH1yZXR1cm4gdGhpcy52YWx1ZUxpc3Q9bnVsbCx0aGlzLnZhbHVlcz1udWxsLHRoaXMuaXNIYW5kbGluZ0ZlYXR1cmVNYXA9ITEsdGhpcy5wcmVwYXJlZD0xLCExfWVsc2UgcmV0dXJuIGk9dGhpcy52YWx1ZXM/dGhpcy52YWx1ZXMubmV4dF8xKCk6dGhpcy52YWx1ZUludGVybmFsRUxpc3Q/dGhpcy52YWx1ZUludGVybmFsRUxpc3QuYmFzaWNHZXQodGhpcy52YWx1ZUxpc3RJbmRleCsrKTp0aGlzLnZhbHVlTGlzdC5nZXRfMCh0aGlzLnZhbHVlTGlzdEluZGV4KyspLHRoaXMuaXNIYW5kbGluZ0ZlYXR1cmVNYXA/KG49YShpLDc2KSxuLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLHQ9bi5nZXRWYWx1ZSgpLHRoaXMucHJlcGFyZWRSZXN1bHQ9dCk6KHQ9aSx0aGlzLnByZXBhcmVkUmVzdWx0PXQpLHRoaXMucHJlcGFyZWQ9MywhMH19LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpLHM7c3dpdGNoKHRoaXMucHJlcGFyZWQpe2Nhc2UtMzpjYXNlLTI6cmV0dXJuITA7Y2FzZS0xOnJldHVybiExO2Nhc2UgMzp0aGlzLnZhbHVlcz90aGlzLnZhbHVlcy5wcmV2aW91c18wKCk6LS10aGlzLnZhbHVlTGlzdEluZGV4O2RlZmF1bHQ6aWYoIXRoaXMudmFsdWVMaXN0fHwodGhpcy52YWx1ZXM/IUZVZSh0aGlzLHRoaXMudmFsdWVzKTohRFVlKHRoaXMpKSl7Zm9yKDt0aGlzLmZlYXR1cmVDdXJzb3I+MDspaWYocj10aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZXNbLS10aGlzLmZlYXR1cmVDdXJzb3JdLCghdGhpcy5mZWF0dXJlRmlsdGVyfHxyLmdldENvbnRhaW5lckNsYXNzKCkhPWt3fHxyLmdldEZlYXR1cmVJRF8wKCkhPTApJiYoIXRoaXMudXNlSXNTZXQoKXx8dGhpcy5lT2JqZWN0LmVJc1NldF8wKHIpKSl7aWYocz10aGlzLmVPYmplY3QuZUdldF8xKHIsdGhpcy5yZXNvbHZlXzAoKSksdGhpcy5pc0hhbmRsaW5nRmVhdHVyZU1hcD0oSHQoKSxhKHIsNjkpLmlzRmVhdHVyZU1hcF8wKCkpLHRoaXMuaXNIYW5kbGluZ0ZlYXR1cmVNYXB8fHIuaXNNYW55KCkpe2lmKHRoaXMucmVzb2x2ZV8wKCk/KG89YShzLDE1KSx0aGlzLnZhbHVlTGlzdD1vKToobz1hKHMsNzEpLHRoaXMudmFsdWVMaXN0PXRoaXMudmFsdWVJbnRlcm5hbEVMaXN0PW8pLEwodGhpcy52YWx1ZUxpc3QsNTkpPyh0aGlzLnZhbHVlTGlzdFNpemU9dGhpcy52YWx1ZUxpc3Quc2l6ZV8xKCksdGhpcy52YWx1ZUxpc3RJbmRleD10aGlzLnZhbHVlTGlzdFNpemUpOnRoaXMudmFsdWVzPXRoaXMudmFsdWVJbnRlcm5hbEVMaXN0P3RoaXMudmFsdWVJbnRlcm5hbEVMaXN0LmJhc2ljTGlzdEl0ZXJhdG9yXzAodGhpcy52YWx1ZUxpc3Quc2l6ZV8xKCkpOnRoaXMudmFsdWVMaXN0Lmxpc3RJdGVyYXRvcl8xKHRoaXMudmFsdWVMaXN0LnNpemVfMSgpKSx0aGlzLnZhbHVlcz9GVWUodGhpcyx0aGlzLnZhbHVlcyk6RFVlKHRoaXMpKXJldHVybiBpPXRoaXMudmFsdWVzP3RoaXMudmFsdWVzLnByZXZpb3VzXzAoKTp0aGlzLnZhbHVlSW50ZXJuYWxFTGlzdD90aGlzLnZhbHVlSW50ZXJuYWxFTGlzdC5iYXNpY0dldCgtLXRoaXMudmFsdWVMaXN0SW5kZXgpOnRoaXMudmFsdWVMaXN0LmdldF8wKC0tdGhpcy52YWx1ZUxpc3RJbmRleCksdGhpcy5pc0hhbmRsaW5nRmVhdHVyZU1hcD8obj1hKGksNzYpLG4uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksdD1uLmdldFZhbHVlKCksdGhpcy5wcmVwYXJlZFJlc3VsdD10KToodD1pLHRoaXMucHJlcGFyZWRSZXN1bHQ9dCksdGhpcy5wcmVwYXJlZD0tMywhMH1lbHNlIGlmKHMhPW51bGwpcmV0dXJuIHRoaXMudmFsdWVMaXN0PW51bGwsdGhpcy52YWx1ZXM9bnVsbCx0PXMsdGhpcy5wcmVwYXJlZFJlc3VsdD10LHRoaXMucHJlcGFyZWQ9LTIsITB9cmV0dXJuIHRoaXMudmFsdWVMaXN0PW51bGwsdGhpcy52YWx1ZXM9bnVsbCx0aGlzLnByZXBhcmVkPS0xLCExfWVsc2UgcmV0dXJuIGk9dGhpcy52YWx1ZXM/dGhpcy52YWx1ZXMucHJldmlvdXNfMCgpOnRoaXMudmFsdWVJbnRlcm5hbEVMaXN0P3RoaXMudmFsdWVJbnRlcm5hbEVMaXN0LmJhc2ljR2V0KC0tdGhpcy52YWx1ZUxpc3RJbmRleCk6dGhpcy52YWx1ZUxpc3QuZ2V0XzAoLS10aGlzLnZhbHVlTGlzdEluZGV4KSx0aGlzLmlzSGFuZGxpbmdGZWF0dXJlTWFwPyhuPWEoaSw3Niksbi5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSx0PW4uZ2V0VmFsdWUoKSx0aGlzLnByZXBhcmVkUmVzdWx0PXQpOih0PWksdGhpcy5wcmVwYXJlZFJlc3VsdD10KSx0aGlzLnByZXBhcmVkPS0zLCEwfX0sbC5uZXh0XzE9ZnVuY3Rpb24oKXtyZXR1cm4gQUwodGhpcyl9LGwubmV4dEluZGV4XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJzb3J9LGwucHJldmlvdXNfMD1mdW5jdGlvbigpe3ZhciBuO2lmKHRoaXMucHJlcGFyZWQ8LTF8fHRoaXMuaGFzUHJldmlvdXMoKSlyZXR1cm4tLXRoaXMuY3Vyc29yLHRoaXMucHJlcGFyZWQ9MCxuPXRoaXMucHJlcGFyZWRSZXN1bHQsdGhpcy5oYXNQcmV2aW91cygpLG47dGhyb3cgYihuZXcgUG8pfSxsLnByZXZpb3VzSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdXJzb3ItMX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBUbil9LGwucmVzb2x2ZV8wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuc2V0XzE9ZnVuY3Rpb24obil7dGhyb3cgYihuZXcgVG4pfSxsLnVzZUlzU2V0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuY3Vyc29yPTAsbC5mZWF0dXJlQ3Vyc29yPTAsbC5pc0hhbmRsaW5nRmVhdHVyZU1hcD0hMSxsLnByZXBhcmVkPTAsbC52YWx1ZUxpc3RJbmRleD0wLGwudmFsdWVMaXN0U2l6ZT0wO3ZhciBTYjtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVDb250ZW50c0VMaXN0L0ZlYXR1cmVJdGVyYXRvckltcGwiLDI4Nyk7ZnVuY3Rpb24gcnRlKGUsbil7dTAoKSxMTC5jYWxsKHRoaXMsZSxuKX1wKDcxMSwyODcsS2IscnRlKSxsLnJlc29sdmVfMD1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVDb250ZW50c0VMaXN0L1Jlc29sdmluZ0ZlYXR1cmVJdGVyYXRvckltcGwiLDcxMSk7ZnVuY3Rpb24gelVlKGUsbil7dTAoKSxydGUuY2FsbCh0aGlzLGUsbil9cCgxMTc4LDcxMSxLYix6VWUpLGwudXNlSXNTZXQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFTmFtZWRFbGVtZW50SW1wbC8xLzEiLDExNzgpO2Z1bmN0aW9uICRVZShlLG4pe3UwKCksTEwuY2FsbCh0aGlzLGUsbil9cCgxMTc5LDI4NyxLYiwkVWUpLGwudXNlSXNTZXQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFTmFtZWRFbGVtZW50SW1wbC8xLzIiLDExNzkpO2Z1bmN0aW9uIHR0ZShlKXt2YXIgbjtyZXR1cm4hZS5mZWF0dXJlJiZlLmZlYXR1cmVJRCE9LTEmJihuPWUubm90aWZpZXIuZUNsYXNzXzAoKSxlLmZlYXR1cmU9a2UobixlLmZlYXR1cmVJRCkpLGUuZmVhdHVyZX1mdW5jdGlvbiBzcChlLG4scix0KXtvR2UuY2FsbCh0aGlzLDEscix0KSx0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlSUQ9bn1mdW5jdGlvbiB0RihlLG4scix0KXtpR2UuY2FsbCh0aGlzLDEscix0KSx0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlSUQ9bn1mdW5jdGlvbiBsdChlLG4scix0LG8pe29GLmNhbGwodGhpcyxlLG4scix0LG8sLTEpfWZ1bmN0aW9uIG9GKGUsbixyLHQsbyxpKXtwcmUuY2FsbCh0aGlzLG4sdCxvLGkpLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmVJRD1yfWZ1bmN0aW9uIFNjKGUsbixyLHQsbyxpLHMpe21ELmNhbGwodGhpcyxuLHQsbyxpLHMpLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmVJRD1yfWZ1bmN0aW9uIHJzKGUsbixyLHQsbyl7YUdlLmNhbGwodGhpcyxuLHQsbyksdGhpcy5ub3RpZmllcj1lLHRoaXMuZmVhdHVyZUlEPXJ9ZnVuY3Rpb24gb3RlKGUsbixyLHQsbyl7dGhpcy5ldmVudFR5cGU9bix0aGlzLm9sZFNpbXBsZVByaW1pdGl2ZVZhbHVlPXQsdGhpcy5uZXdTaW1wbGVQcmltaXRpdmVWYWx1ZT1vLHRoaXMucG9zaXRpb249LTEsdGhpcy5wcmltaXRpdmVUeXBlPTEsdGhpcy5ub3RpZmllcj1lLHRoaXMuZmVhdHVyZT1yfWZ1bmN0aW9uIEJVZShlLG4scix0LG8saSl7b3RlLmNhbGwodGhpcyxlLG4scix0LG8pLGkmJih0aGlzLnBvc2l0aW9uPS0yKX1mdW5jdGlvbiBpdGUoZSxuLHIsdCxvKXt0aGlzLmV2ZW50VHlwZT1uLHRoaXMub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWU9dCx0aGlzLm5ld1NpbXBsZVByaW1pdGl2ZVZhbHVlPW8sdGhpcy5wb3NpdGlvbj0tMSx0aGlzLnByaW1pdGl2ZVR5cGU9Mix0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlPXJ9ZnVuY3Rpb24gR1VlKGUsbixyLHQsbyxpKXtpdGUuY2FsbCh0aGlzLGUsbixyLHQsbyksaSYmKHRoaXMucG9zaXRpb249LTIpfWZ1bmN0aW9uIGF0ZShlLG4scix0LG8pe29HZS5jYWxsKHRoaXMsbix0LG8pLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmU9cn1mdW5jdGlvbiBIVWUoZSxuLHIsdCxvLGkpe2F0ZS5jYWxsKHRoaXMsZSxuLHIsdCxvKSxpJiYodGhpcy5wb3NpdGlvbj0tMil9ZnVuY3Rpb24gbHRlKGUsbixyLHQsbyl7dGhpcy5ldmVudFR5cGU9bix0aGlzLm9sZElFRUVQcmltaXRpdmVWYWx1ZT10LHRoaXMubmV3SUVFRVByaW1pdGl2ZVZhbHVlPW8sdGhpcy5wb3NpdGlvbj0tMSx0aGlzLnByaW1pdGl2ZVR5cGU9NCx0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlPXJ9ZnVuY3Rpb24gVVVlKGUsbixyLHQsbyxpKXtsdGUuY2FsbCh0aGlzLGUsbixyLHQsbyksaSYmKHRoaXMucG9zaXRpb249LTIpfWZ1bmN0aW9uIHN0ZShlLG4scix0LG8pe2lHZS5jYWxsKHRoaXMsbix0LG8pLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmU9cn1mdW5jdGlvbiBXVWUoZSxuLHIsdCxvLGkpe3N0ZS5jYWxsKHRoaXMsZSxuLHIsdCxvKSxpJiYodGhpcy5wb3NpdGlvbj0tMil9ZnVuY3Rpb24gdXRlKGUsbixyLHQsbyl7dGhpcy5ldmVudFR5cGU9bix0aGlzLm9sZFNpbXBsZVByaW1pdGl2ZVZhbHVlPXQsdGhpcy5uZXdTaW1wbGVQcmltaXRpdmVWYWx1ZT1vLHRoaXMucG9zaXRpb249LTEsdGhpcy5wcmltaXRpdmVUeXBlPTYsdGhpcy5ub3RpZmllcj1lLHRoaXMuZmVhdHVyZT1yfWZ1bmN0aW9uIGpVZShlLG4scix0LG8saSl7dXRlLmNhbGwodGhpcyxlLG4scix0LG8pLGkmJih0aGlzLnBvc2l0aW9uPS0yKX1mdW5jdGlvbiBiUyhlLG4scix0LG8pe0NiLmNhbGwodGhpcyxlLG4scix0LG8sLTEpfWZ1bmN0aW9uIENiKGUsbixyLHQsbyxpKXtwcmUuY2FsbCh0aGlzLG4sdCxvLGkpLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmU9cn1mdW5jdGlvbiBpRihlLG4scix0LG8saSl7Q2IuY2FsbCh0aGlzLGUsbixyLHQsbyxpPy0yOi0xKX1mdW5jdGlvbiBjdGUoZSxuLHIsdCxvKXt0aGlzLmV2ZW50VHlwZT1uLHRoaXMub2xkU2ltcGxlUHJpbWl0aXZlVmFsdWU9dCx0aGlzLm5ld1NpbXBsZVByaW1pdGl2ZVZhbHVlPW8sdGhpcy5wb3NpdGlvbj0tMSx0aGlzLnByaW1pdGl2ZVR5cGU9Nyx0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlPXJ9ZnVuY3Rpb24gVlVlKGUsbixyLHQsbyxpKXtjdGUuY2FsbCh0aGlzLGUsbixyLHQsbyksaSYmKHRoaXMucG9zaXRpb249LTIpfWZ1bmN0aW9uIF90ZShlLG4scix0LG8pe2FHZS5jYWxsKHRoaXMsbix0LG8pLHRoaXMubm90aWZpZXI9ZSx0aGlzLmZlYXR1cmU9cn1mdW5jdGlvbiBxVWUoZSxuLHIsdCxvLGkpe190ZS5jYWxsKHRoaXMsZSxuLHIsdCxvKSxpJiYodGhpcy5wb3NpdGlvbj0tMil9cCgzOSwxNTIsUVMsc3AsdEYsbHQsb0YsU2MscnMsb3RlLEJVZSxpdGUsR1VlLGF0ZSxIVWUsbHRlLFVVZSxzdGUsV1VlLHV0ZSxqVWUsYlMsQ2IsaUYsY3RlLFZVZSxfdGUscVVlKSxsLmdldEZlYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdHRlKHRoaXMpfSxsLmdldEZlYXR1cmVEZWZhdWx0VmFsdWU9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj10dGUodGhpcyksbj9uLmdldERlZmF1bHRWYWx1ZSgpOm51bGx9LGwuZ2V0RmVhdHVyZUlEPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmZlYXR1cmVJRD09LTEmJnRoaXMuZmVhdHVyZSYmKHRoaXMuZmVhdHVyZUlEPXRoaXMubm90aWZpZXIuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEKHRoaXMuZmVhdHVyZS5nZXRGZWF0dXJlSURfMCgpLHRoaXMuZmVhdHVyZS5nZXRDb250YWluZXJDbGFzcygpKSksdGhpcy5ub3RpZmllci5lQmFzZVN0cnVjdHVyYWxGZWF0dXJlSUQodGhpcy5mZWF0dXJlSUQsbil9LGwuZ2V0Tm90aWZpZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub3RpZmllcn0sbC5pc0ZlYXR1cmVVbnNldHRhYmxlPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIG49dHRlKHRoaXMpLG4/bi5pc1Vuc2V0dGFibGUoKTohMX0sbC5mZWF0dXJlSUQ9LTEsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFTm90aWZpY2F0aW9uSW1wbCIsMzkpO2Z1bmN0aW9uIFlVZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT0xMD9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwxMSxJbCxuKToodD1HdChhKGtlKChyPWEoQmUoZSwxNiksMjkpLHJ8fChQZSgpLHQwKSksZS5lRmxhZ3NfMD4+MTYpLDE5KSksZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsdC5mZWF0dXJlSUQsdC5jb250YWluZXJDbGFzcyxuKSl9ZnVuY3Rpb24gbWEoZSl7cmV0dXJuIGUuZUdlbmVyaWNFeGNlcHRpb25zfHwoZS5lR2VuZXJpY0V4Y2VwdGlvbnM9bmV3IFpVZShlLEt0LGUpLCFlLmVFeGNlcHRpb25zJiYoZS5lRXhjZXB0aW9ucz1uZXcgVGIoZSxlKSkpLGUuZUdlbmVyaWNFeGNlcHRpb25zfWZ1bmN0aW9uIFMzbihlKXtyZXR1cm4hIWUuZUV4Y2VwdGlvbnMmJm1hKGUuZUV4Y2VwdGlvbnMudGhpcyQwMSkuc2l6ZV8wIT0wJiYhKGUuZUdlbmVyaWNFeGNlcHRpb25zJiZsRihlLmVHZW5lcmljRXhjZXB0aW9ucykpfWZ1bmN0aW9uIGFGKCl7JHJlLmNhbGwodGhpcyl9cCg0MTEsMjkyLHsxMTA6MSw5NDoxLDkzOjEsMTU1OjEsMTk3OjEsNTg6MSw2MjoxLDExNDoxLDQ4MToxLDU0OjEsOTk6MSwxNTg6MSw0MTE6MSwyOTI6MSwxMTk6MSwxMjA6MX0sYUYpLGwuZUJhc2ljUmVtb3ZlRnJvbUNvbnRhaW5lckZlYXR1cmU9ZnVuY3Rpb24obil7cmV0dXJuIFlVZSh0aGlzLG4pfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztzd2l0Y2gobil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnM7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMDtjYXNlIDI6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmMjU2KTtjYXNlIDM6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmNTEyKTtjYXNlIDQ6cmV0dXJuIEoodGhpcy5sb3dlckJvdW5kKTtjYXNlIDU6cmV0dXJuIEoodGhpcy51cHBlckJvdW5kKTtjYXNlIDY6cmV0dXJuIHplKCkscz10aGlzLnVwcGVyQm91bmQscz4xfHxzPT0tMTtjYXNlIDc6cmV0dXJuIHplKCksaT10aGlzLmxvd2VyQm91bmQsaT49MTtjYXNlIDg6cmV0dXJuIHI/QWwodGhpcyk6dGhpcy5lVHlwZTtjYXNlIDk6cmV0dXJuIHRoaXMuZUdlbmVyaWNUeXBlO2Nhc2UgMTA6cmV0dXJuIHRoaXMuZUZsYWdzXzA+PjE2PT0xMD9hKHRoaXMuZUNvbnRhaW5lciwyOSk6bnVsbDtjYXNlIDExOnJldHVybiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDExKSksdGhpcy5lVHlwZVBhcmFtZXRlcnM7Y2FzZSAxMjpyZXR1cm4hdGhpcy5lUGFyYW1ldGVycyYmKHRoaXMuZVBhcmFtZXRlcnM9bmV3IFUoTmQsdGhpcywxMiwxMCkpLHRoaXMuZVBhcmFtZXRlcnM7Y2FzZSAxMzpyZXR1cm4hdGhpcy5lRXhjZXB0aW9ucyYmKHRoaXMuZUV4Y2VwdGlvbnM9bmV3IFRiKHRoaXMsdGhpcykpLHRoaXMuZUV4Y2VwdGlvbnM7Y2FzZSAxNDpyZXR1cm4gbWEodGhpcyl9cmV0dXJuIGxsKHRoaXMsbi1vbigoUGUoKSx0MCkpLGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fHQwKSxuKSxyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksaGkodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDEwOnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShpPXRoaXMuZUZsYWdzXzA+PjE2LGk+PTA/WVVlKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtaSxudWxsLHQpKSksR2EodGhpcyxuLDEwLHQpO2Nhc2UgMTI6cmV0dXJuIXRoaXMuZVBhcmFtZXRlcnMmJih0aGlzLmVQYXJhbWV0ZXJzPW5ldyBVKE5kLHRoaXMsMTIsMTApKSxoaSh0aGlzLmVQYXJhbWV0ZXJzLG4sdCl9cmV0dXJuIHM9YShrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHwoUGUoKSx0MCkpLHIpLDY5KSxzLmdldFNldHRpbmdEZWxlZ2F0ZSgpLmR5bmFtaWNJbnZlcnNlQWRkKHRoaXMsU2kodGhpcyksci1vbigoUGUoKSx0MCkpLG4sdCl9LGwuZUludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksRHQodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDk6cmV0dXJuIFJEKHRoaXMsdCk7Y2FzZSAxMDpyZXR1cm4gR2EodGhpcyxudWxsLDEwLHQpO2Nhc2UgMTE6cmV0dXJuIXRoaXMuZVR5cGVQYXJhbWV0ZXJzJiYodGhpcy5lVHlwZVBhcmFtZXRlcnM9bmV3IFhpKGJpLHRoaXMsMTEpKSxEdCh0aGlzLmVUeXBlUGFyYW1ldGVycyxuLHQpO2Nhc2UgMTI6cmV0dXJuIXRoaXMuZVBhcmFtZXRlcnMmJih0aGlzLmVQYXJhbWV0ZXJzPW5ldyBVKE5kLHRoaXMsMTIsMTApKSxEdCh0aGlzLmVQYXJhbWV0ZXJzLG4sdCk7Y2FzZSAxNDpyZXR1cm4gRHQobWEodGhpcyksbix0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLHQwKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLHQwKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHIsdCxvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybih0aGlzLmVGbGFncyYyNTYpPT0wO2Nhc2UgMzpyZXR1cm4odGhpcy5lRmxhZ3MmNTEyKT09MDtjYXNlIDQ6cmV0dXJuIHRoaXMubG93ZXJCb3VuZCE9MDtjYXNlIDU6cmV0dXJuIHRoaXMudXBwZXJCb3VuZCE9MTtjYXNlIDY6cmV0dXJuIG89dGhpcy51cHBlckJvdW5kLG8+MXx8bz09LTE7Y2FzZSA3OnJldHVybiB0PXRoaXMubG93ZXJCb3VuZCx0Pj0xO2Nhc2UgODpyZXR1cm4hIXRoaXMuZVR5cGUmJiF0aGlzLmVHZW5lcmljVHlwZS5lVHlwZVBhcmFtZXRlciYmT2QodGhpcy5lR2VuZXJpY1R5cGUpLnNpemVfMD09MDtjYXNlIDk6cmV0dXJuISF0aGlzLmVHZW5lcmljVHlwZSYmISh0aGlzLmVUeXBlJiYhdGhpcy5lR2VuZXJpY1R5cGUuZVR5cGVQYXJhbWV0ZXImJk9kKHRoaXMuZUdlbmVyaWNUeXBlKS5zaXplXzA9PTApO2Nhc2UgMTA6cmV0dXJuISEodGhpcy5lRmxhZ3NfMD4+MTY9PTEwJiZhKHRoaXMuZUNvbnRhaW5lciwyOSkpO2Nhc2UgMTE6cmV0dXJuISF0aGlzLmVUeXBlUGFyYW1ldGVycyYmdGhpcy5lVHlwZVBhcmFtZXRlcnMuc2l6ZV8wIT0wO2Nhc2UgMTI6cmV0dXJuISF0aGlzLmVQYXJhbWV0ZXJzJiZ0aGlzLmVQYXJhbWV0ZXJzLnNpemVfMCE9MDtjYXNlIDEzOnJldHVybiEhdGhpcy5lRXhjZXB0aW9ucyYmbWEodGhpcy5lRXhjZXB0aW9ucy50aGlzJDAxKS5zaXplXzAhPTAmJiEodGhpcy5lR2VuZXJpY0V4Y2VwdGlvbnMmJmxGKHRoaXMuZUdlbmVyaWNFeGNlcHRpb25zKSk7Y2FzZSAxNDpyZXR1cm4hIXRoaXMuZUdlbmVyaWNFeGNlcHRpb25zJiZsRih0aGlzLmVHZW5lcmljRXhjZXB0aW9ucyl9cmV0dXJuIHNsKHRoaXMsbi1vbigoUGUoKSx0MCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fHQwKSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0LG87c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKSwhdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLFByKHRoaXMuZUFubm90YXRpb25zLGEociwxNikpO3JldHVybjtjYXNlIDE6Z2kodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMzpsMCh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgNDppMCh0aGlzLGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgNTppcCh0aGlzLGEociwxNykudmFsdWVfMCk7cmV0dXJuO2Nhc2UgODpsMSh0aGlzLGEociwxNDIpKTtyZXR1cm47Y2FzZSA5Om89cXModGhpcyxhKHIsODkpLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpO3JldHVybjtjYXNlIDExOiF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDExKSksZm4odGhpcy5lVHlwZVBhcmFtZXRlcnMpLCF0aGlzLmVUeXBlUGFyYW1ldGVycyYmKHRoaXMuZVR5cGVQYXJhbWV0ZXJzPW5ldyBYaShiaSx0aGlzLDExKSksUHIodGhpcy5lVHlwZVBhcmFtZXRlcnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTI6IXRoaXMuZVBhcmFtZXRlcnMmJih0aGlzLmVQYXJhbWV0ZXJzPW5ldyBVKE5kLHRoaXMsMTIsMTApKSxmbih0aGlzLmVQYXJhbWV0ZXJzKSwhdGhpcy5lUGFyYW1ldGVycyYmKHRoaXMuZVBhcmFtZXRlcnM9bmV3IFUoTmQsdGhpcywxMiwxMCkpLFByKHRoaXMuZVBhcmFtZXRlcnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTM6IXRoaXMuZUV4Y2VwdGlvbnMmJih0aGlzLmVFeGNlcHRpb25zPW5ldyBUYih0aGlzLHRoaXMpKSxoUyh0aGlzLmVFeGNlcHRpb25zKSwhdGhpcy5lRXhjZXB0aW9ucyYmKHRoaXMuZUV4Y2VwdGlvbnM9bmV3IFRiKHRoaXMsdGhpcykpLFByKHRoaXMuZUV4Y2VwdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTQ6Zm4obWEodGhpcykpLFByKG1hKHRoaXMpLGEociwxNikpO3JldHVybn11bCh0aGlzLG4tb24oKFBlKCksdDApKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHx0MCksbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksdDB9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByLHQ7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOmdpKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLCEwKTtyZXR1cm47Y2FzZSAzOmwwKHRoaXMsITApO3JldHVybjtjYXNlIDQ6aTAodGhpcywwKTtyZXR1cm47Y2FzZSA1OmlwKHRoaXMsMSk7cmV0dXJuO2Nhc2UgODpsMSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDk6dD1xcyh0aGlzLG51bGwsbnVsbCksdCYmdC5kaXNwYXRjaF8wKCk7cmV0dXJuO2Nhc2UgMTE6IXRoaXMuZVR5cGVQYXJhbWV0ZXJzJiYodGhpcy5lVHlwZVBhcmFtZXRlcnM9bmV3IFhpKGJpLHRoaXMsMTEpKSxmbih0aGlzLmVUeXBlUGFyYW1ldGVycyk7cmV0dXJuO2Nhc2UgMTI6IXRoaXMuZVBhcmFtZXRlcnMmJih0aGlzLmVQYXJhbWV0ZXJzPW5ldyBVKE5kLHRoaXMsMTIsMTApKSxmbih0aGlzLmVQYXJhbWV0ZXJzKTtyZXR1cm47Y2FzZSAxMzp0aGlzLmVFeGNlcHRpb25zJiZoUyh0aGlzLmVFeGNlcHRpb25zKTtyZXR1cm47Y2FzZSAxNDp0aGlzLmVHZW5lcmljRXhjZXB0aW9ucyYmZm4odGhpcy5lR2VuZXJpY0V4Y2VwdGlvbnMpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCksdDApKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHx0MCksbikpfSxsLmZyZWV6ZT1mdW5jdGlvbigpe3ZhciBuLHI7aWYodGhpcy5lUGFyYW1ldGVycylmb3Iobj0wLHI9dGhpcy5lUGFyYW1ldGVycy5zaXplXzA7bjxyOysrbilyYihPKHRoaXMuZVBhcmFtZXRlcnMsbikpO0FsKHRoaXMpLHRoaXMuZUZsYWdzfD0xfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVPcGVyYXRpb25JbXBsIiw0MTEpO2Z1bmN0aW9uIEMzbihlLG4scil7ZlMobWEoZS50aGlzJDAxKSxuLFhVZShyKSl9ZnVuY3Rpb24gVDNuKGUsbil7cG4obWEoZS50aGlzJDAxKSxYVWUobikpfWZ1bmN0aW9uIEtVZShlLG4pe3ZhciByLHQ7Zm9yKHQ9bmV3IFllKGUpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspaWYocj1hKGVuKHQpLDE0MiksRChuKT09PUQocikpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gYjNuKGUsbixyKXt2YXIgdCxvLGk7cmV0dXJuIHQ9YShPKG1hKGUudGhpcyQwMSksbiksODkpLGk9KG89dC5lUmF3VHlwZSxvfHwoUGUoKSxWcykpLChpLmVJc1Byb3h5KCk/SjAoZS5vd25lcixhKGksNTQpKTppKT09cj9QTCh0KTpvMih0LHIpLGl9ZnVuY3Rpb24gWFVlKGUpe3ZhciBuLHI7cmV0dXJuIHI9KFZ3KCksbj1uZXcgTWQsbiksbzIocixlKSxyfWZ1bmN0aW9uIFRiKGUsbil7dGhpcy50aGlzJDAxPWUsZ1VlLmNhbGwodGhpcyxuKX1wKDUxMyw3NTYscnosVGIpLGwuZGVsZWdhdGVBZGQ9ZnVuY3Rpb24obixyKXtDM24odGhpcyxuLGEociwxNDIpKX0sbC5kZWxlZ2F0ZUFkZF8wPWZ1bmN0aW9uKG4pe1Qzbih0aGlzLGEobiwxNDIpKX0sbC5kZWxlZ2F0ZUdldD1mdW5jdGlvbihuKXt2YXIgcix0O3JldHVybiByPWEoTyhtYSh0aGlzLnRoaXMkMDEpLG4pLDg5KSx0PXIuZVJhd1R5cGUsdHx8KFBlKCksVnMpfSxsLmRlbGVnYXRlUmVtb3ZlPWZ1bmN0aW9uKG4pe3ZhciByLHQ7cmV0dXJuIHI9YShaZihtYSh0aGlzLnRoaXMkMDEpLG4pLDg5KSx0PXIuZVJhd1R5cGUsdHx8KFBlKCksVnMpfSxsLmRlbGVnYXRlU2V0PWZ1bmN0aW9uKG4scil7cmV0dXJuIGIzbih0aGlzLG4sYShyLDE0MikpfSxsLmNhbkNvbnRhaW5OdWxsPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuY3JlYXRlTm90aWZpY2F0aW9uPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG51bGx9LGwuZGVsZWdhdGVCYXNpY0xpc3Q9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEpVZSh0aGlzKX0sbC5kZWxlZ2F0ZUNsZWFyPWZ1bmN0aW9uKCl7Zm4obWEodGhpcy50aGlzJDAxKSl9LGwuZGVsZWdhdGVDb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4gS1VlKHRoaXMsbil9LGwuZGVsZWdhdGVDb250YWluc0FsbD1mdW5jdGlvbihuKXt2YXIgcix0O2Zvcih0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KWlmKHI9dC5uZXh0XzEoKSwhS1VlKHRoaXMscikpcmV0dXJuITE7cmV0dXJuITB9LGwuZGVsZWdhdGVFcXVhbHM9ZnVuY3Rpb24obil7dmFyIHIsdCxvO2lmKEwobiwxNSkmJihvPWEobiwxNSksby5zaXplXzEoKT09bWEodGhpcy50aGlzJDAxKS5zaXplXzApKXtmb3Iocj1vLml0ZXJhdG9yXzAoKSx0PW5ldyBZZSh0aGlzKTtyLmhhc05leHRfMCgpOylpZihEKHIubmV4dF8xKCkpIT09RChlbih0KSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuITF9LGwuZGVsZWdhdGVIYXNoQ29kZT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGk7Zm9yKHQ9MSxyPW5ldyBZZShtYSh0aGlzLnRoaXMkMDEpKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KW49YShlbihyKSw4OSksbz0oaT1uLmVSYXdUeXBlLGl8fChQZSgpLFZzKSksdD0zMSp0KyhvP3VyKG8pOjApO3JldHVybiB0fSxsLmRlbGVnYXRlSW5kZXhPZj1mdW5jdGlvbihuKXt2YXIgcix0LG8saTtmb3Iobz0wLHQ9bmV3IFllKG1hKHRoaXMudGhpcyQwMSkpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspe2lmKHI9YShlbih0KSw4OSksRChuKT09PUQoKGk9ci5lUmF3VHlwZSxpfHwoUGUoKSxWcykpKSlyZXR1cm4gbzsrK299cmV0dXJuLTF9LGwuZGVsZWdhdGVJc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIG1hKHRoaXMudGhpcyQwMSkuc2l6ZV8wPT0wfSxsLmRlbGVnYXRlTGlzdF8xPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuZGVsZWdhdGVTaXplPWZ1bmN0aW9uKCl7cmV0dXJuIG1hKHRoaXMudGhpcyQwMSkuc2l6ZV8wfSxsLmRlbGVnYXRlVG9BcnJheT1mdW5jdGlvbigpe3ZhciBuLHIsdCxvLGkscztmb3Iocz1tYSh0aGlzLnRoaXMkMDEpLnNpemVfMCxpPUIoUXIsTWUsMSxzLDUsMSksdD0wLHI9bmV3IFllKG1hKHRoaXMudGhpcyQwMSkpO3IuY3Vyc29yIT1yLnRoaXMkMDFfMi5zaXplXzEoKTspbj1hKGVuKHIpLDg5KSxpW3QrK109KG89bi5lUmF3VHlwZSxvfHwoUGUoKSxWcykpO3JldHVybiBpfSxsLmRlbGVnYXRlVG9BcnJheV8wPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHMsdSxjO2ZvcihjPW1hKHRoaXMudGhpcyQwMSkuc2l6ZV8wLG4ubGVuZ3RoPGMmJihpPWZiKHdhKG4pLmNvbXBvbmVudFR5cGUsYyksbj1pKSxuLmxlbmd0aD5jJiZUcihuLGMsbnVsbCksbz0wLHQ9bmV3IFllKG1hKHRoaXMudGhpcyQwMSkpO3QuY3Vyc29yIT10LnRoaXMkMDFfMi5zaXplXzEoKTspcj1hKGVuKHQpLDg5KSxzPSh1PXIuZVJhd1R5cGUsdXx8KFBlKCksVnMpKSxUcihuLG8rKyxzKTtyZXR1cm4gbn0sbC5kZWxlZ2F0ZVRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtmb3IoaT1uZXcgTGMsaS5zdHJpbmcrPSJbIixuPW1hKHRoaXMudGhpcyQwMSkscj0wLG89bWEodGhpcy50aGlzJDAxKS5zaXplXzA7cjxvOylKdChpLHoyKCh0PWEoTyhuLHIpLDg5KS5lUmF3VHlwZSx0fHwoUGUoKSxWcykpKSksKytyPG8mJihpLnN0cmluZys9IiwgIik7cmV0dXJuIGkuc3RyaW5nKz0iXSIsaS5zdHJpbmd9LGwuZGlzcGF0Y2hOb3RpZmljYXRpb249ZnVuY3Rpb24obil7fSxsLmdldEZlYXR1cmVJRF8wPWZ1bmN0aW9uKCl7cmV0dXJuIDEzfSxsLmhhc0luc3RhbmNlQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5oYXNJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzTWFueUludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5oYXNOYXZpZ2FibGVJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzUHJveGllcz1mdW5jdGlvbigpe3JldHVybiEwfSxsLmlzQ29udGFpbm1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc0VPYmplY3Q9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTQyKX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIFMzbih0aGlzLnRoaXMkMDEpfSxsLmlzVW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwudXNlRXF1YWxzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRU9wZXJhdGlvbkltcGwvMSIsNTEzKTtmdW5jdGlvbiBKVWUoZSl7dGhpcy50aGlzJDExPWV9cCgxMzc2LDIwNjIsSG0sSlVlKSxsLmxpc3RJdGVyYXRvcl8xPWZ1bmN0aW9uKG4pe3JldHVybiBhYih0aGlzLnRoaXMkMTEsbil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIG1hKHRoaXMudGhpcyQxMS50aGlzJDAxKS5zaXplXzB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRU9wZXJhdGlvbkltcGwvMS8xIiwxMzc2KTtmdW5jdGlvbiBsRihlKXt2YXIgbixyO2ZvcihyPW5ldyBZZShlKTtyLmN1cnNvciE9ci50aGlzJDAxXzIuc2l6ZV8xKCk7KWlmKG49YShlbihyKSw4OSksbi5lVHlwZVBhcmFtZXRlcnx8KCFuLmVUeXBlQXJndW1lbnRzJiYobi5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsbiwxKSksbi5lVHlwZUFyZ3VtZW50cykuc2l6ZV8wIT0wKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEkzbihlLG4scil7dmFyIHQsbztyZXR1cm4gdD1uZXcgU2MoZS5vd25lciwzLDEzLG51bGwsKG89bi5lUmF3VHlwZSxvfHwoUGUoKSxWcykpLHMwKGUsbiksITEpLHI/ci5hZGRfNSh0KTpyPXQscn1mdW5jdGlvbiB4M24oZSxuLHIpe3ZhciB0LG87cmV0dXJuIHQ9bmV3IFNjKGUub3duZXIsNCwxMywobz1uLmVSYXdUeXBlLG98fChQZSgpLFZzKSksbnVsbCxzMChlLG4pLCExKSxyP3IuYWRkXzUodCk6cj10LHJ9ZnVuY3Rpb24gUDNuKGUsbixyLHQpe3ZhciBvLGkscztyZXR1cm4gbz1uZXcgU2MoZS5vd25lciwxLDEzLChzPW4uZVJhd1R5cGUsc3x8KFBlKCksVnMpKSwoaT1yLmVSYXdUeXBlLGl8fChQZSgpLFZzKSksczAoZSxuKSwhMSksdD90LmFkZF81KG8pOnQ9byx0fWZ1bmN0aW9uIFpVZShlLG4scil7dGhpcy50aGlzJDAxPWUsYkwuY2FsbCh0aGlzLG4sciwxNCl9cCgxMzc3LDU1NSxFbyxaVWUpLGwubW92ZT1mdW5jdGlvbihuLHIpe3ZhciB0LG87cmV0dXJuIHQ9YShtUyh0aGlzLG4sciksODkpLFRhKHRoaXMub3duZXIpJiZ0Mih0aGlzLG5ldyBDYih0aGlzLnRoaXMkMDEsNywoUGUoKSxPSGUpLEoociksKG89dC5lUmF3VHlwZSxvfHxWcyksbikpLHR9LGwuc2hhZG93QWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIEkzbih0aGlzLGEobiw4OSkscil9LGwuc2hhZG93UmVtb3ZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHgzbih0aGlzLGEobiw4OSkscil9LGwuc2hhZG93U2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gUDNuKHRoaXMsYShuLDg5KSxhKHIsODkpLHQpfSxsLmNyZWF0ZU5vdGlmaWNhdGlvbj1mdW5jdGlvbihuLHIsdCxvLGkpe3N3aXRjaChuKXtjYXNlIDM6cmV0dXJuIENTKHRoaXMsbixyLHQsbyx0aGlzLnNpemVfMD4xKTtjYXNlIDU6cmV0dXJuIENTKHRoaXMsbixyLHQsbyx0aGlzLnNpemVfMC1hKHQsMTUpLnNpemVfMSgpPjApO2RlZmF1bHQ6cmV0dXJuIG5ldyBTYyh0aGlzLm93bmVyLG4sdGhpcy5mZWF0dXJlSUQscix0LG8sITApfX0sbC5oYXNTaGFkb3c9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIGxGKHRoaXMpfSxsLnVuc2V0PWZ1bmN0aW9uKCl7Zm4odGhpcyl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRU9wZXJhdGlvbkltcGwvMiIsMTM3Nyk7ZnVuY3Rpb24gUVVlKGUsbil7dGhpcy50aGlzJDAxPWUsdGhpcy52YWwkZmFjdG9yeTI9bn1wKDUwNywxLHsyMDM3OjEsNTA3OjF9LFFVZSksZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFUGFja2FnZUltcGwvMSIsNTA3KTtmdW5jdGlvbiBVKGUsbixyLHQpe2pyLmNhbGwodGhpcyxlLG4sciksdGhpcy5pbnZlcnNlRmVhdHVyZUlEPXR9cCgxNCw4MyxFbyxVKSxsLmdldEludmVyc2VGZWF0dXJlQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhQ2xhc3N9LGwuZ2V0SW52ZXJzZUZlYXR1cmVJRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmludmVyc2VGZWF0dXJlSUR9LGwuaGFzTmF2aWdhYmxlSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxsLmludmVyc2VGZWF0dXJlSUQ9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RDb250YWlubWVudFdpdGhJbnZlcnNlRUxpc3QiLDE0KTtmdW5jdGlvbiB4bShlLG4scix0KXtVLmNhbGwodGhpcyxlLG4scix0KX1wKDM2NSwxNCxFbyx4bSksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50V2l0aEludmVyc2VFTGlzdC9SZXNvbHZpbmciLDM2NSk7ZnVuY3Rpb24gdXAoZSxuLHIpe3RoaXMudGhpcyQwMT1lLHhtLmNhbGwodGhpcyxuLHIsNSw2KX1wKDMwOCwzNjUsRW8sdXApLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy50aGlzJDAxLmVOYW1lVG9FQ2xhc3NpZmllck1hcD1udWxsfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVQYWNrYWdlSW1wbC8yIiwzMDgpO2Z1bmN0aW9uIE4zbigpe31wKDEyNzgsMSx7fSxOM24pLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVBhY2thZ2VJbXBsLzMiLDEyNzgpO2Z1bmN0aW9uIGR0ZShlLG4pe3ZhciByLHQsbztyZXR1cm4gcj1yRShlLnN0cmluZ01hcCxuKSxMKHIsMjQxKT8obz1hKHIsMjQxKSxvLmdldE5zVVJJKCk9PW51bGwsby5nZXRFRmFjdG9yeUluc3RhbmNlKCkpOkwociw1MDcpPyh0PWEociwyMDM3KSxvPXQudmFsJGZhY3RvcnkyLG8pOm51bGx9ZnVuY3Rpb24gYTIoZSxuKXt2YXIgcix0LG87cmV0dXJuIHI9bj09bnVsbD9fbyhqdChlLmhhc2hDb2RlTWFwLG51bGwpKTpyRShlLnN0cmluZ01hcCxuKSxMKHIsMjQxKT8obz1hKHIsMjQxKSxvLmdldE5zVVJJKCk9PW51bGwsbyk6TChyLDUwNyk/KHQ9YShyLDIwMzcpLG89dC50aGlzJDAxLG8mJihvLm5zVVJJPT1udWxsfHwobj09bnVsbD9kaShlLmhhc2hDb2RlTWFwLG51bGwsbyk6azEoZS5zdHJpbmdNYXAsbixvKSkpLG8pOm51bGx9ZnVuY3Rpb24gZnRlKCl7c24uY2FsbCh0aGlzKX1wKDczMyw0NSxocCxmdGUpLGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pP1Y1KHRoaXMsbik6ISFqdCh0aGlzLmhhc2hDb2RlTWFwLG4pfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVQYWNrYWdlUmVnaXN0cnlJbXBsIiw3MzMpO2Z1bmN0aW9uIGVXZShlLG4pe3ZhciByLHQ7cmV0dXJuIGUuZUZsYWdzXzA+PjE2PT0xMD9lLmVDb250YWluZXIuZUludmVyc2VSZW1vdmUoZSwxMix4bCxuKToodD1HdChhKGtlKChyPWEoQmUoZSwxNiksMjkpLHJ8fChQZSgpLG9wKSksZS5lRmxhZ3NfMD4+MTYpLDE5KSksZS5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKGUsdC5mZWF0dXJlSUQsdC5jb250YWluZXJDbGFzcyxuKSl9ZnVuY3Rpb24gc0YoKXskcmUuY2FsbCh0aGlzKX1wKDUxOCwyOTIsezExMDoxLDk0OjEsOTM6MSwxNTU6MSwxOTc6MSw1ODoxLDIxMTY6MSwxMTQ6MSw0ODE6MSw1NDoxLDk5OjEsMTU4OjEsNTE4OjEsMjkyOjEsMTE5OjEsMTIwOjF9LHNGKSxsLmVCYXNpY1JlbW92ZUZyb21Db250YWluZXJGZWF0dXJlPWZ1bmN0aW9uKG4pe3JldHVybiBlV2UodGhpcyxuKX0sbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHM7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLHRoaXMuZUFubm90YXRpb25zO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzA7Y2FzZSAyOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJjI1Nik7Y2FzZSAzOnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJjUxMik7Y2FzZSA0OnJldHVybiBKKHRoaXMubG93ZXJCb3VuZCk7Y2FzZSA1OnJldHVybiBKKHRoaXMudXBwZXJCb3VuZCk7Y2FzZSA2OnJldHVybiB6ZSgpLHM9dGhpcy51cHBlckJvdW5kLHM+MXx8cz09LTE7Y2FzZSA3OnJldHVybiB6ZSgpLGk9dGhpcy5sb3dlckJvdW5kLGk+PTE7Y2FzZSA4OnJldHVybiByP0FsKHRoaXMpOnRoaXMuZVR5cGU7Y2FzZSA5OnJldHVybiB0aGlzLmVHZW5lcmljVHlwZTtjYXNlIDEwOnJldHVybiB0aGlzLmVGbGFnc18wPj4xNj09MTA/YSh0aGlzLmVDb250YWluZXIsNjIpOm51bGx9cmV0dXJuIGxsKHRoaXMsbi1vbigoUGUoKSxvcCkpLGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fG9wKSxuKSxyLHQpfSxsLmVJbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscztzd2l0Y2gocil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksaGkodGhpcy5lQW5ub3RhdGlvbnMsbix0KTtjYXNlIDEwOnJldHVybiB0aGlzLmVDb250YWluZXImJih0PShpPXRoaXMuZUZsYWdzXzA+PjE2LGk+PTA/ZVdlKHRoaXMsdCk6dGhpcy5lQ29udGFpbmVyLmVJbnZlcnNlUmVtb3ZlKHRoaXMsLTEtaSxudWxsLHQpKSksR2EodGhpcyxuLDEwLHQpfXJldHVybiBzPWEoa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8KFBlKCksb3ApKSxyKSw2OSkscy5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZUFkZCh0aGlzLFNpKHRoaXMpLHItb24oKFBlKCksb3ApKSxuLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7c3dpdGNoKHIpe2Nhc2UgMDpyZXR1cm4hdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLER0KHRoaXMuZUFubm90YXRpb25zLG4sdCk7Y2FzZSA5OnJldHVybiBSRCh0aGlzLHQpO2Nhc2UgMTA6cmV0dXJuIEdhKHRoaXMsbnVsbCwxMCx0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLG9wKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLG9wKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHIsdCxvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybih0aGlzLmVGbGFncyYyNTYpPT0wO2Nhc2UgMzpyZXR1cm4odGhpcy5lRmxhZ3MmNTEyKT09MDtjYXNlIDQ6cmV0dXJuIHRoaXMubG93ZXJCb3VuZCE9MDtjYXNlIDU6cmV0dXJuIHRoaXMudXBwZXJCb3VuZCE9MTtjYXNlIDY6cmV0dXJuIG89dGhpcy51cHBlckJvdW5kLG8+MXx8bz09LTE7Y2FzZSA3OnJldHVybiB0PXRoaXMubG93ZXJCb3VuZCx0Pj0xO2Nhc2UgODpyZXR1cm4hIXRoaXMuZVR5cGUmJiF0aGlzLmVHZW5lcmljVHlwZS5lVHlwZVBhcmFtZXRlciYmT2QodGhpcy5lR2VuZXJpY1R5cGUpLnNpemVfMD09MDtjYXNlIDk6cmV0dXJuISF0aGlzLmVHZW5lcmljVHlwZSYmISh0aGlzLmVUeXBlJiYhdGhpcy5lR2VuZXJpY1R5cGUuZVR5cGVQYXJhbWV0ZXImJk9kKHRoaXMuZUdlbmVyaWNUeXBlKS5zaXplXzA9PTApO2Nhc2UgMTA6cmV0dXJuISEodGhpcy5lRmxhZ3NfMD4+MTY9PTEwJiZhKHRoaXMuZUNvbnRhaW5lciw2MikpfXJldHVybiBzbCh0aGlzLG4tb24oKFBlKCksb3ApKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxvcCksbikpfSxsLmVTdGF0aWNDbGFzcz1mdW5jdGlvbigpe3JldHVybiBQZSgpLG9wfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVQYXJhbWV0ZXJJbXBsIiw1MTgpO2Z1bmN0aW9uIG5XZShlKXt2YXIgbjtyZXR1cm4gZS5lUmVmZXJlbmNlVHlwZXx8KG49ZS5lVHlwZSxMKG4sOTApJiYoZS5lUmVmZXJlbmNlVHlwZT1hKG4sMjkpKSksZS5lUmVmZXJlbmNlVHlwZX1mdW5jdGlvbiBHdChlKXt2YXIgbjtyZXR1cm4gZS5lT3Bwb3NpdGUmJmUuZU9wcG9zaXRlLmVGbGFnc18wJjY0JiYobj1lLmVPcHBvc2l0ZSxlLmVPcHBvc2l0ZT1hKEowKGUsbiksMTkpLGUuZU9wcG9zaXRlIT1uJiZlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSw5LDIxLG4sZS5lT3Bwb3NpdGUpKSksZS5lT3Bwb3NpdGV9ZnVuY3Rpb24gcHRlKGUpe3ZhciBuO3JldHVybighZS5lUmVmZXJlbmNlVHlwZXx8IShlLmVGbGFncyYxKSYmZS5lUmVmZXJlbmNlVHlwZS5lRmxhZ3NfMCY2NCkmJihuPUFsKGUpLEwobiw5MCkmJihlLmVSZWZlcmVuY2VUeXBlPWEobiwyOSkpKSxlLmVSZWZlcmVuY2VUeXBlfWZ1bmN0aW9uIEEzbihlLG4pe2d0ZShlLG4pLEwoZS5lQ29udGFpbmVyLDkwKSYmbHAoaGEoYShlLmVDb250YWluZXIsOTApKSwyKX1mdW5jdGlvbiBndGUoZSxuKXt2YXIgcjtyPShlLmVGbGFncyZHbykhPTAsbj9lLmVGbGFnc3w9R286ZS5lRmxhZ3MmPS0zMjc2OSxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgcnMoZSwxLDE4LHIsbikpfWZ1bmN0aW9uIGh0ZShlLG4pe3ZhciByO3I9ZS5lT3Bwb3NpdGUsZS5lT3Bwb3NpdGU9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDIxLHIsZS5lT3Bwb3NpdGUpKX1mdW5jdGlvbiBtdGUoZSxuKXt2YXIgcjtyPShlLmVGbGFncyZGdCkhPTAsbj9lLmVGbGFnc3w9RnQ6ZS5lRmxhZ3MmPS02NTUzNyxlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgcnMoZSwxLDIwLHIsbikpfWZ1bmN0aW9uIHl0ZSgpe3FIZS5jYWxsKHRoaXMpLHRoaXMuZUZsYWdzfD1GdH1wKDEwMiw0NjIsezExMDoxLDk0OjEsOTM6MSwxNTU6MSwxOTc6MSw1ODoxLDE5OjEsMTc5OjEsNjk6MSwxMTQ6MSw0ODE6MSw1NDoxLDk5OjEsMTU4OjEsMTAyOjEsNDYyOjEsMjkyOjEsMTE5OjEsMTIwOjEsNjkyOjF9LHl0ZSksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpLHMsdTtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnM7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMDtjYXNlIDI6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmMjU2KTtjYXNlIDM6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmNTEyKTtjYXNlIDQ6cmV0dXJuIEoodGhpcy5sb3dlckJvdW5kKTtjYXNlIDU6cmV0dXJuIEoodGhpcy51cHBlckJvdW5kKTtjYXNlIDY6cmV0dXJuIHplKCksdT10aGlzLnVwcGVyQm91bmQsdT4xfHx1PT0tMTtjYXNlIDc6cmV0dXJuIHplKCksaT10aGlzLmxvd2VyQm91bmQsaT49MTtjYXNlIDg6cmV0dXJuIHI/QWwodGhpcyk6dGhpcy5lVHlwZTtjYXNlIDk6cmV0dXJuIHRoaXMuZUdlbmVyaWNUeXBlO2Nhc2UgMTA6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmTGwpO2Nhc2UgMTE6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmamQpO2Nhc2UgMTI6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmSGQpO2Nhc2UgMTM6cmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlTGl0ZXJhbDtjYXNlIDE0OnJldHVybiBxdyh0aGlzKTtjYXNlIDE1OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkZpKTtjYXNlIDE2OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJktzKTtjYXNlIDE3OnJldHVybiBhcCh0aGlzKTtjYXNlIDE4OnJldHVybiB6ZSgpLCEhKHRoaXMuZUZsYWdzJkdvKTtjYXNlIDE5OnJldHVybiB6ZSgpLHM9R3QodGhpcyksISEocyYmcy5lRmxhZ3MmR28pO2Nhc2UgMjA6cmV0dXJuIHplKCksISEodGhpcy5lRmxhZ3MmRnQpO2Nhc2UgMjE6cmV0dXJuIHI/R3QodGhpcyk6dGhpcy5lT3Bwb3NpdGU7Y2FzZSAyMjpyZXR1cm4gcj9wdGUodGhpcyk6bldlKHRoaXMpO2Nhc2UgMjM6cmV0dXJuIXRoaXMuZUtleXMmJih0aGlzLmVLZXlzPW5ldyBXZyhucCx0aGlzLDIzKSksdGhpcy5lS2V5c31yZXR1cm4gbGwodGhpcyxuLW9uKChQZSgpLEJnKSksa2UoKG89YShCZSh0aGlzLDE2KSwyOSksb3x8QmcpLG4pLHIsdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLmVBbm5vdGF0aW9ucyYmdGhpcy5lQW5ub3RhdGlvbnMuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4gdGhpcy5uYW1lXzAhPW51bGw7Y2FzZSAyOnJldHVybih0aGlzLmVGbGFncyYyNTYpPT0wO2Nhc2UgMzpyZXR1cm4odGhpcy5lRmxhZ3MmNTEyKT09MDtjYXNlIDQ6cmV0dXJuIHRoaXMubG93ZXJCb3VuZCE9MDtjYXNlIDU6cmV0dXJuIHRoaXMudXBwZXJCb3VuZCE9MTtjYXNlIDY6cmV0dXJuIGk9dGhpcy51cHBlckJvdW5kLGk+MXx8aT09LTE7Y2FzZSA3OnJldHVybiB0PXRoaXMubG93ZXJCb3VuZCx0Pj0xO2Nhc2UgODpyZXR1cm4hIXRoaXMuZVR5cGUmJiF0aGlzLmVHZW5lcmljVHlwZS5lVHlwZVBhcmFtZXRlciYmT2QodGhpcy5lR2VuZXJpY1R5cGUpLnNpemVfMD09MDtjYXNlIDk6cmV0dXJuISF0aGlzLmVHZW5lcmljVHlwZSYmISh0aGlzLmVUeXBlJiYhdGhpcy5lR2VuZXJpY1R5cGUuZVR5cGVQYXJhbWV0ZXImJk9kKHRoaXMuZUdlbmVyaWNUeXBlKS5zaXplXzA9PTApO2Nhc2UgMTA6cmV0dXJuKHRoaXMuZUZsYWdzJkxsKT09MDtjYXNlIDExOnJldHVybih0aGlzLmVGbGFncyZqZCkhPTA7Y2FzZSAxMjpyZXR1cm4odGhpcy5lRmxhZ3MmSGQpIT0wO2Nhc2UgMTM6cmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlTGl0ZXJhbCE9bnVsbDtjYXNlIDE0OnJldHVybiBxdyh0aGlzKSE9bnVsbDtjYXNlIDE1OnJldHVybih0aGlzLmVGbGFncyZGaSkhPTA7Y2FzZSAxNjpyZXR1cm4odGhpcy5lRmxhZ3MmS3MpIT0wO2Nhc2UgMTc6cmV0dXJuISFhcCh0aGlzKTtjYXNlIDE4OnJldHVybih0aGlzLmVGbGFncyZHbykhPTA7Y2FzZSAxOTpyZXR1cm4gbz1HdCh0aGlzKSwhIW8mJihvLmVGbGFncyZHbykhPTA7Y2FzZSAyMDpyZXR1cm4odGhpcy5lRmxhZ3MmRnQpPT0wO2Nhc2UgMjE6cmV0dXJuISF0aGlzLmVPcHBvc2l0ZTtjYXNlIDIyOnJldHVybiEhbldlKHRoaXMpO2Nhc2UgMjM6cmV0dXJuISF0aGlzLmVLZXlzJiZ0aGlzLmVLZXlzLnNpemVfMCE9MH1yZXR1cm4gc2wodGhpcyxuLW9uKChQZSgpLEJnKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8QmcpLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7dmFyIHQsbztzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpLCF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksUHIodGhpcy5lQW5ub3RhdGlvbnMsYShyLDE2KSk7cmV0dXJuO2Nhc2UgMTpGRCh0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSAyOmEwKHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAzOmwwKHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSA0OmkwKHRoaXMsYShyLDE3KS52YWx1ZV8wKTtyZXR1cm47Y2FzZSA1OmlwKHRoaXMsYShyLDE3KS52YWx1ZV8wKTtyZXR1cm47Y2FzZSA4OmwxKHRoaXMsYShyLDE0MikpO3JldHVybjtjYXNlIDk6bz1xcyh0aGlzLGEociw4OSksbnVsbCksbyYmby5kaXNwYXRjaF8wKCk7cmV0dXJuO2Nhc2UgMTA6WXcodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDExOlp3KHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAxMjpYdyh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMTM6QnJlKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDE1Okp3KHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAxNjpLdyh0aGlzLGFlKGllKHIpKSk7cmV0dXJuO2Nhc2UgMTg6QTNuKHRoaXMsYWUoaWUocikpKTtyZXR1cm47Y2FzZSAyMDptdGUodGhpcyxhZShpZShyKSkpO3JldHVybjtjYXNlIDIxOmh0ZSh0aGlzLGEociwxOSkpO3JldHVybjtjYXNlIDIzOiF0aGlzLmVLZXlzJiYodGhpcy5lS2V5cz1uZXcgV2cobnAsdGhpcywyMykpLGZuKHRoaXMuZUtleXMpLCF0aGlzLmVLZXlzJiYodGhpcy5lS2V5cz1uZXcgV2cobnAsdGhpcywyMykpLFByKHRoaXMuZUtleXMsYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxCZykpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fEJnKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxCZ30sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHIsdDtzd2l0Y2gobil7Y2FzZSAwOiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksZm4odGhpcy5lQW5ub3RhdGlvbnMpO3JldHVybjtjYXNlIDE6TCh0aGlzLmVDb250YWluZXIsOTApJiZscChoYShhKHRoaXMuZUNvbnRhaW5lciw5MCkpLDQpLGdpKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMjphMCh0aGlzLCEwKTtyZXR1cm47Y2FzZSAzOmwwKHRoaXMsITApO3JldHVybjtjYXNlIDQ6aTAodGhpcywwKTtyZXR1cm47Y2FzZSA1OmlwKHRoaXMsMSk7cmV0dXJuO2Nhc2UgODpsMSh0aGlzLG51bGwpO3JldHVybjtjYXNlIDk6dD1xcyh0aGlzLG51bGwsbnVsbCksdCYmdC5kaXNwYXRjaF8wKCk7cmV0dXJuO2Nhc2UgMTA6WXcodGhpcywhMCk7cmV0dXJuO2Nhc2UgMTE6WncodGhpcywhMSk7cmV0dXJuO2Nhc2UgMTI6WHcodGhpcywhMSk7cmV0dXJuO2Nhc2UgMTM6dGhpcy5kZWZhdWx0VmFsdWVGYWN0b3J5PW51bGwsRUwodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAxNTpKdyh0aGlzLCExKTtyZXR1cm47Y2FzZSAxNjpLdyh0aGlzLCExKTtyZXR1cm47Y2FzZSAxODpndGUodGhpcywhMSksTCh0aGlzLmVDb250YWluZXIsOTApJiZscChoYShhKHRoaXMuZUNvbnRhaW5lciw5MCkpLDIpO3JldHVybjtjYXNlIDIwOm10ZSh0aGlzLCEwKTtyZXR1cm47Y2FzZSAyMTpodGUodGhpcyxudWxsKTtyZXR1cm47Y2FzZSAyMzohdGhpcy5lS2V5cyYmKHRoaXMuZUtleXM9bmV3IFdnKG5wLHRoaXMsMjMpKSxmbih0aGlzLmVLZXlzKTtyZXR1cm59Y2wodGhpcyxuLW9uKChQZSgpLEJnKSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8QmcpLG4pKX0sbC5mcmVlemU9ZnVuY3Rpb24oKXtwdGUodGhpcyksYzIodW8oKEtpKCksVHQpLHRoaXMpKSxBbCh0aGlzKSx0aGlzLmVGbGFnc3w9MX0sbC5nZXRFT3Bwb3NpdGU9ZnVuY3Rpb24oKXtyZXR1cm4gR3QodGhpcyl9LGwuaXNDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1HdCh0aGlzKSwhIW4mJihuLmVGbGFncyZHbykhPTB9LGwuaXNDb250YWlubWVudD1mdW5jdGlvbigpe3JldHVybih0aGlzLmVGbGFncyZHbykhPTB9LGwuaXNSZXNvbHZlUHJveGllc18wPWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuZUZsYWdzJkZ0KSE9MH0sbC5zZXRFVHlwZT1mdW5jdGlvbihuLHIpe3JldHVybiB0aGlzLmVSZWZlcmVuY2VUeXBlPW51bGwsRnJlKHRoaXMsbixyKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuZUZsYWdzXzAmNjQ/dkwodGhpcyk6KG49bmV3IHlsKHZMKHRoaXMpKSxuLnN0cmluZys9IiAoY29udGFpbm1lbnQ6ICIsQWMobiwodGhpcy5lRmxhZ3MmR28pIT0wKSxuLnN0cmluZys9IiwgcmVzb2x2ZVByb3hpZXM6ICIsQWMobiwodGhpcy5lRmxhZ3MmRnQpIT0wKSxuLnN0cmluZys9IikiLG4uc3RyaW5nKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFUmVmZXJlbmNlSW1wbCIsMTAyKTtmdW5jdGlvbiBMM24oZSxuKXt3dGUoZSxuPT1udWxsP251bGw6KFZlKG4pLG4pKX1mdW5jdGlvbiBrM24oZSxuKXt3dGUoZSxuPT1udWxsP251bGw6KFZlKG4pLG4pKX1mdW5jdGlvbiB3dGUoZSxuKXt2YXIgcjtyPWUua2V5LGUua2V5PW4sZS5lRmxhZ3NfMCY0JiYhKGUuZUZsYWdzXzAmMSkmJlhuKGUsbmV3IGx0KGUsMSwwLHIsZS5rZXkpKX1mdW5jdGlvbiBFdGUoZSxuKXt2YXIgcjtyPWUudmFsdWVfMCxlLnZhbHVlXzA9bixlLmVGbGFnc18wJjQmJiEoZS5lRmxhZ3NfMCYxKSYmWG4oZSxuZXcgbHQoZSwxLDEscixlLnZhbHVlXzApKX1mdW5jdGlvbiBPM24oZSxuKXt2YXIgcjtyZXR1cm4gcj1lLnZhbHVlXzAsRXRlKGUsbikscn1mdW5jdGlvbiByV2UoKXt9cCg1NjEsMTIwLHsxMTA6MSw0NDoxLDk0OjEsOTM6MSwxMzY6MSw1ODoxLDExNDoxLDU0OjEsOTk6MSw1NjE6MSwxMTk6MSwxMjA6MX0scldlKSxsLmVxdWFsc18wPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzPT09bn0sbC5nZXRLZXk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9LGwuZ2V0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gUjEodGhpcyl9LGwuc2V0S2V5PWZ1bmN0aW9uKG4pe0wzbih0aGlzLHhuKG4pKX0sbC5zZXRWYWx1ZT1mdW5jdGlvbihuKXtyZXR1cm4gTzNuKHRoaXMseG4obikpfSxsLmVHZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuIHRoaXMua2V5O2Nhc2UgMTpyZXR1cm4gdGhpcy52YWx1ZV8wfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCksQnQpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHxCdCksbikscix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4gdGhpcy5rZXkhPW51bGw7Y2FzZSAxOnJldHVybiB0aGlzLnZhbHVlXzAhPW51bGx9cmV0dXJuIHNsKHRoaXMsbi1vbigoUGUoKSxCdCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fEJ0KSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0O3N3aXRjaChuKXtjYXNlIDA6azNuKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDE6RXRlKHRoaXMseG4ocikpO3JldHVybn11bCh0aGlzLG4tb24oKFBlKCksQnQpKSxrZSgodD1hKEJlKHRoaXMsMTYpLDI5KSx0fHxCdCksbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIFBlKCksQnR9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3ZhciByO3N3aXRjaChuKXtjYXNlIDA6d3RlKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMTpFdGUodGhpcyxudWxsKTtyZXR1cm59Y2wodGhpcyxuLW9uKChQZSgpLEJ0KSksa2UoKHI9YShCZSh0aGlzLDE2KSwyOSkscnx8QnQpLG4pKX0sbC5nZXRIYXNoPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuaGFzaD09LTEmJihuPXRoaXMua2V5LHRoaXMuaGFzaD1uPT1udWxsPzA6TmMobikpLHRoaXMuaGFzaH0sbC5zZXRIYXNoPWZ1bmN0aW9uKG4pe3RoaXMuaGFzaD1ufSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gdGhpcy5lRmxhZ3NfMCY2ND9ucyh0aGlzKToobj1uZXcgeWwobnModGhpcykpLG4uc3RyaW5nKz0iIChrZXk6ICIsSnQobix0aGlzLmtleSksbi5zdHJpbmcrPSIsIHZhbHVlOiAiLEp0KG4sdGhpcy52YWx1ZV8wKSxuLnN0cmluZys9IikiLG4uc3RyaW5nKX0sbC5oYXNoPS0xLGwua2V5PW51bGwsbC52YWx1ZV8wPW51bGw7dmFyIEJvPWcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cmluZ1RvU3RyaW5nTWFwRW50cnlJbXBsIiw1NjEpLHRXZT1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJGZWF0dXJlTWFwL0VudHJ5L0ludGVybmFsIik7ZnVuY3Rpb24gTTNuKGUsbil7dmFyIHI7aWYobiE9bnVsbCYmIWUuZVN0cnVjdHVyYWxGZWF0dXJlLmdldEVUeXBlKCkuaXNJbnN0YW5jZShuKSl0aHJvdyByPUwobiw1OCk/YShuLDU4KS5lQ2xhc3NfMCgpLm5hbWVfMDp5Xyh3YShuKSksYihuZXcgaXkoIlRoZSBmZWF0dXJlICciK2UuZVN0cnVjdHVyYWxGZWF0dXJlLmdldE5hbWUoKSsiJ3MgdHlwZSAnIitlLmVTdHJ1Y3R1cmFsRmVhdHVyZS5nZXRFVHlwZSgpLmdldE5hbWUoKSsiJyBkb2VzIG5vdCBwZXJtaXQgYSB2YWx1ZSBvZiB0eXBlICciK3IrIiciKSl9ZnVuY3Rpb24gdnRlKGUpe3RoaXMuZVN0cnVjdHVyYWxGZWF0dXJlPWV9cCg1NzYsMSxYYiksbC5jcmVhdGVFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5jcmVhdGVFbnRyeV8wKGEobiw1NCkpfSxsLmNyZWF0ZUVudHJ5XzA9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY3JlYXRlRW50cnkobil9LGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHIsdDtyZXR1cm4gdGhpcz09PW4/ITA6TChuLDc2KT8ocj1hKG4sNzYpLHIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCk9PXRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlPyh0PXRoaXMuZ2V0VmFsdWUoKSx0PT1udWxsP3IuZ2V0VmFsdWUoKT09bnVsbDpZbih0LHIuZ2V0VmFsdWUoKSkpOiExKTohMX0sbC5nZXRFU3RydWN0dXJhbEZlYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lU3RydWN0dXJhbEZlYXR1cmV9LGwuaGFzaENvZGVfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiBuPXRoaXMuZ2V0VmFsdWUoKSx1cih0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZSleKG49PW51bGw/MDp1cihuKSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIG49dGhpcy5lU3RydWN0dXJhbEZlYXR1cmUscj1IYShuLmdldEVDb250YWluaW5nQ2xhc3MoKSkuZ2V0TnNQcmVmaXgoKSxuLmdldE5hbWUoKSwociE9bnVsbCYmci5sZW5ndGghPTA/cisiOiIrbi5nZXROYW1lKCk6bi5nZXROYW1lKCkpKyI9Iit0aGlzLmdldFZhbHVlKCl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9CYXNpY0ZlYXR1cmVNYXBFbnRyeSIsNTc2KTtmdW5jdGlvbiBSM24oZSxuLHIsdCxvKXt2YXIgaTtyZXR1cm4gciYmKGk9RXIobi5lQ2xhc3NfMCgpLGUuZVN0cnVjdHVyYWxGZWF0dXJlKSxvPXIuZUludmVyc2VBZGQobiwtMS0oaT09LTE/dDppKSxudWxsLG8pKSxvfWZ1bmN0aW9uIEQzbihlLG4scix0LG8pe3ZhciBpO3JldHVybiByJiYoaT1FcihuLmVDbGFzc18wKCksZS5lU3RydWN0dXJhbEZlYXR1cmUpLG89ci5lSW52ZXJzZVJlbW92ZShuLC0xLShpPT0tMT90OmkpLG51bGwsbykpLG99ZnVuY3Rpb24gU3RlKGUsbil7dnRlLmNhbGwodGhpcyxlKSx0aGlzLnZhbHVlXzA9bn1wKDc5MSw1NzYsWGIsU3RlKSxsLmNyZWF0ZUVudHJ5XzA9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBTdGUodGhpcy5lU3RydWN0dXJhbEZlYXR1cmUsbil9LGwuZ2V0VmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZV8wfSxsLmludmVyc2VBZGRfMD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIFIzbih0aGlzLG4sdGhpcy52YWx1ZV8wLHIsdCl9LGwuaW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gRDNuKHRoaXMsbix0aGlzLnZhbHVlXzAscix0KX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0NvbnRhaW5tZW50VXBkYXRpbmdGZWF0dXJlTWFwRW50cnkiLDc5MSk7ZnVuY3Rpb24gb1dlKGUsbil7dGhpcy5mZWF0dXJlPWUsdGhpcy5mZWF0dXJlTWFwRmVhdHVyZT1ufXAoMTM1MCwxLHt9LG9XZSksbC5keW5hbWljR2V0XzA9ZnVuY3Rpb24obixyLHQsbyxpKXt2YXIgcztyZXR1cm4gcz1hKE93KG4sdGhpcy5mZWF0dXJlTWFwRmVhdHVyZSksMjIwKSxzLnNldHRpbmcodGhpcy5mZWF0dXJlKS5nZXRfNihvKX0sbC5keW5hbWljSW52ZXJzZUFkZD1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzO3JldHVybiBzPWEoT3cobix0aGlzLmZlYXR1cmVNYXBGZWF0dXJlKSwyMjApLHMuYmFzaWNBZGRfMCh0aGlzLmZlYXR1cmUsbyxpKX0sbC5keW5hbWljSW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzO3JldHVybiBzPWEoT3cobix0aGlzLmZlYXR1cmVNYXBGZWF0dXJlKSwyMjApLHMuYmFzaWNSZW1vdmVfMCh0aGlzLmZlYXR1cmUsbyxpKX0sbC5keW5hbWljSXNTZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3JldHVybiBvPWEoT3cobix0aGlzLmZlYXR1cmVNYXBGZWF0dXJlKSwyMjApLG8uc2V0dGluZyh0aGlzLmZlYXR1cmUpLmlzU2V0XzAoKX0sbC5keW5hbWljU2V0XzA9ZnVuY3Rpb24obixyLHQsbyl7dmFyIGk7aT1hKE93KG4sdGhpcy5mZWF0dXJlTWFwRmVhdHVyZSksMjIwKSxpLnNldHRpbmcodGhpcy5mZWF0dXJlKS5zZXRfMShvKX0sbC5keW5hbWljU2V0dGluZz1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIGEoT3cobix0aGlzLmZlYXR1cmVNYXBGZWF0dXJlKSwyMjApLnNldHRpbmcodGhpcy5mZWF0dXJlKX0sbC5keW5hbWljVW5zZXRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87bz1hKE93KG4sdGhpcy5mZWF0dXJlTWFwRmVhdHVyZSksMjIwKSxvLnNldHRpbmcodGhpcy5mZWF0dXJlKS51bnNldCgpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVGZWF0dXJlTWFwRGVsZWdhdG9yIiwxMzUwKTtmdW5jdGlvbiBrTChlLG4pe3N3aXRjaChlLnN0eWxlKXtjYXNlIDA6Y2FzZSAyOmNhc2UgNDpjYXNlIDY6Y2FzZSA0MjpjYXNlIDQ0OmNhc2UgNDY6Y2FzZSA0ODpjYXNlIDg6Y2FzZSAxMDpjYXNlIDEyOmNhc2UgMTQ6Y2FzZSAxNjpjYXNlIDE4OmNhc2UgMjA6Y2FzZSAyMjpjYXNlIDI0OmNhc2UgMjY6Y2FzZSAyODpjYXNlIDMwOmNhc2UgMzI6Y2FzZSAzNDpjYXNlIDM2OmNhc2UgMzg6cmV0dXJuIG5ldyBfVmUoZS5keW5hbWljS2luZCxlLmRhdGFDbGFzcyxuLGUuZmVhdHVyZSk7Y2FzZSAxOnJldHVybiBuZXcgYkwoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSA0MzpyZXR1cm4gbmV3IHJWZShlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpKTtjYXNlIDM6cmV0dXJuIG5ldyBqcihlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpKTtjYXNlIDQ1OnJldHVybiBuZXcgWGkoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSA0MTpyZXR1cm4gbmV3IFlpKGEoQWwoZS5mZWF0dXJlKSwyOSksZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSA1MDpyZXR1cm4gbmV3IGRWZShhKEFsKGUuZmVhdHVyZSksMjkpLGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSkpO2Nhc2UgNTpyZXR1cm4gbmV3IHNvZShlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpLGUuaW52ZXJzZUZlYXR1cmUuZmVhdHVyZUlEKTtjYXNlIDQ3OnJldHVybiBuZXcgdFZlKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSksZS5pbnZlcnNlRmVhdHVyZS5mZWF0dXJlSUQpO2Nhc2UgNzpyZXR1cm4gbmV3IFUoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSxlLmludmVyc2VGZWF0dXJlLmZlYXR1cmVJRCk7Y2FzZSA0OTpyZXR1cm4gbmV3IHhtKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSksZS5pbnZlcnNlRmVhdHVyZS5mZWF0dXJlSUQpO2Nhc2UgOTpyZXR1cm4gbmV3IG5WZShlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpKTtjYXNlIDExOnJldHVybiBuZXcgZVZlKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSkpO2Nhc2UgMTM6cmV0dXJuIG5ldyBsb2UoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSAxNTpyZXR1cm4gbmV3IEJMKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSkpO2Nhc2UgMTc6cmV0dXJuIG5ldyBvVmUoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSAxOTpyZXR1cm4gbmV3IFdnKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSkpO2Nhc2UgMjE6cmV0dXJuIG5ldyB1b2UoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7Y2FzZSAyMzpyZXR1cm4gbmV3IHliKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSkpO2Nhc2UgMjU6cmV0dXJuIG5ldyB1VmUoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSxlLmludmVyc2VGZWF0dXJlLmZlYXR1cmVJRCk7Y2FzZSAyNzpyZXR1cm4gbmV3IExlKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSksZS5pbnZlcnNlRmVhdHVyZS5mZWF0dXJlSUQpO2Nhc2UgMjk6cmV0dXJuIG5ldyBzVmUoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSxlLmludmVyc2VGZWF0dXJlLmZlYXR1cmVJRCk7Y2FzZSAzMTpyZXR1cm4gbmV3IGxWZShlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpLGUuaW52ZXJzZUZlYXR1cmUuZmVhdHVyZUlEKTtjYXNlIDMzOnJldHVybiBuZXcgX29lKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSksZS5pbnZlcnNlRmVhdHVyZS5mZWF0dXJlSUQpO2Nhc2UgMzU6cmV0dXJuIG5ldyBjb2UoZS5kYXRhQ2xhc3MsbixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSxlLmludmVyc2VGZWF0dXJlLmZlYXR1cmVJRCk7Y2FzZSAzNzpyZXR1cm4gbmV3IGJGKGUuZGF0YUNsYXNzLG4sRXIobi5lQ2xhc3NfMCgpLGUuZmVhdHVyZSksZS5pbnZlcnNlRmVhdHVyZS5mZWF0dXJlSUQpO2Nhc2UgMzk6cmV0dXJuIG5ldyBZTChlLmRhdGFDbGFzcyxuLEVyKG4uZUNsYXNzXzAoKSxlLmZlYXR1cmUpLGUuaW52ZXJzZUZlYXR1cmUuZmVhdHVyZUlEKTtjYXNlIDQwOnJldHVybiBuZXcgTnIobixFcihuLmVDbGFzc18wKCksZS5mZWF0dXJlKSk7ZGVmYXVsdDp0aHJvdyBiKG5ldyBJbygiVW5rbm93biBmZWF0dXJlIHN0eWxlOiAiK2Uuc3R5bGUpKX19ZnVuY3Rpb24gYzAoZSxuLHIpe3RoaXMuc3R5bGU9ZSx0aGlzLmRhdGFDbGFzcz1uLHRoaXMuZmVhdHVyZT1yfWZ1bmN0aW9uIHMxKGUsbixyLHQpe3RoaXMuc3R5bGU9ZSx0aGlzLmRhdGFDbGFzcz1uLHRoaXMuZmVhdHVyZT1yLHRoaXMuaW52ZXJzZUZlYXR1cmU9dH1mdW5jdGlvbiBfMChlLG4pe3RoaXMuc3R5bGU9ZSx0aGlzLmRhdGFDbGFzcz1Rcix0aGlzLmR5bmFtaWNLaW5kPWNWZShuKSx0aGlzLmZlYXR1cmU9bn1mdW5jdGlvbiB1MShlLG4scil7dGhpcy5zdHlsZT1lLHRoaXMuZGF0YUNsYXNzPVFyLHRoaXMuZHluYW1pY0tpbmQ9Y1ZlKG4pLHRoaXMuZmVhdHVyZT1uLHRoaXMuaW52ZXJzZUZlYXR1cmU9cn1wKDkxLDEse30sYzAsczEsXzAsdTEpLGwuZHluYW1pY0dldF8wPWZ1bmN0aW9uKG4scix0LG8saSl7dmFyIHM7aWYocz1yLmR5bmFtaWNHZXQodCkscz09bnVsbCYmci5keW5hbWljU2V0KHQscz1rTCh0aGlzLG4pKSwhaSlzd2l0Y2godGhpcy5zdHlsZSl7Y2FzZSA1MDpjYXNlIDQxOnJldHVybiBhKHMsNTk3KS5tYXBfMigpO2Nhc2UgNDA6cmV0dXJuIGEocywyMjApLmdldFdyYXBwZXIoKX1yZXR1cm4gc30sbC5keW5hbWljSW52ZXJzZUFkZD1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzLHU7cmV0dXJuIHU9ci5keW5hbWljR2V0KHQpLHU9PW51bGwmJnIuZHluYW1pY1NldCh0LHU9a0wodGhpcyxuKSkscz1hKHUsNzEpLmJhc2ljQWRkKG8saSksc30sbC5keW5hbWljSW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzO3JldHVybiBzPXIuZHluYW1pY0dldCh0KSxzIT1udWxsJiYoaT1hKHMsNzEpLmJhc2ljUmVtb3ZlKG8saSkpLGl9LGwuZHluYW1pY0lzU2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbztyZXR1cm4gbz1yLmR5bmFtaWNHZXQodCksbyE9bnVsbCYmYShvLDc5KS5pc1NldF8wKCl9LGwuZHluYW1pY1NldF8wPWZ1bmN0aW9uKG4scix0LG8pe3ZhciBpO2k9YShyLmR5bmFtaWNHZXQodCksNzkpLCFpJiZyLmR5bmFtaWNTZXQodCxpPWtMKHRoaXMsbikpLGkuc2V0XzEobyl9LGwuZHluYW1pY1NldHRpbmc9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7cmV0dXJuIGk9ci5keW5hbWljR2V0KHQpLGk9PW51bGwmJnIuZHluYW1pY1NldCh0LGk9a0wodGhpcyxuKSksTChpLDc5KT9hKGksNzkpOihvPWEoci5keW5hbWljR2V0KHQpLDE1KSxuZXcgQVdlKG8pKX0sbC5keW5hbWljVW5zZXRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG87bz1hKHIuZHluYW1pY0dldCh0KSw3OSksIW8mJnIuZHluYW1pY1NldCh0LG89a0wodGhpcyxuKSksby51bnNldCgpfSxsLmR5bmFtaWNLaW5kPTAsbC5zdHlsZT0wLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZU1hbnkiLDkxKTtmdW5jdGlvbiBkbCgpe2RsPUYsanU9KGQkZSgpLGYkZSl9ZnVuY3Rpb24gT0woZSl7dGhpcy5mZWF0dXJlPWV9cCg1MTIsMSx7fSksbC5keW5hbWljSW52ZXJzZUFkZD1mdW5jdGlvbihuLHIsdCxvLGkpe3Rocm93IGIobmV3IFRuKX0sbC5keW5hbWljSW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIsdCxvLGkpe3Rocm93IGIobmV3IFRuKX0sbC5keW5hbWljU2V0dGluZz1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIG5ldyBpV2UodGhpcyxuLHIsdCl9O3ZhciBqdTtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGUiLDUxMik7ZnVuY3Rpb24gaVdlKGUsbixyLHQpe3RoaXMudGhpcyQxMT1lLHRoaXMudmFsJG93bmVyMj1uLHRoaXMudmFsJHNldHRpbmdzMz1yLHRoaXMudmFsJGluZGV4ND10fXAoMTM2NywxLHc2LGlXZSksbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aGlzJDExLmR5bmFtaWNHZXRfMCh0aGlzLnZhbCRvd25lcjIsdGhpcy52YWwkc2V0dGluZ3MzLHRoaXMudmFsJGluZGV4NCxuLCEwKX0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQxMS5keW5hbWljSXNTZXQodGhpcy52YWwkb3duZXIyLHRoaXMudmFsJHNldHRpbmdzMyx0aGlzLnZhbCRpbmRleDQpfSxsLnNldF8xPWZ1bmN0aW9uKG4pe3RoaXMudGhpcyQxMS5keW5hbWljU2V0XzAodGhpcy52YWwkb3duZXIyLHRoaXMudmFsJHNldHRpbmdzMyx0aGlzLnZhbCRpbmRleDQsbil9LGwudW5zZXQ9ZnVuY3Rpb24oKXt0aGlzLnRoaXMkMTEuZHluYW1pY1Vuc2V0XzAodGhpcy52YWwkb3duZXIyLHRoaXMudmFsJHNldHRpbmdzMyx0aGlzLnZhbCRpbmRleDQpfSxsLnZhbCRpbmRleDQ9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGUvMSIsMTM2Nyk7ZnVuY3Rpb24gQ3RlKGUsbixyKXtkbCgpLE9MLmNhbGwodGhpcyxuKSx0aGlzLmVDbGFzcz1lLHRoaXMuaW52ZXJzZUZlYXR1cmU9cn1wKDc4NCw1MTIse30sQ3RlKSxsLmR5bmFtaWNHZXRfMD1mdW5jdGlvbihuLHIsdCxvLGkpe3JldHVybiBHUihuLG4uZUludGVybmFsQ29udGFpbmVyKCksbi5lQ29udGFpbmVyRmVhdHVyZUlEXzAoKSk9PXRoaXMuaW52ZXJzZUZlYXR1cmU/dGhpcy5pc1Jlc29sdmVQcm94aWVzXzAoKSYmbz9NUihuKTpuLmVJbnRlcm5hbENvbnRhaW5lcigpOm51bGx9LGwuZHluYW1pY0ludmVyc2VBZGQ9ZnVuY3Rpb24obixyLHQsbyxpKXt2YXIgcyx1O3JldHVybiBuLmVJbnRlcm5hbENvbnRhaW5lcigpJiYoaT0ocz1uLmVDb250YWluZXJGZWF0dXJlSURfMCgpLHM+PTA/bi5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZShpKTpuLmVJbnRlcm5hbENvbnRhaW5lcigpLmVJbnZlcnNlUmVtb3ZlKG4sLTEtcyxudWxsLGkpKSksdT1FcihuLmVDbGFzc18wKCksdGhpcy5mZWF0dXJlKSxuLmVCYXNpY1NldENvbnRhaW5lcl8wKG8sdSxpKX0sbC5keW5hbWljSW52ZXJzZVJlbW92ZT1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzO3JldHVybiBzPUVyKG4uZUNsYXNzXzAoKSx0aGlzLmZlYXR1cmUpLG4uZUJhc2ljU2V0Q29udGFpbmVyXzAobnVsbCxzLGkpfSxsLmR5bmFtaWNJc1NldD1mdW5jdGlvbihuLHIsdCl7dmFyIG87cmV0dXJuIG89RXIobi5lQ2xhc3NfMCgpLHRoaXMuZmVhdHVyZSksISFuLmVJbnRlcm5hbENvbnRhaW5lcigpJiZuLmVDb250YWluZXJGZWF0dXJlSURfMCgpPT1vfSxsLmR5bmFtaWNTZXRfMD1mdW5jdGlvbihuLHIsdCxvKXt2YXIgaSxzLHUsYyxfO2lmKG8hPW51bGwmJiFIRCh0aGlzLmVDbGFzcyxvKSl0aHJvdyBiKG5ldyBpeSgiVGhlIHZhbHVlIG9mIHR5cGUgJyIrKEwobyw1OCk/anJlKGEobyw1OCkuZUNsYXNzXzAoKSk6b3ood2EobykpKSsiJyBtdXN0IGJlIG9mIHR5cGUgJyIrdGhpcy5lQ2xhc3MrIiciKSk7aWYoaT1uLmVJbnRlcm5hbENvbnRhaW5lcigpLHU9RXIobi5lQ2xhc3NfMCgpLHRoaXMuZmVhdHVyZSksRChvKSE9PUQoaSl8fG4uZUNvbnRhaW5lckZlYXR1cmVJRF8wKCkhPXUmJm8hPW51bGwpe2lmKGYyKG4sYShvLDU4KSkpdGhyb3cgYihuZXcgR2UoIlJlY3Vyc2l2ZSBjb250YWlubWVudCBub3QgYWxsb3dlZCBmb3IgIituLnRvU3RyaW5nXzAoKSkpO189bnVsbCxpJiYoXz0ocz1uLmVDb250YWluZXJGZWF0dXJlSURfMCgpLHM+PTA/bi5lQmFzaWNSZW1vdmVGcm9tQ29udGFpbmVyRmVhdHVyZShfKTpuLmVJbnRlcm5hbENvbnRhaW5lcigpLmVJbnZlcnNlUmVtb3ZlKG4sLTEtcyxudWxsLF8pKSksYz1hKG8sNTQpLGMmJihfPWMuZUludmVyc2VBZGQobixFcihjLmVDbGFzc18wKCksdGhpcy5pbnZlcnNlRmVhdHVyZSksbnVsbCxfKSksXz1uLmVCYXNpY1NldENvbnRhaW5lcl8wKGMsdSxfKSxfJiZfLmRpc3BhdGNoXzAoKX1lbHNlIG4uZUJhc2ljSGFzQWRhcHRlcnMoKSYmbi5lRGVsaXZlcigpJiZYbihuLG5ldyBsdChuLDEsdSxvLG8pKX0sbC5keW5hbWljVW5zZXRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saSxzLHU7bz1uLmVJbnRlcm5hbENvbnRhaW5lcigpLG8/KHU9KGk9bi5lQ29udGFpbmVyRmVhdHVyZUlEXzAoKSxpPj0wP24uZUJhc2ljUmVtb3ZlRnJvbUNvbnRhaW5lckZlYXR1cmUobnVsbCk6bi5lSW50ZXJuYWxDb250YWluZXIoKS5lSW52ZXJzZVJlbW92ZShuLC0xLWksbnVsbCxudWxsKSkscz1FcihuLmVDbGFzc18wKCksdGhpcy5mZWF0dXJlKSx1PW4uZUJhc2ljU2V0Q29udGFpbmVyXzAobnVsbCxzLHUpLHUmJnUuZGlzcGF0Y2hfMCgpKTpuLmVCYXNpY0hhc0FkYXB0ZXJzKCkmJm4uZURlbGl2ZXIoKSYmWG4obixuZXcgYlMobiwxLHRoaXMuZmVhdHVyZSxudWxsLG51bGwpKX0sbC5pc1Jlc29sdmVQcm94aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlQ29udGFpbmVyIiw3ODQpO2Z1bmN0aW9uIGFXZShlLG4scil7ZGwoKSxDdGUuY2FsbCh0aGlzLGUsbixyKX1wKDEzNTEsNzg0LHt9LGFXZSksbC5pc1Jlc29sdmVQcm94aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlQ29udGFpbmVyUmVzb2x2aW5nIiwxMzUxKTtmdW5jdGlvbiBsV2UoZSxuLHIpe09MLmNhbGwodGhpcyxyKSx0aGlzLmRlZmF1bHRWYWx1ZT1lLHRoaXMuaW50cmluc2ljRGVmYXVsdFZhbHVlPW4sdGhpcy5ub3RpZmljYXRpb25DcmVhdG9yPSh1RigpLGNGKX1mdW5jdGlvbiBzV2UoZSxuLHIsdCl7T0wuY2FsbCh0aGlzLHIpLHRoaXMuZGVmYXVsdFZhbHVlPWUsdGhpcy5pbnRyaW5zaWNEZWZhdWx0VmFsdWU9bix0aGlzLm5vdGlmaWNhdGlvbkNyZWF0b3I9dH1wKDU3NCw1MTIse30pLGwuZHluYW1pY0dldF8wPWZ1bmN0aW9uKG4scix0LG8saSl7dmFyIHM7cmV0dXJuIHM9ci5keW5hbWljR2V0KHQpLHM9PW51bGw/dGhpcy5kZWZhdWx0VmFsdWU6RChzKT09PUQoanUpP251bGw6c30sbC5keW5hbWljSXNTZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3JldHVybiBvPXIuZHluYW1pY0dldCh0KSxvIT1udWxsJiYoRChvKT09PUQoanUpfHwhWW4obyx0aGlzLmRlZmF1bHRWYWx1ZSkpfSxsLmR5bmFtaWNTZXRfMD1mdW5jdGlvbihuLHIsdCxvKXt2YXIgaSxzO24uZUJhc2ljSGFzQWRhcHRlcnMoKSYmbi5lRGVsaXZlcigpPyhpPShzPXIuZHluYW1pY0dldCh0KSxzPT1udWxsP3RoaXMuZGVmYXVsdFZhbHVlOkQocyk9PT1EKGp1KT9udWxsOnMpLG89PW51bGw/dGhpcy5pbnRyaW5zaWNEZWZhdWx0VmFsdWUhPW51bGw/KHIuZHluYW1pY1NldCh0LG51bGwpLG89dGhpcy5kZWZhdWx0VmFsdWUpOnRoaXMuZGVmYXVsdFZhbHVlIT1udWxsP3IuZHluYW1pY1NldCh0LGp1KTpyLmR5bmFtaWNTZXQodCxudWxsKToodGhpcy52YWxpZGF0ZV8wKG8pLHIuZHluYW1pY1NldCh0LG8pKSxYbihuLHRoaXMubm90aWZpY2F0aW9uQ3JlYXRvci5jcmVhdGVOb3RpZmljYXRpb25fMChuLDEsdGhpcy5mZWF0dXJlLGksbykpKTpvPT1udWxsP3RoaXMuaW50cmluc2ljRGVmYXVsdFZhbHVlIT1udWxsP3IuZHluYW1pY1NldCh0LG51bGwpOnRoaXMuZGVmYXVsdFZhbHVlIT1udWxsP3IuZHluYW1pY1NldCh0LGp1KTpyLmR5bmFtaWNTZXQodCxudWxsKToodGhpcy52YWxpZGF0ZV8wKG8pLHIuZHluYW1pY1NldCh0LG8pKX0sbC5keW5hbWljVW5zZXRfMD1mdW5jdGlvbihuLHIsdCl7dmFyIG8saTtuLmVCYXNpY0hhc0FkYXB0ZXJzKCkmJm4uZURlbGl2ZXIoKT8obz0oaT1yLmR5bmFtaWNHZXQodCksaT09bnVsbD90aGlzLmRlZmF1bHRWYWx1ZTpEKGkpPT09RChqdSk/bnVsbDppKSxyLmR5bmFtaWNVbnNldCh0KSxYbihuLHRoaXMubm90aWZpY2F0aW9uQ3JlYXRvci5jcmVhdGVOb3RpZmljYXRpb25fMChuLDEsdGhpcy5mZWF0dXJlLG8sdGhpcy5kZWZhdWx0VmFsdWUpKSk6ci5keW5hbWljVW5zZXQodCl9LGwudmFsaWRhdGVfMD1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBuY2UpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhIiw1NzQpO2Z1bmN0aW9uIHVGKCl7dUY9RixjRj1uZXcgdVdlLFR0ZT1uZXcgY1dlLGJ0ZT1uZXcgX1dlLEl0ZT1uZXcgZFdlLHh0ZT1uZXcgZldlLFB0ZT1uZXcgcFdlLE50ZT1uZXcgZ1dlLEF0ZT1uZXcgaFdlLEx0ZT1uZXcgbVdlfWZ1bmN0aW9uIHVXZSgpe31wKHZwLDEse30sdVdlKSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8wPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyBiUyhuLHIsdCxvLGkpfSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8xPWZ1bmN0aW9uKG4scix0LG8saSxzKXtyZXR1cm4gbmV3IGlGKG4scix0LG8saSxzKX07dmFyIFR0ZSxidGUsSXRlLHh0ZSxQdGUsTnRlLEF0ZSxjRixMdGU7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YS9Ob3RpZmljYXRpb25DcmVhdG9yIix2cCk7ZnVuY3Rpb24gY1dlKCl7fXAoMTM2OCx2cCx7fSxjV2UpLGwuY3JlYXRlTm90aWZpY2F0aW9uXzA9ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbmV3IF90ZShuLHIsdCxhZShpZShvKSksYWUoaWUoaSkpKX0sbC5jcmVhdGVOb3RpZmljYXRpb25fMT1mdW5jdGlvbihuLHIsdCxvLGkscyl7cmV0dXJuIG5ldyBxVWUobixyLHQsYWUoaWUobykpLGFlKGllKGkpKSxzKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YS9Ob3RpZmljYXRpb25DcmVhdG9yLzEiLDEzNjgpO2Z1bmN0aW9uIF9XZSgpe31wKDEzNjksdnAse30sX1dlKSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8wPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyBvdGUobixyLHQsYShvLDIyMikudmFsdWVfMCxhKGksMjIyKS52YWx1ZV8wKX0sbC5jcmVhdGVOb3RpZmljYXRpb25fMT1mdW5jdGlvbihuLHIsdCxvLGkscyl7cmV0dXJuIG5ldyBCVWUobixyLHQsYShvLDIyMikudmFsdWVfMCxhKGksMjIyKS52YWx1ZV8wLHMpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhL05vdGlmaWNhdGlvbkNyZWF0b3IvMiIsMTM2OSk7ZnVuY3Rpb24gZFdlKCl7fXAoMTM3MCx2cCx7fSxkV2UpLGwuY3JlYXRlTm90aWZpY2F0aW9uXzA9ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbmV3IGl0ZShuLHIsdCxhKG8sMTgwKS52YWx1ZV8wLGEoaSwxODApLnZhbHVlXzApfSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8xPWZ1bmN0aW9uKG4scix0LG8saSxzKXtyZXR1cm4gbmV3IEdVZShuLHIsdCxhKG8sMTgwKS52YWx1ZV8wLGEoaSwxODApLnZhbHVlXzAscyl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZURhdGEvTm90aWZpY2F0aW9uQ3JlYXRvci8zIiwxMzcwKTtmdW5jdGlvbiBmV2UoKXt9cCgxMzcxLHZwLHt9LGZXZSksbC5jcmVhdGVOb3RpZmljYXRpb25fMD1mdW5jdGlvbihuLHIsdCxvLGkpe3JldHVybiBuZXcgYXRlKG4scix0LFIoJChvKSksUigkKGkpKSl9LGwuY3JlYXRlTm90aWZpY2F0aW9uXzE9ZnVuY3Rpb24obixyLHQsbyxpLHMpe3JldHVybiBuZXcgSFVlKG4scix0LFIoJChvKSksUigkKGkpKSxzKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YS9Ob3RpZmljYXRpb25DcmVhdG9yLzQiLDEzNzEpO2Z1bmN0aW9uIHBXZSgpe31wKDEzNzIsdnAse30scFdlKSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8wPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyBsdGUobixyLHQsYShvLDE2MSkudmFsdWVfMCxhKGksMTYxKS52YWx1ZV8wKX0sbC5jcmVhdGVOb3RpZmljYXRpb25fMT1mdW5jdGlvbihuLHIsdCxvLGkscyl7cmV0dXJuIG5ldyBVVWUobixyLHQsYShvLDE2MSkudmFsdWVfMCxhKGksMTYxKS52YWx1ZV8wLHMpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhL05vdGlmaWNhdGlvbkNyZWF0b3IvNSIsMTM3Mik7ZnVuY3Rpb24gZ1dlKCl7fXAoMTM3Myx2cCx7fSxnV2UpLGwuY3JlYXRlTm90aWZpY2F0aW9uXzA9ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbmV3IHN0ZShuLHIsdCxhKG8sMTcpLnZhbHVlXzAsYShpLDE3KS52YWx1ZV8wKX0sbC5jcmVhdGVOb3RpZmljYXRpb25fMT1mdW5jdGlvbihuLHIsdCxvLGkscyl7cmV0dXJuIG5ldyBXVWUobixyLHQsYShvLDE3KS52YWx1ZV8wLGEoaSwxNykudmFsdWVfMCxzKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YS9Ob3RpZmljYXRpb25DcmVhdG9yLzYiLDEzNzMpO2Z1bmN0aW9uIGhXZSgpe31wKDEzNzQsdnAse30saFdlKSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8wPWZ1bmN0aW9uKG4scix0LG8saSl7cmV0dXJuIG5ldyB1dGUobixyLHQsYShvLDE2OCkudmFsdWVfMCxhKGksMTY4KS52YWx1ZV8wKX0sbC5jcmVhdGVOb3RpZmljYXRpb25fMT1mdW5jdGlvbihuLHIsdCxvLGkscyl7cmV0dXJuIG5ldyBqVWUobixyLHQsYShvLDE2OCkudmFsdWVfMCxhKGksMTY4KS52YWx1ZV8wLHMpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhL05vdGlmaWNhdGlvbkNyZWF0b3IvNyIsMTM3NCk7ZnVuY3Rpb24gbVdlKCl7fXAoMTM3NSx2cCx7fSxtV2UpLGwuY3JlYXRlTm90aWZpY2F0aW9uXzA9ZnVuY3Rpb24obixyLHQsbyxpKXtyZXR1cm4gbmV3IGN0ZShuLHIsdCxhKG8sMTkxKS52YWx1ZV8wLGEoaSwxOTEpLnZhbHVlXzApfSxsLmNyZWF0ZU5vdGlmaWNhdGlvbl8xPWZ1bmN0aW9uKG4scix0LG8saSxzKXtyZXR1cm4gbmV3IFZVZShuLHIsdCxhKG8sMTkxKS52YWx1ZV8wLGEoaSwxOTEpLnZhbHVlXzAscyl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZURhdGEvTm90aWZpY2F0aW9uQ3JlYXRvci84IiwxMzc1KTtmdW5jdGlvbiB5V2UoZSxuLHIsdCl7ZGwoKSxsV2UuY2FsbCh0aGlzLG4scix0KSx0aGlzLmVEYXRhVHlwZT1lfXAoMTM1Myw1NzQse30seVdlKSxsLnZhbGlkYXRlXzA9ZnVuY3Rpb24obil7aWYoIXRoaXMuZURhdGFUeXBlLmlzSW5zdGFuY2UobikpdGhyb3cgYihuZXcgaXkoIlRoZSB2YWx1ZSBvZiB0eXBlICciK3dhKG4pKyInIG11c3QgYmUgb2YgdHlwZSAnIit0aGlzLmVEYXRhVHlwZSsiJyIpKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YUR5bmFtaWMiLDEzNTMpO2Z1bmN0aW9uIHdXZShlLG4scix0KXtkbCgpLHNXZS5jYWxsKHRoaXMsZSxuLHIsdCl9cCgxMzU0LDU3NCx7fSx3V2UpLGwudmFsaWRhdGVfMD1mdW5jdGlvbihuKXt9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZURhdGFTdGF0aWMiLDEzNTQpLHAoNzg1LDU3NCx7fSksbC5keW5hbWljSXNTZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3JldHVybiBvPXIuZHluYW1pY0dldCh0KSxvIT1udWxsfSxsLmR5bmFtaWNTZXRfMD1mdW5jdGlvbihuLHIsdCxvKXt2YXIgaSxzO24uZUJhc2ljSGFzQWRhcHRlcnMoKSYmbi5lRGVsaXZlcigpPyhpPSEwLHM9ci5keW5hbWljR2V0KHQpLHM9PW51bGw/KGk9ITEscz10aGlzLmRlZmF1bHRWYWx1ZSk6RChzKT09PUQoanUpJiYocz1udWxsKSxvPT1udWxsP3RoaXMuaW50cmluc2ljRGVmYXVsdFZhbHVlIT1udWxsPyhyLmR5bmFtaWNTZXQodCxudWxsKSxvPXRoaXMuZGVmYXVsdFZhbHVlKTpyLmR5bmFtaWNTZXQodCxqdSk6KHRoaXMudmFsaWRhdGVfMChvKSxyLmR5bmFtaWNTZXQodCxvKSksWG4obix0aGlzLm5vdGlmaWNhdGlvbkNyZWF0b3IuY3JlYXRlTm90aWZpY2F0aW9uXzEobiwxLHRoaXMuZmVhdHVyZSxzLG8sIWkpKSk6bz09bnVsbD90aGlzLmludHJpbnNpY0RlZmF1bHRWYWx1ZSE9bnVsbD9yLmR5bmFtaWNTZXQodCxudWxsKTpyLmR5bmFtaWNTZXQodCxqdSk6KHRoaXMudmFsaWRhdGVfMChvKSxyLmR5bmFtaWNTZXQodCxvKSl9LGwuZHluYW1pY1Vuc2V0XzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGk7bi5lQmFzaWNIYXNBZGFwdGVycygpJiZuLmVEZWxpdmVyKCk/KG89ITAsaT1yLmR5bmFtaWNHZXQodCksaT09bnVsbD8obz0hMSxpPXRoaXMuZGVmYXVsdFZhbHVlKTpEKGkpPT09RChqdSkmJihpPW51bGwpLHIuZHluYW1pY1Vuc2V0KHQpLFhuKG4sdGhpcy5ub3RpZmljYXRpb25DcmVhdG9yLmNyZWF0ZU5vdGlmaWNhdGlvbl8xKG4sMix0aGlzLmZlYXR1cmUsaSx0aGlzLmRlZmF1bHRWYWx1ZSxvKSkpOnIuZHluYW1pY1Vuc2V0KHQpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhVW5zZXR0YWJsZSIsNzg1KTtmdW5jdGlvbiBFV2UoZSxuLHIsdCl7ZGwoKSxsV2UuY2FsbCh0aGlzLG4scix0KSx0aGlzLmVEYXRhVHlwZT1lfXAoMTM1NSw3ODUse30sRVdlKSxsLnZhbGlkYXRlXzA9ZnVuY3Rpb24obil7aWYoIXRoaXMuZURhdGFUeXBlLmlzSW5zdGFuY2UobikpdGhyb3cgYihuZXcgaXkoIlRoZSB2YWx1ZSBvZiB0eXBlICciK3dhKG4pKyInIG11c3QgYmUgb2YgdHlwZSAnIit0aGlzLmVEYXRhVHlwZSsiJyIpKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRGF0YVVuc2V0dGFibGVEeW5hbWljIiwxMzU1KTtmdW5jdGlvbiB2V2UoZSxuLHIsdCl7ZGwoKSxzV2UuY2FsbCh0aGlzLGUsbixyLHQpfXAoMTM1Niw3ODUse30sdldlKSxsLnZhbGlkYXRlXzA9ZnVuY3Rpb24obil7fSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVEYXRhVW5zZXR0YWJsZVN0YXRpYyIsMTM1Nik7ZnVuY3Rpb24gTUwoZSxuKXtkbCgpLE9MLmNhbGwodGhpcyxuKSx0aGlzLmVDbGFzcz1lfWZ1bmN0aW9uIGt0ZShlLG4scil7T0wuY2FsbCh0aGlzLG4pLHRoaXMuZUNsYXNzPWUsdGhpcy5pbnZlcnNlRmVhdHVyZT1yfXAoNDEwLDUxMix7fSxNTCksbC5keW5hbWljR2V0XzA9ZnVuY3Rpb24obixyLHQsbyxpKXt2YXIgcyx1LGMsXyxkO2lmKGQ9ci5keW5hbWljR2V0KHQpLHRoaXMuaXNVbnNldHRhYmxlKCkmJkQoZCk9PT1EKGp1KSlyZXR1cm4gbnVsbDtpZih0aGlzLmlzUmVzb2x2ZVByb3hpZXNfMCgpJiZvJiZkIT1udWxsKXtpZihjPWEoZCw1NCksYy5lSXNQcm94eSgpJiYoXz1KMChuLGMpLGMhPV8pKXtpZighSEQodGhpcy5lQ2xhc3MsXykpdGhyb3cgYihuZXcgaXkoIlRoZSB2YWx1ZSBvZiB0eXBlICciK3dhKF8pKyInIG11c3QgYmUgb2YgdHlwZSAnIit0aGlzLmVDbGFzcysiJyIpKTtyLmR5bmFtaWNTZXQodCxkPV8pLHRoaXMuaXNDb250YWlubWVudCgpJiYocz1hKF8sNTQpLHU9Yy5lSW52ZXJzZVJlbW92ZShuLHRoaXMuaW52ZXJzZUZlYXR1cmU/RXIoYy5lQ2xhc3NfMCgpLHRoaXMuaW52ZXJzZUZlYXR1cmUpOi0xLUVyKG4uZUNsYXNzXzAoKSx0aGlzLmZlYXR1cmUpLG51bGwsbnVsbCksIXMuZUludGVybmFsQ29udGFpbmVyKCkmJih1PXMuZUludmVyc2VBZGQobix0aGlzLmludmVyc2VGZWF0dXJlP0VyKHMuZUNsYXNzXzAoKSx0aGlzLmludmVyc2VGZWF0dXJlKTotMS1FcihuLmVDbGFzc18wKCksdGhpcy5mZWF0dXJlKSxudWxsLHUpKSx1JiZ1LmRpc3BhdGNoXzAoKSksbi5lQmFzaWNIYXNBZGFwdGVycygpJiZuLmVEZWxpdmVyKCkmJlhuKG4sbmV3IGJTKG4sOSx0aGlzLmZlYXR1cmUsYyxfKSl9cmV0dXJuIGR9ZWxzZSByZXR1cm4gZH0sbC5keW5hbWljSW52ZXJzZUFkZD1mdW5jdGlvbihuLHIsdCxvLGkpe3ZhciBzLHU7cmV0dXJuIHU9ci5keW5hbWljR2V0KHQpLEQodSk9PT1EKGp1KSYmKHU9bnVsbCksci5keW5hbWljU2V0KHQsbyksdGhpcy5oYXNJbnZlcnNlKCk/RCh1KSE9PUQobykmJnUhPW51bGwmJihzPWEodSw1NCksaT1zLmVJbnZlcnNlUmVtb3ZlKG4sRXIocy5lQ2xhc3NfMCgpLHRoaXMuaW52ZXJzZUZlYXR1cmUpLG51bGwsaSkpOnRoaXMuaXNDb250YWlubWVudCgpJiZ1IT1udWxsJiYoaT1hKHUsNTQpLmVJbnZlcnNlUmVtb3ZlKG4sLTEtRXIobi5lQ2xhc3NfMCgpLHRoaXMuZmVhdHVyZSksbnVsbCxpKSksbi5lQmFzaWNIYXNBZGFwdGVycygpJiZuLmVEZWxpdmVyKCkmJighaSYmKGk9bmV3IGVfKDQpKSxpLmFkZF81KG5ldyBiUyhuLDEsdGhpcy5mZWF0dXJlLHUsbykpKSxpfSxsLmR5bmFtaWNJbnZlcnNlUmVtb3ZlPWZ1bmN0aW9uKG4scix0LG8saSl7dmFyIHM7cmV0dXJuIHM9ci5keW5hbWljR2V0KHQpLEQocyk9PT1EKGp1KSYmKHM9bnVsbCksci5keW5hbWljVW5zZXQodCksbi5lQmFzaWNIYXNBZGFwdGVycygpJiZuLmVEZWxpdmVyKCkmJighaSYmKGk9bmV3IGVfKDQpKSx0aGlzLmlzVW5zZXR0YWJsZSgpP2kuYWRkXzUobmV3IGJTKG4sMix0aGlzLmZlYXR1cmUscyxudWxsKSk6aS5hZGRfNShuZXcgYlMobiwxLHRoaXMuZmVhdHVyZSxzLG51bGwpKSksaX0sbC5keW5hbWljSXNTZXQ9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3JldHVybiBvPXIuZHluYW1pY0dldCh0KSxvIT1udWxsfSxsLmR5bmFtaWNTZXRfMD1mdW5jdGlvbihuLHIsdCxvKXt2YXIgaSxzLHUsYyxfO2lmKG8hPW51bGwmJiFIRCh0aGlzLmVDbGFzcyxvKSl0aHJvdyBiKG5ldyBpeSgiVGhlIHZhbHVlIG9mIHR5cGUgJyIrKEwobyw1OCk/anJlKGEobyw1OCkuZUNsYXNzXzAoKSk6b3ood2EobykpKSsiJyBtdXN0IGJlIG9mIHR5cGUgJyIrdGhpcy5lQ2xhc3MrIiciKSk7Xz1yLmR5bmFtaWNHZXQodCksYz1fIT1udWxsLHRoaXMuaXNVbnNldHRhYmxlKCkmJkQoXyk9PT1EKGp1KSYmKF89bnVsbCksdT1udWxsLHRoaXMuaGFzSW52ZXJzZSgpP0QoXykhPT1EKG8pJiYoXyE9bnVsbCYmKGk9YShfLDU0KSx1PWkuZUludmVyc2VSZW1vdmUobixFcihpLmVDbGFzc18wKCksdGhpcy5pbnZlcnNlRmVhdHVyZSksbnVsbCx1KSksbyE9bnVsbCYmKGk9YShvLDU0KSx1PWkuZUludmVyc2VBZGQobixFcihpLmVDbGFzc18wKCksdGhpcy5pbnZlcnNlRmVhdHVyZSksbnVsbCx1KSkpOnRoaXMuaXNDb250YWlubWVudCgpJiZEKF8pIT09RChvKSYmKF8hPW51bGwmJih1PWEoXyw1NCkuZUludmVyc2VSZW1vdmUobiwtMS1FcihuLmVDbGFzc18wKCksdGhpcy5mZWF0dXJlKSxudWxsLHUpKSxvIT1udWxsJiYodT1hKG8sNTQpLmVJbnZlcnNlQWRkKG4sLTEtRXIobi5lQ2xhc3NfMCgpLHRoaXMuZmVhdHVyZSksbnVsbCx1KSkpLG89PW51bGwmJnRoaXMuaXNVbnNldHRhYmxlKCk/ci5keW5hbWljU2V0KHQsanUpOnIuZHluYW1pY1NldCh0LG8pLG4uZUJhc2ljSGFzQWRhcHRlcnMoKSYmbi5lRGVsaXZlcigpPyhzPW5ldyBpRihuLDEsdGhpcy5mZWF0dXJlLF8sbyx0aGlzLmlzVW5zZXR0YWJsZSgpJiYhYyksdT8odS5hZGRfNShzKSx1LmRpc3BhdGNoXzAoKSk6WG4obixzKSk6dSYmdS5kaXNwYXRjaF8wKCl9LGwuZHluYW1pY1Vuc2V0XzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvLGkscyx1LGM7Yz1yLmR5bmFtaWNHZXQodCksdT1jIT1udWxsLHRoaXMuaXNVbnNldHRhYmxlKCkmJkQoYyk9PT1EKGp1KSYmKGM9bnVsbCkscz1udWxsLGMhPW51bGwmJih0aGlzLmhhc0ludmVyc2UoKT8obz1hKGMsNTQpLHM9by5lSW52ZXJzZVJlbW92ZShuLEVyKG8uZUNsYXNzXzAoKSx0aGlzLmludmVyc2VGZWF0dXJlKSxudWxsLHMpKTp0aGlzLmlzQ29udGFpbm1lbnQoKSYmKHM9YShjLDU0KS5lSW52ZXJzZVJlbW92ZShuLC0xLUVyKG4uZUNsYXNzXzAoKSx0aGlzLmZlYXR1cmUpLG51bGwscykpKSxyLmR5bmFtaWNVbnNldCh0KSxuLmVCYXNpY0hhc0FkYXB0ZXJzKCkmJm4uZURlbGl2ZXIoKT8oaT1uZXcgaUYobix0aGlzLmlzVW5zZXR0YWJsZSgpPzI6MSx0aGlzLmZlYXR1cmUsYyxudWxsLHUpLHM/KHMuYWRkXzUoaSkscy5kaXNwYXRjaF8wKCkpOlhuKG4saSkpOnMmJnMuZGlzcGF0Y2hfMCgpfSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNSZXNvbHZlUHJveGllc18wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaXNVbnNldHRhYmxlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZUVPYmplY3QiLDQxMCk7ZnVuY3Rpb24gX0YoZSxuKXtkbCgpLE1MLmNhbGwodGhpcyxlLG4pfXAoNTc1LDQxMCx7fSxfRiksbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZUVPYmplY3RDb250YWlubWVudCIsNTc1KTtmdW5jdGlvbiBTV2UoZSxuKXtkbCgpLF9GLmNhbGwodGhpcyxlLG4pfXAoMTM1OSw1NzUse30sU1dlKSxsLmlzUmVzb2x2ZVByb3hpZXNfMD1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVFT2JqZWN0Q29udGFpbm1lbnRSZXNvbHZpbmciLDEzNTkpO2Z1bmN0aW9uIE90ZShlLG4pe2RsKCksX0YuY2FsbCh0aGlzLGUsbil9cCg3ODcsNTc1LHt9LE90ZSksbC5pc1Vuc2V0dGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdENvbnRhaW5tZW50VW5zZXR0YWJsZSIsNzg3KTtmdW5jdGlvbiBDV2UoZSxuKXtkbCgpLE90ZS5jYWxsKHRoaXMsZSxuKX1wKDEzNjEsNzg3LHt9LENXZSksbC5pc1Jlc29sdmVQcm94aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdENvbnRhaW5tZW50VW5zZXR0YWJsZVJlc29sdmluZyIsMTM2MSk7ZnVuY3Rpb24gZEYoZSxuLHIpe2RsKCksa3RlLmNhbGwodGhpcyxlLG4scil9cCg2NTAsNTc1LHt9LGRGKSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdENvbnRhaW5tZW50V2l0aEludmVyc2UiLDY1MCk7ZnVuY3Rpb24gVFdlKGUsbixyKXtkbCgpLGRGLmNhbGwodGhpcyxlLG4scil9cCgxMzYwLDY1MCx7fSxUV2UpLGwuaXNSZXNvbHZlUHJveGllc18wPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnRlcm5hbFNldHRpbmdEZWxlZ2F0ZVNpbmdsZUVPYmplY3RDb250YWlubWVudFdpdGhJbnZlcnNlUmVzb2x2aW5nIiwxMzYwKTtmdW5jdGlvbiBNdGUoZSxuLHIpe2RsKCksZEYuY2FsbCh0aGlzLGUsbixyKX1wKDc4OCw2NTAse30sTXRlKSxsLmlzVW5zZXR0YWJsZT1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVFT2JqZWN0Q29udGFpbm1lbnRXaXRoSW52ZXJzZVVuc2V0dGFibGUiLDc4OCk7ZnVuY3Rpb24gYldlKGUsbixyKXtkbCgpLE10ZS5jYWxsKHRoaXMsZSxuLHIpfXAoMTM2Miw3ODgse30sYldlKSxsLmlzUmVzb2x2ZVByb3hpZXNfMD1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvSW50ZXJuYWxTZXR0aW5nRGVsZWdhdGVTaW5nbGVFT2JqZWN0Q29udGFpbm1lbnRXaXRoSW52ZXJzZVVuc2V0dGFibGVSZXNvbHZpbmciLDEzNjIpO2Z1bmN0aW9uIFJ0ZShlLG4pe2RsKCksTUwuY2FsbCh0aGlzLGUsbil9cCg2NTEsNDEwLHt9LFJ0ZSksbC5pc1Jlc29sdmVQcm94aWVzXzA9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFJlc29sdmluZyIsNjUxKTtmdW5jdGlvbiBJV2UoZSxuKXtkbCgpLFJ0ZS5jYWxsKHRoaXMsZSxuKX1wKDEzNjMsNjUxLHt9LElXZSksbC5pc1Vuc2V0dGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFJlc29sdmluZ1Vuc2V0dGFibGUiLDEzNjMpO2Z1bmN0aW9uIER0ZShlLG4scil7ZGwoKSxrdGUuY2FsbCh0aGlzLGUsbixyKX1wKDc4OSw2NTEse30sRHRlKSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFJlc29sdmluZ1dpdGhJbnZlcnNlIiw3ODkpO2Z1bmN0aW9uIHhXZShlLG4scil7ZGwoKSxEdGUuY2FsbCh0aGlzLGUsbixyKX1wKDEzNjQsNzg5LHt9LHhXZSksbC5pc1Vuc2V0dGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFJlc29sdmluZ1dpdGhJbnZlcnNlVW5zZXR0YWJsZSIsMTM2NCk7ZnVuY3Rpb24gUFdlKGUsbil7ZGwoKSxNTC5jYWxsKHRoaXMsZSxuKX1wKDEzNTcsNDEwLHt9LFBXZSksbC5pc1Vuc2V0dGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFVuc2V0dGFibGUiLDEzNTcpO2Z1bmN0aW9uIEZ0ZShlLG4scil7ZGwoKSxrdGUuY2FsbCh0aGlzLGUsbixyKX1wKDc4Niw0MTAse30sRnRlKSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFdpdGhJbnZlcnNlIiw3ODYpO2Z1bmN0aW9uIE5XZShlLG4scil7ZGwoKSxGdGUuY2FsbCh0aGlzLGUsbixyKX1wKDEzNTgsNzg2LHt9LE5XZSksbC5pc1Vuc2V0dGFibGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFU3RydWN0dXJhbEZlYXR1cmVJbXBsL0ludGVybmFsU2V0dGluZ0RlbGVnYXRlU2luZ2xlRU9iamVjdFdpdGhJbnZlcnNlVW5zZXR0YWJsZSIsMTM1OCk7ZnVuY3Rpb24gRjNuKGUsbixyLHQpe3JldHVybiByJiYodD1yLmVJbnZlcnNlQWRkKG4sRXIoci5lQ2xhc3NfMCgpLGUuZVN0cnVjdHVyYWxGZWF0dXJlLmdldEVPcHBvc2l0ZSgpKSxudWxsLHQpKSx0fWZ1bmN0aW9uIHozbihlLG4scix0KXtyZXR1cm4gciYmKHQ9ci5lSW52ZXJzZVJlbW92ZShuLEVyKHIuZUNsYXNzXzAoKSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZS5nZXRFT3Bwb3NpdGUoKSksbnVsbCx0KSksdH1mdW5jdGlvbiB6dGUoZSxuLHIpe3RoaXMudGhpcyQwMT1lLHZ0ZS5jYWxsKHRoaXMsbiksdGhpcy52YWx1ZV8wPXJ9cCg3OTAsNTc2LFhiLHp0ZSksbC5jcmVhdGVFbnRyeV8wPWZ1bmN0aW9uKG4pe3JldHVybiBuZXcgenRlKHRoaXMudGhpcyQwMSx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZSxuKX0sbC5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlXzB9LGwuaW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gRjNuKHRoaXMsbix0aGlzLnZhbHVlXzAsdCl9LGwuaW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gejNuKHRoaXMsbix0aGlzLnZhbHVlXzAsdCl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9JbnZlcnNlVXBkYXRpbmdGZWF0dXJlTWFwRW50cnkiLDc5MCk7ZnVuY3Rpb24gQVdlKGUpe3RoaXMubGlzdD1lfXAoMTM2NSwxLHc2LEFXZSksbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5saXN0fSxsLmlzU2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gTCh0aGlzLmxpc3QsOTcpP2EodGhpcy5saXN0LDk3KS5pc1NldF8wKCk6IXRoaXMubGlzdC5pc0VtcHR5KCl9LGwuc2V0XzE9ZnVuY3Rpb24obil7dGhpcy5saXN0LmNsZWFyXzAoKSx0aGlzLmxpc3QuYWRkQWxsKGEobiwxNSkpfSxsLnVuc2V0PWZ1bmN0aW9uKCl7TCh0aGlzLmxpc3QsOTcpP2EodGhpcy5saXN0LDk3KS51bnNldCgpOnRoaXMubGlzdC5jbGVhcl8wKCl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9TZXR0aW5nTWFueSIsMTM2NSk7ZnVuY3Rpb24gTFdlKGUpe3RoaXMuZVN0cnVjdHVyYWxGZWF0dXJlPWUsdGhpcy5lRGF0YVR5cGU9YShBbChlKSwxNTYpLHRoaXMuZUZhY3Rvcnk9dGhpcy5lRGF0YVR5cGUuZ2V0RVBhY2thZ2UoKS5nZXRFRmFjdG9yeUluc3RhbmNlKCl9cCgxMzY2LDU3NixYYixMV2UpLGwuY3JlYXRlRW50cnk9ZnVuY3Rpb24obil7cmV0dXJuIG5ldyBmRigob3IoKSxPUyksdGhpcy5lRmFjdG9yeS5jb252ZXJ0VG9TdHJpbmcodGhpcy5lRGF0YVR5cGUsbikpfSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGwuaW52ZXJzZUFkZF8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gdH0sbC5pbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiB0fSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdHJ1Y3R1cmFsRmVhdHVyZUltcGwvU2ltcGxlQ29udGVudEZlYXR1cmVNYXBFbnRyeSIsMTM2Nik7ZnVuY3Rpb24gZkYoZSxuKXt2dGUuY2FsbCh0aGlzLGUpLHRoaXMudmFsdWVfMD1ufXAoNjUyLDU3NixYYixmRiksbC5jcmVhdGVFbnRyeT1mdW5jdGlvbihuKXtyZXR1cm4gbmV3IGZGKHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlLG4pfSxsLmdldFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWVfMH0sbC5pbnZlcnNlQWRkXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiB0fSxsLmludmVyc2VSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIHR9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRVN0cnVjdHVyYWxGZWF0dXJlSW1wbC9TaW1wbGVGZWF0dXJlTWFwRW50cnkiLDY1Mik7ZnVuY3Rpb24gbDIoKXt9cCg0MDMsNTA2LGV1LGwyKSxsLm5ld0RhdGE9ZnVuY3Rpb24obil7cmV0dXJuIEIoSWwsTWUsMjksbiwwLDEpfSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVTdXBlckFkYXB0ZXIvMSIsNDAzKTtmdW5jdGlvbiAkdGUoZSl7cmV0dXJuIWUuZUdlbmVyaWNUeXBlcyYmKGUuZUdlbmVyaWNUeXBlcz1uZXcgUkwobmV3IGdGKSksZS5lR2VuZXJpY1R5cGVzfWZ1bmN0aW9uIHBGKCl7fXAoNDU3LDQ0OCx7MTEwOjEsOTQ6MSw5MzoxLDE1NToxLDE5NzoxLDU4OjEsMTE0OjEsODUwOjEsNTQ6MSw5OToxLDE1ODoxLDQ1NzoxLDExOToxLDEyMDoxfSxwRiksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXt2YXIgbztzd2l0Y2gobil7Y2FzZSAwOnJldHVybiF0aGlzLmVBbm5vdGF0aW9ucyYmKHRoaXMuZUFubm90YXRpb25zPW5ldyBVKERuLHRoaXMsMCwzKSksdGhpcy5lQW5ub3RhdGlvbnM7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMDtjYXNlIDI6cmV0dXJuIXRoaXMuZUJvdW5kcyYmKHRoaXMuZUJvdW5kcz1uZXcgSVModGhpcyxLdCx0aGlzKSksdGhpcy5lQm91bmRzfXJldHVybiBsbCh0aGlzLG4tb24oKFBlKCksTGQpKSxrZSgobz1hKEJlKHRoaXMsMTYpLDI5KSxvfHxMZCksbikscix0KX0sbC5lSW52ZXJzZVJlbW92ZV8wPWZ1bmN0aW9uKG4scix0KXt2YXIgbyxpO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxEdCh0aGlzLmVBbm5vdGF0aW9ucyxuLHQpO2Nhc2UgMjpyZXR1cm4hdGhpcy5lQm91bmRzJiYodGhpcy5lQm91bmRzPW5ldyBJUyh0aGlzLEt0LHRoaXMpKSxEdCh0aGlzLmVCb3VuZHMsbix0KX1yZXR1cm4gaT1hKGtlKChvPWEoQmUodGhpcywxNiksMjkpLG98fChQZSgpLExkKSksciksNjkpLGkuZ2V0U2V0dGluZ0RlbGVnYXRlKCkuZHluYW1pY0ludmVyc2VSZW1vdmUodGhpcyxTaSh0aGlzKSxyLW9uKChQZSgpLExkKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMuZUFubm90YXRpb25zJiZ0aGlzLmVBbm5vdGF0aW9ucy5zaXplXzAhPTA7Y2FzZSAxOnJldHVybiB0aGlzLm5hbWVfMCE9bnVsbDtjYXNlIDI6cmV0dXJuISF0aGlzLmVCb3VuZHMmJnRoaXMuZUJvdW5kcy5zaXplXzAhPTB9cmV0dXJuIHNsKHRoaXMsbi1vbigoUGUoKSxMZCkpLGtlKChyPWEoQmUodGhpcywxNiksMjkpLHJ8fExkKSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3ZhciB0O3N3aXRjaChuKXtjYXNlIDA6IXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxmbih0aGlzLmVBbm5vdGF0aW9ucyksIXRoaXMuZUFubm90YXRpb25zJiYodGhpcy5lQW5ub3RhdGlvbnM9bmV3IFUoRG4sdGhpcywwLDMpKSxQcih0aGlzLmVBbm5vdGF0aW9ucyxhKHIsMTYpKTtyZXR1cm47Y2FzZSAxOmdpKHRoaXMseG4ocikpO3JldHVybjtjYXNlIDI6IXRoaXMuZUJvdW5kcyYmKHRoaXMuZUJvdW5kcz1uZXcgSVModGhpcyxLdCx0aGlzKSksZm4odGhpcy5lQm91bmRzKSwhdGhpcy5lQm91bmRzJiYodGhpcy5lQm91bmRzPW5ldyBJUyh0aGlzLEt0LHRoaXMpKSxQcih0aGlzLmVCb3VuZHMsYShyLDE2KSk7cmV0dXJufXVsKHRoaXMsbi1vbigoUGUoKSxMZCkpLGtlKCh0PWEoQmUodGhpcywxNiksMjkpLHR8fExkKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gUGUoKSxMZH0sbC5lVW5zZXQ9ZnVuY3Rpb24obil7dmFyIHI7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5lQW5ub3RhdGlvbnMmJih0aGlzLmVBbm5vdGF0aW9ucz1uZXcgVShEbix0aGlzLDAsMykpLGZuKHRoaXMuZUFubm90YXRpb25zKTtyZXR1cm47Y2FzZSAxOmdpKHRoaXMsbnVsbCk7cmV0dXJuO2Nhc2UgMjohdGhpcy5lQm91bmRzJiYodGhpcy5lQm91bmRzPW5ldyBJUyh0aGlzLEt0LHRoaXMpKSxmbih0aGlzLmVCb3VuZHMpO3JldHVybn1jbCh0aGlzLG4tb24oKFBlKCksTGQpKSxrZSgocj1hKEJlKHRoaXMsMTYpLDI5KSxyfHxMZCksbikpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVUeXBlUGFyYW1ldGVySW1wbCIsNDU3KTtmdW5jdGlvbiAkM24oZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKHI9KHU9bixobSh1LGUub3duZXIsLTEtZS5mZWF0dXJlSUQscikpLHM9JHRlKGUudGhpcyQwMSksaT0odD1uZXcgTF8obmV3IEFfKHMudGhpcyQxMSkudGhpcyQwMSksbmV3IERMKHQpKTtpLnZhbCRkZWxlZ2F0ZUl0ZXJhdG9yMi5oYXNOZXh0OylvPWEoTjEoaS52YWwkZGVsZWdhdGVJdGVyYXRvcjIpLmdldEtleSgpLDg5KSxyPWkyKG8sTkwobyxlLnRoaXMkMDEpLHIpO3JldHVybiByfWZ1bmN0aW9uIEIzbihlLG4scil7dmFyIHQsbyxpLHMsdTtmb3Iocj0odT1uLEFBKHUsZS5vd25lciwtMS1lLmZlYXR1cmVJRCxyKSkscz0kdGUoZS50aGlzJDAxKSxpPSh0PW5ldyBMXyhuZXcgQV8ocy50aGlzJDExKS50aGlzJDAxKSxuZXcgREwodCkpO2kudmFsJGRlbGVnYXRlSXRlcmF0b3IyLmhhc05leHQ7KW89YShOMShpLnZhbCRkZWxlZ2F0ZUl0ZXJhdG9yMikuZ2V0S2V5KCksODkpLHI9aTIobyxOTChvLGUudGhpcyQwMSkscik7cmV0dXJuIHJ9ZnVuY3Rpb24gSVMoZSxuLHIpe3RoaXMudGhpcyQwMT1lLGpyLmNhbGwodGhpcyxuLHIsMil9cCg0NTgsODMsRW8sSVMpLGwuaW52ZXJzZUFkZD1mdW5jdGlvbihuLHIpe3JldHVybiAkM24odGhpcyxhKG4sODkpLHIpfSxsLmludmVyc2VSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gQjNuKHRoaXMsYShuLDg5KSxyKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFVHlwZVBhcmFtZXRlckltcGwvMSIsNDU4KTtmdW5jdGlvbiBnRigpe3NuLmNhbGwodGhpcyl9cCg2NDcsNDUsaHAsZ0YpLGwua2V5U2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFJMKHRoaXMpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVUeXBlUGFyYW1ldGVySW1wbC8yIiw2NDcpO2Z1bmN0aW9uIGtXZShlLG4pe3JldHVybiBCbihlLnRoaXMkMTEsbiwiIik9PW51bGx9ZnVuY3Rpb24gT1dlKGUsbil7cmV0dXJuIHlpKGUudGhpcyQxMSxuKT8oaGgoZS50aGlzJDExLG4pLCEwKTohMX1mdW5jdGlvbiBSTChlKXt0aGlzLnRoaXMkMTE9ZX1wKDU3MCxTcyxEaSxSTCksbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4ga1dlKHRoaXMsYShuLDg5KSl9LGwuYWRkQWxsPWZ1bmN0aW9uKG4pe3ZhciByLHQsbztmb3Iobz0hMSx0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9YSh0Lm5leHRfMSgpLDg5KSxCbih0aGlzLnRoaXMkMTEsciwiIik9PW51bGwmJihvPSEwKTtyZXR1cm4gb30sbC5jbGVhcl8wPWZ1bmN0aW9uKCl7WmkodGhpcy50aGlzJDExKX0sbC5jb250YWlucz1mdW5jdGlvbihuKXtyZXR1cm4geWkodGhpcy50aGlzJDExLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj1uZXcgTF8obmV3IEFfKHRoaXMudGhpcyQxMSkudGhpcyQwMSksbmV3IERMKG4pfSxsLnJlbW92ZV8xPWZ1bmN0aW9uKG4pe3JldHVybiBPV2UodGhpcyxuKX0sbC5zaXplXzE9ZnVuY3Rpb24oKXtyZXR1cm4gVjIodGhpcy50aGlzJDExKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFVHlwZVBhcmFtZXRlckltcGwvMi8xIiw1NzApO2Z1bmN0aW9uIERMKGUpe3RoaXMudmFsJGRlbGVnYXRlSXRlcmF0b3IyPWV9cCg1NzEsMSxzdCxETCksbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIGEoTjEodGhpcy52YWwkZGVsZWdhdGVJdGVyYXRvcjIpLmdldEtleSgpLDg5KX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWwkZGVsZWdhdGVJdGVyYXRvcjIuaGFzTmV4dH0sbC5yZW1vdmU9ZnVuY3Rpb24oKXtXY2UodGhpcy52YWwkZGVsZWdhdGVJdGVyYXRvcjIpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVUeXBlUGFyYW1ldGVySW1wbC8yLzEvMSIsNTcxKTtmdW5jdGlvbiBNV2UoKXtzbi5jYWxsKHRoaXMpfXAoMTMyOSw0NSxocCxNV2UpLGwuY29udGFpbnNLZXk9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pP1Y1KHRoaXMsbik6ISFqdCh0aGlzLmhhc2hDb2RlTWFwLG4pfSxsLmdldF8zPWZ1bmN0aW9uKG4pe3ZhciByLHQ7cmV0dXJuIHI9dXQobik/bmkodGhpcyxuKTpfbyhqdCh0aGlzLmhhc2hDb2RlTWFwLG4pKSxMKHIsODUxKT8odD1hKHIsODUxKSxyPXQuZ2V0RVZhbGlkYXRvcigpLEJuKHRoaXMsYShuLDI0MSkscikscik6cj8/KG49PW51bGw/KFRGKCksYVZlKTpudWxsKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFVmFsaWRhdG9yUmVnaXN0cnlJbXBsIiwxMzI5KTtmdW5jdGlvbiBHM24oZSl7aWYoV0koInRydWUiLGUpKXJldHVybiB6ZSgpLG95O2lmKFdJKCJmYWxzZSIsZSkpcmV0dXJuIHplKCksUzA7dGhyb3cgYihuZXcgR2UoIkV4cGVjdGluZyB0cnVlIG9yIGZhbHNlIikpfWZ1bmN0aW9uIEgzbihlKXt2YXIgbjtyZXR1cm4gZT09bnVsbD9udWxsOihuPWEoZSwxOTUpLHl2bihuLG4ubGVuZ3RoKSl9ZnVuY3Rpb24gVTNuKGUpe3JldHVybiBMKGUsMTgwKT8iIithKGUsMTgwKS52YWx1ZV8wOmU9PW51bGw/bnVsbDp2byhlKX1mdW5jdGlvbiBXM24oZSl7cmV0dXJuIEwoZSwxODApPyIiK2EoZSwxODApLnZhbHVlXzA6ZT09bnVsbD9udWxsOnZvKGUpfWZ1bmN0aW9uIGozbihlKXt2YXIgbixyO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7cj0wO3RyeXtyPUFhKGUsYnQscW4pJnpyfWNhdGNoKHQpe2lmKHQ9d3IodCksTCh0LDEzMCkpbj1WSShlKSxyPW5bMF07ZWxzZSB0aHJvdyBiKHQpfXJldHVybiB2QyhyKX1mdW5jdGlvbiBWM24oZSl7dmFyIG4scjtpZihlPT1udWxsKXJldHVybiBudWxsO3I9MDt0cnl7cj1BYShlLGJ0LHFuKSZ6cn1jYXRjaCh0KXtpZih0PXdyKHQpLEwodCwxMzApKW49VkkoZSkscj1uWzBdO2Vsc2UgdGhyb3cgYih0KX1yZXR1cm4gdkMocil9ZnVuY3Rpb24gcTNuKGUpe3ZhciBuLHIsdDtpZihlPT1udWxsKXJldHVybiBudWxsO2ZvcihuPW51bGwscj0wO3I8dVMubGVuZ3RoOysrcil0cnl7cmV0dXJuIHhVZSh1U1tyXSxlKX1jYXRjaChvKXtpZihvPXdyKG8pLEwobywzMykpdD1vLG49dDtlbHNlIHRocm93IGIobyl9dGhyb3cgYihuZXcgZEwobikpfWZ1bmN0aW9uIFJXZSgpe31mdW5jdGlvbiBZM24oKXskQSgpO3ZhciBlLG47dHJ5e2lmKG49YShkdGUoKG5fKCksUGwpLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIiksMjA0MCksbilyZXR1cm4gbn1jYXRjaChyKXtpZihyPXdyKHIpLEwociwxMDMpKWU9cixscmUoKGJuKCksZSkpO2Vsc2UgdGhyb3cgYihyKX1yZXR1cm4gbmV3IFJXZX1wKDEzNDksNzIwLHsxMTA6MSw5NDoxLDkzOjEsNDgwOjEsMTU1OjEsNTg6MSwxMTQ6MSwyMDQwOjEsNTQ6MSw5OToxLDE1ODoxLDExOToxLDEyMDoxfSxSV2UpLGwuY29udmVydFRvU3RyaW5nPWZ1bmN0aW9uKG4scil7c3dpdGNoKG4uZ2V0Q2xhc3NpZmllcklEKCkpe2Nhc2UgMjE6Y2FzZSAyMjpjYXNlIDIzOmNhc2UgMjQ6Y2FzZSAyNjpjYXNlIDMxOmNhc2UgMzI6Y2FzZSAzNzpjYXNlIDM4OmNhc2UgMzk6Y2FzZSA0MDpjYXNlIDQzOmNhc2UgNDQ6Y2FzZSA0ODpjYXNlIDQ5OmNhc2UgMjA6cmV0dXJuIHI9PW51bGw/bnVsbDp2byhyKTtjYXNlIDI1OnJldHVybiBIM24ocik7Y2FzZSAyNzpyZXR1cm4gVTNuKHIpO2Nhc2UgMjg6cmV0dXJuIFczbihyKTtjYXNlIDI5OnJldHVybiByPT1udWxsP251bGw6SVVlKHVTWzBdLGEociwyMDYpKTtjYXNlIDQxOnJldHVybiByPT1udWxsPyIiOnlfKGEociwyOTcpKTtjYXNlIDQyOnJldHVybiB2byhyKTtjYXNlIDUwOnJldHVybiB4bihyKTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJUaGUgZGF0YXR5cGUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKX19LGwuY3JlYXRlXzM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHg7c3dpdGNoKG4ubWV0YU9iamVjdElEPT0tMSYmKG4ubWV0YU9iamVjdElEPShtPUhhKG4pLG0/czAobS5nZXRFQ2xhc3NpZmllcnMoKSxuKTotMSkpLG4ubWV0YU9iamVjdElEKXtjYXNlIDA6cmV0dXJuIHQ9bmV3IEJELHQ7Y2FzZSAxOnJldHVybiByPW5ldyBEcmUscjtjYXNlIDI6cmV0dXJuIG89bmV3IFZyZSxvO2Nhc2UgNDpyZXR1cm4gaT1uZXcgeEwsaTtjYXNlIDU6cmV0dXJuIHM9bmV3IFNVZSxzO2Nhc2UgNjpyZXR1cm4gdT1uZXcgYlVlLHU7Y2FzZSA3OnJldHVybiBjPW5ldyB5bmUsYztjYXNlIDEwOnJldHVybiBkPW5ldyBoTCxkO2Nhc2UgMTE6cmV0dXJuIGY9bmV3IGFGLGY7Y2FzZSAxMjpyZXR1cm4gaD1uZXcgQSRlLGg7Y2FzZSAxMzpyZXR1cm4geT1uZXcgc0YseTtjYXNlIDE0OnJldHVybiBFPW5ldyB5dGUsRTtjYXNlIDE3OnJldHVybiB2PW5ldyByV2UsdjtjYXNlIDE4OnJldHVybiBfPW5ldyBNZCxfO2Nhc2UgMTk6cmV0dXJuIHg9bmV3IHBGLHg7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiVGhlIGNsYXNzICciK24ubmFtZV8wKyInIGlzIG5vdCBhIHZhbGlkIGNsYXNzaWZpZXIiKSl9fSxsLmNyZWF0ZUZyb21TdHJpbmc9ZnVuY3Rpb24obixyKXtzd2l0Y2gobi5nZXRDbGFzc2lmaWVySUQoKSl7Y2FzZSAyMDpyZXR1cm4gcj09bnVsbD9udWxsOm5ldyBnQihyKTtjYXNlIDIxOnJldHVybiByPT1udWxsP251bGw6bmV3IFQwKHIpO2Nhc2UgMjM6Y2FzZSAyMjpyZXR1cm4gcj09bnVsbD9udWxsOkczbihyKTtjYXNlIDI2OmNhc2UgMjQ6cmV0dXJuIHI9PW51bGw/bnVsbDpFQyhBYShyLC0xMjgsMTI3KTw8MjQ+PjI0KTtjYXNlIDI1OnJldHVybiB3dm4ocik7Y2FzZSAyNzpyZXR1cm4gajNuKHIpO2Nhc2UgMjg6cmV0dXJuIFYzbihyKTtjYXNlIDI5OnJldHVybiBxM24ocik7Y2FzZSAzMjpjYXNlIDMxOnJldHVybiByPT1udWxsP251bGw6UWQocik7Y2FzZSAzODpjYXNlIDM3OnJldHVybiByPT1udWxsP251bGw6bmV3IHEkKHIpO2Nhc2UgNDA6Y2FzZSAzOTpyZXR1cm4gcj09bnVsbD9udWxsOkooQWEocixidCxxbikpO2Nhc2UgNDE6cmV0dXJuIG51bGw7Y2FzZSA0MjpyZXR1cm4gcj09bnVsbCxudWxsO2Nhc2UgNDQ6Y2FzZSA0MzpyZXR1cm4gcj09bnVsbD9udWxsOmVjKEhJKHIpKTtjYXNlIDQ5OmNhc2UgNDg6cmV0dXJuIHI9PW51bGw/bnVsbDpseShBYShyLEpiLDMyNzY3KTw8MTY+PjE2KTtjYXNlIDUwOnJldHVybiByO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIlRoZSBkYXRhdHlwZSAnIituLmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBjbGFzc2lmaWVyIikpfX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZUZhY3RvcnlJbXBsIiwxMzQ5KTtmdW5jdGlvbiBCdGUoKXtCdGU9RixIdGU9bmV3IFF9ZnVuY3Rpb24gSzNuKGUpe2UuZUF0dHJpYnV0ZUVDbGFzcz1udWxsLGUuZUFubm90YXRpb25FQ2xhc3M9bnVsbCxlLmVDbGFzc0VDbGFzcz1udWxsLGUuZURhdGFUeXBlRUNsYXNzPW51bGwsZS5lRW51bUVDbGFzcz1udWxsLGUuZUVudW1MaXRlcmFsRUNsYXNzPW51bGwsZS5lRmFjdG9yeUVDbGFzcz1udWxsLGUuZUNsYXNzaWZpZXJFQ2xhc3M9bnVsbCxlLmVNb2RlbEVsZW1lbnRFQ2xhc3M9bnVsbCxlLmVOYW1lZEVsZW1lbnRFQ2xhc3M9bnVsbCxlLmVPYmplY3RFQ2xhc3M9bnVsbCxlLmVPcGVyYXRpb25FQ2xhc3M9bnVsbCxlLmVQYWNrYWdlRUNsYXNzPW51bGwsZS5lUGFyYW1ldGVyRUNsYXNzPW51bGwsZS5lUmVmZXJlbmNlRUNsYXNzPW51bGwsZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3M9bnVsbCxlLmVUeXBlZEVsZW1lbnRFQ2xhc3M9bnVsbCxlLmVTdHJpbmdUb1N0cmluZ01hcEVudHJ5RUNsYXNzPW51bGwsZS5lR2VuZXJpY1R5cGVFQ2xhc3M9bnVsbCxlLmVUeXBlUGFyYW1ldGVyRUNsYXNzPW51bGwsZS5lQmlnRGVjaW1hbEVEYXRhVHlwZT1udWxsLGUuZUJpZ0ludGVnZXJFRGF0YVR5cGU9bnVsbCxlLmVCb29sZWFuT2JqZWN0RURhdGFUeXBlPW51bGwsZS5lQ2hhcmFjdGVyT2JqZWN0RURhdGFUeXBlPW51bGwsZS5lRGF0ZUVEYXRhVHlwZT1udWxsLGUuZURpYWdub3N0aWNDaGFpbkVEYXRhVHlwZT1udWxsLGUuZURvdWJsZU9iamVjdEVEYXRhVHlwZT1udWxsLGUuZUZsb2F0T2JqZWN0RURhdGFUeXBlPW51bGwsZS5lSW50ZWdlck9iamVjdEVEYXRhVHlwZT1udWxsLGUuZUJvb2xlYW5FRGF0YVR5cGU9bnVsbCxlLmVCeXRlT2JqZWN0RURhdGFUeXBlPW51bGwsZS5lQnl0ZUVEYXRhVHlwZT1udWxsLGUuZUJ5dGVBcnJheUVEYXRhVHlwZT1udWxsLGUuZUNoYXJFRGF0YVR5cGU9bnVsbCxlLmVEb3VibGVFRGF0YVR5cGU9bnVsbCxlLmVGbG9hdEVEYXRhVHlwZT1udWxsLGUuZUludEVEYXRhVHlwZT1udWxsLGUuZUphdmFDbGFzc0VEYXRhVHlwZT1udWxsLGUuZUphdmFPYmplY3RFRGF0YVR5cGU9bnVsbCxlLmVMb25nT2JqZWN0RURhdGFUeXBlPW51bGwsZS5lTWFwRURhdGFUeXBlPW51bGwsZS5lU2hvcnRPYmplY3RFRGF0YVR5cGU9bnVsbCxlLmVMb25nRURhdGFUeXBlPW51bGwsZS5lU2hvcnRFRGF0YVR5cGU9bnVsbCxlLmVUcmVlSXRlcmF0b3JFRGF0YVR5cGU9bnVsbCxlLmVJbnZvY2F0aW9uVGFyZ2V0RXhjZXB0aW9uRURhdGFUeXBlPW51bGwsZS5lRmVhdHVyZU1hcEVudHJ5RURhdGFUeXBlPW51bGwsZS5lRW51bWVyYXRvckVEYXRhVHlwZT1udWxsLGUuZUZlYXR1cmVNYXBFRGF0YVR5cGU9bnVsbCxlLmVTdHJpbmdFRGF0YVR5cGU9bnVsbCxlLmVlTGlzdEVEYXRhVHlwZT1udWxsLGUuZVJlc291cmNlRURhdGFUeXBlPW51bGwsZS5lUmVzb3VyY2VTZXRFRGF0YVR5cGU9bnVsbCxlLmlzQ3JlYXRlZD0hMSxlLmlzSW5pdGlhbGl6ZWQ9ITF9ZnVuY3Rpb24gR3RlKCl7dmFyIGUsbixyO3JldHVybiBuPShyPShlPW5ldyBNZCxlKSxyKSxlZShIdGUsbiksbn1mdW5jdGlvbiBYM24oZSl7RW4oZS5lQXR0cmlidXRlRUNsYXNzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIixQKEkoc2UsMSksWCwyLDYsWyJjb25zdHJhaW50cyIsIkNvbnNpc3RlbnRUcmFuc2llbnQiXSkpLEVuKGUuZUFubm90YXRpb25FQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiV2VsbEZvcm1lZFNvdXJjZVVSSSJdKSksRW4oZS5lQ2xhc3NFQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiSW50ZXJmYWNlSXNBYnN0cmFjdCBBdE1vc3RPbmVJRCBVbmlxdWVGZWF0dXJlTmFtZXMgVW5pcXVlT3BlcmF0aW9uU2lnbmF0dXJlcyBOb0NpcmN1bGFyU3VwZXJUeXBlcyBXZWxsRm9ybWVkTWFwRW50cnlDbGFzcyBDb25zaXN0ZW50U3VwZXJUeXBlcyBEaXNqb2ludEZlYXR1cmVBbmRPcGVyYXRpb25TaWduYXR1cmVzIl0pKSxFbihlLmVDbGFzc2lmaWVyRUNsYXNzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIixQKEkoc2UsMSksWCwyLDYsWyJjb25zdHJhaW50cyIsIldlbGxGb3JtZWRJbnN0YW5jZVR5cGVOYW1lIFVuaXF1ZVR5cGVQYXJhbWV0ZXJOYW1lcyJdKSksRW4oZS5lRW51bUVDbGFzcywiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMi9FY29yZSIsUChJKHNlLDEpLFgsMiw2LFsiY29uc3RyYWludHMiLCJVbmlxdWVFbnVtZXJhdG9yTmFtZXMgVW5pcXVlRW51bWVyYXRvckxpdGVyYWxzIl0pKSxFbihlLmVOYW1lZEVsZW1lbnRFQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiV2VsbEZvcm1lZE5hbWUiXSkpLEVuKGUuZU9wZXJhdGlvbkVDbGFzcywiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMi9FY29yZSIsUChJKHNlLDEpLFgsMiw2LFsiY29uc3RyYWludHMiLCJVbmlxdWVQYXJhbWV0ZXJOYW1lcyBVbmlxdWVUeXBlUGFyYW1ldGVyTmFtZXMgTm9SZXBlYXRpbmdWb2lkIl0pKSxFbihlLmVQYWNrYWdlRUNsYXNzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIixQKEkoc2UsMSksWCwyLDYsWyJjb25zdHJhaW50cyIsIldlbGxGb3JtZWROc1VSSSBXZWxsRm9ybWVkTnNQcmVmaXggVW5pcXVlU3VicGFja2FnZU5hbWVzIFVuaXF1ZUNsYXNzaWZpZXJOYW1lcyBVbmlxdWVOc1VSSXMiXSkpLEVuKGUuZVJlZmVyZW5jZUVDbGFzcywiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMi9FY29yZSIsUChJKHNlLDEpLFgsMiw2LFsiY29uc3RyYWludHMiLCJDb25zaXN0ZW50T3Bwb3NpdGUgU2luZ2xlQ29udGFpbmVyIENvbnNpc3RlbnRLZXlzIENvbnNpc3RlbnRVbmlxdWUgQ29uc2lzdGVudENvbnRhaW5lciJdKSksRW4oZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiVmFsaWREZWZhdWx0VmFsdWVMaXRlcmFsIl0pKSxFbihlLmVUeXBlZEVsZW1lbnRFQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiVmFsaWRMb3dlckJvdW5kIFZhbGlkVXBwZXJCb3VuZCBDb25zaXN0ZW50Qm91bmRzIFZhbGlkVHlwZSJdKSksRW4oZS5lR2VuZXJpY1R5cGVFQ2xhc3MsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLFAoSShzZSwxKSxYLDIsNixbImNvbnN0cmFpbnRzIiwiQ29uc2lzdGVudFR5cGUgQ29uc2lzdGVudEJvdW5kcyBDb25zaXN0ZW50QXJndW1lbnRzIl0pKX1mdW5jdGlvbiBKM24oZSl7RW4oZS5lQmlnRGVjaW1hbEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2RlY2ltYWwiXSkpLEVuKGUuZUJpZ0ludGVnZXJFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsiYmFzZVR5cGUiLCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNpbnRlZ2VyIl0pKSxFbihlLmVCb29sZWFuRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImJhc2VUeXBlIiwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjYm9vbGVhbiJdKSksRW4oZS5lQm9vbGVhbk9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsIkVCb29sZWFuIiwibmFtZSIsIkVCb29sZWFuOk9iamVjdCJdKSksRW4oZS5lQnl0ZUVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2J5dGUiXSkpLEVuKGUuZUJ5dGVBcnJheUVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2hleEJpbmFyeSJdKSksRW4oZS5lQnl0ZU9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsIkVCeXRlIiwibmFtZSIsIkVCeXRlOk9iamVjdCJdKSksRW4oZS5lQ2hhcmFjdGVyT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImJhc2VUeXBlIiwiRUNoYXIiLCJuYW1lIiwiRUNoYXI6T2JqZWN0Il0pKSxFbihlLmVEb3VibGVFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsiYmFzZVR5cGUiLCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNkb3VibGUiXSkpLEVuKGUuZURvdWJsZU9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsIkVEb3VibGUiLCJuYW1lIiwiRURvdWJsZTpPYmplY3QiXSkpLEVuKGUuZUZsb2F0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImJhc2VUeXBlIiwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjZmxvYXQiXSkpLEVuKGUuZUZsb2F0T2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImJhc2VUeXBlIiwiRUZsb2F0IiwibmFtZSIsIkVGbG9hdDpPYmplY3QiXSkpLEVuKGUuZUludEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI2ludCJdKSksRW4oZS5lSW50ZWdlck9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsIkVJbnQiLCJuYW1lIiwiRUludDpPYmplY3QiXSkpLEVuKGUuZUxvbmdFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsiYmFzZVR5cGUiLCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNsb25nIl0pKSxFbihlLmVMb25nT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImJhc2VUeXBlIiwiRUxvbmciLCJuYW1lIiwiRUxvbmc6T2JqZWN0Il0pKSxFbihlLmVTaG9ydEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI3Nob3J0Il0pKSxFbihlLmVTaG9ydE9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJiYXNlVHlwZSIsIkVTaG9ydCIsIm5hbWUiLCJFU2hvcnQ6T2JqZWN0Il0pKSxFbihlLmVTdHJpbmdFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsiYmFzZVR5cGUiLCJodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNzdHJpbmciXSkpfWZ1bmN0aW9uIFozbihlKXtlLmlzQ3JlYXRlZHx8KGUuaXNDcmVhdGVkPSEwLGUuZUF0dHJpYnV0ZUVDbGFzcz16byhlLDApLElyKGUuZUF0dHJpYnV0ZUVDbGFzcywxOCksZHIoZS5lQXR0cmlidXRlRUNsYXNzLDE5KSxlLmVBbm5vdGF0aW9uRUNsYXNzPXpvKGUsMSksSXIoZS5lQW5ub3RhdGlvbkVDbGFzcywxKSxkcihlLmVBbm5vdGF0aW9uRUNsYXNzLDIpLGRyKGUuZUFubm90YXRpb25FQ2xhc3MsMyksZHIoZS5lQW5ub3RhdGlvbkVDbGFzcyw0KSxkcihlLmVBbm5vdGF0aW9uRUNsYXNzLDUpLGUuZUNsYXNzRUNsYXNzPXpvKGUsMiksSXIoZS5lQ2xhc3NFQ2xhc3MsOCksSXIoZS5lQ2xhc3NFQ2xhc3MsOSksZHIoZS5lQ2xhc3NFQ2xhc3MsMTApLGRyKGUuZUNsYXNzRUNsYXNzLDExKSxkcihlLmVDbGFzc0VDbGFzcywxMiksZHIoZS5lQ2xhc3NFQ2xhc3MsMTMpLGRyKGUuZUNsYXNzRUNsYXNzLDE0KSxkcihlLmVDbGFzc0VDbGFzcywxNSksZHIoZS5lQ2xhc3NFQ2xhc3MsMTYpLGRyKGUuZUNsYXNzRUNsYXNzLDE3KSxkcihlLmVDbGFzc0VDbGFzcywxOCksZHIoZS5lQ2xhc3NFQ2xhc3MsMTkpLGRyKGUuZUNsYXNzRUNsYXNzLDIwKSxkcihlLmVDbGFzc0VDbGFzcywyMSksZHIoZS5lQ2xhc3NFQ2xhc3MsMjIpLGRyKGUuZUNsYXNzRUNsYXNzLDIzKSxzbyhlLmVDbGFzc0VDbGFzcyksc28oZS5lQ2xhc3NFQ2xhc3MpLHNvKGUuZUNsYXNzRUNsYXNzKSxzbyhlLmVDbGFzc0VDbGFzcyksc28oZS5lQ2xhc3NFQ2xhc3MpLHNvKGUuZUNsYXNzRUNsYXNzKSxzbyhlLmVDbGFzc0VDbGFzcyksc28oZS5lQ2xhc3NFQ2xhc3MpLHNvKGUuZUNsYXNzRUNsYXNzKSxzbyhlLmVDbGFzc0VDbGFzcyksZS5lQ2xhc3NpZmllckVDbGFzcz16byhlLDMpLElyKGUuZUNsYXNzaWZpZXJFQ2xhc3MsMiksSXIoZS5lQ2xhc3NpZmllckVDbGFzcywzKSxJcihlLmVDbGFzc2lmaWVyRUNsYXNzLDQpLElyKGUuZUNsYXNzaWZpZXJFQ2xhc3MsNSksZHIoZS5lQ2xhc3NpZmllckVDbGFzcyw2KSxkcihlLmVDbGFzc2lmaWVyRUNsYXNzLDcpLHNvKGUuZUNsYXNzaWZpZXJFQ2xhc3MpLHNvKGUuZUNsYXNzaWZpZXJFQ2xhc3MpLGUuZURhdGFUeXBlRUNsYXNzPXpvKGUsNCksSXIoZS5lRGF0YVR5cGVFQ2xhc3MsOCksZS5lRW51bUVDbGFzcz16byhlLDUpLGRyKGUuZUVudW1FQ2xhc3MsOSksc28oZS5lRW51bUVDbGFzcyksc28oZS5lRW51bUVDbGFzcyksc28oZS5lRW51bUVDbGFzcyksZS5lRW51bUxpdGVyYWxFQ2xhc3M9em8oZSw2KSxJcihlLmVFbnVtTGl0ZXJhbEVDbGFzcywyKSxJcihlLmVFbnVtTGl0ZXJhbEVDbGFzcywzKSxJcihlLmVFbnVtTGl0ZXJhbEVDbGFzcyw0KSxkcihlLmVFbnVtTGl0ZXJhbEVDbGFzcyw1KSxlLmVGYWN0b3J5RUNsYXNzPXpvKGUsNyksZHIoZS5lRmFjdG9yeUVDbGFzcywxKSxzbyhlLmVGYWN0b3J5RUNsYXNzKSxzbyhlLmVGYWN0b3J5RUNsYXNzKSxzbyhlLmVGYWN0b3J5RUNsYXNzKSxlLmVNb2RlbEVsZW1lbnRFQ2xhc3M9em8oZSw4KSxkcihlLmVNb2RlbEVsZW1lbnRFQ2xhc3MsMCksc28oZS5lTW9kZWxFbGVtZW50RUNsYXNzKSxlLmVOYW1lZEVsZW1lbnRFQ2xhc3M9em8oZSw5KSxJcihlLmVOYW1lZEVsZW1lbnRFQ2xhc3MsMSksZS5lT2JqZWN0RUNsYXNzPXpvKGUsMTApLHNvKGUuZU9iamVjdEVDbGFzcyksc28oZS5lT2JqZWN0RUNsYXNzKSxzbyhlLmVPYmplY3RFQ2xhc3MpLHNvKGUuZU9iamVjdEVDbGFzcyksc28oZS5lT2JqZWN0RUNsYXNzKSxzbyhlLmVPYmplY3RFQ2xhc3MpLHNvKGUuZU9iamVjdEVDbGFzcyksc28oZS5lT2JqZWN0RUNsYXNzKSxzbyhlLmVPYmplY3RFQ2xhc3MpLHNvKGUuZU9iamVjdEVDbGFzcyksc28oZS5lT2JqZWN0RUNsYXNzKSxzbyhlLmVPYmplY3RFQ2xhc3MpLHNvKGUuZU9iamVjdEVDbGFzcyksc28oZS5lT2JqZWN0RUNsYXNzKSxzbyhlLmVPYmplY3RFQ2xhc3MpLGUuZU9wZXJhdGlvbkVDbGFzcz16byhlLDExKSxkcihlLmVPcGVyYXRpb25FQ2xhc3MsMTApLGRyKGUuZU9wZXJhdGlvbkVDbGFzcywxMSksZHIoZS5lT3BlcmF0aW9uRUNsYXNzLDEyKSxkcihlLmVPcGVyYXRpb25FQ2xhc3MsMTMpLGRyKGUuZU9wZXJhdGlvbkVDbGFzcywxNCksc28oZS5lT3BlcmF0aW9uRUNsYXNzKSxzbyhlLmVPcGVyYXRpb25FQ2xhc3MpLGUuZVBhY2thZ2VFQ2xhc3M9em8oZSwxMiksSXIoZS5lUGFja2FnZUVDbGFzcywyKSxJcihlLmVQYWNrYWdlRUNsYXNzLDMpLGRyKGUuZVBhY2thZ2VFQ2xhc3MsNCksZHIoZS5lUGFja2FnZUVDbGFzcyw1KSxkcihlLmVQYWNrYWdlRUNsYXNzLDYpLGRyKGUuZVBhY2thZ2VFQ2xhc3MsNyksc28oZS5lUGFja2FnZUVDbGFzcyksZS5lUGFyYW1ldGVyRUNsYXNzPXpvKGUsMTMpLGRyKGUuZVBhcmFtZXRlckVDbGFzcywxMCksZS5lUmVmZXJlbmNlRUNsYXNzPXpvKGUsMTQpLElyKGUuZVJlZmVyZW5jZUVDbGFzcywxOCksSXIoZS5lUmVmZXJlbmNlRUNsYXNzLDE5KSxJcihlLmVSZWZlcmVuY2VFQ2xhc3MsMjApLGRyKGUuZVJlZmVyZW5jZUVDbGFzcywyMSksZHIoZS5lUmVmZXJlbmNlRUNsYXNzLDIyKSxkcihlLmVSZWZlcmVuY2VFQ2xhc3MsMjMpLGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzPXpvKGUsMTUpLElyKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLDEwKSxJcihlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywxMSksSXIoZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsMTIpLElyKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLDEzKSxJcihlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywxNCksSXIoZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsMTUpLElyKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLDE2KSxkcihlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywxNyksc28oZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLHNvKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSxlLmVUeXBlZEVsZW1lbnRFQ2xhc3M9em8oZSwxNiksSXIoZS5lVHlwZWRFbGVtZW50RUNsYXNzLDIpLElyKGUuZVR5cGVkRWxlbWVudEVDbGFzcywzKSxJcihlLmVUeXBlZEVsZW1lbnRFQ2xhc3MsNCksSXIoZS5lVHlwZWRFbGVtZW50RUNsYXNzLDUpLElyKGUuZVR5cGVkRWxlbWVudEVDbGFzcyw2KSxJcihlLmVUeXBlZEVsZW1lbnRFQ2xhc3MsNyksZHIoZS5lVHlwZWRFbGVtZW50RUNsYXNzLDgpLGRyKGUuZVR5cGVkRWxlbWVudEVDbGFzcyw5KSxlLmVTdHJpbmdUb1N0cmluZ01hcEVudHJ5RUNsYXNzPXpvKGUsMTcpLElyKGUuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MsMCksSXIoZS5lU3RyaW5nVG9TdHJpbmdNYXBFbnRyeUVDbGFzcywxKSxlLmVHZW5lcmljVHlwZUVDbGFzcz16byhlLDE4KSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcywwKSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcywxKSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcywyKSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcywzKSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcyw0KSxkcihlLmVHZW5lcmljVHlwZUVDbGFzcyw1KSxzbyhlLmVHZW5lcmljVHlwZUVDbGFzcyksZS5lVHlwZVBhcmFtZXRlckVDbGFzcz16byhlLDE5KSxkcihlLmVUeXBlUGFyYW1ldGVyRUNsYXNzLDIpLGUuZUJpZ0RlY2ltYWxFRGF0YVR5cGU9R24oZSwyMCksZS5lQmlnSW50ZWdlckVEYXRhVHlwZT1HbihlLDIxKSxlLmVCb29sZWFuRURhdGFUeXBlPUduKGUsMjIpLGUuZUJvb2xlYW5PYmplY3RFRGF0YVR5cGU9R24oZSwyMyksZS5lQnl0ZUVEYXRhVHlwZT1HbihlLDI0KSxlLmVCeXRlQXJyYXlFRGF0YVR5cGU9R24oZSwyNSksZS5lQnl0ZU9iamVjdEVEYXRhVHlwZT1HbihlLDI2KSxlLmVDaGFyRURhdGFUeXBlPUduKGUsMjcpLGUuZUNoYXJhY3Rlck9iamVjdEVEYXRhVHlwZT1HbihlLDI4KSxlLmVEYXRlRURhdGFUeXBlPUduKGUsMjkpLGUuZURpYWdub3N0aWNDaGFpbkVEYXRhVHlwZT1HbihlLDMwKSxlLmVEb3VibGVFRGF0YVR5cGU9R24oZSwzMSksZS5lRG91YmxlT2JqZWN0RURhdGFUeXBlPUduKGUsMzIpLGUuZWVMaXN0RURhdGFUeXBlPUduKGUsMzMpLGUuZUVudW1lcmF0b3JFRGF0YVR5cGU9R24oZSwzNCksZS5lRmVhdHVyZU1hcEVEYXRhVHlwZT1HbihlLDM1KSxlLmVGZWF0dXJlTWFwRW50cnlFRGF0YVR5cGU9R24oZSwzNiksZS5lRmxvYXRFRGF0YVR5cGU9R24oZSwzNyksZS5lRmxvYXRPYmplY3RFRGF0YVR5cGU9R24oZSwzOCksZS5lSW50RURhdGFUeXBlPUduKGUsMzkpLGUuZUludGVnZXJPYmplY3RFRGF0YVR5cGU9R24oZSw0MCksZS5lSmF2YUNsYXNzRURhdGFUeXBlPUduKGUsNDEpLGUuZUphdmFPYmplY3RFRGF0YVR5cGU9R24oZSw0MiksZS5lTG9uZ0VEYXRhVHlwZT1HbihlLDQzKSxlLmVMb25nT2JqZWN0RURhdGFUeXBlPUduKGUsNDQpLGUuZU1hcEVEYXRhVHlwZT1HbihlLDQ1KSxlLmVSZXNvdXJjZUVEYXRhVHlwZT1HbihlLDQ2KSxlLmVSZXNvdXJjZVNldEVEYXRhVHlwZT1HbihlLDQ3KSxlLmVTaG9ydEVEYXRhVHlwZT1HbihlLDQ4KSxlLmVTaG9ydE9iamVjdEVEYXRhVHlwZT1HbihlLDQ5KSxlLmVTdHJpbmdFRGF0YVR5cGU9R24oZSw1MCksZS5lVHJlZUl0ZXJhdG9yRURhdGFUeXBlPUduKGUsNTEpLGUuZUludm9jYXRpb25UYXJnZXRFeGNlcHRpb25FRGF0YVR5cGU9R24oZSw1MikpfWZ1bmN0aW9uIFEzbihlKXt2YXIgbixyLHQsbyxpLHMsdTtlLmlzSW5pdGlhbGl6ZWR8fChlLmlzSW5pdGlhbGl6ZWQ9ITAsZ2koZSwiZWNvcmUiKSxHQShlLCJlY29yZSIpLEhBKGUsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiKSx0YihlLmVlTGlzdEVEYXRhVHlwZSwiRSIpLHRiKGUuZUphdmFDbGFzc0VEYXRhVHlwZSwiVCIpLHRiKGUuZU1hcEVEYXRhVHlwZSwiSyIpLHRiKGUuZU1hcEVEYXRhVHlwZSwiViIpLHRiKGUuZVRyZWVJdGVyYXRvckVEYXRhVHlwZSwiRSIpLHBuKHdvKGUuZUF0dHJpYnV0ZUVDbGFzcyksZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLHBuKHdvKGUuZUFubm90YXRpb25FQ2xhc3MpLGUuZU1vZGVsRWxlbWVudEVDbGFzcykscG4od28oZS5lQ2xhc3NFQ2xhc3MpLGUuZUNsYXNzaWZpZXJFQ2xhc3MpLHBuKHdvKGUuZUNsYXNzaWZpZXJFQ2xhc3MpLGUuZU5hbWVkRWxlbWVudEVDbGFzcykscG4od28oZS5lRGF0YVR5cGVFQ2xhc3MpLGUuZUNsYXNzaWZpZXJFQ2xhc3MpLHBuKHdvKGUuZUVudW1FQ2xhc3MpLGUuZURhdGFUeXBlRUNsYXNzKSxwbih3byhlLmVFbnVtTGl0ZXJhbEVDbGFzcyksZS5lTmFtZWRFbGVtZW50RUNsYXNzKSxwbih3byhlLmVGYWN0b3J5RUNsYXNzKSxlLmVNb2RlbEVsZW1lbnRFQ2xhc3MpLHBuKHdvKGUuZU5hbWVkRWxlbWVudEVDbGFzcyksZS5lTW9kZWxFbGVtZW50RUNsYXNzKSxwbih3byhlLmVPcGVyYXRpb25FQ2xhc3MpLGUuZVR5cGVkRWxlbWVudEVDbGFzcykscG4od28oZS5lUGFja2FnZUVDbGFzcyksZS5lTmFtZWRFbGVtZW50RUNsYXNzKSxwbih3byhlLmVQYXJhbWV0ZXJFQ2xhc3MpLGUuZVR5cGVkRWxlbWVudEVDbGFzcykscG4od28oZS5lUmVmZXJlbmNlRUNsYXNzKSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcykscG4od28oZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLGUuZVR5cGVkRWxlbWVudEVDbGFzcykscG4od28oZS5lVHlwZWRFbGVtZW50RUNsYXNzKSxlLmVOYW1lZEVsZW1lbnRFQ2xhc3MpLHBuKHdvKGUuZVR5cGVQYXJhbWV0ZXJFQ2xhc3MpLGUuZU5hbWVkRWxlbWVudEVDbGFzcyksJG8oZS5lQXR0cmlidXRlRUNsYXNzLG5wLCJFQXR0cmlidXRlIiwhMSwhMSwhMCksT3IoYShPKEcoZS5lQXR0cmlidXRlRUNsYXNzKSwwKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwiaUQiLG51bGwsMCwxLG5wLCExLCExLCEwLCExLCEwLCExKSxmcihhKE8oRyhlLmVBdHRyaWJ1dGVFQ2xhc3MpLDEpLDE5KSxlLmVEYXRhVHlwZUVDbGFzcyxudWxsLCJlQXR0cmlidXRlVHlwZSIsMSwxLG5wLCEwLCEwLCExLCExLCEwLCExLCEwKSwkbyhlLmVBbm5vdGF0aW9uRUNsYXNzLERuLCJFQW5ub3RhdGlvbiIsITEsITEsITApLE9yKGEoTyhHKGUuZUFubm90YXRpb25FQ2xhc3MpLDApLDM1KSxlLmVTdHJpbmdFRGF0YVR5cGUsInNvdXJjZSIsbnVsbCwwLDEsRG4sITEsITEsITAsITEsITAsITEpLGZyKGEoTyhHKGUuZUFubm90YXRpb25FQ2xhc3MpLDEpLDE5KSxlLmVTdHJpbmdUb1N0cmluZ01hcEVudHJ5RUNsYXNzLG51bGwsImRldGFpbHMiLDAsLTEsRG4sITEsITEsITAsITAsITEsITEsITEpLGZyKGEoTyhHKGUuZUFubm90YXRpb25FQ2xhc3MpLDIpLDE5KSxlLmVNb2RlbEVsZW1lbnRFQ2xhc3MsYShPKEcoZS5lTW9kZWxFbGVtZW50RUNsYXNzKSwwKSwxOSksImVNb2RlbEVsZW1lbnQiLDAsMSxEbiwhMCwhMSwhMCwhMSwhMSwhMSwhMSksZnIoYShPKEcoZS5lQW5ub3RhdGlvbkVDbGFzcyksMyksMTkpLGUuZU9iamVjdEVDbGFzcyxudWxsLCJjb250ZW50cyIsMCwtMSxEbiwhMSwhMSwhMCwhMCwhMSwhMSwhMSksZnIoYShPKEcoZS5lQW5ub3RhdGlvbkVDbGFzcyksNCksMTkpLGUuZU9iamVjdEVDbGFzcyxudWxsLCJyZWZlcmVuY2VzIiwwLC0xLERuLCExLCExLCEwLCExLCEwLCExLCExKSwkbyhlLmVDbGFzc0VDbGFzcyxJbCwiRUNsYXNzIiwhMSwhMSwhMCksT3IoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDApLDM1KSxlLmVCb29sZWFuRURhdGFUeXBlLCJhYnN0cmFjdCIsbnVsbCwwLDEsSWwsITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwxKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwiaW50ZXJmYWNlIixudWxsLDAsMSxJbCwhMSwhMSwhMCwhMSwhMCwhMSksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDIpLDE5KSxlLmVDbGFzc0VDbGFzcyxudWxsLCJlU3VwZXJUeXBlcyIsMCwtMSxJbCwhMSwhMSwhMCwhMSwhMCwhMCwhMSksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDMpLDE5KSxlLmVPcGVyYXRpb25FQ2xhc3MsYShPKEcoZS5lT3BlcmF0aW9uRUNsYXNzKSwwKSwxOSksImVPcGVyYXRpb25zIiwwLC0xLElsLCExLCExLCEwLCEwLCExLCExLCExKSxmcihhKE8oRyhlLmVDbGFzc0VDbGFzcyksNCksMTkpLGUuZUF0dHJpYnV0ZUVDbGFzcyxudWxsLCJlQWxsQXR0cmlidXRlcyIsMCwtMSxJbCwhMCwhMCwhMSwhMSwhMCwhMSwhMCksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDUpLDE5KSxlLmVSZWZlcmVuY2VFQ2xhc3MsbnVsbCwiZUFsbFJlZmVyZW5jZXMiLDAsLTEsSWwsITAsITAsITEsITEsITAsITEsITApLGZyKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSw2KSwxOSksZS5lUmVmZXJlbmNlRUNsYXNzLG51bGwsImVSZWZlcmVuY2VzIiwwLC0xLElsLCEwLCEwLCExLCExLCEwLCExLCEwKSxmcihhKE8oRyhlLmVDbGFzc0VDbGFzcyksNyksMTkpLGUuZUF0dHJpYnV0ZUVDbGFzcyxudWxsLCJlQXR0cmlidXRlcyIsMCwtMSxJbCwhMCwhMCwhMSwhMSwhMCwhMSwhMCksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDgpLDE5KSxlLmVSZWZlcmVuY2VFQ2xhc3MsbnVsbCwiZUFsbENvbnRhaW5tZW50cyIsMCwtMSxJbCwhMCwhMCwhMSwhMSwhMCwhMSwhMCksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDkpLDE5KSxlLmVPcGVyYXRpb25FQ2xhc3MsbnVsbCwiZUFsbE9wZXJhdGlvbnMiLDAsLTEsSWwsITAsITAsITEsITEsITAsITEsITApLGZyKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwxMCksMTkpLGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLG51bGwsImVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXMiLDAsLTEsSWwsITAsITAsITEsITEsITAsITEsITApLGZyKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwxMSksMTkpLGUuZUNsYXNzRUNsYXNzLG51bGwsImVBbGxTdXBlclR5cGVzIiwwLC0xLElsLCEwLCEwLCExLCExLCEwLCExLCEwKSxmcihhKE8oRyhlLmVDbGFzc0VDbGFzcyksMTIpLDE5KSxlLmVBdHRyaWJ1dGVFQ2xhc3MsbnVsbCwiZUlEQXR0cmlidXRlIiwwLDEsSWwsITAsITAsITEsITEsITEsITEsITApLGZyKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwxMyksMTkpLGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSw3KSwxOSksImVTdHJ1Y3R1cmFsRmVhdHVyZXMiLDAsLTEsSWwsITEsITEsITAsITAsITEsITEsITEpLGZyKGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwxNCksMTkpLGUuZUdlbmVyaWNUeXBlRUNsYXNzLG51bGwsImVHZW5lcmljU3VwZXJUeXBlcyIsMCwtMSxJbCwhMSwhMSwhMCwhMCwhMSwhMCwhMSksZnIoYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDE1KSwxOSksZS5lR2VuZXJpY1R5cGVFQ2xhc3MsbnVsbCwiZUFsbEdlbmVyaWNTdXBlclR5cGVzIiwwLC0xLElsLCEwLCEwLCExLCExLCEwLCExLCEwKSx1PWVvKGEoTyhlcihlLmVDbGFzc0VDbGFzcyksMCksNjIpLGUuZUJvb2xlYW5FRGF0YVR5cGUsImlzU3VwZXJUeXBlT2YiKSxsbyh1LGUuZUNsYXNzRUNsYXNzLCJzb21lQ2xhc3MiKSxlbyhhKE8oZXIoZS5lQ2xhc3NFQ2xhc3MpLDEpLDYyKSxlLmVJbnRFRGF0YVR5cGUsImdldEZlYXR1cmVDb3VudCIpLHU9ZW8oYShPKGVyKGUuZUNsYXNzRUNsYXNzKSwyKSw2MiksZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsImdldEVTdHJ1Y3R1cmFsRmVhdHVyZSIpLGxvKHUsZS5lSW50RURhdGFUeXBlLCJmZWF0dXJlSUQiKSx1PWVvKGEoTyhlcihlLmVDbGFzc0VDbGFzcyksMyksNjIpLGUuZUludEVEYXRhVHlwZSwiZ2V0RmVhdHVyZUlEIiksbG8odSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywiZmVhdHVyZSIpLHU9ZW8oYShPKGVyKGUuZUNsYXNzRUNsYXNzKSw0KSw2MiksZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsImdldEVTdHJ1Y3R1cmFsRmVhdHVyZSIpLGxvKHUsZS5lU3RyaW5nRURhdGFUeXBlLCJmZWF0dXJlTmFtZSIpLGVvKGEoTyhlcihlLmVDbGFzc0VDbGFzcyksNSksNjIpLGUuZUludEVEYXRhVHlwZSwiZ2V0T3BlcmF0aW9uQ291bnQiKSx1PWVvKGEoTyhlcihlLmVDbGFzc0VDbGFzcyksNiksNjIpLGUuZU9wZXJhdGlvbkVDbGFzcywiZ2V0RU9wZXJhdGlvbiIpLGxvKHUsZS5lSW50RURhdGFUeXBlLCJvcGVyYXRpb25JRCIpLHU9ZW8oYShPKGVyKGUuZUNsYXNzRUNsYXNzKSw3KSw2MiksZS5lSW50RURhdGFUeXBlLCJnZXRPcGVyYXRpb25JRCIpLGxvKHUsZS5lT3BlcmF0aW9uRUNsYXNzLCJvcGVyYXRpb24iKSx1PWVvKGEoTyhlcihlLmVDbGFzc0VDbGFzcyksOCksNjIpLGUuZU9wZXJhdGlvbkVDbGFzcywiZ2V0T3ZlcnJpZGUiKSxsbyh1LGUuZU9wZXJhdGlvbkVDbGFzcywib3BlcmF0aW9uIiksdT1lbyhhKE8oZXIoZS5lQ2xhc3NFQ2xhc3MpLDkpLDYyKSxlLmVHZW5lcmljVHlwZUVDbGFzcywiZ2V0RmVhdHVyZVR5cGUiKSxsbyh1LGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLCJmZWF0dXJlIiksJG8oZS5lQ2xhc3NpZmllckVDbGFzcyxFcywiRUNsYXNzaWZpZXIiLCEwLCExLCEwKSxPcihhKE8oRyhlLmVDbGFzc2lmaWVyRUNsYXNzKSwwKSwzNSksZS5lU3RyaW5nRURhdGFUeXBlLCJpbnN0YW5jZUNsYXNzTmFtZSIsbnVsbCwwLDEsRXMsITEsITAsITAsITAsITAsITEpLG49bWMoZS5lSmF2YUNsYXNzRURhdGFUeXBlKSxyPUd0ZSgpLHBuKCghbi5lVHlwZUFyZ3VtZW50cyYmKG4uZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LG4sMSkpLG4uZVR5cGVBcmd1bWVudHMpLHIpLHgkZShhKE8oRyhlLmVDbGFzc2lmaWVyRUNsYXNzKSwxKSwzNSksbiwiaW5zdGFuY2VDbGFzcyIsRXMsITAsITAsITEsITApLE9yKGEoTyhHKGUuZUNsYXNzaWZpZXJFQ2xhc3MpLDIpLDM1KSxlLmVKYXZhT2JqZWN0RURhdGFUeXBlLCJkZWZhdWx0VmFsdWUiLG51bGwsMCwxLEVzLCEwLCEwLCExLCExLCEwLCEwKSxPcihhKE8oRyhlLmVDbGFzc2lmaWVyRUNsYXNzKSwzKSwzNSksZS5lU3RyaW5nRURhdGFUeXBlLCJpbnN0YW5jZVR5cGVOYW1lIixudWxsLDAsMSxFcywhMSwhMCwhMCwhMCwhMCwhMSksZnIoYShPKEcoZS5lQ2xhc3NpZmllckVDbGFzcyksNCksMTkpLGUuZVBhY2thZ2VFQ2xhc3MsYShPKEcoZS5lUGFja2FnZUVDbGFzcyksMyksMTkpLCJlUGFja2FnZSIsMCwxLEVzLCEwLCExLCExLCExLCEwLCExLCExKSxmcihhKE8oRyhlLmVDbGFzc2lmaWVyRUNsYXNzKSw1KSwxOSksZS5lVHlwZVBhcmFtZXRlckVDbGFzcyxudWxsLCJlVHlwZVBhcmFtZXRlcnMiLDAsLTEsRXMsITEsITEsITAsITAsITAsITEsITEpLHU9ZW8oYShPKGVyKGUuZUNsYXNzaWZpZXJFQ2xhc3MpLDApLDYyKSxlLmVCb29sZWFuRURhdGFUeXBlLCJpc0luc3RhbmNlIiksbG8odSxlLmVKYXZhT2JqZWN0RURhdGFUeXBlLCJvYmplY3QiKSxlbyhhKE8oZXIoZS5lQ2xhc3NpZmllckVDbGFzcyksMSksNjIpLGUuZUludEVEYXRhVHlwZSwiZ2V0Q2xhc3NpZmllcklEIiksJG8oZS5lRGF0YVR5cGVFQ2xhc3MsTUQsIkVEYXRhVHlwZSIsITEsITEsITApLE9yKGEoTyhHKGUuZURhdGFUeXBlRUNsYXNzKSwwKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwic2VyaWFsaXphYmxlIiwidHJ1ZSIsMCwxLE1ELCExLCExLCEwLCExLCEwLCExKSwkbyhlLmVFbnVtRUNsYXNzLGZMLCJFRW51bSIsITEsITEsITApLGZyKGEoTyhHKGUuZUVudW1FQ2xhc3MpLDApLDE5KSxlLmVFbnVtTGl0ZXJhbEVDbGFzcyxhKE8oRyhlLmVFbnVtTGl0ZXJhbEVDbGFzcyksMyksMTkpLCJlTGl0ZXJhbHMiLDAsLTEsZkwsITEsITEsITAsITAsITEsITEsITEpLHU9ZW8oYShPKGVyKGUuZUVudW1FQ2xhc3MpLDApLDYyKSxlLmVFbnVtTGl0ZXJhbEVDbGFzcywiZ2V0RUVudW1MaXRlcmFsIiksbG8odSxlLmVTdHJpbmdFRGF0YVR5cGUsIm5hbWUiKSx1PWVvKGEoTyhlcihlLmVFbnVtRUNsYXNzKSwxKSw2MiksZS5lRW51bUxpdGVyYWxFQ2xhc3MsImdldEVFbnVtTGl0ZXJhbCIpLGxvKHUsZS5lSW50RURhdGFUeXBlLCJ2YWx1ZSIpLHU9ZW8oYShPKGVyKGUuZUVudW1FQ2xhc3MpLDIpLDYyKSxlLmVFbnVtTGl0ZXJhbEVDbGFzcywiZ2V0RUVudW1MaXRlcmFsQnlMaXRlcmFsIiksbG8odSxlLmVTdHJpbmdFRGF0YVR5cGUsImxpdGVyYWwiKSwkbyhlLmVFbnVtTGl0ZXJhbEVDbGFzcyx2YywiRUVudW1MaXRlcmFsIiwhMSwhMSwhMCksT3IoYShPKEcoZS5lRW51bUxpdGVyYWxFQ2xhc3MpLDApLDM1KSxlLmVJbnRFRGF0YVR5cGUsInZhbHVlIixudWxsLDAsMSx2YywhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lRW51bUxpdGVyYWxFQ2xhc3MpLDEpLDM1KSxlLmVFbnVtZXJhdG9yRURhdGFUeXBlLCJpbnN0YW5jZSIsbnVsbCwwLDEsdmMsITAsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZUVudW1MaXRlcmFsRUNsYXNzKSwyKSwzNSksZS5lU3RyaW5nRURhdGFUeXBlLCJsaXRlcmFsIixudWxsLDAsMSx2YywhMSwhMSwhMCwhMSwhMCwhMSksZnIoYShPKEcoZS5lRW51bUxpdGVyYWxFQ2xhc3MpLDMpLDE5KSxlLmVFbnVtRUNsYXNzLGEoTyhHKGUuZUVudW1FQ2xhc3MpLDApLDE5KSwiZUVudW0iLDAsMSx2YywhMCwhMSwhMSwhMSwhMSwhMSwhMSksJG8oZS5lRmFjdG9yeUVDbGFzcyxhUywiRUZhY3RvcnkiLCExLCExLCEwKSxmcihhKE8oRyhlLmVGYWN0b3J5RUNsYXNzKSwwKSwxOSksZS5lUGFja2FnZUVDbGFzcyxhKE8oRyhlLmVQYWNrYWdlRUNsYXNzKSwyKSwxOSksImVQYWNrYWdlIiwxLDEsYVMsITAsITEsITAsITEsITEsITEsITEpLHU9ZW8oYShPKGVyKGUuZUZhY3RvcnlFQ2xhc3MpLDApLDYyKSxlLmVPYmplY3RFQ2xhc3MsImNyZWF0ZSIpLGxvKHUsZS5lQ2xhc3NFQ2xhc3MsImVDbGFzcyIpLHU9ZW8oYShPKGVyKGUuZUZhY3RvcnlFQ2xhc3MpLDEpLDYyKSxlLmVKYXZhT2JqZWN0RURhdGFUeXBlLCJjcmVhdGVGcm9tU3RyaW5nIiksbG8odSxlLmVEYXRhVHlwZUVDbGFzcywiZURhdGFUeXBlIiksbG8odSxlLmVTdHJpbmdFRGF0YVR5cGUsImxpdGVyYWxWYWx1ZSIpLHU9ZW8oYShPKGVyKGUuZUZhY3RvcnlFQ2xhc3MpLDIpLDYyKSxlLmVTdHJpbmdFRGF0YVR5cGUsImNvbnZlcnRUb1N0cmluZyIpLGxvKHUsZS5lRGF0YVR5cGVFQ2xhc3MsImVEYXRhVHlwZSIpLGxvKHUsZS5lSmF2YU9iamVjdEVEYXRhVHlwZSwiaW5zdGFuY2VWYWx1ZSIpLCRvKGUuZU1vZGVsRWxlbWVudEVDbGFzcyxKVCwiRU1vZGVsRWxlbWVudCIsITAsITEsITApLGZyKGEoTyhHKGUuZU1vZGVsRWxlbWVudEVDbGFzcyksMCksMTkpLGUuZUFubm90YXRpb25FQ2xhc3MsYShPKEcoZS5lQW5ub3RhdGlvbkVDbGFzcyksMiksMTkpLCJlQW5ub3RhdGlvbnMiLDAsLTEsSlQsITEsITEsITAsITAsITEsITEsITEpLHU9ZW8oYShPKGVyKGUuZU1vZGVsRWxlbWVudEVDbGFzcyksMCksNjIpLGUuZUFubm90YXRpb25FQ2xhc3MsImdldEVBbm5vdGF0aW9uIiksbG8odSxlLmVTdHJpbmdFRGF0YVR5cGUsInNvdXJjZSIpLCRvKGUuZU5hbWVkRWxlbWVudEVDbGFzcyxPUiwiRU5hbWVkRWxlbWVudCIsITAsITEsITApLE9yKGEoTyhHKGUuZU5hbWVkRWxlbWVudEVDbGFzcyksMCksMzUpLGUuZVN0cmluZ0VEYXRhVHlwZSwibmFtZSIsbnVsbCwwLDEsT1IsITEsITEsITAsITEsITAsITEpLCRvKGUuZU9iamVjdEVDbGFzcyxLMCwiRU9iamVjdCIsITEsITEsITApLGVvKGEoTyhlcihlLmVPYmplY3RFQ2xhc3MpLDApLDYyKSxlLmVDbGFzc0VDbGFzcywiZUNsYXNzIiksZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksMSksNjIpLGUuZUJvb2xlYW5FRGF0YVR5cGUsImVJc1Byb3h5IiksZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksMiksNjIpLGUuZVJlc291cmNlRURhdGFUeXBlLCJlUmVzb3VyY2UiKSxlbyhhKE8oZXIoZS5lT2JqZWN0RUNsYXNzKSwzKSw2MiksZS5lT2JqZWN0RUNsYXNzLCJlQ29udGFpbmVyIiksZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksNCksNjIpLGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLCJlQ29udGFpbmluZ0ZlYXR1cmUiKSxlbyhhKE8oZXIoZS5lT2JqZWN0RUNsYXNzKSw1KSw2MiksZS5lUmVmZXJlbmNlRUNsYXNzLCJlQ29udGFpbm1lbnRGZWF0dXJlIiksdT1lbyhhKE8oZXIoZS5lT2JqZWN0RUNsYXNzKSw2KSw2MiksbnVsbCwiZUNvbnRlbnRzIiksbj1tYyhlLmVlTGlzdEVEYXRhVHlwZSkscj1tYyhlLmVPYmplY3RFQ2xhc3MpLHBuKCghbi5lVHlwZUFyZ3VtZW50cyYmKG4uZVR5cGVBcmd1bWVudHM9bmV3IGpyKEt0LG4sMSkpLG4uZVR5cGVBcmd1bWVudHMpLHIpLG89cXModSxuLG51bGwpLG8mJm8uZGlzcGF0Y2hfMCgpLHU9ZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksNyksNjIpLG51bGwsImVBbGxDb250ZW50cyIpLG49bWMoZS5lVHJlZUl0ZXJhdG9yRURhdGFUeXBlKSxyPW1jKGUuZU9iamVjdEVDbGFzcykscG4oKCFuLmVUeXBlQXJndW1lbnRzJiYobi5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsbiwxKSksbi5lVHlwZUFyZ3VtZW50cyksciksaT1xcyh1LG4sbnVsbCksaSYmaS5kaXNwYXRjaF8wKCksdT1lbyhhKE8oZXIoZS5lT2JqZWN0RUNsYXNzKSw4KSw2MiksbnVsbCwiZUNyb3NzUmVmZXJlbmNlcyIpLG49bWMoZS5lZUxpc3RFRGF0YVR5cGUpLHI9bWMoZS5lT2JqZWN0RUNsYXNzKSxwbigoIW4uZVR5cGVBcmd1bWVudHMmJihuLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxuLDEpKSxuLmVUeXBlQXJndW1lbnRzKSxyKSxzPXFzKHUsbixudWxsKSxzJiZzLmRpc3BhdGNoXzAoKSx1PWVvKGEoTyhlcihlLmVPYmplY3RFQ2xhc3MpLDkpLDYyKSxlLmVKYXZhT2JqZWN0RURhdGFUeXBlLCJlR2V0IiksbG8odSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywiZmVhdHVyZSIpLHU9ZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksMTApLDYyKSxlLmVKYXZhT2JqZWN0RURhdGFUeXBlLCJlR2V0IiksbG8odSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywiZmVhdHVyZSIpLGxvKHUsZS5lQm9vbGVhbkVEYXRhVHlwZSwicmVzb2x2ZSIpLHU9ZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksMTEpLDYyKSxudWxsLCJlU2V0IiksbG8odSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywiZmVhdHVyZSIpLGxvKHUsZS5lSmF2YU9iamVjdEVEYXRhVHlwZSwibmV3VmFsdWUiKSx1PWVvKGEoTyhlcihlLmVPYmplY3RFQ2xhc3MpLDEyKSw2MiksZS5lQm9vbGVhbkVEYXRhVHlwZSwiZUlzU2V0IiksbG8odSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcywiZmVhdHVyZSIpLHU9ZW8oYShPKGVyKGUuZU9iamVjdEVDbGFzcyksMTMpLDYyKSxudWxsLCJlVW5zZXQiKSxsbyh1LGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzLCJmZWF0dXJlIiksdT1lbyhhKE8oZXIoZS5lT2JqZWN0RUNsYXNzKSwxNCksNjIpLGUuZUphdmFPYmplY3RFRGF0YVR5cGUsImVJbnZva2UiKSxsbyh1LGUuZU9wZXJhdGlvbkVDbGFzcywib3BlcmF0aW9uIiksbj1tYyhlLmVlTGlzdEVEYXRhVHlwZSkscj1HdGUoKSxwbigoIW4uZVR5cGVBcmd1bWVudHMmJihuLmVUeXBlQXJndW1lbnRzPW5ldyBqcihLdCxuLDEpKSxuLmVUeXBlQXJndW1lbnRzKSxyKSxCQSh1LG4sImFyZ3VtZW50cyIpLHZ2bih1LGUuZUludm9jYXRpb25UYXJnZXRFeGNlcHRpb25FRGF0YVR5cGUpLCRvKGUuZU9wZXJhdGlvbkVDbGFzcyx4bCwiRU9wZXJhdGlvbiIsITEsITEsITApLGZyKGEoTyhHKGUuZU9wZXJhdGlvbkVDbGFzcyksMCksMTkpLGUuZUNsYXNzRUNsYXNzLGEoTyhHKGUuZUNsYXNzRUNsYXNzKSwzKSwxOSksImVDb250YWluaW5nQ2xhc3MiLDAsMSx4bCwhMCwhMSwhMSwhMSwhMSwhMSwhMSksZnIoYShPKEcoZS5lT3BlcmF0aW9uRUNsYXNzKSwxKSwxOSksZS5lVHlwZVBhcmFtZXRlckVDbGFzcyxudWxsLCJlVHlwZVBhcmFtZXRlcnMiLDAsLTEseGwsITEsITEsITAsITAsITAsITEsITEpLGZyKGEoTyhHKGUuZU9wZXJhdGlvbkVDbGFzcyksMiksMTkpLGUuZVBhcmFtZXRlckVDbGFzcyxhKE8oRyhlLmVQYXJhbWV0ZXJFQ2xhc3MpLDApLDE5KSwiZVBhcmFtZXRlcnMiLDAsLTEseGwsITEsITEsITAsITAsITEsITEsITEpLGZyKGEoTyhHKGUuZU9wZXJhdGlvbkVDbGFzcyksMyksMTkpLGUuZUNsYXNzaWZpZXJFQ2xhc3MsbnVsbCwiZUV4Y2VwdGlvbnMiLDAsLTEseGwsITEsITEsITAsITEsITAsITAsITEpLGZyKGEoTyhHKGUuZU9wZXJhdGlvbkVDbGFzcyksNCksMTkpLGUuZUdlbmVyaWNUeXBlRUNsYXNzLG51bGwsImVHZW5lcmljRXhjZXB0aW9ucyIsMCwtMSx4bCwhMSwhMSwhMCwhMCwhMSwhMCwhMSksZW8oYShPKGVyKGUuZU9wZXJhdGlvbkVDbGFzcyksMCksNjIpLGUuZUludEVEYXRhVHlwZSwiZ2V0T3BlcmF0aW9uSUQiKSx1PWVvKGEoTyhlcihlLmVPcGVyYXRpb25FQ2xhc3MpLDEpLDYyKSxlLmVCb29sZWFuRURhdGFUeXBlLCJpc092ZXJyaWRlT2YiKSxsbyh1LGUuZU9wZXJhdGlvbkVDbGFzcywic29tZU9wZXJhdGlvbiIpLCRvKGUuZVBhY2thZ2VFQ2xhc3MseXMsIkVQYWNrYWdlIiwhMSwhMSwhMCksT3IoYShPKEcoZS5lUGFja2FnZUVDbGFzcyksMCksMzUpLGUuZVN0cmluZ0VEYXRhVHlwZSwibnNVUkkiLG51bGwsMCwxLHlzLCExLCExLCEwLCExLCEwLCExKSxPcihhKE8oRyhlLmVQYWNrYWdlRUNsYXNzKSwxKSwzNSksZS5lU3RyaW5nRURhdGFUeXBlLCJuc1ByZWZpeCIsbnVsbCwwLDEseXMsITEsITEsITAsITEsITAsITEpLGZyKGEoTyhHKGUuZVBhY2thZ2VFQ2xhc3MpLDIpLDE5KSxlLmVGYWN0b3J5RUNsYXNzLGEoTyhHKGUuZUZhY3RvcnlFQ2xhc3MpLDApLDE5KSwiZUZhY3RvcnlJbnN0YW5jZSIsMSwxLHlzLCEwLCExLCEwLCExLCExLCExLCExKSxmcihhKE8oRyhlLmVQYWNrYWdlRUNsYXNzKSwzKSwxOSksZS5lQ2xhc3NpZmllckVDbGFzcyxhKE8oRyhlLmVDbGFzc2lmaWVyRUNsYXNzKSw0KSwxOSksImVDbGFzc2lmaWVycyIsMCwtMSx5cywhMSwhMSwhMCwhMCwhMCwhMSwhMSksZnIoYShPKEcoZS5lUGFja2FnZUVDbGFzcyksNCksMTkpLGUuZVBhY2thZ2VFQ2xhc3MsYShPKEcoZS5lUGFja2FnZUVDbGFzcyksNSksMTkpLCJlU3VicGFja2FnZXMiLDAsLTEseXMsITEsITEsITAsITAsITAsITEsITEpLGZyKGEoTyhHKGUuZVBhY2thZ2VFQ2xhc3MpLDUpLDE5KSxlLmVQYWNrYWdlRUNsYXNzLGEoTyhHKGUuZVBhY2thZ2VFQ2xhc3MpLDQpLDE5KSwiZVN1cGVyUGFja2FnZSIsMCwxLHlzLCEwLCExLCExLCExLCEwLCExLCExKSx1PWVvKGEoTyhlcihlLmVQYWNrYWdlRUNsYXNzKSwwKSw2MiksZS5lQ2xhc3NpZmllckVDbGFzcywiZ2V0RUNsYXNzaWZpZXIiKSxsbyh1LGUuZVN0cmluZ0VEYXRhVHlwZSwibmFtZSIpLCRvKGUuZVBhcmFtZXRlckVDbGFzcyxOZCwiRVBhcmFtZXRlciIsITEsITEsITApLGZyKGEoTyhHKGUuZVBhcmFtZXRlckVDbGFzcyksMCksMTkpLGUuZU9wZXJhdGlvbkVDbGFzcyxhKE8oRyhlLmVPcGVyYXRpb25FQ2xhc3MpLDIpLDE5KSwiZU9wZXJhdGlvbiIsMCwxLE5kLCEwLCExLCExLCExLCExLCExLCExKSwkbyhlLmVSZWZlcmVuY2VFQ2xhc3MscnAsIkVSZWZlcmVuY2UiLCExLCExLCEwKSxPcihhKE8oRyhlLmVSZWZlcmVuY2VFQ2xhc3MpLDApLDM1KSxlLmVCb29sZWFuRURhdGFUeXBlLCJjb250YWlubWVudCIsbnVsbCwwLDEscnAsITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZVJlZmVyZW5jZUVDbGFzcyksMSksMzUpLGUuZUJvb2xlYW5FRGF0YVR5cGUsImNvbnRhaW5lciIsbnVsbCwwLDEscnAsITAsITAsITEsITEsITAsITApLE9yKGEoTyhHKGUuZVJlZmVyZW5jZUVDbGFzcyksMiksMzUpLGUuZUJvb2xlYW5FRGF0YVR5cGUsInJlc29sdmVQcm94aWVzIiwidHJ1ZSIsMCwxLHJwLCExLCExLCEwLCExLCEwLCExKSxmcihhKE8oRyhlLmVSZWZlcmVuY2VFQ2xhc3MpLDMpLDE5KSxlLmVSZWZlcmVuY2VFQ2xhc3MsbnVsbCwiZU9wcG9zaXRlIiwwLDEscnAsITEsITEsITAsITEsITAsITEsITEpLGZyKGEoTyhHKGUuZVJlZmVyZW5jZUVDbGFzcyksNCksMTkpLGUuZUNsYXNzRUNsYXNzLG51bGwsImVSZWZlcmVuY2VUeXBlIiwxLDEscnAsITAsITAsITEsITEsITAsITEsITApLGZyKGEoTyhHKGUuZVJlZmVyZW5jZUVDbGFzcyksNSksMTkpLGUuZUF0dHJpYnV0ZUVDbGFzcyxudWxsLCJlS2V5cyIsMCwtMSxycCwhMSwhMSwhMCwhMSwhMCwhMSwhMSksJG8oZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MsUmksIkVTdHJ1Y3R1cmFsRmVhdHVyZSIsITAsITEsITApLE9yKGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSwwKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwiY2hhbmdlYWJsZSIsInRydWUiLDAsMSxSaSwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDEpLDM1KSxlLmVCb29sZWFuRURhdGFUeXBlLCJ2b2xhdGlsZSIsbnVsbCwwLDEsUmksITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSwyKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwidHJhbnNpZW50IixudWxsLDAsMSxSaSwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lU3RydWN0dXJhbEZlYXR1cmVFQ2xhc3MpLDMpLDM1KSxlLmVTdHJpbmdFRGF0YVR5cGUsImRlZmF1bHRWYWx1ZUxpdGVyYWwiLG51bGwsMCwxLFJpLCExLCExLCEwLCExLCEwLCExKSxPcihhKE8oRyhlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcyksNCksMzUpLGUuZUphdmFPYmplY3RFRGF0YVR5cGUsImRlZmF1bHRWYWx1ZSIsbnVsbCwwLDEsUmksITAsITAsITEsITEsITAsITApLE9yKGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSw1KSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwidW5zZXR0YWJsZSIsbnVsbCwwLDEsUmksITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSw2KSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwiZGVyaXZlZCIsbnVsbCwwLDEsUmksITEsITEsITAsITEsITAsITEpLGZyKGEoTyhHKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSw3KSwxOSksZS5lQ2xhc3NFQ2xhc3MsYShPKEcoZS5lQ2xhc3NFQ2xhc3MpLDEzKSwxOSksImVDb250YWluaW5nQ2xhc3MiLDAsMSxSaSwhMCwhMSwhMSwhMSwhMSwhMSwhMSksZW8oYShPKGVyKGUuZVN0cnVjdHVyYWxGZWF0dXJlRUNsYXNzKSwwKSw2MiksZS5lSW50RURhdGFUeXBlLCJnZXRGZWF0dXJlSUQiKSx1PWVvKGEoTyhlcihlLmVTdHJ1Y3R1cmFsRmVhdHVyZUVDbGFzcyksMSksNjIpLG51bGwsImdldENvbnRhaW5lckNsYXNzIiksbj1tYyhlLmVKYXZhQ2xhc3NFRGF0YVR5cGUpLHI9R3RlKCkscG4oKCFuLmVUeXBlQXJndW1lbnRzJiYobi5lVHlwZUFyZ3VtZW50cz1uZXcganIoS3QsbiwxKSksbi5lVHlwZUFyZ3VtZW50cyksciksdD1xcyh1LG4sbnVsbCksdCYmdC5kaXNwYXRjaF8wKCksJG8oZS5lVHlwZWRFbGVtZW50RUNsYXNzLGVwLCJFVHlwZWRFbGVtZW50IiwhMCwhMSwhMCksT3IoYShPKEcoZS5lVHlwZWRFbGVtZW50RUNsYXNzKSwwKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwib3JkZXJlZCIsInRydWUiLDAsMSxlcCwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lVHlwZWRFbGVtZW50RUNsYXNzKSwxKSwzNSksZS5lQm9vbGVhbkVEYXRhVHlwZSwidW5pcXVlIiwidHJ1ZSIsMCwxLGVwLCExLCExLCEwLCExLCEwLCExKSxPcihhKE8oRyhlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDIpLDM1KSxlLmVJbnRFRGF0YVR5cGUsImxvd2VyQm91bmQiLG51bGwsMCwxLGVwLCExLCExLCEwLCExLCEwLCExKSxPcihhKE8oRyhlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDMpLDM1KSxlLmVJbnRFRGF0YVR5cGUsInVwcGVyQm91bmQiLCIxIiwwLDEsZXAsITEsITEsITAsITEsITAsITEpLE9yKGEoTyhHKGUuZVR5cGVkRWxlbWVudEVDbGFzcyksNCksMzUpLGUuZUJvb2xlYW5FRGF0YVR5cGUsIm1hbnkiLG51bGwsMCwxLGVwLCEwLCEwLCExLCExLCEwLCEwKSxPcihhKE8oRyhlLmVUeXBlZEVsZW1lbnRFQ2xhc3MpLDUpLDM1KSxlLmVCb29sZWFuRURhdGFUeXBlLCJyZXF1aXJlZCIsbnVsbCwwLDEsZXAsITAsITAsITEsITEsITAsITApLGZyKGEoTyhHKGUuZVR5cGVkRWxlbWVudEVDbGFzcyksNiksMTkpLGUuZUNsYXNzaWZpZXJFQ2xhc3MsbnVsbCwiZVR5cGUiLDAsMSxlcCwhMSwhMCwhMCwhMSwhMCwhMCwhMSksZnIoYShPKEcoZS5lVHlwZWRFbGVtZW50RUNsYXNzKSw3KSwxOSksZS5lR2VuZXJpY1R5cGVFQ2xhc3MsbnVsbCwiZUdlbmVyaWNUeXBlIiwwLDEsZXAsITEsITAsITAsITAsITEsITAsITEpLCRvKGUuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MsRV8sIkVTdHJpbmdUb1N0cmluZ01hcEVudHJ5IiwhMSwhMSwhMSksT3IoYShPKEcoZS5lU3RyaW5nVG9TdHJpbmdNYXBFbnRyeUVDbGFzcyksMCksMzUpLGUuZVN0cmluZ0VEYXRhVHlwZSwia2V5IixudWxsLDAsMSxFXywhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5lU3RyaW5nVG9TdHJpbmdNYXBFbnRyeUVDbGFzcyksMSksMzUpLGUuZVN0cmluZ0VEYXRhVHlwZSwidmFsdWUiLG51bGwsMCwxLEVfLCExLCExLCEwLCExLCEwLCExKSwkbyhlLmVHZW5lcmljVHlwZUVDbGFzcyxLdCwiRUdlbmVyaWNUeXBlIiwhMSwhMSwhMCksZnIoYShPKEcoZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDApLDE5KSxlLmVHZW5lcmljVHlwZUVDbGFzcyxudWxsLCJlVXBwZXJCb3VuZCIsMCwxLEt0LCExLCExLCEwLCEwLCExLCExLCExKSxmcihhKE8oRyhlLmVHZW5lcmljVHlwZUVDbGFzcyksMSksMTkpLGUuZUdlbmVyaWNUeXBlRUNsYXNzLG51bGwsImVUeXBlQXJndW1lbnRzIiwwLC0xLEt0LCExLCExLCEwLCEwLCExLCExLCExKSxmcihhKE8oRyhlLmVHZW5lcmljVHlwZUVDbGFzcyksMiksMTkpLGUuZUNsYXNzaWZpZXJFQ2xhc3MsbnVsbCwiZVJhd1R5cGUiLDEsMSxLdCwhMCwhMSwhMSwhMSwhMCwhMSwhMCksZnIoYShPKEcoZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDMpLDE5KSxlLmVHZW5lcmljVHlwZUVDbGFzcyxudWxsLCJlTG93ZXJCb3VuZCIsMCwxLEt0LCExLCExLCEwLCEwLCExLCExLCExKSxmcihhKE8oRyhlLmVHZW5lcmljVHlwZUVDbGFzcyksNCksMTkpLGUuZVR5cGVQYXJhbWV0ZXJFQ2xhc3MsbnVsbCwiZVR5cGVQYXJhbWV0ZXIiLDAsMSxLdCwhMSwhMSwhMCwhMSwhMSwhMSwhMSksZnIoYShPKEcoZS5lR2VuZXJpY1R5cGVFQ2xhc3MpLDUpLDE5KSxlLmVDbGFzc2lmaWVyRUNsYXNzLG51bGwsImVDbGFzc2lmaWVyIiwwLDEsS3QsITEsITEsITAsITEsITAsITEsITEpLHU9ZW8oYShPKGVyKGUuZUdlbmVyaWNUeXBlRUNsYXNzKSwwKSw2MiksZS5lQm9vbGVhbkVEYXRhVHlwZSwiaXNJbnN0YW5jZSIpLGxvKHUsZS5lSmF2YU9iamVjdEVEYXRhVHlwZSwib2JqZWN0IiksJG8oZS5lVHlwZVBhcmFtZXRlckVDbGFzcyxiaSwiRVR5cGVQYXJhbWV0ZXIiLCExLCExLCEwKSxmcihhKE8oRyhlLmVUeXBlUGFyYW1ldGVyRUNsYXNzKSwwKSwxOSksZS5lR2VuZXJpY1R5cGVFQ2xhc3MsbnVsbCwiZUJvdW5kcyIsMCwtMSxiaSwhMSwhMSwhMCwhMCwhMSwhMSwhMSksSG4oZS5lQmlnRGVjaW1hbEVEYXRhVHlwZSxGNSwiRUJpZ0RlY2ltYWwiLCEwKSxIbihlLmVCaWdJbnRlZ2VyRURhdGFUeXBlLE5wLCJFQmlnSW50ZWdlciIsITApLEhuKGUuZUJvb2xlYW5FRGF0YVR5cGUseWEsIkVCb29sZWFuIiwhMCksSG4oZS5lQm9vbGVhbk9iamVjdEVEYXRhVHlwZSxBciwiRUJvb2xlYW5PYmplY3QiLCEwKSxIbihlLmVCeXRlRURhdGFUeXBlLEppLCJFQnl0ZSIsITApLEhuKGUuZUJ5dGVBcnJheUVEYXRhVHlwZSxJKEppLDEpLCJFQnl0ZUFycmF5IiwhMCksSG4oZS5lQnl0ZU9iamVjdEVEYXRhVHlwZSx1aCwiRUJ5dGVPYmplY3QiLCEwKSxIbihlLmVDaGFyRURhdGFUeXBlLGZsLCJFQ2hhciIsITApLEhuKGUuZUNoYXJhY3Rlck9iamVjdEVEYXRhVHlwZSxGMiwiRUNoYXJhY3Rlck9iamVjdCIsITApLEhuKGUuZURhdGVFRGF0YVR5cGUsekksIkVEYXRlIiwhMCksSG4oZS5lRGlhZ25vc3RpY0NoYWluRURhdGFUeXBlLHFvZSwiRURpYWdub3N0aWNDaGFpbiIsITEpLEhuKGUuZURvdWJsZUVEYXRhVHlwZSxjdCwiRURvdWJsZSIsITApLEhuKGUuZURvdWJsZU9iamVjdEVEYXRhVHlwZSwkciwiRURvdWJsZU9iamVjdCIsITApLEhuKGUuZWVMaXN0RURhdGFUeXBlLFZuZSwiRUVMaXN0IiwhMSksSG4oZS5lRW51bWVyYXRvckVEYXRhVHlwZSxFcmUsIkVFbnVtZXJhdG9yIiwhMSksSG4oZS5lRmVhdHVyZU1hcEVEYXRhVHlwZSxlb2UsIkVGZWF0dXJlTWFwIiwhMSksSG4oZS5lRmVhdHVyZU1hcEVudHJ5RURhdGFUeXBlLHBMLCJFRmVhdHVyZU1hcEVudHJ5IiwhMSksSG4oZS5lRmxvYXRFRGF0YVR5cGUscHAsIkVGbG9hdCIsITApLEhuKGUuZUZsb2F0T2JqZWN0RURhdGFUeXBlLGF5LCJFRmxvYXRPYmplY3QiLCEwKSxIbihlLmVJbnRFRGF0YVR5cGUsaG4sIkVJbnQiLCEwKSxIbihlLmVJbnRlZ2VyT2JqZWN0RURhdGFUeXBlLHZ0LCJFSW50ZWdlck9iamVjdCIsITApLEhuKGUuZUphdmFDbGFzc0VEYXRhVHlwZSxheiwiRUphdmFDbGFzcyIsITApLEhuKGUuZUphdmFPYmplY3RFRGF0YVR5cGUsUXIsIkVKYXZhT2JqZWN0IiwhMCksSG4oZS5lTG9uZ0VEYXRhVHlwZSxfXywiRUxvbmciLCEwKSxIbihlLmVMb25nT2JqZWN0RURhdGFUeXBlLEkxLCJFTG9uZ09iamVjdCIsITApLEhuKGUuZU1hcEVEYXRhVHlwZSxneiwiRU1hcCIsITEpLEhuKGUuZVJlc291cmNlRURhdGFUeXBlLFV0ZSwiRVJlc291cmNlIiwhMSksSG4oZS5lUmVzb3VyY2VTZXRFRGF0YVR5cGUsWW9lLCJFUmVzb3VyY2VTZXQiLCExKSxIbihlLmVTaG9ydEVEYXRhVHlwZSxYZywiRVNob3J0IiwhMCksSG4oZS5lU2hvcnRPYmplY3RFRGF0YVR5cGUseDEsIkVTaG9ydE9iamVjdCIsITApLEhuKGUuZVN0cmluZ0VEYXRhVHlwZSxzZSwiRVN0cmluZyIsITApLEhuKGUuZVRyZWVJdGVyYXRvckVEYXRhVHlwZSxucmUsIkVUcmVlSXRlcmF0b3IiLCExKSxIbihlLmVJbnZvY2F0aW9uVGFyZ2V0RXhjZXB0aW9uRURhdGFUeXBlLEtvZSwiRUludm9jYXRpb25UYXJnZXRFeGNlcHRpb24iLCExKSxTbmUoZSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMi9FY29yZSIpKX1mdW5jdGlvbiBEV2UoKXtDbmUuY2FsbCh0aGlzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIiwoVncoKSxBcmUpKSxLM24odGhpcyl9ZnVuY3Rpb24gZVRuKCl7QnRlKCk7dmFyIGU7cmV0dXJuIEZXZT9hKGEyKChuXygpLFBsKSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMi9FY29yZSIpLDIwMzgpOigkbihFXyxuZXcgU2plKSxuVG4oKSxlPWEoTChuaSgobl8oKSxQbCksImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiKSw1NjApP25pKFBsLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAyL0Vjb3JlIik6bmV3IERXZSw1NjApLEZXZT0hMCxaM24oZSksUTNuKGUpLEJuKChQcmUoKSxOcmUpLGUsbmV3IHpXZSksdG8oUGwsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiLGUpLGUpfWZ1bmN0aW9uIG5UbigpeyRuKG5wLG5ldyBLV2UpLCRuKERuLG5ldyBhamUpLCRuKElsLG5ldyBtamUpLCRuKEVzLG5ldyBDamUpLCRuKE1ELG5ldyBUamUpLCRuKGZMLG5ldyBiamUpLCRuKHZjLG5ldyBJamUpLCRuKGFTLG5ldyB4amUpLCRuKEpULG5ldyAkV2UpLCRuKE9SLG5ldyBCV2UpLCRuKEswLG5ldyBHV2UpLCRuKHhsLG5ldyBIV2UpLCRuKHlzLG5ldyBVV2UpLCRuKE5kLG5ldyBXV2UpLCRuKHJwLG5ldyBqV2UpLCRuKFJpLG5ldyBWV2UpLCRuKGVwLG5ldyBxV2UpLCRuKEJvLG5ldyBZV2UpLCRuKEt0LG5ldyBYV2UpLCRuKGJpLG5ldyBKV2UpLCRuKEFyLG5ldyBaV2UpLCRuKEkoSmksMSksbmV3IFFXZSksJG4odWgsbmV3IGVqZSksJG4oRjIsbmV3IG5qZSksJG4oekksbmV3IHJqZSksJG4ocW9lLG5ldyB0amUpLCRuKCRyLG5ldyBvamUpLCRuKFZuZSxuZXcgaWplKSwkbihFcmUsbmV3IGxqZSksJG4oZW9lLG5ldyBzamUpLCRuKHBMLG5ldyB1amUpLCRuKGF5LG5ldyBjamUpLCRuKHZ0LG5ldyBfamUpLCRuKGF6LG5ldyBkamUpLCRuKEkxLG5ldyBmamUpLCRuKGd6LG5ldyBwamUpLCRuKFV0ZSxuZXcgZ2plKSwkbihZb2UsbmV3IGhqZSksJG4oeDEsbmV3IHlqZSksJG4oc2UsbmV3IHdqZSksJG4obnJlLG5ldyBFamUpLCRuKEtvZSxuZXcgdmplKX1mdW5jdGlvbiByVG4oKXtCdGUoKTt2YXIgZSxuO2ZvcihKM24oKHJfKCksJGUpKSxYM24oJGUpLGVEKCRlKSxldGU9KFBlKCksVnMpLG49bmV3IFQoSHRlKTtuLmk8bi50aGlzJDAxLmFycmF5Lmxlbmd0aDspZT1hKEMobiksMjQ4KSxpMihlLFZzLG51bGwpO3JldHVybiEwfXAoNTYwLDE4NCx7MTEwOjEsOTQ6MSw5MzoxLDE1NToxLDE5NzoxLDU4OjEsMjQxOjEsMTE0OjEsMjAzODoxLDU0OjEsOTk6MSwxNTg6MSwxODQ6MSw1NjA6MSwxMTk6MSwxMjA6MSw2OTA6MX0sRFdlKSxsLmlzQ3JlYXRlZD0hMSxsLmlzSW5pdGlhbGl6ZWQ9ITE7dmFyIEh0ZSxGV2U9ITE7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsIiw1NjApO2Z1bmN0aW9uIHpXZSgpe31wKDEyMzQsMSx7ODUxOjF9LHpXZSksbC5nZXRFVmFsaWRhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIEVWZSgpLFNWZX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzEiLDEyMzQpO2Z1bmN0aW9uICRXZSgpe31wKDEyNDMsMSx6biwkV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE1NSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihKVCxNZSwxNTUsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTAiLDEyNDMpO2Z1bmN0aW9uIEJXZSgpe31wKDEyNDQsMSx6bixCV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE5Nyl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihPUixNZSwxOTcsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTEiLDEyNDQpO2Z1bmN0aW9uIEdXZSgpe31wKDEyNDUsMSx6bixHV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDU4KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEswLE1lLDU4LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzEyIiwxMjQ1KTtmdW5jdGlvbiBIV2UoKXt9cCgxMjQ2LDEsem4sSFdlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw0MTEpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoeGwsbnosNjIsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTMiLDEyNDYpO2Z1bmN0aW9uIFVXZSgpe31wKDEyNDcsMSx6bixVV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDI0MSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQih5cyxNZSwyNDEsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTQiLDEyNDcpO2Z1bmN0aW9uIFdXZSgpe31wKDEyNDgsMSx6bixXV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDUxOCl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihOZCxNZSwyMTE2LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzE1IiwxMjQ4KTtmdW5jdGlvbiBqV2UoKXt9cCgxMjQ5LDEsem4saldlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxMDIpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIocnAsRXAsMTksbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTYiLDEyNDkpO2Z1bmN0aW9uIFZXZSgpe31wKDEyNTAsMSx6bixWV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE3OSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihSaSxFcCwxNzksbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTciLDEyNTApO2Z1bmN0aW9uIHFXZSgpe31wKDEyNTEsMSx6bixxV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDQ4MSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihlcCxNZSw0ODEsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMTgiLDEyNTEpO2Z1bmN0aW9uIFlXZSgpe31wKDEyNTIsMSx6bixZV2UpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDU2MSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihCbyxBaWUsNTYxLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzE5IiwxMjUyKTtmdW5jdGlvbiBLV2UoKXt9cCgxMjM1LDEsem4sS1dlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwzMzEpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIobnAsRXAsMzUsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMiIsMTIzNSk7ZnVuY3Rpb24gWFdlKCl7fXAoMTI1MywxLHpuLFhXZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMjQ4KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEt0LGtpZSw4OSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8yMCIsMTI1Myk7ZnVuY3Rpb24gSldlKCl7fXAoMTI1NCwxLHpuLEpXZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sNDU3KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKGJpLE1lLDg1MCxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8yMSIsMTI1NCk7ZnVuY3Rpb24gWldlKCl7fXAoMTI1NSwxLHpuLFpXZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBWZChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEFyLFgsNDg1LG4sOCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzIyIiwxMjU1KTtmdW5jdGlvbiBRV2UoKXt9cCgxMjU2LDEsem4sUVdlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxOTUpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoSmksWCwxOTUsbiwwLDIpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMjMiLDEyNTYpO2Z1bmN0aW9uIGVqZSgpe31wKDEyNTcsMSx6bixlamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDIyMil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQih1aCxYLDIyMixuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8yNCIsMTI1Nyk7ZnVuY3Rpb24gbmplKCl7fXAoMTI1OCwxLHpuLG5qZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTgwKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEYyLFgsMTgwLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzI1IiwxMjU4KTtmdW5jdGlvbiByamUoKXt9cCgxMjU5LDEsem4scmplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwyMDYpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoekksWCwyMDYsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMjYiLDEyNTkpO2Z1bmN0aW9uIHRqZSgpe31wKDEyNjAsMSx6bix0amUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4hMX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHFvZSxNZSwyMjE1LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzI3IiwxMjYwKTtmdW5jdGlvbiBvamUoKXt9cCgxMjYxLDEsem4sb2plKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHFkKG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoJHIsWCwzNDUsbiw3LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMjgiLDEyNjEpO2Z1bmN0aW9uIGlqZSgpe31wKDEyNjIsMSx6bixpamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDYxKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKFZuZSxVZCw2MSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8yOSIsMTI2Mik7ZnVuY3Rpb24gYWplKCl7fXAoMTIzNiwxLHpuLGFqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sNTE5KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKERuLHszOjEsNDoxLDU6MSwyMDMzOjF9LDU5OCxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8zIiwxMjM2KTtmdW5jdGlvbiBsamUoKXt9cCgxMjYzLDEsem4sbGplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw1ODIpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoRXJlLE1lLDIwMzksbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMzAiLDEyNjMpO2Z1bmN0aW9uIHNqZSgpe31wKDEyNjQsMSx6bixzamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE2MCl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihlb2UsVWQsMTYwLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzMxIiwxMjY0KTtmdW5jdGlvbiB1amUoKXt9cCgxMjY1LDEsem4sdWplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw3Nil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihwTCxPaWUsNzYsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMzIiLDEyNjUpO2Z1bmN0aW9uIGNqZSgpe31wKDEyNjYsMSx6bixjamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE2MSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihheSxYLDE2MSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8zMyIsMTI2Nik7ZnVuY3Rpb24gX2plKCl7fXAoMTI2NywxLHpuLF9qZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTcpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIodnQsWCwxNyxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8zNCIsMTI2Nyk7ZnVuY3Rpb24gZGplKCl7fXAoMTI2OCwxLHpuLGRqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMjk3KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKGF6LE1lLDI5NyxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8zNSIsMTI2OCk7ZnVuY3Rpb24gZmplKCl7fXAoMTI2OSwxLHpuLGZqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTY4KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEkxLFgsMTY4LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzM2IiwxMjY5KTtmdW5jdGlvbiBwamUoKXt9cCgxMjcwLDEsem4scGplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw4NSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihneixNZSw4NSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC8zNyIsMTI3MCk7ZnVuY3Rpb24gZ2plKCl7fXAoMTI3MSwxLHpuLGdqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sNTk5KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKFV0ZSxNZSw1OTksbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvMzgiLDEyNzEpO2Z1bmN0aW9uIGhqZSgpe31wKDEyNzIsMSx6bixoamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4hMX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKFlvZSxNZSwyMjE2LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzM5IiwxMjcyKTtmdW5jdGlvbiBtamUoKXt9cCgxMjM3LDEsem4sbWplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw5MCl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihJbCxNZSwyOSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC80IiwxMjM3KTtmdW5jdGlvbiB5amUoKXt9cCgxMjczLDEsem4seWplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxOTEpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoeDEsWCwxOTEsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvNDAiLDEyNzMpO2Z1bmN0aW9uIHdqZSgpe31wKDEyNzQsMSx6bix3amUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvNDEiLDEyNzQpO2Z1bmN0aW9uIEVqZSgpe31wKDEyNzUsMSx6bixFamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDU5Nil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihucmUsTWUsNTk2LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzQyIiwxMjc1KTtmdW5jdGlvbiB2amUoKXt9cCgxMjc2LDEsem4sdmplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuITF9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihLb2UsWCwyMjE3LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzQzIiwxMjc2KTtmdW5jdGlvbiBTamUoKXt9cCgxMjc3LDEsem4sU2plKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw0NCl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihFXyxIYiw0NCxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC80NCIsMTI3Nyk7ZnVuY3Rpb24gQ2plKCl7fXAoMTIzOCwxLHpuLENqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTQyKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKEVzLE1lLDE0MixuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC81IiwxMjM4KTtmdW5jdGlvbiBUamUoKXt9cCgxMjM5LDEsem4sVGplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNTYpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoTUQsTWUsMTU2LG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzYiLDEyMzkpO2Z1bmN0aW9uIGJqZSgpe31wKDEyNDAsMSx6bixiamUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDQ2OSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihmTCxNZSw2ODUsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIkVjb3JlUGFja2FnZUltcGwvNyIsMTI0MCk7ZnVuY3Rpb24gSWplKCl7fXAoMTI0MSwxLHpuLElqZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sNTgyKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHZjLE1lLDY5NCxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiRWNvcmVQYWNrYWdlSW1wbC84IiwxMjQxKTtmdW5jdGlvbiB4amUoKXt9cCgxMjQyLDEsem4seGplKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw0ODApfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoYVMsTWUsNDgwLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLmltcGwiLCJFY29yZVBhY2thZ2VJbXBsLzkiLDEyNDIpO2Z1bmN0aW9uIHRUbihlLG4pe3ZhciByLHQsbyxpO2lmKG4uc2V0VGFyZ2V0KGUudGhpcyQwMSksaT1hKEJlKGUudGhpcyQwMSw4KSwyMDM1KSxpIT1udWxsKWZvcihyPWksdD0wLG89ci5sZW5ndGg7dDxvOysrdCludWxsLiRfbnVsbE1ldGhvZCgpfWZ1bmN0aW9uIFBqZShlLG4scil7dmFyIHQsbyxpLHMsdSxjO2lmKHU9YShCZShlLnRoaXMkMDEsOCksMjAzNSksdSE9bnVsbClmb3Iobz11LGk9MCxzPW8ubGVuZ3RoO2k8czsrK2kpbnVsbC4kX251bGxNZXRob2QoKTt0PXIsZS50aGlzJDAxLmVGbGFnc18wJjF8fChjPW5ldyBBamUoZSxyLG4pLHQubm90aWZ5Q2hhbmdlZChjKSksTCh0LDY4Nik/YSh0LDY4NikudW5zZXRUYXJnZXQoZS50aGlzJDAxKTp0LmdldFRhcmdldCgpPT1lLnRoaXMkMDEmJnQuc2V0VGFyZ2V0KG51bGwpfWZ1bmN0aW9uIHMyKGUsbil7dmFyIHIsdDtpZigrK2UubW9kQ291bnQsbiE9bnVsbCYmKHI9KHQ9ZS50aGlzJDAxLmVDb250YWluZXIsTCh0LDk5KT9hKHQsOTkpLmVCYXNpY0FkYXB0ZXJBcnJheSgpOm51bGwpLEtaZShuLHIpKSl7bW0oZS50aGlzJDAxLDQscik7cmV0dXJufW1tKGUudGhpcyQwMSw0LGEobiwxMjkpKX1mdW5jdGlvbiBOamUoZSl7aEdlKCksdGhpcy50aGlzJDAxPWV9cCgxMDM4LDIwODAsTmllLE5qZSksbC5kaWRBZGQ9ZnVuY3Rpb24obixyKXt0VG4odGhpcyxhKHIsNDI0KSl9LGwuZGlkUmVtb3ZlPWZ1bmN0aW9uKG4scil7UGplKHRoaXMsbixhKHIsNDI0KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5pbXBsIiwiTWluaW1hbEVPYmplY3RJbXBsLzFBcnJheURlbGVnYXRpbmdBZGFwdGVyTGlzdCIsMTAzOCk7ZnVuY3Rpb24gQWplKGUsbixyKXt0aGlzLnRoaXMkMTE9ZSxwcmUuY2FsbCh0aGlzLDgsbixudWxsLHIpfXAoMTAzOSwxNTIsUVMsQWplKSxsLmdldE5vdGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQxMS50aGlzJDAxfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUuaW1wbCIsIk1pbmltYWxFT2JqZWN0SW1wbC8xQXJyYXlEZWxlZ2F0aW5nQWRhcHRlckxpc3QvMSIsMTAzOSk7ZnVuY3Rpb24gYm4oKXtibj1GLG5ldyBMamUsbmV3IFF9ZnVuY3Rpb24gTGplKCl7bmV3IHNuLG5ldyBzbixuZXcgc259cCgxMDY3LDEwNjYse30sTGplKSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUucGx1Z2luIiwiRWNvcmVQbHVnaW4iLDEwNjcpO3ZhciBVdGU9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5yZXNvdXJjZSIsIlJlc291cmNlIik7ZnVuY3Rpb24gb1RuKGUsbil7dmFyIHIsdCxvO2ZvcihvPW4uYXJyYXkubGVuZ3RoLHI9YVRuKGUsbz09MD8iIjooQWUoMCxuLmFycmF5Lmxlbmd0aCkseG4obi5hcnJheVswXSkpKSx0PTE7dDxvJiZyOysrdClyPWEociw1NCkuZU9iamVjdEZvclVSSUZyYWdtZW50U2VnbWVudCgoQWUodCxuLmFycmF5Lmxlbmd0aCkseG4obi5hcnJheVt0XSkpKTtyZXR1cm4gcn1mdW5jdGlvbiBpVG4oZSxuKXt2YXIgcix0LG8saSxzLHU7Zm9yKGk9bnVsbCxvPW5ldyBPamUoKCFlLmNvbnRlbnRzJiYoZS5jb250ZW50cz1uZXcgaEYoZSkpLGUuY29udGVudHMpKTtXdGUobyk7KWlmKHI9YShlTChvKSw1OCksdD0ocz1yLmVDbGFzc18wKCksdT0oR2cocykscy5lSURBdHRyaWJ1dGUpLCF1fHwhci5lSXNTZXRfMCh1KT9udWxsOnBvZSh6RCh1KSxyLmVHZXRfMCh1KSkpLHQhPW51bGwmJlRlKHQsbikpe2k9cjticmVha31yZXR1cm4gaX1mdW5jdGlvbiBhVG4oZSxuKXt2YXIgcix0LG87aWYobz0wLG4ubGVuZ3RoPjApdHJ5e289QWEobixidCxxbil9Y2F0Y2goaSl7dGhyb3cgaT13cihpKSxMKGksMTMwKT8odD1pLGIobmV3IGRMKHQpKSk6YihpKX1yZXR1cm4gcj0oIWUuY29udGVudHMmJihlLmNvbnRlbnRzPW5ldyBoRihlKSksZS5jb250ZW50cyksbzxyLnNpemVfMCYmbz49MD9hKE8ocixvKSw1OCk6bnVsbH1wKDc5OSwxNTI0LE1pZSksbC5hdHRhY2hlZD1mdW5jdGlvbihuKXt9LGwuZGV0YWNoZWQ9ZnVuY3Rpb24obil7fSxsLmdldENvbnRlbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuY29udGVudHMmJih0aGlzLmNvbnRlbnRzPW5ldyBoRih0aGlzKSksdGhpcy5jb250ZW50c30sbC5nZXRFT2JqZWN0PWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHM7aWYobz1uLmxlbmd0aCxvPjApaWYoSGUoMCxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KDApPT00Nyl7Zm9yKHM9bmV3IF9pKDQpLGk9MSxyPTE7cjxvOysrcilIZShyLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQocik9PTQ3JiYoZWUocyxpPT1yPyIiOihndChpLHIsbi5sZW5ndGgpLG4uc3Vic3RyKGksci1pKSkpLGk9cisxKTtyZXR1cm4gZWUocywoSGUoaSxuLmxlbmd0aCsxKSxuLnN1YnN0cihpKSkpLG9Ubih0aGlzLHMpfWVsc2UgSGUoby0xLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoby0xKT09NjMmJih0PWNCKG4seGkoNjMpLG8tMiksdD4wJiYobj0oZ3QoMCx0LG4ubGVuZ3RoKSxuLnN1YnN0cigwLHQpKSkpO3JldHVybiBpVG4odGhpcyxuKX0sbC5nZXRSZXNvdXJjZVNldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc291cmNlU2V0fSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4geV8odGhpcy5fX19jbGF6eikrIkAiKyhuPXVyKHRoaXMpPj4+MCxuLnRvU3RyaW5nKDE2KSkrIiB1cmk9JyIrdGhpcy51cmlfMCsiJyJ9LGwuaXNMb2FkZWQ9ITEsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnJlc291cmNlLmltcGwiLCJSZXNvdXJjZUltcGwiLDc5OSk7ZnVuY3Rpb24ga2plKGUpe3RoaXMudXJpXzA9ZX1wKDE1MjUsNzk5LE1pZSxramUpLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5yZXNvdXJjZS5pbXBsIiwiQmluYXJ5UmVzb3VyY2VJbXBsIiwxNTI1KTtmdW5jdGlvbiBsVG4oZSxuKXtyZXR1cm4gZS5pc1Jlc29sdmVQcm94aWVzP24uZUNvbnRlbnRzXzAoKS5pdGVyYXRvcl8wKCk6YShuLmVDb250ZW50c18wKCksNzEpLmJhc2ljSXRlcmF0b3IoKX1mdW5jdGlvbiBXdGUoZSl7dmFyIG47aWYoIWUuaW5jbHVkZVJvb3QmJmUuZGF0YV8wPT1udWxsKWUubmV4dFBydW5lSXRlcmF0b3I9ZS5nZXRDaGlsZHJlbihlLm9iamVjdCkscG4oZSxlLm5leHRQcnVuZUl0ZXJhdG9yKSxuPWUubmV4dFBydW5lSXRlcmF0b3I7ZWxzZXtpZihlLmRhdGFfMD09bnVsbClyZXR1cm4hMDtpZihlLnNpemVfMD09MClyZXR1cm4hMTtuPWEoZS5kYXRhXzBbZS5zaXplXzAtMV0sNTEpfXJldHVybiBuPT1lLnJlc291cmNlU2V0SXRlcmF0b3ImJm51bGwuJF9udWxsRmllbGQ+PW51bGwuJF9udWxsTWV0aG9kKCk/KGVMKGUpLFd0ZShlKSk6bi5oYXNOZXh0XzAoKX1wKDExOTAsNzA4LG02KSxsLmdldENoaWxkcmVuPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sNTgpP2xUbih0aGlzLGEobiw1OCkpOkwobiw1OTkpP25ldyBZZShhKG4sNTk5KS5nZXRDb250ZW50cygpKTpEKG4pPT09RCh0aGlzLm9iamVjdCk/YShuLDE2KS5pdGVyYXRvcl8wKCk6KGp3KCksaGIubGlzdEl0ZXJhdG9yKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gV3RlKHRoaXMpfSxsLmlzUmVzb2x2ZVByb3hpZXM9ITEsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFY29yZVV0aWwvQ29udGVudFRyZWVJdGVyYXRvciIsMTE5MCk7ZnVuY3Rpb24gT2plKGUpe3FCZS5jYWxsKHRoaXMsZSwhMSksdGhpcy5pc1Jlc29sdmVQcm94aWVzPSExfXAoMTUyNiwxMTkwLG02LE9qZSksbC5nZXRDaGlsZHJlbj1mdW5jdGlvbihuKXtyZXR1cm4gRChuKT09PUQodGhpcy5vYmplY3QpP2EobiwxNSkuaXRlcmF0b3JfMCgpOm5ldyB3VmUoYShuLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS5yZXNvdXJjZS5pbXBsIiwiUmVzb3VyY2VJbXBsLzUiLDE1MjYpO2Z1bmN0aW9uIGhGKGUpe3RoaXMudGhpcyQwMT1lfXAoNjU4LDIwOTIsTGllLGhGKSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNpemVfMDw9ND9Xdyh0aGlzLG4pOkwobiw1NCkmJmEobiw1NCkuZURpcmVjdFJlc291cmNlKCk9PXRoaXMudGhpcyQwMX0sbC5kaWRBZGQ9ZnVuY3Rpb24obixyKXtuPT10aGlzLnNpemVfMC0xJiYodGhpcy50aGlzJDAxLmlzTG9hZGVkfHwodGhpcy50aGlzJDAxLmlzTG9hZGVkPSEwKSl9LGwuZGlkQ2xlYXI9ZnVuY3Rpb24obixyKXtuPT0wP3RoaXMudGhpcyQwMS5pc0xvYWRlZHx8KHRoaXMudGhpcyQwMS5pc0xvYWRlZD0hMCk6Y0QodGhpcyxuLHIpfSxsLmRpZFJlbW92ZT1mdW5jdGlvbihuLHIpe30sbC5kaWRTZXQ9ZnVuY3Rpb24obixyLHQpe30sbC5nZXRGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiAyfSxsLmdldE5vdGlmaWVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMX0sbC5oYXNJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwuaW52ZXJzZUFkZD1mdW5jdGlvbihuLHIpe3ZhciB0O3JldHVybiB0PWEobiw1NCkscj10LmVTZXRSZXNvdXJjZSh0aGlzLnRoaXMkMDEscikscn0sbC5pbnZlcnNlUmVtb3ZlPWZ1bmN0aW9uKG4scil7dmFyIHQ7cmV0dXJuIHQ9YShuLDU0KSx0LmVTZXRSZXNvdXJjZShudWxsLHIpfSxsLmlzTm90aWZpY2F0aW9uUmVxdWlyZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5pc1VuaXF1ZT1mdW5jdGlvbigpe3JldHVybiEwfSxsLm5ld0RhdGE9ZnVuY3Rpb24obil7cmV0dXJuIEIoSzAsTWUsNTgsbiwwLDEpfSxsLnVzZUVxdWFscz1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUucmVzb3VyY2UuaW1wbCIsIlJlc291cmNlSW1wbC9Db250ZW50c0VMaXN0Iiw2NTgpO2Z1bmN0aW9uIE1qZShlKXt0aGlzLnRoaXMkMDE9ZX1wKDk3MCwyMDYyLEhtLE1qZSksbC5saXN0SXRlcmF0b3JfMT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aGlzJDAxLmJhc2ljTGlzdEl0ZXJhdG9yXzAobil9LGwuc2l6ZV8xPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhpcyQwMS5zaXplXzEoKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJBYnN0cmFjdFNlcXVlbnRpYWxJbnRlcm5hbEVMaXN0LzEiLDk3MCk7ZnVuY3Rpb24gS2koKXtLaT1GLFZ0ZT1QKEkoc2UsMSksWCwyLDYsWyJ1bnNwZWNpZmllZCIsInNpbXBsZSIsImF0dHJpYnV0ZSIsImF0dHJpYnV0ZVdpbGRjYXJkIiwiZWxlbWVudCIsImVsZW1lbnRXaWxkY2FyZCIsImdyb3VwIl0pLGp0ZT1QKEkoc2UsMSksWCwyLDYsWyJ1bnNwZWNpZmllZCIsImVtcHR5Iiwic2ltcGxlIiwibWl4ZWQiLCJlbGVtZW50T25seSJdKSxxdGU9UChJKHNlLDEpLFgsMiw2LFsidW5zcGVjaWZpZWQiLCJwcmVzZXJ2ZSIsInJlcGxhY2UiLCJjb2xsYXBzZSJdKSxUdD1uZXcgRGplfXZhciBqdGUsVnRlLFR0LHF0ZTtmdW5jdGlvbiB1Migpe3UyPUY7dmFyIGUsbjtGTD0oVncoKSxuPW5ldyB4TCxuKSx6TD0oZT1uZXcgQkQsZSl9ZnVuY3Rpb24gc1RuKGUsbil7dmFyIHIsdCxvO3JldHVybiByPW4uZ2V0RUFubm90YXRpb24oZS5hbm5vdGF0aW9uVVJJKSxyJiYobz14bih3cygoIXIuZGV0YWlscyYmKHIuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHIpKSxyLmRldGFpbHMpLCJhZmZpbGlhdGlvbiIpKSxvIT1udWxsKT8odD1qSShvLHhpKDM1KSksdD09LTE/eUYoZSx4UyhlLEhhKG4uZ2V0RUNvbnRhaW5pbmdDbGFzcygpKSksbyk6dD09MD95RihlLG51bGwsKEhlKDEsby5sZW5ndGgrMSksby5zdWJzdHIoMSkpKTp5RihlLChndCgwLHQsby5sZW5ndGgpLG8uc3Vic3RyKDAsdCkpLChIZSh0KzEsby5sZW5ndGgrMSksby5zdWJzdHIodCsxKSkpKTpudWxsfWZ1bmN0aW9uIHVUbihlLG4pe3ZhciByLHQsbyxpLHM7cmV0dXJuIG89bi5nZXRFQW5ub3RhdGlvbihlLmFubm90YXRpb25VUkkpLG8mJih0PSghby5kZXRhaWxzJiYoby5kZXRhaWxzPW5ldyBiYSgoUGUoKSxCdCksQm8sbykpLG8uZGV0YWlscykscj14bih3cyh0LCJiYXNlVHlwZSIpKSxyIT1udWxsJiYoaT1yLmxhc3RJbmRleE9mKCIjIikscz1pPT0tMT9adGUoZSxuLmdldEVQYWNrYWdlKCkscik6aT09MD9JYihlLG51bGwsKEhlKDEsci5sZW5ndGgrMSksci5zdWJzdHIoMSkpKTpJYihlLChndCgwLGksci5sZW5ndGgpLHIuc3Vic3RyKDAsaSkpLChIZShpKzEsci5sZW5ndGgrMSksci5zdWJzdHIoaSsxKSkpLEwocywxNTYpKSk/YShzLDE1Nik6bnVsbH1mdW5jdGlvbiBjVG4oZSxuKXt2YXIgcix0LG87aWYocj1uLmdldEVBbm5vdGF0aW9uKGUuYW5ub3RhdGlvblVSSSksciYmKG89d3MoKCFyLmRldGFpbHMmJihyLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxyKSksci5kZXRhaWxzKSwia2luZCIpLG8hPW51bGwpKXtmb3IodD0xO3Q8KEtpKCksanRlKS5sZW5ndGg7Kyt0KWlmKFRlKGp0ZVt0XSxvKSlyZXR1cm4gdH1yZXR1cm4gMH1mdW5jdGlvbiBfVG4oZSxuKXt2YXIgcix0LG87aWYocj1uLmdldEVBbm5vdGF0aW9uKGUuYW5ub3RhdGlvblVSSSksciYmKG89d3MoKCFyLmRldGFpbHMmJihyLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxyKSksci5kZXRhaWxzKSwia2luZCIpLG8hPW51bGwpKXtmb3IodD0xO3Q8KEtpKCksVnRlKS5sZW5ndGg7Kyt0KWlmKFRlKFZ0ZVt0XSxvKSlyZXR1cm4gdH1yZXR1cm4gMH1mdW5jdGlvbiBkVG4oZSxuKXt2YXIgcix0LG8saSxzLHU7aWYocj1uLmdldEVBbm5vdGF0aW9uKGUuYW5ub3RhdGlvblVSSSksciYmKHU9eG4od3MoKCFyLmRldGFpbHMmJihyLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxyKSksci5kZXRhaWxzKSwiZ3JvdXAiKSksdSE9bnVsbCkpc3dpdGNoKG89akkodSx4aSgzNSkpLHQ9bi5nZXRFQ29udGFpbmluZ0NsYXNzKCksbz09LTE/KHM9eFMoZSxIYSh0KSksaT11KTpvPT0wPyhzPW51bGwsaT0oSGUoMSx1Lmxlbmd0aCsxKSx1LnN1YnN0cigxKSkpOihzPShndCgwLG8sdS5sZW5ndGgpLHUuc3Vic3RyKDAsbykpLGk9KEhlKG8rMSx1Lmxlbmd0aCsxKSx1LnN1YnN0cihvKzEpKSksUmQodW8oZSxuKSkpe2Nhc2UgMjpjYXNlIDM6cmV0dXJuIHZUbihlLHQscyxpKTtjYXNlIDA6Y2FzZSA0OmNhc2UgNTpjYXNlIDY6cmV0dXJuIENUbihlLHQscyxpKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBmVG4oZSxuKXt2YXIgcix0LG8saSxzO3JldHVybiB0PW4uZ2V0RUFubm90YXRpb24oZS5hbm5vdGF0aW9uVVJJKSx0JiYocj0oIXQuZGV0YWlscyYmKHQuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHQpKSx0LmRldGFpbHMpLGk9eG4od3MociwiaXRlbVR5cGUiKSksaSE9bnVsbCYmKG89aS5sYXN0SW5kZXhPZigiIyIpLHM9bz09LTE/WnRlKGUsbi5nZXRFUGFja2FnZSgpLGkpOm89PTA/SWIoZSxudWxsLChIZSgxLGkubGVuZ3RoKzEpLGkuc3Vic3RyKDEpKSk6SWIoZSwoZ3QoMCxvLGkubGVuZ3RoKSxpLnN1YnN0cigwLG8pKSwoSGUobysxLGkubGVuZ3RoKzEpLGkuc3Vic3RyKG8rMSkpKSxMKHMsMTU2KSkpP2EocywxNTYpOm51bGx9ZnVuY3Rpb24gcFRuKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2lmKHI9bi5nZXRFQW5ub3RhdGlvbihlLmFubm90YXRpb25VUkkpLHImJihjPXhuKHdzKCghci5kZXRhaWxzJiYoci5kZXRhaWxzPW5ldyBiYSgoUGUoKSxCdCksQm8scikpLHIuZGV0YWlscyksIm1lbWJlclR5cGVzIikpLGMhPW51bGwpKXtmb3IoXz1uZXcgUSxpPWVmKGMsIlxcdyIpLHM9MCx1PWkubGVuZ3RoO3M8dTsrK3Mpbz1pW3NdLHQ9by5sYXN0SW5kZXhPZigiIyIpLGQ9dD09LTE/WnRlKGUsbi5nZXRFUGFja2FnZSgpLG8pOnQ9PTA/SWIoZSxudWxsLChIZSgxLG8ubGVuZ3RoKzEpLG8uc3Vic3RyKDEpKSk6SWIoZSwoZ3QoMCx0LG8ubGVuZ3RoKSxvLnN1YnN0cigwLHQpKSwoSGUodCsxLG8ubGVuZ3RoKzEpLG8uc3Vic3RyKHQrMSkpKSxMKGQsMTU2KSYmZWUoXyxhKGQsMTU2KSk7cmV0dXJuIF99cmV0dXJuIE5lKCksTmUoKSxPdH1mdW5jdGlvbiBSamUoZSxuKXt2YXIgcix0O3JldHVybiByPW4uZ2V0RUFubm90YXRpb24oZS5hbm5vdGF0aW9uVVJJKSxyJiYodD14bih3cygoIXIuZGV0YWlscyYmKHIuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHIpKSxyLmRldGFpbHMpLCJuYW1lIikpLHQhPW51bGwpP3Q6bi5nZXROYW1lKCl9ZnVuY3Rpb24gZ1RuKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1uLmdldEVBbm5vdGF0aW9uKGUuYW5ub3RhdGlvblVSSSksciYmKHQ9eG4od3MoKCFyLmRldGFpbHMmJihyLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxyKSksci5kZXRhaWxzKSwibmFtZSIpKSx0IT1udWxsKT90Om4uZ2V0TmFtZSgpfWZ1bmN0aW9uIGhUbihlLG4pe3ZhciByLHQ7cmV0dXJuIHI9bi5nZXRFQW5ub3RhdGlvbihlLmFubm90YXRpb25VUkkpLHI/KHQ9eG4od3MoKCFyLmRldGFpbHMmJihyLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxyKSksci5kZXRhaWxzKSwibmFtZXNwYWNlIikpLFRlKCIjI3RhcmdldE5hbWVzcGFjZSIsdCk/eFMoZSxIYShuLmdldEVDb250YWluaW5nQ2xhc3MoKSkpOnQpOm51bGx9ZnVuY3Rpb24gbVRuKGUsbil7dmFyIHIsdCxvO2lmKHI9bi5nZXRFQW5ub3RhdGlvbihlLmFubm90YXRpb25VUkkpLHIpe2ZvcihvPXhuKHdzKCghci5kZXRhaWxzJiYoci5kZXRhaWxzPW5ldyBiYSgoUGUoKSxCdCksQm8scikpLHIuZGV0YWlscyksIndoaXRlU3BhY2UiKSksdD0xO3Q8KEtpKCkscXRlKS5sZW5ndGg7Kyt0KWlmKFRlKHF0ZVt0XSxvKSlyZXR1cm4gdH1yZXR1cm4gMH1mdW5jdGlvbiB5VG4oZSxuKXt2YXIgcix0LG8saSxzLHUsYztpZihyPW4uZ2V0RUFubm90YXRpb24oZS5hbm5vdGF0aW9uVVJJKSxyJiYoYz14bih3cygoIXIuZGV0YWlscyYmKHIuZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLHIpKSxyLmRldGFpbHMpLCJ3aWxkY2FyZHMiKSksYyE9bnVsbCkpe2Zvcih0PW5ldyBRLGk9ZWYoYywiXFx3Iikscz0wLHU9aS5sZW5ndGg7czx1OysrcylvPWlbc10sVGUobywiIyNvdGhlciIpP2VlKHQsIiEjIyIreFMoZSxIYShuLmdldEVDb250YWluaW5nQ2xhc3MoKSkpKTpUZShvLCIjI2xvY2FsIik/dC5hcnJheS5wdXNoKG51bGwpOlRlKG8sIiMjdGFyZ2V0TmFtZXNwYWNlIik/ZWUodCx4UyhlLEhhKG4uZ2V0RUNvbnRhaW5pbmdDbGFzcygpKSkpOlJlKHQuYXJyYXksbyk7cmV0dXJuIHR9cmV0dXJuIE5lKCksTmUoKSxPdH1mdW5jdGlvbiBVZyhlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmO2lmKEVyKG4scik+PTApcmV0dXJuIHI7c3dpdGNoKFJkKHVvKGUscikpKXtjYXNlIDI6e2lmKFRlKCIiLGQwKGUsci5nZXRFQ29udGFpbmluZ0NsYXNzKCkpLmdldE5hbWUoKSkpe2lmKGM9eGIodW8oZSxyKSksdT1jMih1byhlLHIpKSxkPUt0ZShlLG4sYyx1KSxkKXJldHVybiBkO2ZvcihvPVl0ZShlLG4pLHM9MCxmPW8uc2l6ZV8xKCk7czxmOysrcylpZihkPWEoby5nZXRfMChzKSwxNzkpLFF0ZSh3Rih1byhlLGQpKSxjKSlyZXR1cm4gZH1yZXR1cm4gbnVsbH1jYXNlIDQ6e2lmKFRlKCIiLGQwKGUsci5nZXRFQ29udGFpbmluZ0NsYXNzKCkpLmdldE5hbWUoKSkpe2Zvcih0PXI7dDt0PVJUbih1byhlLHQpKSlpZihfPXhiKHVvKGUsdCkpLHU9YzIodW8oZSx0KSksZD1YdGUoZSxuLF8sdSksZClyZXR1cm4gZDtpZihjPXhiKHVvKGUscikpLFRlKCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAzL1hNTFR5cGUiLGMpKXJldHVybiBKdGUoZSxuKTtmb3IoaT1tRihlLG4pLHM9MCxmPWkuc2l6ZV8xKCk7czxmOysrcylpZihkPWEoaS5nZXRfMChzKSwxNzkpLFF0ZSh3Rih1byhlLGQpKSxjKSlyZXR1cm4gZH1yZXR1cm4gbnVsbH1kZWZhdWx0OnJldHVybiBudWxsfX1mdW5jdGlvbiBZdGUoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtmb3IoZj13byhuKSxfPW51bGwsbz0hMSx1PTAsZD1RbyhmLnRoaXMkMDEpLnNpemVfMDt1PGQ7Kyt1KXM9YSh3YihmLHUsKGk9YShPKFFvKGYudGhpcyQwMSksdSksODkpLGM9aS5lUmF3VHlwZSxMKGMsOTApP2EoYywyOSk6KFBlKCksTmwpKSksMjkpLHI9WXRlKGUscyksci5pc0VtcHR5KCl8fChfPyhvfHwobz0hMCxfPW5ldyBfTChfKSksXy5hZGRBbGwocikpOl89cik7cmV0dXJuIHQ9U1RuKGUsbiksdC5pc0VtcHR5KCk/X3x8KE5lKCksTmUoKSxPdCk6Xz8ob3x8KF89bmV3IF9MKF8pKSxfLmFkZEFsbCh0KSxfKTp0fWZ1bmN0aW9uIG1GKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGY7Zm9yKGY9d28obiksXz1udWxsLHQ9ITEsdT0wLGQ9UW8oZi50aGlzJDAxKS5zaXplXzA7dTxkOysrdSlpPWEod2IoZix1LChvPWEoTyhRbyhmLnRoaXMkMDEpLHUpLDg5KSxjPW8uZVJhd1R5cGUsTChjLDkwKT9hKGMsMjkpOihQZSgpLE5sKSkpLDI5KSxyPW1GKGUsaSksci5pc0VtcHR5KCl8fChfPyh0fHwodD0hMCxfPW5ldyBfTChfKSksXy5hZGRBbGwocikpOl89cik7cmV0dXJuIHM9VFRuKGUsbikscy5pc0VtcHR5KCk/X3x8KE5lKCksTmUoKSxPdCk6Xz8odHx8KF89bmV3IF9MKF8pKSxfLmFkZEFsbChzKSxfKTpzfWZ1bmN0aW9uIHdUbihlLG4pe3ZhciByO3JldHVybiByPW4uZ2V0RUFubm90YXRpb24oZS5hbm5vdGF0aW9uVVJJKSxyfWZ1bmN0aW9uIEVUbihlLG4scil7dmFyIHQsbyxpO3JldHVybiBpPShvPWEyKGUucmVnaXN0cnksbiksbyksaSYmKHQ9YSgkTChiYihlLGkpLCIiKSwyOSksdCk/S3RlKGUsdCxuLHIpOm51bGx9ZnVuY3Rpb24gdlRuKGUsbixyLHQpe3ZhciBvO3JldHVybiBvPUt0ZShlLG4scix0KSwhbyYmKG89RVRuKGUscix0KSxvJiYhVWcoZSxuLG8pKT9udWxsOm99ZnVuY3Rpb24gU1RuKGUsbil7dmFyIHIsdCxvLGkscztmb3IodD0oIW4uZVN0cnVjdHVyYWxGZWF0dXJlcyYmKG4uZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSxuLDIxLDE3KSksbi5lU3RydWN0dXJhbEZlYXR1cmVzKSxpPW51bGwsbz0wLHM9dC5zaXplXzA7bzxzOysrbylzd2l0Y2gocj1hKE8odCxvKSwxNzkpLFJkKHVvKGUscikpKXtjYXNlIDI6Y2FzZSAzOiFpJiYoaT1uZXcgUSksUmUoaS5hcnJheSxyKX1yZXR1cm4gaXx8KE5lKCksTmUoKSxPdCl9ZnVuY3Rpb24geUYoZSxuLHIpe3ZhciB0LG8saTtyZXR1cm4gaT0obz1hMihlLnJlZ2lzdHJ5LG4pLG8pLGkmJih0PWEoJEwoYmIoZSxpKSwiIiksMjkpLHQpP1h0ZShlLHQsbixyKTpudWxsfWZ1bmN0aW9uIENUbihlLG4scix0KXt2YXIgbztyZXR1cm4gbz1YdGUoZSxuLHIsdCksIW8mJihvPXlGKGUscix0KSxvJiYhVWcoZSxuLG8pKT9udWxsOm99ZnVuY3Rpb24gVFRuKGUsbil7dmFyIHIsdCxvLGkscztmb3IodD0oIW4uZVN0cnVjdHVyYWxGZWF0dXJlcyYmKG4uZVN0cnVjdHVyYWxGZWF0dXJlcz1uZXcgVShSaSxuLDIxLDE3KSksbi5lU3RydWN0dXJhbEZlYXR1cmVzKSxpPW51bGwsbz0wLHM9dC5zaXplXzA7bzxzOysrbylzd2l0Y2gocj1hKE8odCxvKSwxNzkpLFJkKHVvKGUscikpKXtjYXNlIDQ6Y2FzZSA1OmNhc2UgNjp7IWkmJihpPW5ldyBRKSxSZShpLmFycmF5LHIpO2JyZWFrfX1yZXR1cm4gaXx8KE5lKCksTmUoKSxPdCl9ZnVuY3Rpb24gZDAoZSxuKXt2YXIgcix0O3JldHVybiByPWEobiw2OTEpLHQ9ci5nZXRFeHRlbmRlZE1ldGFEYXRhXzEoKSwhdCYmci5zZXRFeHRlbmRlZE1ldGFEYXRhXzEodD1MKG4sOTApP25ldyBGamUoZSxhKG4sMjkpKTpuZXcgemplKGUsYShuLDE1NikpKSx0fWZ1bmN0aW9uIGJiKGUsbil7dmFyIHIsdDtyZXR1cm4gcj1hKG4sNjkwKSx0PXIuZ2V0RXh0ZW5kZWRNZXRhRGF0YSgpLCF0JiZyLnNldEV4dGVuZGVkTWV0YURhdGEodD1uZXcgJGplKGUsbikpLHR9ZnVuY3Rpb24gdW8oZSxuKXt2YXIgcix0O3JldHVybiByPWEobiw2OTIpLHQ9ci5nZXRFeHRlbmRlZE1ldGFEYXRhXzAoKSwhdCYmci5zZXRFeHRlbmRlZE1ldGFEYXRhXzAodD1uZXcgQmplKGUsbikpLHR9ZnVuY3Rpb24gS3RlKGUsbixyLHQpe3ZhciBvLGkscyx1LGM7Zm9yKG89WXRlKGUsbiksdT0wLGM9by5zaXplXzEoKTt1PGM7Kyt1KWlmKGk9YShvLmdldF8wKHUpLDE3OSksVGUodCxjMih1byhlLGkpKSkpe2lmKHM9eGIodW8oZSxpKSkscj09bnVsbCl7aWYocz09bnVsbClyZXR1cm4gaX1lbHNlIGlmKFRlKHIscykpcmV0dXJuIGl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gWHRlKGUsbixyLHQpe3ZhciBvLGkscyx1LGM7Zm9yKG89bUYoZSxuKSx1PTAsYz1vLnNpemVfMSgpO3U8YzsrK3UpaWYoaT1hKG8uZ2V0XzAodSksMTc5KSxUZSh0LGMyKHVvKGUsaSkpKSl7aWYocz14Yih1byhlLGkpKSxyPT1udWxsKXtpZihzPT1udWxsKXJldHVybiBpfWVsc2UgaWYoVGUocixzKSlyZXR1cm4gaX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBKdGUoZSxuKXt2YXIgcix0LG8saTtzd2l0Y2goZDAoZSxuKS5nZXRDb250ZW50S2luZCgpKXtjYXNlIDM6Y2FzZSAyOntmb3Iocj1HZyhuKSxvPTAsaT1yLnNpemVfMDtvPGk7KytvKWlmKHQ9YShPKHIsbyksMzUpLFJkKHVvKGUsdCkpPT01KXJldHVybiB0O2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiB4UyhlLG4pe3JldHVybiBPVG4oYmIoZSxuKSk/bi5nZXROc1VSSSgpOm51bGx9ZnVuY3Rpb24gSWIoZSxuLHIpe3ZhciB0LG87cmV0dXJuIG89KHQ9YTIoZS5yZWdpc3RyeSxuKSx0KSxvPyRMKGJiKGUsbykscik6bnVsbH1mdW5jdGlvbiBadGUoZSxuLHIpe3JldHVybiAkTChiYihlLG4pLHIpfWZ1bmN0aW9uIFF0ZShlLG4pe3ZhciByLHQsbyxpO2lmKCFlLmlzRW1wdHkoKSl7Zm9yKHI9MCx0PWUuc2l6ZV8xKCk7cjx0OysrcilpZihpPXhuKGUuZ2V0XzAocikpLGk9PW51bGw/bj09bnVsbDpUZShpLnN1YnN0cigwLDMpLCIhIyMiKT9uIT1udWxsJiYobz1uLmxlbmd0aCwhVGUoaS5zdWJzdHIoaS5sZW5ndGgtbyxvKSxuKXx8aS5sZW5ndGghPW4ubGVuZ3RoKzMpJiYhVGUoImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDMvWE1MVHlwZSIsbik6VGUoaSwiIyNhbnkiKSYmIVRlKCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAzL1hNTFR5cGUiLG4pfHxUZShpLG4pKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIERqZSgpe3UyKCksYlRuLmNhbGwodGhpcywobl8oKSxQbCkpfWZ1bmN0aW9uIGJUbihlKXt0aGlzLmFubm90YXRpb25VUkk9KFZlKCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiKSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIiksdGhpcy5yZWdpc3RyeT1lLG5ldyBmdGV9cCg2MzQsMSx7fSxEamUpO3ZhciBGTCx6TDtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkJhc2ljRXh0ZW5kZWRNZXRhRGF0YSIsNjM0KTtmdW5jdGlvbiBJVG4oZSxuKXtlLmNvbnRlbnRLaW5kPW59ZnVuY3Rpb24geFRuKGUsbil7ZS5uYW1lXzA9bn1mdW5jdGlvbiBGamUoZSxuKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmVDbGFzcz1ufXAoMTE4MSwxLHt9LEZqZSksbC5nZXRCYXNlVHlwZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldENvbnRlbnRLaW5kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGVudEtpbmQ9PS0yJiZJVG4odGhpcyxjVG4odGhpcy50aGlzJDAxLHRoaXMuZUNsYXNzKSksdGhpcy5jb250ZW50S2luZH0sbC5nZXRJdGVtVHlwZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLmdldE1lbWJlclR5cGVzPWZ1bmN0aW9uKCl7cmV0dXJuIE5lKCksTmUoKSxPdH0sbC5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZV8wPT0idW5pbml0aWFsaXplZCImJnhUbih0aGlzLFJqZSh0aGlzLnRoaXMkMDEsdGhpcy5lQ2xhc3MpKSx0aGlzLm5hbWVfMH0sbC5nZXRXaGl0ZVNwYWNlRmFjZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sbC5jb250ZW50S2luZD0tMixsLm5hbWVfMD0idW5pbml0aWFsaXplZCIsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJCYXNpY0V4dGVuZGVkTWV0YURhdGEvRUNsYXNzRXh0ZW5kZWRNZXRhRGF0YUltcGwiLDExODEpO2Z1bmN0aW9uIFBUbihlLG4pe2UuYmFzZVR5cGU9bn1mdW5jdGlvbiBOVG4oZSxuKXtlLml0ZW1UeXBlPW59ZnVuY3Rpb24gQVRuKGUsbil7ZS5tZW1iZXJUeXBlcz1ufWZ1bmN0aW9uIExUbihlLG4pe2UubmFtZV8wPW59ZnVuY3Rpb24ga1RuKGUsbil7ZS53aGl0ZVNwYWNlPW59ZnVuY3Rpb24gemplKGUsbil7dGhpcy50aGlzJDAxPWUsdGhpcy5iYXNlVHlwZT0odTIoKSxGTCksdGhpcy5pdGVtVHlwZT1GTCx0aGlzLmVEYXRhVHlwZT1ufXAoMTE4MiwxLHt9LHpqZSksbC5nZXRCYXNlVHlwZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJhc2VUeXBlPT0odTIoKSxGTCkmJlBUbih0aGlzLHVUbih0aGlzLnRoaXMkMDEsdGhpcy5lRGF0YVR5cGUpKSx0aGlzLmJhc2VUeXBlfSxsLmdldENvbnRlbnRLaW5kPWZ1bmN0aW9uKCl7cmV0dXJuIDB9LGwuZ2V0SXRlbVR5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtVHlwZT09KHUyKCksRkwpJiZOVG4odGhpcyxmVG4odGhpcy50aGlzJDAxLHRoaXMuZURhdGFUeXBlKSksdGhpcy5pdGVtVHlwZX0sbC5nZXRNZW1iZXJUeXBlcz1mdW5jdGlvbigpe3JldHVybiF0aGlzLm1lbWJlclR5cGVzJiZBVG4odGhpcyxwVG4odGhpcy50aGlzJDAxLHRoaXMuZURhdGFUeXBlKSksdGhpcy5tZW1iZXJUeXBlc30sbC5nZXROYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZV8wPT0idW5pbml0aWFsaXplZCImJkxUbih0aGlzLFJqZSh0aGlzLnRoaXMkMDEsdGhpcy5lRGF0YVR5cGUpKSx0aGlzLm5hbWVfMH0sbC5nZXRXaGl0ZVNwYWNlRmFjZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53aGl0ZVNwYWNlPT0tMiYma1RuKHRoaXMsbVRuKHRoaXMudGhpcyQwMSx0aGlzLmVEYXRhVHlwZSkpLHRoaXMud2hpdGVTcGFjZX0sbC5uYW1lXzA9InVuaW5pdGlhbGl6ZWQiLGwud2hpdGVTcGFjZT0tMixnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkJhc2ljRXh0ZW5kZWRNZXRhRGF0YS9FRGF0YVR5cGVFeHRlbmRlZE1ldGFEYXRhSW1wbCIsMTE4Mik7ZnVuY3Rpb24gJEwoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQsZjtpZihkPW51bGwsZS5uYW1lVG9DbGFzc2lmaWVyTWFwJiYoZD1hKG5pKGUubmFtZVRvQ2xhc3NpZmllck1hcCxuKSwxNDIpKSwhZCl7aWYoaT1lLmVQYWNrYWdlLmdldEVDbGFzc2lmaWVycygpLGY9aS5zaXplXzAsIWUubmFtZVRvQ2xhc3NpZmllck1hcHx8VjIoZS5uYW1lVG9DbGFzc2lmaWVyTWFwKSE9Zil7Zm9yKGM9bmV3IHNuLGUubmFtZVRvQ2xhc3NpZmllck1hcCYmYjIoYyxlLm5hbWVUb0NsYXNzaWZpZXJNYXApLF89Yy5oYXNoQ29kZU1hcC5zaXplXzArYy5zdHJpbmdNYXAuc2l6ZV8wLHU9Xzt1PGY7Kyt1KXQ9YShPKGksdSksMTQyKSxvPWQwKGUudGhpcyQwMSx0KS5nZXROYW1lKCkscj1hKG89PW51bGw/ZGkoYy5oYXNoQ29kZU1hcCxudWxsLHQpOmsxKGMuc3RyaW5nTWFwLG8sdCksMTQyKSxyJiZyIT10JiYobz09bnVsbD9kaShjLmhhc2hDb2RlTWFwLG51bGwscik6azEoYy5zdHJpbmdNYXAsbyxyKSk7aWYoYy5oYXNoQ29kZU1hcC5zaXplXzArYy5zdHJpbmdNYXAuc2l6ZV8wIT1mKWZvcihzPTA7czxfOysrcyl0PWEoTyhpLHMpLDE0Miksbz1kMChlLnRoaXMkMDEsdCkuZ2V0TmFtZSgpLHI9YShvPT1udWxsP2RpKGMuaGFzaENvZGVNYXAsbnVsbCx0KTprMShjLnN0cmluZ01hcCxvLHQpLDE0MiksciYmciE9dCYmKG89PW51bGw/ZGkoYy5oYXNoQ29kZU1hcCxudWxsLHIpOmsxKGMuc3RyaW5nTWFwLG8scikpO2UubmFtZVRvQ2xhc3NpZmllck1hcD1jfWQ9YShuaShlLm5hbWVUb0NsYXNzaWZpZXJNYXAsbiksMTQyKX1yZXR1cm4gZH1mdW5jdGlvbiBPVG4oZSl7dmFyIG47cmV0dXJuIGUuaXNJbml0aWFsaXplZHx8TVRuKGUsKG49d1RuKGUudGhpcyQwMSxlLmVQYWNrYWdlKSwhbnx8IVRlKCJmYWxzZSIsd3MoKCFuLmRldGFpbHMmJihuLmRldGFpbHM9bmV3IGJhKChQZSgpLEJ0KSxCbyxuKSksbi5kZXRhaWxzKSwicXVhbGlmaWVkIikpKSksZS5pc1F1YWxpZmllZH1mdW5jdGlvbiBNVG4oZSxuKXtlLmlzUXVhbGlmaWVkPW4sZS5pc0luaXRpYWxpemVkPSEwfWZ1bmN0aW9uICRqZShlLG4pe3RoaXMudGhpcyQwMT1lLHRoaXMuZVBhY2thZ2U9bn1wKDExODAsMSx7fSwkamUpLGwuaXNJbml0aWFsaXplZD0hMSxsLmlzUXVhbGlmaWVkPSExLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiQmFzaWNFeHRlbmRlZE1ldGFEYXRhL0VQYWNrYWdlRXh0ZW5kZWRNZXRhRGF0YUltcGwiLDExODApO2Z1bmN0aW9uIFJUbihlKXtyZXR1cm4gZS5hZmZpbGlhdGlvbj09KHUyKCksekwpJiZEVG4oZSxzVG4oZS50aGlzJDAxLGUuZVN0cnVjdHVyYWxGZWF0dXJlKSksZS5hZmZpbGlhdGlvbn1mdW5jdGlvbiBSZChlKXtyZXR1cm4gZS5mZWF0dXJlS2luZD09LTImJkZUbihlLF9UbihlLnRoaXMkMDEsZS5lU3RydWN0dXJhbEZlYXR1cmUpKSxlLmZlYXR1cmVLaW5kfWZ1bmN0aW9uIFBtKGUpe3JldHVybiBlLmdyb3VwXzA9PSh1MigpLHpMKSYmelRuKGUsZFRuKGUudGhpcyQwMSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZSkpLGUuZ3JvdXBfMH1mdW5jdGlvbiBjMihlKXtyZXR1cm4gZS5uYW1lXzA9PSJ1bmluaXRpYWxpemVkIiYmJFRuKGUsZ1RuKGUudGhpcyQwMSxlLmVTdHJ1Y3R1cmFsRmVhdHVyZSkpLGUubmFtZV8wfWZ1bmN0aW9uIHhiKGUpe3JldHVybiBlLm5hbWVzcGFjZT09InVuaW5pdGlhbGl6ZWQiJiZCVG4oZSxoVG4oZS50aGlzJDAxLGUuZVN0cnVjdHVyYWxGZWF0dXJlKSksZS5uYW1lc3BhY2V9ZnVuY3Rpb24gd0YoZSl7cmV0dXJuIWUud2lsZGNhcmRzJiZHVG4oZSx5VG4oZS50aGlzJDAxLGUuZVN0cnVjdHVyYWxGZWF0dXJlKSksZS53aWxkY2FyZHN9ZnVuY3Rpb24gRFRuKGUsbil7ZS5hZmZpbGlhdGlvbj1ufWZ1bmN0aW9uIEZUbihlLG4pe2UuZmVhdHVyZUtpbmQ9bn1mdW5jdGlvbiB6VG4oZSxuKXtlLmdyb3VwXzA9bn1mdW5jdGlvbiAkVG4oZSxuKXtlLm5hbWVfMD1ufWZ1bmN0aW9uIEJUbihlLG4pe2UubmFtZXNwYWNlPW59ZnVuY3Rpb24gR1RuKGUsbil7ZS53aWxkY2FyZHM9bn1mdW5jdGlvbiBCamUoZSxuKXt0aGlzLnRoaXMkMDE9ZSx0aGlzLmdyb3VwXzA9KHUyKCksekwpLHRoaXMuYWZmaWxpYXRpb249ekwsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmU9bn1wKDExODMsMSx7fSxCamUpLGwuZmVhdHVyZUtpbmQ9LTIsbC5uYW1lXzA9InVuaW5pdGlhbGl6ZWQiLGwubmFtZXNwYWNlPSJ1bmluaXRpYWxpemVkIixnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkJhc2ljRXh0ZW5kZWRNZXRhRGF0YS9FU3RydWN0dXJhbEZlYXR1cmVFeHRlbmRlZE1ldGFEYXRhSW1wbCIsMTE4Myk7ZnVuY3Rpb24gQkwoZSxuLHIpe3FyZS5jYWxsKHRoaXMsZSxuKSx0aGlzLmZlYXR1cmVJRD1yfXAoNTkzLDYzMixFbyxCTCksbC5nZXRGZWF0dXJlSURfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZlYXR1cmVJRH0sbC5pc0VPYmplY3Q9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5yZXNvbHZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHJ9LGwuZmVhdHVyZUlEPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFRGF0YVR5cGVFTGlzdCIsNTkzKTt2YXIgZW9lPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkZlYXR1cmVNYXAiKTtmdW5jdGlvbiBIVG4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYztpZihvPXIsaT1vLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLENjKGUub3duZXIsaSkpe2lmKGkuaXNVbmlxdWUoKSl7Zm9yKHQ9YShlLmRhdGFfMCwxMjQpLHM9MDtzPGUuc2l6ZV8wOysrcylpZih1PXRbc10sWW4odSxvKSYmcyE9bil0aHJvdyBiKG5ldyBHZSgiVGhlICdubyBkdXBsaWNhdGVzJyBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpfX1lbHNlIGZvcihjPUlpKGUub3duZXIuZUNsYXNzXzAoKSxpKSx0PWEoZS5kYXRhXzAsMTI0KSxzPTA7czxlLnNpemVfMDsrK3MpaWYodT10W3NdLGMuaXNWYWxpZCh1LmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl0aHJvdyBiKG5ldyBHZSgiVGhlIG11bHRpcGxpY2l0eSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpO2ZTKGUsbixyKX1mdW5jdGlvbiBHamUoZSxuLHIsdCl7dmFyIG8saSxzLHUsYztpZih1PShIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSksQ2MoZS5vd25lcixuKSl7aWYobi5pc1VuaXF1ZSgpJiZVTChlLG4sdCxMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCkpdGhyb3cgYihuZXcgR2UoIlRoZSAnbm8gZHVwbGljYXRlcycgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKX1lbHNlIGZvcihjPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxvPWEoZS5kYXRhXzAsMTI0KSxzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLGMuaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl0aHJvdyBiKG5ldyBHZSgiVGhlIG11bHRpcGxpY2l0eSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpO2ZTKGUsb29lKGUsbixyKSx1P2EodCw3Nik6VnUobix0KSl9ZnVuY3Rpb24gbm9lKGUsbixyKXt2YXIgdCxvLGkscyx1O2lmKHM9KEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpKSxDYyhlLm93bmVyLG4pKXtpZihuLmlzVW5pcXVlKCkmJlVMKGUsbixyLEwobiwxMDIpJiYoYShuLDE5KS5lRmxhZ3MmRnQpIT0wKSlyZXR1cm4hMX1lbHNlIGZvcih1PUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSx0PWEoZS5kYXRhXzAsMTI0KSxpPTA7aTxlLnNpemVfMDsrK2kpaWYobz10W2ldLHUuaXNWYWxpZChvLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSlyZXR1cm4ocz9ZbihvLHIpOnI9PW51bGw/by5nZXRWYWx1ZSgpPT1udWxsOlluKHIsby5nZXRWYWx1ZSgpKSk/ITE6KGEoemcoZSxpLHM/YShyLDc2KTpWdShuLHIpKSw3NiksITApO3JldHVybiBwbihlLHM/YShyLDc2KTpWdShuLHIpKX1mdW5jdGlvbiBVVG4oZSxuKXt2YXIgcix0LG8saSxzLHU7aWYodD1uLG89dC5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxDYyhlLm93bmVyLG8pKXtpZihvLmlzVW5pcXVlKCkmJkhMKGUsbyx0LmdldFZhbHVlKCkpKXJldHVybiExfWVsc2UgZm9yKHU9SWkoZS5vd25lci5lQ2xhc3NfMCgpLG8pLHI9YShlLmRhdGFfMCwxMjQpLGk9MDtpPGUuc2l6ZV8wOysraSlpZihzPXJbaV0sdS5pc1ZhbGlkKHMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXJldHVybiBZbihzLHQpPyExOihhKHpnKGUsaSxuKSw3NiksITApO3JldHVybiBwbihlLG4pfWZ1bmN0aW9uIFdUbihlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZCxmO2lmKHQuc2l6ZV8xKCk9PTApcmV0dXJuITE7aWYoYz0oSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCkpLHM9Yz90Om5ldyBQZCh0LnNpemVfMSgpKSxDYyhlLm93bmVyLG4pKXtpZihuLmlzVW5pcXVlKCkpZm9yKGQ9dC5pdGVyYXRvcl8wKCk7ZC5oYXNOZXh0XzAoKTspXz1kLm5leHRfMSgpLFVMKGUsbixfLEwobiwxMDIpJiYoYShuLDE5KS5lRmxhZ3MmRnQpIT0wKXx8KGk9VnUobixfKSxzLmFkZF8yKGkpKTtlbHNlIGlmKCFjKWZvcihkPXQuaXRlcmF0b3JfMCgpO2QuaGFzTmV4dF8wKCk7KV89ZC5uZXh0XzEoKSxpPVZ1KG4sXykscy5hZGRfMihpKX1lbHNle2ZvcihmPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxvPWEoZS5kYXRhXzAsMTI0KSx1PTA7dTxlLnNpemVfMDsrK3UpaWYoaT1vW3VdLGYuaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl0aHJvdyBiKG5ldyBHZSgiVGhlIG11bHRpcGxpY2l0eSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpO2lmKHQuc2l6ZV8xKCk+MSl0aHJvdyBiKG5ldyBHZSgiVGhlIG11bHRpcGxpY2l0eSBjb25zdHJhaW50IGlzIHZpb2xhdGVkIikpO2N8fChpPVZ1KG4sdC5pdGVyYXRvcl8wKCkubmV4dF8xKCkpLHMuYWRkXzIoaSkpfXJldHVybiBxbmUoZSxvb2UoZSxuLHIpLHMpfWZ1bmN0aW9uIGpUbihlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtpZihyLnNpemVfMSgpPT0wKXJldHVybiExO2lmKHU9KEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpKSxpPXU/cjpuZXcgUGQoci5zaXplXzEoKSksQ2MoZS5vd25lcixuKSl7aWYobi5pc1VuaXF1ZSgpKWZvcihfPXIuaXRlcmF0b3JfMCgpO18uaGFzTmV4dF8wKCk7KWM9Xy5uZXh0XzEoKSxVTChlLG4sYyxMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCl8fChvPVZ1KG4sYyksaS5jb250YWlucyhvKXx8aS5hZGRfMihvKSk7ZWxzZSBpZighdSlmb3IoXz1yLml0ZXJhdG9yXzAoKTtfLmhhc05leHRfMCgpOyljPV8ubmV4dF8xKCksbz1WdShuLGMpLGkuYWRkXzIobyl9ZWxzZXtpZihyLnNpemVfMSgpPjEpdGhyb3cgYihuZXcgR2UoIlRoZSBtdWx0aXBsaWNpdHkgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKTtmb3IoZD1JaShlLm93bmVyLmVDbGFzc18wKCksbiksdD1hKGUuZGF0YV8wLDEyNCkscz0wO3M8ZS5zaXplXzA7KytzKWlmKG89dFtzXSxkLmlzVmFsaWQoby5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpe2lmKHIuY29udGFpbnModT9vOm8uZ2V0VmFsdWUoKSkpcmV0dXJuITE7Zm9yKF89ci5pdGVyYXRvcl8wKCk7Xy5oYXNOZXh0XzAoKTspYz1fLm5leHRfMSgpLGEoemcoZSxzLHU/YShjLDc2KTpWdShuLGMpKSw3Nik7cmV0dXJuITB9dXx8KG89VnUobixyLml0ZXJhdG9yXzAoKS5uZXh0XzEoKSksaS5hZGRfMihvKSl9cmV0dXJuIFByKGUsaSl9ZnVuY3Rpb24gVlRuKGUsbixyLHQpe3ZhciBvO2UubW9kQ291bnQ9LTEsZ3JlKGUsb29lKGUsbixyKSwoSHQoKSxvPWEobiw2OSkuZ2V0RmVhdHVyZU1hcEVudHJ5UHJvdG90eXBlKCksby5jcmVhdGVFbnRyeSh0KSkpfWZ1bmN0aW9uIHFUbihlLG4pe3ZhciByLHQsbyxpO2UubW9kQ291bnQ9LTEsVGEoZS5vd25lcik/KHI9ZS5zaXplXzAsaT1lLnNpemVfMCE9MCxzYihlLG4pLHQ9bmV3IFNjKGUub3duZXIsMyxlLmZlYXR1cmVJRCxudWxsLG4scixpKSxvPW4uaW52ZXJzZUFkZF8wKGUub3duZXIsZS5mZWF0dXJlSUQsbnVsbCksbz1xamUoZSxuLG8pLG8/KG8uYWRkXzUodCksby5kaXNwYXRjaF8wKCkpOlhuKGUub3duZXIsdCkpOihzYihlLG4pLG89bi5pbnZlcnNlQWRkXzAoZS5vd25lcixlLmZlYXR1cmVJRCxudWxsKSxvJiZvLmRpc3BhdGNoXzAoKSl9ZnVuY3Rpb24gWVRuKGUsbil7KytlLm1vZENvdW50LHZGKGUsZS5zaXplXzAsbikscVRuKGUsYShuLDM0MykpfWZ1bmN0aW9uIHJvZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF87aWYocj09bnVsbCl7Zm9yKG89YShlLmRhdGFfMCwxMjQpLHU9MDt1PGUuc2l6ZV8wOysrdSlpZihzPW9bdV0scy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKT09bilyZXR1cm4gRHQoZSxzLHQpfXJldHVybiBpPShIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKT9hKHIsNzYpOlZ1KG4scikpLFRhKGUub3duZXIpPyhfPSFBYihlLG4pLHQ9aGkoZSxpLHQpLGM9bi5pc01hbnkoKT9hXyhlLDMsbixudWxsLHIsXzIoZSxuLHIsTChuLDEwMikmJihhKG4sMTkpLmVGbGFncyZGdCkhPTApLF8pOmFfKGUsMSxuLG4uZ2V0RGVmYXVsdFZhbHVlKCksciwtMSxfKSx0P3QuYWRkXzUoYyk6dD1jKTp0PWhpKGUsaSx0KSx0fWZ1bmN0aW9uIEhqZShlLG4pe3JldHVybiBuZXcgZDIobixlKX1mdW5jdGlvbiBLVG4oZSxuKXtyZXR1cm4gbmV3IGQyKG4sZSl9ZnVuY3Rpb24gWFRuKGUsbixyKXt2YXIgdCxvO2ZvcihvPW5ldyBkMihuLGUpLHQ9MDt0PHI7Kyt0KXFMKG8pO3JldHVybiBvfWZ1bmN0aW9uIFBiKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYoTChuLDc2KSlyZXR1cm4gRHQoZSxuLHIpO2Zvcih1PW51bGwsaT1udWxsLHQ9YShlLmRhdGFfMCwxMjQpLHM9MDtzPGUuc2l6ZV8wOysrcylpZihvPXRbc10sWW4obixvLmdldFZhbHVlKCkpJiYoaT1vLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLEwoaSwxMDIpJiZhKGksMTkpLmVGbGFncyZHbykpe3U9bzticmVha31yZXR1cm4gdSYmKFRhKGUub3duZXIpJiYoYz1pLmlzTWFueSgpP2FfKGUsNCxpLG4sbnVsbCxfMihlLGksbixMKGksMTAyKSYmKGEoaSwxOSkuZUZsYWdzJkZ0KSE9MCksITApOmFfKGUsaS5pc1Vuc2V0dGFibGUoKT8yOjEsaSxuLGkuZ2V0RGVmYXVsdFZhbHVlKCksLTEsITApLHI/ci5hZGRfNShjKTpyPWMpLHI9UGIoZSx1LHIpKSxyfWZ1bmN0aW9uIHRvZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF8sZDtpZihkPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxvPTAsaT1hKGUuZGF0YV8wLDEyNCksYz1udWxsLEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpKXtmb3IodT0wO3U8ZS5zaXplXzA7Kyt1KWlmKHM9aVt1XSxkLmlzVmFsaWQocy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpe2lmKFluKHMscikpe2M9czticmVha30rK299fWVsc2UgaWYociE9bnVsbCl7Zm9yKHU9MDt1PGUuc2l6ZV8wOysrdSlpZihzPWlbdV0sZC5pc1ZhbGlkKHMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXtpZihZbihyLHMuZ2V0VmFsdWUoKSkpe2M9czticmVha30rK299fWVsc2UgZm9yKHU9MDt1PGUuc2l6ZV8wOysrdSlpZihzPWlbdV0sZC5pc1ZhbGlkKHMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXtpZihzLmdldFZhbHVlKCk9PW51bGwpe2M9czticmVha30rK299cmV0dXJuIGMmJihUYShlLm93bmVyKSYmKF89bi5pc01hbnkoKT9uZXcgUEYoZS5vd25lciw0LG4scixudWxsLG8sITApOmFfKGUsbi5pc1Vuc2V0dGFibGUoKT8yOjEsbixyLG4uZ2V0RGVmYXVsdFZhbHVlKCksLTEsITApLHQ/dC5hZGRfNShfKTp0PV8pLHQ9UGIoZSxjLHQpKSx0fWZ1bmN0aW9uIEdMKGUsbil7dmFyIHIsdCxvLGkscztmb3Iocz1JaShlLm93bmVyLmVDbGFzc18wKCksbiksbz1uZXcgUUEscj1hKGUuZGF0YV8wLDEyNCksaT1lLnNpemVfMDstLWk+PTA7KXQ9cltpXSxzLmlzVmFsaWQodC5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJnBuKG8sdCk7IWNHZShlLG8pJiZUYShlLm93bmVyKSYmdDIoZSxuLmlzTWFueSgpP2FfKGUsNixuLChOZSgpLE90KSxudWxsLC0xLCExKTphXyhlLG4uaXNVbnNldHRhYmxlKCk/MjoxLG4sbnVsbCxudWxsLC0xLCExKSl9ZnVuY3Rpb24gSEwoZSxuLHIpe3JldHVybiBVTChlLG4scixMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCl9ZnVuY3Rpb24gVUwoZSxuLHIsdCl7dmFyIG8saSxzLHUsYztpZihjPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxvPWEoZS5kYXRhXzAsMTI0KSxIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSl7Zm9yKHM9MDtzPGUuc2l6ZV8wOysrcylpZihpPW9bc10sYy5pc1ZhbGlkKGkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiZZbihpLHIpKXJldHVybiEwfWVsc2UgaWYociE9bnVsbCl7Zm9yKHU9MDt1PGUuc2l6ZV8wOysrdSlpZihpPW9bdV0sYy5pc1ZhbGlkKGkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiZZbihyLGkuZ2V0VmFsdWUoKSkpcmV0dXJuITA7aWYodCl7Zm9yKHM9MDtzPGUuc2l6ZV8wOysrcylpZihpPW9bc10sYy5pc1ZhbGlkKGkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiZEKHIpPT09RChFRihlLGEoaS5nZXRWYWx1ZSgpLDU4KSkpKXJldHVybiEwfX1lbHNlIGZvcihzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLGMuaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSYmaS5nZXRWYWx1ZSgpPT1udWxsKXJldHVybiExO3JldHVybiExfWZ1bmN0aW9uIEpUbihlLG4scil7dmFyIHQ7Zm9yKHQ9ci5pdGVyYXRvcl8wKCk7dC5oYXNOZXh0XzAoKTspaWYoIUhMKGUsbix0Lm5leHRfMSgpKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBhXyhlLG4scix0LG8saSxzKXtyZXR1cm4gbmV3IFBGKGUub3duZXIsbixyLHQsbyxpLHMpfWZ1bmN0aW9uIG9vZShlLG4scil7dmFyIHQsbyxpLHMsdSxjO2ZvcihjPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSx0PTAsdT1lLnNpemVfMCxvPWEoZS5kYXRhXzAsMTI0KSxzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLGMuaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7aWYocj09dClyZXR1cm4gczsrK3QsdT1zKzF9aWYocj09dClyZXR1cm4gdTt0aHJvdyBiKG5ldyBubygiaW5kZXg9IityKyIsIHNpemU9Iit0KSl9ZnVuY3Rpb24gV0woZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2lmKGM9SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLGk9YShlLmRhdGFfMCwxMjQpLENjKGUub3duZXIsbikpe2ZvcihvPTAsdT0wO3U8ZS5zaXplXzA7Kyt1KWlmKHM9aVt1XSxjLmlzVmFsaWQocy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpe2lmKG89PXIpcmV0dXJuIEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpP3M6KF89cy5nZXRWYWx1ZSgpLF8hPW51bGwmJnQmJkwobiwxMDIpJiZhKG4sMTkpLmVGbGFncyZGdCYmKF89UFMoZSxuLHUsbyxfKSksXyk7KytvfXRocm93IGIobmV3IG5vKCJpbmRleD0iK3IrIiwgc2l6ZT0iK28pKX1lbHNle2ZvcihvPTAsdT0wO3U8ZS5zaXplXzA7Kyt1KXtpZihzPWlbdV0sYy5pc1ZhbGlkKHMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXJldHVybiBIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKT9zOihfPXMuZ2V0VmFsdWUoKSxfIT1udWxsJiZ0JiZMKG4sMTAyKSYmYShuLDE5KS5lRmxhZ3MmRnQmJihfPVBTKGUsbix1LG8sXykpLF8pOysrb31yZXR1cm4gbi5nZXREZWZhdWx0VmFsdWUoKX19ZnVuY3Rpb24gTmIoZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQ7aWYobz1hKGUuZGF0YV8wLDEyNCksQ2MoZS5vd25lcixuKSlyZXR1cm4gSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCk/bmV3IFhMKG4sZSk6bmV3IGtiKG4sZSk7Zm9yKF89SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLHQ9MCx1PTA7dTxlLnNpemVfMDsrK3Upe2lmKGk9b1t1XSxzPWkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksXy5pc1ZhbGlkKHMpKXtpZihIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSlyZXR1cm4gaTtpZihzPT0oQW0oKSxrbSl8fHM9PUxtKXtmb3IoYz1uZXcgTGEodm8oaS5nZXRWYWx1ZSgpKSk7Kyt1PGUuc2l6ZV8wOylpPW9bdV0scz1pLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLChzPT1rbXx8cz09TG0pJiZPbihjLHZvKGkuZ2V0VmFsdWUoKSkpO3JldHVybiBnb2UoYShuLmdldEVUeXBlKCksMTU2KSxjLnN0cmluZyl9ZWxzZSByZXR1cm4gZD1pLmdldFZhbHVlKCksZCE9bnVsbCYmciYmTChuLDEwMikmJmEobiwxOSkuZUZsYWdzJkZ0JiYoZD1QUyhlLG4sdSx0LGQpKSxkfSsrdH1yZXR1cm4gbi5nZXREZWZhdWx0VmFsdWUoKX1mdW5jdGlvbiBaVG4oZSxuLHIpe3JldHVybiBfMihlLG4scixMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCl9ZnVuY3Rpb24gXzIoZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfO2lmKF89SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLGM9MCxvPWEoZS5kYXRhXzAsMTI0KSxIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSl7Zm9yKHM9MDtzPGUuc2l6ZV8wOysrcylpZihpPW9bc10sXy5pc1ZhbGlkKGkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXtpZihZbihpLHIpKXJldHVybiBjOysrY319ZWxzZSBpZihyIT1udWxsKXtmb3IodT0wO3U8ZS5zaXplXzA7Kyt1KWlmKGk9b1t1XSxfLmlzVmFsaWQoaS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpe2lmKFluKHIsaS5nZXRWYWx1ZSgpKSlyZXR1cm4gYzsrK2N9aWYodCl7Zm9yKGM9MCxzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLF8uaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7aWYoRChyKT09PUQoRUYoZSxhKGkuZ2V0VmFsdWUoKSw1OCkpKSlyZXR1cm4gYzsrK2N9fX1lbHNlIGZvcihzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLF8uaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7aWYoaS5nZXRWYWx1ZSgpPT1udWxsKXJldHVybiBjOysrY31yZXR1cm4tMX1mdW5jdGlvbiBRVG4oZSxuLHIpe3JldHVybiBuLmludmVyc2VBZGRfMChlLm93bmVyLGUuZmVhdHVyZUlELHIpfWZ1bmN0aW9uIGVibihlLG4scil7cmV0dXJuIFFUbihlLGEobiwzNDMpLHIpfWZ1bmN0aW9uIG5ibihlLG4scil7cmV0dXJuIG4uaW52ZXJzZVJlbW92ZV8wKGUub3duZXIsZS5mZWF0dXJlSUQscil9ZnVuY3Rpb24gaW9lKGUsbixyKXtyZXR1cm4gbmJuKGUsYShuLDM0Mykscil9ZnVuY3Rpb24gQWIoZSxuKXt2YXIgcix0LG8saTtmb3IoaT1JaShlLm93bmVyLmVDbGFzc18wKCksbikscj1hKGUuZGF0YV8wLDEyNCksbz0wO288ZS5zaXplXzA7KytvKWlmKHQ9cltvXSxpLmlzVmFsaWQodC5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gcmJuKGUsbil7cmV0dXJuIEwobiwxMDIpJiZhKG4sMTkpLmVGbGFncyZGdD9uZXcgQ0YobixlKTpuZXcgZDIobixlKX1mdW5jdGlvbiBzaShlLG4pe3JldHVybiBIdCgpLEREKG4pP25ldyBYTChuLGUpOm5ldyBrYihuLGUpfWZ1bmN0aW9uIHRibihlLG4pe3JldHVybiBMKG4sMTAyKSYmYShuLDE5KS5lRmxhZ3MmRnQ/bmV3IENGKG4sZSk6bmV3IGQyKG4sZSl9ZnVuY3Rpb24gb2JuKGUsbixyKXt2YXIgdCxvO2ZvcihvPUwobiwxMDIpJiZhKG4sMTkpLmVGbGFncyZGdD9uZXcgQ0YobixlKTpuZXcgZDIobixlKSx0PTA7dDxyOysrdClxTChvKTtyZXR1cm4gb31mdW5jdGlvbiBpYm4oZSxuLHIpe3ZhciB0LG8saSxzLHUsYyxfLGQsZixoLG0seTtpZihUYShlLm93bmVyKSl7aWYobiE9ciYmKG89YShlLmRhdGFfMCwxMjQpLG09b1tyXSxzPW0uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksQ2MoZS5vd25lcixzKSkpe2Zvcih5PUlpKGUub3duZXIuZUNsYXNzXzAoKSxzKSxjPS0xLHU9LTEsdD0wLF89MCxmPW4+cj9uOnI7Xzw9ZjsrK18pXz09cj91PXQrKzooaT1vW19dLGQ9eS5pc1ZhbGlkKGkuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpLF89PW4mJihjPV89PWYmJiFkP3QtMTp0KSxkJiYrK3QpO3JldHVybiBoPWEobVMoZSxuLHIpLDc2KSx1IT1jJiZ0MihlLG5ldyBDYihlLm93bmVyLDcscyxKKHUpLG0uZ2V0VmFsdWUoKSxjKSksaH19ZWxzZSByZXR1cm4gYShkRChlLG4sciksNzYpO3JldHVybiBhKG1TKGUsbixyKSw3Nil9ZnVuY3Rpb24gVWplKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXyxkLGY7aWYoQ2MoZS5vd25lcixuKSl7Zm9yKGY9SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLGk9YShlLmRhdGFfMCwxMjQpLGQ9bnVsbCxjPS0xLHU9LTEsbz0wLF89MDtfPGUuc2l6ZV8wOysrXylzPWlbX10sZi5pc1ZhbGlkKHMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiYobz09ciYmKGM9Xyksbz09dCYmKHU9XyxkPXMuZ2V0VmFsdWUoKSksKytvKTtpZihjPT0tMSl0aHJvdyBiKG5ldyBubygidGFyZ2V0SW5kZXg9IityKyIsIHNpemU9IitvKSk7aWYodT09LTEpdGhyb3cgYihuZXcgbm8oInNvdXJjZUluZGV4PSIrdCsiLCBzaXplPSIrbykpO3JldHVybiBtUyhlLGMsdSksVGEoZS5vd25lcikmJnQyKGUsYV8oZSw3LG4sSih0KSxkLHIsITApKSxkfWVsc2UgdGhyb3cgYihuZXcgR2UoIlRoZSBmZWF0dXJlIG11c3QgYmUgbWFueS12YWx1ZWQgdG8gc3VwcG9ydCBtb3ZlIikpfWZ1bmN0aW9uIGFibihlLG4scix0KXtVamUoZSxuLHIsXzIoZSxuLHQsTChuLDEwMikmJihhKG4sMTkpLmVGbGFncyZGdCkhPTApKX1mdW5jdGlvbiBXamUoZSxuLHIpe3ZhciB0LG8saSxzLHU7Zm9yKHU9SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLG89YShlLmRhdGFfMCwxMjQpLHQ9MCxzPTA7czxlLnNpemVfMDsrK3MpaWYoaT1vW3NdLHUuaXNWYWxpZChpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7aWYodD09cilyZXR1cm4gWmYoZSxzKSxIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKT9pOmkuZ2V0VmFsdWUoKTsrK3R9dGhyb3cgYihuZXcgbm8oImluZGV4PSIrcisiLCBzaXplPSIrdCkpfWZ1bmN0aW9uIGxibihlLG4scil7dmFyIHQsbyxpLHM7aWYocz1JaShlLm93bmVyLmVDbGFzc18wKCksbiksdD1hKGUuZGF0YV8wLDEyNCksSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCkpe2ZvcihpPTA7aTxlLnNpemVfMDsrK2kpaWYobz10W2ldLHMuaXNWYWxpZChvLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSYmWW4obyxyKSlyZXR1cm4gWmYoZSxpKSwhMH1lbHNlIGlmKHIhPW51bGwpe2ZvcihpPTA7aTxlLnNpemVfMDsrK2kpaWYobz10W2ldLHMuaXNWYWxpZChvLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSYmWW4ocixvLmdldFZhbHVlKCkpKXJldHVybiBaZihlLGkpLCEwfWVsc2UgZm9yKGk9MDtpPGUuc2l6ZV8wOysraSlpZihvPXRbaV0scy5pc1ZhbGlkKG8uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiZvLmdldFZhbHVlKCk9PW51bGwpcmV0dXJuIFpmKGUsaSksITA7cmV0dXJuITF9ZnVuY3Rpb24gc2JuKGUsbixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2lmKHM9ci5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxMKHMsMTAyKSYmYShzLDE5KS5lRmxhZ3MmRnQmJihoPWEoci5nZXRWYWx1ZSgpLDU0KSxFPUowKGUub3duZXIsaCksRSE9aCkpe2lmKGQ9VnUocyxFKSxwUyhlLG4sdkYoZSxuLGQpKSxmPW51bGwsVGEoZS5vd25lcikmJih0PVVnKChLaSgpLFR0KSxlLm93bmVyLmVDbGFzc18wKCkscyksdCE9a2UoZS5vd25lci5lQ2xhc3NfMCgpLGUuZmVhdHVyZUlEKSkpe2Zvcih2PUlpKGUub3duZXIuZUNsYXNzXzAoKSxzKSx1PTAsaT1hKGUuZGF0YV8wLDEyNCksYz0wO2M8bjsrK2Mpbz1pW2NdLHYuaXNWYWxpZChvLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSYmKyt1O2Y9bmV3IFBGKGUub3duZXIsOSx0LGgsRSx1LCExKSxmLmFkZF81KG5ldyBTYyhlLm93bmVyLDksZS5mZWF0dXJlSUQscixkLG4sITEpKX1yZXR1cm4geT1hKHMsMTkpLG09R3QoeSksbT8oZj1oLmVJbnZlcnNlUmVtb3ZlKGUub3duZXIsRXIoaC5lQ2xhc3NfMCgpLG0pLG51bGwsZiksZj1hKEUsNTQpLmVJbnZlcnNlQWRkKGUub3duZXIsRXIoRS5lQ2xhc3NfMCgpLG0pLG51bGwsZikpOnkuZUZsYWdzJkdvJiYoXz0tMS1FcihlLm93bmVyLmVDbGFzc18wKCkseSksZj1oLmVJbnZlcnNlUmVtb3ZlKGUub3duZXIsXyxudWxsLG51bGwpLCFhKEUsNTQpLmVJbnRlcm5hbENvbnRhaW5lcigpJiYoZj1hKEUsNTQpLmVJbnZlcnNlQWRkKGUub3duZXIsXyxudWxsLGYpKSksZiYmZi5kaXNwYXRjaF8wKCksZH1yZXR1cm4gcn1mdW5jdGlvbiBFRihlLG4pe3JldHVybiBKMChlLm93bmVyLGEobiw1NCkpfWZ1bmN0aW9uIFBTKGUsbixyLHQsbyl7dmFyIGkscyx1LGM7cmV0dXJuIGM9RUYoZSxhKG8sNTgpKSxEKGMpIT09RChvKT8odT1hKGUuZGF0YV8wW3JdLDc2KSxpPVZ1KG4sYykscFMoZSxyLHZGKGUscixpKSksVGEoZS5vd25lcikmJihzPWFfKGUsOSxpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLG8sYyx0LCExKSxfcmUocyxuZXcgU2MoZS5vd25lciw5LGUuZmVhdHVyZUlELHUsaSx0LCExKSksaEQocykpLGMpOm99ZnVuY3Rpb24gdWJuKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYobz1yLGk9by5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxDYyhlLm93bmVyLGkpKXtpZihpLmlzVW5pcXVlKCkpe2Zvcih0PWEoZS5kYXRhXzAsMTI0KSxzPTA7czxlLnNpemVfMDsrK3MpaWYodT10W3NdLFluKHUsbykmJnMhPW4pdGhyb3cgYihuZXcgR2UoIlRoZSAnbm8gZHVwbGljYXRlcycgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKX19ZWxzZSBmb3IoYz1JaShlLm93bmVyLmVDbGFzc18wKCksaSksdD1hKGUuZGF0YV8wLDEyNCkscz0wO3M8ZS5zaXplXzA7KytzKWlmKHU9dFtzXSxjLmlzVmFsaWQodS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJnMhPW4pdGhyb3cgYihuZXcgR2UoIlRoZSBtdWx0aXBsaWNpdHkgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKTtyZXR1cm4gYSh6ZyhlLG4sciksNzYpfWZ1bmN0aW9uIExiKGUsbil7UUhlKGUsTChuLDE2MCk/bjphKG4sMjAzNikuZmVhdHVyZU1hcF8wKCkpfWZ1bmN0aW9uIGpqZShlLG4scix0KXt2YXIgbyxpLHMsdSxjLF87aWYoXz1JaShlLm93bmVyLmVDbGFzc18wKCksbikscz1hKGUuZGF0YV8wLDEyNCksQ2MoZS5vd25lcixuKSl7aWYobi5pc1VuaXF1ZSgpJiYoaT1fMihlLG4sdCxMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCksaT49MCYmaSE9cikpdGhyb3cgYihuZXcgR2UoIlRoZSAnbm8gZHVwbGljYXRlcycgY29uc3RyYWludCBpcyB2aW9sYXRlZCIpKTtmb3Iobz0wLGM9MDtjPGUuc2l6ZV8wOysrYylpZih1PXNbY10sXy5pc1ZhbGlkKHUuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXtpZihvPT1yKXJldHVybiBhKHpnKGUsYywoSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCk/YSh0LDc2KTpWdShuLHQpKSksNzYpOysrb310aHJvdyBiKG5ldyBubygiaW5kZXg9IityKyIsIHNpemU9IitvKSl9ZWxzZXtmb3IoYz0wO2M8ZS5zaXplXzA7KytjKWlmKHU9c1tjXSxfLmlzVmFsaWQodS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkpcmV0dXJuIEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpP3U6dS5nZXRWYWx1ZSgpO3JldHVybiBudWxsfX1mdW5jdGlvbiBqTChlLG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZDtpZihDYyhlLm93bmVyLG4pKWM9KEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpP25ldyBYTChuLGUpOm5ldyBrYihuLGUpKSxHTChjLmZlYXR1cmVNYXAsYy5mZWF0dXJlKSxOUyhjLGEociwxNikpO2Vsc2V7Zm9yKGQ9SWkoZS5vd25lci5lQ2xhc3NfMCgpLG4pLHQ9YShlLmRhdGFfMCwxMjQpLHM9MDtzPGUuc2l6ZV8wOysrcylpZihvPXRbc10saT1vLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLGQuaXNWYWxpZChpKSl7aWYoaT09KEFtKCksa20pfHxpPT1MbSl7Zm9yKF89YW9lKGUsbixyKSx1PXMsXz9aZihlLHMpOisrcztzPGUuc2l6ZV8wOylvPXRbc10saT1vLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpLGk9PWttfHxpPT1MbT9aZihlLHMpOisrcztffHxhKHpnKGUsdSxWdShuLHIpKSw3Nil9ZWxzZSBhb2UoZSxuLHIpP1pmKGUscyk6YSh6ZyhlLHMsKEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpP2Eociw3Nik6VnUobixyKSkpLDc2KTtyZXR1cm59YW9lKGUsbixyKXx8cG4oZSwoSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCk/YShyLDc2KTpWdShuLHIpKSl9fWZ1bmN0aW9uIFZqZShlLG4pe3JldHVybiBDYyhlLm93bmVyLG4pPyhIdCgpLEREKG4pP25ldyBYTChuLGUpOm5ldyBrYihuLGUpKTpuZXcgUFZlKG4sZSl9ZnVuY3Rpb24gcWplKGUsbixyKXt2YXIgdCxvLGk7cmV0dXJuIHQ9bi5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxpPW4uZ2V0VmFsdWUoKSxvPXQuaXNNYW55KCk/YV8oZSwzLHQsbnVsbCxpLF8yKGUsdCxpLEwodCwxMDIpJiYoYSh0LDE5KS5lRmxhZ3MmRnQpIT0wKSwhMCk6YV8oZSwxLHQsdC5nZXREZWZhdWx0VmFsdWUoKSxpLC0xLCEwKSxyP3IuYWRkXzUobyk6cj1vLHJ9ZnVuY3Rpb24gY2JuKGUsbixyKXtyZXR1cm4gcWplKGUsYShuLDM0Mykscil9ZnVuY3Rpb24gX2JuKGUsbixyKXt2YXIgdCxvLGk7cmV0dXJuIHQ9bi5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSxpPW4uZ2V0VmFsdWUoKSxvPXQuaXNNYW55KCk/YV8oZSw0LHQsaSxudWxsLF8yKGUsdCxpLEwodCwxMDIpJiYoYSh0LDE5KS5lRmxhZ3MmRnQpIT0wKSwhMCk6YV8oZSx0LmlzVW5zZXR0YWJsZSgpPzI6MSx0LGksdC5nZXREZWZhdWx0VmFsdWUoKSwtMSwhMCkscj9yLmFkZF81KG8pOnI9byxyfWZ1bmN0aW9uIFlqZShlLG4scil7cmV0dXJuIF9ibihlLGEobiwzNDMpLHIpfWZ1bmN0aW9uIGRibihlLG4scix0KXt2YXIgbyxpLHMsdTtyZXR1cm4gVGEoZS5vd25lcikmJihvPW4uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksdT1uLmdldFZhbHVlKCksaT1yLmdldFZhbHVlKCkscz1hXyhlLDEsbyx1LGksby5pc01hbnkoKT9fMihlLG8saSxMKG8sMTAyKSYmKGEobywxOSkuZUZsYWdzJkZ0KSE9MCk6LTEsITApLHQ/dC5hZGRfNShzKTp0PXMpLHR9ZnVuY3Rpb24gYW9lKGUsbixyKXt2YXIgdDtyZXR1cm4gbi5pc1Vuc2V0dGFibGUoKT8hMTpuLmdldFVwcGVyQm91bmQoKSE9LTI/KHQ9bi5nZXREZWZhdWx0VmFsdWUoKSx0PT1udWxsP3I9PW51bGw6WW4odCxyKSk6bi5nZXRFQ29udGFpbmluZ0NsYXNzKCk9PWUub3duZXIuZUNsYXNzXzAoKSYmcj09bnVsbH1mdW5jdGlvbiBmYm4oZSxuKXt2YXIgcix0LG8saSxzO2ZvcihzPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxpPTAscj1hKGUuZGF0YV8wLDEyNCksbz0wO288ZS5zaXplXzA7KytvKXQ9cltvXSxzLmlzVmFsaWQodC5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJisraTtyZXR1cm4gaX1mdW5jdGlvbiBwYm4oZSxuKXtyZXR1cm4gZ2JuKGUsbixMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCl9ZnVuY3Rpb24gZ2JuKGUsbixyKXt2YXIgdCxvLGkscyx1LGM7aWYocz1uZXcgUUEsdT1JaShlLm93bmVyLmVDbGFzc18wKCksbiksdD1hKGUuZGF0YV8wLDEyNCksSHQoKSxhKG4sNjkpLmlzRmVhdHVyZU1hcF8wKCkpZm9yKGk9MDtpPGUuc2l6ZV8wOysraSlvPXRbaV0sdS5pc1ZhbGlkKG8uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiZwbihzLG8pO2Vsc2UgZm9yKGk9MDtpPGUuc2l6ZV8wOysraSlvPXRbaV0sdS5pc1ZhbGlkKG8uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpJiYoYz1vLmdldFZhbHVlKCkscG4ocyxyP1BTKGUsbixpLHMuc2l6ZV8wLGMpOmMpKTtyZXR1cm4gSm5lKHMpfWZ1bmN0aW9uIGhibihlLG4scil7cmV0dXJuIG1ibihlLG4scixMKG4sMTAyKSYmKGEobiwxOSkuZUZsYWdzJkZ0KSE9MCl9ZnVuY3Rpb24gbWJuKGUsbixyLHQpe3ZhciBvLGkscyx1LGMsXztpZih1PW5ldyBRQSxjPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxvPWEoZS5kYXRhXzAsMTI0KSxIdCgpLGEobiw2OSkuaXNGZWF0dXJlTWFwXzAoKSlmb3Iocz0wO3M8ZS5zaXplXzA7KytzKWk9b1tzXSxjLmlzVmFsaWQoaS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJnBuKHUsaSk7ZWxzZSBmb3Iocz0wO3M8ZS5zaXplXzA7KytzKWk9b1tzXSxjLmlzVmFsaWQoaS5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJihfPWkuZ2V0VmFsdWUoKSxwbih1LHQ/UFMoZSxuLHMsdS5zaXplXzAsXyk6XykpO3JldHVybiBabmUodSxyKX1mdW5jdGlvbiBLamUoZSxuKXt2YXIgcix0LG8saSxzO2ZvcihzPUlpKGUub3duZXIuZUNsYXNzXzAoKSxuKSxpPW51bGwscj1hKGUuZGF0YV8wLDEyNCksbz0wO288ZS5zaXplXzA7KytvKXQ9cltvXSxzLmlzVmFsaWQodC5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSkmJighaSYmKGk9bmV3IFFBKSxwbihpLHQpKTtpJiZjR2UoZSxpKX1mdW5jdGlvbiB2RihlLG4scil7dmFyIHQsbztpZihlLm1vZENvdW50PT0wKXJldHVybiByO2lmKG89YShuVWUoZSxuLHIpLDc2KSx0PXIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksIXQuaXNDaGFuZ2VhYmxlKCl8fCFlLmZlYXR1cmVNYXBWYWxpZGF0b3IuaXNWYWxpZCh0KSl0aHJvdyBiKG5ldyBJbygiSW52YWxpZCBlbnRyeSBmZWF0dXJlICciK3QuZ2V0RUNvbnRhaW5pbmdDbGFzcygpLm5hbWVfMCsiLiIrdC5nZXROYW1lKCkrIiciKSk7cmV0dXJuIG99ZnVuY3Rpb24gTnIoZSxuKXtCTC5jYWxsKHRoaXMsdFdlLGUsbiksdGhpcy53cmFwcGVyPXRoaXMsdGhpcy5mZWF0dXJlTWFwVmFsaWRhdG9yPUlpKGUuZUNsYXNzXzAoKSxrZSh0aGlzLm93bmVyLmVDbGFzc18wKCksdGhpcy5mZWF0dXJlSUQpKX1wKDc4LDU5Myx7MzoxLDQ6MSwyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNTk6MSw3MDoxLDY2OjEsNjE6MSw3OToxLDE2MDoxLDIyMDoxLDIwMzY6MSw3MToxLDk3OjF9LE5yKSxsLmFkZF8zPWZ1bmN0aW9uKG4scil7SFRuKHRoaXMsbixhKHIsNzYpKX0sbC5hZGRfMj1mdW5jdGlvbihuKXtyZXR1cm4gVVRuKHRoaXMsYShuLDc2KSl9LGwuYWRkVW5pcXVlXzA9ZnVuY3Rpb24obil7WVRuKHRoaXMsYShuLDc2KSl9LGwuaW52ZXJzZUFkZD1mdW5jdGlvbihuLHIpe3JldHVybiBlYm4odGhpcyxhKG4sNzYpLHIpfSxsLmludmVyc2VSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gaW9lKHRoaXMsYShuLDc2KSxyKX0sbC5tb3ZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIGlibih0aGlzLG4scil9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBzYm4odGhpcyxuLGEociw3NikpfSxsLnNldF8yPWZ1bmN0aW9uKG4scil7cmV0dXJuIHVibih0aGlzLG4sYShyLDc2KSl9LGwuc2hhZG93QWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIGNibih0aGlzLGEobiw3Nikscil9LGwuc2hhZG93UmVtb3ZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIFlqZSh0aGlzLGEobiw3Nikscil9LGwuc2hhZG93U2V0PWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gZGJuKHRoaXMsYShuLDc2KSxhKHIsNzYpLHQpfSxsLnZhbGlkYXRlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHZGKHRoaXMsbixhKHIsNzYpKX0sbC5hZGRfNj1mdW5jdGlvbihuLHIpe3JldHVybiBub2UodGhpcyxuLHIpfSxsLmFkZEFsbF8wPWZ1bmN0aW9uKG4scil7dmFyIHQsbyxpLHMsdSxjLF8sZCxmO2ZvcihkPW5ldyBQZChyLnNpemVfMSgpKSxpPXIuaXRlcmF0b3JfMCgpO2kuaGFzTmV4dF8wKCk7KWlmKG89YShpLm5leHRfMSgpLDc2KSxzPW8uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksQ2ModGhpcy5vd25lcixzKSkoIXMuaXNVbmlxdWUoKXx8IUhMKHRoaXMscyxvLmdldFZhbHVlKCkpJiYhV3coZCxvKSkmJnBuKGQsbyk7ZWxzZXtmb3IoZj1JaSh0aGlzLm93bmVyLmVDbGFzc18wKCkscyksdD1hKHRoaXMuZGF0YV8wLDEyNCksdT0hMCxjPTA7Yzx0aGlzLnNpemVfMDsrK2MpaWYoXz10W2NdLGYuaXNWYWxpZChfLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7YSh6Zyh0aGlzLGMsbyksNzYpLHU9ITE7YnJlYWt9dSYmcG4oZCxvKX1yZXR1cm4gcW5lKHRoaXMsbixkKX0sbC5hZGRBbGw9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2ZvcihfPW5ldyBQZChuLnNpemVfMSgpKSxvPW4uaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KWlmKHQ9YShvLm5leHRfMSgpLDc2KSxpPXQuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCksQ2ModGhpcy5vd25lcixpKSkoIWkuaXNVbmlxdWUoKXx8IUhMKHRoaXMsaSx0LmdldFZhbHVlKCkpJiYhV3coXyx0KSkmJnBuKF8sdCk7ZWxzZXtmb3IoZD1JaSh0aGlzLm93bmVyLmVDbGFzc18wKCksaSkscj1hKHRoaXMuZGF0YV8wLDEyNCkscz0hMCx1PTA7dTx0aGlzLnNpemVfMDsrK3UpaWYoYz1yW3VdLGQuaXNWYWxpZChjLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpKSl7YSh6Zyh0aGlzLHUsdCksNzYpLHM9ITE7YnJlYWt9cyYmcG4oXyx0KX1yZXR1cm4gUHIodGhpcyxfKX0sbC5hZGRBbGxVbmlxdWVfMD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tb2RDb3VudD0tMSx5RCh0aGlzLHRoaXMuc2l6ZV8wLG4pfSxsLmJhc2ljQWRkXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiByb2UodGhpcyxuLHIsdCl9LGwuYmFzaWNSZW1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gUGIodGhpcyxuLHIpfSxsLmJhc2ljUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3JldHVybiB0b2UodGhpcyxuLHIsdCl9LGwuZmVhdHVyZU1hcF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGwuZ2V0Xzc9ZnVuY3Rpb24obixyKXtyZXR1cm4gTmIodGhpcyxuLHIpfSxsLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKE8odGhpcyxuKSw3NikuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCl9LGwuZ2V0VmFsdWVfMT1mdW5jdGlvbihuKXtyZXR1cm4gYShPKHRoaXMsbiksNzYpLmdldFZhbHVlKCl9LGwuZ2V0V3JhcHBlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLndyYXBwZXJ9LGwuaGFzSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxsLmhhc1NoYWRvdz1mdW5jdGlvbigpe3JldHVybiEwfSxsLmlzU2V0XzE9ZnVuY3Rpb24obil7cmV0dXJuIUFiKHRoaXMsbil9LGwubmV3RGF0YT1mdW5jdGlvbihuKXtyZXR1cm4gQih0V2UsT2llLDM0MyxuLDAsMSl9LGwucmVzb2x2ZVByb3h5PWZ1bmN0aW9uKG4pe3JldHVybiBFRih0aGlzLG4pfSxsLnNldF8xPWZ1bmN0aW9uKG4pe0xiKHRoaXMsbil9LGwuc2V0XzM9ZnVuY3Rpb24obixyKXtqTCh0aGlzLG4scil9LGwuc2V0dGluZz1mdW5jdGlvbihuKXtyZXR1cm4gVmplKHRoaXMsbil9LGwudW5zZXRfMD1mdW5jdGlvbihuKXtLamUodGhpcyxuKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJCYXNpY0ZlYXR1cmVNYXAiLDc4KTtmdW5jdGlvbiBWTChlKXtpZihlLmZlYXR1cmVNYXAubW9kQ291bnQhPWUuZXhwZWN0ZWRNb2RDb3VudCl0aHJvdyBiKG5ldyBYYSl9ZnVuY3Rpb24gU0YoZSl7c3dpdGNoKGUucHJlcGFyZWQpe2Nhc2UgMjpyZXR1cm4hMDtjYXNlIDE6cmV0dXJuITE7Y2FzZS0xOisrZS5lbnRyeUN1cnNvcjtkZWZhdWx0OnJldHVybiBlLnNjYW5OZXh0KCl9fWZ1bmN0aW9uIFhqZShlKXtzd2l0Y2goZS5wcmVwYXJlZCl7Y2FzZS0yOnJldHVybiEwO2Nhc2UtMTpyZXR1cm4hMTtjYXNlIDE6LS1lLmVudHJ5Q3Vyc29yO2RlZmF1bHQ6cmV0dXJuIGUuc2NhblByZXZpb3VzKCl9fWZ1bmN0aW9uIHFMKGUpe3ZhciBuO2lmKFNGKGUpKXJldHVybiBWTChlKSxlLnJlc29sdmVfMCgpJiYobj1QUyhlLmZlYXR1cmVNYXAsZS5lU3RydWN0dXJhbEZlYXR1cmUsZS5lbnRyeUN1cnNvcixlLmN1cnNvcixlLnByZXBhcmVkUmVzdWx0KSxlLnByZXBhcmVkUmVzdWx0PW4pLGUubGFzdEN1cnNvcj1lLmN1cnNvciwrK2UuY3Vyc29yLCsrZS5lbnRyeUN1cnNvcixlLnByZXBhcmVkPTAsZS5wcmVwYXJlZFJlc3VsdDt0aHJvdyBiKG5ldyBQbyl9cCgxOTYwLDEsQ3UpLGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLmFkZF8xPWZ1bmN0aW9uKG4pe2lmKHRoaXMubGFzdEN1cnNvcj09LTEpdGhyb3cgYihuZXcgemkpO1ZMKHRoaXMpO3RyeXtHamUodGhpcy5mZWF0dXJlTWFwLHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlLHRoaXMuY3Vyc29yLG4pLHRoaXMuZXhwZWN0ZWRNb2RDb3VudD10aGlzLmZlYXR1cmVNYXAubW9kQ291bnQscUwodGhpcyl9Y2F0Y2gocil7dGhyb3cgcj13cihyKSxMKHIsNzcpP2IobmV3IFhhKTpiKHIpfX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gU0YodGhpcyl9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4gWGplKHRoaXMpfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBxTCh0aGlzKX0sbC5uZXh0SW5kZXhfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmN1cnNvcn0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7dmFyIG47aWYoWGplKHRoaXMpKXJldHVybiBWTCh0aGlzKSx0aGlzLmxhc3RDdXJzb3I9LS10aGlzLmN1cnNvcix0aGlzLnJlc29sdmVfMCgpJiYobj1QUyh0aGlzLmZlYXR1cmVNYXAsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmUsdGhpcy5lbnRyeUN1cnNvcix0aGlzLmN1cnNvcix0aGlzLnByZXBhcmVkUmVzdWx0KSx0aGlzLnByZXBhcmVkUmVzdWx0PW4pLHRoaXMucHJlcGFyZWQ9MCx0aGlzLnByZXBhcmVkUmVzdWx0O3Rocm93IGIobmV3IFBvKX0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3Vyc29yLTF9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7aWYodGhpcy5sYXN0Q3Vyc29yPT0tMSl0aHJvdyBiKG5ldyB6aSk7VkwodGhpcyk7dHJ5e1dqZSh0aGlzLmZlYXR1cmVNYXAsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmUsdGhpcy5sYXN0Q3Vyc29yKSx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy5mZWF0dXJlTWFwLm1vZENvdW50LHRoaXMubGFzdEN1cnNvcjx0aGlzLmN1cnNvciYmKC0tdGhpcy5jdXJzb3IsLS10aGlzLmVudHJ5Q3Vyc29yKSwtLXRoaXMubGFzdEN1cnNvcn1jYXRjaChuKXt0aHJvdyBuPXdyKG4pLEwobiw3Nyk/YihuZXcgWGEpOmIobil9fSxsLnJlc29sdmVfMD1mdW5jdGlvbigpe3JldHVybiExfSxsLnNldF8xPWZ1bmN0aW9uKG4pe2lmKHRoaXMubGFzdEN1cnNvcj09LTEpdGhyb3cgYihuZXcgemkpO1ZMKHRoaXMpO3RyeXtqamUodGhpcy5mZWF0dXJlTWFwLHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlLHRoaXMubGFzdEN1cnNvcixuKSx0aGlzLmV4cGVjdGVkTW9kQ291bnQ9dGhpcy5mZWF0dXJlTWFwLm1vZENvdW50fWNhdGNoKHIpe3Rocm93IHI9d3IociksTChyLDc3KT9iKG5ldyBYYSk6YihyKX19LGwuY3Vyc29yPTAsbC5lbnRyeUN1cnNvcj0wLGwuZXhwZWN0ZWRNb2RDb3VudD0wLGwuaXNGZWF0dXJlTWFwPSExLGwubGFzdEN1cnNvcj0wLGwucHJlcGFyZWQ9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkZlYXR1cmVNYXBVdGlsL0Jhc2ljRmVhdHVyZUVJdGVyYXRvciIsMTk2MCk7ZnVuY3Rpb24gZDIoZSxuKXt0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZT1lLHRoaXMuZmVhdHVyZU1hcD1uLHRoaXMuZXhwZWN0ZWRNb2RDb3VudD1uLm1vZENvdW50LHRoaXMuaXNGZWF0dXJlTWFwPShIdCgpLGEoZSw2OSkuaXNGZWF0dXJlTWFwXzAoKSksdGhpcy52YWxpZGF0b3I9SWkobi5vd25lci5lQ2xhc3NfMCgpLGUpfXAoNDIwLDE5NjAsQ3UsZDIpLGwuc2Nhbk5leHQ9ZnVuY3Rpb24oKXt2YXIgbixyLHQ7Zm9yKHQ9dGhpcy5mZWF0dXJlTWFwLnNpemVfMCxuPWEodGhpcy5mZWF0dXJlTWFwLmRhdGFfMCwxMjQpO3RoaXMuZW50cnlDdXJzb3I8dDspe2lmKHI9blt0aGlzLmVudHJ5Q3Vyc29yXSx0aGlzLnZhbGlkYXRvci5pc1ZhbGlkKHIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXJldHVybiB0aGlzLnByZXBhcmVkUmVzdWx0PXRoaXMuaXNGZWF0dXJlTWFwP3I6ci5nZXRWYWx1ZSgpLHRoaXMucHJlcGFyZWQ9MiwhMDsrK3RoaXMuZW50cnlDdXJzb3J9cmV0dXJuIHRoaXMucHJlcGFyZWQ9MSx0aGlzLmxhc3RDdXJzb3I9LTEsITF9LGwuc2NhblByZXZpb3VzPWZ1bmN0aW9uKCl7dmFyIG4scjtmb3Iobj1hKHRoaXMuZmVhdHVyZU1hcC5kYXRhXzAsMTI0KTstLXRoaXMuZW50cnlDdXJzb3I+PTA7KWlmKHI9blt0aGlzLmVudHJ5Q3Vyc29yXSx0aGlzLnZhbGlkYXRvci5pc1ZhbGlkKHIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkpKXJldHVybiB0aGlzLnByZXBhcmVkUmVzdWx0PXRoaXMuaXNGZWF0dXJlTWFwP3I6ci5nZXRWYWx1ZSgpLHRoaXMucHJlcGFyZWQ9LTIsITA7cmV0dXJuIHRoaXMucHJlcGFyZWQ9LTEsdGhpcy5sYXN0Q3Vyc29yPS0xLCExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkJhc2ljRmVhdHVyZU1hcC9GZWF0dXJlRUl0ZXJhdG9yIiw0MjApO2Z1bmN0aW9uIENGKGUsbil7ZDIuY2FsbCh0aGlzLGUsbil9cCg2NzYsNDIwLEN1LENGKSxsLnJlc29sdmVfMD1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkJhc2ljRmVhdHVyZU1hcC9SZXNvbHZpbmdGZWF0dXJlRUl0ZXJhdG9yIiw2NzYpO2Z1bmN0aW9uIEpqZSgpe3ZiLmNhbGwodGhpcyxudWxsLG51bGwpfXAoOTY4LDQ5NixZYixKamUpLGwuYmFzaWNMaXN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRUNvbnRlbnRzRUxpc3QvMSIsOTY4KTtmdW5jdGlvbiBaamUoZSxuKXt2Yi5jYWxsKHRoaXMsZSxuKX1wKDk2OSw0OTYsWWIsWmplKSxsLnJlc29sdmVfMD1mdW5jdGlvbigpe3JldHVybiExfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVDb250ZW50c0VMaXN0LzIiLDk2OSk7ZnVuY3Rpb24gUWplKCl7TEwuY2FsbCh0aGlzLG51bGwsbnVsbCl9cCg5NjcsMjg3LEtiLFFqZSksbC5maWx0ZXJfMD1mdW5jdGlvbihuKXt9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFQ29udGVudHNFTGlzdC9GZWF0dXJlSXRlcmF0b3JJbXBsLzEiLDk2Nyk7ZnVuY3Rpb24gbG9lKGUsbixyKXtCTC5jYWxsKHRoaXMsZSxuLHIpfXAoODQwLDU5MyxFbyxsb2UpLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5pc1NldD0hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNTZXR9LGwudW5zZXQ9ZnVuY3Rpb24oKXt2YXIgbjtmbih0aGlzKSxUYSh0aGlzLm93bmVyKT8obj10aGlzLmlzU2V0LHRoaXMuaXNTZXQ9ITEsWG4odGhpcy5vd25lcixuZXcgcnModGhpcy5vd25lciwyLHRoaXMuZmVhdHVyZUlELG4sITEpKSk6dGhpcy5pc1NldD0hMX0sbC5pc1NldD0hMSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVEYXRhVHlwZUVMaXN0L1Vuc2V0dGFibGUiLDg0MCk7ZnVuY3Rpb24gZVZlKGUsbixyKXtCTC5jYWxsKHRoaXMsZSxuLHIpfXAoMTk1OCw1OTMsRW8sZVZlKSxsLmlzVW5pcXVlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRURhdGFUeXBlVW5pcXVlRUxpc3QiLDE5NTgpO2Z1bmN0aW9uIG5WZShlLG4scil7bG9lLmNhbGwodGhpcyxlLG4scil9cCgxOTU5LDg0MCxFbyxuVmUpLGwuaXNVbmlxdWU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFRGF0YVR5cGVVbmlxdWVFTGlzdC9VbnNldHRhYmxlIiwxOTU5KTtmdW5jdGlvbiBYaShlLG4scil7anIuY2FsbCh0aGlzLGUsbixyKX1wKDE0Nyw4MyxFbyxYaSksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50RUxpc3QvUmVzb2x2aW5nIiwxNDcpO2Z1bmN0aW9uIHJWZShlLG4scil7YkwuY2FsbCh0aGlzLGUsbixyKX1wKDExODQsNTU1LEVvLHJWZSksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50RUxpc3QvVW5zZXR0YWJsZS9SZXNvbHZpbmciLDExODQpO2Z1bmN0aW9uIHNvZShlLG4scix0KXtVLmNhbGwodGhpcyxlLG4scix0KX1wKDc2NiwxNCxFbyxzb2UpLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5pc1NldD0hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNTZXR9LGwudW5zZXQ9ZnVuY3Rpb24oKXt2YXIgbjtmbih0aGlzKSxUYSh0aGlzLm93bmVyKT8obj10aGlzLmlzU2V0LHRoaXMuaXNTZXQ9ITEsWG4odGhpcy5vd25lcixuZXcgcnModGhpcy5vd25lciwyLHRoaXMuZmVhdHVyZUlELG4sITEpKSk6dGhpcy5pc1NldD0hMX0sbC5pc1NldD0hMSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RDb250YWlubWVudFdpdGhJbnZlcnNlRUxpc3QvVW5zZXR0YWJsZSIsNzY2KTtmdW5jdGlvbiB0VmUoZSxuLHIsdCl7c29lLmNhbGwodGhpcyxlLG4scix0KX1wKDEyMjIsNzY2LEVvLHRWZSksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdENvbnRhaW5tZW50V2l0aEludmVyc2VFTGlzdC9VbnNldHRhYmxlL1Jlc29sdmluZyIsMTIyMik7ZnVuY3Rpb24gdW9lKGUsbixyKXt5Yi5jYWxsKHRoaXMsZSxuLHIpfXAoNzU3LDUwNSxFbyx1b2UpLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5pc1NldD0hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNTZXR9LGwudW5zZXQ9ZnVuY3Rpb24oKXt2YXIgbjtmbih0aGlzKSxUYSh0aGlzLm93bmVyKT8obj10aGlzLmlzU2V0LHRoaXMuaXNTZXQ9ITEsWG4odGhpcy5vd25lcixuZXcgcnModGhpcy5vd25lciwyLHRoaXMuZmVhdHVyZUlELG4sITEpKSk6dGhpcy5pc1NldD0hMX0sbC5pc1NldD0hMSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RFTGlzdC9VbnNldHRhYmxlIiw3NTcpO2Z1bmN0aW9uIFdnKGUsbixyKXt5Yi5jYWxsKHRoaXMsZSxuLHIpfXAoMzM4LDUwNSxFbyxXZyksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdFJlc29sdmluZ0VMaXN0IiwzMzgpO2Z1bmN0aW9uIG9WZShlLG4scil7dW9lLmNhbGwodGhpcyxlLG4scil9cCgxODQ0LDc1NyxFbyxvVmUpLGwuaGFzUHJveGllcz1mdW5jdGlvbigpe3JldHVybiEwfSxsLnJlc29sdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gSW0odGhpcyxuLGEociw1OCkpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RSZXNvbHZpbmdFTGlzdC9VbnNldHRhYmxlIiwxODQ0KTtmdW5jdGlvbiBURigpe1RGPUYsYVZlPW5ldyBpVmV9ZnVuY3Rpb24gaVZlKCl7fXAoMTUyNywxLHt9LGlWZSk7dmFyIGFWZTtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RWYWxpZGF0b3IiLDE1MjcpO2Z1bmN0aW9uIFlMKGUsbixyLHQpe3liLmNhbGwodGhpcyxlLG4sciksdGhpcy5pbnZlcnNlRmVhdHVyZUlEPXR9cCg1NTksNTA1LEVvLFlMKSxsLmdldEludmVyc2VGZWF0dXJlQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhQ2xhc3N9LGwuZ2V0SW52ZXJzZUZlYXR1cmVJRD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmludmVyc2VGZWF0dXJlSUR9LGwuaGFzSW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxsLmhhc05hdmlnYWJsZUludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5pbnZlcnNlRmVhdHVyZUlEPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFT2JqZWN0V2l0aEludmVyc2VFTGlzdCIsNTU5KTtmdW5jdGlvbiBsVmUoZSxuLHIsdCl7WUwuY2FsbCh0aGlzLGUsbixyLHQpfXAoMTIyNSw1NTksRW8sbFZlKSxsLmhhc01hbnlJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdFdpdGhJbnZlcnNlRUxpc3QvTWFueUludmVyc2UiLDEyMjUpO2Z1bmN0aW9uIGJGKGUsbixyLHQpe1lMLmNhbGwodGhpcyxlLG4scix0KX1wKDYzNSw1NTksRW8sYkYpLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5pc1NldD0hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNTZXR9LGwudW5zZXQ9ZnVuY3Rpb24oKXt2YXIgbjtmbih0aGlzKSxUYSh0aGlzLm93bmVyKT8obj10aGlzLmlzU2V0LHRoaXMuaXNTZXQ9ITEsWG4odGhpcy5vd25lcixuZXcgcnModGhpcy5vd25lciwyLHRoaXMuZmVhdHVyZUlELG4sITEpKSk6dGhpcy5pc1NldD0hMX0sbC5pc1NldD0hMSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RXaXRoSW52ZXJzZUVMaXN0L1Vuc2V0dGFibGUiLDYzNSk7ZnVuY3Rpb24gc1ZlKGUsbixyLHQpe2JGLmNhbGwodGhpcyxlLG4scix0KX1wKDEyMjQsNjM1LEVvLHNWZSksbC5oYXNNYW55SW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RXaXRoSW52ZXJzZUVMaXN0L1Vuc2V0dGFibGUvTWFueUludmVyc2UiLDEyMjQpO2Z1bmN0aW9uIGNvZShlLG4scix0KXtZTC5jYWxsKHRoaXMsZSxuLHIsdCl9cCg3NjcsNTU5LEVvLGNvZSksbC5oYXNQcm94aWVzPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGwucmVzb2x2ZT1mdW5jdGlvbihuLHIpe3JldHVybiBJbSh0aGlzLG4sYShyLDU4KSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdFdpdGhJbnZlcnNlUmVzb2x2aW5nRUxpc3QiLDc2Nyk7ZnVuY3Rpb24gTGUoZSxuLHIsdCl7Y29lLmNhbGwodGhpcyxlLG4scix0KX1wKDMyLDc2NyxFbyxMZSksbC5oYXNNYW55SW52ZXJzZT1mdW5jdGlvbigpe3JldHVybiEwfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVPYmplY3RXaXRoSW52ZXJzZVJlc29sdmluZ0VMaXN0L01hbnlJbnZlcnNlIiwzMik7ZnVuY3Rpb24gX29lKGUsbixyLHQpe2JGLmNhbGwodGhpcyxlLG4scix0KX1wKDc2OCw2MzUsRW8sX29lKSxsLmhhc1Byb3hpZXM9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sbC5yZXNvbHZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIEltKHRoaXMsbixhKHIsNTgpKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFT2JqZWN0V2l0aEludmVyc2VSZXNvbHZpbmdFTGlzdC9VbnNldHRhYmxlIiw3NjgpO2Z1bmN0aW9uIHVWZShlLG4scix0KXtfb2UuY2FsbCh0aGlzLGUsbixyLHQpfXAoMTIyMyw3NjgsRW8sdVZlKSxsLmhhc01hbnlJbnZlcnNlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRU9iamVjdFdpdGhJbnZlcnNlUmVzb2x2aW5nRUxpc3QvVW5zZXR0YWJsZS9NYW55SW52ZXJzZSIsMTIyMyk7ZnVuY3Rpb24gY1ZlKGUpe3ZhciBuLHIsdCxvLGkscztyZXR1cm4gaT0wLG49QWwoZSksbi5nZXRJbnN0YW5jZUNsYXNzKCkmJihpfD00KSxlLmVGbGFncyZGaSYmKGl8PTIpLEwoZSwxMDIpPyhyPWEoZSwxOSksbz1HdChyKSxyLmVGbGFncyZHbyYmKGl8PTMyKSxvJiYob24oYXAobykpLGl8PTgscz1vLnVwcGVyQm91bmQsKHM+MXx8cz09LTEpJiYoaXw9MTYpLG8uZUZsYWdzJkdvJiYoaXw9NjQpKSxyLmVGbGFncyZGdCYmKGl8PWpkKSxpfD1MbCk6TChuLDQ2OSk/aXw9NTEyOih0PW4uZ2V0SW5zdGFuY2VDbGFzcygpLHQmJnQubW9kaWZpZXJzJjEmJihpfD0yNTYpKSxlLmVGbGFncyY1MTImJihpfD0xMjgpLGl9cCgxMTg1LDYzMixFbyksbC5jYW5Db250YWluTnVsbD1mdW5jdGlvbigpe3JldHVybih0aGlzLmtpbmQmMTc5Mik9PTB9LGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5raW5kfD0xfSxsLmhhc0luc3RhbmNlQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5raW5kJjQpIT0wfSxsLmhhc0ludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5raW5kJjQwKSE9MH0sbC5oYXNNYW55SW52ZXJzZT1mdW5jdGlvbigpe3JldHVybih0aGlzLmtpbmQmMTYpIT0wfSxsLmhhc05hdmlnYWJsZUludmVyc2U9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5raW5kJjgpIT0wfSxsLmhhc1Byb3hpZXM9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5raW5kJmpkKSE9MH0sbC5pc0NvbnRhaW5tZW50PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMua2luZCYzMikhPTB9LGwuaXNFT2JqZWN0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMua2luZCZMbCkhPTB9LGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5kYXRhQ2xhc3M/YUhlKHRoaXMuZGF0YUNsYXNzLG4pOnRoaXMuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlKCkuZ2V0RVR5cGUoKS5pc0luc3RhbmNlKG4pfSxsLmlzU2V0XzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5raW5kJjI/KHRoaXMua2luZCYxKSE9MDp0aGlzLnNpemVfMCE9MH0sbC5pc1VuaXF1ZT1mdW5jdGlvbigpe3JldHVybih0aGlzLmtpbmQmMTI4KSE9MH0sbC51bnNldD1mdW5jdGlvbigpe3ZhciBuO2ZuKHRoaXMpLHRoaXMua2luZCYyJiYoVGEodGhpcy5vd25lcik/KG49KHRoaXMua2luZCYxKSE9MCx0aGlzLmtpbmQmPS0yLHQyKHRoaXMsbmV3IHJzKHRoaXMub3duZXIsMixFcih0aGlzLm93bmVyLmVDbGFzc18wKCksdGhpcy5nZXRFU3RydWN0dXJhbEZlYXR1cmUoKSksbiwhMSkpKTp0aGlzLmtpbmQmPS0yKX0sbC51c2VFcXVhbHM9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5raW5kJjE1MzYpPT0wfSxsLmtpbmQ9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlRUxpc3QvR2VuZXJpYyIsMTE4NSk7ZnVuY3Rpb24gX1ZlKGUsbixyLHQpe3FyZS5jYWxsKHRoaXMsbixyKSx0aGlzLmtpbmQ9ZSx0aGlzLmVTdHJ1Y3R1cmFsRmVhdHVyZT10fXAoMTE4NiwxMTg1LEVvLF9WZSksbC5nZXRFU3RydWN0dXJhbEZlYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lU3RydWN0dXJhbEZlYXR1cmV9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRWNvcmVFTGlzdC9EeW5hbWljIiwxMTg2KTtmdW5jdGlvbiBkb2UoZSl7dGhpcy50aGlzJDAxPWV9cCg3NjUsNjYsZXUsZG9lKSxsLm5ld0RhdGE9ZnVuY3Rpb24obil7cmV0dXJuIGZiKHRoaXMudGhpcyQwMS5lbnRyeUNsYXNzLG4pfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlRU1hcC8xIiw3NjUpO2Z1bmN0aW9uIGZvZShlLG4scix0KXt0aGlzLnRoaXMkMDE9ZSxqci5jYWxsKHRoaXMsbixyLHQpfXAoNzY0LDgzLEVvLGZvZSksbC5kaWRBZGQ9ZnVuY3Rpb24obixyKXt0TCh0aGlzLnRoaXMkMDEsYShyLDEzNikpfSxsLmRpZENsZWFyPWZ1bmN0aW9uKG4scil7TkdlKHRoaXMudGhpcyQwMSl9LGwuZGlkTW92ZT1mdW5jdGlvbihuLHIsdCl7dmFyIG87Kysobz10aGlzLnRoaXMkMDEsYShyLDEzNiksbykubW9kQ291bnR9LGwuZGlkUmVtb3ZlPWZ1bmN0aW9uKG4scil7SUQodGhpcy50aGlzJDAxLGEociwxMzYpKX0sbC5kaWRTZXQ9ZnVuY3Rpb24obixyLHQpe0lEKHRoaXMudGhpcyQwMSxhKHQsMTM2KSksRCh0KT09PUQocikmJmEodCwxMzYpLnNldEhhc2goeUNuKGEociwxMzYpLmdldEtleSgpKSksdEwodGhpcy50aGlzJDAxLGEociwxMzYpKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFY29yZUVNYXAvRGVsZWdhdGVFT2JqZWN0Q29udGFpbm1lbnRFTGlzdCIsNzY0KTtmdW5jdGlvbiBkVmUoZSxuLHIsdCl7dGhpcy5pbml0aWFsaXplRGVsZWdhdGVFTGlzdCgpLHRoaXMuZW50cnlDbGFzcz1uLHRoaXMuZW50cnlFQ2xhc3M9ZSx0aGlzLmRlbGVnYXRlRUxpc3Q9bnVsbCx0aGlzLmRlbGVnYXRlRUxpc3Q9bmV3IGZWZSh0aGlzLG4scix0KX1wKDEyMjAsMTQxLGV6LGRWZSksZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJFY29yZUVNYXAvVW5zZXR0YWJsZSIsMTIyMCk7ZnVuY3Rpb24gZlZlKGUsbixyLHQpe2ZvZS5jYWxsKHRoaXMsZSxuLHIsdCl9cCgxMjIxLDc2NCxFbyxmVmUpLGwuZGlkQ2hhbmdlPWZ1bmN0aW9uKCl7dGhpcy5pc1NldD0hMH0sbC5pc1NldF8wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNTZXR9LGwudW5zZXQ9ZnVuY3Rpb24oKXt2YXIgbjtmbih0aGlzKSxUYSh0aGlzLm93bmVyKT8obj10aGlzLmlzU2V0LHRoaXMuaXNTZXQ9ITEsWG4odGhpcy5vd25lcixuZXcgcnModGhpcy5vd25lciwyLHRoaXMuZmVhdHVyZUlELG4sITEpKSk6dGhpcy5pc1NldD0hMX0sbC5pc1NldD0hMSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlRU1hcC9VbnNldHRhYmxlL1Vuc2V0dGFibGVEZWxlZ2F0ZUVPYmplY3RDb250YWlubWVudEVMaXN0IiwxMjIxKTtmdW5jdGlvbiBwb2UoZSxuKXtyZXR1cm4gZS5nZXRFUGFja2FnZSgpLmdldEVGYWN0b3J5SW5zdGFuY2UoKS5jb252ZXJ0VG9TdHJpbmcoZSxuKX1mdW5jdGlvbiBnb2UoZSxuKXtyZXR1cm4gZS5nZXRFUGFja2FnZSgpLmdldEVGYWN0b3J5SW5zdGFuY2UoKS5jcmVhdGVGcm9tU3RyaW5nKGUsbil9ZnVuY3Rpb24geWJuKGUpe3ZhciBuLHI7Zm9yKHI9cFZlKEhhKGUpKS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspaWYobj14bihyLm5leHRfMSgpKSxzUyhlLG4pKXJldHVybiBXQ24oKHZIZSgpLFNIZSksbik7cmV0dXJuIG51bGx9ZnVuY3Rpb24gcFZlKGUpe3ZhciBuLHIsdCxvLGkscyx1O2lmKGUmJihuPWUuZ2V0RUFubm90YXRpb24oImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiKSxuJiYocz14bih3cygoIW4uZGV0YWlscyYmKG4uZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLG4pKSxuLmRldGFpbHMpLCJjb252ZXJzaW9uRGVsZWdhdGVzIikpLHMhPW51bGwpKSl7Zm9yKHU9bmV3IFEsdD1lZihzLCJcXHcrIiksbz0wLGk9dC5sZW5ndGg7bzxpOysrbylyPXRbb10sUmUodS5hcnJheSxyKTtyZXR1cm4gdX1yZXR1cm4gTmUoKSxOZSgpLE90fWZ1bmN0aW9uIGdWZShlKXt2YXIgbixyLHQ7aWYodD1lLGUpZm9yKG49MCxyPWUuZUNvbnRhaW5lcl8wKCk7cjtyPXIuZUNvbnRhaW5lcl8wKCkpe2lmKCsrbj5sNilyZXR1cm4gZ1ZlKHIpO2lmKHQ9cixyPT1lKXRocm93IGIobmV3IHJvKCJUaGVyZSBpcyBhIGN5Y2xlIGluIHRoZSBjb250YWlubWVudCBoaWVyYXJjaHkgb2YgIitlKSl9cmV0dXJuIHR9ZnVuY3Rpb24gd2JuKGUpe3ZhciBuLHI7Zm9yKHI9RWJuKEhhKGFwKGUpKSkuaXRlcmF0b3JfMCgpO3IuaGFzTmV4dF8wKCk7KWlmKG49eG4oci5uZXh0XzEoKSksc1MoZSxuKSlyZXR1cm4gakNuKChiSGUoKSxJSGUpLG4pO3JldHVybiBudWxsfWZ1bmN0aW9uIEVibihlKXt2YXIgbixyLHQsbyxpLHMsdTtpZihuPWUuZ2V0RUFubm90YXRpb24oImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDIvRWNvcmUiKSxuJiYodT14bih3cygoIW4uZGV0YWlscyYmKG4uZGV0YWlscz1uZXcgYmEoKFBlKCksQnQpLEJvLG4pKSxuLmRldGFpbHMpLCJzZXR0aW5nRGVsZWdhdGVzIikpLHUhPW51bGwpKXtmb3Iocj1uZXcgUSxvPWVmKHUsIlxcdysiKSxpPTAscz1vLmxlbmd0aDtpPHM7KytpKXQ9b1tpXSxSZShyLmFycmF5LHQpO3JldHVybiByfXJldHVybiBOZSgpLE5lKCksT3R9ZnVuY3Rpb24gZjIoZSxuKXt2YXIgcix0O2lmKG4pe2lmKG49PWUpcmV0dXJuITA7Zm9yKHI9MCx0PWEobiw1NCkuZUludGVybmFsQ29udGFpbmVyKCk7dCYmdCE9bjt0PXQuZUludGVybmFsQ29udGFpbmVyKCkpe2lmKCsrcj5sNilyZXR1cm4gZjIoZSx0KTtpZih0PT1lKXJldHVybiEwfX1yZXR1cm4hMX1mdW5jdGlvbiBoVmUoZSl7dmFyIG4scix0LG87aWYocj1hKGUsNTQpLmVQcm94eVVSSV8wKCkscil0cnl7aWYodD1udWxsLG49YTIoKG5fKCksUGwpLHNIZShMQ24ocikpKSxuJiYobz1uLmVSZXNvdXJjZV8wKCksbyYmKHQ9by5nZXRFT2JqZWN0KGhaZShyLmZyYWdtZW50KSkpKSx0JiZ0IT1lKXJldHVybiBoVmUodCl9Y2F0Y2goaSl7aWYoaT13cihpKSwhTChpLDYzKSl0aHJvdyBiKGkpfXJldHVybiBlfWZ1bmN0aW9uIHZibihlKXtyZXR1cm4gZT9lLm1vZGlmaWVycyYxP2U9PXlhP0FyOmU9PWhuP3Z0OmU9PXBwP2F5OmU9PWN0PyRyOmU9PV9fP0kxOmU9PVhnP3gxOmU9PUppP3VoOkYyOmU6bnVsbH1mdW5jdGlvbiBJRihlLG4pe3ZhciByLHQsbyxpLHMsdSxjLF87aWYobil7aWYocj0oaT1uLmVDbGFzc18wKCksaT9IYShpKS5nZXRFRmFjdG9yeUluc3RhbmNlKCkuY3JlYXRlXzMoaSk6bnVsbCkscil7Zm9yKFJjKGUsbixyKSxvPW4uZUNsYXNzXzAoKSxjPTAsXz0oby5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmRXUobyksby5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YSkubGVuZ3RoO2M8XzsrK2MpdT0odD0oby5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmRXUobyksby5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YSksYz49MCYmYzx0Lmxlbmd0aD90W2NdOm51bGwpLHUuaXNDaGFuZ2VhYmxlKCkmJiF1LmlzRGVyaXZlZCgpJiYoTCh1LDMzMSk/Q2JuKGUsYSh1LDM1KSxuLHIpOihzPWEodSwxOSkscy5lRmxhZ3MmR28mJmJibihlLHMsbixyKSkpO24uZUlzUHJveHkoKSYmYShyLDU0KS5lU2V0UHJveHlVUkkoYShuLDU0KS5lUHJveHlVUklfMCgpKX1yZXR1cm4gcn1lbHNlIHJldHVybiBudWxsfWZ1bmN0aW9uIFNibihlLG4pe3ZhciByLHQsbyxpO2ZvcihvPW5ldyBfaShuLnNpemVfMSgpKSx0PW4uaXRlcmF0b3JfMCgpO3QuaGFzTmV4dF8wKCk7KXI9dC5uZXh0XzEoKSxpPUlGKGUsYShyLDU4KSksaSYmUmUoby5hcnJheSxpKTtyZXR1cm4gb31mdW5jdGlvbiBDYm4oZSxuLHIsdCl7dmFyIG8saSxzO3IuZUlzU2V0XzAobikmJihIdCgpLEREKG4pPyhvPWEoci5lR2V0XzAobiksMTYwKSxJYm4oZSxvKSk6KGk9KHM9bixzP2EodCw1NCkuZVNldHRpbmcocyk6bnVsbCksaSYmVGJuKHIuZUdldF8wKG4pLGkpKSl9ZnVuY3Rpb24gVGJuKGUsbil7bi5zZXRfMShlKX1mdW5jdGlvbiBiYm4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYztyLmVJc1NldF8wKG4pJiYobz0ocz1uLHM/YSh0LDU0KS5lU2V0dGluZyhzKTpudWxsKSxvJiYoYz1yLmVHZXRfMChuKSx1PW4udXBwZXJCb3VuZCx1PjF8fHU9PS0xPyhpPWEoYywxNSksby5zZXRfMShTYm4oZSxpKSkpOm8uc2V0XzEoSUYoZSxhKGMsNTgpKSkpKX1mdW5jdGlvbiBJYm4oZSxuKXt2YXIgcix0LG8saTtmb3IodD0wLG89bi5zaXplXzEoKTt0PG87Kyt0KXI9bi5nZXRFU3RydWN0dXJhbEZlYXR1cmVfMCh0KSxMKHIsMTAyKSYmYShyLDE5KS5lRmxhZ3MmR28mJihpPW4uZ2V0VmFsdWVfMSh0KSxpIT1udWxsJiZJRihlLGEoaSw1OCkpKX1mdW5jdGlvbiB4Ym4oZSxuLHIsdCl7dmFyIG8saSxzLHUsYyxfLGQsZixoLG0seSxFO2lmKHIuZUlzU2V0XzAobikmJihkPShtPW4sbT9hKHQsNTQpLmVTZXR0aW5nKG0pOm51bGwpLGQpKWlmKEU9ci5lR2V0XzEobixlLnJlc29sdmVQcm94aWVzKSx5PW4udXBwZXJCb3VuZCx5PjF8fHk9PS0xKWlmKGY9YShFLDcxKSxoPWEoZCw3MSksZi5pc0VtcHR5KCkpaC5jbGVhcl8wKCk7ZWxzZSBmb3Iocz0hIUd0KG4pLGk9MCx1PWUucmVzb2x2ZVByb3hpZXM/Zi5pdGVyYXRvcl8wKCk6Zi5iYXNpY0l0ZXJhdG9yKCk7dS5oYXNOZXh0XzAoKTspXz1hKHUubmV4dF8xKCksNTgpLG89YSh4cyhlLF8pLDU4KSxvPyhzPyhjPWguaW5kZXhPZl8wKG8pLGM9PS0xP2guYWRkVW5pcXVlKGksbyk6aSE9YyYmaC5tb3ZlXzAoaSxvKSk6aC5hZGRVbmlxdWUoaSxvKSwrK2kpOmUudXNlT3JpZ2luYWxSZWZlcmVuY2VzJiYhcyYmKGguYWRkVW5pcXVlKGksXyksKytpKTtlbHNlIEU9PW51bGw/ZC5zZXRfMShudWxsKToobz14cyhlLEUpLG89PW51bGw/ZS51c2VPcmlnaW5hbFJlZmVyZW5jZXMmJiFHdChuKSYmZC5zZXRfMShFKTpkLnNldF8xKG8pKX1mdW5jdGlvbiBQYm4oZSl7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHYseCxBLGssTSxILHE7Zm9yKGY9bmV3IHVHKG5ldyBzRyhlKSk7Zi5uZXh0XzAhPWYudGhpcyQxMS50aGlzJDAxLmhlYWQ7KWZvcihkPWNfZShmKSx1PWEoZC5rZXksNTgpLG49YShkLnZhbHVlXzAsNTgpLHM9dS5lQ2xhc3NfMCgpLEU9MCxNPShzLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdShzKSxzLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKS5sZW5ndGg7RTxNOysrRSlpZihfPShpPShzLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdShzKSxzLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKSxFPj0wJiZFPGkubGVuZ3RoP2lbRV06bnVsbCksXy5pc0NoYW5nZWFibGUoKSYmIV8uaXNEZXJpdmVkKCkpe2lmKEwoXywxMDIpKWM9YShfLDE5KSwhKGMuZUZsYWdzJkdvKSYmKHE9R3QoYyksIShxJiZxLmVGbGFncyZHbykpJiZ4Ym4oZSxjLHUsbik7ZWxzZSBpZihIdCgpLGEoXyw2OSkuaXNGZWF0dXJlTWFwXzAoKSYmKHI9KEg9XyxhKEg/YShuLDU0KS5lU2V0dGluZyhIKTpudWxsLDE2MCkpLHIpKWZvcihtPWEodS5lR2V0XzAoXyksMTYwKSx0PXIuc2l6ZV8xKCksdj0wLHk9bS5zaXplXzEoKTt2PHk7Kyt2KWlmKGg9bS5nZXRFU3RydWN0dXJhbEZlYXR1cmVfMCh2KSxMKGgsMTAyKSl7aWYoaz1tLmdldFZhbHVlXzEodiksbz14cyhlLGspLG89PW51bGwmJmshPW51bGwpe2lmKEE9YShoLDE5KSwhZS51c2VPcmlnaW5hbFJlZmVyZW5jZXN8fEEuZUZsYWdzJkdvfHxHdChBKSljb250aW51ZTtvPWt9aWYoIXIuYWRkXzYoaCxvKSl7Zm9yKHg9MDt4PHQ7Kyt4KWlmKHIuZ2V0RVN0cnVjdHVyYWxGZWF0dXJlXzAoeCk9PWgmJkQoci5nZXRWYWx1ZV8xKHgpKT09PUQobykpe3IubW92ZShyLnNpemVfMSgpLTEseCksLS10O2JyZWFrfX19ZWxzZSByLmFkZF82KG0uZ2V0RVN0cnVjdHVyYWxGZWF0dXJlXzAodiksbS5nZXRWYWx1ZV8xKHYpKX19ZnVuY3Rpb24gbVZlKCl7RGMuY2FsbCh0aGlzKSx0aGlzLnJlc29sdmVQcm94aWVzPSEwLHRoaXMudXNlT3JpZ2luYWxSZWZlcmVuY2VzPSEwfXAoMTE4OSwyMTUsaHAsbVZlKSxsLnJlc29sdmVQcm94aWVzPSExLGwudXNlT3JpZ2luYWxSZWZlcmVuY2VzPSExLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRWNvcmVVdGlsL0NvcGllciIsMTE4OSk7ZnVuY3Rpb24geVZlKGUpe2lmKGUucHJlcGFyZWRSZXN1bHQ9PW51bGwpe2Zvcig7ZS5pdGVyYXRvci5oYXNOZXh0XzAoKTspaWYoZS5wcmVwYXJlZFJlc3VsdD1lLml0ZXJhdG9yLm5leHRfMSgpLCFhKGUucHJlcGFyZWRSZXN1bHQsNTQpLmVEaXJlY3RSZXNvdXJjZSgpKXJldHVybiEwO3JldHVybiBlLnByZXBhcmVkUmVzdWx0PW51bGwsITF9ZWxzZSByZXR1cm4hMH1mdW5jdGlvbiB3VmUoZSl7dmFyIG47bj1lLmVDb250ZW50c18wKCksdGhpcy5pdGVyYXRvcj1MKG4sNzEpP2Eobiw3MSkuYmFzaWNJdGVyYXRvcigpOm4uaXRlcmF0b3JfMCgpfXAoNzU5LDEsc3Qsd1ZlKSxsLmZvckVhY2hSZW1haW5pbmc9ZnVuY3Rpb24obil7d3QodGhpcyxuKX0sbC5oYXNOZXh0XzA9ZnVuY3Rpb24oKXtyZXR1cm4geVZlKHRoaXMpfSxsLm5leHRfMT1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB5VmUodGhpcyksbj10aGlzLnByZXBhcmVkUmVzdWx0LHRoaXMucHJlcGFyZWRSZXN1bHQ9bnVsbCxufSxsLnJlbW92ZT1mdW5jdGlvbigpe3RoaXMuaXRlcmF0b3IucmVtb3ZlKCl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRWNvcmVVdGlsL1Byb3BlckNvbnRlbnRJdGVyYXRvciIsNzU5KTtmdW5jdGlvbiBFVmUoKXtFVmU9RixURigpLFNWZT1uZXcgdlZlfWZ1bmN0aW9uIHZWZSgpe1ZvZSgpfXAoMTUyOCwxNTI3LHt9LHZWZSk7dmFyIFNWZTtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkVjb3JlVmFsaWRhdG9yIiwxNTI4KTtmdW5jdGlvbiBIdCgpe0h0PUYsQ1ZlPW5ldyBUVmV9ZnVuY3Rpb24gVnUoZSxuKXtIdCgpO3ZhciByO3JldHVybiByPWEoZSw2OSkuZ2V0RmVhdHVyZU1hcEVudHJ5UHJvdG90eXBlKCksTTNuKHIsbiksci5jcmVhdGVFbnRyeShuKX1mdW5jdGlvbiBJaShlLG4pe0h0KCk7dmFyIHIsdCxvLGk7cmV0dXJuIG4/bj09KG9yKCksalZlKXx8KG49PU9WZXx8bj09YzF8fG49PWtWZSkmJmUhPUVvZT9uZXcgaG9lKGUsbik6KHQ9YShuLDY5Mikscj10LmdldEV4dGVuZGVkTWV0YURhdGFfMCgpLHJ8fChjMih1bygoS2koKSxUdCksbikpLHI9dC5nZXRFeHRlbmRlZE1ldGFEYXRhXzAoKSksaT0oIXIudmFsaWRhdG9yTWFwJiYoci52YWxpZGF0b3JNYXA9bmV3IHNuKSxyLnZhbGlkYXRvck1hcCksbz1hKF9vKGp0KGkuaGFzaENvZGVNYXAsZSkpLDIwNDEpLCFvJiZCbihpLGUsbz1uZXcgaG9lKGUsbikpLG8pOkNWZX1mdW5jdGlvbiBDYyhlLG4pe0h0KCk7dmFyIHIsdCxvO3JldHVybiBuLmlzTWFueSgpPyEwOm4uZ2V0VXBwZXJCb3VuZCgpPT0tMj9uPT0oQW0oKSxrbSl8fG49PUxtfHxuPT1ORnx8bj09QUY/ITA6KG89ZS5lQ2xhc3NfMCgpLEVyKG8sbik+PTA/ITE6KHI9VWcoKEtpKCksVHQpLG8sbikscj8odD1yLmdldFVwcGVyQm91bmQoKSwodD4xfHx0PT0tMSkmJlJkKHVvKFR0LHIpKSE9Myk6ITApKTohMX12YXIgQ1ZlO0NyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUudXRpbCIsIkZlYXR1cmVNYXBVdGlsL1ZhbGlkYXRvciIpO2Z1bmN0aW9uIFRWZSgpe31wKDEyOTUsMSx7MjA0MToxfSxUVmUpLGwuaXNWYWxpZD1mdW5jdGlvbihuKXtyZXR1cm4hMH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJGZWF0dXJlTWFwVXRpbC8xIiwxMjk1KTtmdW5jdGlvbiBiVmUoKXtiVmU9Rix4Rj0oTmUoKSxuZXcgWjUoIiMjYW55IikpfWZ1bmN0aW9uIE5ibihlLG4pe3ZhciByO3JldHVybiBlLndpbGRjYXJkcz09eEY/KHI9UmQodW8oKEtpKCksVHQpLG4pKSxlLmlzRWxlbWVudD9yPT00JiZuIT0oQW0oKSxrbSkmJm4hPShBbSgpLExtKSYmbiE9KEFtKCksTkYpJiZuIT0oQW0oKSxBRik6cj09Mik6ZS5ncm91cE1lbWJlcnMmJihlLmdyb3VwTWVtYmVycy5jb250YWlucyhuKXx8ZS5ncm91cE1lbWJlcnMuY29udGFpbnMoUG0odW8oKEtpKCksVHQpLG4pKSl8fGUuZ3JvdXBNZW1iZXJzLmNvbnRhaW5zKFVnKChLaSgpLFR0KSxlLmNvbnRhaW5pbmdDbGFzcyxuKSkpPyEwOmUud2lsZGNhcmRzJiZRdGUoKEtpKCksZS53aWxkY2FyZHMpLHhiKHVvKFR0LG4pKSk/KHI9UmQodW8oVHQsbikpLGUuaXNFbGVtZW50P3I9PTQ6cj09Mik6ITF9ZnVuY3Rpb24gaG9lKGUsbil7YlZlKCk7dmFyIHIsdCxvLGkscyx1LGM7aWYodGhpcy5jYWNoZT1uZXcgbW9lKHRoaXMpLHRoaXMuY29udGFpbmluZ0NsYXNzPWUsdGhpcy5lU3RydWN0dXJhbEZlYXR1cmU9bix0aGlzLndpbGRjYXJkcz13Rih1bygoS2koKSxUdCksbikpLHRoaXMud2lsZGNhcmRzLmlzRW1wdHkoKSlpZigodT1KdGUoVHQsZSkpPT1uKWZvcih0aGlzLmlzRWxlbWVudD0hMCx0aGlzLmdyb3VwTWVtYmVycz1uZXcgUSx0aGlzLndpbGRjYXJkcz1uZXcgRUhlLHRoaXMud2lsZGNhcmRzLmFkZF8yKCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAzL1hNTFR5cGUiKSxhKCRMKGJiKFR0LEhhKGUpKSwiIiksMjkpPT1lJiZ0aGlzLndpbGRjYXJkcy5hZGRfMih4UyhUdCxIYShlKSkpLG89bUYoVHQsZSkuaXRlcmF0b3JfMCgpO28uaGFzTmV4dF8wKCk7KXN3aXRjaCh0PWEoby5uZXh0XzEoKSwxNzkpLFJkKHVvKFR0LHQpKSl7Y2FzZSA0Ont0aGlzLmdyb3VwTWVtYmVycy5hZGRfMih0KTticmVha31jYXNlIDU6e3RoaXMud2lsZGNhcmRzLmFkZEFsbCh3Rih1byhUdCx0KSkpO2JyZWFrfX1lbHNlIGlmKEh0KCksYShuLDY5KS5pc0ZlYXR1cmVNYXBfMCgpKWZvcih0aGlzLmlzRWxlbWVudD0hMCx0aGlzLndpbGRjYXJkcz1udWxsLHRoaXMuZ3JvdXBNZW1iZXJzPW5ldyBRLHM9MCxjPShlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhPT1udWxsJiZFdShlKSxlLmVBbGxTdHJ1Y3R1cmFsRmVhdHVyZXNEYXRhKS5sZW5ndGg7czxjOysrcylmb3IodD0ocj0oZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YT09bnVsbCYmRXUoZSksZS5lQWxsU3RydWN0dXJhbEZlYXR1cmVzRGF0YSkscz49MCYmczxyLmxlbmd0aD9yW3NdOm51bGwpLGk9UG0odW8oVHQsdCkpO2k7aT1QbSh1byhUdCxpKSkpaT09biYmdGhpcy5ncm91cE1lbWJlcnMuYWRkXzIodCk7ZWxzZSBSZCh1byhUdCxuKSk9PTEmJnU/KHRoaXMud2lsZGNhcmRzPW51bGwsdGhpcy5ncm91cE1lbWJlcnM9KEFtKCksTlZlKSk6KHRoaXMud2lsZGNhcmRzPW51bGwsdGhpcy5pc0VsZW1lbnQ9ITAsdGhpcy5ncm91cE1lbWJlcnM9KE5lKCksbmV3IFo1KG4pKSk7ZWxzZSB0aGlzLmlzRWxlbWVudD1SZCh1byhUdCxuKSk9PTUsdGhpcy53aWxkY2FyZHMuZXF1YWxzXzAoeEYpJiYodGhpcy53aWxkY2FyZHM9eEYpfXAoNzczLDEsezIwNDE6MX0saG9lKSxsLmlzVmFsaWQ9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHRoaXMuZVN0cnVjdHVyYWxGZWF0dXJlPT1uPyEwOihyPWllKEtlKHRoaXMuY2FjaGUsbikpLHI9PW51bGw/TmJuKHRoaXMsbik/KElWZSh0aGlzLmNhY2hlLG4sKHplKCksb3kpKSwhMCk6KElWZSh0aGlzLmNhY2hlLG4sKHplKCksUzApKSwhMSk6cj09KHplKCksb3kpKX0sbC5pc0VsZW1lbnQ9ITE7dmFyIHhGO2coIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRmVhdHVyZU1hcFV0aWwvQmFzaWNWYWxpZGF0b3IiLDc3Myk7ZnVuY3Rpb24gSVZlKGUsbixyKXt2YXIgdDt0PW5ldyBtb2UoZS50aGlzJDExKSxiMih0LGUudGhpcyQxMS5jYWNoZSksZGkodC5oYXNoQ29kZU1hcCxuLHIpLGUudGhpcyQxMS5jYWNoZT10fWZ1bmN0aW9uIG1vZShlKXt0aGlzLnRoaXMkMTE9ZSxzbi5jYWxsKHRoaXMpfXAoNzc0LDQ1LGhwLG1vZSksZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJGZWF0dXJlTWFwVXRpbC9CYXNpY1ZhbGlkYXRvci9DYWNoZSIsNzc0KTtmdW5jdGlvbiBOUyhlLG4pe3JldHVybiBqVG4oZS5mZWF0dXJlTWFwLGUuZmVhdHVyZSxuKX1mdW5jdGlvbiB4VmUoZSxuLHIpe3JldHVybiB0b2UoZS5mZWF0dXJlTWFwLGUuZmVhdHVyZSxuLHIpfWZ1bmN0aW9uIE5tKGUpe0dMKGUuZmVhdHVyZU1hcCxlLmZlYXR1cmUpfWZ1bmN0aW9uIEtMKGUpe3JldHVybiBBYihlLmZlYXR1cmVNYXAsZS5mZWF0dXJlKX1mdW5jdGlvbiBrYihlLG4pe3RoaXMuZmVhdHVyZT1lLHRoaXMuZmVhdHVyZU1hcD1ufXAoNTA5LDU2LHsyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNjE6MSw3OToxLDcxOjEsOTc6MX0sa2IpLGwuYWRkXzM9ZnVuY3Rpb24obixyKXtHamUodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLHIpfSxsLmFkZF8yPWZ1bmN0aW9uKG4pe3JldHVybiBub2UodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuKX0sbC5hZGRBbGxfMD1mdW5jdGlvbihuLHIpe3JldHVybiBXVG4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLHIpfSxsLmFkZEFsbD1mdW5jdGlvbihuKXtyZXR1cm4gTlModGhpcyxuKX0sbC5hZGRVbmlxdWU9ZnVuY3Rpb24obixyKXtWVG4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLHIpfSxsLmJhc2ljQWRkPWZ1bmN0aW9uKG4scil7cmV0dXJuIHJvZSh0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4scil9LGwuYmFzaWNHZXQ9ZnVuY3Rpb24obil7cmV0dXJuIFdMKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsbiwhMSl9LGwuYmFzaWNJdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBIamUodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGwuYmFzaWNMaXN0SXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gS1RuKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUpfSxsLmJhc2ljTGlzdEl0ZXJhdG9yXzA9ZnVuY3Rpb24obil7cmV0dXJuIFhUbih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4pfSxsLmJhc2ljUmVtb3ZlPWZ1bmN0aW9uKG4scil7cmV0dXJuIHhWZSh0aGlzLG4scil9LGwuY2xlYXJfMD1mdW5jdGlvbigpe05tKHRoaXMpfSxsLmNvbnRhaW5zPWZ1bmN0aW9uKG4pe3JldHVybiBITCh0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4pfSxsLmNvbnRhaW5zQWxsPWZ1bmN0aW9uKG4pe3JldHVybiBKVG4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuKX0sbC5nZXRfMD1mdW5jdGlvbihuKXtyZXR1cm4gV0wodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLCEwKX0sbC5nZXRfNj1mdW5jdGlvbihuKXtyZXR1cm4gdGhpc30sbC5pbmRleE9mXzA9ZnVuY3Rpb24obil7cmV0dXJuIFpUbih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4pfSxsLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gS0wodGhpcyl9LGwuaXNTZXRfMD1mdW5jdGlvbigpe3JldHVybiFBYih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlKX0sbC5pdGVyYXRvcl8wPWZ1bmN0aW9uKCl7cmV0dXJuIHJibih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlKX0sbC5saXN0SXRlcmF0b3JfMD1mdW5jdGlvbigpe3JldHVybiB0Ym4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGwubGlzdEl0ZXJhdG9yXzE9ZnVuY3Rpb24obil7cmV0dXJuIG9ibih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4pfSxsLm1vdmU9ZnVuY3Rpb24obixyKXtyZXR1cm4gVWplKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsbixyKX0sbC5tb3ZlXzA9ZnVuY3Rpb24obixyKXthYm4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLHIpfSxsLnJlbW92ZV8yPWZ1bmN0aW9uKG4pe3JldHVybiBXamUodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuKX0sbC5yZW1vdmVfMT1mdW5jdGlvbihuKXtyZXR1cm4gbGJuKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsbil9LGwuc2V0XzI9ZnVuY3Rpb24obixyKXtyZXR1cm4gamplKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsbixyKX0sbC5zZXRfMT1mdW5jdGlvbihuKXtHTCh0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlKSxOUyh0aGlzLGEobiwxNSkpfSxsLnNpemVfMT1mdW5jdGlvbigpe3JldHVybiBmYm4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGwudG9BcnJheT1mdW5jdGlvbigpe3JldHVybiBwYm4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGwudG9BcnJheV8wPWZ1bmN0aW9uKG4pe3JldHVybiBoYm4odGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG4scjtmb3Iocj1uZXcgTGMsci5zdHJpbmcrPSJbIixuPUhqZSh0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlKTtTRihuKTspSnQocix6MihxTChuKSkpLFNGKG4pJiYoci5zdHJpbmcrPSIsICIpO3JldHVybiByLnN0cmluZys9Il0iLHIuc3RyaW5nfSxsLnVuc2V0PWZ1bmN0aW9uKCl7R0wodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRmVhdHVyZU1hcFV0aWwvRmVhdHVyZUVMaXN0Iiw1MDkpO2Z1bmN0aW9uIEFTKGUsbil7dmFyIHI7cmV0dXJuIGUuZmVhdHVyZUlEPT0tMSYmZS5mZWF0dXJlJiYocj1lLmZlYXR1cmUuZ2V0Q29udGFpbmVyQ2xhc3MoKSxlLmZlYXR1cmVJRD1yP2Uubm90aWZpZXIuZURlcml2ZWRTdHJ1Y3R1cmFsRmVhdHVyZUlEKGUuZmVhdHVyZS5nZXRGZWF0dXJlSURfMCgpLHIpOkVyKGUubm90aWZpZXIuZUNsYXNzXzAoKSxlLmZlYXR1cmUpKSxlLm5vdGlmaWVyLmVCYXNlU3RydWN0dXJhbEZlYXR1cmVJRChlLmZlYXR1cmVJRCxuKX1mdW5jdGlvbiBQRihlLG4scix0LG8saSxzKXttRC5jYWxsKHRoaXMsbix0LG8saSxzKSx0aGlzLm5vdGlmaWVyPWUsdGhpcy5mZWF0dXJlPXJ9cCg2NDQsMzksUVMsUEYpLGwuZ2V0RmVhdHVyZUlEPWZ1bmN0aW9uKG4pe3JldHVybiBBUyh0aGlzLG4pfSxsLm1lcmdlXzA9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGM7c3dpdGNoKHRoaXMuZXZlbnRUeXBlKXtjYXNlIDE6Y2FzZSAyOntpZihzPW4uZ2V0Tm90aWZpZXIoKSxEKHMpPT09RCh0aGlzLm5vdGlmaWVyKSYmQVModGhpcyxudWxsKT09bi5nZXRGZWF0dXJlSUQobnVsbCkpcmV0dXJuIHRoaXMubmV3VmFsdWU9bi5nZXROZXdWYWx1ZSgpLG4uZ2V0RXZlbnRUeXBlKCk9PTEmJih0aGlzLmV2ZW50VHlwZT0xKSwhMDticmVha31jYXNlIDM6e3N3aXRjaChpPW4uZ2V0RXZlbnRUeXBlKCksaSl7Y2FzZSAzOntpZihzPW4uZ2V0Tm90aWZpZXIoKSxEKHMpPT09RCh0aGlzLm5vdGlmaWVyKSYmQVModGhpcyxudWxsKT09bi5nZXRGZWF0dXJlSUQobnVsbCkpcmV0dXJuIHRoaXMuZXZlbnRUeXBlPTUscj1uZXcgUGQoMikscG4ocix0aGlzLm5ld1ZhbHVlKSxwbihyLG4uZ2V0TmV3VmFsdWUoKSksdGhpcy5uZXdWYWx1ZT1yLCEwO2JyZWFrfX1icmVha31jYXNlIDU6e3N3aXRjaChpPW4uZ2V0RXZlbnRUeXBlKCksaSl7Y2FzZSAzOntpZihzPW4uZ2V0Tm90aWZpZXIoKSxEKHMpPT09RCh0aGlzLm5vdGlmaWVyKSYmQVModGhpcyxudWxsKT09bi5nZXRGZWF0dXJlSUQobnVsbCkpcmV0dXJuIHQ9YSh0aGlzLm5ld1ZhbHVlLDE2KSx0LmFkZF8yKG4uZ2V0TmV3VmFsdWUoKSksITA7YnJlYWt9fWJyZWFrfWNhc2UgNDp7c3dpdGNoKGk9bi5nZXRFdmVudFR5cGUoKSxpKXtjYXNlIDM6e2lmKHM9bi5nZXROb3RpZmllcigpLEQocyk9PT1EKHRoaXMubm90aWZpZXIpJiZBUyh0aGlzLG51bGwpPT1uLmdldEZlYXR1cmVJRChudWxsKSlyZXR1cm4gdGhpcy5ldmVudFR5cGU9MSx0aGlzLm5ld1ZhbHVlPW4uZ2V0TmV3VmFsdWUoKSwhMDticmVha31jYXNlIDQ6e2lmKHM9bi5nZXROb3RpZmllcigpLEQocyk9PT1EKHRoaXMubm90aWZpZXIpJiZBUyh0aGlzLG51bGwpPT1uLmdldEZlYXR1cmVJRChudWxsKSlyZXR1cm4gdGhpcy5ldmVudFR5cGU9NixjPW5ldyBQZCgyKSxwbihjLHRoaXMub2xkVmFsdWUpLHBuKGMsbi5nZXRPbGRWYWx1ZSgpKSx0aGlzLm9sZFZhbHVlPWMsdT1QKEkoaG4sMSksa24sMjgsMTUsW3RoaXMucG9zaXRpb24sbi5nZXRQb3NpdGlvbl8wKCldKSx0aGlzLm5ld1ZhbHVlPXUsITA7YnJlYWt9fWJyZWFrfWNhc2UgNjp7c3dpdGNoKGk9bi5nZXRFdmVudFR5cGUoKSxpKXtjYXNlIDQ6e2lmKHM9bi5nZXROb3RpZmllcigpLEQocyk9PT1EKHRoaXMubm90aWZpZXIpJiZBUyh0aGlzLG51bGwpPT1uLmdldEZlYXR1cmVJRChudWxsKSlyZXR1cm4gdD1hKHRoaXMub2xkVmFsdWUsMTYpLHQuYWRkXzIobi5nZXRPbGRWYWx1ZSgpKSx1PWEodGhpcy5uZXdWYWx1ZSw1Myksbz1CKGhuLGtuLDI4LHUubGVuZ3RoKzEsMTUsMSksWG8odSwwLG8sMCx1Lmxlbmd0aCksb1t1Lmxlbmd0aF09bi5nZXRQb3NpdGlvbl8wKCksdGhpcy5uZXdWYWx1ZT1vLCEwO2JyZWFrfX1icmVha319cmV0dXJuITF9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRmVhdHVyZU1hcFV0aWwvRmVhdHVyZUVOb3RpZmljYXRpb25JbXBsIiw2NDQpO2Z1bmN0aW9uIFhMKGUsbil7a2IuY2FsbCh0aGlzLGUsbiksdGhpcy53cmFwcGVyPXRoaXN9cCg1NjQsNTA5LHsyMDoxLDMxOjEsNTY6MSwxNjoxLDE1OjEsNjE6MSw3OToxLDE2MDoxLDIyMDoxLDIwMzY6MSw3MToxLDk3OjF9LFhMKSxsLmFkZF82PWZ1bmN0aW9uKG4scil7cmV0dXJuIG5vZSh0aGlzLmZlYXR1cmVNYXAsbixyKX0sbC5iYXNpY0FkZF8wPWZ1bmN0aW9uKG4scix0KXtyZXR1cm4gcm9lKHRoaXMuZmVhdHVyZU1hcCxuLHIsdCl9LGwuYmFzaWNSZW1vdmVfMD1mdW5jdGlvbihuLHIsdCl7cmV0dXJuIHRvZSh0aGlzLmZlYXR1cmVNYXAsbixyLHQpfSxsLmZlYXR1cmVNYXBfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSxsLmdldF83PWZ1bmN0aW9uKG4scil7cmV0dXJuIE5iKHRoaXMuZmVhdHVyZU1hcCxuLHIpfSxsLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZV8wPWZ1bmN0aW9uKG4pe3JldHVybiBhKFdMKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsbiwhMSksNzYpLmdldEVTdHJ1Y3R1cmFsRmVhdHVyZSgpfSxsLmdldFZhbHVlXzE9ZnVuY3Rpb24obil7cmV0dXJuIGEoV0wodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSxuLCExKSw3NikuZ2V0VmFsdWUoKX0sbC5nZXRXcmFwcGVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud3JhcHBlcn0sbC5pc1NldF8xPWZ1bmN0aW9uKG4pe3JldHVybiFBYih0aGlzLmZlYXR1cmVNYXAsbil9LGwuc2V0XzM9ZnVuY3Rpb24obixyKXtqTCh0aGlzLmZlYXR1cmVNYXAsbixyKX0sbC5zZXR0aW5nPWZ1bmN0aW9uKG4pe3JldHVybiBWamUodGhpcy5mZWF0dXJlTWFwLG4pfSxsLnVuc2V0XzA9ZnVuY3Rpb24obil7S2plKHRoaXMuZmVhdHVyZU1hcCxuKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnV0aWwiLCJGZWF0dXJlTWFwVXRpbC9GZWF0dXJlRmVhdHVyZU1hcCIsNTY0KTtmdW5jdGlvbiBQVmUoZSxuKXt0aGlzLmZlYXR1cmU9ZSx0aGlzLmZlYXR1cmVNYXA9bn1wKDEyOTQsMSx3NixQVmUpLGwuZ2V0XzY9ZnVuY3Rpb24obil7cmV0dXJuIFdMKHRoaXMuZmVhdHVyZU1hcCx0aGlzLmZlYXR1cmUsLTEsbil9LGwuaXNTZXRfMD1mdW5jdGlvbigpe3JldHVybiFBYih0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlKX0sbC5zZXRfMT1mdW5jdGlvbihuKXtqTCh0aGlzLmZlYXR1cmVNYXAsdGhpcy5mZWF0dXJlLG4pfSxsLnVuc2V0PWZ1bmN0aW9uKCl7R0wodGhpcy5mZWF0dXJlTWFwLHRoaXMuZmVhdHVyZSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS51dGlsIiwiRmVhdHVyZU1hcFV0aWwvRmVhdHVyZVZhbHVlIiwxMjk0KTtmdW5jdGlvbiBBbSgpe0FtPUYsa209YShPKEcoKHdvZSgpLFdvKS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw2KSwzNSksTG09YShPKEcoV28ueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksMyksMzUpLE5GPWEoTyhHKFdvLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDQpLDM1KSxBRj1hKE8oRyhXby54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw1KSwxOSksd0woa20pLHdMKExtKSx3TChORiksd0woQUYpLE5WZT1uZXcgZWEoUChJKFJpLDEpLEVwLDE3OSwwLFtrbSxMbV0pKX12YXIgTG0sTkYsQUYsa20sTlZlLE9iPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUiLCJBbnlUeXBlIik7ZnVuY3Rpb24gTEYoZSl7SW8uY2FsbCh0aGlzLGUpfXAoNjgwLDYzLEt1LExGKSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUiLCJJbnZhbGlkRGF0YXR5cGVWYWx1ZUV4Y2VwdGlvbiIsNjgwKTt2YXIgSkw9Q3IoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZSIsIlByb2Nlc3NpbmdJbnN0cnVjdGlvbiIpLE1iPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUiLCJTaW1wbGVBbnlUeXBlIikseW9lPUNyKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUiLCJYTUxUeXBlRG9jdW1lbnRSb290Iik7ZnVuY3Rpb24gQVZlKCl7QVZlPUYsTFZlPVZibigpfXZhciBMVmU7ZnVuY3Rpb24gd29lKCl7d29lPUYsV289SmJuKCl9dmFyIFdvO2Z1bmN0aW9uIG9yKCl7b3I9RixFb2U9KHdvZSgpLFdvKS5hbnlUeXBlRUNsYXNzLE9WZT1hKE8oRyhXby5hbnlUeXBlRUNsYXNzKSwwKSwzNSksYzE9YShPKEcoV28uYW55VHlwZUVDbGFzcyksMSksMzUpLGtWZT1hKE8oRyhXby5hbnlUeXBlRUNsYXNzKSwyKSwzNSksamc9V28ucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzLGEoTyhHKFdvLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcyksMCksMzUpLGEoTyhHKFdvLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcyksMSksMzUpLFZnPVdvLnNpbXBsZUFueVR5cGVFQ2xhc3MsTFM9YShPKEcoV28uc2ltcGxlQW55VHlwZUVDbGFzcyksMCksMzUpLGEoTyhHKFdvLnNpbXBsZUFueVR5cGVFQ2xhc3MpLDEpLDM1KSxhKE8oRyhXby5zaW1wbGVBbnlUeXBlRUNsYXNzKSwyKSwxOSksRGQ9V28ueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyxqVmU9YShPKEcoV28ueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksMCksMzUpLGEoTyhHKFdvLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDEpLDE5KSxhKE8oRyhXby54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwyKSwxOSksUmI9YShPKEcoV28ueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksMyksMzUpLERiPWEoTyhHKFdvLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDQpLDM1KSxPUz1hKE8oRyhXby54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw2KSwzNSksa1M9YShPKEcoV28ueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksNSksMTkpLE1WZT1Xby5kYXRlRURhdGFUeXBlLFJWZT1Xby5kYXRlVGltZUVEYXRhVHlwZSxEVmU9V28uZHVyYXRpb25FRGF0YVR5cGUsRlZlPVdvLmdEYXlFRGF0YVR5cGUselZlPVdvLmdNb250aEVEYXRhVHlwZSwkVmU9V28uZ01vbnRoRGF5RURhdGFUeXBlLEJWZT1Xby5nWWVhckVEYXRhVHlwZSxHVmU9V28uZ1llYXJNb250aEVEYXRhVHlwZSxIVmU9V28ubm90YXRpb25FRGF0YVR5cGUsVVZlPVdvLnFOYW1lRURhdGFUeXBlLFdWZT1Xby50aW1lRURhdGFUeXBlfXZhciBFb2UsYzEsa1ZlLE9WZSxNVmUsUlZlLERWZSxGVmUselZlLCRWZSxCVmUsR1ZlLEhWZSxqZyxVVmUsVmcsTFMsV1ZlLERkLFJiLERiLGpWZSxrUyxPUztmdW5jdGlvbiB2b2UoKXtoTC5jYWxsKHRoaXMpfXAoODQ0LDUxNix7MTEwOjEsOTQ6MSw5MzoxLDU4OjEsNTQ6MSw5OToxLDg1NzoxfSx2b2UpLGwuZUdldD1mdW5jdGlvbihuLHIsdCl7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4gdD8oIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx0aGlzLm1peGVkKTooIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx0aGlzLm1peGVkLndyYXBwZXIpO2Nhc2UgMTpyZXR1cm4gdD8oIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxhKHNpKHRoaXMubWl4ZWQsKG9yKCksYzEpKSwxNjApKTooIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxhKGEoc2kodGhpcy5taXhlZCwob3IoKSxjMSkpLDE2MCksMjIwKSkuZ2V0V3JhcHBlcigpO2Nhc2UgMjpyZXR1cm4gdD8oIXRoaXMuYW55QXR0cmlidXRlJiYodGhpcy5hbnlBdHRyaWJ1dGU9bmV3IE5yKHRoaXMsMikpLHRoaXMuYW55QXR0cmlidXRlKTooIXRoaXMuYW55QXR0cmlidXRlJiYodGhpcy5hbnlBdHRyaWJ1dGU9bmV3IE5yKHRoaXMsMikpLHRoaXMuYW55QXR0cmlidXRlLndyYXBwZXIpfXJldHVybiBsbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6dGhpcy5lU3RhdGljQ2xhc3MoKSxuKSxyLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxQYih0aGlzLm1peGVkLG4sdCk7Y2FzZSAxOnJldHVybighdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGEoYShzaSh0aGlzLm1peGVkLChvcigpLGMxKSksMTYwKSw3MSkpLmJhc2ljUmVtb3ZlKG4sdCk7Y2FzZSAyOnJldHVybiF0aGlzLmFueUF0dHJpYnV0ZSYmKHRoaXMuYW55QXR0cmlidXRlPW5ldyBOcih0aGlzLDIpKSxQYih0aGlzLmFueUF0dHJpYnV0ZSxuLHQpfXJldHVybiBvPWEoa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6dGhpcy5lU3RhdGljQ2xhc3MoKSxyKSw2OSksby5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZVJlbW92ZSh0aGlzLFVlZSh0aGlzKSxyLW9uKHRoaXMuZVN0YXRpY0NsYXNzKCkpLG4sdCl9LGwuZUlzU2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDA6cmV0dXJuISF0aGlzLm1peGVkJiZ0aGlzLm1peGVkLnNpemVfMCE9MDtjYXNlIDE6cmV0dXJuISghdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGEoc2kodGhpcy5taXhlZCwob3IoKSxjMSkpLDE2MCkpLmlzRW1wdHkoKTtjYXNlIDI6cmV0dXJuISF0aGlzLmFueUF0dHJpYnV0ZSYmdGhpcy5hbnlBdHRyaWJ1dGUuc2l6ZV8wIT0wfXJldHVybiBzbCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6dGhpcy5lU3RhdGljQ2xhc3MoKSxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3N3aXRjaChuKXtjYXNlIDA6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxMYih0aGlzLm1peGVkLHIpO3JldHVybjtjYXNlIDE6KCF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksYShhKHNpKHRoaXMubWl4ZWQsKG9yKCksYzEpKSwxNjApLDIyMCkpLnNldF8xKHIpO3JldHVybjtjYXNlIDI6IXRoaXMuYW55QXR0cmlidXRlJiYodGhpcy5hbnlBdHRyaWJ1dGU9bmV3IE5yKHRoaXMsMikpLExiKHRoaXMuYW55QXR0cmlidXRlLHIpO3JldHVybn11bCh0aGlzLG4tb24odGhpcy5lU3RhdGljQ2xhc3MoKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6dGhpcy5lU3RhdGljQ2xhc3MoKSxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gb3IoKSxFb2V9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDA6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxmbih0aGlzLm1peGVkKTtyZXR1cm47Y2FzZSAxOighdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGEoc2kodGhpcy5taXhlZCwob3IoKSxjMSkpLDE2MCkpLmNsZWFyXzAoKTtyZXR1cm47Y2FzZSAyOiF0aGlzLmFueUF0dHJpYnV0ZSYmKHRoaXMuYW55QXR0cmlidXRlPW5ldyBOcih0aGlzLDIpKSxmbih0aGlzLmFueUF0dHJpYnV0ZSk7cmV0dXJufWNsKHRoaXMsbi1vbih0aGlzLmVTdGF0aWNDbGFzcygpKSxrZSh0aGlzLmVGbGFncyYyPyghdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzKS5nZXRFQ2xhc3MoKTp0aGlzLmVTdGF0aWNDbGFzcygpLG4pKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuZUZsYWdzJjQ/bnModGhpcyk6KG49bmV3IHlsKG5zKHRoaXMpKSxuLnN0cmluZys9IiAobWl4ZWQ6ICIsJDIobix0aGlzLm1peGVkKSxuLnN0cmluZys9IiwgYW55QXR0cmlidXRlOiAiLCQyKG4sdGhpcy5hbnlBdHRyaWJ1dGUpLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIkFueVR5cGVJbXBsIiw4NDQpO2Z1bmN0aW9uIEFibihlLG4pe2UuZGF0YV8wPW59ZnVuY3Rpb24gTGJuKGUsbil7ZS50YXJnZXQ9bn1mdW5jdGlvbiBWVmUoKXt9cCg2ODEsNTE2LHsxMTA6MSw5NDoxLDkzOjEsNTg6MSw1NDoxLDk5OjEsMjExOToxLDY4MToxfSxWVmUpLGwuZUdldD1mdW5jdGlvbihuLHIsdCl7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4gdGhpcy5kYXRhXzA7Y2FzZSAxOnJldHVybiB0aGlzLnRhcmdldH1yZXR1cm4gbGwodGhpcyxuLW9uKChvcigpLGpnKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6amcsbikscix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4gdGhpcy5kYXRhXzAhPW51bGw7Y2FzZSAxOnJldHVybiB0aGlzLnRhcmdldCE9bnVsbH1yZXR1cm4gc2wodGhpcyxuLW9uKChvcigpLGpnKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6amcsbikpfSxsLmVTZXQ9ZnVuY3Rpb24obixyKXtzd2l0Y2gobil7Y2FzZSAwOkFibih0aGlzLHhuKHIpKTtyZXR1cm47Y2FzZSAxOkxibih0aGlzLHhuKHIpKTtyZXR1cm59dWwodGhpcyxuLW9uKChvcigpLGpnKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6amcsbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG9yKCksamd9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDA6dGhpcy5kYXRhXzA9bnVsbDtyZXR1cm47Y2FzZSAxOnRoaXMudGFyZ2V0PW51bGw7cmV0dXJufWNsKHRoaXMsbi1vbigob3IoKSxqZykpLGtlKHRoaXMuZUZsYWdzJjI/KCF0aGlzLmVQcm9wZXJ0aWVzJiYodGhpcy5lUHJvcGVydGllcz1uZXcgdnMpLHRoaXMuZVByb3BlcnRpZXMpLmdldEVDbGFzcygpOmpnLG4pKX0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7dmFyIG47cmV0dXJuIHRoaXMuZUZsYWdzJjQ/bnModGhpcyk6KG49bmV3IHlsKG5zKHRoaXMpKSxuLnN0cmluZys9IiAoZGF0YTogIixKdChuLHRoaXMuZGF0YV8wKSxuLnN0cmluZys9IiwgdGFyZ2V0OiAiLEp0KG4sdGhpcy50YXJnZXQpLG4uc3RyaW5nKz0iKSIsbi5zdHJpbmcpfSxsLmRhdGFfMD1udWxsLGwudGFyZ2V0PW51bGwsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25JbXBsIiw2ODEpO2Z1bmN0aW9uIGtibihlLG4pe2UuaW5zdGFuY2VUeXBlPW59ZnVuY3Rpb24gU29lKGUsbil7IWUubWl4ZWQmJihlLm1peGVkPW5ldyBOcihlLDApKSxqTChlLm1peGVkLChvcigpLExTKSxuKX1mdW5jdGlvbiBxVmUoKXt2b2UuY2FsbCh0aGlzKX1wKDY4Miw4NDQsezExMDoxLDk0OjEsOTM6MSw1ODoxLDU0OjEsOTk6MSw4NTc6MSwyMTIwOjEsNjgyOjF9LHFWZSksbC5lR2V0PWZ1bmN0aW9uKG4scix0KXtzd2l0Y2gobil7Y2FzZSAwOnJldHVybiB0PyghdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLHRoaXMubWl4ZWQpOighdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLHRoaXMubWl4ZWQud3JhcHBlcik7Y2FzZSAxOnJldHVybiB0PyghdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGEoc2kodGhpcy5taXhlZCwob3IoKSxjMSkpLDE2MCkpOighdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGEoYShzaSh0aGlzLm1peGVkLChvcigpLGMxKSksMTYwKSwyMjApKS5nZXRXcmFwcGVyKCk7Y2FzZSAyOnJldHVybiB0PyghdGhpcy5hbnlBdHRyaWJ1dGUmJih0aGlzLmFueUF0dHJpYnV0ZT1uZXcgTnIodGhpcywyKSksdGhpcy5hbnlBdHRyaWJ1dGUpOighdGhpcy5hbnlBdHRyaWJ1dGUmJih0aGlzLmFueUF0dHJpYnV0ZT1uZXcgTnIodGhpcywyKSksdGhpcy5hbnlBdHRyaWJ1dGUud3JhcHBlcik7Y2FzZSAzOnJldHVybiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSkseG4oTmIodGhpcy5taXhlZCwob3IoKSxMUyksITApKTtjYXNlIDQ6cmV0dXJuIGdvZSh0aGlzLmluc3RhbmNlVHlwZSwoIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx4bihOYih0aGlzLm1peGVkLChvcigpLExTKSwhMCkpKSk7Y2FzZSA1OnJldHVybiB0aGlzLmluc3RhbmNlVHlwZX1yZXR1cm4gbGwodGhpcyxuLW9uKChvcigpLFZnKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6Vmcsbikscix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMubWl4ZWQmJnRoaXMubWl4ZWQuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4hKCF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksYShzaSh0aGlzLm1peGVkLChvcigpLGMxKSksMTYwKSkuaXNFbXB0eSgpO2Nhc2UgMjpyZXR1cm4hIXRoaXMuYW55QXR0cmlidXRlJiZ0aGlzLmFueUF0dHJpYnV0ZS5zaXplXzAhPTA7Y2FzZSAzOnJldHVybiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSkseG4oTmIodGhpcy5taXhlZCwob3IoKSxMUyksITApKSE9bnVsbDtjYXNlIDQ6cmV0dXJuIGdvZSh0aGlzLmluc3RhbmNlVHlwZSwoIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx4bihOYih0aGlzLm1peGVkLChvcigpLExTKSwhMCkpKSkhPW51bGw7Y2FzZSA1OnJldHVybiEhdGhpcy5pbnN0YW5jZVR5cGV9cmV0dXJuIHNsKHRoaXMsbi1vbigob3IoKSxWZykpLGtlKHRoaXMuZUZsYWdzJjI/KCF0aGlzLmVQcm9wZXJ0aWVzJiYodGhpcy5lUHJvcGVydGllcz1uZXcgdnMpLHRoaXMuZVByb3BlcnRpZXMpLmdldEVDbGFzcygpOlZnLG4pKX0sbC5lU2V0PWZ1bmN0aW9uKG4scil7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLExiKHRoaXMubWl4ZWQscik7cmV0dXJuO2Nhc2UgMTooIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxhKGEoc2kodGhpcy5taXhlZCwob3IoKSxjMSkpLDE2MCksMjIwKSkuc2V0XzEocik7cmV0dXJuO2Nhc2UgMjohdGhpcy5hbnlBdHRyaWJ1dGUmJih0aGlzLmFueUF0dHJpYnV0ZT1uZXcgTnIodGhpcywyKSksTGIodGhpcy5hbnlBdHRyaWJ1dGUscik7cmV0dXJuO2Nhc2UgMzpTb2UodGhpcyx4bihyKSk7cmV0dXJuO2Nhc2UgNDpTb2UodGhpcyxwb2UodGhpcy5pbnN0YW5jZVR5cGUscikpO3JldHVybjtjYXNlIDU6a2JuKHRoaXMsYShyLDE1NikpO3JldHVybn11bCh0aGlzLG4tb24oKG9yKCksVmcpKSxrZSh0aGlzLmVGbGFncyYyPyghdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzKS5nZXRFQ2xhc3MoKTpWZyxuKSxyKX0sbC5lU3RhdGljQ2xhc3M9ZnVuY3Rpb24oKXtyZXR1cm4gb3IoKSxWZ30sbC5lVW5zZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMDohdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLGZuKHRoaXMubWl4ZWQpO3JldHVybjtjYXNlIDE6KCF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksYShzaSh0aGlzLm1peGVkLChvcigpLGMxKSksMTYwKSkuY2xlYXJfMCgpO3JldHVybjtjYXNlIDI6IXRoaXMuYW55QXR0cmlidXRlJiYodGhpcy5hbnlBdHRyaWJ1dGU9bmV3IE5yKHRoaXMsMikpLGZuKHRoaXMuYW55QXR0cmlidXRlKTtyZXR1cm47Y2FzZSAzOiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksakwodGhpcy5taXhlZCwob3IoKSxMUyksbnVsbCk7cmV0dXJuO2Nhc2UgNDpTb2UodGhpcyxwb2UodGhpcy5pbnN0YW5jZVR5cGUsbnVsbCkpO3JldHVybjtjYXNlIDU6dGhpcy5pbnN0YW5jZVR5cGU9bnVsbDtyZXR1cm59Y2wodGhpcyxuLW9uKChvcigpLFZnKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6VmcsbikpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlNpbXBsZUFueVR5cGVJbXBsIiw2ODIpO2Z1bmN0aW9uIFlWZSgpe2hMLmNhbGwodGhpcyl9cCg2ODMsNTE2LHsxMTA6MSw5NDoxLDkzOjEsNTg6MSw1NDoxLDk5OjEsMjEyMToxLDY4MzoxfSxZVmUpLGwuZUdldD1mdW5jdGlvbihuLHIsdCl7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4gdD8oIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx0aGlzLm1peGVkKTooIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSx0aGlzLm1peGVkLndyYXBwZXIpO2Nhc2UgMTpyZXR1cm4gdD8oIXRoaXMueE1MTlNQcmVmaXhNYXAmJih0aGlzLnhNTE5TUHJlZml4TWFwPW5ldyBZaSgoUGUoKSxCdCksQm8sdGhpcywxKSksdGhpcy54TUxOU1ByZWZpeE1hcCk6KCF0aGlzLnhNTE5TUHJlZml4TWFwJiYodGhpcy54TUxOU1ByZWZpeE1hcD1uZXcgWWkoKFBlKCksQnQpLEJvLHRoaXMsMSkpLHBiKHRoaXMueE1MTlNQcmVmaXhNYXApKTtjYXNlIDI6cmV0dXJuIHQ/KCF0aGlzLnhTSVNjaGVtYUxvY2F0aW9uJiYodGhpcy54U0lTY2hlbWFMb2NhdGlvbj1uZXcgWWkoKFBlKCksQnQpLEJvLHRoaXMsMikpLHRoaXMueFNJU2NoZW1hTG9jYXRpb24pOighdGhpcy54U0lTY2hlbWFMb2NhdGlvbiYmKHRoaXMueFNJU2NoZW1hTG9jYXRpb249bmV3IFlpKChQZSgpLEJ0KSxCbyx0aGlzLDIpKSxwYih0aGlzLnhTSVNjaGVtYUxvY2F0aW9uKSk7Y2FzZSAzOnJldHVybiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksc2kodGhpcy5taXhlZCwob3IoKSxSYikpO2Nhc2UgNDpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLHNpKHRoaXMubWl4ZWQsKG9yKCksRGIpKTtjYXNlIDU6cmV0dXJuIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxzaSh0aGlzLm1peGVkLChvcigpLGtTKSk7Y2FzZSA2OnJldHVybiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksc2kodGhpcy5taXhlZCwob3IoKSxPUykpfXJldHVybiBsbCh0aGlzLG4tb24oKG9yKCksRGQpKSxrZSh0aGlzLmVGbGFncyYyPyghdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzKS5nZXRFQ2xhc3MoKTpEZCxuKSxyLHQpfSxsLmVJbnZlcnNlUmVtb3ZlXzA9ZnVuY3Rpb24obixyLHQpe3ZhciBvO3N3aXRjaChyKXtjYXNlIDA6cmV0dXJuIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxQYih0aGlzLm1peGVkLG4sdCk7Y2FzZSAxOnJldHVybiF0aGlzLnhNTE5TUHJlZml4TWFwJiYodGhpcy54TUxOU1ByZWZpeE1hcD1uZXcgWWkoKFBlKCksQnQpLEJvLHRoaXMsMSkpLG1MKHRoaXMueE1MTlNQcmVmaXhNYXAsbix0KTtjYXNlIDI6cmV0dXJuIXRoaXMueFNJU2NoZW1hTG9jYXRpb24mJih0aGlzLnhTSVNjaGVtYUxvY2F0aW9uPW5ldyBZaSgoUGUoKSxCdCksQm8sdGhpcywyKSksbUwodGhpcy54U0lTY2hlbWFMb2NhdGlvbixuLHQpO2Nhc2UgNTpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLHhWZShzaSh0aGlzLm1peGVkLChvcigpLGtTKSksbix0KX1yZXR1cm4gbz1hKGtlKHRoaXMuZUZsYWdzJjI/KCF0aGlzLmVQcm9wZXJ0aWVzJiYodGhpcy5lUHJvcGVydGllcz1uZXcgdnMpLHRoaXMuZVByb3BlcnRpZXMpLmdldEVDbGFzcygpOihvcigpLERkKSxyKSw2OSksby5nZXRTZXR0aW5nRGVsZWdhdGUoKS5keW5hbWljSW52ZXJzZVJlbW92ZSh0aGlzLFVlZSh0aGlzKSxyLW9uKChvcigpLERkKSksbix0KX0sbC5lSXNTZXQ9ZnVuY3Rpb24obil7c3dpdGNoKG4pe2Nhc2UgMDpyZXR1cm4hIXRoaXMubWl4ZWQmJnRoaXMubWl4ZWQuc2l6ZV8wIT0wO2Nhc2UgMTpyZXR1cm4hIXRoaXMueE1MTlNQcmVmaXhNYXAmJnRoaXMueE1MTlNQcmVmaXhNYXAuc2l6ZV8wIT0wO2Nhc2UgMjpyZXR1cm4hIXRoaXMueFNJU2NoZW1hTG9jYXRpb24mJnRoaXMueFNJU2NoZW1hTG9jYXRpb24uc2l6ZV8wIT0wO2Nhc2UgMzpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLCFLTChzaSh0aGlzLm1peGVkLChvcigpLFJiKSkpO2Nhc2UgNDpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLCFLTChzaSh0aGlzLm1peGVkLChvcigpLERiKSkpO2Nhc2UgNTpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLCFLTChzaSh0aGlzLm1peGVkLChvcigpLGtTKSkpO2Nhc2UgNjpyZXR1cm4hdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLCFLTChzaSh0aGlzLm1peGVkLChvcigpLE9TKSkpfXJldHVybiBzbCh0aGlzLG4tb24oKG9yKCksRGQpKSxrZSh0aGlzLmVGbGFncyYyPyghdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzKS5nZXRFQ2xhc3MoKTpEZCxuKSl9LGwuZVNldD1mdW5jdGlvbihuLHIpe3N3aXRjaChuKXtjYXNlIDA6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxMYih0aGlzLm1peGVkLHIpO3JldHVybjtjYXNlIDE6IXRoaXMueE1MTlNQcmVmaXhNYXAmJih0aGlzLnhNTE5TUHJlZml4TWFwPW5ldyBZaSgoUGUoKSxCdCksQm8sdGhpcywxKSkseUwodGhpcy54TUxOU1ByZWZpeE1hcCxyKTtyZXR1cm47Y2FzZSAyOiF0aGlzLnhTSVNjaGVtYUxvY2F0aW9uJiYodGhpcy54U0lTY2hlbWFMb2NhdGlvbj1uZXcgWWkoKFBlKCksQnQpLEJvLHRoaXMsMikpLHlMKHRoaXMueFNJU2NoZW1hTG9jYXRpb24scik7cmV0dXJuO2Nhc2UgMzohdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLE5tKHNpKHRoaXMubWl4ZWQsKG9yKCksUmIpKSksIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxOUyhzaSh0aGlzLm1peGVkLFJiKSxhKHIsMTYpKTtyZXR1cm47Y2FzZSA0OiF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksTm0oc2kodGhpcy5taXhlZCwob3IoKSxEYikpKSwhdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLE5TKHNpKHRoaXMubWl4ZWQsRGIpLGEociwxNikpO3JldHVybjtjYXNlIDU6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxObShzaSh0aGlzLm1peGVkLChvcigpLGtTKSkpLCF0aGlzLm1peGVkJiYodGhpcy5taXhlZD1uZXcgTnIodGhpcywwKSksTlMoc2kodGhpcy5taXhlZCxrUyksYShyLDE2KSk7cmV0dXJuO2Nhc2UgNjohdGhpcy5taXhlZCYmKHRoaXMubWl4ZWQ9bmV3IE5yKHRoaXMsMCkpLE5tKHNpKHRoaXMubWl4ZWQsKG9yKCksT1MpKSksIXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxOUyhzaSh0aGlzLm1peGVkLE9TKSxhKHIsMTYpKTtyZXR1cm59dWwodGhpcyxuLW9uKChvcigpLERkKSksa2UodGhpcy5lRmxhZ3MmMj8oIXRoaXMuZVByb3BlcnRpZXMmJih0aGlzLmVQcm9wZXJ0aWVzPW5ldyB2cyksdGhpcy5lUHJvcGVydGllcykuZ2V0RUNsYXNzKCk6RGQsbikscil9LGwuZVN0YXRpY0NsYXNzPWZ1bmN0aW9uKCl7cmV0dXJuIG9yKCksRGR9LGwuZVVuc2V0PWZ1bmN0aW9uKG4pe3N3aXRjaChuKXtjYXNlIDA6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxmbih0aGlzLm1peGVkKTtyZXR1cm47Y2FzZSAxOiF0aGlzLnhNTE5TUHJlZml4TWFwJiYodGhpcy54TUxOU1ByZWZpeE1hcD1uZXcgWWkoKFBlKCksQnQpLEJvLHRoaXMsMSkpLHRoaXMueE1MTlNQcmVmaXhNYXAuZGVsZWdhdGVFTGlzdC5jbGVhcl8wKCk7cmV0dXJuO2Nhc2UgMjohdGhpcy54U0lTY2hlbWFMb2NhdGlvbiYmKHRoaXMueFNJU2NoZW1hTG9jYXRpb249bmV3IFlpKChQZSgpLEJ0KSxCbyx0aGlzLDIpKSx0aGlzLnhTSVNjaGVtYUxvY2F0aW9uLmRlbGVnYXRlRUxpc3QuY2xlYXJfMCgpO3JldHVybjtjYXNlIDM6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxObShzaSh0aGlzLm1peGVkLChvcigpLFJiKSkpO3JldHVybjtjYXNlIDQ6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxObShzaSh0aGlzLm1peGVkLChvcigpLERiKSkpO3JldHVybjtjYXNlIDU6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxObShzaSh0aGlzLm1peGVkLChvcigpLGtTKSkpO3JldHVybjtjYXNlIDY6IXRoaXMubWl4ZWQmJih0aGlzLm1peGVkPW5ldyBOcih0aGlzLDApKSxObShzaSh0aGlzLm1peGVkLChvcigpLE9TKSkpO3JldHVybn1jbCh0aGlzLG4tb24oKG9yKCksRGQpKSxrZSh0aGlzLmVGbGFncyYyPyghdGhpcy5lUHJvcGVydGllcyYmKHRoaXMuZVByb3BlcnRpZXM9bmV3IHZzKSx0aGlzLmVQcm9wZXJ0aWVzKS5nZXRFQ2xhc3MoKTpEZCxuKSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3ZhciBuO3JldHVybiB0aGlzLmVGbGFncyY0P25zKHRoaXMpOihuPW5ldyB5bChucyh0aGlzKSksbi5zdHJpbmcrPSIgKG1peGVkOiAiLCQyKG4sdGhpcy5taXhlZCksbi5zdHJpbmcrPSIpIixuLnN0cmluZyl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZURvY3VtZW50Um9vdEltcGwiLDY4Myk7ZnVuY3Rpb24gS1ZlKCl7S1ZlPUYsJEEoKSxDb2U9aHIsdHFlPVZyLFRvZT1uZXcgQ0MoaHIpLG9xZT1uZXcgQ0MoVnIpfWZ1bmN0aW9uIE9ibihlKXtpZihlPWNpKGUsITApLFRlKCJ0cnVlIixlKXx8VGUoIjEiLGUpKXJldHVybiB6ZSgpLG95O2lmKFRlKCJmYWxzZSIsZSl8fFRlKCIwIixlKSlyZXR1cm4gemUoKSxTMDt0aHJvdyBiKG5ldyBMRigiSW52YWxpZCBib29sZWFuIHZhbHVlOiAnIitlKyInIikpfWZ1bmN0aW9uIE1ibihlKXtyZXR1cm4gZT09bnVsbD9udWxsOmVJbihlKX1mdW5jdGlvbiBSYm4oZSl7cmV0dXJuIGU9PWhyPyJJTkYiOmU9PVZyPyItSU5GIjoiIitlfWZ1bmN0aW9uIFhWZShlKXt2YXIgbixyLHQ7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZihyPWEoZSwxNSksci5pc0VtcHR5KCkpcmV0dXJuIiI7Zm9yKHQ9bmV3IExjLG49ci5pdGVyYXRvcl8wKCk7bi5oYXNOZXh0XzAoKTspSnQodCwob3IoKSx4bihuLm5leHRfMSgpKSkpLHQuc3RyaW5nKz0iICI7cmV0dXJuIEE1KHQsdC5zdHJpbmcubGVuZ3RoLTEpfWZ1bmN0aW9uIERibihlKXtyZXR1cm4gZT09aHI/IklORiI6ZT09VnI/Ii1JTkYiOiIiK2V9ZnVuY3Rpb24gRmJuKGUpe3JldHVybiBlPT1udWxsP251bGw6dEluKGUpfWZ1bmN0aW9uIEpWZShlKXt2YXIgbixyLHQ7aWYoIWUpcmV0dXJuIG51bGw7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIiI7Zm9yKHQ9bmV3IExjLHI9ZS5pdGVyYXRvcl8wKCk7ci5oYXNOZXh0XzAoKTspbj1yLm5leHRfMSgpLEp0KHQseG4obikpLHQuc3RyaW5nKz0iICI7cmV0dXJuIEE1KHQsdC5zdHJpbmcubGVuZ3RoLTEpfWZ1bmN0aW9uIFpWZShlKXt2YXIgbixyLHQ7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZihyPWEoZSwxNSksci5pc0VtcHR5KCkpcmV0dXJuIiI7Zm9yKHQ9bmV3IExjLG49ci5pdGVyYXRvcl8wKCk7bi5oYXNOZXh0XzAoKTspSnQodCwob3IoKSx4bihuLm5leHRfMSgpKSkpLHQuc3RyaW5nKz0iICI7cmV0dXJuIEE1KHQsdC5zdHJpbmcubGVuZ3RoLTEpfWZ1bmN0aW9uIHpibihlKXtyZXR1cm4gZT09bnVsbD9udWxsOnZvKGUpfWZ1bmN0aW9uICRibihlKXtyZXR1cm4gZT09bnVsbD9udWxsOnZvKGUpfWZ1bmN0aW9uIEJibihlKXt2YXIgbjtpZihlPT1udWxsKXJldHVybiBudWxsO2lmKG49UWJuKGNpKGUsITApKSxuPT1udWxsKXRocm93IGIobmV3IExGKCJJbnZhbGlkIGJhc2U2NEJpbmFyeSB2YWx1ZTogJyIrZSsiJyIpKTtyZXR1cm4gbn1mdW5jdGlvbiBHYm4oZSl7dmFyIG4scix0LG87aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZih0PWNpKGUsITApLG89MyxUZSh0LnN1YnN0cih0Lmxlbmd0aC1vLG8pLCJJTkYiKSl7aWYocj10Lmxlbmd0aCxyPT00KXtpZihuPShIZSgwLHQubGVuZ3RoKSx0LmNoYXJDb2RlQXQoMCkpLG49PTQzKXJldHVybiBDb2U7aWYobj09NDUpcmV0dXJuIHRxZX1lbHNlIGlmKHI9PTMpcmV0dXJuIENvZX1yZXR1cm4gUWQodCl9ZnVuY3Rpb24gUVZlKGUpe3ZhciBuLHIsdCxvLGk7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtmb3IoaT1uZXcgUSxyPVpSKGUpLHQ9MCxvPXIubGVuZ3RoO3Q8bzsrK3Qpbj1yW3RdLGVlKGksY2kobiwhMCkpO3JldHVybiBpfWZ1bmN0aW9uIEhibihlKXt2YXIgbixyLHQsbztpZihlPT1udWxsKXJldHVybiBudWxsO2lmKHQ9Y2koZSwhMCksbz0zLFRlKHQuc3Vic3RyKHQubGVuZ3RoLW8sbyksIklORiIpKXtpZihyPXQubGVuZ3RoLHI9PTQpe2lmKG49KEhlKDAsdC5sZW5ndGgpLHQuY2hhckNvZGVBdCgwKSksbj09NDMpcmV0dXJuIFRvZTtpZihuPT00NSlyZXR1cm4gb3FlfWVsc2UgaWYocj09MylyZXR1cm4gVG9lfXJldHVybiBuZXcgcSQodCl9ZnVuY3Rpb24gVWJuKGUpe3ZhciBuO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYobj1ySW4oY2koZSwhMCkpLG49PW51bGwpdGhyb3cgYihuZXcgTEYoIkludmFsaWQgaGV4QmluYXJ5IHZhbHVlOiAnIitlKyInIikpO3JldHVybiBufWZ1bmN0aW9uIGVxZShlKXt2YXIgbixyLHQsbyxpO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7Zm9yKGk9bmV3IFEscj1aUihlKSx0PTAsbz1yLmxlbmd0aDt0PG87Kyt0KW49clt0XSxlZShpLGNpKG4sITApKTtyZXR1cm4gaX1mdW5jdGlvbiBucWUoZSl7dmFyIG4scix0LG8saTtpZihlPT1udWxsKXJldHVybiBudWxsO2ZvcihpPW5ldyBRLHI9WlIoZSksdD0wLG89ci5sZW5ndGg7dDxvOysrdCluPXJbdF0sZWUoaSxjaShuLCEwKSk7cmV0dXJuIGl9ZnVuY3Rpb24gV2JuKGUpe3ZhciBuO3JldHVybiBlPT1udWxsP251bGw6bmV3IFQwKChuPWNpKGUsITApLG4ubGVuZ3RoPjAmJihIZSgwLG4ubGVuZ3RoKSxuLmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSxuLmxlbmd0aCsxKSxuLnN1YnN0cigxKSk6bikpfWZ1bmN0aW9uIGpibihlKXt2YXIgbjtyZXR1cm4gZT09bnVsbD9udWxsOm5ldyBUMCgobj1jaShlLCEwKSxuLmxlbmd0aD4wJiYoSGUoMCxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsbi5sZW5ndGgrMSksbi5zdWJzdHIoMSkpOm4pKX1mdW5jdGlvbiBycWUoKXt9ZnVuY3Rpb24gVmJuKCl7S1ZlKCk7dmFyIGUsbjt0cnl7aWYobj1hKGR0ZSgobl8oKSxQbCksImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDMvWE1MVHlwZSIpLDIxMjIpLG4pcmV0dXJuIG59Y2F0Y2gocil7aWYocj13cihyKSxMKHIsMTAzKSllPXIsbHJlKChibigpLGUpKTtlbHNlIHRocm93IGIocil9cmV0dXJuIG5ldyBycWV9cCgyMDI4LDcyMCx7MTEwOjEsOTQ6MSw5MzoxLDQ4MDoxLDE1NToxLDU4OjEsMTE0OjEsNTQ6MSw5OToxLDE1ODoxLDExOToxLDEyMDoxLDIxMjI6MX0scnFlKSxsLmNvbnZlcnRUb1N0cmluZz1mdW5jdGlvbihuLHIpe3N3aXRjaChuLmdldENsYXNzaWZpZXJJRCgpKXtjYXNlIDc6Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOmNhc2UgMTY6Y2FzZSAyMjpjYXNlIDIzOmNhc2UgMjQ6Y2FzZSAyNTpjYXNlIDI2OmNhc2UgMzI6Y2FzZSAzMzpjYXNlIDM0OmNhc2UgMzY6Y2FzZSAzNzpjYXNlIDQ0OmNhc2UgNDU6Y2FzZSA1MDpjYXNlIDUxOmNhc2UgNTM6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6Y2FzZSA1ODpjYXNlIDYwOmNhc2UgNjE6Y2FzZSA0OnJldHVybiByPT1udWxsP251bGw6dm8ocik7Y2FzZSAxOTpjYXNlIDI4OmNhc2UgMjk6Y2FzZSAzNTpjYXNlIDM4OmNhc2UgMzk6Y2FzZSA0MTpjYXNlIDQ2OmNhc2UgNTI6Y2FzZSA1NDpjYXNlIDU6cmV0dXJuIHhuKHIpO2Nhc2UgNjpyZXR1cm4gTWJuKGEociwxOTUpKTtjYXNlIDEyOmNhc2UgNDc6Y2FzZSA0OTpjYXNlIDExOnJldHVybiBFJGUodGhpcyxuLHIpO2Nhc2UgMTM6cmV0dXJuIHI9PW51bGw/bnVsbDpTWmUoYShyLDI0NykpO2Nhc2UgMTU6Y2FzZSAxNDpyZXR1cm4gcj09bnVsbD9udWxsOlJibihSKCQocikpKTtjYXNlIDE3OnJldHVybiBYVmUoKG9yKCkscikpO2Nhc2UgMTg6cmV0dXJuIFhWZShyKTtjYXNlIDIxOmNhc2UgMjA6cmV0dXJuIHI9PW51bGw/bnVsbDpEYm4oYShyLDE2MSkudmFsdWVfMCk7Y2FzZSAyNzpyZXR1cm4gRmJuKGEociwxOTUpKTtjYXNlIDMwOnJldHVybiBKVmUoKG9yKCksYShyLDE1KSkpO2Nhc2UgMzE6cmV0dXJuIEpWZShhKHIsMTUpKTtjYXNlIDQwOnJldHVybiAkYm4oKG9yKCkscikpO2Nhc2UgNDI6cmV0dXJuIFpWZSgob3IoKSxyKSk7Y2FzZSA0MzpyZXR1cm4gWlZlKHIpO2Nhc2UgNTk6Y2FzZSA0ODpyZXR1cm4gemJuKChvcigpLHIpKTtkZWZhdWx0OnRocm93IGIobmV3IEdlKCJUaGUgZGF0YXR5cGUgJyIrbi5nZXROYW1lKCkrIicgaXMgbm90IGEgdmFsaWQgY2xhc3NpZmllciIpKX19LGwuY3JlYXRlXzM9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscztzd2l0Y2gobi5tZXRhT2JqZWN0SUQ9PS0xJiYobi5tZXRhT2JqZWN0SUQ9KHQ9SGEobiksdD9zMCh0LmdldEVDbGFzc2lmaWVycygpLG4pOi0xKSksbi5tZXRhT2JqZWN0SUQpe2Nhc2UgMDpyZXR1cm4gcj1uZXcgdm9lLHI7Y2FzZSAxOnJldHVybiBvPW5ldyBWVmUsbztjYXNlIDI6cmV0dXJuIGk9bmV3IHFWZSxpO2Nhc2UgMzpyZXR1cm4gcz1uZXcgWVZlLHM7ZGVmYXVsdDp0aHJvdyBiKG5ldyBHZSgiVGhlIGNsYXNzICciK24ubmFtZV8wKyInIGlzIG5vdCBhIHZhbGlkIGNsYXNzaWZpZXIiKSl9fSxsLmNyZWF0ZUZyb21TdHJpbmc9ZnVuY3Rpb24obixyKXt2YXIgdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2LHgsQTtzd2l0Y2gobi5nZXRDbGFzc2lmaWVySUQoKSl7Y2FzZSA1OmNhc2UgNTI6Y2FzZSA0OnJldHVybiByO2Nhc2UgNjpyZXR1cm4gQmJuKHIpO2Nhc2UgODpjYXNlIDc6cmV0dXJuIHI9PW51bGw/bnVsbDpPYm4ocik7Y2FzZSA5OnJldHVybiByPT1udWxsP251bGw6RUMoQWEoKG89Y2kociwhMCksby5sZW5ndGg+MCYmKEhlKDAsby5sZW5ndGgpLG8uY2hhckNvZGVBdCgwKT09NDMpPyhIZSgxLG8ubGVuZ3RoKzEpLG8uc3Vic3RyKDEpKTpvKSwtMTI4LDEyNyk8PDI0Pj4yNCk7Y2FzZSAxMDpyZXR1cm4gcj09bnVsbD9udWxsOkVDKEFhKChpPWNpKHIsITApLGkubGVuZ3RoPjAmJihIZSgwLGkubGVuZ3RoKSxpLmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSxpLmxlbmd0aCsxKSxpLnN1YnN0cigxKSk6aSksLTEyOCwxMjcpPDwyND4+MjQpO2Nhc2UgMTE6cmV0dXJuIHhuKElkKHRoaXMsKG9yKCksTVZlKSxyKSk7Y2FzZSAxMjpyZXR1cm4geG4oSWQodGhpcywob3IoKSxSVmUpLHIpKTtjYXNlIDEzOnJldHVybiByPT1udWxsP251bGw6bmV3IGdCKGNpKHIsITApKTtjYXNlIDE1OmNhc2UgMTQ6cmV0dXJuIEdibihyKTtjYXNlIDE2OnJldHVybiB4bihJZCh0aGlzLChvcigpLERWZSkscikpO2Nhc2UgMTc6cmV0dXJuIFFWZSgob3IoKSxyKSk7Y2FzZSAxODpyZXR1cm4gUVZlKHIpO2Nhc2UgMjg6Y2FzZSAyOTpjYXNlIDM1OmNhc2UgMzg6Y2FzZSAzOTpjYXNlIDQxOmNhc2UgNTQ6Y2FzZSAxOTpyZXR1cm4gY2kociwhMCk7Y2FzZSAyMTpjYXNlIDIwOnJldHVybiBIYm4ocik7Y2FzZSAyMjpyZXR1cm4geG4oSWQodGhpcywob3IoKSxGVmUpLHIpKTtjYXNlIDIzOnJldHVybiB4bihJZCh0aGlzLChvcigpLHpWZSkscikpO2Nhc2UgMjQ6cmV0dXJuIHhuKElkKHRoaXMsKG9yKCksJFZlKSxyKSk7Y2FzZSAyNTpyZXR1cm4geG4oSWQodGhpcywob3IoKSxCVmUpLHIpKTtjYXNlIDI2OnJldHVybiB4bihJZCh0aGlzLChvcigpLEdWZSkscikpO2Nhc2UgMjc6cmV0dXJuIFVibihyKTtjYXNlIDMwOnJldHVybiBlcWUoKG9yKCkscikpO2Nhc2UgMzE6cmV0dXJuIGVxZShyKTtjYXNlIDMyOnJldHVybiByPT1udWxsP251bGw6SihBYSgoZj1jaShyLCEwKSxmLmxlbmd0aD4wJiYoSGUoMCxmLmxlbmd0aCksZi5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsZi5sZW5ndGgrMSksZi5zdWJzdHIoMSkpOmYpLGJ0LHFuKSk7Y2FzZSAzMzpyZXR1cm4gcj09bnVsbD9udWxsOm5ldyBUMCgoaD1jaShyLCEwKSxoLmxlbmd0aD4wJiYoSGUoMCxoLmxlbmd0aCksaC5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsaC5sZW5ndGgrMSksaC5zdWJzdHIoMSkpOmgpKTtjYXNlIDM0OnJldHVybiByPT1udWxsP251bGw6SihBYSgobT1jaShyLCEwKSxtLmxlbmd0aD4wJiYoSGUoMCxtLmxlbmd0aCksbS5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsbS5sZW5ndGgrMSksbS5zdWJzdHIoMSkpOm0pLGJ0LHFuKSk7Y2FzZSAzNjpyZXR1cm4gcj09bnVsbD9udWxsOmVjKEhJKCh5PWNpKHIsITApLHkubGVuZ3RoPjAmJihIZSgwLHkubGVuZ3RoKSx5LmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSx5Lmxlbmd0aCsxKSx5LnN1YnN0cigxKSk6eSkpKTtjYXNlIDM3OnJldHVybiByPT1udWxsP251bGw6ZWMoSEkoKEU9Y2kociwhMCksRS5sZW5ndGg+MCYmKEhlKDAsRS5sZW5ndGgpLEUuY2hhckNvZGVBdCgwKT09NDMpPyhIZSgxLEUubGVuZ3RoKzEpLEUuc3Vic3RyKDEpKTpFKSkpO2Nhc2UgNDA6cmV0dXJuIGpibigob3IoKSxyKSk7Y2FzZSA0MjpyZXR1cm4gbnFlKChvcigpLHIpKTtjYXNlIDQzOnJldHVybiBucWUocik7Y2FzZSA0NDpyZXR1cm4gcj09bnVsbD9udWxsOm5ldyBUMCgodj1jaShyLCEwKSx2Lmxlbmd0aD4wJiYoSGUoMCx2Lmxlbmd0aCksdi5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsdi5sZW5ndGgrMSksdi5zdWJzdHIoMSkpOnYpKTtjYXNlIDQ1OnJldHVybiByPT1udWxsP251bGw6bmV3IFQwKCh4PWNpKHIsITApLHgubGVuZ3RoPjAmJihIZSgwLHgubGVuZ3RoKSx4LmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSx4Lmxlbmd0aCsxKSx4LnN1YnN0cigxKSk6eCkpO2Nhc2UgNDY6cmV0dXJuIGNpKHIsITEpO2Nhc2UgNDc6cmV0dXJuIHhuKElkKHRoaXMsKG9yKCksSFZlKSxyKSk7Y2FzZSA1OTpjYXNlIDQ4OnJldHVybiBXYm4oKG9yKCkscikpO2Nhc2UgNDk6cmV0dXJuIHhuKElkKHRoaXMsKG9yKCksVVZlKSxyKSk7Y2FzZSA1MDpyZXR1cm4gcj09bnVsbD9udWxsOmx5KEFhKChBPWNpKHIsITApLEEubGVuZ3RoPjAmJihIZSgwLEEubGVuZ3RoKSxBLmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSxBLmxlbmd0aCsxKSxBLnN1YnN0cigxKSk6QSksSmIsMzI3NjcpPDwxNj4+MTYpO2Nhc2UgNTE6cmV0dXJuIHI9PW51bGw/bnVsbDpseShBYSgocz1jaShyLCEwKSxzLmxlbmd0aD4wJiYoSGUoMCxzLmxlbmd0aCkscy5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEscy5sZW5ndGgrMSkscy5zdWJzdHIoMSkpOnMpLEpiLDMyNzY3KTw8MTY+PjE2KTtjYXNlIDUzOnJldHVybiB4bihJZCh0aGlzLChvcigpLFdWZSkscikpO2Nhc2UgNTU6cmV0dXJuIHI9PW51bGw/bnVsbDpseShBYSgodT1jaShyLCEwKSx1Lmxlbmd0aD4wJiYoSGUoMCx1Lmxlbmd0aCksdS5jaGFyQ29kZUF0KDApPT00Myk/KEhlKDEsdS5sZW5ndGgrMSksdS5zdWJzdHIoMSkpOnUpLEpiLDMyNzY3KTw8MTY+PjE2KTtjYXNlIDU2OnJldHVybiByPT1udWxsP251bGw6bHkoQWEoKGM9Y2kociwhMCksYy5sZW5ndGg+MCYmKEhlKDAsYy5sZW5ndGgpLGMuY2hhckNvZGVBdCgwKT09NDMpPyhIZSgxLGMubGVuZ3RoKzEpLGMuc3Vic3RyKDEpKTpjKSxKYiwzMjc2Nyk8PDE2Pj4xNik7Y2FzZSA1NzpyZXR1cm4gcj09bnVsbD9udWxsOmVjKEhJKChfPWNpKHIsITApLF8ubGVuZ3RoPjAmJihIZSgwLF8ubGVuZ3RoKSxfLmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSxfLmxlbmd0aCsxKSxfLnN1YnN0cigxKSk6XykpKTtjYXNlIDU4OnJldHVybiByPT1udWxsP251bGw6ZWMoSEkoKGQ9Y2kociwhMCksZC5sZW5ndGg+MCYmKEhlKDAsZC5sZW5ndGgpLGQuY2hhckNvZGVBdCgwKT09NDMpPyhIZSgxLGQubGVuZ3RoKzEpLGQuc3Vic3RyKDEpKTpkKSkpO2Nhc2UgNjA6cmV0dXJuIHI9PW51bGw/bnVsbDpKKEFhKCh0PWNpKHIsITApLHQubGVuZ3RoPjAmJihIZSgwLHQubGVuZ3RoKSx0LmNoYXJDb2RlQXQoMCk9PTQzKT8oSGUoMSx0Lmxlbmd0aCsxKSx0LnN1YnN0cigxKSk6dCksYnQscW4pKTtjYXNlIDYxOnJldHVybiByPT1udWxsP251bGw6SihBYShjaShyLCEwKSxidCxxbikpO2RlZmF1bHQ6dGhyb3cgYihuZXcgR2UoIlRoZSBkYXRhdHlwZSAnIituLmdldE5hbWUoKSsiJyBpcyBub3QgYSB2YWxpZCBjbGFzc2lmaWVyIikpfX07dmFyIHRxZSxDb2Usb3FlLFRvZTtnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVGYWN0b3J5SW1wbCIsMjAyOCk7ZnVuY3Rpb24gcWJuKGUpe2UuYW55VHlwZUVDbGFzcz1udWxsLGUucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzPW51bGwsZS5zaW1wbGVBbnlUeXBlRUNsYXNzPW51bGwsZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzPW51bGwsZS5hbnlTaW1wbGVUeXBlRURhdGFUeXBlPW51bGwsZS5hbnlVUklFRGF0YVR5cGU9bnVsbCxlLmJhc2U2NEJpbmFyeUVEYXRhVHlwZT1udWxsLGUuYm9vbGVhbkVEYXRhVHlwZT1udWxsLGUuYm9vbGVhbk9iamVjdEVEYXRhVHlwZT1udWxsLGUuZGVjaW1hbEVEYXRhVHlwZT1udWxsLGUuaW50ZWdlckVEYXRhVHlwZT1udWxsLGUuaW50T2JqZWN0RURhdGFUeXBlPW51bGwsZS5sb25nRURhdGFUeXBlPW51bGwsZS5sb25nT2JqZWN0RURhdGFUeXBlPW51bGwsZS5pbnRFRGF0YVR5cGU9bnVsbCxlLnNob3J0RURhdGFUeXBlPW51bGwsZS5zaG9ydE9iamVjdEVEYXRhVHlwZT1udWxsLGUuYnl0ZUVEYXRhVHlwZT1udWxsLGUuYnl0ZU9iamVjdEVEYXRhVHlwZT1udWxsLGUuZGF0ZUVEYXRhVHlwZT1udWxsLGUuZGF0ZVRpbWVFRGF0YVR5cGU9bnVsbCxlLnN0cmluZ0VEYXRhVHlwZT1udWxsLGUuZG91YmxlRURhdGFUeXBlPW51bGwsZS5kb3VibGVPYmplY3RFRGF0YVR5cGU9bnVsbCxlLmR1cmF0aW9uRURhdGFUeXBlPW51bGwsZS5lbnRpdGllc0Jhc2VFRGF0YVR5cGU9bnVsbCxlLm5vcm1hbGl6ZWRTdHJpbmdFRGF0YVR5cGU9bnVsbCxlLnRva2VuRURhdGFUeXBlPW51bGwsZS5uYW1lRURhdGFUeXBlPW51bGwsZS5uY05hbWVFRGF0YVR5cGU9bnVsbCxlLmVudGl0eUVEYXRhVHlwZT1udWxsLGUuZW50aXRpZXNFRGF0YVR5cGU9bnVsbCxlLmZsb2F0RURhdGFUeXBlPW51bGwsZS5mbG9hdE9iamVjdEVEYXRhVHlwZT1udWxsLGUuZ0RheUVEYXRhVHlwZT1udWxsLGUuZ01vbnRoRURhdGFUeXBlPW51bGwsZS5nTW9udGhEYXlFRGF0YVR5cGU9bnVsbCxlLmdZZWFyRURhdGFUeXBlPW51bGwsZS5nWWVhck1vbnRoRURhdGFUeXBlPW51bGwsZS5oZXhCaW5hcnlFRGF0YVR5cGU9bnVsbCxlLmlkRURhdGFUeXBlPW51bGwsZS5pZHJlZkVEYXRhVHlwZT1udWxsLGUuaWRyZWZzQmFzZUVEYXRhVHlwZT1udWxsLGUuaWRyZWZzRURhdGFUeXBlPW51bGwsZS5sYW5ndWFnZUVEYXRhVHlwZT1udWxsLGUubm9uUG9zaXRpdmVJbnRlZ2VyRURhdGFUeXBlPW51bGwsZS5uZWdhdGl2ZUludGVnZXJFRGF0YVR5cGU9bnVsbCxlLm5tdG9rZW5FRGF0YVR5cGU9bnVsbCxlLm5tdG9rZW5zQmFzZUVEYXRhVHlwZT1udWxsLGUubm10b2tlbnNFRGF0YVR5cGU9bnVsbCxlLm5vbk5lZ2F0aXZlSW50ZWdlckVEYXRhVHlwZT1udWxsLGUubm90YXRpb25FRGF0YVR5cGU9bnVsbCxlLnBvc2l0aXZlSW50ZWdlckVEYXRhVHlwZT1udWxsLGUucU5hbWVFRGF0YVR5cGU9bnVsbCxlLnRpbWVFRGF0YVR5cGU9bnVsbCxlLnVuc2lnbmVkTG9uZ0VEYXRhVHlwZT1udWxsLGUudW5zaWduZWRJbnRFRGF0YVR5cGU9bnVsbCxlLnVuc2lnbmVkSW50T2JqZWN0RURhdGFUeXBlPW51bGwsZS51bnNpZ25lZFNob3J0RURhdGFUeXBlPW51bGwsZS51bnNpZ25lZFNob3J0T2JqZWN0RURhdGFUeXBlPW51bGwsZS51bnNpZ25lZEJ5dGVFRGF0YVR5cGU9bnVsbCxlLnVuc2lnbmVkQnl0ZU9iamVjdEVEYXRhVHlwZT1udWxsLGUuaXNDcmVhdGVkPSExLGUuaXNJbml0aWFsaXplZD0hMX1mdW5jdGlvbiBZYm4oZSl7RW4oZS5hbnlTaW1wbGVUeXBlRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJhbnlTaW1wbGVUeXBlIl0pKSxFbihlLmFueVR5cGVFQ2xhc3MsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImFueVR5cGUiLCJraW5kIiwibWl4ZWQiXSkpLEVuKGEoTyhHKGUuYW55VHlwZUVDbGFzcyksMCksMzUpLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImtpbmQiLCJlbGVtZW50V2lsZGNhcmQiLCJuYW1lIiwiOm1peGVkIl0pKSxFbihhKE8oRyhlLmFueVR5cGVFQ2xhc3MpLDEpLDM1KSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJraW5kIiwiZWxlbWVudFdpbGRjYXJkIiwid2lsZGNhcmRzIiwiIyNhbnkiLCJuYW1lIiwiOjEiLCJwcm9jZXNzaW5nIiwibGF4Il0pKSxFbihhKE8oRyhlLmFueVR5cGVFQ2xhc3MpLDIpLDM1KSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJraW5kIiwiYXR0cmlidXRlV2lsZGNhcmQiLCJ3aWxkY2FyZHMiLCIjI2FueSIsIm5hbWUiLCI6MiIsInByb2Nlc3NpbmciLCJsYXgiXSkpLEVuKGUuYW55VVJJRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJhbnlVUkkiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuYmFzZTY0QmluYXJ5RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJiYXNlNjRCaW5hcnkiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuYm9vbGVhbkVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwiYm9vbGVhbiIsIndoaXRlU3BhY2UiLCJjb2xsYXBzZSJdKSksRW4oZS5ib29sZWFuT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJib29sZWFuOk9iamVjdCIsImJhc2VUeXBlIiwiYm9vbGVhbiJdKSksRW4oZS5ieXRlRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJieXRlIl0pKSxFbihlLmJ5dGVPYmplY3RFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImJ5dGU6T2JqZWN0IiwiYmFzZVR5cGUiLCJieXRlIl0pKSxFbihlLmRhdGVFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImRhdGUiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZGF0ZVRpbWVFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImRhdGVUaW1lIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLmRlY2ltYWxFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImRlY2ltYWwiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZG91YmxlRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJkb3VibGUiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZG91YmxlT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJkb3VibGU6T2JqZWN0IiwiYmFzZVR5cGUiLCJkb3VibGUiXSkpLEVuKGUuZHVyYXRpb25FRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImR1cmF0aW9uIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLmVudGl0aWVzRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJFTlRJVElFUyIsImJhc2VUeXBlIiwiRU5USVRJRVNfLl9iYXNlIiwibWluTGVuZ3RoIiwiMSJdKSksRW4oZS5lbnRpdGllc0Jhc2VFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIkVOVElUSUVTXy5fYmFzZSIsIml0ZW1UeXBlIiwiRU5USVRZIl0pKSxFbihlLmVudGl0eUVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwiRU5USVRZIiwiYmFzZVR5cGUiLCJOQ05hbWUiXSkpLEVuKGUuZmxvYXRFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImZsb2F0Iiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLmZsb2F0T2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJmbG9hdDpPYmplY3QiLCJiYXNlVHlwZSIsImZsb2F0Il0pKSxFbihlLmdEYXlFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImdEYXkiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZ01vbnRoRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJnTW9udGgiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZ01vbnRoRGF5RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJnTW9udGhEYXkiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuZ1llYXJFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImdZZWFyIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLmdZZWFyTW9udGhFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImdZZWFyTW9udGgiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuaGV4QmluYXJ5RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJoZXhCaW5hcnkiLCJ3aGl0ZVNwYWNlIiwiY29sbGFwc2UiXSkpLEVuKGUuaWRFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIklEIiwiYmFzZVR5cGUiLCJOQ05hbWUiXSkpLEVuKGUuaWRyZWZFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIklEUkVGIiwiYmFzZVR5cGUiLCJOQ05hbWUiXSkpLEVuKGUuaWRyZWZzRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJJRFJFRlMiLCJiYXNlVHlwZSIsIklEUkVGU18uX2Jhc2UiLCJtaW5MZW5ndGgiLCIxIl0pKSxFbihlLmlkcmVmc0Jhc2VFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIklEUkVGU18uX2Jhc2UiLCJpdGVtVHlwZSIsIklEUkVGIl0pKSxFbihlLmludEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwiaW50Il0pKSxFbihlLmludGVnZXJFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImludGVnZXIiXSkpLEVuKGUuaW50T2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJpbnQ6T2JqZWN0IiwiYmFzZVR5cGUiLCJpbnQiXSkpLEVuKGUubGFuZ3VhZ2VFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsImxhbmd1YWdlIiwiYmFzZVR5cGUiLCJ0b2tlbiIsInBhdHRlcm4iLCJbYS16QS1aXXsxLDh9KC1bYS16QS1aMC05XXsxLDh9KSoiXSkpLEVuKGUubG9uZ0VEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwibG9uZyJdKSksRW4oZS5sb25nT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJsb25nOk9iamVjdCIsImJhc2VUeXBlIiwibG9uZyJdKSksRW4oZS5uYW1lRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJOYW1lIiwiYmFzZVR5cGUiLCJ0b2tlbiIsInBhdHRlcm4iLCJcXGlcXGMqIl0pKSxFbihlLm5jTmFtZUVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwiTkNOYW1lIiwiYmFzZVR5cGUiLCJOYW1lIiwicGF0dGVybiIsIltcXGktWzpdXVtcXGMtWzpdXSoiXSkpLEVuKGUubmVnYXRpdmVJbnRlZ2VyRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJuZWdhdGl2ZUludGVnZXIiLCJiYXNlVHlwZSIsIm5vblBvc2l0aXZlSW50ZWdlciIsIm1heEluY2x1c2l2ZSIsIi0xIl0pKSxFbihlLm5tdG9rZW5FRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIk5NVE9LRU4iLCJiYXNlVHlwZSIsInRva2VuIiwicGF0dGVybiIsIlxcYysiXSkpLEVuKGUubm10b2tlbnNFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIk5NVE9LRU5TIiwiYmFzZVR5cGUiLCJOTVRPS0VOU18uX2Jhc2UiLCJtaW5MZW5ndGgiLCIxIl0pKSxFbihlLm5tdG9rZW5zQmFzZUVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwiTk1UT0tFTlNfLl9iYXNlIiwiaXRlbVR5cGUiLCJOTVRPS0VOIl0pKSxFbihlLm5vbk5lZ2F0aXZlSW50ZWdlckVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwibm9uTmVnYXRpdmVJbnRlZ2VyIiwiYmFzZVR5cGUiLCJpbnRlZ2VyIiwibWluSW5jbHVzaXZlIiwiMCJdKSksRW4oZS5ub25Qb3NpdGl2ZUludGVnZXJFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIm5vblBvc2l0aXZlSW50ZWdlciIsImJhc2VUeXBlIiwiaW50ZWdlciIsIm1heEluY2x1c2l2ZSIsIjAiXSkpLEVuKGUubm9ybWFsaXplZFN0cmluZ0VEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwibm9ybWFsaXplZFN0cmluZyIsImJhc2VUeXBlIiwic3RyaW5nIiwid2hpdGVTcGFjZSIsInJlcGxhY2UiXSkpLEVuKGUubm90YXRpb25FRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIk5PVEFUSU9OIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLnBvc2l0aXZlSW50ZWdlckVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwicG9zaXRpdmVJbnRlZ2VyIiwiYmFzZVR5cGUiLCJub25OZWdhdGl2ZUludGVnZXIiLCJtaW5JbmNsdXNpdmUiLCIxIl0pKSxFbihlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcywiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwicHJvY2Vzc2luZ0luc3RydWN0aW9uXy5fdHlwZSIsImtpbmQiLCJlbXB0eSJdKSksRW4oYShPKEcoZS5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb25FQ2xhc3MpLDApLDM1KSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJraW5kIiwiYXR0cmlidXRlIiwibmFtZSIsImRhdGEiXSkpLEVuKGEoTyhHKGUucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzKSwxKSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsia2luZCIsImF0dHJpYnV0ZSIsIm5hbWUiLCJ0YXJnZXQiXSkpLEVuKGUucU5hbWVFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIlFOYW1lIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLnNob3J0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJzaG9ydCJdKSksRW4oZS5zaG9ydE9iamVjdEVEYXRhVHlwZSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJuYW1lIiwic2hvcnQ6T2JqZWN0IiwiYmFzZVR5cGUiLCJzaG9ydCJdKSksRW4oZS5zaW1wbGVBbnlUeXBlRUNsYXNzLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJzaW1wbGVBbnlUeXBlIiwia2luZCIsInNpbXBsZSJdKSksRW4oYShPKEcoZS5zaW1wbGVBbnlUeXBlRUNsYXNzKSwwKSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIjozIiwia2luZCIsInNpbXBsZSJdKSksRW4oYShPKEcoZS5zaW1wbGVBbnlUeXBlRUNsYXNzKSwxKSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIjo0Iiwia2luZCIsInNpbXBsZSJdKSksRW4oYShPKEcoZS5zaW1wbGVBbnlUeXBlRUNsYXNzKSwyKSwxOSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIjo1Iiwia2luZCIsInNpbXBsZSJdKSksRW4oZS5zdHJpbmdFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsInN0cmluZyIsIndoaXRlU3BhY2UiLCJwcmVzZXJ2ZSJdKSksRW4oZS50aW1lRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJ0aW1lIiwid2hpdGVTcGFjZSIsImNvbGxhcHNlIl0pKSxFbihlLnRva2VuRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJ0b2tlbiIsImJhc2VUeXBlIiwibm9ybWFsaXplZFN0cmluZyIsIndoaXRlU3BhY2UiLCJjb2xsYXBzZSJdKSksRW4oZS51bnNpZ25lZEJ5dGVFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsInVuc2lnbmVkQnl0ZSIsIm1heEluY2x1c2l2ZSIsIjI1NSIsIm1pbkluY2x1c2l2ZSIsIjAiXSkpLEVuKGUudW5zaWduZWRCeXRlT2JqZWN0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJ1bnNpZ25lZEJ5dGU6T2JqZWN0IiwiYmFzZVR5cGUiLCJ1bnNpZ25lZEJ5dGUiXSkpLEVuKGUudW5zaWduZWRJbnRFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsInVuc2lnbmVkSW50IiwibWF4SW5jbHVzaXZlIiwiNDI5NDk2NzI5NSIsIm1pbkluY2x1c2l2ZSIsIjAiXSkpLEVuKGUudW5zaWduZWRJbnRPYmplY3RFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsInVuc2lnbmVkSW50Ok9iamVjdCIsImJhc2VUeXBlIiwidW5zaWduZWRJbnQiXSkpLEVuKGUudW5zaWduZWRMb25nRURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJ1bnNpZ25lZExvbmciLCJiYXNlVHlwZSIsIm5vbk5lZ2F0aXZlSW50ZWdlciIsIm1heEluY2x1c2l2ZSIsIjE4NDQ2NzQ0MDczNzA5NTUxNjE1IiwibWluSW5jbHVzaXZlIiwiMCJdKSksRW4oZS51bnNpZ25lZFNob3J0RURhdGFUeXBlLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbIm5hbWUiLCJ1bnNpZ25lZFNob3J0IiwibWF4SW5jbHVzaXZlIiwiNjU1MzUiLCJtaW5JbmNsdXNpdmUiLCIwIl0pKSxFbihlLnVuc2lnbmVkU2hvcnRPYmplY3RFRGF0YVR5cGUsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsInVuc2lnbmVkU2hvcnQ6T2JqZWN0IiwiYmFzZVR5cGUiLCJ1bnNpZ25lZFNob3J0Il0pKSxFbihlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MsImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsibmFtZSIsIiIsImtpbmQiLCJtaXhlZCJdKSksRW4oYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwwKSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsia2luZCIsImVsZW1lbnRXaWxkY2FyZCIsIm5hbWUiLCI6bWl4ZWQiXSkpLEVuKGEoTyhHKGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksMSksMTkpLCJodHRwOi8vL29yZy9lY2xpcHNlL2VtZi9lY29yZS91dGlsL0V4dGVuZGVkTWV0YURhdGEiLFAoSShzZSwxKSxYLDIsNixbImtpbmQiLCJhdHRyaWJ1dGUiLCJuYW1lIiwieG1sbnM6cHJlZml4Il0pKSxFbihhKE8oRyhlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDIpLDE5KSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJraW5kIiwiYXR0cmlidXRlIiwibmFtZSIsInhzaTpzY2hlbWFMb2NhdGlvbiJdKSksRW4oYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwzKSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsia2luZCIsImVsZW1lbnQiLCJuYW1lIiwiY0RBVEEiLCJuYW1lc3BhY2UiLCIjI3RhcmdldE5hbWVzcGFjZSJdKSksRW4oYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw0KSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsia2luZCIsImVsZW1lbnQiLCJuYW1lIiwiY29tbWVudCIsIm5hbWVzcGFjZSIsIiMjdGFyZ2V0TmFtZXNwYWNlIl0pKSxFbihhKE8oRyhlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDUpLDE5KSwiaHR0cDovLy9vcmcvZWNsaXBzZS9lbWYvZWNvcmUvdXRpbC9FeHRlbmRlZE1ldGFEYXRhIixQKEkoc2UsMSksWCwyLDYsWyJraW5kIiwiZWxlbWVudCIsIm5hbWUiLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCJuYW1lc3BhY2UiLCIjI3RhcmdldE5hbWVzcGFjZSJdKSksRW4oYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw2KSwzNSksImh0dHA6Ly8vb3JnL2VjbGlwc2UvZW1mL2Vjb3JlL3V0aWwvRXh0ZW5kZWRNZXRhRGF0YSIsUChJKHNlLDEpLFgsMiw2LFsia2luZCIsImVsZW1lbnQiLCJuYW1lIiwidGV4dCIsIm5hbWVzcGFjZSIsIiMjdGFyZ2V0TmFtZXNwYWNlIl0pKX1mdW5jdGlvbiBLYm4oZSl7ZS5pc0NyZWF0ZWR8fChlLmlzQ3JlYXRlZD0hMCxlLmFueVR5cGVFQ2xhc3M9em8oZSwwKSxJcihlLmFueVR5cGVFQ2xhc3MsMCksSXIoZS5hbnlUeXBlRUNsYXNzLDEpLElyKGUuYW55VHlwZUVDbGFzcywyKSxlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcz16byhlLDEpLElyKGUucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzLDApLElyKGUucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzLDEpLGUuc2ltcGxlQW55VHlwZUVDbGFzcz16byhlLDIpLElyKGUuc2ltcGxlQW55VHlwZUVDbGFzcywzKSxJcihlLnNpbXBsZUFueVR5cGVFQ2xhc3MsNCksZHIoZS5zaW1wbGVBbnlUeXBlRUNsYXNzLDUpLGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcz16byhlLDMpLElyKGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcywwKSxkcihlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MsMSksZHIoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzLDIpLElyKGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcywzKSxJcihlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MsNCksZHIoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzLDUpLElyKGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyw2KSxlLmFueVNpbXBsZVR5cGVFRGF0YVR5cGU9R24oZSw0KSxlLmFueVVSSUVEYXRhVHlwZT1HbihlLDUpLGUuYmFzZTY0QmluYXJ5RURhdGFUeXBlPUduKGUsNiksZS5ib29sZWFuRURhdGFUeXBlPUduKGUsNyksZS5ib29sZWFuT2JqZWN0RURhdGFUeXBlPUduKGUsOCksZS5ieXRlRURhdGFUeXBlPUduKGUsOSksZS5ieXRlT2JqZWN0RURhdGFUeXBlPUduKGUsMTApLGUuZGF0ZUVEYXRhVHlwZT1HbihlLDExKSxlLmRhdGVUaW1lRURhdGFUeXBlPUduKGUsMTIpLGUuZGVjaW1hbEVEYXRhVHlwZT1HbihlLDEzKSxlLmRvdWJsZUVEYXRhVHlwZT1HbihlLDE0KSxlLmRvdWJsZU9iamVjdEVEYXRhVHlwZT1HbihlLDE1KSxlLmR1cmF0aW9uRURhdGFUeXBlPUduKGUsMTYpLGUuZW50aXRpZXNFRGF0YVR5cGU9R24oZSwxNyksZS5lbnRpdGllc0Jhc2VFRGF0YVR5cGU9R24oZSwxOCksZS5lbnRpdHlFRGF0YVR5cGU9R24oZSwxOSksZS5mbG9hdEVEYXRhVHlwZT1HbihlLDIwKSxlLmZsb2F0T2JqZWN0RURhdGFUeXBlPUduKGUsMjEpLGUuZ0RheUVEYXRhVHlwZT1HbihlLDIyKSxlLmdNb250aEVEYXRhVHlwZT1HbihlLDIzKSxlLmdNb250aERheUVEYXRhVHlwZT1HbihlLDI0KSxlLmdZZWFyRURhdGFUeXBlPUduKGUsMjUpLGUuZ1llYXJNb250aEVEYXRhVHlwZT1HbihlLDI2KSxlLmhleEJpbmFyeUVEYXRhVHlwZT1HbihlLDI3KSxlLmlkRURhdGFUeXBlPUduKGUsMjgpLGUuaWRyZWZFRGF0YVR5cGU9R24oZSwyOSksZS5pZHJlZnNFRGF0YVR5cGU9R24oZSwzMCksZS5pZHJlZnNCYXNlRURhdGFUeXBlPUduKGUsMzEpLGUuaW50RURhdGFUeXBlPUduKGUsMzIpLGUuaW50ZWdlckVEYXRhVHlwZT1HbihlLDMzKSxlLmludE9iamVjdEVEYXRhVHlwZT1HbihlLDM0KSxlLmxhbmd1YWdlRURhdGFUeXBlPUduKGUsMzUpLGUubG9uZ0VEYXRhVHlwZT1HbihlLDM2KSxlLmxvbmdPYmplY3RFRGF0YVR5cGU9R24oZSwzNyksZS5uYW1lRURhdGFUeXBlPUduKGUsMzgpLGUubmNOYW1lRURhdGFUeXBlPUduKGUsMzkpLGUubmVnYXRpdmVJbnRlZ2VyRURhdGFUeXBlPUduKGUsNDApLGUubm10b2tlbkVEYXRhVHlwZT1HbihlLDQxKSxlLm5tdG9rZW5zRURhdGFUeXBlPUduKGUsNDIpLGUubm10b2tlbnNCYXNlRURhdGFUeXBlPUduKGUsNDMpLGUubm9uTmVnYXRpdmVJbnRlZ2VyRURhdGFUeXBlPUduKGUsNDQpLGUubm9uUG9zaXRpdmVJbnRlZ2VyRURhdGFUeXBlPUduKGUsNDUpLGUubm9ybWFsaXplZFN0cmluZ0VEYXRhVHlwZT1HbihlLDQ2KSxlLm5vdGF0aW9uRURhdGFUeXBlPUduKGUsNDcpLGUucG9zaXRpdmVJbnRlZ2VyRURhdGFUeXBlPUduKGUsNDgpLGUucU5hbWVFRGF0YVR5cGU9R24oZSw0OSksZS5zaG9ydEVEYXRhVHlwZT1HbihlLDUwKSxlLnNob3J0T2JqZWN0RURhdGFUeXBlPUduKGUsNTEpLGUuc3RyaW5nRURhdGFUeXBlPUduKGUsNTIpLGUudGltZUVEYXRhVHlwZT1HbihlLDUzKSxlLnRva2VuRURhdGFUeXBlPUduKGUsNTQpLGUudW5zaWduZWRCeXRlRURhdGFUeXBlPUduKGUsNTUpLGUudW5zaWduZWRCeXRlT2JqZWN0RURhdGFUeXBlPUduKGUsNTYpLGUudW5zaWduZWRJbnRFRGF0YVR5cGU9R24oZSw1NyksZS51bnNpZ25lZEludE9iamVjdEVEYXRhVHlwZT1HbihlLDU4KSxlLnVuc2lnbmVkTG9uZ0VEYXRhVHlwZT1HbihlLDU5KSxlLnVuc2lnbmVkU2hvcnRFRGF0YVR5cGU9R24oZSw2MCksZS51bnNpZ25lZFNob3J0T2JqZWN0RURhdGFUeXBlPUduKGUsNjEpKX1mdW5jdGlvbiBYYm4oZSl7dmFyIG47ZS5pc0luaXRpYWxpemVkfHwoZS5pc0luaXRpYWxpemVkPSEwLGdpKGUsInR5cGUiKSxHQShlLCJlY29yZS54bWwudHlwZSIpLEhBKGUsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDMvWE1MVHlwZSIpLG49YShhMigobl8oKSxQbCksImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDMvWE1MVHlwZSIpLDIwNDQpLHBuKHdvKGUuc2ltcGxlQW55VHlwZUVDbGFzcyksZS5hbnlUeXBlRUNsYXNzKSwkbyhlLmFueVR5cGVFQ2xhc3MsT2IsIkFueVR5cGUiLCExLCExLCEwKSxPcihhKE8oRyhlLmFueVR5cGVFQ2xhc3MpLDApLDM1KSxlLmVjb3JlUGFja2FnZS5lRmVhdHVyZU1hcEVudHJ5RURhdGFUeXBlLCJtaXhlZCIsbnVsbCwwLC0xLE9iLCExLCExLCEwLCExLCExLCExKSxPcihhKE8oRyhlLmFueVR5cGVFQ2xhc3MpLDEpLDM1KSxlLmVjb3JlUGFja2FnZS5lRmVhdHVyZU1hcEVudHJ5RURhdGFUeXBlLCJhbnkiLG51bGwsMCwtMSxPYiwhMCwhMCwhMCwhMSwhMSwhMCksT3IoYShPKEcoZS5hbnlUeXBlRUNsYXNzKSwyKSwzNSksZS5lY29yZVBhY2thZ2UuZUZlYXR1cmVNYXBFbnRyeUVEYXRhVHlwZSwiYW55QXR0cmlidXRlIixudWxsLDAsLTEsT2IsITEsITEsITAsITEsITEsITEpLCRvKGUucHJvY2Vzc2luZ0luc3RydWN0aW9uRUNsYXNzLEpMLCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLCExLCExLCEwKSxPcihhKE8oRyhlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcyksMCksMzUpLGUuc3RyaW5nRURhdGFUeXBlLCJkYXRhIixudWxsLDAsMSxKTCwhMSwhMSwhMCwhMSwhMCwhMSksT3IoYShPKEcoZS5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb25FQ2xhc3MpLDEpLDM1KSxlLnN0cmluZ0VEYXRhVHlwZSwidGFyZ2V0IixudWxsLDEsMSxKTCwhMSwhMSwhMCwhMSwhMCwhMSksJG8oZS5zaW1wbGVBbnlUeXBlRUNsYXNzLE1iLCJTaW1wbGVBbnlUeXBlIiwhMSwhMSwhMCksT3IoYShPKEcoZS5zaW1wbGVBbnlUeXBlRUNsYXNzKSwwKSwzNSksbi5zdHJpbmdFRGF0YVR5cGUsInJhd1ZhbHVlIixudWxsLDAsMSxNYiwhMCwhMCwhMCwhMSwhMCwhMCksT3IoYShPKEcoZS5zaW1wbGVBbnlUeXBlRUNsYXNzKSwxKSwzNSksbi5hbnlTaW1wbGVUeXBlRURhdGFUeXBlLCJ2YWx1ZSIsbnVsbCwwLDEsTWIsITAsITAsITAsITEsITAsITApLGZyKGEoTyhHKGUuc2ltcGxlQW55VHlwZUVDbGFzcyksMiksMTkpLGUuZWNvcmVQYWNrYWdlLmVEYXRhVHlwZUVDbGFzcyxudWxsLCJpbnN0YW5jZVR5cGUiLDEsMSxNYiwhMSwhMSwhMCwhMSwhMSwhMSwhMSksJG8oZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzLHlvZSwiWE1MVHlwZURvY3VtZW50Um9vdCIsITEsITEsITApLE9yKGEoTyhHKGUueG1sVHlwZURvY3VtZW50Um9vdEVDbGFzcyksMCksMzUpLGUuZWNvcmVQYWNrYWdlLmVGZWF0dXJlTWFwRW50cnlFRGF0YVR5cGUsIm1peGVkIixudWxsLDAsLTEsbnVsbCwhMSwhMSwhMCwhMSwhMSwhMSksZnIoYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwxKSwxOSksZS5lY29yZVBhY2thZ2UuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MsbnVsbCwieE1MTlNQcmVmaXhNYXAiLDAsLTEsbnVsbCwhMCwhMSwhMCwhMCwhMSwhMSwhMSksZnIoYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwyKSwxOSksZS5lY29yZVBhY2thZ2UuZVN0cmluZ1RvU3RyaW5nTWFwRW50cnlFQ2xhc3MsbnVsbCwieFNJU2NoZW1hTG9jYXRpb24iLDAsLTEsbnVsbCwhMCwhMSwhMCwhMCwhMSwhMSwhMSksT3IoYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSwzKSwzNSksZS5zdHJpbmdFRGF0YVR5cGUsImNEQVRBIixudWxsLDAsLTIsbnVsbCwhMCwhMCwhMCwhMSwhMSwhMCksT3IoYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw0KSwzNSksZS5zdHJpbmdFRGF0YVR5cGUsImNvbW1lbnQiLG51bGwsMCwtMixudWxsLCEwLCEwLCEwLCExLCExLCEwKSxmcihhKE8oRyhlLnhtbFR5cGVEb2N1bWVudFJvb3RFQ2xhc3MpLDUpLDE5KSxlLnByb2Nlc3NpbmdJbnN0cnVjdGlvbkVDbGFzcyxudWxsLCJwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24iLDAsLTIsbnVsbCwhMCwhMCwhMCwhMCwhMSwhMSwhMCksT3IoYShPKEcoZS54bWxUeXBlRG9jdW1lbnRSb290RUNsYXNzKSw2KSwzNSksZS5zdHJpbmdFRGF0YVR5cGUsInRleHQiLG51bGwsMCwtMixudWxsLCEwLCEwLCEwLCExLCExLCEwKSxIbihlLmFueVNpbXBsZVR5cGVFRGF0YVR5cGUsUXIsIkFueVNpbXBsZVR5cGUiLCEwKSxIbihlLmFueVVSSUVEYXRhVHlwZSxzZSwiQW55VVJJIiwhMCksSG4oZS5iYXNlNjRCaW5hcnlFRGF0YVR5cGUsSShKaSwxKSwiQmFzZTY0QmluYXJ5IiwhMCksSG4oZS5ib29sZWFuRURhdGFUeXBlLHlhLCJCb29sZWFuIiwhMCksSG4oZS5ib29sZWFuT2JqZWN0RURhdGFUeXBlLEFyLCJCb29sZWFuT2JqZWN0IiwhMCksSG4oZS5ieXRlRURhdGFUeXBlLEppLCJCeXRlIiwhMCksSG4oZS5ieXRlT2JqZWN0RURhdGFUeXBlLHVoLCJCeXRlT2JqZWN0IiwhMCksSG4oZS5kYXRlRURhdGFUeXBlLHNlLCJEYXRlIiwhMCksSG4oZS5kYXRlVGltZUVEYXRhVHlwZSxzZSwiRGF0ZVRpbWUiLCEwKSxIbihlLmRlY2ltYWxFRGF0YVR5cGUsRjUsIkRlY2ltYWwiLCEwKSxIbihlLmRvdWJsZUVEYXRhVHlwZSxjdCwiRG91YmxlIiwhMCksSG4oZS5kb3VibGVPYmplY3RFRGF0YVR5cGUsJHIsIkRvdWJsZU9iamVjdCIsITApLEhuKGUuZHVyYXRpb25FRGF0YVR5cGUsc2UsIkR1cmF0aW9uIiwhMCksSG4oZS5lbnRpdGllc0VEYXRhVHlwZSxqYSwiRU5USVRJRVMiLCEwKSxIbihlLmVudGl0aWVzQmFzZUVEYXRhVHlwZSxqYSwiRU5USVRJRVNCYXNlIiwhMCksSG4oZS5lbnRpdHlFRGF0YVR5cGUsc2UsIkVOVElUWSIsITApLEhuKGUuZmxvYXRFRGF0YVR5cGUscHAsIkZsb2F0IiwhMCksSG4oZS5mbG9hdE9iamVjdEVEYXRhVHlwZSxheSwiRmxvYXRPYmplY3QiLCEwKSxIbihlLmdEYXlFRGF0YVR5cGUsc2UsIkdEYXkiLCEwKSxIbihlLmdNb250aEVEYXRhVHlwZSxzZSwiR01vbnRoIiwhMCksSG4oZS5nTW9udGhEYXlFRGF0YVR5cGUsc2UsIkdNb250aERheSIsITApLEhuKGUuZ1llYXJFRGF0YVR5cGUsc2UsIkdZZWFyIiwhMCksSG4oZS5nWWVhck1vbnRoRURhdGFUeXBlLHNlLCJHWWVhck1vbnRoIiwhMCksSG4oZS5oZXhCaW5hcnlFRGF0YVR5cGUsSShKaSwxKSwiSGV4QmluYXJ5IiwhMCksSG4oZS5pZEVEYXRhVHlwZSxzZSwiSUQiLCEwKSxIbihlLmlkcmVmRURhdGFUeXBlLHNlLCJJRFJFRiIsITApLEhuKGUuaWRyZWZzRURhdGFUeXBlLGphLCJJRFJFRlMiLCEwKSxIbihlLmlkcmVmc0Jhc2VFRGF0YVR5cGUsamEsIklEUkVGU0Jhc2UiLCEwKSxIbihlLmludEVEYXRhVHlwZSxobiwiSW50IiwhMCksSG4oZS5pbnRlZ2VyRURhdGFUeXBlLE5wLCJJbnRlZ2VyIiwhMCksSG4oZS5pbnRPYmplY3RFRGF0YVR5cGUsdnQsIkludE9iamVjdCIsITApLEhuKGUubGFuZ3VhZ2VFRGF0YVR5cGUsc2UsIkxhbmd1YWdlIiwhMCksSG4oZS5sb25nRURhdGFUeXBlLF9fLCJMb25nIiwhMCksSG4oZS5sb25nT2JqZWN0RURhdGFUeXBlLEkxLCJMb25nT2JqZWN0IiwhMCksSG4oZS5uYW1lRURhdGFUeXBlLHNlLCJOYW1lIiwhMCksSG4oZS5uY05hbWVFRGF0YVR5cGUsc2UsIk5DTmFtZSIsITApLEhuKGUubmVnYXRpdmVJbnRlZ2VyRURhdGFUeXBlLE5wLCJOZWdhdGl2ZUludGVnZXIiLCEwKSxIbihlLm5tdG9rZW5FRGF0YVR5cGUsc2UsIk5NVE9LRU4iLCEwKSxIbihlLm5tdG9rZW5zRURhdGFUeXBlLGphLCJOTVRPS0VOUyIsITApLEhuKGUubm10b2tlbnNCYXNlRURhdGFUeXBlLGphLCJOTVRPS0VOU0Jhc2UiLCEwKSxIbihlLm5vbk5lZ2F0aXZlSW50ZWdlckVEYXRhVHlwZSxOcCwiTm9uTmVnYXRpdmVJbnRlZ2VyIiwhMCksSG4oZS5ub25Qb3NpdGl2ZUludGVnZXJFRGF0YVR5cGUsTnAsIk5vblBvc2l0aXZlSW50ZWdlciIsITApLEhuKGUubm9ybWFsaXplZFN0cmluZ0VEYXRhVHlwZSxzZSwiTm9ybWFsaXplZFN0cmluZyIsITApLEhuKGUubm90YXRpb25FRGF0YVR5cGUsc2UsIk5PVEFUSU9OIiwhMCksSG4oZS5wb3NpdGl2ZUludGVnZXJFRGF0YVR5cGUsc2UsIlBvc2l0aXZlSW50ZWdlciIsITApLEhuKGUucU5hbWVFRGF0YVR5cGUsc2UsIlFOYW1lIiwhMCksSG4oZS5zaG9ydEVEYXRhVHlwZSxYZywiU2hvcnQiLCEwKSxIbihlLnNob3J0T2JqZWN0RURhdGFUeXBlLHgxLCJTaG9ydE9iamVjdCIsITApLEhuKGUuc3RyaW5nRURhdGFUeXBlLHNlLCJTdHJpbmciLCEwKSxIbihlLnRpbWVFRGF0YVR5cGUsc2UsIlRpbWUiLCEwKSxIbihlLnRva2VuRURhdGFUeXBlLHNlLCJUb2tlbiIsITApLEhuKGUudW5zaWduZWRCeXRlRURhdGFUeXBlLFhnLCJVbnNpZ25lZEJ5dGUiLCEwKSxIbihlLnVuc2lnbmVkQnl0ZU9iamVjdEVEYXRhVHlwZSx4MSwiVW5zaWduZWRCeXRlT2JqZWN0IiwhMCksSG4oZS51bnNpZ25lZEludEVEYXRhVHlwZSxfXywiVW5zaWduZWRJbnQiLCEwKSxIbihlLnVuc2lnbmVkSW50T2JqZWN0RURhdGFUeXBlLEkxLCJVbnNpZ25lZEludE9iamVjdCIsITApLEhuKGUudW5zaWduZWRMb25nRURhdGFUeXBlLE5wLCJVbnNpZ25lZExvbmciLCEwKSxIbihlLnVuc2lnbmVkU2hvcnRFRGF0YVR5cGUsaG4sIlVuc2lnbmVkU2hvcnQiLCEwKSxIbihlLnVuc2lnbmVkU2hvcnRPYmplY3RFRGF0YVR5cGUsdnQsIlVuc2lnbmVkU2hvcnRPYmplY3QiLCEwKSxTbmUoZSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMy9YTUxUeXBlIiksWWJuKGUpKX1mdW5jdGlvbiBpcWUoKXtDbmUuY2FsbCh0aGlzLCJodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2VtZi8yMDAzL1hNTFR5cGUiLChBVmUoKSxMVmUpKSxxYm4odGhpcyl9ZnVuY3Rpb24gSmJuKCl7dmFyIGU7cmV0dXJuIGFxZT9hKGEyKChuXygpLFBsKSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMy9YTUxUeXBlIiksMjA0NCk6KFpibigpLGU9YShMKG5pKChuXygpLFBsKSwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMy9YTUxUeXBlIiksNTk0KT9uaShQbCwiaHR0cDovL3d3dy5lY2xpcHNlLm9yZy9lbWYvMjAwMy9YTUxUeXBlIik6bmV3IGlxZSw1OTQpLGFxZT0hMCxLYm4oZSksWGJuKGUpLEJuKChQcmUoKSxOcmUpLGUsbmV3IGxxZSksZUQoZSksdG8oUGwsImh0dHA6Ly93d3cuZWNsaXBzZS5vcmcvZW1mLzIwMDMvWE1MVHlwZSIsZSksZSl9ZnVuY3Rpb24gWmJuKCl7JG4oT2IsbmV3IHlxZSksJG4oSkwsbmV3IE5xZSksJG4oTWIsbmV3IEJxZSksJG4oeW9lLG5ldyBKcWUpLCRuKHNlLG5ldyBuWWUpLCRuKEkoSmksMSksbmV3IHJZZSksJG4oQXIsbmV3IHRZZSksJG4odWgsbmV3IG9ZZSksJG4oc2UsbmV3IHNxZSksJG4oc2UsbmV3IHVxZSksJG4oc2UsbmV3IGNxZSksJG4oJHIsbmV3IF9xZSksJG4oc2UsbmV3IGRxZSksJG4oamEsbmV3IGZxZSksJG4oamEsbmV3IHBxZSksJG4oc2UsbmV3IGdxZSksJG4oYXksbmV3IGhxZSksJG4oc2UsbmV3IG1xZSksJG4oc2UsbmV3IHdxZSksJG4oc2UsbmV3IEVxZSksJG4oc2UsbmV3IHZxZSksJG4oc2UsbmV3IFNxZSksJG4oSShKaSwxKSxuZXcgQ3FlKSwkbihzZSxuZXcgVHFlKSwkbihzZSxuZXcgYnFlKSwkbihqYSxuZXcgSXFlKSwkbihqYSxuZXcgeHFlKSwkbihzZSxuZXcgUHFlKSwkbih2dCxuZXcgQXFlKSwkbihzZSxuZXcgTHFlKSwkbihJMSxuZXcga3FlKSwkbihzZSxuZXcgT3FlKSwkbihzZSxuZXcgTXFlKSwkbihzZSxuZXcgUnFlKSwkbihzZSxuZXcgRHFlKSwkbihqYSxuZXcgRnFlKSwkbihqYSxuZXcgenFlKSwkbihzZSxuZXcgJHFlKSwkbihzZSxuZXcgR3FlKSwkbihzZSxuZXcgSHFlKSwkbihzZSxuZXcgVXFlKSwkbihzZSxuZXcgV3FlKSwkbihzZSxuZXcganFlKSwkbih4MSxuZXcgVnFlKSwkbihzZSxuZXcgcXFlKSwkbihzZSxuZXcgWXFlKSwkbihzZSxuZXcgS3FlKSwkbih4MSxuZXcgWHFlKSwkbihJMSxuZXcgWnFlKSwkbihzZSxuZXcgUXFlKSwkbih2dCxuZXcgZVllKX1wKDU5NCwxODQsezExMDoxLDk0OjEsOTM6MSwxNTU6MSwxOTc6MSw1ODoxLDI0MToxLDExNDoxLDU0OjEsOTk6MSwxNTg6MSwxODQ6MSwxMTk6MSwxMjA6MSw2OTA6MSwyMDQ0OjEsNTk0OjF9LGlxZSksbC5pc0NyZWF0ZWQ9ITEsbC5pc0luaXRpYWxpemVkPSExO3ZhciBhcWU9ITE7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwiLDU5NCk7ZnVuY3Rpb24gbHFlKCl7fXAoMTk2MSwxLHs4NTE6MX0sbHFlKSxsLmdldEVWYWxpZGF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gVm9lKCksSVllfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8xIiwxOTYxKTtmdW5jdGlvbiBzcWUoKXt9cCgxOTcwLDEsem4sc3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMTAiLDE5NzApO2Z1bmN0aW9uIHVxZSgpe31wKDE5NzEsMSx6bix1cWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8xMSIsMTk3MSk7ZnVuY3Rpb24gY3FlKCl7fXAoMTk3MiwxLHpuLGNxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzEyIiwxOTcyKTtmdW5jdGlvbiBfcWUoKXt9cCgxOTczLDEsem4sX3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHFkKG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoJHIsWCwzNDUsbiw3LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8xMyIsMTk3Myk7ZnVuY3Rpb24gZHFlKCl7fXAoMTk3NCwxLHpuLGRxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzE0IiwxOTc0KTtmdW5jdGlvbiBmcWUoKXt9cCgxOTc1LDEsem4sZnFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihqYSxVZCwxNSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzE1IiwxOTc1KTtmdW5jdGlvbiBwcWUoKXt9cCgxOTc2LDEsem4scHFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihqYSxVZCwxNSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzE2IiwxOTc2KTtmdW5jdGlvbiBncWUoKXt9cCgxOTc3LDEsem4sZ3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMTciLDE5NzcpO2Z1bmN0aW9uIGhxZSgpe31wKDE5NzgsMSx6bixocWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE2MSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihheSxYLDE2MSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzE4IiwxOTc4KTtmdW5jdGlvbiBtcWUoKXt9cCgxOTc5LDEsem4sbXFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMTkiLDE5NzkpO2Z1bmN0aW9uIHlxZSgpe31wKDE5NjIsMSx6bix5cWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDg1Nyl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihPYixNZSw4NTcsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8yIiwxOTYyKTtmdW5jdGlvbiB3cWUoKXt9cCgxOTgwLDEsem4sd3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMjAiLDE5ODApO2Z1bmN0aW9uIEVxZSgpe31wKDE5ODEsMSx6bixFcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8yMSIsMTk4MSk7ZnVuY3Rpb24gdnFlKCl7fXAoMTk4MiwxLHpuLHZxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzIyIiwxOTgyKTtmdW5jdGlvbiBTcWUoKXt9cCgxOTgzLDEsem4sU3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMjMiLDE5ODMpO2Z1bmN0aW9uIENxZSgpe31wKDE5ODQsMSx6bixDcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE5NSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihKaSxYLDE5NSxuLDAsMil9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzI0IiwxOTg0KTtmdW5jdGlvbiBUcWUoKXt9cCgxOTg1LDEsem4sVHFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMjUiLDE5ODUpO2Z1bmN0aW9uIGJxZSgpe31wKDE5ODYsMSx6bixicWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8yNiIsMTk4Nik7ZnVuY3Rpb24gSXFlKCl7fXAoMTk4NywxLHpuLElxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTUpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoamEsVWQsMTUsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8yNyIsMTk4Nyk7ZnVuY3Rpb24geHFlKCl7fXAoMTk4OCwxLHpuLHhxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTUpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoamEsVWQsMTUsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8yOCIsMTk4OCk7ZnVuY3Rpb24gUHFlKCl7fXAoMTk4OSwxLHpuLFBxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzI5IiwxOTg5KTtmdW5jdGlvbiBOcWUoKXt9cCgxOTYzLDEsem4sTnFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiw2ODEpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoSkwsTWUsMjExOSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzMiLDE5NjMpO2Z1bmN0aW9uIEFxZSgpe31wKDE5OTAsMSx6bixBcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE3KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHZ0LFgsMTcsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8zMCIsMTk5MCk7ZnVuY3Rpb24gTHFlKCl7fXAoMTk5MSwxLHpuLExxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzMxIiwxOTkxKTtmdW5jdGlvbiBrcWUoKXt9cCgxOTkyLDEsem4sa3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNjgpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoSTEsWCwxNjgsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8zMiIsMTk5Mik7ZnVuY3Rpb24gT3FlKCl7fXAoMTk5MywxLHpuLE9xZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzMzIiwxOTkzKTtmdW5jdGlvbiBNcWUoKXt9cCgxOTk0LDEsem4sTXFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMzQiLDE5OTQpO2Z1bmN0aW9uIFJxZSgpe31wKDE5OTUsMSx6bixScWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC8zNSIsMTk5NSk7ZnVuY3Rpb24gRHFlKCl7fXAoMTk5NiwxLHpuLERxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzM2IiwxOTk2KTtmdW5jdGlvbiBGcWUoKXt9cCgxOTk3LDEsem4sRnFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihqYSxVZCwxNSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzM3IiwxOTk3KTtmdW5jdGlvbiB6cWUoKXt9cCgxOTk4LDEsem4senFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxNSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihqYSxVZCwxNSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzM4IiwxOTk4KTtmdW5jdGlvbiAkcWUoKXt9cCgxOTk5LDEsem4sJHFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvMzkiLDE5OTkpO2Z1bmN0aW9uIEJxZSgpe31wKDE5NjQsMSx6bixCcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDY4Mil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihNYixNZSwyMTIwLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNCIsMTk2NCk7ZnVuY3Rpb24gR3FlKCl7fXAoMmUzLDEsem4sR3FlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNDAiLDJlMyk7ZnVuY3Rpb24gSHFlKCl7fXAoMjAwMSwxLHpuLEhxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzQxIiwyMDAxKTtmdW5jdGlvbiBVcWUoKXt9cCgyMDAyLDEsem4sVXFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNDIiLDIwMDIpO2Z1bmN0aW9uIFdxZSgpe31wKDIwMDMsMSx6bixXcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC80MyIsMjAwMyk7ZnVuY3Rpb24ganFlKCl7fXAoMjAwNCwxLHpuLGpxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzQ0IiwyMDA0KTtmdW5jdGlvbiBWcWUoKXt9cCgyMDA1LDEsem4sVnFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEwobiwxOTEpfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoeDEsWCwxOTEsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC80NSIsMjAwNSk7ZnVuY3Rpb24gcXFlKCl7fXAoMjAwNiwxLHpuLHFxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzQ2IiwyMDA2KTtmdW5jdGlvbiBZcWUoKXt9cCgyMDA3LDEsem4sWXFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNDciLDIwMDcpO2Z1bmN0aW9uIEtxZSgpe31wKDIwMDgsMSx6bixLcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gdXQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihzZSxYLDIsbiw2LDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC80OCIsMjAwOCk7ZnVuY3Rpb24gWHFlKCl7fXAoMjAwOSwxLHpuLFhxZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBMKG4sMTkxKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHgxLFgsMTkxLG4sMCwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNDkiLDIwMDkpO2Z1bmN0aW9uIEpxZSgpe31wKDE5NjUsMSx6bixKcWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDY4Myl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQih5b2UsTWUsMjEyMSxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzUiLDE5NjUpO2Z1bmN0aW9uIFpxZSgpe31wKDIwMTAsMSx6bixacWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE2OCl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihJMSxYLDE2OCxuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzUwIiwyMDEwKTtmdW5jdGlvbiBRcWUoKXt9cCgyMDExLDEsem4sUXFlKSxsLmlzSW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIHV0KG4pfSxsLm5ld0FycmF5SW5zdGFuY2U9ZnVuY3Rpb24obil7cmV0dXJuIEIoc2UsWCwyLG4sNiwxKX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmltcGwiLCJYTUxUeXBlUGFja2FnZUltcGwvNTEiLDIwMTEpO2Z1bmN0aW9uIGVZZSgpe31wKDIwMTIsMSx6bixlWWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE3KX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHZ0LFgsMTcsbiwwLDEpfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW1wbCIsIlhNTFR5cGVQYWNrYWdlSW1wbC81MiIsMjAxMik7ZnVuY3Rpb24gblllKCl7fXAoMTk2NiwxLHpuLG5ZZSksbC5pc0luc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiB1dChuKX0sbC5uZXdBcnJheUluc3RhbmNlPWZ1bmN0aW9uKG4pe3JldHVybiBCKHNlLFgsMixuLDYsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzYiLDE5NjYpO2Z1bmN0aW9uIHJZZSgpe31wKDE5NjcsMSx6bixyWWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDE5NSl9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihKaSxYLDE5NSxuLDAsMil9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzciLDE5NjcpO2Z1bmN0aW9uIHRZZSgpe31wKDE5NjgsMSx6bix0WWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gVmQobil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQihBcixYLDQ4NSxuLDgsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzgiLDE5NjgpO2Z1bmN0aW9uIG9ZZSgpe31wKDE5NjksMSx6bixvWWUpLGwuaXNJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gTChuLDIyMil9LGwubmV3QXJyYXlJbnN0YW5jZT1mdW5jdGlvbihuKXtyZXR1cm4gQih1aCxYLDIyMixuLDAsMSl9LGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbXBsIiwiWE1MVHlwZVBhY2thZ2VJbXBsLzkiLDE5NjkpO2Z1bmN0aW9uIGJvZSgpe2JvZT1GO3ZhciBlLG4scix0LG8saSxzLHUsYztmb3IoWXM9QihKaSx3cCwyOCwyNTUsMTUsMSksZjA9QihmbCxYcywyOCw2NCwxNSwxKSxuPTA7bjwyNTU7bisrKVlzW25dPS0xO2ZvcihyPTkwO3I+PTY1O3ItLSlZc1tyXT1yLTY1PDwyND4+MjQ7Zm9yKHQ9MTIyO3Q+PTk3O3QtLSlZc1t0XT10LTk3KzI2PDwyND4+MjQ7Zm9yKG89NTc7bz49NDg7by0tKVlzW29dPW8tNDgrNTI8PDI0Pj4yNDtmb3IoWXNbNDNdPTYyLFlzWzQ3XT02MyxpPTA7aTw9MjU7aSsrKWYwW2ldPTY1K2kmenI7Zm9yKHM9MjYsYz0wO3M8PTUxOysrcyxjKyspZjBbc109OTcrYyZ6cjtmb3IoZT01Mix1PTA7ZTw9NjE7KytlLHUrKylmMFtlXT00OCt1JnpyO2YwWzYyXT00MyxmMFs2M109NDd9ZnVuY3Rpb24gUWJuKGUpe2JvZSgpO3ZhciBuLHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHksRSx2O2lmKGU9PW51bGx8fChpPVZJKGUpLHk9bkluKGkpLHklNCE9MCkpcmV0dXJuIG51bGw7aWYoRT15LzR8MCxFPT0wKXJldHVybiBCKEppLHdwLDI4LDAsMTUsMSk7Zm9yKGY9bnVsbCxuPTAscj0wLHQ9MCxvPTAscz0wLHU9MCxjPTAsXz0wLG09MCxoPTAsZD0wLGY9QihKaSx3cCwyOCxFKjMsMTUsMSk7bTxFLTE7bSsrKXtpZighRmIocz1pW2QrK10pfHwhRmIodT1pW2QrK10pfHwhRmIoYz1pW2QrK10pfHwhRmIoXz1pW2QrK10pKXJldHVybiBudWxsO249WXNbc10scj1Zc1t1XSx0PVlzW2NdLG89WXNbX10sZltoKytdPShuPDwyfHI+PjQpPDwyND4+MjQsZltoKytdPSgociYxNSk8PDR8dD4+MiYxNSk8PDI0Pj4yNCxmW2grK109KHQ8PDZ8byk8PDI0Pj4yNH1yZXR1cm4hRmIocz1pW2QrK10pfHwhRmIodT1pW2QrK10pP251bGw6KG49WXNbc10scj1Zc1t1XSxjPWlbZCsrXSxfPWlbZCsrXSxZc1tjXT09LTF8fFlzW19dPT0tMT9jPT02MSYmXz09NjE/ciYxNT9udWxsOih2PUIoSmksd3AsMjgsbSozKzEsMTUsMSksWG8oZiwwLHYsMCxtKjMpLHZbaF09KG48PDJ8cj4+NCk8PDI0Pj4yNCx2KTpjIT02MSYmXz09NjE/KHQ9WXNbY10sdCYzP251bGw6KHY9QihKaSx3cCwyOCxtKjMrMiwxNSwxKSxYbyhmLDAsdiwwLG0qMyksdltoKytdPShuPDwyfHI+PjQpPDwyND4+MjQsdltoXT0oKHImMTUpPDw0fHQ+PjImMTUpPDwyND4+MjQsdikpOm51bGw6KHQ9WXNbY10sbz1Zc1tfXSxmW2grK109KG48PDJ8cj4+NCk8PDI0Pj4yNCxmW2grK109KChyJjE1KTw8NHx0Pj4yJjE1KTw8MjQ+PjI0LGZbaCsrXT0odDw8NnxvKTw8MjQ+PjI0LGYpKX1mdW5jdGlvbiBlSW4oZSl7Ym9lKCk7dmFyIG4scix0LG8saSxzLHUsYyxfLGQsZixoLG0seSxFLHY7aWYoZT09bnVsbClyZXR1cm4gbnVsbDtpZihmPWUubGVuZ3RoKjgsZj09MClyZXR1cm4iIjtmb3IodT1mJTI0LG09Zi8yNHwwLGg9dSE9MD9tKzE6bSxpPW51bGwsaT1CKGZsLFhzLDI4LGgqNCwxNSwxKSxfPTAsZD0wLG49MCxyPTAsdD0wLHM9MCxvPTAsYz0wO2M8bTtjKyspbj1lW28rK10scj1lW28rK10sdD1lW28rK10sZD0ociYxNSk8PDI0Pj4yNCxfPShuJjMpPDwyND4+MjQseT1uJi0xMjg/KG4+PjJeMTkyKTw8MjQ+PjI0Om4+PjI8PDI0Pj4yNCxFPXImLTEyOD8ocj4+NF4yNDApPDwyND4+MjQ6cj4+NDw8MjQ+PjI0LHY9dCYtMTI4Pyh0Pj42XjI1Mik8PDI0Pj4yNDp0Pj42PDwyND4+MjQsaVtzKytdPWYwW3ldLGlbcysrXT1mMFtFfF88PDRdLGlbcysrXT1mMFtkPDwyfHZdLGlbcysrXT1mMFt0JjYzXTtyZXR1cm4gdT09OD8obj1lW29dLF89KG4mMyk8PDI0Pj4yNCx5PW4mLTEyOD8obj4+Ml4xOTIpPDwyND4+MjQ6bj4+Mjw8MjQ+PjI0LGlbcysrXT1mMFt5XSxpW3MrK109ZjBbXzw8NF0saVtzKytdPTYxLGlbcysrXT02MSk6dT09MTYmJihuPWVbb10scj1lW28rMV0sZD0ociYxNSk8PDI0Pj4yNCxfPShuJjMpPDwyND4+MjQseT1uJi0xMjg/KG4+PjJeMTkyKTw8MjQ+PjI0Om4+PjI8PDI0Pj4yNCxFPXImLTEyOD8ocj4+NF4yNDApPDwyND4+MjQ6cj4+NDw8MjQ+PjI0LGlbcysrXT1mMFt5XSxpW3MrK109ZjBbRXxfPDw0XSxpW3MrK109ZjBbZDw8Ml0saVtzKytdPTYxKSxpdShpLDAsaS5sZW5ndGgpfWZ1bmN0aW9uIEZiKGUpe3JldHVybiBZc1tlXSE9LTF9ZnVuY3Rpb24gbkluKGUpe3ZhciBuLHIsdDtmb3IodD0wLHI9ZS5sZW5ndGgsbj0wO248cjtuKyspZVtuXT09MzJ8fGVbbl09PTEzfHxlW25dPT0xMHx8ZVtuXT09OXx8KGVbdCsrXT1lW25dKTtyZXR1cm4gdH12YXIgWXMsZjA7ZnVuY3Rpb24gSW9lKCl7SW9lPUY7dmFyIGUsbixyLHQsbyxpO2ZvcihNUz1CKEppLHdwLDI4LDI1NSwxNSwxKSxaTD1CKGZsLFhzLDI4LDE2LDE1LDEpLG49MDtuPDI1NTtuKyspTVNbbl09LTE7Zm9yKHI9NTc7cj49NDg7ci0tKU1TW3JdPXItNDg8PDI0Pj4yNDtmb3IodD03MDt0Pj02NTt0LS0pTVNbdF09dC02NSsxMDw8MjQ+PjI0O2ZvcihvPTEwMjtvPj05NztvLS0pTVNbb109by05NysxMDw8MjQ+PjI0O2ZvcihpPTA7aTwxMDtpKyspWkxbaV09NDgraSZ6cjtmb3IoZT0xMDtlPD0xNTtlKyspWkxbZV09NjUrZS0xMCZ6cn1mdW5jdGlvbiBySW4oZSl7SW9lKCk7dmFyIG4scix0LG8saSxzLHU7aWYoZT09bnVsbHx8KG89ZS5sZW5ndGgsbyUyIT0wKSlyZXR1cm4gbnVsbDtmb3Iobj1WSShlKSxpPW8vMnwwLHI9QihKaSx3cCwyOCxpLDE1LDEpLHQ9MDt0PGk7dCsrKXtpZihzPU1TW25bdCoyXV0scz09LTF8fCh1PU1TW25bdCoyKzFdXSx1PT0tMSkpcmV0dXJuIG51bGw7clt0XT0oczw8NHx1KTw8MjQ+PjI0fXJldHVybiByfWZ1bmN0aW9uIHRJbihlKXtJb2UoKTt2YXIgbixyLHQsbyxpO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7Zm9yKHQ9ZS5sZW5ndGgsbz10KjIsbj1CKGZsLFhzLDI4LG8sMTUsMSkscj0wO3I8dDtyKyspaT1lW3JdLGk8MCYmKGkrPTI1NiksbltyKjJdPVpMW2k+PjRdLG5bcioyKzFdPVpMW2kmMTVdO3JldHVybiBpdShuLDAsbi5sZW5ndGgpfXZhciBNUyxaTDtmdW5jdGlvbiBpWWUoKXtpWWU9RixOPUIoSmksd3AsMjgsRnQsMTUsMSksTls5XT0zNSxOWzEwXT0xOSxOWzEzXT0xOSxOWzMyXT01MSxOWzMzXT00OSxOWzM0XT0zMyx6KE4sMzUsMzgsNDkpLE5bMzhdPTEseihOLDM5LDQ1LDQ5KSx6KE4sNDUsNDcsLTcxKSxOWzQ3XT00OSx6KE4sNDgsNTgsLTcxKSxOWzU4XT02MSxOWzU5XT00OSxOWzYwXT0xLE5bNjFdPTQ5LE5bNjJdPTMzLHooTiw2Myw2NSw0OSkseihOLDY1LDkxLC0zKSx6KE4sOTEsOTMsMzMpLE5bOTNdPTEsTls5NF09MzMsTls5NV09LTMsTls5Nl09MzMseihOLDk3LDEyMywtMykseihOLDEyMywxODMsMzMpLE5bMTgzXT0tODcseihOLDE4NCwxOTIsMzMpLHooTiwxOTIsMjE1LC0xOSksTlsyMTVdPTMzLHooTiwyMTYsMjQ3LC0xOSksTlsyNDddPTMzLHooTiwyNDgsMzA2LC0xOSkseihOLDMwNiwzMDgsMzMpLHooTiwzMDgsMzE5LC0xOSkseihOLDMxOSwzMjEsMzMpLHooTiwzMjEsMzI5LC0xOSksTlszMjldPTMzLHooTiwzMzAsMzgzLC0xOSksTlszODNdPTMzLHooTiwzODQsNDUyLC0xOSkseihOLDQ1Miw0NjEsMzMpLHooTiw0NjEsNDk3LC0xOSkseihOLDQ5Nyw1MDAsMzMpLHooTiw1MDAsNTAyLC0xOSkseihOLDUwMiw1MDYsMzMpLHooTiw1MDYsNTM2LC0xOSkseihOLDUzNiw1OTIsMzMpLHooTiw1OTIsNjgxLC0xOSkseihOLDY4MSw2OTksMzMpLHooTiw2OTksNzA2LC0xOSkseihOLDcwNiw3MjAsMzMpLHooTiw3MjAsNzIyLC04NykseihOLDcyMiw3NjgsMzMpLHooTiw3NjgsODM4LC04NykseihOLDgzOCw4NjQsMzMpLHooTiw4NjQsODY2LC04NykseihOLDg2Niw5MDIsMzMpLE5bOTAyXT0tMTksTls5MDNdPS04Nyx6KE4sOTA0LDkwNywtMTkpLE5bOTA3XT0zMyxOWzkwOF09LTE5LE5bOTA5XT0zMyx6KE4sOTEwLDkzMCwtMTkpLE5bOTMwXT0zMyx6KE4sOTMxLDk3NSwtMTkpLE5bOTc1XT0zMyx6KE4sOTc2LDk4MywtMTkpLHooTiw5ODMsOTg2LDMzKSxOWzk4Nl09LTE5LE5bOTg3XT0zMyxOWzk4OF09LTE5LE5bOTg5XT0zMyxOWzk5MF09LTE5LE5bOTkxXT0zMyxOWzk5Ml09LTE5LE5bOTkzXT0zMyx6KE4sOTk0LDEwMTIsLTE5KSx6KE4sMTAxMiwxMDI1LDMzKSx6KE4sMTAyNSwxMDM3LC0xOSksTlsxMDM3XT0zMyx6KE4sMTAzOCwxMTA0LC0xOSksTlsxMTA0XT0zMyx6KE4sMTEwNSwxMTE3LC0xOSksTlsxMTE3XT0zMyx6KE4sMTExOCwxMTU0LC0xOSksTlsxMTU0XT0zMyx6KE4sMTE1NSwxMTU5LC04NykseihOLDExNTksMTE2OCwzMykseihOLDExNjgsMTIyMSwtMTkpLHooTiwxMjIxLDEyMjMsMzMpLHooTiwxMjIzLDEyMjUsLTE5KSx6KE4sMTIyNSwxMjI3LDMzKSx6KE4sMTIyNywxMjI5LC0xOSkseihOLDEyMjksMTIzMiwzMykseihOLDEyMzIsMTI2MCwtMTkpLHooTiwxMjYwLDEyNjIsMzMpLHooTiwxMjYyLDEyNzAsLTE5KSx6KE4sMTI3MCwxMjcyLDMzKSx6KE4sMTI3MiwxMjc0LC0xOSkseihOLDEyNzQsMTMyOSwzMykseihOLDEzMjksMTM2NywtMTkpLHooTiwxMzY3LDEzNjksMzMpLE5bMTM2OV09LTE5LHooTiwxMzcwLDEzNzcsMzMpLHooTiwxMzc3LDE0MTUsLTE5KSx6KE4sMTQxNSwxNDI1LDMzKSx6KE4sMTQyNSwxNDQyLC04NyksTlsxNDQyXT0zMyx6KE4sMTQ0MywxNDY2LC04NyksTlsxNDY2XT0zMyx6KE4sMTQ2NywxNDcwLC04NyksTlsxNDcwXT0zMyxOWzE0NzFdPS04NyxOWzE0NzJdPTMzLHooTiwxNDczLDE0NzUsLTg3KSxOWzE0NzVdPTMzLE5bMTQ3Nl09LTg3LHooTiwxNDc3LDE0ODgsMzMpLHooTiwxNDg4LDE1MTUsLTE5KSx6KE4sMTUxNSwxNTIwLDMzKSx6KE4sMTUyMCwxNTIzLC0xOSkseihOLDE1MjMsMTU2OSwzMykseihOLDE1NjksMTU5NSwtMTkpLHooTiwxNTk1LDE2MDAsMzMpLE5bMTYwMF09LTg3LHooTiwxNjAxLDE2MTEsLTE5KSx6KE4sMTYxMSwxNjE5LC04NykseihOLDE2MTksMTYzMiwzMykseihOLDE2MzIsMTY0MiwtODcpLHooTiwxNjQyLDE2NDgsMzMpLE5bMTY0OF09LTg3LHooTiwxNjQ5LDE3MjAsLTE5KSx6KE4sMTcyMCwxNzIyLDMzKSx6KE4sMTcyMiwxNzI3LC0xOSksTlsxNzI3XT0zMyx6KE4sMTcyOCwxNzQzLC0xOSksTlsxNzQzXT0zMyx6KE4sMTc0NCwxNzQ4LC0xOSksTlsxNzQ4XT0zMyxOWzE3NDldPS0xOSx6KE4sMTc1MCwxNzY1LC04NykseihOLDE3NjUsMTc2NywtMTkpLHooTiwxNzY3LDE3NjksLTg3KSxOWzE3NjldPTMzLHooTiwxNzcwLDE3NzQsLTg3KSx6KE4sMTc3NCwxNzc2LDMzKSx6KE4sMTc3NiwxNzg2LC04NykseihOLDE3ODYsMjMwNSwzMykseihOLDIzMDUsMjMwOCwtODcpLE5bMjMwOF09MzMseihOLDIzMDksMjM2MiwtMTkpLHooTiwyMzYyLDIzNjQsMzMpLE5bMjM2NF09LTg3LE5bMjM2NV09LTE5LHooTiwyMzY2LDIzODIsLTg3KSx6KE4sMjM4MiwyMzg1LDMzKSx6KE4sMjM4NSwyMzg5LC04NykseihOLDIzODksMjM5MiwzMykseihOLDIzOTIsMjQwMiwtMTkpLHooTiwyNDAyLDI0MDQsLTg3KSx6KE4sMjQwNCwyNDA2LDMzKSx6KE4sMjQwNiwyNDE2LC04NykseihOLDI0MTYsMjQzMywzMykseihOLDI0MzMsMjQzNiwtODcpLE5bMjQzNl09MzMseihOLDI0MzcsMjQ0NSwtMTkpLHooTiwyNDQ1LDI0NDcsMzMpLHooTiwyNDQ3LDI0NDksLTE5KSx6KE4sMjQ0OSwyNDUxLDMzKSx6KE4sMjQ1MSwyNDczLC0xOSksTlsyNDczXT0zMyx6KE4sMjQ3NCwyNDgxLC0xOSksTlsyNDgxXT0zMyxOWzI0ODJdPS0xOSx6KE4sMjQ4MywyNDg2LDMzKSx6KE4sMjQ4NiwyNDkwLC0xOSkseihOLDI0OTAsMjQ5MiwzMyksTlsyNDkyXT0tODcsTlsyNDkzXT0zMyx6KE4sMjQ5NCwyNTAxLC04NykseihOLDI1MDEsMjUwMywzMykseihOLDI1MDMsMjUwNSwtODcpLHooTiwyNTA1LDI1MDcsMzMpLHooTiwyNTA3LDI1MTAsLTg3KSx6KE4sMjUxMCwyNTE5LDMzKSxOWzI1MTldPS04Nyx6KE4sMjUyMCwyNTI0LDMzKSx6KE4sMjUyNCwyNTI2LC0xOSksTlsyNTI2XT0zMyx6KE4sMjUyNywyNTMwLC0xOSkseihOLDI1MzAsMjUzMiwtODcpLHooTiwyNTMyLDI1MzQsMzMpLHooTiwyNTM0LDI1NDQsLTg3KSx6KE4sMjU0NCwyNTQ2LC0xOSkseihOLDI1NDYsMjU2MiwzMyksTlsyNTYyXT0tODcseihOLDI1NjMsMjU2NSwzMykseihOLDI1NjUsMjU3MSwtMTkpLHooTiwyNTcxLDI1NzUsMzMpLHooTiwyNTc1LDI1NzcsLTE5KSx6KE4sMjU3NywyNTc5LDMzKSx6KE4sMjU3OSwyNjAxLC0xOSksTlsyNjAxXT0zMyx6KE4sMjYwMiwyNjA5LC0xOSksTlsyNjA5XT0zMyx6KE4sMjYxMCwyNjEyLC0xOSksTlsyNjEyXT0zMyx6KE4sMjYxMywyNjE1LC0xOSksTlsyNjE1XT0zMyx6KE4sMjYxNiwyNjE4LC0xOSkseihOLDI2MTgsMjYyMCwzMyksTlsyNjIwXT0tODcsTlsyNjIxXT0zMyx6KE4sMjYyMiwyNjI3LC04NykseihOLDI2MjcsMjYzMSwzMykseihOLDI2MzEsMjYzMywtODcpLHooTiwyNjMzLDI2MzUsMzMpLHooTiwyNjM1LDI2MzgsLTg3KSx6KE4sMjYzOCwyNjQ5LDMzKSx6KE4sMjY0OSwyNjUzLC0xOSksTlsyNjUzXT0zMyxOWzI2NTRdPS0xOSx6KE4sMjY1NSwyNjYyLDMzKSx6KE4sMjY2MiwyNjc0LC04NykseihOLDI2NzQsMjY3NywtMTkpLHooTiwyNjc3LDI2ODksMzMpLHooTiwyNjg5LDI2OTIsLTg3KSxOWzI2OTJdPTMzLHooTiwyNjkzLDI3MDAsLTE5KSxOWzI3MDBdPTMzLE5bMjcwMV09LTE5LE5bMjcwMl09MzMseihOLDI3MDMsMjcwNiwtMTkpLE5bMjcwNl09MzMseihOLDI3MDcsMjcyOSwtMTkpLE5bMjcyOV09MzMseihOLDI3MzAsMjczNywtMTkpLE5bMjczN109MzMseihOLDI3MzgsMjc0MCwtMTkpLE5bMjc0MF09MzMseihOLDI3NDEsMjc0NiwtMTkpLHooTiwyNzQ2LDI3NDgsMzMpLE5bMjc0OF09LTg3LE5bMjc0OV09LTE5LHooTiwyNzUwLDI3NTgsLTg3KSxOWzI3NThdPTMzLHooTiwyNzU5LDI3NjIsLTg3KSxOWzI3NjJdPTMzLHooTiwyNzYzLDI3NjYsLTg3KSx6KE4sMjc2NiwyNzg0LDMzKSxOWzI3ODRdPS0xOSx6KE4sMjc4NSwyNzkwLDMzKSx6KE4sMjc5MCwyODAwLC04NykseihOLDI4MDAsMjgxNywzMykseihOLDI4MTcsMjgyMCwtODcpLE5bMjgyMF09MzMseihOLDI4MjEsMjgyOSwtMTkpLHooTiwyODI5LDI4MzEsMzMpLHooTiwyODMxLDI4MzMsLTE5KSx6KE4sMjgzMywyODM1LDMzKSx6KE4sMjgzNSwyODU3LC0xOSksTlsyODU3XT0zMyx6KE4sMjg1OCwyODY1LC0xOSksTlsyODY1XT0zMyx6KE4sMjg2NiwyODY4LC0xOSkseihOLDI4NjgsMjg3MCwzMykseihOLDI4NzAsMjg3NCwtMTkpLHooTiwyODc0LDI4NzYsMzMpLE5bMjg3Nl09LTg3LE5bMjg3N109LTE5LHooTiwyODc4LDI4ODQsLTg3KSx6KE4sMjg4NCwyODg3LDMzKSx6KE4sMjg4NywyODg5LC04NykseihOLDI4ODksMjg5MSwzMykseihOLDI4OTEsMjg5NCwtODcpLHooTiwyODk0LDI5MDIsMzMpLHooTiwyOTAyLDI5MDQsLTg3KSx6KE4sMjkwNCwyOTA4LDMzKSx6KE4sMjkwOCwyOTEwLC0xOSksTlsyOTEwXT0zMyx6KE4sMjkxMSwyOTE0LC0xOSkseihOLDI5MTQsMjkxOCwzMykseihOLDI5MTgsMjkyOCwtODcpLHooTiwyOTI4LDI5NDYsMzMpLHooTiwyOTQ2LDI5NDgsLTg3KSxOWzI5NDhdPTMzLHooTiwyOTQ5LDI5NTUsLTE5KSx6KE4sMjk1NSwyOTU4LDMzKSx6KE4sMjk1OCwyOTYxLC0xOSksTlsyOTYxXT0zMyx6KE4sMjk2MiwyOTY2LC0xOSkseihOLDI5NjYsMjk2OSwzMykseihOLDI5NjksMjk3MSwtMTkpLE5bMjk3MV09MzMsTlsyOTcyXT0tMTksTlsyOTczXT0zMyx6KE4sMjk3NCwyOTc2LC0xOSkseihOLDI5NzYsMjk3OSwzMykseihOLDI5NzksMjk4MSwtMTkpLHooTiwyOTgxLDI5ODQsMzMpLHooTiwyOTg0LDI5ODcsLTE5KSx6KE4sMjk4NywyOTkwLDMzKSx6KE4sMjk5MCwyOTk4LC0xOSksTlsyOTk4XT0zMyx6KE4sMjk5OSwzMDAyLC0xOSkseihOLDMwMDIsMzAwNiwzMykseihOLDMwMDYsMzAxMSwtODcpLHooTiwzMDExLDMwMTQsMzMpLHooTiwzMDE0LDMwMTcsLTg3KSxOWzMwMTddPTMzLHooTiwzMDE4LDMwMjIsLTg3KSx6KE4sMzAyMiwzMDMxLDMzKSxOWzMwMzFdPS04Nyx6KE4sMzAzMiwzMDQ3LDMzKSx6KE4sMzA0NywzMDU2LC04NykseihOLDMwNTYsMzA3MywzMykseihOLDMwNzMsMzA3NiwtODcpLE5bMzA3Nl09MzMseihOLDMwNzcsMzA4NSwtMTkpLE5bMzA4NV09MzMseihOLDMwODYsMzA4OSwtMTkpLE5bMzA4OV09MzMseihOLDMwOTAsMzExMywtMTkpLE5bMzExM109MzMseihOLDMxMTQsMzEyNCwtMTkpLE5bMzEyNF09MzMseihOLDMxMjUsMzEzMCwtMTkpLHooTiwzMTMwLDMxMzQsMzMpLHooTiwzMTM0LDMxNDEsLTg3KSxOWzMxNDFdPTMzLHooTiwzMTQyLDMxNDUsLTg3KSxOWzMxNDVdPTMzLHooTiwzMTQ2LDMxNTAsLTg3KSx6KE4sMzE1MCwzMTU3LDMzKSx6KE4sMzE1NywzMTU5LC04NykseihOLDMxNTksMzE2OCwzMykseihOLDMxNjgsMzE3MCwtMTkpLHooTiwzMTcwLDMxNzQsMzMpLHooTiwzMTc0LDMxODQsLTg3KSx6KE4sMzE4NCwzMjAyLDMzKSx6KE4sMzIwMiwzMjA0LC04NyksTlszMjA0XT0zMyx6KE4sMzIwNSwzMjEzLC0xOSksTlszMjEzXT0zMyx6KE4sMzIxNCwzMjE3LC0xOSksTlszMjE3XT0zMyx6KE4sMzIxOCwzMjQxLC0xOSksTlszMjQxXT0zMyx6KE4sMzI0MiwzMjUyLC0xOSksTlszMjUyXT0zMyx6KE4sMzI1MywzMjU4LC0xOSkseihOLDMyNTgsMzI2MiwzMykseihOLDMyNjIsMzI2OSwtODcpLE5bMzI2OV09MzMseihOLDMyNzAsMzI3MywtODcpLE5bMzI3M109MzMseihOLDMyNzQsMzI3OCwtODcpLHooTiwzMjc4LDMyODUsMzMpLHooTiwzMjg1LDMyODcsLTg3KSx6KE4sMzI4NywzMjk0LDMzKSxOWzMyOTRdPS0xOSxOWzMyOTVdPTMzLHooTiwzMjk2LDMyOTgsLTE5KSx6KE4sMzI5OCwzMzAyLDMzKSx6KE4sMzMwMiwzMzEyLC04NykseihOLDMzMTIsMzMzMCwzMykseihOLDMzMzAsMzMzMiwtODcpLE5bMzMzMl09MzMseihOLDMzMzMsMzM0MSwtMTkpLE5bMzM0MV09MzMseihOLDMzNDIsMzM0NSwtMTkpLE5bMzM0NV09MzMseihOLDMzNDYsMzM2OSwtMTkpLE5bMzM2OV09MzMseihOLDMzNzAsMzM4NiwtMTkpLHooTiwzMzg2LDMzOTAsMzMpLHooTiwzMzkwLDMzOTYsLTg3KSx6KE4sMzM5NiwzMzk4LDMzKSx6KE4sMzM5OCwzNDAxLC04NyksTlszNDAxXT0zMyx6KE4sMzQwMiwzNDA2LC04NykseihOLDM0MDYsMzQxNSwzMyksTlszNDE1XT0tODcseihOLDM0MTYsMzQyNCwzMykseihOLDM0MjQsMzQyNiwtMTkpLHooTiwzNDI2LDM0MzAsMzMpLHooTiwzNDMwLDM0NDAsLTg3KSx6KE4sMzQ0MCwzNTg1LDMzKSx6KE4sMzU4NSwzNjMxLC0xOSksTlszNjMxXT0zMyxOWzM2MzJdPS0xOSxOWzM2MzNdPS04Nyx6KE4sMzYzNCwzNjM2LC0xOSkseihOLDM2MzYsMzY0MywtODcpLHooTiwzNjQzLDM2NDgsMzMpLHooTiwzNjQ4LDM2NTQsLTE5KSx6KE4sMzY1NCwzNjYzLC04NyksTlszNjYzXT0zMyx6KE4sMzY2NCwzNjc0LC04NykseihOLDM2NzQsMzcxMywzMykseihOLDM3MTMsMzcxNSwtMTkpLE5bMzcxNV09MzMsTlszNzE2XT0tMTkseihOLDM3MTcsMzcxOSwzMykseihOLDM3MTksMzcyMSwtMTkpLE5bMzcyMV09MzMsTlszNzIyXT0tMTkseihOLDM3MjMsMzcyNSwzMyksTlszNzI1XT0tMTkseihOLDM3MjYsMzczMiwzMykseihOLDM3MzIsMzczNiwtMTkpLE5bMzczNl09MzMseihOLDM3MzcsMzc0NCwtMTkpLE5bMzc0NF09MzMseihOLDM3NDUsMzc0OCwtMTkpLE5bMzc0OF09MzMsTlszNzQ5XT0tMTksTlszNzUwXT0zMyxOWzM3NTFdPS0xOSx6KE4sMzc1MiwzNzU0LDMzKSx6KE4sMzc1NCwzNzU2LC0xOSksTlszNzU2XT0zMyx6KE4sMzc1NywzNzU5LC0xOSksTlszNzU5XT0zMyxOWzM3NjBdPS0xOSxOWzM3NjFdPS04Nyx6KE4sMzc2MiwzNzY0LC0xOSkseihOLDM3NjQsMzc3MCwtODcpLE5bMzc3MF09MzMseihOLDM3NzEsMzc3MywtODcpLE5bMzc3M109LTE5LHooTiwzNzc0LDM3NzYsMzMpLHooTiwzNzc2LDM3ODEsLTE5KSxOWzM3ODFdPTMzLE5bMzc4Ml09LTg3LE5bMzc4M109MzMseihOLDM3ODQsMzc5MCwtODcpLHooTiwzNzkwLDM3OTIsMzMpLHooTiwzNzkyLDM4MDIsLTg3KSx6KE4sMzgwMiwzODY0LDMzKSx6KE4sMzg2NCwzODY2LC04NykseihOLDM4NjYsMzg3MiwzMykseihOLDM4NzIsMzg4MiwtODcpLHooTiwzODgyLDM4OTMsMzMpLE5bMzg5M109LTg3LE5bMzg5NF09MzMsTlszODk1XT0tODcsTlszODk2XT0zMyxOWzM4OTddPS04Nyx6KE4sMzg5OCwzOTAyLDMzKSx6KE4sMzkwMiwzOTA0LC04NykseihOLDM5MDQsMzkxMiwtMTkpLE5bMzkxMl09MzMseihOLDM5MTMsMzk0NiwtMTkpLHooTiwzOTQ2LDM5NTMsMzMpLHooTiwzOTUzLDM5NzMsLTg3KSxOWzM5NzNdPTMzLHooTiwzOTc0LDM5ODAsLTg3KSx6KE4sMzk4MCwzOTg0LDMzKSx6KE4sMzk4NCwzOTkwLC04NyksTlszOTkwXT0zMyxOWzM5OTFdPS04NyxOWzM5OTJdPTMzLHooTiwzOTkzLDQwMTQsLTg3KSx6KE4sNDAxNCw0MDE3LDMzKSx6KE4sNDAxNyw0MDI0LC04NyksTls0MDI0XT0zMyxOWzQwMjVdPS04Nyx6KE4sNDAyNiw0MjU2LDMzKSx6KE4sNDI1Niw0Mjk0LC0xOSkseihOLDQyOTQsNDMwNCwzMykseihOLDQzMDQsNDM0MywtMTkpLHooTiw0MzQzLDQzNTIsMzMpLE5bNDM1Ml09LTE5LE5bNDM1M109MzMseihOLDQzNTQsNDM1NiwtMTkpLE5bNDM1Nl09MzMseihOLDQzNTcsNDM2MCwtMTkpLE5bNDM2MF09MzMsTls0MzYxXT0tMTksTls0MzYyXT0zMyx6KE4sNDM2Myw0MzY1LC0xOSksTls0MzY1XT0zMyx6KE4sNDM2Niw0MzcxLC0xOSkseihOLDQzNzEsNDQxMiwzMyksTls0NDEyXT0tMTksTls0NDEzXT0zMyxOWzQ0MTRdPS0xOSxOWzQ0MTVdPTMzLE5bNDQxNl09LTE5LHooTiw0NDE3LDQ0MjgsMzMpLE5bNDQyOF09LTE5LE5bNDQyOV09MzMsTls0NDMwXT0tMTksTls0NDMxXT0zMyxOWzQ0MzJdPS0xOSx6KE4sNDQzMyw0NDM2LDMzKSx6KE4sNDQzNiw0NDM4LC0xOSkseihOLDQ0MzgsNDQ0MSwzMyksTls0NDQxXT0tMTkseihOLDQ0NDIsNDQ0NywzMykseihOLDQ0NDcsNDQ1MCwtMTkpLE5bNDQ1MF09MzMsTls0NDUxXT0tMTksTls0NDUyXT0zMyxOWzQ0NTNdPS0xOSxOWzQ0NTRdPTMzLE5bNDQ1NV09LTE5LE5bNDQ1Nl09MzMsTls0NDU3XT0tMTkseihOLDQ0NTgsNDQ2MSwzMykseihOLDQ0NjEsNDQ2MywtMTkpLHooTiw0NDYzLDQ0NjYsMzMpLHooTiw0NDY2LDQ0NjgsLTE5KSxOWzQ0NjhdPTMzLE5bNDQ2OV09LTE5LHooTiw0NDcwLDQ1MTAsMzMpLE5bNDUxMF09LTE5LHooTiw0NTExLDQ1MjAsMzMpLE5bNDUyMF09LTE5LHooTiw0NTIxLDQ1MjMsMzMpLE5bNDUyM109LTE5LHooTiw0NTI0LDQ1MjYsMzMpLHooTiw0NTI2LDQ1MjgsLTE5KSx6KE4sNDUyOCw0NTM1LDMzKSx6KE4sNDUzNSw0NTM3LC0xOSksTls0NTM3XT0zMyxOWzQ1MzhdPS0xOSxOWzQ1MzldPTMzLHooTiw0NTQwLDQ1NDcsLTE5KSx6KE4sNDU0Nyw0NTg3LDMzKSxOWzQ1ODddPS0xOSx6KE4sNDU4OCw0NTkyLDMzKSxOWzQ1OTJdPS0xOSx6KE4sNDU5Myw0NjAxLDMzKSxOWzQ2MDFdPS0xOSx6KE4sNDYwMiw3NjgwLDMzKSx6KE4sNzY4MCw3ODM2LC0xOSkseihOLDc4MzYsNzg0MCwzMykseihOLDc4NDAsNzkzMCwtMTkpLHooTiw3OTMwLDc5MzYsMzMpLHooTiw3OTM2LDc5NTgsLTE5KSx6KE4sNzk1OCw3OTYwLDMzKSx6KE4sNzk2MCw3OTY2LC0xOSkseihOLDc5NjYsNzk2OCwzMykseihOLDc5NjgsODAwNiwtMTkpLHooTiw4MDA2LDgwMDgsMzMpLHooTiw4MDA4LDgwMTQsLTE5KSx6KE4sODAxNCw4MDE2LDMzKSx6KE4sODAxNiw4MDI0LC0xOSksTls4MDI0XT0zMyxOWzgwMjVdPS0xOSxOWzgwMjZdPTMzLE5bODAyN109LTE5LE5bODAyOF09MzMsTls4MDI5XT0tMTksTls4MDMwXT0zMyx6KE4sODAzMSw4MDYyLC0xOSkseihOLDgwNjIsODA2NCwzMykseihOLDgwNjQsODExNywtMTkpLE5bODExN109MzMseihOLDgxMTgsODEyNSwtMTkpLE5bODEyNV09MzMsTls4MTI2XT0tMTkseihOLDgxMjcsODEzMCwzMykseihOLDgxMzAsODEzMywtMTkpLE5bODEzM109MzMseihOLDgxMzQsODE0MSwtMTkpLHooTiw4MTQxLDgxNDQsMzMpLHooTiw4MTQ0LDgxNDgsLTE5KSx6KE4sODE0OCw4MTUwLDMzKSx6KE4sODE1MCw4MTU2LC0xOSkseihOLDgxNTYsODE2MCwzMykseihOLDgxNjAsODE3MywtMTkpLHooTiw4MTczLDgxNzgsMzMpLHooTiw4MTc4LDgxODEsLTE5KSxOWzgxODFdPTMzLHooTiw4MTgyLDgxODksLTE5KSx6KE4sODE4OSw4NDAwLDMzKSx6KE4sODQwMCw4NDEzLC04NykseihOLDg0MTMsODQxNywzMyksTls4NDE3XT0tODcseihOLDg0MTgsODQ4NiwzMyksTls4NDg2XT0tMTkseihOLDg0ODcsODQ5MCwzMykseihOLDg0OTAsODQ5MiwtMTkpLHooTiw4NDkyLDg0OTQsMzMpLE5bODQ5NF09LTE5LHooTiw4NDk1LDg1NzYsMzMpLHooTiw4NTc2LDg1NzksLTE5KSx6KE4sODU3OSwxMjI5MywzMyksTlsxMjI5M109LTg3LE5bMTIyOTRdPTMzLE5bMTIyOTVdPS0xOSx6KE4sMTIyOTYsMTIzMjEsMzMpLHooTiwxMjMyMSwxMjMzMCwtMTkpLHooTiwxMjMzMCwxMjMzNiwtODcpLE5bMTIzMzZdPTMzLHooTiwxMjMzNywxMjM0MiwtODcpLHooTiwxMjM0MiwxMjM1MywzMykseihOLDEyMzUzLDEyNDM3LC0xOSkseihOLDEyNDM3LDEyNDQxLDMzKSx6KE4sMTI0NDEsMTI0NDMsLTg3KSx6KE4sMTI0NDMsMTI0NDUsMzMpLHooTiwxMjQ0NSwxMjQ0NywtODcpLHooTiwxMjQ0NywxMjQ0OSwzMykseihOLDEyNDQ5LDEyNTM5LC0xOSksTlsxMjUzOV09MzMseihOLDEyNTQwLDEyNTQzLC04NykseihOLDEyNTQzLDEyNTQ5LDMzKSx6KE4sMTI1NDksMTI1ODksLTE5KSx6KE4sMTI1ODksMTk5NjgsMzMpLHooTiwxOTk2OCw0MDg3MCwtMTkpLHooTiw0MDg3MCw0NDAzMiwzMykseihOLDQ0MDMyLDU1MjA0LC0xOSkseihOLDU1MjA0LEtTLDMzKSx6KE4sNTczNDQsNjU1MzQsMzMpfXZhciBOO2Z1bmN0aW9uIFBuKGUpe0lvLmNhbGwodGhpcyxlKX1wKDU1LDYzLEt1LFBuKSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9QYXJzZUV4Y2VwdGlvbiIsNTUpO2Z1bmN0aW9uIFduKGUpe3ZhciBuLHIsdDtpZihlLm9mZnNldD49ZS5yZWdleGxlbil7ZS5jaGFyZGF0YT0tMSxlLm5leHR0b2tlbj0xO3JldHVybn1pZihuPUl0KGUucmVnZXgsZS5vZmZzZXQrKyksZS5jaGFyZGF0YT1uLGUuY29udGV4dD09MSl7c3dpdGNoKG4pe2Nhc2UgOTI6aWYodD0xMCxlLm9mZnNldD49ZS5yZWdleGxlbil0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLm5leHQuMSIpKSkpO2UuY2hhcmRhdGE9SXQoZS5yZWdleCxlLm9mZnNldCsrKTticmVhaztjYXNlIDQ1OihlLm9wdGlvbnNfMCY1MTIpPT01MTImJmUub2Zmc2V0PGUucmVnZXhsZW4mJkl0KGUucmVnZXgsZS5vZmZzZXQpPT05MT8oKytlLm9mZnNldCx0PTI0KTp0PTA7YnJlYWs7Y2FzZSA5MTppZigoZS5vcHRpb25zXzAmNTEyKSE9NTEyJiZlLm9mZnNldDxlLnJlZ2V4bGVuJiZJdChlLnJlZ2V4LGUub2Zmc2V0KT09NTgpeysrZS5vZmZzZXQsdD0yMDticmVha31kZWZhdWx0OihuJjY0NTEyKT09S1MmJmUub2Zmc2V0PGUucmVnZXhsZW4mJihyPUl0KGUucmVnZXgsZS5vZmZzZXQpLChyJjY0NTEyKT09NTYzMjAmJihlLmNoYXJkYXRhPUZ0KyhuLUtTPDwxMCkrci01NjMyMCwrK2Uub2Zmc2V0KSksdD0wfWUubmV4dHRva2VuPXQ7cmV0dXJufXN3aXRjaChuKXtjYXNlIDEyNDp0PTI7YnJlYWs7Y2FzZSA0Mjp0PTM7YnJlYWs7Y2FzZSA0Mzp0PTQ7YnJlYWs7Y2FzZSA2Mzp0PTU7YnJlYWs7Y2FzZSA0MTp0PTc7YnJlYWs7Y2FzZSA0Njp0PTg7YnJlYWs7Y2FzZSA5MTp0PTk7YnJlYWs7Y2FzZSA5NDp0PTExO2JyZWFrO2Nhc2UgMzY6dD0xMjticmVhaztjYXNlIDQwOmlmKHQ9NixlLm9mZnNldD49ZS5yZWdleGxlbnx8SXQoZS5yZWdleCxlLm9mZnNldCkhPTYzKWJyZWFrO2lmKCsrZS5vZmZzZXQ+PWUucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5uZXh0LjIiKSkpKTtzd2l0Y2gobj1JdChlLnJlZ2V4LGUub2Zmc2V0KyspLG4pe2Nhc2UgNTg6dD0xMzticmVhaztjYXNlIDYxOnQ9MTQ7YnJlYWs7Y2FzZSAzMzp0PTE1O2JyZWFrO2Nhc2UgOTE6dD0xOTticmVhaztjYXNlIDYyOnQ9MTg7YnJlYWs7Y2FzZSA2MDppZihlLm9mZnNldD49ZS5yZWdleGxlbil0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLm5leHQuMiIpKSkpO2lmKG49SXQoZS5yZWdleCxlLm9mZnNldCsrKSxuPT02MSl0PTE2O2Vsc2UgaWYobj09MzMpdD0xNztlbHNlIHRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIubmV4dC4zIikpKSk7YnJlYWs7Y2FzZSAzNTpmb3IoO2Uub2Zmc2V0PGUucmVnZXhsZW4mJihuPUl0KGUucmVnZXgsZS5vZmZzZXQrKyksbiE9NDEpOyk7aWYobiE9NDEpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5uZXh0LjQiKSkpKTt0PTIxO2JyZWFrO2RlZmF1bHQ6aWYobj09NDV8fDk3PD1uJiZuPD0xMjJ8fDY1PD1uJiZuPD05MCl7LS1lLm9mZnNldCx0PTIyO2JyZWFrfWVsc2UgaWYobj09NDApe3Q9MjM7YnJlYWt9dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5uZXh0LjIiKSkpKX1icmVhaztjYXNlIDkyOmlmKHQ9MTAsZS5vZmZzZXQ+PWUucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5uZXh0LjEiKSkpKTtlLmNoYXJkYXRhPUl0KGUucmVnZXgsZS5vZmZzZXQrKyk7YnJlYWs7ZGVmYXVsdDp0PTB9ZS5uZXh0dG9rZW49dH1mdW5jdGlvbiBvSW4oZSxuLHIpe3ZhciB0LG8saTtpZihlLm9wdGlvbnNfMD1yLGUub2Zmc2V0PTAsZS5jb250ZXh0PTAsZS5wYXJlbm51bWJlcj0xLGUucmVnZXg9biwoZS5vcHRpb25zXzAmMTYpPT0xNiYmKGUucmVnZXg9c0luKGUucmVnZXgpKSxlLnJlZ2V4bGVuPWUucmVnZXgubGVuZ3RoLFduKGUpLGk9RmQoZSksZS5vZmZzZXQhPWUucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wYXJzZS4xIikpKSk7aWYoZS5yZWZlcmVuY2VzKXtmb3IodD0wO3Q8ZS5yZWZlcmVuY2VzLmFycmF5TGlzdC5hcnJheS5sZW5ndGg7dCsrKWlmKG89YShNMShlLnJlZmVyZW5jZXMsdCksNTkyKSxlLnBhcmVubnVtYmVyPD1vLnJlZk51bWJlcil0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnBhcnNlLjIiKSkpKTtlLnJlZmVyZW5jZXMuYXJyYXlMaXN0LmFycmF5Lmxlbmd0aD0wfXJldHVybiBpfWZ1bmN0aW9uIGlJbihlKXt2YXIgbixyLHQsbyxpO3N3aXRjaChuPWUubmV4dHRva2VuLGk9bnVsbCxuKXtjYXNlIDY6cmV0dXJuIGUucHJvY2Vzc1BhcmVuKCk7Y2FzZSAxMzpyZXR1cm4gZS5wcm9jZXNzUGFyZW4yKCk7Y2FzZSAyMzpyZXR1cm4gZS5wcm9jZXNzQ29uZGl0aW9uKCk7Y2FzZSAyMjpyZXR1cm4gZS5wcm9jZXNzTW9kaWZpZXJzKCk7Y2FzZSAxODpyZXR1cm4gZS5wcm9jZXNzSW5kZXBlbmRlbnQoKTtjYXNlIDg6V24oZSksaT0oVm4oKSxGb2UpO2JyZWFrO2Nhc2UgOTpyZXR1cm4gZS5wYXJzZUNoYXJhY3RlckNsYXNzKCEwKTtjYXNlIDE5OnJldHVybiBlLnBhcnNlU2V0T3BlcmF0aW9ucygpO2Nhc2UgMTA6c3dpdGNoKGUuY2hhcmRhdGEpe2Nhc2UgMTAwOmNhc2UgNjg6Y2FzZSAxMTk6Y2FzZSA4NzpjYXNlIDExNTpjYXNlIDgzOnJldHVybiBpPWUuZ2V0VG9rZW5Gb3JTaG9ydGhhbmQoZS5jaGFyZGF0YSksV24oZSksaTtjYXNlIDEwMTpjYXNlIDEwMjpjYXNlIDExMDpjYXNlIDExNDpjYXNlIDExNjpjYXNlIDExNzpjYXNlIDExODpjYXNlIDEyMDpyPWUuZGVjb2RlRXNjYXBlZCgpLHI8RnQ/aT0oVm4oKSxWbigpLG5ldyBxdSgwLHIpKTppPV9ZZShrb2UocikpO2JyZWFrO2Nhc2UgOTk6cmV0dXJuIGUucHJvY2Vzc0JhY2tzb2xpZHVzX2MoKTtjYXNlIDY3OnJldHVybiBlLnByb2Nlc3NCYWNrc29saWR1c19DKCk7Y2FzZSAxMDU6cmV0dXJuIGUucHJvY2Vzc0JhY2tzb2xpZHVzX2koKTtjYXNlIDczOnJldHVybiBlLnByb2Nlc3NCYWNrc29saWR1c19JKCk7Y2FzZSAxMDM6cmV0dXJuIGUucHJvY2Vzc0JhY2tzb2xpZHVzX2coKTtjYXNlIDg4OnJldHVybiBlLnByb2Nlc3NCYWNrc29saWR1c19YKCk7Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6cmV0dXJuIGUucHJvY2Vzc0JhY2tyZWZlcmVuY2UoKTtjYXNlIDgwOmNhc2UgMTEyOmlmKGk9UG9lKGUsZS5jaGFyZGF0YSksIWkpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5hdG9tLjUiKSkpKTticmVhaztkZWZhdWx0Omk9dVllKGUuY2hhcmRhdGEpfVduKGUpO2JyZWFrO2Nhc2UgMDppZihlLmNoYXJkYXRhPT05M3x8ZS5jaGFyZGF0YT09MTIzfHxlLmNoYXJkYXRhPT0xMjUpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5hdG9tLjQiKSkpKTtpPXVZZShlLmNoYXJkYXRhKSx0PWUuY2hhcmRhdGEsV24oZSksKHQmNjQ1MTIpPT1LUyYmZS5uZXh0dG9rZW49PTAmJihlLmNoYXJkYXRhJjY0NTEyKT09NTYzMjAmJihvPUIoZmwsWHMsMjgsMiwxNSwxKSxvWzBdPXQmenIsb1sxXT1lLmNoYXJkYXRhJnpyLGk9a0YoX1llKGl1KG8sMCxvLmxlbmd0aCkpLDApLFduKGUpKTticmVhaztkZWZhdWx0OnRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuYXRvbS40IikpKSl9cmV0dXJuIGl9ZnVuY3Rpb24geG9lKGUpe3ZhciBuLHIsdCxvLGk7c3dpdGNoKG49ZS5uZXh0dG9rZW4sbil7Y2FzZSAxMTpyZXR1cm4gZS5wcm9jZXNzQ2FyZXQoKTtjYXNlIDEyOnJldHVybiBlLnByb2Nlc3NEb2xsYXIoKTtjYXNlIDE0OnJldHVybiBlLnByb2Nlc3NMb29rYWhlYWQoKTtjYXNlIDE1OnJldHVybiBlLnByb2Nlc3NOZWdhdGl2ZWxvb2thaGVhZCgpO2Nhc2UgMTY6cmV0dXJuIGUucHJvY2Vzc0xvb2tiZWhpbmQoKTtjYXNlIDE3OnJldHVybiBlLnByb2Nlc3NOZWdhdGl2ZWxvb2tiZWhpbmQoKTtjYXNlIDIxOnJldHVybiBXbihlKSxWbigpLFZuKCksRFM7Y2FzZSAxMDpzd2l0Y2goZS5jaGFyZGF0YSl7Y2FzZSA2NTpyZXR1cm4gZS5wcm9jZXNzQmFja3NvbGlkdXNfQSgpO2Nhc2UgOTA6cmV0dXJuIGUucHJvY2Vzc0JhY2tzb2xpZHVzX1ooKTtjYXNlIDEyMjpyZXR1cm4gZS5wcm9jZXNzQmFja3NvbGlkdXNfeigpO2Nhc2UgOTg6cmV0dXJuIGUucHJvY2Vzc0JhY2tzb2xpZHVzX2IoKTtjYXNlIDY2OnJldHVybiBlLnByb2Nlc3NCYWNrc29saWR1c19CKCk7Y2FzZSA2MDpyZXR1cm4gZS5wcm9jZXNzQmFja3NvbGlkdXNfbHQoKTtjYXNlIDYyOnJldHVybiBlLnByb2Nlc3NCYWNrc29saWR1c19ndCgpfX1zd2l0Y2goaT1pSW4oZSksbj1lLm5leHR0b2tlbixuKXtjYXNlIDM6cmV0dXJuIGUucHJvY2Vzc1N0YXIoaSk7Y2FzZSA0OnJldHVybiBlLnByb2Nlc3NQbHVzKGkpO2Nhc2UgNTpyZXR1cm4gZS5wcm9jZXNzUXVlc3Rpb24oaSk7Y2FzZSAwOmlmKGUuY2hhcmRhdGE9PTEyMyYmZS5vZmZzZXQ8ZS5yZWdleGxlbil7aWYobz1lLm9mZnNldCx0PTAscj0tMSwobj1JdChlLnJlZ2V4LG8rKykpPj00OCYmbjw9NTcpe2Zvcih0PW4tNDg7bzxlLnJlZ2V4bGVuJiYobj1JdChlLnJlZ2V4LG8rKykpPj00OCYmbjw9NTc7KWlmKHQ9dCoxMCtuLTQ4LHQ8MCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnF1YW50aWZpZXIuNSIpKSkpfWVsc2UgdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5xdWFudGlmaWVyLjEiKSkpKTtpZihyPXQsbj09NDQpe2lmKG8+PWUucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5xdWFudGlmaWVyLjMiKSkpKTtpZigobj1JdChlLnJlZ2V4LG8rKykpPj00OCYmbjw9NTcpe2ZvcihyPW4tNDg7bzxlLnJlZ2V4bGVuJiYobj1JdChlLnJlZ2V4LG8rKykpPj00OCYmbjw9NTc7KWlmKHI9cioxMCtuLTQ4LHI8MCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnF1YW50aWZpZXIuNSIpKSkpO2lmKHQ+cil0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnF1YW50aWZpZXIuNCIpKSkpfWVsc2Ugcj0tMX1pZihuIT0xMjUpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5xdWFudGlmaWVyLjIiKSkpKTtlLmNoZWNrUXVlc3Rpb24obyk/KGk9KFZuKCksVm4oKSxuZXcgZnAoOSxpKSksZS5vZmZzZXQ9bysxKTooaT0oVm4oKSxWbigpLG5ldyBmcCgzLGkpKSxlLm9mZnNldD1vKSxpLnNldE1pbih0KSxpLnNldE1heChyKSxXbihlKX19cmV0dXJuIGl9ZnVuY3Rpb24gRmQoZSl7dmFyIG4scjtmb3Iocj1hWWUoZSksbj1udWxsO2UubmV4dHRva2VuPT0yOylXbihlKSxufHwobj0oVm4oKSxWbigpLG5ldyAkUygyKSksZDEobixyKSxyPW4pLHIuYWRkQ2hpbGQoYVllKGUpKTtyZXR1cm4gcn1mdW5jdGlvbiBhWWUoZSl7dmFyIG4scix0O2lmKG49ZS5uZXh0dG9rZW4sbj09Mnx8bj09N3x8bj09MSlyZXR1cm4gVm4oKSxWbigpLERTO2Zvcih0PXhvZShlKSxyPW51bGw7KG49ZS5uZXh0dG9rZW4pIT0yJiZuIT03JiZuIT0xOylyfHwocj0oVm4oKSxWbigpLG5ldyAkUygxKSksZDEocix0KSx0PXIpLGQxKHIseG9lKGUpKTtyZXR1cm4gdH1mdW5jdGlvbiBQb2UoZSxuKXt2YXIgcix0LG8saTtpZihXbihlKSxlLm5leHR0b2tlbiE9MHx8ZS5jaGFyZGF0YSE9MTIzKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuYXRvbS4yIikpKSk7aWYoaT1uPT0xMTIsdD1lLm9mZnNldCxyPXN5KGUucmVnZXgsMTI1LHQpLHI8MCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmF0b20uMyIpKSkpO3JldHVybiBvPVlhKGUucmVnZXgsdCxyKSxlLm9mZnNldD1yKzEsZFllKG8saSwoZS5vcHRpb25zXzAmNTEyKT09NTEyKX1mdW5jdGlvbiBOb2UoKXt9ZnVuY3Rpb24gXzEoZSl7cmV0dXJuIGU8NDh8fGU+MTAyPy0xOmU8PTU3P2UtNDg6ZTw2NT8tMTplPD03MD9lLTY1KzEwOmU8OTc/LTE6ZS05NysxMH1wKDgzNiwxLHt9LE5vZSksbC5jaGVja1F1ZXN0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiBuPHRoaXMucmVnZXhsZW4mJkl0KHRoaXMucmVnZXgsbik9PTYzfSxsLmRlY29kZUVzY2FwZWQ9ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpO2lmKHRoaXMubmV4dHRva2VuIT0xMCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLm5leHQuMSIpKSkpO3N3aXRjaChuPXRoaXMuY2hhcmRhdGEsbil7Y2FzZSAxMDE6bj0yNzticmVhaztjYXNlIDEwMjpuPTEyO2JyZWFrO2Nhc2UgMTEwOm49MTA7YnJlYWs7Y2FzZSAxMTQ6bj0xMzticmVhaztjYXNlIDExNjpuPTk7YnJlYWs7Y2FzZSAxMjA6aWYoV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZih0aGlzLmNoYXJkYXRhPT0xMjMpe2k9MCx0PTA7ZG97aWYoV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZigoaT1fMSh0aGlzLmNoYXJkYXRhKSk8MClicmVhaztpZih0PnQqMTYpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjIiKSkpKTt0PXQqMTYraX13aGlsZSghMCk7aWYodGhpcy5jaGFyZGF0YSE9MTI1KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwZS4zIikpKSk7aWYodD5XbSl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmRlc2NhcGUuNCIpKSkpO249dH1lbHNle2lmKGk9MCx0aGlzLm5leHR0b2tlbiE9MHx8KGk9XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZih0PWksV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTB8fChpPV8xKHRoaXMuY2hhcmRhdGEpKTwwKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwZS4xIikpKSk7dD10KjE2K2ksbj10fWJyZWFrO2Nhc2UgMTE3OmlmKG89MCxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPW8sV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTB8fChvPV8xKHRoaXMuY2hhcmRhdGEpKTwwKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwZS4xIikpKSk7aWYocj1yKjE2K28sV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTB8fChvPV8xKHRoaXMuY2hhcmRhdGEpKTwwKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwZS4xIikpKSk7aWYocj1yKjE2K28sV24odGhpcyksdGhpcy5uZXh0dG9rZW4hPTB8fChvPV8xKHRoaXMuY2hhcmRhdGEpKTwwKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwZS4xIikpKSk7cj1yKjE2K28sbj1yO2JyZWFrO2Nhc2UgMTE4OmlmKFduKHRoaXMpLHRoaXMubmV4dHRva2VuIT0wfHwobz1fMSh0aGlzLmNoYXJkYXRhKSk8MCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmRlc2NhcGUuMSIpKSkpO2lmKHI9byxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPXIqMTYrbyxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPXIqMTYrbyxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPXIqMTYrbyxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPXIqMTYrbyxXbih0aGlzKSx0aGlzLm5leHR0b2tlbiE9MHx8KG89XzEodGhpcy5jaGFyZGF0YSkpPDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjEiKSkpKTtpZihyPXIqMTYrbyxyPldtKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZGVzY2FwcGUuNCIpKSkpO249cjticmVhaztjYXNlIDY1OmNhc2UgOTA6Y2FzZSAxMjI6dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5kZXNjYXBlLjUiKSkpKX1yZXR1cm4gbn0sbC5nZXRUb2tlbkZvclNob3J0aGFuZD1mdW5jdGlvbihuKXt2YXIgcix0O3N3aXRjaChuKXtjYXNlIDEwMDp0PSh0aGlzLm9wdGlvbnNfMCYzMik9PTMyP2xfKCJOZCIsITApOihWbigpLG42KTticmVhaztjYXNlIDY4OnQ9KHRoaXMub3B0aW9uc18wJjMyKT09MzI/bF8oIk5kIiwhMSk6KFZuKCksQm9lKTticmVhaztjYXNlIDExOTp0PSh0aGlzLm9wdGlvbnNfMCYzMik9PTMyP2xfKCJJc1dvcmQiLCEwKTooVm4oKSxtMik7YnJlYWs7Y2FzZSA4Nzp0PSh0aGlzLm9wdGlvbnNfMCYzMik9PTMyP2xfKCJJc1dvcmQiLCExKTooVm4oKSxIb2UpO2JyZWFrO2Nhc2UgMTE1OnQ9KHRoaXMub3B0aW9uc18wJjMyKT09MzI/bF8oIklzU3BhY2UiLCEwKTooVm4oKSxPbSk7YnJlYWs7Y2FzZSA4Mzp0PSh0aGlzLm9wdGlvbnNfMCYzMik9PTMyP2xfKCJJc1NwYWNlIiwhMSk6KFZuKCksR29lKTticmVhaztkZWZhdWx0OnRocm93IGIobmV3IElvKChyPW4sIkludGVybmFsIEVycm9yOiBzaG9ydGhhbmRzOiBcXHUiK3IudG9TdHJpbmcoMTYpKSkpfXJldHVybiB0fSxsLnBhcnNlQ2hhcmFjdGVyQ2xhc3M9ZnVuY3Rpb24obil7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtO2Zvcih0aGlzLmNvbnRleHQ9MSxXbih0aGlzKSxyPW51bGwsdGhpcy5uZXh0dG9rZW49PTAmJnRoaXMuY2hhcmRhdGE9PTk0PyhXbih0aGlzKSxuP2Y9KFZuKCksVm4oKSxuZXcgVWEoNSkpOihyPShWbigpLFZuKCksbmV3IFVhKDQpKSx1aShyLDAsV20pLGY9bmV3IFVhKDQpKSk6Zj0oVm4oKSxWbigpLG5ldyBVYSg0KSksaT0hMDsobT10aGlzLm5leHR0b2tlbikhPTEmJiEobT09MCYmdGhpcy5jaGFyZGF0YT09OTMmJiFpKTspe2lmKGk9ITEsdD10aGlzLmNoYXJkYXRhLG89ITEsbT09MTApc3dpdGNoKHQpe2Nhc2UgMTAwOmNhc2UgNjg6Y2FzZSAxMTk6Y2FzZSA4NzpjYXNlIDExNTpjYXNlIDgzOl9wKGYsdGhpcy5nZXRUb2tlbkZvclNob3J0aGFuZCh0KSksbz0hMDticmVhaztjYXNlIDEwNTpjYXNlIDczOmNhc2UgOTk6Y2FzZSA2Nzp0PXRoaXMucHJvY2Vzc0NJaW5DaGFyYWN0ZXJDbGFzcyhmLHQpLHQ8MCYmKG89ITApO2JyZWFrO2Nhc2UgMTEyOmNhc2UgODA6aWYoaD1Qb2UodGhpcyx0KSwhaCl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmF0b20uNSIpKSkpO19wKGYsaCksbz0hMDticmVhaztkZWZhdWx0OnQ9dGhpcy5kZWNvZGVFc2NhcGVkKCl9ZWxzZSBpZihtPT0yMCl7aWYodT1zeSh0aGlzLnJlZ2V4LDU4LHRoaXMub2Zmc2V0KSx1PDApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5jYy4xIikpKSk7aWYoYz0hMCxJdCh0aGlzLnJlZ2V4LHRoaXMub2Zmc2V0KT09OTQmJigrK3RoaXMub2Zmc2V0LGM9ITEpLHM9WWEodGhpcy5yZWdleCx0aGlzLm9mZnNldCx1KSxfPWRZZShzLGMsKHRoaXMub3B0aW9uc18wJjUxMik9PTUxMiksIV8pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5jYy4zIikpKSk7aWYoX3AoZixfKSxvPSEwLHUrMT49dGhpcy5yZWdleGxlbnx8SXQodGhpcy5yZWdleCx1KzEpIT05Myl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjEiKSkpKTt0aGlzLm9mZnNldD11KzJ9aWYoV24odGhpcyksIW8paWYodGhpcy5uZXh0dG9rZW4hPTB8fHRoaXMuY2hhcmRhdGEhPTQ1KXVpKGYsdCx0KTtlbHNle2lmKFduKHRoaXMpLChtPXRoaXMubmV4dHRva2VuKT09MSl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjIiKSkpKTttPT0wJiZ0aGlzLmNoYXJkYXRhPT05Mz8odWkoZix0LHQpLHVpKGYsNDUsNDUpKTooZD10aGlzLmNoYXJkYXRhLG09PTEwJiYoZD10aGlzLmRlY29kZUVzY2FwZWQoKSksV24odGhpcyksdWkoZix0LGQpKX0odGhpcy5vcHRpb25zXzAmTGwpPT1MbCYmdGhpcy5uZXh0dG9rZW49PTAmJnRoaXMuY2hhcmRhdGE9PTQ0JiZXbih0aGlzKX1pZih0aGlzLm5leHR0b2tlbj09MSl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjIiKSkpKTtyZXR1cm4gciYmKHpTKHIsZiksZj1yKSxLZyhmKSxGUyhmKSx0aGlzLmNvbnRleHQ9MCxXbih0aGlzKSxmfSxsLnBhcnNlU2V0T3BlcmF0aW9ucz1mdW5jdGlvbigpe3ZhciBuLHIsdCxvO2Zvcih0PXRoaXMucGFyc2VDaGFyYWN0ZXJDbGFzcyghMSk7KG89dGhpcy5uZXh0dG9rZW4pIT03OylpZihuPXRoaXMuY2hhcmRhdGEsbz09MCYmKG49PTQ1fHxuPT0zOCl8fG89PTQpe2lmKFduKHRoaXMpLHRoaXMubmV4dHRva2VuIT05KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIub3BlLjEiKSkpKTtpZihyPXRoaXMucGFyc2VDaGFyYWN0ZXJDbGFzcyghMSksbz09NClfcCh0LHIpO2Vsc2UgaWYobj09NDUpelModCxyKTtlbHNlIGlmKG49PTM4KXZZZSh0LHIpO2Vsc2UgdGhyb3cgYihuZXcgSW8oIkFTU0VSVCIpKX1lbHNlIHRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIub3BlLjIiKSkpKTtyZXR1cm4gV24odGhpcyksdH0sbC5wcm9jZXNzQmFja3JlZmVyZW5jZT1mdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJuIG49dGhpcy5jaGFyZGF0YS00OCxyPShWbigpLFZuKCksbmV3IFJGKDEyLG51bGwsbikpLCF0aGlzLnJlZmVyZW5jZXMmJih0aGlzLnJlZmVyZW5jZXM9bmV3IF94KSxjeCh0aGlzLnJlZmVyZW5jZXMsbmV3IFVvZShuKSksV24odGhpcykscn0sbC5wcm9jZXNzQmFja3NvbGlkdXNfQT1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxWbigpLGdZZX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfQj1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxWbigpLHBZZX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfQz1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX0k9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NCYWNrc29saWR1c19YPWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLGNJbigpfSxsLnByb2Nlc3NCYWNrc29saWR1c19aPWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCksbVllfSxsLnByb2Nlc3NCYWNrc29saWR1c19iPWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCksd1llfSxsLnByb2Nlc3NCYWNrc29saWR1c19jPWZ1bmN0aW9uKCl7dmFyIG47aWYodGhpcy5vZmZzZXQ+PXRoaXMucmVnZXhsZW58fCgobj1JdCh0aGlzLnJlZ2V4LHRoaXMub2Zmc2V0KyspKSY2NTUwNCkhPTY0KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuYXRvbS4xIikpKSk7cmV0dXJuIFduKHRoaXMpLFZuKCksVm4oKSxuZXcgcXUoMCxuLTY0KX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfZz1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxfSW4oKX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfZ3Q9ZnVuY3Rpb24oKXtyZXR1cm4gV24odGhpcyksVm4oKSxFWWV9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX2k9ZnVuY3Rpb24oKXt2YXIgbjtyZXR1cm4gbj0oVm4oKSxWbigpLG5ldyBxdSgwLDEwNSkpLFduKHRoaXMpLG59LGwucHJvY2Vzc0JhY2tzb2xpZHVzX2x0PWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCkseVllfSxsLnByb2Nlc3NCYWNrc29saWR1c196PWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCksaFllfSxsLnByb2Nlc3NDSWluQ2hhcmFjdGVyQ2xhc3M9ZnVuY3Rpb24obixyKXtyZXR1cm4gdGhpcy5kZWNvZGVFc2NhcGVkKCl9LGwucHJvY2Vzc0NhcmV0PWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCksem9lfSxsLnByb2Nlc3NDb25kaXRpb249ZnVuY3Rpb24oKXt2YXIgbixyLHQsbyxpO2lmKHRoaXMub2Zmc2V0KzE+PXRoaXMucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5mYWN0b3IuNCIpKSkpO2lmKG89LTEscj1udWxsLG49SXQodGhpcy5yZWdleCx0aGlzLm9mZnNldCksNDk8PW4mJm48PTU3KXtpZihvPW4tNDgsIXRoaXMucmVmZXJlbmNlcyYmKHRoaXMucmVmZXJlbmNlcz1uZXcgX3gpLGN4KHRoaXMucmVmZXJlbmNlcyxuZXcgVW9lKG8pKSwrK3RoaXMub2Zmc2V0LEl0KHRoaXMucmVnZXgsdGhpcy5vZmZzZXQpIT00MSl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmZhY3Rvci4xIikpKSk7Kyt0aGlzLm9mZnNldH1lbHNlIHN3aXRjaChuPT02MyYmLS10aGlzLm9mZnNldCxXbih0aGlzKSxyPXhvZSh0aGlzKSxyLnR5cGVfMCl7Y2FzZSAyMDpjYXNlIDIxOmNhc2UgMjI6Y2FzZSAyMzpicmVhaztjYXNlIDg6aWYodGhpcy5uZXh0dG9rZW4hPTcpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5mYWN0b3IuMSIpKSkpO2JyZWFrO2RlZmF1bHQ6dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5mYWN0b3IuNSIpKSkpfWlmKFduKHRoaXMpLGk9RmQodGhpcyksdD1udWxsLGkudHlwZV8wPT0yKXtpZihpLnNpemVfMigpIT0yKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjYiKSkpKTt0PWkuZ2V0Q2hpbGQoMSksaT1pLmdldENoaWxkKDApfWlmKHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtyZXR1cm4gV24odGhpcyksVm4oKSxWbigpLG5ldyBDWWUobyxyLGksdCl9LGwucHJvY2Vzc0RvbGxhcj1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxWbigpLCRvZX0sbC5wcm9jZXNzSW5kZXBlbmRlbnQ9ZnVuY3Rpb24oKXt2YXIgbjtpZihXbih0aGlzKSxuPWU2KDI0LEZkKHRoaXMpKSx0aGlzLm5leHR0b2tlbiE9Nyl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmZhY3Rvci4xIikpKSk7cmV0dXJuIFduKHRoaXMpLG59LGwucHJvY2Vzc0xvb2thaGVhZD1mdW5jdGlvbigpe3ZhciBuO2lmKFduKHRoaXMpLG49ZTYoMjAsRmQodGhpcykpLHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtyZXR1cm4gV24odGhpcyksbn0sbC5wcm9jZXNzTG9va2JlaGluZD1mdW5jdGlvbigpe3ZhciBuO2lmKFduKHRoaXMpLG49ZTYoMjIsRmQodGhpcykpLHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtyZXR1cm4gV24odGhpcyksbn0sbC5wcm9jZXNzTW9kaWZpZXJzPWZ1bmN0aW9uKCl7dmFyIG4scix0LG8saTtmb3Iobj0wLHQ9MCxyPS0xO3RoaXMub2Zmc2V0PHRoaXMucmVnZXhsZW4mJihyPUl0KHRoaXMucmVnZXgsdGhpcy5vZmZzZXQpLGk9T29lKHIpLGkhPTApOylufD1pLCsrdGhpcy5vZmZzZXQ7aWYodGhpcy5vZmZzZXQ+PXRoaXMucmVnZXhsZW4pdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5mYWN0b3IuMiIpKSkpO2lmKHI9PTQ1KXtmb3IoKyt0aGlzLm9mZnNldDt0aGlzLm9mZnNldDx0aGlzLnJlZ2V4bGVuJiYocj1JdCh0aGlzLnJlZ2V4LHRoaXMub2Zmc2V0KSxpPU9vZShyKSxpIT0wKTspdHw9aSwrK3RoaXMub2Zmc2V0O2lmKHRoaXMub2Zmc2V0Pj10aGlzLnJlZ2V4bGVuKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjIiKSkpKX1pZihyPT01OCl7aWYoKyt0aGlzLm9mZnNldCxXbih0aGlzKSxvPWNZZShGZCh0aGlzKSxuLHQpLHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtXbih0aGlzKX1lbHNlIGlmKHI9PTQxKSsrdGhpcy5vZmZzZXQsV24odGhpcyksbz1jWWUoRmQodGhpcyksbix0KTtlbHNlIHRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjMiKSkpKTtyZXR1cm4gb30sbC5wcm9jZXNzTmVnYXRpdmVsb29rYWhlYWQ9ZnVuY3Rpb24oKXt2YXIgbjtpZihXbih0aGlzKSxuPWU2KDIxLEZkKHRoaXMpKSx0aGlzLm5leHR0b2tlbiE9Nyl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmZhY3Rvci4xIikpKSk7cmV0dXJuIFduKHRoaXMpLG59LGwucHJvY2Vzc05lZ2F0aXZlbG9va2JlaGluZD1mdW5jdGlvbigpe3ZhciBuO2lmKFduKHRoaXMpLG49ZTYoMjMsRmQodGhpcykpLHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtyZXR1cm4gV24odGhpcyksbn0sbC5wcm9jZXNzUGFyZW49ZnVuY3Rpb24oKXt2YXIgbixyO2lmKFduKHRoaXMpLG49dGhpcy5wYXJlbm51bWJlcisrLHI9a0YoRmQodGhpcyksbiksdGhpcy5uZXh0dG9rZW4hPTcpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5mYWN0b3IuMSIpKSkpO3JldHVybiBXbih0aGlzKSxyfSxsLnByb2Nlc3NQYXJlbjI9ZnVuY3Rpb24oKXt2YXIgbjtpZihXbih0aGlzKSxuPWtGKEZkKHRoaXMpLDApLHRoaXMubmV4dHRva2VuIT03KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuZmFjdG9yLjEiKSkpKTtyZXR1cm4gV24odGhpcyksbn0sbC5wcm9jZXNzUGx1cz1mdW5jdGlvbihuKXtyZXR1cm4gV24odGhpcyksdGhpcy5uZXh0dG9rZW49PTU/KFduKHRoaXMpLFFMKG4sKFZuKCksVm4oKSxuZXcgZnAoOSxuKSkpKTpRTChuLChWbigpLFZuKCksbmV3IGZwKDMsbikpKX0sbC5wcm9jZXNzUXVlc3Rpb249ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIFduKHRoaXMpLHI9KFZuKCksVm4oKSxuZXcgJFMoMikpLHRoaXMubmV4dHRva2VuPT01PyhXbih0aGlzKSxkMShyLERTKSxkMShyLG4pKTooZDEocixuKSxkMShyLERTKSkscn0sbC5wcm9jZXNzU3Rhcj1mdW5jdGlvbihuKXtyZXR1cm4gV24odGhpcyksdGhpcy5uZXh0dG9rZW49PTU/KFduKHRoaXMpLFZuKCksVm4oKSxuZXcgZnAoOSxuKSk6KFZuKCksVm4oKSxuZXcgZnAoMyxuKSl9LGwuY2hhcmRhdGE9MCxsLmNvbnRleHQ9MCxsLm5leHR0b2tlbj0wLGwub2Zmc2V0PTAsbC5vcHRpb25zXzA9MCxsLnBhcmVubnVtYmVyPTEsbC5yZWZlcmVuY2VzPW51bGwsbC5yZWdleGxlbj0wLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbnRlcm5hbCIsIlJlZ0V4L1JlZ2V4UGFyc2VyIiw4MzYpO2Z1bmN0aW9uIEFvZShlKXt2YXIgbjtpZihlLm5leHR0b2tlbiE9MTApdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5uZXh0LjEiKSkpKTtzd2l0Y2gobj1lLmNoYXJkYXRhLG4pe2Nhc2UgMTEwOm49MTA7YnJlYWs7Y2FzZSAxMTQ6bj0xMzticmVhaztjYXNlIDExNjpuPTk7YnJlYWs7Y2FzZSA5MjpjYXNlIDEyNDpjYXNlIDQ2OmNhc2UgOTQ6Y2FzZSA0NTpjYXNlIDYzOmNhc2UgNDI6Y2FzZSA0MzpjYXNlIDEyMzpjYXNlIDEyNTpjYXNlIDQwOmNhc2UgNDE6Y2FzZSA5MTpjYXNlIDkzOmJyZWFrO2RlZmF1bHQ6dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wcm9jZXNzLjEiKSkpKX1yZXR1cm4gbn1mdW5jdGlvbiBwMihlKXt2YXIgbjtzd2l0Y2goZSl7Y2FzZSAxMDA6cmV0dXJuIHFnKCJ4bWw6aXNEaWdpdCIsITApO2Nhc2UgNjg6cmV0dXJuIHFnKCJ4bWw6aXNEaWdpdCIsITEpO2Nhc2UgMTE5OnJldHVybiBxZygieG1sOmlzV29yZCIsITApO2Nhc2UgODc6cmV0dXJuIHFnKCJ4bWw6aXNXb3JkIiwhMSk7Y2FzZSAxMTU6cmV0dXJuIHFnKCJ4bWw6aXNTcGFjZSIsITApO2Nhc2UgODM6cmV0dXJuIHFnKCJ4bWw6aXNTcGFjZSIsITEpO2Nhc2UgOTk6cmV0dXJuIHFnKCJ4bWw6aXNOYW1lQ2hhciIsITApO2Nhc2UgNjc6cmV0dXJuIHFnKCJ4bWw6aXNOYW1lQ2hhciIsITEpO2Nhc2UgMTA1OnJldHVybiBxZygieG1sOmlzSW5pdGlhbE5hbWVDaGFyIiwhMCk7Y2FzZSA3MzpyZXR1cm4gcWcoInhtbDppc0luaXRpYWxOYW1lQ2hhciIsITEpO2RlZmF1bHQ6dGhyb3cgYihuZXcgSW8oKG49ZSwiSW50ZXJuYWwgRXJyb3I6IHNob3J0aGFuZHM6IFxcdSIrbi50b1N0cmluZygxNikpKSl9fWZ1bmN0aW9uIGxZZShlKXt2YXIgbixyLHQsbyxpLHMsdSxjLF87Zm9yKGUuY29udGV4dD0xLFduKGUpLG49bnVsbCxlLm5leHR0b2tlbj09MCYmZS5jaGFyZGF0YT09OTQ/KFduKGUpLG49KFZuKCksVm4oKSxuZXcgVWEoNCkpLHVpKG4sMCxXbSksdT1uZXcgVWEoNCkpOnU9KFZuKCksVm4oKSxuZXcgVWEoNCkpLG89ITA7KF89ZS5uZXh0dG9rZW4pIT0xOyl7aWYoXz09MCYmZS5jaGFyZGF0YT09OTMmJiFvKXtuJiYoelMobix1KSx1PW4pO2JyZWFrfWlmKHI9ZS5jaGFyZGF0YSx0PSExLF89PTEwKXN3aXRjaChyKXtjYXNlIDEwMDpjYXNlIDY4OmNhc2UgMTE5OmNhc2UgODc6Y2FzZSAxMTU6Y2FzZSA4MzpfcCh1LHAyKHIpKSx0PSEwO2JyZWFrO2Nhc2UgMTA1OmNhc2UgNzM6Y2FzZSA5OTpjYXNlIDY3OnI9KF9wKHUscDIocikpLC0xKSxyPDAmJih0PSEwKTticmVhaztjYXNlIDExMjpjYXNlIDgwOmlmKGM9UG9lKGUsciksIWMpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5hdG9tLjUiKSkpKTtfcCh1LGMpLHQ9ITA7YnJlYWs7ZGVmYXVsdDpyPUFvZShlKX1lbHNlIGlmKF89PTI0JiYhbyl7aWYobiYmKHpTKG4sdSksdT1uKSxpPWxZZShlKSx6Uyh1LGkpLGUubmV4dHRva2VuIT0wfHxlLmNoYXJkYXRhIT05Myl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjUiKSkpKTticmVha31pZihXbihlKSwhdCl7aWYoXz09MCl7aWYocj09OTEpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5jYy42IikpKSk7aWYocj09OTMpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5jYy43IikpKSk7aWYocj09NDUmJiFvJiZlLmNoYXJkYXRhIT05Myl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjgiKSkpKX1pZihlLm5leHR0b2tlbiE9MHx8ZS5jaGFyZGF0YSE9NDV8fHI9PTQ1JiZvKXVpKHUscixyKTtlbHNle2lmKFduKGUpLChfPWUubmV4dHRva2VuKT09MSl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmNjLjIiKSkpKTtpZihfPT0wJiZlLmNoYXJkYXRhPT05Myl1aSh1LHIsciksdWkodSw0NSw0NSk7ZWxzZXtpZihfPT0wJiZlLmNoYXJkYXRhPT05M3x8Xz09MjQpdGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5jYy44IikpKSk7aWYocz1lLmNoYXJkYXRhLF89PTApe2lmKHM9PTkxKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuY2MuNiIpKSkpO2lmKHM9PTkzKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuY2MuNyIpKSkpO2lmKHM9PTQ1KXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuY2MuOCIpKSkpfWVsc2UgXz09MTAmJihzPUFvZShlKSk7aWYoV24oZSkscj5zKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIub3BlLjMiKSkpKTt1aSh1LHIscyl9fX1vPSExfWlmKGUubmV4dHRva2VuPT0xKXRocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIuY2MuMiIpKSkpO3JldHVybiBLZyh1KSxGUyh1KSxlLmNvbnRleHQ9MCxXbihlKSx1fWZ1bmN0aW9uIHNZZSgpe05vZS5jYWxsKHRoaXMpfWZ1bmN0aW9uIHFnKGUsbil7dmFyIHIsdDtyZXR1cm4gWWd8fChZZz1uZXcgc24sZzI9bmV3IHNuLHQ9KFZuKCksVm4oKSxuZXcgVWEoNCkpLHpiKHQsYAkKXHJcciAgYCksdG8oWWcsInhtbDppc1NwYWNlIix0KSx0byhnMiwieG1sOmlzU3BhY2UiLGRwKHQpKSx0PW5ldyBVYSg0KSx6Yih0LCIwOdmg2anbsNu54KWm4KWv4Kem4Kev4Kmm4Kmv4Kum4Kuv4K2m4K2v4K+n4K+v4LGm4LGv4LOm4LOv4LWm4LWv4LmQ4LmZ4LuQ4LuZ4Lyg4LypIiksdG8oWWcsInhtbDppc0RpZ2l0Iix0KSx0byhnMiwieG1sOmlzRGlnaXQiLGRwKHQpKSx0PW5ldyBVYSg0KSx6Yih0LCIwOdmg2anbsNu54KWm4KWv4Kem4Kev4Kmm4Kmv4Kum4Kuv4K2m4K2v4K+n4K+v4LGm4LGv4LOm4LOv4LWm4LWv4LmQ4LmZ4LuQ4LuZ4Lyg4LypIiksdG8oWWcsInhtbDppc0RpZ2l0Iix0KSx0byhnMiwieG1sOmlzRGlnaXQiLGRwKHQpKSx0PW5ldyBVYSg0KSx6Yih0LCJBWmF6w4DDlsOYw7bDuMSxxLTEvsWBxYjFisW+xoDHg8eNx7DHtMe1x7rIl8mQyqjKu8uBzobOhs6IzorOjM6Mzo7Ooc6jz47PkM+Wz5rPms+cz5zPns+ez6DPoM+iz7PQgdCM0I7Rj9GR0ZzRntKB0pDThNOH04jTi9OM05DTq9Ou07XTuNO51LHVltWZ1ZnVodaG15DXqtew17LYodi62YHZitmx2rfautq+24DbjtuQ25PblduV26XbpuCkheCkueCkveCkveClmOCloeCmheCmjOCmj+CmkOCmk+CmqOCmquCmsOCmsuCmsuCmtuCmueCnnOCnneCnn+CnoeCnsOCnseCoheCoiuCoj+CokOCok+CoqOCoquCosOCosuCos+CoteCotuCouOCoueCpmeCpnOCpnuCpnuCpsuCptOCqheCqi+CqjeCqjeCqj+CqkeCqk+CqqOCqquCqsOCqsuCqs+CqteCqueCqveCqveCroOCroOCsheCsjOCsj+CskOCsk+CsqOCsquCssOCssuCss+CstuCsueCsveCsveCtnOCtneCtn+CtoeCuheCuiuCujuCukOCukuCuleCumeCumuCunOCunOCunuCun+Cuo+CupOCuqOCuquCuruCuteCut+CuueCwheCwjOCwjuCwkOCwkuCwqOCwquCws+CwteCwueCxoOCxoeCyheCyjOCyjuCykOCykuCyqOCyquCys+CyteCyueCznuCznuCzoOCzoeC0heC0jOC0juC0kOC0kuC0qOC0quC0ueC1oOC1oeC4geC4ruC4sOC4sOC4suC4s+C5gOC5heC6geC6guC6hOC6hOC6h+C6iOC6iuC6iuC6jeC6jeC6lOC6l+C6meC6n+C6oeC6o+C6peC6peC6p+C6p+C6quC6q+C6reC6ruC6sOC6sOC6suC6s+C6veC6veC7gOC7hOC9gOC9h+C9ieC9qeGCoOGDheGDkOGDtuGEgOGEgOGEguGEg+GEheGEh+GEieGEieGEi+GEjOGEjuGEkuGEvOGEvOGEvuGEvuGFgOGFgOGFjOGFjOGFjuGFjuGFkOGFkOGFlOGFleGFmeGFmeGFn+GFoeGFo+GFo+GFpeGFpeGFp+GFp+GFqeGFqeGFreGFruGFsuGFs+GFteGFteGGnuGGnuGGqOGGqOGGq+GGq+GGruGGr+GGt+GGuOGGuuGGuuGGvOGHguGHq+GHq+GHsOGHsOGHueGHueG4gOG6m+G6oOG7ueG8gOG8leG8mOG8neG8oOG9heG9iOG9jeG9kOG9l+G9meG9meG9m+G9m+G9neG9neG9n+G9veG+gOG+tOG+tuG+vOG+vuG+vuG/guG/hOG/huG/jOG/kOG/k+G/luG/m+G/oOG/rOG/suG/tOG/tuG/vOKEpuKEpuKEquKEq+KEruKEruKGgOKGguOAh+OAh+OAoeOAqeOBgeOClOOCoeODuuOEheOErOS4gOm+peqwgO2eoyIpLF9wKHQsYShuaShZZywieG1sOmlzRGlnaXQiKSwxMjIpKSx0byhZZywieG1sOmlzV29yZCIsdCksdG8oZzIsInhtbDppc1dvcmQiLGRwKHQpKSx0PW5ldyBVYSg0KSx6Yih0LCItLjA6QVpfX2F6wrfCt8OAw5bDmMO2w7jEscS0xL7FgcWIxYrFvsaAx4PHjcewx7THtce6yJfJkMqoyrvLgcuQy5HMgM2FzaDNoc6GzorOjM6Mzo7Ooc6jz47PkM+Wz5rPms+cz5zPns+ez6DPoM+iz7PQgdCM0I7Rj9GR0ZzRntKB0oPShtKQ04TTh9OI04vTjNOQ06vTrtO107jTudSx1ZbVmdWZ1aHWhtaR1qHWo9a51rvWvda/1r/XgdeC14TXhNeQ16rXsNey2KHYutmA2ZLZoNmp2bDat9q62r7bgNuO25Dbk9uV26jbqtut27DbueCkgeCkg+CkheCkueCkvOCljeClkeCllOClmOClo+ClpuClr+CmgeCmg+CmheCmjOCmj+CmkOCmk+CmqOCmquCmsOCmsuCmsuCmtuCmueCmvOCmvOCmvuCnhOCnh+CniOCni+CnjeCnl+Cnl+CnnOCnneCnn+Cno+CnpuCnseCoguCoguCoheCoiuCoj+CokOCok+CoqOCoquCosOCosuCos+CoteCotuCouOCoueCovOCovOCovuCpguCph+CpiOCpi+CpjeCpmeCpnOCpnuCpnuCppuCptOCqgeCqg+CqheCqi+CqjeCqjeCqj+CqkeCqk+CqqOCqquCqsOCqsuCqs+CqteCqueCqvOCrheCrh+CrieCri+CrjeCroOCroOCrpuCrr+CsgeCsg+CsheCsjOCsj+CskOCsk+CsqOCsquCssOCssuCss+CstuCsueCsvOCtg+Cth+CtiOCti+CtjeCtluCtl+CtnOCtneCtn+CtoeCtpuCtr+CuguCug+CuheCuiuCujuCukOCukuCuleCumeCumuCunOCunOCunuCun+Cuo+CupOCuqOCuquCuruCuteCut+CuueCuvuCvguCvhuCviOCviuCvjeCvl+Cvl+Cvp+Cvr+CwgeCwg+CwheCwjOCwjuCwkOCwkuCwqOCwquCws+CwteCwueCwvuCxhOCxhuCxiOCxiuCxjeCxleCxluCxoOCxoeCxpuCxr+CyguCyg+CyheCyjOCyjuCykOCykuCyqOCyquCys+CyteCyueCyvuCzhOCzhuCziOCziuCzjeCzleCzluCznuCznuCzoOCzoeCzpuCzr+C0guC0g+C0heC0jOC0juC0kOC0kuC0qOC0quC0ueC0vuC1g+C1huC1iOC1iuC1jeC1l+C1l+C1oOC1oeC1puC1r+C4geC4ruC4sOC4uuC5gOC5juC5kOC5meC6geC6guC6hOC6hOC6h+C6iOC6iuC6iuC6jeC6jeC6lOC6l+C6meC6n+C6oeC6o+C6peC6peC6p+C6p+C6quC6q+C6reC6ruC6sOC6ueC6u+C6veC7gOC7hOC7huC7huC7iOC7jeC7kOC7meC8mOC8meC8oOC8qeC8teC8teC8t+C8t+C8ueC8ueC8vuC9h+C9ieC9qeC9seC+hOC+huC+i+C+kOC+leC+l+C+l+C+meC+reC+seC+t+C+ueC+ueGCoOGDheGDkOGDtuGEgOGEgOGEguGEg+GEheGEh+GEieGEieGEi+GEjOGEjuGEkuGEvOGEvOGEvuGEvuGFgOGFgOGFjOGFjOGFjuGFjuGFkOGFkOGFlOGFleGFmeGFmeGFn+GFoeGFo+GFo+GFpeGFpeGFp+GFp+GFqeGFqeGFreGFruGFsuGFs+GFteGFteGGnuGGnuGGqOGGqOGGq+GGq+GGruGGr+GGt+GGuOGGuuGGuuGGvOGHguGHq+GHq+GHsOGHsOGHueGHueG4gOG6m+G6oOG7ueG8gOG8leG8mOG8neG8oOG9heG9iOG9jeG9kOG9l+G9meG9meG9m+G9m+G9neG9neG9n+G9veG+gOG+tOG+tuG+vOG+vuG+vuG/guG/hOG/huG/jOG/kOG/k+G/luG/m+G/oOG/rOG/suG/tOG/tuG/vOKDkOKDnOKDoeKDoeKEpuKEpuKEquKEq+KEruKEruKGgOKGguOAheOAheOAh+OAh+OAoeOAr+OAseOAteOBgeOClOOCmeOCmuOCneOCnuOCoeODuuODvOODvuOEheOErOS4gOm+peqwgO2eoyIpLHRvKFlnLCJ4bWw6aXNOYW1lQ2hhciIsdCksdG8oZzIsInhtbDppc05hbWVDaGFyIixkcCh0KSksdD1uZXcgVWEoNCksemIodCwiQVphesOAw5bDmMO2w7jEscS0xL7FgcWIxYrFvsaAx4PHjcewx7THtce6yJfJkMqoyrvLgc6GzobOiM6KzozOjM6OzqHOo8+Oz5DPls+az5rPnM+cz57Pns+gz6DPos+z0IHQjNCO0Y/RkdGc0Z7SgdKQ04TTh9OI04vTjNOQ06vTrtO107jTudSx1ZbVmdWZ1aHWhteQ16rXsNey2KHYutmB2YrZsdq32rravtuA247bkNuT25Xbldul26bgpIXgpLngpL3gpL3gpZjgpaHgpoXgpozgpo/gppDgppPgpqjgpqrgprDgprLgprLgprbgprngp5zgp53gp5/gp6Hgp7Dgp7HgqIXgqIrgqI/gqJDgqJPgqKjgqKrgqLDgqLLgqLPgqLXgqLbgqLjgqLngqZngqZzgqZ7gqZ7gqbLgqbTgqoXgqovgqo3gqo3gqo/gqpHgqpPgqqjgqqrgqrDgqrLgqrPgqrXgqrngqr3gqr3gq6Dgq6DgrIXgrIzgrI/grJDgrJPgrKjgrKrgrLDgrLLgrLPgrLbgrLngrL3grL3grZzgrZ3grZ/graHgroXgrorgro7grpDgrpLgrpXgrpngrprgrpzgrpzgrp7grp/grqPgrqTgrqjgrqrgrq7grrXgrrfgrrngsIXgsIzgsI7gsJDgsJLgsKjgsKrgsLPgsLXgsLngsaDgsaHgsoXgsozgso7gspDgspLgsqjgsqrgsrPgsrXgsrngs57gs57gs6Dgs6HgtIXgtIzgtI7gtJDgtJLgtKjgtKrgtLngtaDgtaHguIHguK7guLDguLDguLLguLPguYDguYXguoHguoLguoTguoTguofguojguorguorguo3guo3gupTgupfgupngup/guqHguqPguqXguqXguqfguqfguqrguqvguq3guq7gurDgurDgurLgurPgur3gur3gu4Dgu4TgvYDgvYfgvYngvanhgqDhg4Xhg5Dhg7bhhIDhhIDhhILhhIPhhIXhhIfhhInhhInhhIvhhIzhhI7hhJLhhLzhhLzhhL7hhL7hhYDhhYDhhYzhhYzhhY7hhY7hhZDhhZDhhZThhZXhhZnhhZnhhZ/hhaHhhaPhhaPhhaXhhaXhhafhhafhhanhhanhha3hha7hhbLhhbPhhbXhhbXhhp7hhp7hhqjhhqjhhqvhhqvhhq7hhq/hhrfhhrjhhrrhhrrhhrzhh4Lhh6vhh6vhh7Dhh7Dhh7nhh7nhuIDhupvhuqDhu7nhvIDhvJXhvJjhvJ3hvKDhvYXhvYjhvY3hvZDhvZfhvZnhvZnhvZvhvZvhvZ3hvZ3hvZ/hvb3hvoDhvrThvrbhvrzhvr7hvr7hv4Lhv4Thv4bhv4zhv5Dhv5Phv5bhv5vhv6Dhv6zhv7Lhv7Thv7bhv7zihKbihKbihKrihKvihK7ihK7ihoDihoLjgIfjgIfjgKHjgKnjgYHjgpTjgqHjg7rjhIXjhKzkuIDpvqXqsIDtnqMiKSx1aSh0LDk1LDk1KSx1aSh0LDU4LDU4KSx0byhZZywieG1sOmlzSW5pdGlhbE5hbWVDaGFyIix0KSx0byhnMiwieG1sOmlzSW5pdGlhbE5hbWVDaGFyIixkcCh0KSkpLHI9YShuaShuP1lnOmcyLGUpLDEzOCkscn1mdW5jdGlvbiB6YihlLG4pe3ZhciByLHQ7Zm9yKHQ9bi5sZW5ndGgscj0wO3I8dDtyKz0yKXVpKGUsKEhlKHIsbi5sZW5ndGgpLG4uY2hhckNvZGVBdChyKSksKEhlKHIrMSxuLmxlbmd0aCksbi5jaGFyQ29kZUF0KHIrMSkpKX1wKDE5NDcsODM2LHt9LHNZZSksbC5jaGVja1F1ZXN0aW9uPWZ1bmN0aW9uKG4pe3JldHVybiExfSxsLmRlY29kZUVzY2FwZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gQW9lKHRoaXMpfSxsLmdldFRva2VuRm9yU2hvcnRoYW5kPWZ1bmN0aW9uKG4pe3JldHVybiBwMihuKX0sbC5wYXJzZUNoYXJhY3RlckNsYXNzPWZ1bmN0aW9uKG4pe3JldHVybiBsWWUodGhpcyl9LGwucGFyc2VTZXRPcGVyYXRpb25zPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wcm9jZXNzLjEiKSkpKX0sbC5wcm9jZXNzQmFja3JlZmVyZW5jZT1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX0E9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NCYWNrc29saWR1c19CPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wcm9jZXNzLjEiKSkpKX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfQz1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxwMig2Nyl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX0k9ZnVuY3Rpb24oKXtyZXR1cm4gV24odGhpcykscDIoNzMpfSxsLnByb2Nlc3NCYWNrc29saWR1c19YPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wcm9jZXNzLjEiKSkpKX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfWj1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX2I9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NCYWNrc29saWR1c19jPWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLHAyKDk5KX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfZz1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX2d0PWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcgUG4oQW4oKGJuKCksInBhcnNlci5wcm9jZXNzLjEiKSkpKX0sbC5wcm9jZXNzQmFja3NvbGlkdXNfaT1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxwMigxMDUpfSxsLnByb2Nlc3NCYWNrc29saWR1c19sdD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0JhY2tzb2xpZHVzX3o9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NDSWluQ2hhcmFjdGVyQ2xhc3M9ZnVuY3Rpb24obixyKXtyZXR1cm4gX3AobixwMihyKSksLTF9LGwucHJvY2Vzc0NhcmV0PWZ1bmN0aW9uKCl7cmV0dXJuIFduKHRoaXMpLFZuKCksVm4oKSxuZXcgcXUoMCw5NCl9LGwucHJvY2Vzc0NvbmRpdGlvbj1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0RvbGxhcj1mdW5jdGlvbigpe3JldHVybiBXbih0aGlzKSxWbigpLFZuKCksbmV3IHF1KDAsMzYpfSxsLnByb2Nlc3NJbmRlcGVuZGVudD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0xvb2thaGVhZD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc0xvb2tiZWhpbmQ9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NNb2RpZmllcnM9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLnByb2Nlc3MuMSIpKSkpfSxsLnByb2Nlc3NOZWdhdGl2ZWxvb2thaGVhZD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc05lZ2F0aXZlbG9va2JlaGluZD1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc1BhcmVuPWZ1bmN0aW9uKCl7dmFyIG47aWYoV24odGhpcyksbj1rRihGZCh0aGlzKSwwKSx0aGlzLm5leHR0b2tlbiE9Nyl0aHJvdyBiKG5ldyBQbihBbigoYm4oKSwicGFyc2VyLmZhY3Rvci4xIikpKSk7cmV0dXJuIFduKHRoaXMpLG59LGwucHJvY2Vzc1BhcmVuMj1mdW5jdGlvbigpe3Rocm93IGIobmV3IFBuKEFuKChibigpLCJwYXJzZXIucHJvY2Vzcy4xIikpKSl9LGwucHJvY2Vzc1BsdXM9ZnVuY3Rpb24obil7cmV0dXJuIFduKHRoaXMpLFFMKG4sKFZuKCksVm4oKSxuZXcgZnAoMyxuKSkpfSxsLnByb2Nlc3NRdWVzdGlvbj1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gV24odGhpcykscj0oVm4oKSxWbigpLG5ldyAkUygyKSksZDEocixuKSxkMShyLERTKSxyfSxsLnByb2Nlc3NTdGFyPWZ1bmN0aW9uKG4pe3JldHVybiBXbih0aGlzKSxWbigpLFZuKCksbmV3IGZwKDMsbil9O3ZhciBZZz1udWxsLGcyPW51bGw7Zygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmludGVybmFsIiwiUmVnRXgvUGFyc2VyRm9yWE1MU2NoZW1hIiwxOTQ3KTtmdW5jdGlvbiBMb2UoZSl7dmFyIG47cmV0dXJuIG49bmV3IEIyLGUmMjU2JiYobi5zdHJpbmcrPSJGIiksZSYxMjgmJihuLnN0cmluZys9IkgiKSxlJjUxMiYmKG4uc3RyaW5nKz0iWCIpLGUmMiYmKG4uc3RyaW5nKz0iaSIpLGUmOCYmKG4uc3RyaW5nKz0ibSIpLGUmNCYmKG4uc3RyaW5nKz0icyIpLGUmMzImJihuLnN0cmluZys9InUiKSxlJjY0JiYobi5zdHJpbmcrPSJ3IiksZSYxNiYmKG4uc3RyaW5nKz0ieCIpLGUmTGwmJihuLnN0cmluZys9IiwiKSx1QihuLnN0cmluZyl9ZnVuY3Rpb24ga29lKGUpe3ZhciBuO3JldHVybiBuPUIoZmwsWHMsMjgsMiwxNSwxKSxlLT1GdCxuWzBdPShlPj4xMCkrS1MmenIsblsxXT0oZSYxMDIzKSs1NjMyMCZ6cixpdShuLDAsbi5sZW5ndGgpfWZ1bmN0aW9uIE9vZShlKXt2YXIgbjtzd2l0Y2gobj0wLGUpe2Nhc2UgMTA1Om49MjticmVhaztjYXNlIDEwOTpuPTg7YnJlYWs7Y2FzZSAxMTU6bj00O2JyZWFrO2Nhc2UgMTIwOm49MTY7YnJlYWs7Y2FzZSAxMTc6bj0zMjticmVhaztjYXNlIDExOTpuPTY0O2JyZWFrO2Nhc2UgNzA6bj0yNTY7YnJlYWs7Y2FzZSA3MjpuPTEyODticmVhaztjYXNlIDg4Om49NTEyO2JyZWFrO2Nhc2UgNDQ6bj1MbH1yZXR1cm4gbn1mdW5jdGlvbiBhSW4oKXt2YXIgZSxuLHI7Zm9yKG49MCxlPTA7ZTwxO2UrKyl7aWYocj1Pb2UoKEhlKGUsMSksIlgiLmNoYXJDb2RlQXQoZSkpKSxyPT0wKXRocm93IGIobmV3IFBuKChIZShlLDIpLCJVbmtub3duIE9wdGlvbjogIisiWCIuc3Vic3RyKGUpKSkpO258PXJ9cmV0dXJuIG59ZnVuY3Rpb24gbEluKGUpe3ZhciBuLHIsdCxvO2ZvcihvPWUubGVuZ3RoLG49bnVsbCx0PTA7dDxvO3QrKylyPShIZSh0LGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQodCkpLG91KCIuKis/e1soKXxcXF4kIix4aShyKSk+PTA/KG58fChuPW5ldyBCMix0PjAmJkp0KG4sKGd0KDAsdCxlLmxlbmd0aCksZS5zdWJzdHIoMCx0KSkpKSxuLnN0cmluZys9IlxcIix1eShuLHImenIpKTpuJiZ1eShuLHImenIpO3JldHVybiBuP24uc3RyaW5nOmV9ZnVuY3Rpb24gc0luKGUpe3ZhciBuLHIsdCxvLGk7Zm9yKHQ9ZS5sZW5ndGgsbj1uZXcgQjIsaT0wO2k8dDspaWYocj1JdChlLGkrKyksIShyPT05fHxyPT0xMHx8cj09MTJ8fHI9PTEzfHxyPT0zMikpe2lmKHI9PTM1KXtmb3IoO2k8dCYmKHI9SXQoZSxpKyspLCEocj09MTN8fHI9PTEwKSk7KTtjb250aW51ZX1yPT05MiYmaTx0PyhvPShIZShpLGUubGVuZ3RoKSxlLmNoYXJDb2RlQXQoaSkpKT09MzV8fG89PTl8fG89PTEwfHxvPT0xMnx8bz09MTN8fG89PTMyPyh1eShuLG8menIpLCsraSk6KG4uc3RyaW5nKz0iXFwiLHV5KG4sbyZ6ciksKytpKTp1eShuLHImenIpfXJldHVybiBuLnN0cmluZ31mdW5jdGlvbiBWbigpe1ZuPUYsRFM9bmV3IHpkKDcpLHpvZT1uZXcgcXUoOCw5NCksbmV3IHF1KDgsNjQpLCRvZT1uZXcgcXUoOCwzNiksZ1llPW5ldyBxdSg4LDY1KSxoWWU9bmV3IHF1KDgsMTIyKSxtWWU9bmV3IHF1KDgsOTApLHdZZT1uZXcgcXUoOCw5OCkscFllPW5ldyBxdSg4LDY2KSx5WWU9bmV3IHF1KDgsNjApLEVZZT1uZXcgcXUoOCw2MiksRm9lPW5ldyB6ZCgxMSksbjY9bmV3IFVhKDQpLHVpKG42LDQ4LDU3KSxtMj1uZXcgVWEoNCksdWkobTIsNDgsNTcpLHVpKG0yLDY1LDkwKSx1aShtMiw5NSw5NSksdWkobTIsOTcsMTIyKSxPbT1uZXcgVWEoNCksdWkoT20sOSw5KSx1aShPbSwxMCwxMCksdWkoT20sMTIsMTIpLHVpKE9tLDEzLDEzKSx1aShPbSwzMiwzMiksQm9lPWRwKG42KSxIb2U9ZHAobTIpLEdvZT1kcChPbSksaDI9bmV3IHNuLFJTPW5ldyBzbixmWWU9UChJKHNlLDEpLFgsMiw2LFsiQ24iLCJMdSIsIkxsIiwiTHQiLCJMbSIsIkxvIiwiTW4iLCJNZSIsIk1jIiwiTmQiLCJObCIsIk5vIiwiWnMiLCJabCIsIlpwIiwiQ2MiLCJDZiIsbnVsbCwiQ28iLCJDcyIsIlBkIiwiUHMiLCJQZSIsIlBjIiwiUG8iLCJTbSIsIlNjIiwiU2siLCJTbyIsIlBpIiwiUGYiLCJMIiwiTSIsIk4iLCJaIiwiQyIsIlAiLCJTIl0pLFJvZT1QKEkoc2UsMSksWCwyLDYsWyJCYXNpYyBMYXRpbiIsIkxhdGluLTEgU3VwcGxlbWVudCIsIkxhdGluIEV4dGVuZGVkLUEiLCJMYXRpbiBFeHRlbmRlZC1CIiwiSVBBIEV4dGVuc2lvbnMiLCJTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMiLCJDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MiLCJHcmVlayIsIkN5cmlsbGljIiwiQXJtZW5pYW4iLCJIZWJyZXciLCJBcmFiaWMiLCJTeXJpYWMiLCJUaGFhbmEiLCJEZXZhbmFnYXJpIiwiQmVuZ2FsaSIsIkd1cm11a2hpIiwiR3VqYXJhdGkiLCJPcml5YSIsIlRhbWlsIiwiVGVsdWd1IiwiS2FubmFkYSIsIk1hbGF5YWxhbSIsIlNpbmhhbGEiLCJUaGFpIiwiTGFvIiwiVGliZXRhbiIsIk15YW5tYXIiLCJHZW9yZ2lhbiIsIkhhbmd1bCBKYW1vIiwiRXRoaW9waWMiLCJDaGVyb2tlZSIsIlVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3MiLCJPZ2hhbSIsIlJ1bmljIiwiS2htZXIiLCJNb25nb2xpYW4iLCJMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsIiwiR3JlZWsgRXh0ZW5kZWQiLCJHZW5lcmFsIFB1bmN0dWF0aW9uIiwiU3VwZXJzY3JpcHRzIGFuZCBTdWJzY3JpcHRzIiwiQ3VycmVuY3kgU3ltYm9scyIsIkNvbWJpbmluZyBNYXJrcyBmb3IgU3ltYm9scyIsIkxldHRlcmxpa2UgU3ltYm9scyIsIk51bWJlciBGb3JtcyIsIkFycm93cyIsIk1hdGhlbWF0aWNhbCBPcGVyYXRvcnMiLCJNaXNjZWxsYW5lb3VzIFRlY2huaWNhbCIsIkNvbnRyb2wgUGljdHVyZXMiLCJPcHRpY2FsIENoYXJhY3RlciBSZWNvZ25pdGlvbiIsIkVuY2xvc2VkIEFscGhhbnVtZXJpY3MiLCJCb3ggRHJhd2luZyIsIkJsb2NrIEVsZW1lbnRzIiwiR2VvbWV0cmljIFNoYXBlcyIsIk1pc2NlbGxhbmVvdXMgU3ltYm9scyIsIkRpbmdiYXRzIiwiQnJhaWxsZSBQYXR0ZXJucyIsIkNKSyBSYWRpY2FscyBTdXBwbGVtZW50IiwiS2FuZ3hpIFJhZGljYWxzIiwiSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVycyIsIkNKSyBTeW1ib2xzIGFuZCBQdW5jdHVhdGlvbiIsIkhpcmFnYW5hIiwiS2F0YWthbmEiLCJCb3BvbW9mbyIsIkhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW8iLCJLYW5idW4iLCJCb3BvbW9mbyBFeHRlbmRlZCIsIkVuY2xvc2VkIENKSyBMZXR0ZXJzIGFuZCBNb250aHMiLCJDSksgQ29tcGF0aWJpbGl0eSIsIkNKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEEiLCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIiwiWWkgU3lsbGFibGVzIiwiWWkgUmFkaWNhbHMiLCJIYW5ndWwgU3lsbGFibGVzIiwiUHJpdmF0ZSBVc2UiLCJDSksgQ29tcGF0aWJpbGl0eSBJZGVvZ3JhcGhzIiwiQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXMiLCJBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUEiLCJDb21iaW5pbmcgSGFsZiBNYXJrcyIsIkNKSyBDb21wYXRpYmlsaXR5IEZvcm1zIiwiU21hbGwgRm9ybSBWYXJpYW50cyIsIkFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQiIsIlNwZWNpYWxzIiwiSGFsZndpZHRoIGFuZCBGdWxsd2lkdGggRm9ybXMiLCJPbGQgSXRhbGljIiwiR290aGljIiwiRGVzZXJldCIsIkJ5emFudGluZSBNdXNpY2FsIFN5bWJvbHMiLCJNdXNpY2FsIFN5bWJvbHMiLCJNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHMiLCJDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBCIiwiQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBocyBTdXBwbGVtZW50IiwiVGFncyJdKSxEb2U9UChJKGhuLDEpLGtuLDI4LDE1LFs2NjMwNCw2NjM1MSw2NjM1Miw2NjM4Myw2NjU2MCw2NjYzOSwxMTg3ODQsMTE5MDM5LDExOTA0MCwxMTkyOTUsMTE5ODA4LDEyMDgzMSwxMzEwNzIsMTczNzgyLDE5NDU2MCwxOTUxMDMsOTE3NTA0LDkxNzYzMV0pfWZ1bmN0aW9uIHpkKGUpe3RoaXMudHlwZV8wPWV9ZnVuY3Rpb24gdVllKGUpe3JldHVybiBWbigpLG5ldyBxdSgwLGUpfWZ1bmN0aW9uIHVJbihlKXtyZXR1cm4gbmV3IGZwKDMsZSl9ZnVuY3Rpb24gUUwoZSxuKXtyZXR1cm4gVm4oKSxuZXcgV29lKGUsbil9ZnVuY3Rpb24gZTYoZSxuKXtyZXR1cm4gVm4oKSxuZXcgam9lKGUsbiwwKX1mdW5jdGlvbiBjWWUoZSxuLHIpe3JldHVybiBWbigpLG5ldyBUWWUoZSxuLHIpfWZ1bmN0aW9uIGtGKGUsbil7cmV0dXJuIFZuKCksbmV3IGpvZSg2LGUsbil9ZnVuY3Rpb24gX1llKGUpe3JldHVybiBWbigpLG5ldyBSRigxMCxlLDApfWZ1bmN0aW9uIGNJbigpe1ZuKCk7dmFyIGU7cmV0dXJuIE9GfHwoZT11SW4obF8oIk0iLCEwKSksZT1RTChsXygiTSIsITEpLGUpLE9GPWUsT0YpfWZ1bmN0aW9uIF9Jbigpe1ZuKCk7dmFyIGUsbixyLHQsbyxpO2lmKE1GKXJldHVybiBNRjtmb3IoZT1uZXcgVWEoNCksX3AoZSxsXygiQVNTSUdORUQiLCEwKSkselMoZSxsXygiTSIsITApKSx6UyhlLGxfKCJDIiwhMCkpLGk9bmV3IFVhKDQpLHQ9MDt0PDExO3QrKyl1aShpLHQsdCk7cmV0dXJuIG49bmV3IFVhKDQpLF9wKG4sbF8oIk0iLCEwKSksdWkobiw0NDQ4LDQ2MDcpLHVpKG4sNjU0MzgsNjU0MzkpLG89bmV3ICRTKDIpLGQxKG8sZSksZDEobyxEUykscj1uZXcgJFMoMiksci5hZGRDaGlsZChRTChpLGxfKCJMIiwhMCkpKSxyLmFkZENoaWxkKG4pLHI9bmV3IGZwKDMscikscj1uZXcgV29lKG8sciksTUY9cixNRn1mdW5jdGlvbiBsXyhlLG4pe1ZuKCk7dmFyIHIsdCxvLGkscyx1LGMsXyxkLGYsaCxtLHk7aWYoVjIoaDIpPT0wKXtmb3IoZj1CKGZJbixYLDEyMixmWWUubGVuZ3RoLDAsMSkscz0wO3M8Zi5sZW5ndGg7cysrKWZbc109bmV3IFVhKDQpO2Zvcih0PW5ldyBCMixpPTA7aTxSb2UubGVuZ3RoO2krKyl7aWYoZD1uZXcgVWEoNCksaTw4ND8odT1pKjIsbT0oSGUodSwxNjgpLCJcMH/CgMO/xIDFv8aAyY/JkMqvyrDLv8yAza/NsM+/0IDTv9Sw1o/WkNe/2IDbv9yA3Y/egN6/4KSA4KW/4KaA4Ke/4KiA4Km/4KqA4Ku/4KyA4K2/4K6A4K+/4LCA4LG/4LKA4LO/4LSA4LW/4LaA4Le/4LiA4Lm/4LqA4Lu/4LyA4L+/4YCA4YKf4YKg4YO/4YSA4Ye/4YiA4Y2/4Y6g4Y+/4ZCA4Zm/4ZqA4Zqf4Zqg4Zu/4Z6A4Z+/4aCA4aKv4biA4bu/4byA4b+/4oCA4oGv4oGw4oKf4oKg4oOP4oOQ4oO/4oSA4oWP4oWQ4oaP4oaQ4oe/4oiA4ou/4oyA4o+/4pCA4pC/4pGA4pGf4pGg4pO/4pSA4pW/4paA4paf4pag4pe/4piA4pu/4pyA4p6/4qCA4qO/4rqA4ru/4ryA4r+f4r+w4r+/44CA44C/44GA44Kf44Kg44O/44SA44Sv44Sw44aP44aQ44af44ag44a/44iA44u/44yA44+/45CA5La15LiA6b+/6oCA6pKP6pKQ6pOP6rCA7Z6j7oCA76O/76SA76u/76yA762P762Q77e/77ig77iv77iw77mP77mQ77mv77mw77u+XHVGRUZGXHVGRUZG77yA77+vIi5jaGFyQ29kZUF0KHUpKSxoPShIZSh1KzEsMTY4KSwiXDB/woDDv8SAxb/GgMmPyZDKr8qwy7/MgM2vzbDPv9CA07/UsNaP1pDXv9iA27/cgN2P3oDev+CkgOClv+CmgOCnv+CogOCpv+CqgOCrv+CsgOCtv+CugOCvv+CwgOCxv+CygOCzv+C0gOC1v+C2gOC3v+C4gOC5v+C6gOC7v+C8gOC/v+GAgOGCn+GCoOGDv+GEgOGHv+GIgOGNv+GOoOGPv+GQgOGZv+GagOGan+GaoOGbv+GegOGfv+GggOGir+G4gOG7v+G8gOG/v+KAgOKBr+KBsOKCn+KCoOKDj+KDkOKDv+KEgOKFj+KFkOKGj+KGkOKHv+KIgOKLv+KMgOKPv+KQgOKQv+KRgOKRn+KRoOKTv+KUgOKVv+KWgOKWn+KWoOKXv+KYgOKbv+KcgOKev+KggOKjv+K6gOK7v+K8gOK/n+K/sOK/v+OAgOOAv+OBgOOCn+OCoOODv+OEgOOEr+OEsOOGj+OGkOOGn+OGoOOGv+OIgOOLv+OMgOOPv+OQgOS2teS4gOm/v+qAgOqSj+qSkOqTj+qwgO2eo+6AgO+jv++kgO+rv++sgO+tj++tkO+3v++4oO+4r++4sO+5j++5kO+5r++5sO+7vlx1RkVGRlx1RkVGRu+8gO+/ryIuY2hhckNvZGVBdCh1KzEpKSx1aShkLG0saCkpOih1PShpLTg0KSoyLHVpKGQsRG9lW3VdLERvZVt1KzFdKSksYz1Sb2VbaV0sVGUoYywiU3BlY2lhbHMiKSYmdWkoZCw2NTUyMCw2NTUzMyksVGUoYywiUHJpdmF0ZSBVc2UiKSYmKHVpKGQsOTgzMDQwLDEwNDg1NzMpLHVpKGQsMTA0ODU3NiwxMTE0MTA5KSksdG8oaDIsYyxkKSx0byhSUyxjLGRwKGQpKSxfPXQuc3RyaW5nLmxlbmd0aCwwPF8/dC5zdHJpbmc9WWEodC5zdHJpbmcsMCwwKTowPl8mJih0LnN0cmluZys9bWNlKEIoZmwsWHMsMjgsLV8sMTUsMSkpKSx0LnN0cmluZys9IklzIixvdShjLHhpKDMyKSk+PTApZm9yKG89MDtvPGMubGVuZ3RoO28rKylIZShvLGMubGVuZ3RoKSxjLmNoYXJDb2RlQXQobykhPTMyJiZ1eSh0LChIZShvLGMubGVuZ3RoKSxjLmNoYXJDb2RlQXQobykpKTtlbHNlIHQuc3RyaW5nKz0iIitjO01vZSh0LnN0cmluZyxjLCEwKX1Nb2UoIkFTU0lHTkVEIiwiQ24iLCExKSxNb2UoIlVOQVNTSUdORUQiLCJDbiIsITApLHI9bmV3IFVhKDQpLHVpKHIsMCxXbSksdG8oaDIsIkFMTCIsciksdG8oUlMsIkFMTCIsZHAocikpLCFjcCYmKGNwPW5ldyBzbiksdG8oY3AsIkFTU0lHTkVEIiwiQVNTSUdORUQiKSwhY3AmJihjcD1uZXcgc24pLHRvKGNwLCJVTkFTU0lHTkVEIiwiVU5BU1NJR05FRCIpLCFjcCYmKGNwPW5ldyBzbiksdG8oY3AsIkFMTCIsIkFMTCIpfXJldHVybiB5PWEobmkobj9oMjpSUyxlKSwxMzgpLHl9ZnVuY3Rpb24gZFllKGUsbixyKXtWbigpO3ZhciB0O3JldHVybiB0PWxfKGUsbiksciYmdCYmZEluKGUpJiYodD1udWxsKSx0fWZ1bmN0aW9uIGRJbihlKXtyZXR1cm4gY3A/VjUoY3AsZSk6ITF9ZnVuY3Rpb24gTW9lKGUsbixyKXt2YXIgdCxvO3Q9YShuaShoMixuKSwxMjIpLG89YShuaShSUyxuKSwxMjIpLHI/KHRvKGgyLGUsdCksdG8oUlMsZSxvKSk6KHRvKFJTLGUsdCksdG8oaDIsZSxvKSl9cCgxMjIsMSxqbSx6ZCksbC5hZGRDaGlsZD1mdW5jdGlvbihuKXt0aHJvdyBiKG5ldyBJbygiTm90IHN1cHBvcnRlZC4iKSl9LGwuZ2V0Q2hhcj1mdW5jdGlvbigpe3JldHVybi0xfSxsLmdldENoaWxkPWZ1bmN0aW9uKG4pe3JldHVybiBudWxsfSxsLmdldFN0cmluZz1mdW5jdGlvbigpe3JldHVybiBudWxsfSxsLnNldE1heD1mdW5jdGlvbihuKXt9LGwuc2V0TWluPWZ1bmN0aW9uKG4pe30sbC5zaXplXzI9ZnVuY3Rpb24oKXtyZXR1cm4gMH0sbC50b1N0cmluZ18wPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9TdHJpbmdfMSgwKX0sbC50b1N0cmluZ18xPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnR5cGVfMD09MTE/Ii4iOiIifSxsLnR5cGVfMD0wO3ZhciBSb2UsaDIsUlMsZlllLERvZSxjcD1udWxsLG42LE9GPW51bGwsRm9lLERTLE1GPW51bGwsem9lLCRvZSxCb2UsR29lLEhvZSxwWWUsT20sZ1llLGhZZSxtWWUseVllLG0yLHdZZSxFWWUsZkluPWcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbnRlcm5hbCIsIlJlZ0V4L1Rva2VuIiwxMjIpO2Z1bmN0aW9uIHVpKGUsbixyKXt2YXIgdCxvLGkscztpZihuPD1yPyhvPW4saT1yKToobz1yLGk9biksdD0wLGUucmFuZ2VzPT1udWxsKWUucmFuZ2VzPUIoaG4sa24sMjgsMiwxNSwxKSxlLnJhbmdlc1swXT1vLGUucmFuZ2VzWzFdPWksZS5zb3J0ZWQ9ITA7ZWxzZXtpZih0PWUucmFuZ2VzLmxlbmd0aCxlLnJhbmdlc1t0LTFdKzE9PW8pe2UucmFuZ2VzW3QtMV09aTtyZXR1cm59cz1CKGhuLGtuLDI4LHQrMiwxNSwxKSxYbyhlLnJhbmdlcywwLHMsMCx0KSxlLnJhbmdlcz1zLGUucmFuZ2VzW3QtMV0+PW8mJihlLnNvcnRlZD0hMSxlLmNvbXBhY3RlZD0hMSksZS5yYW5nZXNbdCsrXT1vLGUucmFuZ2VzW3RdPWksZS5zb3J0ZWR8fEtnKGUpfX1mdW5jdGlvbiBGUyhlKXt2YXIgbixyLHQsbztpZighKGUucmFuZ2VzPT1udWxsfHxlLnJhbmdlcy5sZW5ndGg8PTIpJiYhZS5jb21wYWN0ZWQpe2ZvcihuPTAsbz0wO288ZS5yYW5nZXMubGVuZ3RoOyl7Zm9yKG4hPW8/KGUucmFuZ2VzW25dPWUucmFuZ2VzW28rK10sZS5yYW5nZXNbbisxXT1lLnJhbmdlc1tvKytdKTpvKz0yLHI9ZS5yYW5nZXNbbisxXTtvPGUucmFuZ2VzLmxlbmd0aCYmIShyKzE8ZS5yYW5nZXNbb10pOylpZihyKzE9PWUucmFuZ2VzW29dKWUucmFuZ2VzW24rMV09ZS5yYW5nZXNbbysxXSxyPWUucmFuZ2VzW24rMV0sbys9MjtlbHNlIGlmKHI+PWUucmFuZ2VzW28rMV0pbys9MjtlbHNlIGlmKHI8ZS5yYW5nZXNbbysxXSllLnJhbmdlc1tuKzFdPWUucmFuZ2VzW28rMV0scj1lLnJhbmdlc1tuKzFdLG8rPTI7ZWxzZSB0aHJvdyBiKG5ldyBJbygiVG9rZW4jY29tcGFjdFJhbmdlcygpOiBJbnRlcm5lbCBFcnJvcjogWyIrZS5yYW5nZXNbbl0rIiwiK2UucmFuZ2VzW24rMV0rIl0gWyIrZS5yYW5nZXNbb10rIiwiK2UucmFuZ2VzW28rMV0rIl0iKSk7bis9Mn1uIT1lLnJhbmdlcy5sZW5ndGgmJih0PUIoaG4sa24sMjgsbiwxNSwxKSxYbyhlLnJhbmdlcywwLHQsMCxuKSxlLnJhbmdlcz10KSxlLmNvbXBhY3RlZD0hMH19ZnVuY3Rpb24gdlllKGUsbil7dmFyIHIsdCxvLGkscyx1LGMsXyxkO2lmKF89biwhKF8ucmFuZ2VzPT1udWxsfHxlLnJhbmdlcz09bnVsbCkpe2ZvcihLZyhlKSxGUyhlKSxLZyhfKSxGUyhfKSxyPUIoaG4sa24sMjgsZS5yYW5nZXMubGVuZ3RoK18ucmFuZ2VzLmxlbmd0aCwxNSwxKSxkPTAsdD0wLHM9MDt0PGUucmFuZ2VzLmxlbmd0aCYmczxfLnJhbmdlcy5sZW5ndGg7KWlmKG89ZS5yYW5nZXNbdF0saT1lLnJhbmdlc1t0KzFdLHU9Xy5yYW5nZXNbc10sYz1fLnJhbmdlc1tzKzFdLGk8dSl0Kz0yO2Vsc2UgaWYoaT49dSYmbzw9Yyl1PD1vJiZpPD1jPyhyW2QrK109byxyW2QrK109aSx0Kz0yKTp1PD1vPyhyW2QrK109byxyW2QrK109YyxlLnJhbmdlc1t0XT1jKzEscys9Mik6aTw9Yz8ocltkKytdPXUscltkKytdPWksdCs9Mik6KHJbZCsrXT11LHJbZCsrXT1jLGUucmFuZ2VzW3RdPWMrMSk7ZWxzZSBpZihjPG8pcys9MjtlbHNlIHRocm93IGIobmV3IElvKCJUb2tlbiNpbnRlcnNlY3RSYW5nZXMoKTogSW50ZXJuYWwgRXJyb3I6IFsiK2UucmFuZ2VzW3RdKyIsIitlLnJhbmdlc1t0KzFdKyJdICYgWyIrXy5yYW5nZXNbc10rIiwiK18ucmFuZ2VzW3MrMV0rIl0iKSk7Zm9yKDt0PGUucmFuZ2VzLmxlbmd0aDspcltkKytdPWUucmFuZ2VzW3QrK10scltkKytdPWUucmFuZ2VzW3QrK107ZS5yYW5nZXM9QihobixrbiwyOCxkLDE1LDEpLFhvKHIsMCxlLnJhbmdlcywwLGQpfX1mdW5jdGlvbiBfcChlLG4pe3ZhciByLHQsbyxpLHM7aWYocz1hKG4sMTM4KSxLZyhlKSxLZyhzKSxzLnJhbmdlcyE9bnVsbCl7aWYoZS5zb3J0ZWQ9ITAsZS5yYW5nZXM9PW51bGwpe2UucmFuZ2VzPUIoaG4sa24sMjgscy5yYW5nZXMubGVuZ3RoLDE1LDEpLFhvKHMucmFuZ2VzLDAsZS5yYW5nZXMsMCxzLnJhbmdlcy5sZW5ndGgpO3JldHVybn1mb3IoaT1CKGhuLGtuLDI4LGUucmFuZ2VzLmxlbmd0aCtzLnJhbmdlcy5sZW5ndGgsMTUsMSkscj0wLHQ9MCxvPTA7cjxlLnJhbmdlcy5sZW5ndGh8fHQ8cy5yYW5nZXMubGVuZ3RoOylyPj1lLnJhbmdlcy5sZW5ndGg/KGlbbysrXT1zLnJhbmdlc1t0KytdLGlbbysrXT1zLnJhbmdlc1t0KytdKTp0Pj1zLnJhbmdlcy5sZW5ndGg/KGlbbysrXT1lLnJhbmdlc1tyKytdLGlbbysrXT1lLnJhbmdlc1tyKytdKTpzLnJhbmdlc1t0XTxlLnJhbmdlc1tyXXx8cy5yYW5nZXNbdF09PT1lLnJhbmdlc1tyXSYmcy5yYW5nZXNbdCsxXTxlLnJhbmdlc1tyKzFdPyhpW28rK109cy5yYW5nZXNbdCsrXSxpW28rK109cy5yYW5nZXNbdCsrXSk6KGlbbysrXT1lLnJhbmdlc1tyKytdLGlbbysrXT1lLnJhbmdlc1tyKytdKTtlLnJhbmdlcz1pfX1mdW5jdGlvbiBLZyhlKXt2YXIgbixyLHQ7aWYoIWUuc29ydGVkJiZlLnJhbmdlcyE9bnVsbCl7Zm9yKG49ZS5yYW5nZXMubGVuZ3RoLTQ7bj49MDtuLT0yKWZvcihyPTA7cjw9bjtyKz0yKShlLnJhbmdlc1tyXT5lLnJhbmdlc1tyKzJdfHxlLnJhbmdlc1tyXT09PWUucmFuZ2VzW3IrMl0mJmUucmFuZ2VzW3IrMV0+ZS5yYW5nZXNbciszXSkmJih0PWUucmFuZ2VzW3IrMl0sZS5yYW5nZXNbcisyXT1lLnJhbmdlc1tyXSxlLnJhbmdlc1tyXT10LHQ9ZS5yYW5nZXNbciszXSxlLnJhbmdlc1tyKzNdPWUucmFuZ2VzW3IrMV0sZS5yYW5nZXNbcisxXT10KTtlLnNvcnRlZD0hMH19ZnVuY3Rpb24gelMoZSxuKXt2YXIgcix0LG8saSxzLHUsYyxfLGQ7aWYobi50eXBlXzA9PTUpe3ZZZShlLG4pO3JldHVybn1pZihfPW4sIShfLnJhbmdlcz09bnVsbHx8ZS5yYW5nZXM9PW51bGwpKXtmb3IoS2coZSksRlMoZSksS2coXyksRlMoXykscj1CKGhuLGtuLDI4LGUucmFuZ2VzLmxlbmd0aCtfLnJhbmdlcy5sZW5ndGgsMTUsMSksZD0wLHQ9MCxzPTA7dDxlLnJhbmdlcy5sZW5ndGgmJnM8Xy5yYW5nZXMubGVuZ3RoOylpZihvPWUucmFuZ2VzW3RdLGk9ZS5yYW5nZXNbdCsxXSx1PV8ucmFuZ2VzW3NdLGM9Xy5yYW5nZXNbcysxXSxpPHUpcltkKytdPWUucmFuZ2VzW3QrK10scltkKytdPWUucmFuZ2VzW3QrK107ZWxzZSBpZihpPj11JiZvPD1jKXU8PW8mJmk8PWM/dCs9Mjp1PD1vPyhlLnJhbmdlc1t0XT1jKzEscys9Mik6aTw9Yz8ocltkKytdPW8scltkKytdPXUtMSx0Kz0yKToocltkKytdPW8scltkKytdPXUtMSxlLnJhbmdlc1t0XT1jKzEscys9Mik7ZWxzZSBpZihjPG8pcys9MjtlbHNlIHRocm93IGIobmV3IElvKCJUb2tlbiNzdWJ0cmFjdFJhbmdlcygpOiBJbnRlcm5hbCBFcnJvcjogWyIrZS5yYW5nZXNbdF0rIiwiK2UucmFuZ2VzW3QrMV0rIl0gLSBbIitfLnJhbmdlc1tzXSsiLCIrXy5yYW5nZXNbcysxXSsiXSIpKTtmb3IoO3Q8ZS5yYW5nZXMubGVuZ3RoOylyW2QrK109ZS5yYW5nZXNbdCsrXSxyW2QrK109ZS5yYW5nZXNbdCsrXTtlLnJhbmdlcz1CKGhuLGtuLDI4LGQsMTUsMSksWG8ociwwLGUucmFuZ2VzLDAsZCl9fWZ1bmN0aW9uIFVhKGUpe1ZuKCksemQuY2FsbCh0aGlzLGUpLHRoaXMuc29ydGVkPSExLHRoaXMuY29tcGFjdGVkPSExfWZ1bmN0aW9uIGRwKGUpe1ZuKCk7dmFyIG4scix0LG8saSxzO2lmKGUudHlwZV8wIT00JiZlLnR5cGVfMCE9NSl0aHJvdyBiKG5ldyBHZSgiVG9rZW4jY29tcGxlbWVudFJhbmdlcygpOiBtdXN0IGJlIFJBTkdFOiAiK2UudHlwZV8wKSk7Zm9yKGk9ZSxLZyhpKSxGUyhpKSx0PWkucmFuZ2VzLmxlbmd0aCsyLGkucmFuZ2VzWzBdPT0wJiYodC09Mikscj1pLnJhbmdlc1tpLnJhbmdlcy5sZW5ndGgtMV0scj09V20mJih0LT0yKSxvPW5ldyBVYSg0KSxvLnJhbmdlcz1CKGhuLGtuLDI4LHQsMTUsMSkscz0wLGkucmFuZ2VzWzBdPjAmJihvLnJhbmdlc1tzKytdPTAsby5yYW5nZXNbcysrXT1pLnJhbmdlc1swXS0xKSxuPTE7bjxpLnJhbmdlcy5sZW5ndGgtMjtuKz0yKW8ucmFuZ2VzW3MrK109aS5yYW5nZXNbbl0rMSxvLnJhbmdlc1tzKytdPWkucmFuZ2VzW24rMV0tMTtyZXR1cm4gciE9V20mJihvLnJhbmdlc1tzKytdPXIrMSxvLnJhbmdlc1tzXT1XbSksby5jb21wYWN0ZWQ9ITAsb31mdW5jdGlvbiAkYihlKXt2YXIgbixyLHQ7c3dpdGNoKGUpe2Nhc2UgOTE6Y2FzZSA5MzpjYXNlIDQ1OmNhc2UgOTQ6Y2FzZSA0NDpjYXNlIDkyOnQ9IlxcIitTdHJpbmcuZnJvbUNoYXJDb2RlKGUmenIpO2JyZWFrO2Nhc2UgMTI6dD0iXFxmIjticmVhaztjYXNlIDEwOnQ9IlxcbiI7YnJlYWs7Y2FzZSAxMzp0PSJcXHIiO2JyZWFrO2Nhc2UgOTp0PSJcXHQiO2JyZWFrO2Nhc2UgMjc6dD0iXFxlIjticmVhaztkZWZhdWx0OmU8MzI/KHI9KG49ZT4+PjAsIjAiK24udG9TdHJpbmcoMTYpKSx0PSJcXHgiK1lhKHIsci5sZW5ndGgtMixyLmxlbmd0aCkpOmU+PUZ0PyhyPShuPWU+Pj4wLCIwIituLnRvU3RyaW5nKDE2KSksdD0iXFx2IitZYShyLHIubGVuZ3RoLTYsci5sZW5ndGgpKTp0PSIiK1N0cmluZy5mcm9tQ2hhckNvZGUoZSZ6cil9cmV0dXJuIHR9cCgxMzgsMTIyLHszOjEsMTM4OjEsMTIyOjF9LFVhKSxsLnRvU3RyaW5nXzE9ZnVuY3Rpb24obil7dmFyIHIsdCxvO2lmKHRoaXMudHlwZV8wPT00KWlmKHRoaXM9PUZvZSl0PSIuIjtlbHNlIGlmKHRoaXM9PW42KXQ9IlxcZCI7ZWxzZSBpZih0aGlzPT1tMil0PSJcXHciO2Vsc2UgaWYodGhpcz09T20pdD0iXFxzIjtlbHNle2ZvcihvPW5ldyBMYyxvLnN0cmluZys9IlsiLHI9MDtyPHRoaXMucmFuZ2VzLmxlbmd0aDtyKz0yKW4mTGwmJnI+MCYmKG8uc3RyaW5nKz0iLCIpLHRoaXMucmFuZ2VzW3JdPT09dGhpcy5yYW5nZXNbcisxXT9KdChvLCRiKHRoaXMucmFuZ2VzW3JdKSk6KEp0KG8sJGIodGhpcy5yYW5nZXNbcl0pKSxvLnN0cmluZys9Ii0iLEp0KG8sJGIodGhpcy5yYW5nZXNbcisxXSkpKTtvLnN0cmluZys9Il0iLHQ9by5zdHJpbmd9ZWxzZSBpZih0aGlzPT1Cb2UpdD0iXFxEIjtlbHNlIGlmKHRoaXM9PUhvZSl0PSJcXFciO2Vsc2UgaWYodGhpcz09R29lKXQ9IlxcUyI7ZWxzZXtmb3Iobz1uZXcgTGMsby5zdHJpbmcrPSJbXiIscj0wO3I8dGhpcy5yYW5nZXMubGVuZ3RoO3IrPTIpbiZMbCYmcj4wJiYoby5zdHJpbmcrPSIsIiksdGhpcy5yYW5nZXNbcl09PT10aGlzLnJhbmdlc1tyKzFdP0p0KG8sJGIodGhpcy5yYW5nZXNbcl0pKTooSnQobywkYih0aGlzLnJhbmdlc1tyXSkpLG8uc3RyaW5nKz0iLSIsSnQobywkYih0aGlzLnJhbmdlc1tyKzFdKSkpO28uc3RyaW5nKz0iXSIsdD1vLnN0cmluZ31yZXR1cm4gdH0sbC5jb21wYWN0ZWQ9ITEsbC5zb3J0ZWQ9ITEsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmludGVybmFsIiwiUmVnRXgvUmFuZ2VUb2tlbiIsMTM4KTtmdW5jdGlvbiBVb2UoZSl7dGhpcy5yZWZOdW1iZXI9ZX1wKDU5MiwxLHs1OTI6MX0sVW9lKSxsLnJlZk51bWJlcj0wLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbnRlcm5hbCIsIlJlZ0V4L1JlZ2V4UGFyc2VyL1JlZmVyZW5jZVBvc2l0aW9uIiw1OTIpO2Z1bmN0aW9uIHBJbihlLG4scil7dmFyIHQ7ZS5yZWdleD1uLGUub3B0aW9uc18wPXIsdD0oZS5vcHRpb25zXzAmNTEyKT09NTEyP25ldyBzWWU6bmV3IE5vZSxlLnRva2VudHJlZT1vSW4odCxlLnJlZ2V4LGUub3B0aW9uc18wKX1mdW5jdGlvbiBTWWUoZSl7cEluKHRoaXMsZSxhSW4oKSl9cCg1OTEsMSx7MzoxLDU5MToxfSxTWWUpLGwuZXF1YWxzXzA9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIG49PW51bGx8fCFMKG4sNTkxKT8hMToocj1hKG4sNTkxKSxUZSh0aGlzLnJlZ2V4LHIucmVnZXgpJiZ0aGlzLm9wdGlvbnNfMD09ci5vcHRpb25zXzApfSxsLmhhc2hDb2RlXzE9ZnVuY3Rpb24oKXtyZXR1cm4gTmModGhpcy5yZWdleCsiLyIrTG9lKHRoaXMub3B0aW9uc18wKSl9LGwudG9TdHJpbmdfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRva2VudHJlZS50b1N0cmluZ18xKHRoaXMub3B0aW9uc18wKX0sbC5vcHRpb25zXzA9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9SZWd1bGFyRXhwcmVzc2lvbiIsNTkxKTtmdW5jdGlvbiBxdShlLG4pe1ZuKCksemQuY2FsbCh0aGlzLGUpLHRoaXMuY2hhcmRhdGE9bn1wKDIyOCwxMjIsam0scXUpLGwuZ2V0Q2hhcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNoYXJkYXRhfSxsLnRvU3RyaW5nXzE9ZnVuY3Rpb24obil7dmFyIHIsdCxvO3N3aXRjaCh0aGlzLnR5cGVfMCl7Y2FzZSAwOnN3aXRjaCh0aGlzLmNoYXJkYXRhKXtjYXNlIDEyNDpjYXNlIDQyOmNhc2UgNDM6Y2FzZSA2MzpjYXNlIDQwOmNhc2UgNDE6Y2FzZSA0NjpjYXNlIDkxOmNhc2UgMTIzOmNhc2UgOTI6bz0iXFwiK1M2KHRoaXMuY2hhcmRhdGEmenIpO2JyZWFrO2Nhc2UgMTI6bz0iXFxmIjticmVhaztjYXNlIDEwOm89IlxcbiI7YnJlYWs7Y2FzZSAxMzpvPSJcXHIiO2JyZWFrO2Nhc2UgOTpvPSJcXHQiO2JyZWFrO2Nhc2UgMjc6bz0iXFxlIjticmVhaztkZWZhdWx0OnRoaXMuY2hhcmRhdGE+PUZ0Pyh0PShyPXRoaXMuY2hhcmRhdGE+Pj4wLCIwIityLnRvU3RyaW5nKDE2KSksbz0iXFx2IitZYSh0LHQubGVuZ3RoLTYsdC5sZW5ndGgpKTpvPSIiK1M2KHRoaXMuY2hhcmRhdGEmenIpfWJyZWFrO2Nhc2UgODp0aGlzPT16b2V8fHRoaXM9PSRvZT9vPSIiK1M2KHRoaXMuY2hhcmRhdGEmenIpOm89IlxcIitTNih0aGlzLmNoYXJkYXRhJnpyKTticmVhaztkZWZhdWx0Om89bnVsbH1yZXR1cm4gb30sbC5jaGFyZGF0YT0wLGcoIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS5pbnRlcm5hbCIsIlJlZ0V4L1Rva2VuL0NoYXJUb2tlbiIsMjI4KTtmdW5jdGlvbiBmcChlLG4pe1ZuKCksemQuY2FsbCh0aGlzLGUpLHRoaXMuY2hpbGQ9bix0aGlzLm1pbl8wPS0xLHRoaXMubWF4XzA9LTF9cCgzMTgsMTIyLGptLGZwKSxsLmdldENoaWxkPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmNoaWxkfSxsLnNldE1heD1mdW5jdGlvbihuKXt0aGlzLm1heF8wPW59LGwuc2V0TWluPWZ1bmN0aW9uKG4pe3RoaXMubWluXzA9bn0sbC5zaXplXzI9ZnVuY3Rpb24oKXtyZXR1cm4gMX0sbC50b1N0cmluZ18xPWZ1bmN0aW9uKG4pe3ZhciByO2lmKHRoaXMudHlwZV8wPT0zKWlmKHRoaXMubWluXzA8MCYmdGhpcy5tYXhfMDwwKXI9dGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyIqIjtlbHNlIGlmKHRoaXMubWluXzA9PXRoaXMubWF4XzApcj10aGlzLmNoaWxkLnRvU3RyaW5nXzEobikrInsiK3RoaXMubWluXzArIn0iO2Vsc2UgaWYodGhpcy5taW5fMD49MCYmdGhpcy5tYXhfMD49MClyPXRoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsieyIrdGhpcy5taW5fMCsiLCIrdGhpcy5tYXhfMCsifSI7ZWxzZSBpZih0aGlzLm1pbl8wPj0wJiZ0aGlzLm1heF8wPDApcj10aGlzLmNoaWxkLnRvU3RyaW5nXzEobikrInsiK3RoaXMubWluXzArIix9IjtlbHNlIHRocm93IGIobmV3IElvKCJUb2tlbiN0b1N0cmluZygpOiBDTE9TVVJFICIrdGhpcy5taW5fMCsiLCAiK3RoaXMubWF4XzApKTtlbHNlIGlmKHRoaXMubWluXzA8MCYmdGhpcy5tYXhfMDwwKXI9dGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyIqPyI7ZWxzZSBpZih0aGlzLm1pbl8wPT10aGlzLm1heF8wKXI9dGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyJ7Iit0aGlzLm1pbl8wKyJ9PyI7ZWxzZSBpZih0aGlzLm1pbl8wPj0wJiZ0aGlzLm1heF8wPj0wKXI9dGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyJ7Iit0aGlzLm1pbl8wKyIsIit0aGlzLm1heF8wKyJ9PyI7ZWxzZSBpZih0aGlzLm1pbl8wPj0wJiZ0aGlzLm1heF8wPDApcj10aGlzLmNoaWxkLnRvU3RyaW5nXzEobikrInsiK3RoaXMubWluXzArIix9PyI7ZWxzZSB0aHJvdyBiKG5ldyBJbygiVG9rZW4jdG9TdHJpbmcoKTogTk9OR1JFRURZQ0xPU1VSRSAiK3RoaXMubWluXzArIiwgIit0aGlzLm1heF8wKSk7cmV0dXJuIHJ9LGwubWF4XzA9MCxsLm1pbl8wPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmludGVybmFsIiwiUmVnRXgvVG9rZW4vQ2xvc3VyZVRva2VuIiwzMTgpO2Z1bmN0aW9uIFdvZShlLG4pe3pkLmNhbGwodGhpcywxKSx0aGlzLmNoaWxkPWUsdGhpcy5jaGlsZDI9bn1wKDgzNywxMjIsam0sV29lKSxsLmdldENoaWxkPWZ1bmN0aW9uKG4pe3JldHVybiBuPT0wP3RoaXMuY2hpbGQ6dGhpcy5jaGlsZDJ9LGwuc2l6ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIDJ9LGwudG9TdHJpbmdfMT1mdW5jdGlvbihuKXt2YXIgcjtyZXR1cm4gdGhpcy5jaGlsZDIudHlwZV8wPT0zJiZ0aGlzLmNoaWxkMi5nZXRDaGlsZCgwKT09dGhpcy5jaGlsZD9yPXRoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsiKyI6dGhpcy5jaGlsZDIudHlwZV8wPT05JiZ0aGlzLmNoaWxkMi5nZXRDaGlsZCgwKT09dGhpcy5jaGlsZD9yPXRoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsiKz8iOnI9dGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKygiIit0aGlzLmNoaWxkMi50b1N0cmluZ18xKG4pKSxyfSxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9Ub2tlbi9Db25jYXRUb2tlbiIsODM3KTtmdW5jdGlvbiBDWWUoZSxuLHIsdCl7Vm4oKSx6ZC5jYWxsKHRoaXMsMjYpLHRoaXMucmVmTnVtYmVyPWUsdGhpcy5jb25kaXRpb249bix0aGlzLnllcz1yLHRoaXMubm89dH1wKDE5NDUsMTIyLGptLENZZSksbC5nZXRDaGlsZD1mdW5jdGlvbihuKXtpZihuPT0wKXJldHVybiB0aGlzLnllcztpZihuPT0xKXJldHVybiB0aGlzLm5vO3Rocm93IGIobmV3IElvKCJJbnRlcm5hbCBFcnJvcjogIituKSl9LGwuc2l6ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm8/MjoxfSxsLnRvU3RyaW5nXzE9ZnVuY3Rpb24obil7dmFyIHI7cmV0dXJuIHRoaXMucmVmTnVtYmVyPjA/cj0iKD8oIit0aGlzLnJlZk51bWJlcisiKSI6dGhpcy5jb25kaXRpb24udHlwZV8wPT04P3I9Iig/KCIrdGhpcy5jb25kaXRpb24rIikiOnI9Iig/Iit0aGlzLmNvbmRpdGlvbix0aGlzLm5vP3IrPXRoaXMueWVzKyJ8Iit0aGlzLm5vKyIpIjpyKz10aGlzLnllcysiKSIscn0sbC5yZWZOdW1iZXI9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9Ub2tlbi9Db25kaXRpb25Ub2tlbiIsMTk0NSk7ZnVuY3Rpb24gVFllKGUsbixyKXt6ZC5jYWxsKHRoaXMsMjUpLHRoaXMuY2hpbGQ9ZSx0aGlzLmFkZF8wPW4sdGhpcy5tYXNrPXJ9cCgxOTQ2LDEyMixqbSxUWWUpLGwuZ2V0Q2hpbGQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY2hpbGR9LGwuc2l6ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIDF9LGwudG9TdHJpbmdfMT1mdW5jdGlvbihuKXtyZXR1cm4iKD8iKyh0aGlzLmFkZF8wPT0wPyIiOkxvZSh0aGlzLmFkZF8wKSkrKHRoaXMubWFzaz09MD8iIjpMb2UodGhpcy5tYXNrKSkrIjoiK3RoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsiKSJ9LGwuYWRkXzA9MCxsLm1hc2s9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9Ub2tlbi9Nb2RpZmllclRva2VuIiwxOTQ2KTtmdW5jdGlvbiBqb2UoZSxuLHIpe3pkLmNhbGwodGhpcyxlKSx0aGlzLmNoaWxkPW4sdGhpcy5wYXJlbm51bWJlcj1yfXAoODM4LDEyMixqbSxqb2UpLGwuZ2V0Q2hpbGQ9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuY2hpbGR9LGwuc2l6ZV8yPWZ1bmN0aW9uKCl7cmV0dXJuIDF9LGwudG9TdHJpbmdfMT1mdW5jdGlvbihuKXt2YXIgcjtzd2l0Y2gocj1udWxsLHRoaXMudHlwZV8wKXtjYXNlIDY6dGhpcy5wYXJlbm51bWJlcj09MD9yPSIoPzoiK3RoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsiKSI6cj0iKCIrdGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyIpIjticmVhaztjYXNlIDIwOnI9Iig/PSIrdGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyIpIjticmVhaztjYXNlIDIxOnI9Iig/ISIrdGhpcy5jaGlsZC50b1N0cmluZ18xKG4pKyIpIjticmVhaztjYXNlIDIyOnI9Iig/PD0iK3RoaXMuY2hpbGQudG9TdHJpbmdfMShuKSsiKSI7YnJlYWs7Y2FzZSAyMzpyPSIoPzwhIit0aGlzLmNoaWxkLnRvU3RyaW5nXzEobikrIikiO2JyZWFrO2Nhc2UgMjQ6cj0iKD8+Iit0aGlzLmNoaWxkLnRvU3RyaW5nXzEobikrIikifXJldHVybiByfSxsLnBhcmVubnVtYmVyPTAsZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmludGVybmFsIiwiUmVnRXgvVG9rZW4vUGFyZW5Ub2tlbiIsODM4KTtmdW5jdGlvbiBSRihlLG4scil7Vm4oKSx6ZC5jYWxsKHRoaXMsZSksdGhpcy5zdHJpbmc9bix0aGlzLnJlZk51bWJlcj1yfXAoNTMwLDEyMix7MzoxLDEyMjoxLDUzMDoxfSxSRiksbC5nZXRTdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdHJpbmd9LGwudG9TdHJpbmdfMT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50eXBlXzA9PTEyPyJcXCIrdGhpcy5yZWZOdW1iZXI6bEluKHRoaXMuc3RyaW5nKX0sbC5yZWZOdW1iZXI9MCxnKCJvcmcuZWNsaXBzZS5lbWYuZWNvcmUueG1sLnR5cGUuaW50ZXJuYWwiLCJSZWdFeC9Ub2tlbi9TdHJpbmdUb2tlbiIsNTMwKTtmdW5jdGlvbiBkMShlLG4pe3ZhciByLHQsbyxpLHMsdTtpZihuKXtpZighZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW49bmV3IF94KSxlLnR5cGVfMD09Mil7Y3goZS5jaGlsZHJlbixuKTtyZXR1cm59aWYobi50eXBlXzA9PTEpe2ZvcihvPTA7bzxuLnNpemVfMigpO28rKylkMShlLG4uZ2V0Q2hpbGQobykpO3JldHVybn1pZih1PWUuY2hpbGRyZW4uYXJyYXlMaXN0LmFycmF5Lmxlbmd0aCx1PT0wKXtjeChlLmNoaWxkcmVuLG4pO3JldHVybn1pZihzPWEoTTEoZS5jaGlsZHJlbix1LTEpLDEyMiksISgocy50eXBlXzA9PTB8fHMudHlwZV8wPT0xMCkmJihuLnR5cGVfMD09MHx8bi50eXBlXzA9PTEwKSkpe2N4KGUuY2hpbGRyZW4sbik7cmV0dXJufWk9bi50eXBlXzA9PTA/MjpuLmdldFN0cmluZygpLmxlbmd0aCxzLnR5cGVfMD09MD8ocj1uZXcgQjIsdD1zLmdldENoYXIoKSx0Pj1GdD9KdChyLGtvZSh0KSk6dXkocix0JnpyKSxzPW5ldyBSRigxMCxudWxsLDApLHpRZShlLmNoaWxkcmVuLHMsdS0xKSk6KHI9KHMuZ2V0U3RyaW5nKCkubGVuZ3RoK2ksbmV3IEIyKSxKdChyLHMuZ2V0U3RyaW5nKCkpKSxuLnR5cGVfMD09MD8odD1uLmdldENoYXIoKSx0Pj1GdD9KdChyLGtvZSh0KSk6dXkocix0JnpyKSk6SnQocixuLmdldFN0cmluZygpKSxhKHMsNTMwKS5zdHJpbmc9ci5zdHJpbmd9fWZ1bmN0aW9uICRTKGUpe1ZuKCksemQuY2FsbCh0aGlzLGUpfXAoNDc3LDEyMixqbSwkUyksbC5hZGRDaGlsZD1mdW5jdGlvbihuKXtkMSh0aGlzLG4pfSxsLmdldENoaWxkPWZ1bmN0aW9uKG4pe3JldHVybiBhKE0xKHRoaXMuY2hpbGRyZW4sbiksMTIyKX0sbC5zaXplXzI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZHJlbj90aGlzLmNoaWxkcmVuLmFycmF5TGlzdC5hcnJheS5sZW5ndGg6MH0sbC50b1N0cmluZ18xPWZ1bmN0aW9uKG4pe3ZhciByLHQsbyxpLHM7aWYodGhpcy50eXBlXzA9PTEpe2lmKHRoaXMuY2hpbGRyZW4uYXJyYXlMaXN0LmFycmF5Lmxlbmd0aD09MilyPWEoTTEodGhpcy5jaGlsZHJlbiwwKSwxMjIpLHQ9YShNMSh0aGlzLmNoaWxkcmVuLDEpLDEyMiksdC50eXBlXzA9PTMmJnQuZ2V0Q2hpbGQoMCk9PXI/aT1yLnRvU3RyaW5nXzEobikrIisiOnQudHlwZV8wPT05JiZ0LmdldENoaWxkKDApPT1yP2k9ci50b1N0cmluZ18xKG4pKyIrPyI6aT1yLnRvU3RyaW5nXzEobikrKCIiK3QudG9TdHJpbmdfMShuKSk7ZWxzZXtmb3Iocz1uZXcgTGMsbz0wO288dGhpcy5jaGlsZHJlbi5hcnJheUxpc3QuYXJyYXkubGVuZ3RoO28rKylKdChzLGEoTTEodGhpcy5jaGlsZHJlbixvKSwxMjIpLnRvU3RyaW5nXzEobikpO2k9cy5zdHJpbmd9cmV0dXJuIGl9aWYodGhpcy5jaGlsZHJlbi5hcnJheUxpc3QuYXJyYXkubGVuZ3RoPT0yJiZhKE0xKHRoaXMuY2hpbGRyZW4sMSksMTIyKS50eXBlXzA9PTcpaT1hKE0xKHRoaXMuY2hpbGRyZW4sMCksMTIyKS50b1N0cmluZ18xKG4pKyI/IjtlbHNlIGlmKHRoaXMuY2hpbGRyZW4uYXJyYXlMaXN0LmFycmF5Lmxlbmd0aD09MiYmYShNMSh0aGlzLmNoaWxkcmVuLDApLDEyMikudHlwZV8wPT03KWk9YShNMSh0aGlzLmNoaWxkcmVuLDEpLDEyMikudG9TdHJpbmdfMShuKSsiPz8iO2Vsc2V7Zm9yKHM9bmV3IExjLEp0KHMsYShNMSh0aGlzLmNoaWxkcmVuLDApLDEyMikudG9TdHJpbmdfMShuKSksbz0xO288dGhpcy5jaGlsZHJlbi5hcnJheUxpc3QuYXJyYXkubGVuZ3RoO28rKylzLnN0cmluZys9InwiLEp0KHMsYShNMSh0aGlzLmNoaWxkcmVuLG8pLDEyMikudG9TdHJpbmdfMShuKSk7aT1zLnN0cmluZ31yZXR1cm4gaX0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLmludGVybmFsIiwiUmVnRXgvVG9rZW4vVW5pb25Ub2tlbiIsNDc3KTtmdW5jdGlvbiBjaShlLG4pe3ZhciByLHQsbyxpLHMsdSxjO2lmKGU9PW51bGwpcmV0dXJuIG51bGw7aWYoaT1lLmxlbmd0aCxpPT0wKXJldHVybiIiO2ZvcihjPUIoZmwsWHMsMjgsaSwxNSwxKSxndCgwLGksZS5sZW5ndGgpLGd0KDAsaSxjLmxlbmd0aCksZ2NlKGUsMCxpLGMsMCkscj1udWxsLHU9bixvPTAscz0wO288aTtvKyspdD1jW29dLGlZZSgpLHQ8PTMyJiZOW3RdJjI/dT8oIXImJihyPW5ldyB5bChlKSkseVplKHIsby1zKyspKToodT1uLHQhPTMyJiYoIXImJihyPW5ldyB5bChlKSksTjUocixvLXMsby1zKzEsIiAiKSkpOnU9ITE7cmV0dXJuIHU/cj8oaT1yLnN0cmluZy5sZW5ndGgsaT4wP1lhKHIuc3RyaW5nLDAsaS0xKToiIik6KGd0KDAsaS0xLGUubGVuZ3RoKSxlLnN1YnN0cigwLGktMSkpOnI/ci5zdHJpbmc6ZX1mdW5jdGlvbiBCYihlKXt0aGlzLnJlZ3VsYXJFeHByZXNzaW9uPW5ldyBTWWUoZSl9cCg1MjcsMSx7NjAwOjF9LEJiKSxsLnRvU3RyaW5nXzA9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWd1bGFyRXhwcmVzc2lvbi5yZWdleH0sZygib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnhtbC50eXBlLnV0aWwiLCJYTUxUeXBlVXRpbC9QYXR0ZXJuTWF0Y2hlckltcGwiLDUyNyk7ZnVuY3Rpb24gVm9lKCl7Vm9lPUYsVEYoKSxJWWU9bmV3IGJZZSxQKEkoYm0sMiksWCwzODEsMCxbUChJKGJtLDEpLFpiLDYwMCwwLFtuZXcgQmIoIlthLXpBLVpdezEsOH0oLVthLXpBLVowLTldezEsOH0pKiIpXSldKSxQKEkoYm0sMiksWCwzODEsMCxbUChJKGJtLDEpLFpiLDYwMCwwLFtuZXcgQmIoIlxcaVxcYyoiKV0pXSksUChJKGJtLDIpLFgsMzgxLDAsW1AoSShibSwxKSxaYiw2MDAsMCxbbmV3IEJiKCJbXFxpLVs6XV1bXFxjLVs6XV0qIildKSxQKEkoYm0sMSksWmIsNjAwLDAsW25ldyBCYigiXFxpXFxjKiIpXSldKSxuZXcgVDAoIi0xIiksUChJKGJtLDIpLFgsMzgxLDAsW1AoSShibSwxKSxaYiw2MDAsMCxbbmV3IEJiKCJcXGMrIildKV0pLG5ldyBUMCgiMCIpLG5ldyBUMCgiMCIpLG5ldyBUMCgiMSIpLG5ldyBUMCgiMCIpLG5ldyBUMCgiMTg0NDY3NDQwNzM3MDk1NTE2MTUiKX1mdW5jdGlvbiBiWWUoKXt9cCgxNzA3LDE1Mjcse30sYlllKTt2YXIgSVllO2coIm9yZy5lY2xpcHNlLmVtZi5lY29yZS54bWwudHlwZS51dGlsIiwiWE1MVHlwZVZhbGlkYXRvciIsMTcwNyk7ZnVuY3Rpb24gc18oKXtzXz1GLHVfPW5ldyB4WWV9ZnVuY3Rpb24gZjEoZSl7c18oKSx0aGlzLmZpcnN0PTAsdGhpcy5sYXN0PWUtMSx0aGlzLnN0ZXA9MX1wKDI3MCwxLFR1LGYxKSxsLmZvckVhY2hfMD1mdW5jdGlvbihuKXtFdCh0aGlzLG4pfSxsLml0ZXJhdG9yXzA9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5sYXN0LXRoaXMuZmlyc3QpKnRoaXMuc3RlcDwwP3VfOm5ldyBjXyh0aGlzKX0sbC5maXJzdD0wLGwubGFzdD0wLGwuc3RlcD0wO3ZhciB1XztnKCJvcmcuZWNsaXBzZS54dGV4dC54YmFzZS5saWIiLCJFeGNsdXNpdmVSYW5nZSIsMjcwKTtmdW5jdGlvbiBnSW4oKXt0aHJvdyBiKG5ldyBrYygiQ2Fubm90IGFkZCBlbGVtZW50cyB0byBhIFJhbmdlIikpfWZ1bmN0aW9uIGhJbigpe3Rocm93IGIobmV3IFBvKX1mdW5jdGlvbiBtSW4oKXt0aHJvdyBiKG5ldyBQbyl9ZnVuY3Rpb24geUluKCl7dGhyb3cgYihuZXcga2MoIkNhbm5vdCBzZXQgZWxlbWVudHMgaW4gYSBSYW5nZSIpKX1mdW5jdGlvbiB4WWUoKXt9cCgxMDg0LDEsQ3UseFllKSxsLmFkZF8xPWZ1bmN0aW9uKG4pe2EobiwxNyksZ0luKCl9LGwuZm9yRWFjaFJlbWFpbmluZz1mdW5jdGlvbihuKXt3dCh0aGlzLG4pfSxsLm5leHRfMT1mdW5jdGlvbigpe3JldHVybiBoSW4oKX0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7cmV0dXJuIG1JbigpfSxsLnNldF8xPWZ1bmN0aW9uKG4pe2EobiwxNykseUluKCl9LGwuaGFzTmV4dF8wPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sbC5uZXh0SW5kZXhfMD1mdW5jdGlvbigpe3JldHVybi0xfSxsLnByZXZpb3VzSW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4tMX0sbC5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBiKG5ldyBrYygiQ2Fubm90IHJlbW92ZSBlbGVtZW50cyBmcm9tIGEgUmFuZ2UiKSl9LGcoIm9yZy5lY2xpcHNlLnh0ZXh0LnhiYXNlLmxpYiIsIkV4Y2x1c2l2ZVJhbmdlLzEiLDEwODQpO2Z1bmN0aW9uIHdJbigpe3Rocm93IGIobmV3IGtjKCJDYW5ub3QgYWRkIGVsZW1lbnRzIHRvIGEgUmFuZ2UiKSl9ZnVuY3Rpb24gRUluKGUpe3ZhciBuO2lmKCEoZS50aGlzJDAxLnN0ZXA8MD9lLm5leHRfMD49ZS50aGlzJDAxLmxhc3Q6ZS5uZXh0XzA8PWUudGhpcyQwMS5sYXN0KSl0aHJvdyBiKG5ldyBQbyk7cmV0dXJuIG49ZS5uZXh0XzAsZS5uZXh0XzArPWUudGhpcyQwMS5zdGVwLCsrZS5uZXh0SW5kZXgsSihuKX1mdW5jdGlvbiB2SW4oZSl7aWYoZS5uZXh0SW5kZXg8PTApdGhyb3cgYihuZXcgUG8pO3JldHVybi0tZS5uZXh0SW5kZXgsZS5uZXh0XzAtPWUudGhpcyQwMS5zdGVwLEooZS5uZXh0XzApfWZ1bmN0aW9uIFNJbigpe3Rocm93IGIobmV3IGtjKCJDYW5ub3Qgc2V0IGVsZW1lbnRzIGluIGEgUmFuZ2UiKSl9ZnVuY3Rpb24gY18oZSl7dGhpcy50aGlzJDAxPWUsdGhpcy5uZXh0XzA9dGhpcy50aGlzJDAxLmZpcnN0fXAoMjU4LDEsQ3UsY18pLGwuYWRkXzE9ZnVuY3Rpb24obil7YShuLDE3KSx3SW4oKX0sbC5mb3JFYWNoUmVtYWluaW5nPWZ1bmN0aW9uKG4pe3d0KHRoaXMsbil9LGwubmV4dF8xPWZ1bmN0aW9uKCl7cmV0dXJuIEVJbih0aGlzKX0sbC5wcmV2aW91c18wPWZ1bmN0aW9uKCl7cmV0dXJuIHZJbih0aGlzKX0sbC5zZXRfMT1mdW5jdGlvbihuKXthKG4sMTcpLFNJbigpfSxsLmhhc05leHRfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoaXMkMDEuc3RlcDwwP3RoaXMubmV4dF8wPj10aGlzLnRoaXMkMDEubGFzdDp0aGlzLm5leHRfMDw9dGhpcy50aGlzJDAxLmxhc3R9LGwuaGFzUHJldmlvdXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0SW5kZXg+MH0sbC5uZXh0SW5kZXhfMD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHRJbmRleH0sbC5wcmV2aW91c0luZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dEluZGV4LTF9LGwucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgYihuZXcga2MoIkNhbm5vdCByZW1vdmUgZWxlbWVudHMgZnJvbSBhIFJhbmdlIikpfSxsLm5leHRfMD0wLGwubmV4dEluZGV4PTAsZygib3JnLmVjbGlwc2UueHRleHQueGJhc2UubGliIiwiRXhjbHVzaXZlUmFuZ2UvUmFuZ2VJdGVyYXRvciIsMjU4KTtmdW5jdGlvbiBDSW4oZSxuKXtiSW4obmV3IFllKGUpLG4pfWZ1bmN0aW9uIFBZZShlKXtyZXR1cm4gZT9lLmlzRW1wdHkoKTohZS5pdGVyYXRvcl8wKCkuaGFzTmV4dF8wKCl9ZnVuY3Rpb24gR2IoZSl7cmV0dXJuIWV8fFBZZShlKX1mdW5jdGlvbiBUSW4oZSxuKXtmb3IoO2UuZGF0YV8wPT1udWxsJiYhZS5pbmNsdWRlUm9vdD9ycmUoZSk6ZS5kYXRhXzA9PW51bGx8fGUuc2l6ZV8wIT0wJiZhKGUuZGF0YV8wW2Uuc2l6ZV8wLTFdLDUxKS5oYXNOZXh0XzAoKTspU1NuKG4sZUwoZSkpfWZ1bmN0aW9uIGJJbihlLG4pe3ZhciByO2ZvcihyPTA7ZS5jdXJzb3IhPWUudGhpcyQwMV8yLnNpemVfMSgpOylDU24obixlbihlKSxKKHIpKSxyIT1xbiYmKytyfXZhciBmbD1WbSgiY2hhciIsIkMiKSxobj1WbSgiaW50IiwiSSIpLHlhPVZtKCJib29sZWFuIiwiWiIpLF9fPVZtKCJsb25nIiwiSiIpLEppPVZtKCJieXRlIiwiQiIpLGN0PVZtKCJkb3VibGUiLCJEIikscHA9Vm0oImZsb2F0IiwiRiIpLFhnPVZtKCJzaG9ydCIsIlMiKSxJSW49Q3IoIm9yZy5lY2xpcHNlLmVsay5jb3JlLmxhYmVscyIsIklMYWJlbE1hbmFnZXIiKSxxb2U9Q3IoIm9yZy5lY2xpcHNlLmVtZi5jb21tb24udXRpbCIsIkRpYWdub3N0aWNDaGFpbiIpLFlvZT1Dcigib3JnLmVjbGlwc2UuZW1mLmVjb3JlLnJlc291cmNlIiwiUmVzb3VyY2VTZXQiKSxLb2U9Zygib3JnLmVjbGlwc2UuZW1mLmNvbW1vbi51dGlsIiwiSW52b2NhdGlvblRhcmdldEV4Y2VwdGlvbiIsbnVsbCksTlllPShOSSgpLE1YZSksQVllPUFZZT1SWWU7RFllKFpKZSksTVllKCJwZXJtUHJvcHMiLFtbWyJsb2NhbGUiLCJkZWZhdWx0Il0sWyJ1c2VyLmFnZW50IiwiZ2Vja28xXzgiXV0sW1sibG9jYWxlIiwiZGVmYXVsdCJdLFsidXNlci5hZ2VudCIsInNhZmFyaSJdXV0pLEFZZShudWxsLCJlbGsiLG51bGwpfSkoWm9lLFpvZS5leHBvcnRzKX0pKCk7Cg==", Z_ = (l) => Uint8Array.from(atob(l), (Z) => Z.charCodeAt(0)), II = typeof self < "u" && self.Blob && new Blob([Z_(sF)], { type: "text/javascript;charset=utf-8" });
function c_(l) {
  let Z;
  try {
    if (Z = II && (self.URL || self.webkitURL).createObjectURL(II), !Z) throw "";
    const u = new Worker(Z, {
      name: l == null ? void 0 : l.name
    });
    return u.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(Z);
    }), u;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + sF,
      {
        name: l == null ? void 0 : l.name
      }
    );
  } finally {
    Z && (self.URL || self.webkitURL).revokeObjectURL(Z);
  }
}
const b_ = {
  "elk.algorithm": "layered",
  "elk.direction": "DOWN",
  // This seems to result in a more compact layout
  "elk.layered.nodePlacement.strategy": "NETWORK_SIMPLEX",
  "elk.layered.mergeEdges": "true"
  // Can you use spline routing instead which generates non orthogonal edges
  // "elk.edgeRouting": "SPLINES",
  // "elk.layered.edgeRouting.splines.mode": "CONSERVATIVE",
}, Hi = 5, u_ = {
  "elk.algorithm": "layered",
  "elk.direction": "DOWN",
  "elk.spacing.componentComponent": Hi.toString(),
  "elk.spacing.nodeNode": Hi.toString(),
  "elk.padding": `[top=${Hi},left=${Hi},bottom=${Hi},right=${Hi}]`,
  "elk.spacing.portPort": "0",
  // allow ports on e-class to be anywhere
  // TODO: they only seem to appear on top side of nodes, figure out if there is a way to allow them
  // to be on all sides if it would result in a better layout
  portConstraints: "FREE"
}, UI = {
  "elk.layered.cycleBreaking.strategy": "INTERACTIVE",
  "elk.layered.layering.strategy": "INTERACTIVE",
  "elk.layered.nodePlacement.strategy": "INTERACTIVE"
  // Had to disable or leads to weird edges
  // "elk.layered.crossingMinimization.semiInteractive": "true",
  // "elk.layered.crossingMinimization.strategy": "INTERACTIVE",
}, s_ = {
  portConstraints: "FIXED_ORDER"
}, d_ = [...LV("pastel1"), ...LV("pastel2")];
async function G_(l, Z, u, s, G, i, m) {
  const a = JSON.parse(l), { elkNode: n, colors: p } = m_(a, Z, s, u, G, i), y = JSON.stringify(n, null, 2), h = await i_(n, m), S = e_(h), t = o_(h), W = new Map(
    [...Object.entries(Object.groupBy(S, (R) => R.source)), ...Object.entries(Object.groupBy(S, (R) => R.target))].map(
      ([R, x]) => [R, (x || []).map((r) => r.id)]
    )
  ), V = new Map(S.map((R) => [R.id, [R.source, R.target]]));
  return {
    layout: { layout: h, colors: p },
    elkJSON: y,
    nodes: t,
    edges: S,
    edgeToNodes: V,
    nodeToEdges: W
  };
}
function m_(l, Z, u, s, G, i) {
  var W;
  const m = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  for (const [V, R] of Object.entries(l.nodes))
    m.set(V, R.eclass), a.has(R.eclass) || a.set(R.eclass, []), a.get(R.eclass).push([V, R]);
  if (u) {
    const V = /* @__PURE__ */ new Set();
    if (u.type === "class")
      V.add(u.id);
    else {
      const x = m.get(u.id);
      V.add(x), a.set(x, [[u.id, l.nodes[u.id]]]);
    }
    const R = /* @__PURE__ */ new Set();
    for (; V.size > 0; ) {
      const x = V.values().next().value;
      V.delete(x), R.add(x);
      for (const r of a.get(x).flatMap(([, k]) => k.children || [])) {
        const k = l.nodes[r].eclass;
        R.has(k) || V.add(k);
      }
    }
    for (const x of a.keys())
      R.has(x) || a.delete(x);
  }
  const n = /* @__PURE__ */ new Map();
  for (const [V, R] of [...a.values()].flatMap((x) => x))
    for (const [x, r] of (R.children || []).entries()) {
      const k = m.get(r);
      n.has(k) || n.set(k, []), n.get(k).push({ nodeID: V, index: x });
    }
  const p = l.class_data || {}, y = [
    ...new Set(
      Object.values(p).map(({ type: V }) => V).filter((V) => V)
    )
  ].sort(), h = [...d_], S = /* @__PURE__ */ new Map([[void 0, null]]);
  if (G)
    for (const [V, R] of G.colors.entries())
      y.includes(V) && R && (S.set(V, R), h.splice(h.indexOf(R), 1), y.splice(y.indexOf(V), 1));
  for (const [V, R] of y.entries())
    S.set(R, h[V % h.length]);
  const t = {
    id: "--eclipse-layout-kernel-root",
    layoutOptions: b_,
    children: [],
    edges: []
  };
  t.layoutOptions["elk.aspectRatio"] = s;
  for (const [V, R] of a.entries()) {
    const r = {
      id: `class-${V}`,
      data: { color: S.get((W = p[V]) == null ? void 0 : W.type), id: V },
      layoutOptions: u_,
      children: [],
      ports: i ? [] : (n.get(V) || []).map(({ nodeID: k, index: U }) => ({
        id: `port-class-incoming-${k}-${U}`
      })),
      edges: []
    };
    t.children.push(r);
    for (const [k, U] of R) {
      const w = Z(U.op), z = `node-${k}`, D = {
        id: z,
        data: { label: U.op, id: k },
        width: w.width,
        height: w.height,
        ports: [],
        labels: [{ text: U.op }],
        layoutOptions: s_
      };
      r.children.push(D);
      const C = Object.keys(U.children || []).length;
      for (const [j, E] of (U.children || []).entries()) {
        const g = `${k}-${j}`, A = `class-${m.get(E)}`, J = `port-node-${g}`, F = `port-class-incoming-${g}`, v = `port-class-outgoing-${g}`, T = `edge-inner-${g}`, f = `edge-outer-${g}`;
        D.ports.push({
          id: J,
          layoutOptions: {
            "port.side": "SOUTH",
            /// index is clockwise from top right, so we need to the reverse index, so that first port is on the left
            "port.index": (C - j - 1).toString()
          }
        }), r.ports.push({ id: v }), r.edges.push({
          id: T,
          edgeID: g,
          sourceNode: z,
          targetNode: A,
          sources: [J],
          targets: [v]
        }), t.edges.push({
          id: f,
          edgeID: g,
          sourceNode: z,
          targetNode: A,
          sources: [v],
          targets: [i ? A : F]
        });
      }
    }
  }
  if (G) {
    const V = G.layout, R = new Set(V.children.map(({ data: r }) => r.id)), x = Object.groupBy(
      t.children,
      ({ data: r }) => R.has(r.id).toString()
    );
    if ((x.false || []).length > (x.true || []).length)
      return { elkNode: t, colors: S };
    t.layoutOptions = { ...t.layoutOptions, ...UI };
    for (const r of t.children) {
      const k = V.children.find(({ id: U }) => U === r.id);
      if (k) {
        r.layoutOptions = { ...r.layoutOptions, ...UI }, r.x = k.x, r.y = k.y;
        for (const U of r.ports || []) {
          const w = (k.ports || []).find(({ id: z }) => z === U.id);
          w && (U.x = w.x, U.y = w.y);
        }
        for (const U of r.children) {
          const w = k.children.find(({ id: z }) => z === U.id);
          if (w) {
            for (const z of U.ports || []) {
              const D = (w.ports || []).find(({ id: C }) => C === z.id);
              D && (z.x = D.x, z.y = D.y);
            }
            U.x = w.x, U.y = w.y;
          }
        }
      }
    }
  }
  return { elkNode: t, colors: S };
}
function i_(l, Z) {
  return new Promise((u, s) => {
    Z.aborted && s(Z.reason);
    const G = new l_({
      workerFactory: () => new c_(),
      workerUrl: ""
    });
    Z.addEventListener("abort", () => {
      G.terminateWorker(), s(Z.reason);
    }), G.layout(l).then(u, s);
  });
}
function o_(l) {
  return l.children.flatMap(({ children: Z, x: u, y: s, data: G, id: i, height: m, width: a }) => [
    { position: { x: u, y: s }, data: G, id: i, type: "class", height: m, width: a },
    ...Z.map(({ x: n, y: p, height: y, width: h, data: S, id: t }) => ({
      data: S,
      id: t,
      type: "node",
      parentId: i,
      position: { x: n, y: p },
      width: h,
      height: y
    }))
  ]);
}
function e_(l) {
  const Z = Object.fromEntries(l.edges.map(({ edgeID: u, sections: s }) => [u, s[0]]));
  return l.children.flatMap(
    ({ x: u, y: s, edges: G }) => G.map(({ edgeID: i, sections: m, sourceNode: a, targetNode: n }) => {
      const [p] = m, y = Z[i], h = [p.startPoint, ...p.bendPoints || [], p.endPoint].map(({ x: S, y: t }) => ({
        x: S + u,
        y: t + s
      }));
      return {
        type: "edge",
        id: i,
        source: a,
        target: n,
        data: {
          // Combien inner and outer edge show it just shows up once in the rendering and can be selected as a single unit.
          points: [...h, ...y.bendPoints || [], y.endPoint]
        }
      };
    })
  );
}
const dF = new B7();
function a_(l) {
  return /* @__PURE__ */ B.jsx(
    lB,
    {
      ...l,
      className: Um(
        l.className,
        "flex flex-col gap-2 orientation-horizontal:min-w-64 orientation-vertical:items-center"
      )
    }
  );
}
const CI = [
  "absolute top-[50%] translate-y-[-50%] rounded-full",
  "group-orientation-horizontal:h-1",
  "group-orientation-horizontal:w-full",
  "group-orientation-vertical:left-[50%]",
  "group-orientation-vertical:h-full",
  "group-orientation-vertical:w-[6px]",
  "group-orientation-vertical:translate-x-[-50%]",
  "group-orientation-vertical:translate-y-[-50%]",
  "group-disabled:opacity-50"
];
function n_({ thumbLabels: l }) {
  return /* @__PURE__ */ B.jsx(uB, { className: "group relative flex w-full items-center orientation-horizontal:h-7 orientation-vertical:h-44 orientation-vertical:w-7", children: ({ state: Z, orientation: u }) => /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    /* @__PURE__ */ B.jsx(
      "div",
      {
        className: lb("bg-zinc-200 dark:bg-zinc-300", CI)
      }
    ),
    /* @__PURE__ */ B.jsx(
      "div",
      {
        className: lb("bg-accent", CI),
        style: p_(Z, u)
      }
    ),
    Z.values.map((s, G) => /* @__PURE__ */ B.jsx(
      dB,
      {
        index: G,
        "aria-label": l == null ? void 0 : l[G],
        className: Um("", [
          "size-5 rounded-full border bg-white shadow-xl dark:border-0",
          "group-orientation-horizontal:top-[50%] group-orientation-vertical:left-[50%]",
          "dragging:border-8  dragging:border-accent",
          "disabled:cursor-not-allowed",
          NV
        ])
      },
      G
    ))
  ] }) });
}
function p_(l, Z) {
  const u = l.values.length == 2, s = u ? (l.getThumbPercent(1) - l.getThumbPercent(0)) * 100 + "%" : l.getThumbPercent(0) * 100 + "%", G = u ? l.getThumbPercent(0) * 100 + "%" : "0";
  return Z === "horizontal" ? {
    width: s,
    left: G
  } : {
    height: s,
    bottom: G,
    top: "auto",
    transform: "translate(-50%,0px)"
  };
}
function L_({ data: l, selected: Z }) {
  return /* @__PURE__ */ B.jsxs(
    "div",
    {
      className: `rounded-md border-dotted border-black h-full w-full ${Z ? "border-2" : "border"}`,
      style: { backgroundColor: l.color || "white" },
      title: l.id,
      children: [
        /* @__PURE__ */ B.jsx(mF, { type: "class", id: l.id }),
        /* @__PURE__ */ B.jsx(Rm, { type: "target", position: Tl.Top, className: "invisible" }),
        /* @__PURE__ */ B.jsx(Rm, { type: "source", position: Tl.Bottom, className: "invisible" })
      ]
    }
  );
}
function GF(l) {
  var Z, u, s;
  return /* @__PURE__ */ B.jsxs(
    "div",
    {
      className: `p-1 rounded-md outline bg-white outline-black h-full w-full ${l != null && l.selected ? "outline-2" : "outline-1"}`,
      ref: l == null ? void 0 : l.outerRef,
      children: [
        l != null && l.outerRef ? /* @__PURE__ */ B.jsx(B.Fragment, {}) : /* @__PURE__ */ B.jsx(mF, { type: "node", id: l.data.id }),
        /* @__PURE__ */ B.jsx(
          "div",
          {
            className: "font-mono text-xs truncate max-w-96 min-w-4 text-center",
            title: `${(Z = l == null ? void 0 : l.data) == null ? void 0 : Z.id}
${(u = l == null ? void 0 : l.data) == null ? void 0 : u.label}`,
            ref: l == null ? void 0 : l.innerRef,
            children: (s = l == null ? void 0 : l.data) == null ? void 0 : s.label
          }
        ),
        l != null && l.outerRef ? /* @__PURE__ */ B.jsx(B.Fragment, {}) : /* @__PURE__ */ B.jsx(Rm, { type: "source", position: Tl.Bottom, className: "invisible" })
      ]
    }
  );
}
function mF(l) {
  const Z = M.useContext(Fx), u = M.useCallback(() => Z(l), [Z, l]);
  return /* @__PURE__ */ B.jsx(W7, { position: Tl.Top, children: /* @__PURE__ */ B.jsx(
    "button",
    {
      onClick: u,
      className: "rounded bg-white px-2 py-1 text-xs font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50",
      children: "Filter"
    }
  ) });
}
function h_({ data: l, ...Z }) {
  const { points: u } = l, s = u.map(({ x: G, y: i }, m) => `${m === 0 ? "M" : "L"} ${G} ${i}`).join(" ");
  return /* @__PURE__ */ B.jsx(Kn, { ...Z, path: s, style: { stroke: "black", strokeWidth: Z.selected ? 1 : 0.5 } });
}
const y_ = {
  class: M.memo(L_),
  node: M.memo(GF)
}, S_ = {
  edge: M.memo(h_)
}, Fx = M.createContext(null);
function rI(l, Z) {
  let u = null;
  for (const s of l) {
    if (s.type !== "select")
      continue;
    const G = Z.has(s.id);
    s.selected ? G || (u || (u = new Set(Z)), u.add(s.id)) : G && (u || (u = new Set(Z)), u.delete(s.id));
  }
  return u;
}
const t_ = { markerEnd: { type: qa.ArrowClosed, color: "black" } }, X_ = { hideAttribution: !0 };
function K_({
  nodes: l,
  edges: Z,
  selectedNode: u,
  nodeToEdges: s,
  edgeToNodes: G,
  elkJSON: i,
  useInteractiveLayout: m,
  setUseInteractiveLayout: a,
  mergeEdges: n,
  setMergeEdges: p
}) {
  const [y, h] = M.useState(/* @__PURE__ */ new Set()), [S, t] = M.useState(/* @__PURE__ */ new Set()), W = M.useRef(!1), V = M.useMemo(
    () => l.map((E) => ({ ...E, selected: S.has(E.id) })),
    [l, S]
  ), R = M.useMemo(
    () => Z.map((E) => ({ ...E, selected: y.has(E.id) })),
    [Z, y]
  ), x = M.useCallback(
    (E) => {
      const g = rI(E, S);
      if (g) {
        const A = [...g].flatMap((J) => s.get(J));
        t(g), h(new Set(A)), W.current = !0;
      }
    },
    [S, t, s, h]
  ), r = M.useCallback(
    (E) => {
      const g = rI(E, y);
      if (g) {
        const A = [...g].flatMap((J) => G.get(J));
        t(new Set(A)), h(g), W.current = !0;
      }
    },
    [y, h, G, t]
  ), k = M.useContext(Fx), U = M.useCallback(() => k(null), [k]), w = sy(), z = QA();
  M.useEffect(() => {
    z && (W.current ? W.current = !1 : w.fitView({ padding: 0.1, duration: 1e3 }));
  }, [z, w, W]);
  const [D, C] = M.useState(!1), j = k7();
  return /* @__PURE__ */ B.jsxs(
    BA,
    {
      nodes: V,
      nodeTypes: y_,
      edgeTypes: S_,
      edges: R,
      minZoom: 0.05,
      maxZoom: 10,
      nodesDraggable: !1,
      nodesConnectable: !1,
      nodesFocusable: !0,
      onNodesChange: x,
      onEdgesChange: r,
      defaultEdgeOptions: t_,
      proOptions: X_,
      children: [
        u ? /* @__PURE__ */ B.jsx(Zn, { position: "top-center", children: /* @__PURE__ */ B.jsx(
          "button",
          {
            className: "rounded bg-white px-2 py-1 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50 hover:shadow-md hover:ring-gray-400 transition-all duration-200",
            onClick: U,
            children: "Reset filter"
          }
        ) }) : /* @__PURE__ */ B.jsx(B.Fragment, {}),
        /* @__PURE__ */ B.jsx(Zn, { position: "top-right", children: /* @__PURE__ */ B.jsxs(aB, { children: [
          /* @__PURE__ */ B.jsx(V7, { onPress: () => C((E) => !E), noIndicator: !0, variant: "plain", isIconOnly: !0, children: /* @__PURE__ */ B.jsx(nG, { "aria-label": "Open setting menu", children: /* @__PURE__ */ B.jsx(hD, { className: "size-6" }) }) }),
          /* @__PURE__ */ B.jsx(x7, { placement: "bottom right", isOpen: D, onOpenChange: C, children: /* @__PURE__ */ B.jsxs(R7, { children: [
            /* @__PURE__ */ B.jsxs(
              _K,
              {
                onAction: M.useCallback(
                  () => a(!m),
                  [a, m]
                ),
                className: "cursor-pointer",
                children: [
                  /* @__PURE__ */ B.jsx(nG, { children: m ? /* @__PURE__ */ B.jsx(mD, {}) : /* @__PURE__ */ B.jsx(dD, {}) }),
                  /* @__PURE__ */ B.jsx(lW, { children: "Interactive layout" }),
                  /* @__PURE__ */ B.jsx(ZW, { children: m ? "Layout independently of previous positions" : "Layout interactively based on previous positions" })
                ]
              }
            ),
            /* @__PURE__ */ B.jsxs(_K, { onAction: M.useCallback(() => p(!n), [p, n]), className: "cursor-pointer", children: [
              /* @__PURE__ */ B.jsx(nG, { children: n ? /* @__PURE__ */ B.jsx(aD, {}) : /* @__PURE__ */ B.jsx(oD, {}) }),
              /* @__PURE__ */ B.jsx(lW, { children: "Merge edges" }),
              /* @__PURE__ */ B.jsx(ZW, { children: n ? "Seperate ports for incoming edges" : "Merge all incoming edges" })
            ] }),
            /* @__PURE__ */ B.jsx(Y7, {}),
            /* @__PURE__ */ B.jsxs(_K, { onAction: M.useCallback(() => j.copy(i), [i, j]), className: "cursor-pointer", children: [
              /* @__PURE__ */ B.jsx(nG, { children: /* @__PURE__ */ B.jsx(pD, {}) }),
              /* @__PURE__ */ B.jsx(lW, { children: "Copy ELK" }),
              /* @__PURE__ */ B.jsx(ZW, { children: j.copied ? "Copied ELK JSON to clipboard" : j.error ? `Failed to copy ELK JSON to clipboard ${j.error.message}` : "Copy ELK JSON to clipboard" })
            ] })
          ] }) })
        ] }) }),
        /* @__PURE__ */ B.jsx(u7, {})
      ]
    }
  );
}
function W_({
  egraph: l,
  outerElem: Z,
  innerElem: u,
  aspectRatio: s,
  firstEgraph: G
}) {
  const [i, m] = M.useState(!1), [a, n] = M.useState(!1), p = M.useRef(null), [y, h] = M.useState(null), S = M.useMemo(() => y && y.firstEgraph === G ? y : null, [y, G]), t = M.useCallback(
    (z) => {
      h(z ? { ...z, firstEgraph: G } : null);
    },
    [h, G]
  ), W = M.useCallback(
    (z) => (u.innerText = z, Z.getBoundingClientRect()),
    [Z, u]
  ), V = i ? p.current : null, R = m6({
    queryKey: ["layout", l, W, s, S, V, a],
    networkMode: "always",
    queryFn: ({ signal: z }) => G_(l, W, s, S, V, a, z),
    staleTime: 1 / 0,
    retry: !1,
    retryOnMount: !1,
    placeholderData: U7
  });
  if (M.useEffect(() => {
    R.status === "success" && (p.current = R.data.layout);
  }, [R.status, R.data]), R.isError)
    return /* @__PURE__ */ B.jsxs("div", { className: "p-4", children: [
      "Error: ",
      R.error.message
    ] });
  if (R.isPending)
    return /* @__PURE__ */ B.jsx(f2, {});
  const { nodes: x, edges: r, elkJSON: k, nodeToEdges: U, edgeToNodes: w } = R.data;
  return /* @__PURE__ */ B.jsxs(B.Fragment, { children: [
    R.isFetching ? /* @__PURE__ */ B.jsx(f2, {}) : /* @__PURE__ */ B.jsx(B.Fragment, {}),
    /* @__PURE__ */ B.jsx(Fx.Provider, { value: t, children: /* @__PURE__ */ B.jsx(er, { children: /* @__PURE__ */ B.jsx(
      K_,
      {
        nodes: x,
        edges: r,
        nodeToEdges: U,
        edgeToNodes: w,
        selectedNode: S,
        elkJSON: k,
        useInteractiveLayout: i,
        setUseInteractiveLayout: m,
        mergeEdges: a,
        setMergeEdges: n
      }
    ) }) })
  ] });
}
function V_({ length: l, onSelect: Z, selected: u }) {
  return /* @__PURE__ */ B.jsx("div", { className: `absolute top-0 left-0 p-4 z-50 backdrop-blur-sm ${l > 1 ? "" : "opacity-0"}`, children: /* @__PURE__ */ B.jsx(
    a_,
    {
      minValue: 0,
      maxValue: l - 1,
      onChange: Z,
      value: u,
      "aria-label": "Select which egraph to display from the history",
      children: /* @__PURE__ */ B.jsx("div", { className: "flex flex-1 items-end", children: /* @__PURE__ */ B.jsxs("div", { className: "flex flex-1 flex-col", children: [
        /* @__PURE__ */ B.jsx(cB, { className: "self-center", children: ({ state: s }) => /* @__PURE__ */ B.jsxs("span", { className: "text-sm", children: [
          s.getThumbValueLabel(0),
          " / ",
          l - 1
        ] }) }),
        /* @__PURE__ */ B.jsx("div", { className: "flex flex-1 items-center gap-3", children: /* @__PURE__ */ B.jsx(n_, { thumbLabels: ["volume"] }) })
      ] }) })
    }
  ) });
}
function iF({ egraphs: l, height: Z = null, resize: u = !1 }) {
  const [s, G] = M.useState(null), [i, m] = M.useState(null), [a, n] = M.useState(null), p = s ? s.clientWidth / s.clientHeight : null, [y, h] = M.useState(null), S = y && y.egraphs === l ? y.index : l.length - 1, t = M.useCallback(
    (W) => {
      h({ egraphs: l, index: W });
    },
    [h, l]
  );
  return /* @__PURE__ */ B.jsxs("div", { className: `twp w-full relative ${u ? "resize-y" : ""}`, style: { height: Z || "100%" }, ref: G, children: [
    /* @__PURE__ */ B.jsx("div", { className: "invisible absolute", children: /* @__PURE__ */ B.jsx(GF, { outerRef: m, innerRef: n }) }),
    /* @__PURE__ */ B.jsx(V_, { length: l.length, onSelect: t, selected: S }),
    i && a && p && /* @__PURE__ */ B.jsx(
      W_,
      {
        aspectRatio: p,
        firstEgraph: l[0],
        egraph: l[S],
        outerElem: i,
        innerElem: a
      }
    )
  ] });
}
function N_({ model: l, el: Z }) {
  const u = hV(Z);
  return u.render(
    /* @__PURE__ */ B.jsx(xr, { client: dF, children: /* @__PURE__ */ B.jsx(iF, { egraphs: l.get("egraphs"), height: "600px", resize: !0 }) })
  ), () => {
    u.unmount();
  };
}
function w_(l) {
  const Z = hV(l);
  function u(G) {
    Z.render(
      /* @__PURE__ */ B.jsx(xr, { client: dF, children: /* @__PURE__ */ B.jsx(iF, { egraphs: G }) })
    );
  }
  function s() {
    Z.unmount();
  }
  return { render: u, unmount: s };
}
export {
  PZ as $,
  V4 as A,
  D4 as B,
  Hh as C,
  h_ as CustomEdge,
  q9 as D,
  G1 as E,
  L_ as EClassNode,
  GF as ENode,
  tV as F,
  Ks as G,
  Ln as H,
  f4 as I,
  yd as J,
  Kf as K,
  Mf as L,
  m1 as M,
  mF as MyNodeToolbar,
  Im as N,
  Th as O,
  W1 as P,
  _9 as Q,
  tl as R,
  Uf as S,
  KV as T,
  A4 as U,
  gh as V,
  iF as Visualizer,
  I_ as W,
  oW as X,
  $9 as Y,
  H4 as Z,
  ZU as _,
  gb as a,
  Ba as a0,
  Y1 as a1,
  B as a2,
  Um as a3,
  r_ as a4,
  T4 as a5,
  C_ as a6,
  F_ as a7,
  lb as a8,
  lD as a9,
  nW as aa,
  AB as ab,
  uD as ac,
  f2 as ad,
  m6 as ae,
  U7 as af,
  hV as ag,
  xr as ah,
  dF as ai,
  $f as b,
  I1 as c,
  xK as d,
  HZ as e,
  Su as f,
  X4 as g,
  RV as h,
  ad as i,
  Sm as j,
  qI as k,
  Y4 as l,
  S4 as m,
  w_ as mount,
  Ha as n,
  Ro as o,
  xV as p,
  l1 as q,
  M as r,
  N_ as render,
  NE as s,
  t4 as t,
  M4 as u,
  L4 as v,
  U_ as w,
  TE as x,
  Sf as y,
  B4 as z
};
